00000000                            ; =========================================================================================================================================================
00000000                            ; Hedgebrew Engine (Clean, Overhauled, Enhanced S3&K Engine)
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Configuration
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Configuration.asm"	; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ASM68K Options
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		opt	l.				; Use "." for local labels
00000000                            		opt	ws+				; allow white spaces in operand parsing
00000000                            		opt	op+				; Optimize to PC relative addressing
00000000                            		opt	os+				; Optimize short branches
00000000                            		opt	ow+				; Optimize absolute long addressing
00000000                            		opt	oz+				; Optimize zero displacements
00000000                            		opt	oaq+				; Optimize to addq
00000000                            		opt	osq+				; Optimize to subq
00000000                            		opt	omq+				; Optimize to moveq
00000000                            		opt	ae-				; Disable automatic evens
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Required
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            GAME_NAME	equs	"Hedgebrew Engine Project                        "; International name
00000000                            IO_SUPPORT	equs	"J"				; I/O support
00000000 =20202020                  SRAM_SUPPORT	equ	$20202020			; SRAM support
00000000 =20202020                  SRAM_START	equ	$20202020			; SRAM start address
00000000 =20202020                  SRAM_END	equ	$20202020			; SRAM end address
00000000                            NOTES		equs	""; Notes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000001                  DEBUG_BUILD	equ	1				; Debug build flag (0 = Disabled)
00000000                            ENABLE_HANDLER	equ	0|DEBUG				; Vladikcomper's error handler enable flag (0 = Disabled)
00000000 =00000000                  ENABLE_LAGMETER	equ	0				; Lag meter enable flag (0 = Disabled)
00000000 =00000001                  DEBUG		equ	DEBUG_BUILD			; Hack
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Sound/langZ80.asm"		; Z80 Language macros
00000000                            ; MADE BY NATSUMI 2017
00000000                            
00000000                            ; DEFINE HELPERS
00000000 =00000000                  z80prg =	0		; 0 IN 68K MODE, 1 IN Z80 MODE
00000000 =00000000                  ztemp =		0		; TEMPORARY REGISTER
00000000 =00000000                  zundoc =	0		; SET TO 0 TO USE UNDOCUMENTED OPCODES
00000000 =00000001                  zchkoffs =	1		; SET TO 0 TO NOT CHECK IX/IY AND JR OFFSETS
00000000                            z80regstr	EQUS "a b c d e h l bc de hl sp af ix iy i r ixh ixl iyh iyl (bc) (de) (hl) (sp) af' (ix) (iy)"
00000000                            
00000000                            ; EASILY MAKE SECTIONS
00000000                            z80prog	macro obj
00000000                            	if narg=0
00000000                            		OBJEND
00000000                            	; magic function that fixes all the jr and djnz opcodes, along with offsets.
00000000                            	; Used for detecting illegal forward jumps
00000000                            		local lastpos
00000000                            lastpos =	*
00000000                            			local off, byte
00000000                            		rept zfuturec
00000000                            			popp off
00000000                            			popp byte
00000000                            			org zfuturepos-zfutureobj+off
00000000                            			dc.b byte
00000000                            		endr
00000000                            		org lastpos
00000000                            		POPO		; restore options
00000000                            z80prg =	0
00000000                            		MEXIT		; exit macro here
00000000                            	endif
00000000                            	PUSHO			; push options
00000000                            	OPT AE-			; automatic evens off
00000000                            	OPT AN+			; allow use of 100H instead of $100
00000000                            	OPT M-			; do not print better macro info. Comment out for large text dump.
00000000                            	OPT D-			; make sure EQU/SET do not descope local lables
00000000                            zfutureobj =	\obj
00000000                            zfuturepos =	*
00000000                            zfuturec =	0
00000000                            	if narg=1
00000000                            		OBJ \obj
00000000                            z80prg =	1
00000000                            	else
00000000                            		inform 0,"Invalid num of args!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; CREATE A LITTLE-ENDIAN Z80 ABSOLUTE ADDRESS
00000000                            z80word	macro word
00000000                            	dc.b ((\word)&$FF), ((\word)>>8&$FF)
00000000                                endm
00000000                            
00000000                            ; SAVES THE RÃˆGISTER ID TO ZTEMP
00000000                            zgetreg	macro reg, err
00000000                            	if strlen("\reg")=0
00000000                            		inform \err,"The register must not be empty!"
00000000                            		mexit
00000000                            	endif
00000000                            ztemp = instr("\z80regstr", "\reg")
00000000                            	if (ztemp<>0)&(ztemp<55)
00000000                            ztemp =		(z\reg)
00000000                            	elseif ztemp=56
00000000                            ztemp =		zbcr
00000000                            	elseif ztemp=61
00000000                            ztemp =		zder
00000000                            	elseif ztemp=66
00000000                            ztemp =		zhlr
00000000                            	elseif ztemp=71
00000000                            ztemp =		zspr
00000000                            	elseif ztemp=76
00000000                            ztemp =		zaf2
00000000                            	elseif ztemp=79
00000000                            ztemp =		zixr
00000000                            	elseif ztemp=85
00000000                            ztemp =		ziyr
00000000                            	else
00000000                            		if instr("\reg", "(ix+")<>0|instr("\reg", "(ix-")<>0
00000000                            ztemp =		zixp
00000000                            		elseif instr("\reg", "(iy+")<>0|instr("\reg", "(iy-")<>0
00000000                            ztemp =		ziyp
00000000                            		else
00000000                            ztemp =			-1
00000000                            			local a, cc, p
00000000                            a =			0
00000000                            p =			1
00000000                            d =			0
00000000                            			while a=0
00000000                            				if p>strlen("\reg")
00000000                            ztemp =					-2
00000000                            a =					1
00000000                            				else
00000000                            cc					substr p,p,"\reg"
00000000                            					if '\cc'='('
00000000                            d =						d+1
00000000                            					elseif '\cc'=')'
00000000                            d =						d-1
00000000                            					elseif ('\cc'<>' ')&('\cc'<>'	')
00000000                            						if d<1
00000000                            a =							1
00000000                            						endif
00000000                            					endif
00000000                            				endif
00000000                            p =				p+1
00000000                            			endw
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; PLACES THE SIGNED OFFSET INTO ROM, AND QUEUES A CHECK
00000000                            zindoff	macro reg, byte
00000000                            	local off
00000000                            off	substr 4, strlen("\reg")-1, "\reg"
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zjrfuture macro off, byte
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; QUEUES SIGNED VALUES TO BE FIXED
00000000                            zfuture	macro byte
00000000                            zfuturec =	zfuturec+1
00000000                            		local p,v
00000000                            p =		*-2
00000000                            v =		\byte
00000000                            		pushp "\#v"
00000000                            		pushp "\#p"
00000000                                endm
00000000                            
00000000                            ; Define equates for registers
00000000 =00000000                  zb = 	0
00000000 =00000001                  zc =	1
00000000 =00000002                  zd =	2
00000000 =00000003                  ze =	3
00000000 =00000004                  zh =	4
00000000 =00000005                  zl =	5
00000000 =00000007                  za =	7
00000000 =00000008                  zbc =	8
00000000 =00000009                  zde =	9
00000000 =0000000A                  zhl =	$A
00000000 =0000000B                  zsp =	$B
00000000 =00000018                  zbcr =	$18
00000000 =00000019                  zder =	$19
00000000 =0000001A                  zhlr =	$1A
00000000 =0000001B                  zspr =	$1B
00000000 =00000020                  zix =	$20
00000000 =00000021                  ziy =	$21
00000000 =00000022                  zixr =	$22
00000000 =00000023                  ziyr =	$23
00000000 =00000024                  zixp =	$24
00000000 =00000025                  ziyp =	$25
00000000 =00000028                  zixh =	$28
00000000 =00000029                  zixl =	$29
00000000 =0000002A                  ziyh =	$2A
00000000 =0000002B                  ziyl =	$2B
00000000 =00000030                  zaf =	$30
00000000 =00000031                  zaf2 =	$31
00000000 =00000038                  zi =	$38
00000000 =00000039                  zr =	$39
00000000                            
00000000                            
00000000                            ; Define instructions
00000000                            
00000000                            db	macro val
00000000                            	dc.b \_
00000000                                endm
00000000                            
00000000                            dsb	macro num, val
00000000                            	dcb.b \_
00000000                                endm
00000000                            
00000000                            dw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            dsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            rlc	macro reg, reg2
00000000                            	zgetreg \reg, 0
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $00+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $00+ztemp		; rlc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $06			; rlc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rlc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rlc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rrc	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $08+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $08+ztemp		; rrc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $0E			; rrc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rrc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rrc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $10+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $10+ztemp		; rl a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $16			; rl (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rl (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rl (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rr	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $18+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $18+ztemp		; rr a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $1E			; rr (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rr (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rr (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sla	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $20+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $20+ztemp		; sla a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $26			; sla (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sla (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sla (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sra	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $28+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $28+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $2E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sll	macro reg
00000000                            	if zundoc
00000000                            		inform 2,"Undocumented opcodes are not enabled."
00000000                            	endif
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $30+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $30+ztemp		; sll a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $36			; sll (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sll (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sll (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            srl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $38+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $38+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $3E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            bit	macro bit, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $40+ztemp+(\bit*$08)	; bit 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $46+(\bit*$08)	; bit 0-7,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; bit 0-7,(ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; bit 0-7,(iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            res	macro bit, reg, reg2
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $80+ztemp+(\bit*$08)	; res 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $86+(\bit*$08)	; res 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; res 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $80+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zset	macro bit, reg
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $C0+ztemp+(\bit*$08)	; set 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $C6+(\bit*$08)	; set 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; set 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $C0+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            im	macro im
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if "\im"="0/1"
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $ED, $4E		; im 0/1
00000000                            	elseif (\im<0)|(\im>2)
00000000                            		inform 2,"Interrupt mode must only be 0, 1 or 2!"
00000000                            	elseif \im=2
00000000                            		dc.b $ED, $5E		; im 2
00000000                            	else
00000000                            		dc.b $ED, $46+(\im*$10); im 0 or 1
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rst	macro addr
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if type(\addr)&1
00000000                            		if (\addr&7)=0
00000000                            			if \addr>$48|\addr<0
00000000                            				inform 2,"Invalid address! Must be at least 0 and at most $38!"
00000000                            			endif
00000000                            		else
00000000                            			inform 2,"Address must be aligned by $8!"
00000000                            		endif
00000000                            	endif
00000000                            		dc.b $C7+\addr	; RST *
00000000                                endm
00000000                            
00000000                            inc	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $04+(ztemp*$08)		; inc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $34			; inc (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $03+((ztemp-zbc)*$10)	; inc bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $23			; inc ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $23			; inc iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; inc ix+
00000000                            		zindoff \reg, $34
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; inc iy+
00000000                            		zindoff \reg, $34
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $24+((ztemp&$01)*$08); inc ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            dec	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $05+(ztemp*$08)		; dec a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $35			; dec (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $0B+((ztemp-zbc)*$10)	; dec bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $2B			; dec ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $2B			; dec iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; dec ix+
00000000                            		zindoff \reg, $35
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; dec iy+
00000000                            		zindoff \reg, $35
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $25+((ztemp&$01)*$08); dec ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zsub	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $D6			; sub a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $90+ztemp			; sub a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $96			; sub a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sub a,(ix+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sub a,(iy+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $94+(ztemp&$01); sub a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zand	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $E6			; and a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A0+ztemp			; and a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $A6			; and a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; and a,(ix+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; and a,(iy+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $A4+(ztemp&$01); and a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $F6			; or a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B0+ztemp			; or a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; or a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; or a,(ix+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; or a,(iy+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $B4+(ztemp&$01); or a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            xor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $EE			; xor a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A8+ztemp			; xor a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; xor a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; xor a,(ix+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; xor a,(iy+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $AC+(ztemp&$01); xor a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            cp	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $FE			; cp a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B8+ztemp			; cp a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $BE			; cp a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; cp a,(ix+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; cp a,(iy+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $BC+(ztemp&$01); cp a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zadd	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; add a,(ix+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; add a,(iy+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $86		; add a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $C6		; add a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $80+ztemp		; add a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $84+(ztemp&$01); add a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $09+((ztemp-zbc)*$10)	; add hl,bc, de, hl or sp
00000000                            	elseif ztemp1=zix
00000000                            		dc.b $DD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add ix,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add ix,de
00000000                            		elseif ztemp=zix
00000000                            			dc.b $29		; add ix,ix
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add ix,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: ix, \reg2!"
00000000                            		endif
00000000                            	elseif ztemp1=ziy
00000000                            		dc.b $FD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add iy,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add iy,de
00000000                            		elseif ztemp=ziy
00000000                            			dc.b $29		; add iy,iy
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add iy,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: iy, \reg2!"
00000000                            		endif
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            adc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; adc a,(ix+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; adc a,(iy+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $8E		; adc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $CE		; adc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $88+ztemp		; adc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $8C+(ztemp&$01); adc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $4A+((ztemp-zbc)*$10)	; adc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sbc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; sbc a,(ix+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; sbc a,(iy+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $9E		; sbc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DE		; sbc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $98+ztemp		; sbc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $9C+(ztemp&$01); sbc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $42+((ztemp-zbc)*$10)	; sbc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpop	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C1+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F1		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E1		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E1		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpush	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C5+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F5		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E5		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E5		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ex	macro reg1, reg2
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            	if ((zreg1=zaf)|(zreg1=zaf2))&((ztemp=zaf)|(ztemp=zaf2))
00000000                            		dc.b $08			; ex af,af' & ex af',af & ex af,af
00000000                            	elseif ((zreg1=zde)|(zreg1=zhl))&((ztemp=zde)|(ztemp=zhl))
00000000                            		dc.b $EB			; ex de,hl & ex hl,de
00000000                            	elseif ((zreg1=zspr)|(zreg1=zhl))&((ztemp=zspr)|(ztemp=zhl))
00000000                            		dc.b $E3			; ex (sp),hl & ex hl,(sp)
00000000                            	elseif ((zreg1=zix)|(zreg1=zspr))&((ztemp=zix)|(ztemp=zspr))
00000000                            		dc.b $DD,$E3			; ex (sp),ix & ex ix,(sp)
00000000                            	elseif ((zreg1=ziy)|(zreg1=zspr))&((ztemp=ziy)|(ztemp=zspr))
00000000                            		dc.b $FD,$E3			; ex (sp),iy & ex iy,(sp)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            out	macro port, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if (ztemp=-1)&(instr("\port", "0")<>0)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $71		; out (c),0
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $41+(ztemp*$08)		; out (c),a, b, c, d, e, h or l
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; out (*),a
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            in	macro reg, port
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if narg=1
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $70		; in (c)
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $40+(ztemp*$08)		; in a, b, c, d, e, h or l,(c)
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; in a,(*)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ld	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            zreg2 =	ztemp
00000000                            	if zreg1=-2
00000000                            		if zreg2=za
00000000                            			dc.b $32			; ld (**),a
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zhl
00000000                            			dc.b $22			; ld (**),hl
00000000                            			z80word \reg1
00000000                            		elseif (zreg2>=zbc)&(zreg2<=zsp)
00000000                            			dc.b $ED, $43+((zreg2-zbc)*$10)	; ld (**),bc, de, sp
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zix
00000000                            			dc.b $DD, $22			; ld (**),ix
00000000                            			z80word \reg1
00000000                            		elseif zreg2=ziy
00000000                            			dc.b $FD, $22			; ld (**),iy
00000000                            			z80word \reg1
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-1
00000000                            		if (zreg1<=za)
00000000                            			dc.b $06+(zreg1*$08), \reg2	; ld a, b, c, d, e, h or l,*
00000000                            		elseif zreg1=zhlr
00000000                            			dc.b $36, \reg2			; ld (hl),*
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $01+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $21			; ld ix,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $21			; ld iy,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zixp
00000000                            			dc.b $DD			; ld (ix+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif zreg1=ziyp
00000000                            			dc.b $FD			; ld (iy+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif (zreg1>=zixh)&(zreg1<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((zreg1&$02)*$10), $26+((zreg1&$01)*$08), \reg2; ld ixh, ixl, iyh, iyl,*
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-2
00000000                            		if (zreg1=za)
00000000                            			dc.b $3A			; ld a,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zhl
00000000                            			dc.b $2A			; ld hl,(**)
00000000                            			z80word \reg2
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $ED, $4B+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $2A			; ld ix,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $2A			; ld iy,(**)
00000000                            			z80word \reg2
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif (zreg1<=za)&(zreg2<=za)
00000000                            		dc.b $40+(zreg1*$08)+zreg2		; ld a, b, c, d, e, h or l,a, b, c, d, e, h or l
00000000                            	elseif (zreg1=za)&(zreg2=zbcr)
00000000                            		dc.b $0A				; ld a,(bc)
00000000                            	elseif (zreg1=za)&(zreg2=zder)
00000000                            		dc.b $1A				; ld a,(de)
00000000                            	elseif (zreg1<=za)&(zreg2=zhlr)
00000000                            		dc.b $46+(zreg1*$08)			; ld a, b, c, d, e, h or l,(hl)
00000000                            	elseif (zreg1=zhlr)&(zreg2<=za)
00000000                            		dc.b $70+zreg2				; ld (hl),a, b, c, d, e, h or l
00000000                            	elseif (zreg1<=za)&(zreg2=zixp)
00000000                            		dc.b $DD				; ld a, b, c, d, e, h or l,(ix+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg1<=za)&(zreg2=ziyp)
00000000                            		dc.b $FD				; ld a, b, c, d, e, h or l,(iy+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg2<=za)&(zreg1=zixp)
00000000                            		dc.b $DD				; ld (ix+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg2<=za)&(zreg1=ziyp)
00000000                            		dc.b $FD				; ld (iy+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg1=zbcr)&(zreg2=za)
00000000                            		dc.b $02				; ld (bc),a
00000000                            	elseif (zreg1=zder)&(zreg2=za)
00000000                            		dc.b $12				; ld (de),a
00000000                            	elseif (zreg1=zsp)&(zreg2=zhl)
00000000                            		dc.b $F9				; ld sp,hl
00000000                            	elseif (zreg1=zi)&(zreg2=za)
00000000                            		dc.b $ED, $47				; ld i,a
00000000                            	elseif (zreg2=zi)&(zreg1=za)
00000000                            		dc.b $ED, $57				; ld a,i
00000000                            	elseif (zreg1=zr)&(zreg2=za)
00000000                            		dc.b $ED, $4F				; ld r,a
00000000                            	elseif (zreg2=zr)&(zreg1=za)
00000000                            		dc.b $ED, $5F				; ld a,r
00000000                            	elseif (zreg1=zsp)&(zreg2=zix)
00000000                            		dc.b $DD, $F9				; ld sp, ix
00000000                            	elseif (zreg1=zsp)&(zreg2=ziy)
00000000                            		dc.b $FD, $F9				; ld sp, iy
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&((zreg2<=za)&(zreg2<>zh)&(zreg2<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+zreg2; ld ixh, ixl, iyh, iyl,a, b, c, d, e
00000000                            	elseif (zreg2>=zixh)&(zreg2<=ziyl)&((zreg1<=za)&(zreg1<>zh)&(zreg1<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg2&$02)*$10), $44+(zreg2&$01)+(zreg1*$08); ld a, b, c, d, e,ixh, ixl, iyh, iyl
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&(zreg2>=zixh)&(zreg2>=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if ((zreg1&$02)<>(zreg2&$02))
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            			mexit
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+(zreg2&$01); ld ixh, ixl, iyh, iyl,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            djnz	macro addr
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \addr-*-2, $10
00000000                                endm
00000000                            
00000000                            jr	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zjrfuture \cond-*-2, $18
00000000                            	else
00000000                            		jr\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jrnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $20
00000000                                endm
00000000                            
00000000                            jrnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $30
00000000                                endm
00000000                            
00000000                            jrz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $28
00000000                                endm
00000000                            
00000000                            jrc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $38
00000000                                endm
00000000                            
00000000                            jp	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zgetreg \cond, 0
00000000                            		if ztemp=zhlr
00000000                            			dc.b $E9		; jp (hl)
00000000                            		elseif ztemp=zixr
00000000                            			dc.b $DD, $E9		; jp (ix)
00000000                            		elseif ztemp=ziyr
00000000                            			dc.b $FD, $E9		; jp (iy)
00000000                            		else
00000000                            			dc.b $C3		; jp **
00000000                            			z80word \cond
00000000                            		endif
00000000                            	else
00000000                            		jp\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jpnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpc	macro off
00000000                            	dc.b $DA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            call	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		dc.b $CD
00000000                            		z80word \cond
00000000                            	else
00000000                            		call\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            callnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $DC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            ret	macro cond
00000000                            	if narg=0
00000000                            		dc.b $C9
00000000                            	else
00000000                            		ret\cond
00000000                            	endif
00000000                                endm
00000000                            
00000000                            retnz	macro
00000000                            	dc.b $C0
00000000                                endm
00000000                            
00000000                            retz	macro
00000000                            	dc.b $C8
00000000                                endm
00000000                            
00000000                            retnc	macro
00000000                            	dc.b $D0
00000000                                endm
00000000                            
00000000                            retc	macro
00000000                            	dc.b $D8
00000000                                endm
00000000                            
00000000                            retpo	macro
00000000                            	dc.b $E0
00000000                                endm
00000000                            
00000000                            retpe	macro
00000000                            	dc.b $E8
00000000                                endm
00000000                            
00000000                            retp	macro
00000000                            	dc.b $F0
00000000                                endm
00000000                            
00000000                            retm	macro
00000000                            	dc.b $F8
00000000                                endm
00000000                            
00000000                            di	macro
00000000                            	if z80prg=0
00000000                            		move	#$2700,sr	; THIS IS HERE, IF YOU WANNA USE DI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $F3
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ei	macro
00000000                            	if z80prg=0
00000000                            		move	#$2300,sr	; THIS IS HERE, IF YOU WANNA USE EI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $FB
00000000                            	endif
00000000                                endm
00000000                            
00000000                            halt	macro
00000000                            	if z80prg=0
00000000                            		stop	#$2700		; THIS IS HERE, IF YOU WANNA USE HALT IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $76
00000000                            	endif
00000000                                endm
00000000                            
00000000                            znop	macro
00000000                            	dc.b $00
00000000                                endm
00000000                            
00000000                            rlca	macro
00000000                            	dc.b $07
00000000                                endm
00000000                            
00000000                            rla	macro
00000000                            	dc.b $17
00000000                                endm
00000000                            
00000000                            daa	macro
00000000                            	dc.b $27
00000000                                endm
00000000                            
00000000                            scf	macro
00000000                            	dc.b $37
00000000                                endm
00000000                            
00000000                            rrca	macro
00000000                            	dc.b $0F
00000000                                endm
00000000                            
00000000                            rra	macro
00000000                            	dc.b $1F
00000000                                endm
00000000                            
00000000                            cpl	macro
00000000                            	dc.b $2F
00000000                                endm
00000000                            
00000000                            ccf	macro
00000000                            	dc.b $3F
00000000                                endm
00000000                            
00000000                            exx	macro
00000000                            	dc.b $D9
00000000                                endm
00000000                            
00000000                            zneg	macro
00000000                            	dc.b $ED, $44
00000000                                endm
00000000                            
00000000                            retn	macro
00000000                            	dc.b $ED, $45
00000000                                endm
00000000                            
00000000                            reti	macro
00000000                            	dc.b $ED, $4D
00000000                                endm
00000000                            
00000000                            rrd	macro
00000000                            	dc.b $ED, $67
00000000                                endm
00000000                            
00000000                            rld	macro
00000000                            	dc.b $ED, $6F
00000000                                endm
00000000                            
00000000                            ldi	macro
00000000                            	dc.b $ED, $A0
00000000                                endm
00000000                            
00000000                            cpi	macro
00000000                            	dc.b $ED, $A1
00000000                                endm
00000000                            
00000000                            ini	macro
00000000                            	dc.b $ED, $A2
00000000                                endm
00000000                            
00000000                            outi	macro
00000000                            	dc.b $ED, $A3
00000000                                endm
00000000                            
00000000                            ldd	macro
00000000                            	dc.b $ED, $A8
00000000                                endm
00000000                            
00000000                            cpd	macro
00000000                            	dc.b $ED, $A9
00000000                                endm
00000000                            
00000000                            ind	macro
00000000                            	dc.b $ED, $AA
00000000                                endm
00000000                            
00000000                            outd	macro
00000000                            	dc.b $ED, $AB
00000000                                endm
00000000                            
00000000                            ldir	macro
00000000                            	dc.b $ED, $B0
00000000                                endm
00000000                            
00000000                            cpir	macro
00000000                            	dc.b $ED, $B1
00000000                                endm
00000000                            
00000000                            inir	macro
00000000                            	dc.b $ED, $B2
00000000                                endm
00000000                            
00000000                            otir	macro
00000000                            	dc.b $ED, $B3
00000000                                endm
00000000                            
00000000                            lddr	macro
00000000                            	dc.b $ED, $B8
00000000                                endm
00000000                            
00000000                            cpdr	macro
00000000                            	dc.b $ED, $B9
00000000                                endm
00000000                            
00000000                            indr	macro
00000000                            	dc.b $ED, $BA
00000000                                endm
00000000                            
00000000                            otdr	macro
00000000                            	dc.b $ED, $BB
00000000                                endm
00000000                            		include	"Sound/amps/code/macro.asm"	; AMPS macros
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Various assembly flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            	opt ae+
00000000                            
00000000                            ; if safe mode is enabled (1), then the driver will attempt to find any issues.
00000000                            ; if Vladik's error debugger is installed, then the error will be displayed.
00000000                            ; else, the CPU is trapped.
00000000                            
00000000 =00000001                  safe =	DEBUG
00000000                            
00000000                            ; Select the tempo algorith.
00000000                            ; 0 = Overflow method.
00000000                            ; 1 = Counter method.
00000000                            
00000000 =00000000                  tempo =	0
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Channel configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cFlags		rs.b 1		; various channel flags, see below
00000000 =00000001                  cType		rs.b 1		; hardware type for the channel
00000000 =00000002                  cData		rs.l 1		; 68k tracker address for the channel
00000000 =00000006                  cPanning	rs.b 0		; channel panning and LFO. FM and DAC only
00000000 =00000006                  cEnvPos		rs.b 1		; volume envelope position. PSG only
00000000 =00000007                  cDetune		rs.b 1		; frequency detune (offset)
00000000 =00000008                  cPitch		rs.b 1		; pitch (transposition) offset
00000000 =00000009                  cVolume		rs.b 1		; channel volume
00000000 =0000000A                  cTick		rs.b 1		; channel tick multiplier
00000000 =0000000B                  cSample		rs.b 0		; channel sample ID, DAC only
00000000 =0000000B                  cVolEnv		rs.b 0		; volume envelope ID. PSG only
00000000 =0000000B                  cVoice		rs.b 1		; YM2612 voice ID. FM only
00000000 =0000000C                  cDuration	rs.b 1		; current note duration
00000000 =0000000D                  cLastDur	rs.b 1		; last note duration
00000000 =0000000E                  cFreq		rs.w 1		; channel base frequency
00000000 =00000010                  cModDelay	rs.b 0		; delay before modulation starts
00000000 =00000010                  cMod		rs.l 1		; modulation data address
00000000 =00000014                  cModFreq	rs.w 1		; modulation frequency offset
00000000 =00000016                  cModSpeed	rs.b 1		; number of frames til next modulation step
00000000 =00000017                  cModStep	rs.b 1		; modulation frequency offset per step
00000000 =00000018                  cModCount	rs.b 1		; number of modulation steps until reversal
00000000 =00000019                  cLoop		rs.b 3		; loop counter values
00000000 =0000001B                  cStatPSG4 =	__rs-1		; PSG4 type value. PSG3 only
00000000 =0000001A                  cPrio =		__rs-2		; sound effect channel priority. SFX only
00000000 =0000001C                  cSizeSFX	rs.w 0		; size of each SFX track
00000000                            
00000000 =0000001C                  cNoteTimeCur	rs.b 1		; frame counter to note off. Music only
00000000 =0000001D                  cNoteTimeMain	rs.b 1		; copy of frame counter to note off. Music only
00000000 =0000001E                  cStack		rs.b 1		; channel stack pointer. Music only
00000000                            		rs.b 1		; unused. Music only
00000000                            		rs.l 3		; channel stack data. Music only
00000000 =0000002C                  cSize		rs.w 0		; size of each music track
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for cFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cfbMode		rs.b 0		; set if in pitch mode, clear if in sample mode. DAC only
00000000 =00000000                  cfbRest		rs.b 1		; set if channel is resting. FM and PSG only
00000000 =00000001                  cfbInt		rs.b 1		; set if interrupted by SFX. Music only
00000000 =00000002                  cfbHold		rs.b 1		; set if playing notes does not trigger note-on's
00000000 =00000003                  cfbMod		rs.b 1		; set if modulation is enabled
00000000 =00000004                  cfbCond		rs.b 1		; set if ignoring many tracker commands
00000000 =00000005                  cfbVol		rs.b 1		; set if channel should update volume
00000000 =00000007                  cfbRun =	$07		; set if channel is running a tracker
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc variables for channel modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  ctbPt2 =	$02		; bit part 2 - FM 4-6
00000000 =00000000                  ctFM1 =		$00		; FM 1
00000000 =00000001                  ctFM2 =		$01		; FM 2
00000000 =00000002                  ctFM3 =		$02		; FM 3	- Valid for SFX
00000000 =00000004                  ctFM4 =		$04		; FM 4	- Valid for SFX
00000000 =00000005                  ctFM5 =		$05		; FM 5	- Valid for SFX
00000000                            
00000000 =00000003                  ctbDAC =	$03		; DAC bit
00000000 =0000000B                  ctDAC1 =	(1<<ctbDAC)|$03	; DAC 1	- Valid for SFX
00000000 =0000000E                  ctDAC2 =	(1<<ctbDAC)|$06	; DAC 2
00000000                            
00000000 =00000080                  ctPSG1 =	$80		; PSG 1	- Valid for SFX
00000000 =000000A0                  ctPSG2 =	$A0		; PSG 2	- Valid for SFX
00000000 =000000C0                  ctPSG3 =	$C0		; PSG 3	- Valid for SFX
00000000 =000000E0                  ctPSG4 =	$E0		; PSG 4
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  Mus_DAC =	2		; number of DAC channels
00000000 =00000005                  Mus_FM =	5		; number of FM channels
00000000 =00000003                  Mus_PSG =	3		; number of PSG channels
00000000 =0000000A                  Mus_Ch =	Mus_DAC+Mus_FM+Mus_PSG; total number of music channels
00000000 =00000001                  SFX_DAC =	1		; number of DAC SFX channels
00000000 =00000003                  SFX_FM =	3		; number of FM SFX channels
00000000 =00000003                  SFX_PSG =	3		; number of PSG SFX channels
00000000 =00000007                  SFX_Ch =	SFX_DAC+SFX_FM+SFX_PSG; total number of SFX channels
00000000                            
00000000 =0000001D                  VoiceRegs =	29		; total number of registers inside of a voice
00000000 =00000019                  VoiceTL =	VoiceRegs-4	; location of voice TL levels
00000000                            
00000000 =00001000                  MaxPitch =	$1000		; this is the maximum pitch Dual PCM is capable of processing
00000000 =00000018                  Z80E_Read =	$00018		; this is used by Dual PCM internally but we need this for macros
00000000                            
00000000                            ; NOTE: There is no magic trick to making Dual PCM play samples at higher rates.
00000000                            ; These values are only here to allow you to give lower pitch samples higher
00000000                            ; quality, and playing samples at higher rates than Dual PCM can process them
00000000                            ; may decrease the perceived quality by the end user. Use these equates only
00000000                            ; if you know what you are doing.
00000000                            
00000000 =00000140                  sr17 =		$0140		; 5 Quarter sample rate	17500 Hz
00000000 =00000120                  sr15 =		$0120		; 9 Eights sample rate	15750 Hz
00000000 =00000100                  sr14 =		$0100		; Default sample rate	14000 Hz
00000000 =000000E0                  sr12 =		$00E0		; 7 Eights sample rate	12250 Hz
00000000 =000000C0                  sr10 =		$00C0		; 3 Quarter sample rate	10500 Hz
00000000 =000000A0                  sr8 =		$00A0		; 5 Eights sample rate	8750 Hz
00000000 =00000080                  sr7 =		$0080		; Half sample rate	7000 HZ
00000000 =00000060                  sr5 =		$0060		; 3 Eights sample rate	5250 Hz
00000000 =00000040                  sr3 =		$0040		; 1 Quarter sample rate	3500 Hz
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound driver RAM configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00A00000                  dZ80 =		$A00000		; quick reference to Z80 RAM
00000000 =00C00011                  dPSG =		$C00011		; quick reference to PSG port
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for mFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  mfbRing		rs.b 1		; if set, change speaker (play different sfx)
00000000 =00000001                  mfbSpeed	rs.b 1		; if set, speed shoes are active
00000000 =00000002                  mfbWater	rs.b 1		; if set, underwater mode is active
00000000 =00000003                  mfbNoPAL	rs.b 1		; if set, play songs slowly in PAL region
00000000 =00000007                  mfbPaused =	$07		; if set, sound driver is paused
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound ID equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 1
00000000 =00000001                  Mus_Reset	rs.b 1		; reset underwater and speed shoes flags, update volume
00000000 =00000002                  Mus_FadeOut	rs.b 1		; initialize a music fade out
00000000 =00000003                  Mus_Stop	rs.b 1		; stop all music
00000000 =00000004                  Mus_ShoesOn	rs.b 1		; enable speed shoes mode
00000000 =00000005                  Mus_ShoesOff	rs.b 1		; disable speed shoes mode
00000000 =00000006                  Mus_ToWater	rs.b 1		; enable underwater mode
00000000 =00000007                  Mus_OutWater	rs.b 1		; disable underwater mode
00000000 =00000008                  Mus_Pause	rs.b 1		; pause the music
00000000 =00000009                  Mus_Unpause	rs.b 1		; unpause the music
00000000 =0000000A                  MusOff		rs.b 0		; first music ID
00000000                            
00000000 =00000078                  MusCount =	$78		; number of installed music tracks
00000000 =00000082                  SFXoff =	MusCount+MusOff	; first SFX ID
00000000 =00000078                  SFXcount =	$78		; number of intalled sound effects
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Condition modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  dcoT		rs.b 1		; condition T	; True
00000000 =00000001                  dcoF		rs.b 1		; condition F	; False
00000000 =00000002                  dcoHI		rs.b 1		; condition HI	; HIgher (unsigned)
00000000 =00000003                  dcoLS		rs.b 1		; condition LS	; Less or Same (unsigned)
00000000 =00000004                  dcoHS		rs.b 0		; condition HS	; Higher or Sane (unsigned)
00000000 =00000004                  dcoCC		rs.b 1		; condition CC	; Carry Clear (unsigned)
00000000 =00000005                  dcoLO		rs.b 0		; condition LO	; LOwer (unsigned)
00000000 =00000005                  dcoCS		rs.b 1		; condition CS	; Carry Set (unsigned)
00000000 =00000006                  dcoNE		rs.b 1		; condition NE	; Not Equal
00000000 =00000007                  dcoEQ		rs.b 1		; condition EQ	; EQual
00000000 =00000008                  dcoVC		rs.b 1		; condition VC	; oVerflow Clear (signed)
00000000 =00000009                  dcoVS		rs.b 1		; condition VS	; oVerflow Set (signed)
00000000 =0000000A                  dcoPL		rs.b 1		; condition PL	; Positive (PLus)
00000000 =0000000B                  dcoMI		rs.b 1		; condition MI	; Negamite (MInus)
00000000 =0000000C                  dcoGE		rs.b 1		; condition GE	; Greater or Equal (signed)
00000000 =0000000D                  dcoLT		rs.b 1		; condition LT	; Less Than (signed)
00000000 =0000000E                  dcoGT		rs.b 1		; condition GT	; GreaTer (signed)
00000000 =0000000F                  dcoLE		rs.b 1		; condition LE	; Less or Equal (signed)
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Emvelope commands equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  eReset		rs.w 1		; 80 - Restart from position 0
00000000 =00000082                  eHold		rs.w 1		; 82 - Hold volume at current level
00000000 =00000084                  eLoop		rs.w 1		; 84 - Jump back/forwards according to next byte
00000000 =00000086                  eStop		rs.w 1		; 86 - Stop current note and envelope
00000000 =00000088                  eLast		rs.w 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Fade out end commands
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  fEnd		rs.l 1		; 80 - Do nothing
00000000 =00000084                  fStop		rs.l 1		; 84 - Stop all music
00000000 =00000088                  fResVol		rs.l 1		; 88 - Reset volume and update
00000000 =0000008C                  fReset		rs.l 1		; 8C - Stop music playing and reset volume
00000000 =00000090                  fLast		rs.l 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Quickly read a word from odd address. 28 cycles
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dREAD_WORD	macro areg, dreg
00000000                            	move.b	(\areg)+,(sp)		; read the next byte into stack
00000000                            	move.w	(sp),\dreg		; get word back from stack (shift byte by 8 bits)
00000000                            	move.b	(\areg),\dreg		; get the next byte into register
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; used to calculate the address of the right FM voice
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dCALC_VOICE	macro off
00000000                            	lsl.w	#5,d0			; multiply voice ID by $20
00000000                            	if narg>0
00000000                            		add.w	#\off,d0	; if have had extra argument, add it to offset
00000000                            	endif
00000000                            	add.w	d0,a1			; add offset to voice table address
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to stop, and waits for it to finish stopping (acquire bus)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;stopZ80 	macro
00000000                            ;	move.w	#$100,$A11100		; stop the Z80
00000000                            ;.loop\@
00000000                            ;	btst	#0,$A11100
00000000                            ;	bne.s	.loop\@			; loop until it says it's stopped
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to start again
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;startZ80 	macro
00000000                            ;	move.w	#0,$A11100		; start the Z80
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for pausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSPAUSE	macro	; enable request pause and paused flags
00000000                            	move.b	#Mus_Pause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for unpausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSUNPAUSE	macro	; enable request unpause flag
00000000                            	move.b	#Mus_Unpause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for queueing sound
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            playSnd	macro id, queue	; queue sound
00000000                            	move.b	\id,(mQueue+((\queue\)-1)).w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create volume envelope table, and SMPS2ASM equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            volenv		macro name
00000000                            	rept narg			; repeate for all arguments
00000000                            v\name =	__venv			; create SMPS2ASM equate
00000000                            		dc.l vd\name		; create pointer
00000000                            __venv =	__venv+1		; increase ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates SFX pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrSFX		macro type, name
00000000                            .type =		\type<<24		; create equate for the type mask
00000000                            	rept narg-1			; repeat for all arguments
00000000                            		dc.l \name\|.type	; create pointer with specified type
00000000                            __sfx =		__sfx+1			; increase SFX ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates music pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrMusic	macro name, sptempo
00000000                            	rept narg/2			; repeat for half of the arguments
00000000                            		dc.l ((\sptempo)<<24)|\name\; create pointer with tempo
00000000                            __mus =		__mus+1			; increase music ID
00000000                            	shift				; shift next argument into view
00000000                            	shift				; ''
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Include PCM data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            incSWF		macro name, file
00000000                            SWF_\name\	incbin	\file		; include PCM data
00000000                            SWFR_\name\ 	dcb.b Z80E_Read*(MaxPitch/$100),$00; add end markers (for Dual PCM)
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create data for a sample
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            sample		macro freq, start, loop, name
00000000                            	if narg=4		; if we have 4 arguments, we'd like a custom name
00000000                            d\name =	__samp		; use the extra argument to create SMPS2ASM equate
00000000                            	else
00000000                            d\start =	__samp		; else, use the first one!
00000000                            	endif
00000000                            __samp =	__samp+1	; increase sample ID
00000000                            ; create offsets for the sample normal, reverse, loop normal, loop reverse.
00000000                            	dc.b SWF_\start&$FF,((SWF_\start>>$08)&$7F)|$80,(SWF_\start>>$0F)&$FF
00000000                            	dc.b (SWFR_\start-1)&$FF,(((SWFR_\start-1)>>$08)&$7F)|$80,((SWFR_\start-1)>>$0F)&$FF
00000000                            	dc.b SWF_\loop&$FF,((SWF_\loop>>$08)&$7F)|$80, (SWF_\loop>>$0F)&$FF
00000000                            	dc.b (SWFR_\loop-1)&$FF,(((SWFR_\loop-1)>>$08)&$7F)|$80,((SWFR_\loop-1)>>$0F)&$FF
00000000                            	dc.w \freq-$100		; sample frequency (actually offset, so we remove $100)
00000000                            	dc.w 0			; unused!
00000000                                endm
00000000                            ; ===========================================================================
00000000                            	opt ae-
00000000                            		include	"Sound/amps/code/smps2asm.asm"	; AMPS SMPS2ASM
00000000                            ; ===============================================
00000000                            ; Based on Flamewing's SMPS2ASM, and S1SMPS2ASM by Marc (AKA Cinossu)
00000000                            ; Reworked and improved by Natsumi
00000000                            ; ===============================================
00000000                            ; this macro is created to emulate enum in AS
00000000                            enum	macro	num, lable
00000000                            ; copy initial number for referencing later
00000000                            .num	= num
00000000                            	rept narg-1
00000000                            \lable		set .num
00000000                            .num =	.num+1
00000000                            	shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Note Equates
00000000                            	enum $80+0, nRst
00000000 =00000080                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000080                M nrst	set	.num
00000000 =00000081                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nRst+1,nC0,nCs0,nD0,nEb0,nE0,nF0,nFs0,nG0,nAb0,nA0,nBb0,nB0
00000000 =00000081                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000081                M nc0	set	.num
00000000 =00000082                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000082                M ncs0	set	.num
00000000 =00000083                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000083                M nd0	set	.num
00000000 =00000084                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000084                M neb0	set	.num
00000000 =00000085                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000085                M ne0	set	.num
00000000 =00000086                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000086                M nf0	set	.num
00000000 =00000087                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000087                M nfs0	set	.num
00000000 =00000088                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000088                M ng0	set	.num
00000000 =00000089                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000089                M nab0	set	.num
00000000 =0000008A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008A                M na0	set	.num
00000000 =0000008B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008B                M nbb0	set	.num
00000000 =0000008C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008C                M nb0	set	.num
00000000 =0000008D                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB0+1, nC1,nCs1,nD1,nEb1,nE1,nF1,nFs1,nG1,nAb1,nA1,nBb1,nB1
00000000 =0000008D                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =0000008D                M nc1	set	.num
00000000 =0000008E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008E                M ncs1	set	.num
00000000 =0000008F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008F                M nd1	set	.num
00000000 =00000090                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000090                M neb1	set	.num
00000000 =00000091                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000091                M ne1	set	.num
00000000 =00000092                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000092                M nf1	set	.num
00000000 =00000093                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000093                M nfs1	set	.num
00000000 =00000094                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000094                M ng1	set	.num
00000000 =00000095                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000095                M nab1	set	.num
00000000 =00000096                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000096                M na1	set	.num
00000000 =00000097                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000097                M nbb1	set	.num
00000000 =00000098                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000098                M nb1	set	.num
00000000 =00000099                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB1+1, nC2,nCs2,nD2,nEb2,nE2,nF2,nFs2,nG2,nAb2,nA2,nBb2,nB2
00000000 =00000099                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000099                M nc2	set	.num
00000000 =0000009A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009A                M ncs2	set	.num
00000000 =0000009B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009B                M nd2	set	.num
00000000 =0000009C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009C                M neb2	set	.num
00000000 =0000009D                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009D                M ne2	set	.num
00000000 =0000009E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009E                M nf2	set	.num
00000000 =0000009F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009F                M nfs2	set	.num
00000000 =000000A0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A0                M ng2	set	.num
00000000 =000000A1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A1                M nab2	set	.num
00000000 =000000A2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A2                M na2	set	.num
00000000 =000000A3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A3                M nbb2	set	.num
00000000 =000000A4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A4                M nb2	set	.num
00000000 =000000A5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB2+1, nC3,nCs3,nD3,nEb3,nE3,nF3,nFs3,nG3,nAb3,nA3,nBb3,nB3
00000000 =000000A5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000A5                M nc3	set	.num
00000000 =000000A6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A6                M ncs3	set	.num
00000000 =000000A7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A7                M nd3	set	.num
00000000 =000000A8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A8                M neb3	set	.num
00000000 =000000A9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A9                M ne3	set	.num
00000000 =000000AA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AA                M nf3	set	.num
00000000 =000000AB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AB                M nfs3	set	.num
00000000 =000000AC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AC                M ng3	set	.num
00000000 =000000AD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AD                M nab3	set	.num
00000000 =000000AE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AE                M na3	set	.num
00000000 =000000AF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AF                M nbb3	set	.num
00000000 =000000B0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B0                M nb3	set	.num
00000000 =000000B1                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB3+1, nC4,nCs4,nD4,nEb4,nE4,nF4,nFs4,nG4,nAb4,nA4,nBb4,nB4
00000000 =000000B1                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000B1                M nc4	set	.num
00000000 =000000B2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B2                M ncs4	set	.num
00000000 =000000B3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B3                M nd4	set	.num
00000000 =000000B4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B4                M neb4	set	.num
00000000 =000000B5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B5                M ne4	set	.num
00000000 =000000B6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B6                M nf4	set	.num
00000000 =000000B7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B7                M nfs4	set	.num
00000000 =000000B8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B8                M ng4	set	.num
00000000 =000000B9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B9                M nab4	set	.num
00000000 =000000BA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BA                M na4	set	.num
00000000 =000000BB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BB                M nbb4	set	.num
00000000 =000000BC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BC                M nb4	set	.num
00000000 =000000BD                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB4+1, nC5,nCs5,nD5,nEb5,nE5,nF5,nFs5,nG5,nAb5,nA5,nBb5,nB5
00000000 =000000BD                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000BD                M nc5	set	.num
00000000 =000000BE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BE                M ncs5	set	.num
00000000 =000000BF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BF                M nd5	set	.num
00000000 =000000C0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C0                M neb5	set	.num
00000000 =000000C1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C1                M ne5	set	.num
00000000 =000000C2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C2                M nf5	set	.num
00000000 =000000C3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C3                M nfs5	set	.num
00000000 =000000C4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C4                M ng5	set	.num
00000000 =000000C5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C5                M nab5	set	.num
00000000 =000000C6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C6                M na5	set	.num
00000000 =000000C7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C7                M nbb5	set	.num
00000000 =000000C8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C8                M nb5	set	.num
00000000 =000000C9                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB5+1, nC6,nCs6,nD6,nEb6,nE6,nF6,nFs6,nG6,nAb6,nA6,nBb6,nB6
00000000 =000000C9                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000C9                M nc6	set	.num
00000000 =000000CA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CA                M ncs6	set	.num
00000000 =000000CB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CB                M nd6	set	.num
00000000 =000000CC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CC                M neb6	set	.num
00000000 =000000CD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CD                M ne6	set	.num
00000000 =000000CE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CE                M nf6	set	.num
00000000 =000000CF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CF                M nfs6	set	.num
00000000 =000000D0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D0                M ng6	set	.num
00000000 =000000D1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D1                M nab6	set	.num
00000000 =000000D2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D2                M na6	set	.num
00000000 =000000D3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D3                M nbb6	set	.num
00000000 =000000D4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D4                M nb6	set	.num
00000000 =000000D5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB6+1, nC7,nCs7,nD7,nEb7,nE7,nF7,nFs7,nG7,nAb7,nA7,nBb7
00000000 =000000D5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000D5                M nc7	set	.num
00000000 =000000D6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D6                M ncs7	set	.num
00000000 =000000D7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D7                M nd7	set	.num
00000000 =000000D8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D8                M neb7	set	.num
00000000 =000000D9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D9                M ne7	set	.num
00000000 =000000DA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DA                M nf7	set	.num
00000000 =000000DB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DB                M nfs7	set	.num
00000000 =000000DC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DC                M ng7	set	.num
00000000 =000000DD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DD                M nab7	set	.num
00000000 =000000DE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DE                M na7	set	.num
00000000 =000000DF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DF                M nbb7	set	.num
00000000 =000000E0                M .num	=	.num+1
00000000                          M 	shift
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; PSG volume envelope equates
00000000 =00000000                  v00 =	$00
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Header Macros
00000000                            sHeaderInit	macro
00000000                            sPointZero =	*
00000000                            sPatNum =	0
00000000                                endm
00000000                            
00000000                            ; Header - Set up Channel Usage
00000000                            sHeaderCh	macro fm,psg
00000000                            	dc.b \fm-1
00000000                            	if narg=2
00000000                            		if \fm>5
00000000                            			inform 2,"You sure there are \fm FM channels?"
00000000                            		endif
00000000                            		dc.b \psg-1
00000000                            		if \psg>3
00000000                            			inform 2,"You sure there are \psg PSG channels?"
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Convert S1 tempo to S3 tempo
00000000                            sConvS1Tempo	macro tempo
00000000                            s2tempo = ((((((((tempo=0)&1)<<8)|tempo)-1)<<8)+(((((tempo=0)&1)<<8)|tempo)>>1))/((((tempo=0)&1)<<8)|tempo))&$FF
00000000                            s3tempo = ($100-(((s2tempo=0)&1)|s2tempo))&$FF
00000000                                endm
00000000                            
00000000                            ; Header - Set up Tempo and Tick Multiplier
00000000                            sHeaderTempo	macro tmul,tempo
00000000                            	dc.b \tmul-1,\tempo
00000000                                endm
00000000                            
00000000                            sHeaderTempoS1	macro tmul,tempo
00000000                            	sConvS1Tempo \tempo
00000000                            	dc.b \tmul-1,s3tempo
00000000                                endm
00000000                            
00000000                            ; Header - Set priority leve
00000000                            sHeaderPrio	macro prio
00000000                            	dc.b \prio
00000000                                endm
00000000                            
00000000                            ; Header - Set up DAC Channel
00000000                            sHeaderDAC	macro loc,vol,samp
00000000                            	dc.w \loc-sPointZero
00000000                            	if narg>=2
00000000                            		dc.b \vol
00000000                            		if narg>=3
00000000                            			dc.b \samp
00000000                            		else
00000000                            			dc.b $00
00000000                            		endif
00000000                            	else
00000000                            		dc.w $00
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Header - Set up FM Channel
00000000                            sHeaderFM	macro loc,pitch,vol
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; Header - Set up PSG Channel
00000000                            sHeaderPSG	macro loc,pitch,vol,detune,volenv
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol,\detune,\volenv
00000000                                endm
00000000                            
00000000                            ; Header - Set up SFX Channel
00000000                            sHeaderSFX	macro flags,type,loc,pitch,vol
00000000                            	dc.b \flags,\type
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Command Flag Macros and Equates. Based on the original s1smps2asm, and Flamewing's smps2asm
00000000 =00000000                  spNone set $00
00000000 =00000040                  spRight set $40
00000000 =00000080                  spLeft set $80
00000000 =000000C0                  spCentre set $C0
00000000 =000000C0                  spCenter set $C0
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Macros for FM instruments
00000000                            ; Patches - Feedback
00000000                            
00000000                            ; Patches - Algorithm
00000000                            spAlgorithm macro val, name
00000000                            	if (sPatNum<>0)&(safe=0)
00000000                            		; align the patch
00000000                            		dc.b (*^(sPatNum*spTL4))&$FF
00000000                            		dc.b ((*>>8)+(spDe3*spDR3))&$FF
00000000                            		dc.b ((*>>16)-(spTL1*spRR3))&$FF
00000000                            	endif
00000000                            	if narg>1
00000000                            p\name =	sPatNum
00000000                            	endif
00000000                            sPatNum =	sPatNum+1
00000000                            spAl	= val
00000000                                endm
00000000                            
00000000                            spFeedback macro val
00000000                            spFe	= val
00000000                                endm
00000000                            
00000000                            ; Patches - Detune
00000000                            spDetune macro op1,op2,op3,op4
00000000                            spDe1	= op1
00000000                            spDe2	= op2
00000000                            spDe3	= op3
00000000                            spDe4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Multiple
00000000                            spMultiple macro op1,op2,op3,op4
00000000                            spMu1	= op1
00000000                            spMu2	= op2
00000000                            spMu3	= op3
00000000                            spMu4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Rate Scale
00000000                            spRateScale macro op1,op2,op3,op4
00000000                            spRS1	= op1
00000000                            spRS2	= op2
00000000                            spRS3	= op3
00000000                            spRS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Attack Rate
00000000                            spAttackRt macro op1,op2,op3,op4
00000000                            spAR1	= op1
00000000                            spAR2	= op2
00000000                            spAR3	= op3
00000000                            spAR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Amplitude Modulation
00000000                            spAmpMod macro op1,op2,op3,op4
00000000                            spAM1	= op1
00000000                            spAM2	= op2
00000000                            spAM3	= op3
00000000                            spAM4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Rate
00000000                            spSustainRt macro op1,op2,op3,op4
00000000                            spSR1	= op1		; Also known as decay 1 rate
00000000                            spSR2	= op2
00000000                            spSR3	= op3
00000000                            spSR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Level
00000000                            spSustainLv macro op1,op2,op3,op4
00000000                            spSL1	= op1		; also known as decay 1 level
00000000                            spSL2	= op2
00000000                            spSL3	= op3
00000000                            spSL4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Decay Rate
00000000                            spDecayRt macro op1,op2,op3,op4
00000000                            spDR1	= op1		; Also known as decay 2 rate
00000000                            spDR2	= op2
00000000                            spDR3	= op3
00000000                            spDR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Release Rate
00000000                            spReleaseRt macro op1,op2,op3,op4
00000000                            spRR1	= op1
00000000                            spRR2	= op2
00000000                            spRR3	= op3
00000000                            spRR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - SSG-EG
00000000                            spSSGEG macro op1,op2,op3,op4
00000000                            spSS1	= op1
00000000                            spSS2	= op2
00000000                            spSS3	= op3
00000000                            spSS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level
00000000                            spTotalLv macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            ; Construct the patch finally.
00000000                            	dc.b	(spFe<<3)+spAl
00000000                            ;   0     1     2     3     4     5     6     7
00000000                            ;%1000,%1000,%1000,%1000,%1010,%1110,%1110,%1111
00000000                            spTLMask4 set $80
00000000                            spTLMask2 set ((spAl>=5)<<7)
00000000                            spTLMask3 set ((spAl>=4)<<7)
00000000                            spTLMask1 set ((spAl=7)<<7)
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1|spTLMask1,  spTL3|spTLMask3,  spTL2|spTLMask2,  spTL4|spTLMask4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level (for broken total level masks)
00000000                            spTotalLv2 macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            	dc.b (spFe<<3)+spAl
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1,	       spTL3,		 spTL2,		   spTL4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; SMPS commands
00000000                            
00000000                            ; E0xx - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00000000                            sPan		macro pan, ams, fms
00000000                            	if narg=1
00000000                            		dc.b $E0, \pan
00000000                            	elseif narg=2
00000000                            		dc.b $E0, \pan|\ams
00000000                            	else
00000000                            		dc.b $E0, \pan|(\ams<<4)|\fms
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; E1xx - Set channel frequency displacement to xx (DETUNE_SET)
00000000                            ssDetune	macro val
00000000                            	dc.b $E1, \val
00000000                                endm
00000000                            
00000000                            ; E2xx - Add xx to channel frequency displacement (DETUNE)
00000000                            saDetune	macro val
00000000                            	dc.b $E2, \val
00000000                                endm
00000000                            
00000000                            ; E3xx - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00000000                            ssTranspose	macro val
00000000                            	dc.b $E3, \val
00000000                                endm
00000000                            
00000000                            ; E4xx - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00000000                            saTranspose	macro val
00000000                            	dc.b $E4, \val
00000000                                endm
00000000                            
00000000                            ; E5xx - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00000000                            ssTickMulCh	macro val
00000000                            	dc.b $E5, \val-1
00000000                                endm
00000000                            
00000000                            ; E6xx - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00000000                            ssTickMul	macro val
00000000                            	dc.b $E6, \val-1
00000000                                endm
00000000                            
00000000                            ; E7 - Do not attack of next note (HOLD)
00000000 =000000E7                  sHold =		$E7
00000000                            
00000000                            ; E8xx - Set patch/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00000000                            sVoice		macro val
00000000                            	dc.b $E8, \val
00000000                                endm
00000000                            
00000000                            ; E9xx - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00000000                            ssTempoShoes	macro val
00000000                            	dc.b $E9, \val
00000000                                endm
00000000                            
00000000                            ; EAxx - Set music tempo to xx (TEMPO - TEMPO_SET)
00000000                            ssTempo		macro val
00000000                            	dc.b $EA, \val
00000000                                endm
00000000                            ssTempoS1	macro val
00000000                            	sConvS1Tempo \val
00000000                            	dc.b $EA, s3tempo
00000000                                endm
00000000                            
00000000                            ; EB - Turn on Modulation (MOD_SET - MODS_ON)
00000000                            sModOn		macro
00000000                            	dc.b $EB
00000000                                endm
00000000                            
00000000                            ; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00000000                            sModOff		macro
00000000                            	dc.b $EC
00000000                                endm
00000000                            
00000000                            ; EDxx - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00000000                            saVol		macro vol
00000000                            	dc.b $ED, \vol
00000000                                endm
00000000                            
00000000                            ; EExx - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00000000                            ssVol		macro vol
00000000                            	dc.b $EE, \vol
00000000                                endm
00000000                            
00000000                            ; EFxxyy - Enable/Disable LFO (SET_LFO - LFO_AMSEN)
00000000                            ssLFO		macro reg, ams, fms, pan
00000000                            	if narg=2
00000000                            		dc.b $EF, \reg,\ams
00000000                            	elseif narg=3
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms
00000000                            	else
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms|\pan
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; F0wwxxyyzz - Modulation
00000000                            ;  ww: wait time
00000000                            ;  xx: modulation speed
00000000                            ;  yy: change per step
00000000                            ;  zz: number of steps
00000000                            ; (MOD_SETUP)
00000000                            ssMod68k	macro wait, speed, step, count
00000000                            	dc.b $F0, \wait,\speed,\step,\count
00000000                                endm
00000000                            
00000000                            ; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00000000                            sModeSampDAC	macro
00000000                            	dc.b $F1
00000000                                endm
00000000                            
00000000                            ; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00000000                            sModePitchDAC	macro
00000000                            	dc.b $F2
00000000                                endm
00000000                            
00000000                            ; F3xx - PSG4 noise mode xx (PSG_NOISE - PNOIS_AMPS)
00000000                            sNoisePSG	macro val
00000000                            	dc.b $F3, \val
00000000                                endm
00000000                            
00000000                            ; F4xxxx - Keep looping back to xxxx each time the SFX is being played (CONT_SFX)
00000000                            sCont		macro loc
00000000                            	dc.b $F4
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F5 - End of channel (TRK_END - TEND_STD)
00000000                            sStop		macro
00000000                            	dc.b $F5
00000000                                endm
00000000                            
00000000                            ; F6xxxx - Jump to xxxx (GOTO)
00000000                            ssJump		macro loc
00000000                            	dc.b $F6
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F7xxyyzzzz - Loop back to zzzz yy times, xx being the loop index for loop recursion fixing (LOOP)
00000000                            sLoop		macro index,loops,loc
00000000                            	dc.b $F7, \index
00000000                            	dc.w \loc-*-1
00000000                            	dc.b \loops
00000000                                endm
00000000                            
00000000                            ; F8xxxx - Call pattern at xxxx, saving return point (GOSUB)
00000000                            sCall		macro loc
00000000                            	dc.b $F8
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F9 - Return (RETURN)
00000000                            sRet		macro
00000000                            	dc.b $F9
00000000                                endm
00000000                            
00000000                            ; FAyyxx - Set communications byte yy to xx (SET_COMM - SPECIAL)
00000000                            sComm		macro num, val
00000000                            	dc.b $FA, \num,\val
00000000                                endm
00000000                            
00000000                            ; FBxyzz - Get communications byte y, and compare zz with it using condition x (COMM_CONDITION)
00000000                            sCond		macro num, cond, val
00000000                            	dc.b $FB, \num|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FC - Reset condition (COMM_RESET)
00000000                            sCondOff	macro
00000000                            	dc.b $FC
00000000                                endm
00000000                            
00000000                            ; FDxx - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL)
00000000                            sNoteTimeOut	macro val
00000000                            	dc.b $FD, \val
00000000                                endm
00000000                            
00000000                            ; FExxyy - YM command yy on register xx (YMCMD)
00000000                            sCmdYM		macro reg, val
00000000                            	dc.b $FE, \reg,\val
00000000                                endm
00000000                            
00000000                            ; FF00xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00000000                            sPlaySamp1	macro id
00000000                            	dc.b $FF,$00, \id
00000000                                endm
00000000                            
00000000                            ; FF01xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC2)
00000000                            sPlaySamp2	macro id
00000000                            	dc.b $FF,$01, \id
00000000                                endm
00000000                            
00000000                            ; FF02xxxx - Set channel frequency to xxxx (CHFREQ_SET)
00000000                            ssFreq		macro freq
00000000                            	dc.b $FF,$02
00000000                            	dc.w \freq
00000000                                endm
00000000                            
00000000                            ; FF03xx - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00000000                            ssFreqNote	macro note
00000000                            	dc.b $FF,$03, \note^$80
00000000                                endm
00000000                            
00000000                            ; FF04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00000000                            sSpinRev	macro
00000000                            	dc.b $FF,$04
00000000                                endm
00000000                            
00000000                            ; FF05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00000000                            sSpinReset	macro
00000000                            	dc.b $FF,$05
00000000                                endm
00000000                            
00000000                            ; FF06xx - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00000000                            saTempoSpeed	macro tempo
00000000                            	dc.b $FF,$06, \tempo
00000000                                endm
00000000                            
00000000                            ; FF07xx - Add xx to music tempo (TEMPO - TEMPO_ADD)
00000000                            saTempo		macro tempo
00000000                            	dc.b $FF,$07, \tempo
00000000                                endm
00000000                            
00000000                            ; FF08xyzz - Get RAM address pointer offset by y, compare zz with it using condition x (COMM_CONDITION - COMM_SPEC)
00000000                            sCondReg	macro off, cond, val
00000000                            	dc.b $FF,$08, \off|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FF09xx - Play another music/sfx (SND_CMD)
00000000                            sPlayMus	macro id
00000000                            	dc.b $FF,$09, \id
00000000                                endm
00000000                            
00000000                            ; FF0A - Enable raw frequency mode (RAW_FREQ)
00000000                            sFreqOn		macro freq
00000000                            	dc.b $FF,$0A
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00000000                            sFreqOff	macro freq
00000000                            	dc.b $FF,$0B
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0C - Enable FM3 special mode (SPC_FM3)
00000000                            sSpecFM3	macro freq
00000000                            	dc.b $FF,$0C
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0Dxx - Set DAC filter bank address (DAC_FILTER)
00000000                            ssFilter	macro bank
00000000                            	dc.b $FF,$0D, \bank
00000000                                endm
00000000                            
00000000                            ; FF0E - Freeze 68k. Debug flag (DEBUG_STOP_CPU)
00000000                            sFreeze		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0E
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; FF0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00000000                            sCheck		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0F
00000000                            	endif
00000000                                endm
00000000                            
00000000                            		include	"Config/Constants.asm"		; Constants
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive constants
00000000                            ; =========================================================================================================================================================
00000000 =00000000                  ROM_START		equ	$000000				; ROM area start address
00000000 =00400000                  ROM_END			equ	$3FFFFF+1			; ROM area end address
00000000                            
00000000 =00A00000                  Z80_RAM			equ	$A00000				; Z80 RAM start address
00000000 =00A02000                  Z80_RAM_END		equ	$A02000				; Z80 RAM end address
00000000 =00A11100                  Z80_BUS_REQ		equ	$A11100				; Z80 bus request
00000000 =00A11200                  Z80_RESET		equ	$A11200				; Z80 reset
00000000                            
00000000 =00A04000                  YM2612_A0		equ	$A04000				; M68K YM2612 register port 0
00000000 =00A04001                  YM2612_D0		equ	$A04001				; M68K YM2612 data port 0
00000000 =00A04002                  YM2612_A1		equ	$A04002				; M68K YM2612 register port 1
00000000 =00A04003                  YM2612_D1		equ	$A04003				; M68K YM2612 data port 1
00000000 =00C00011                  PSG_INPUT		equ	$C00011				; M68K PSG input
00000000                            
00000000 =00A10001                  HW_VERSION		equ	$A10001				; Hardware version
00000000 =00A14000                  TMSS_PORT		equ	$A14000				; TMSS port
00000000                            
00000000 =00A10003                  PORT_A_DATA		equ	$A10003				; Port A data
00000000 =00A10005                  PORT_B_DATA		equ	$A10005				; Port B data
00000000 =00A10007                  PORT_C_DATA		equ	$A10007				; Port C data
00000000 =00A10009                  PORT_A_CTRL		equ	$A10009				; Port A control
00000000 =00A1000B                  PORT_B_CTRL		equ	$A1000B				; Port B control
00000000 =00A1000D                  PORT_C_CTRL		equ	$A1000D				; Port C control
00000000 =00A1000F                  PORT_A_TX		equ	$A1000F				; Port A Tx data
00000000 =00A10011                  PORT_A_RX		equ	$A10011				; Port A Rx data
00000000 =00A10013                  PORT_A_SCTRL		equ	$A10013				; Port A S control
00000000 =00A10015                  PORT_B_TX		equ	$A10015				; Port B Tx data
00000000 =00A10017                  PORT_B_RX		equ	$A10017				; Port B Rx data
00000000 =00A10019                  PORT_B_SCTRL		equ	$A10019				; Port B S control
00000000 =00A1001B                  PORT_C_TX		equ	$A1001B				; Port C Tx data
00000000 =00A1001D                  PORT_C_RX		equ	$A1001D				; Port C Rx data
00000000 =00A1001F                  PORT_C_SCTRL		equ	$A1001F				; Port C S control
00000000                            
00000000 =00A130F1                  SRAM_ACCESS		equ	$A130F1				; SRAM access register ($200000 - $3FFFFF)
00000000                            
00000000 =00A130F3                  MAPPER_BANK_1		equ	$A130F3				; Mapper bank 1 register ($080000 - $0FFFFF)
00000000 =00A130F5                  MAPPER_BANK_2		equ	$A130F5				; Mapper bank 2 register ($100000 - $17FFFF)
00000000 =00A130F7                  MAPPER_BANK_3		equ	$A130F7				; Mapper bank 3 register ($180000 - $1FFFFF)
00000000 =00A130F9                  MAPPER_BANK_4		equ	$A130F9				; Mapper bank 4 register ($200000 - $27FFFF)
00000000 =00A130FB                  MAPPER_BANK_5		equ	$A130FB				; Mapper bank 5 register ($280000 - $2FFFFF)
00000000 =00A130FD                  MAPPER_BANK_6		equ	$A130FD				; Mapper bank 6 register ($300000 - $37FFFF)
00000000 =00A130FF                  MAPPER_BANK_7		equ	$A130FF				; Mapper bank 7 register ($380000 - $3FFFFF)
00000000                            
00000000 =00C00000                  VDP_DATA		equ	$C00000				; VDP data port
00000000 =00C00004                  VDP_CTRL		equ	$C00004				; VDP control port
00000000 =00C00008                  VDP_HVCOUNT		equ	$C00008				; VDP H/V counter
00000000 =00C0001C                  VDP_DEBUG		equ	$C0001C				; VDP debug register
00000000                            
00000000 =00FF0000                  RAM_START		equ	$FF0000				; M68K RAM start address
00000000 =01000000                  RAM_END			equ	$FFFFFF+1			; M68K RAM end address
00000000                            
00000000 =FFFF8000                  RAM_WORD_START		equ	$FFFF8000			; Starting address of absolute word addressable M68K RAM
00000000 =00000000                  RAM_WORD_END		equ	$FFFFFFFF+1			; Ending address of absolute word addressable M68K RAM
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Align
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound	- Size boundary
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            align		macros	bound
00000000                            		cnop	0,\bound
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pad RS to even address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------
00000000                            rseven		macros
00000000                            		rs.b	__rs&1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Push registers to stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to push
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            push		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 \regs,-(sp)
00000000                            			else
00000000                            				move.\0	\regs,-(sp)
00000000                            			endif
00000000                            		else
00000000                            			zpush	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Pop registers from stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to pop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            pop		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 (sp)+,\regs
00000000                            			else
00000000                            				move.\0	(sp)+,\regs
00000000                            			endif
00000000                            		else
00000000                            			zpop	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Clear memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	starta	- Address to start clearing memory at
00000000                            ;	enda	- Address to finish clearing memory at
00000000                            ;		  (not rEQUired if there exists a label that is the same as the starting label, but with "_End" at the end of it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            clrRAM		macro	starta, enda
00000000                            		local	endaddr
00000000                            		if narg<2
00000000                            endaddr			EQUS	"\starta\_End"
00000000                            		else
00000000                            endaddr			EQUS	"\enda"
00000000                            		endif
00000000                            		moveq	#0,d0
00000000                            		if ((\starta)&$8000)=0
00000000                            			lea	\starta,a1
00000000                            		else
00000000                            			lea	(\starta).w,a1
00000000                            		endif
00000000                            		if (\starta)&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		move.w	#(((\endaddr)-(\starta))-((\starta)&1))>>2-1,d1
00000000                            .Clear\@:	move.l	d0,(a1)+
00000000                            		dbf	d1,.Clear\@
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&2
00000000                            			move.w	d0,(a1)+
00000000                            		endif
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOff		macros
00000000                            		move.b	#0,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOn		macros
00000000                            		move.b	#1,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOff		macros
00000000                            		ori	#$700,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOn		macros
00000000                            		andi	#$F8FF,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            doZ80Stop	macros
00000000                            		move.w	#$100,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to stop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Stop	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80 and wait for it to
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            stopZ80		macro
00000000                            		doZ80Stop
00000000                          M 	move.w	#$100,z80_bus_req
00000000                            		waitZ80Stop
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            startZ80	macros
00000000                            		move.w	#0,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to start
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Start	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		beq.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80Off	macros
00000000                            		move.w	#$100,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Reset the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80	macros
00000000                            		move.w	#0,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the YM2612 to not be busy
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitYM		macro
00000000                            		nop
00000000                            		nop
00000000                            		nop
00000000                            @Wait\@:	tst.b	(a0)
00000000                            		bmi.s	@Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for DMA finish
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	port	- Something to represent the VDP control port (default is VDP_CTRL_PORT)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00000000                            waitDMA		macro	port
00000000                            .Wait\@:
00000000                            		if narg>0
00000000                            			move.w	\port,d1
00000000                            		else
00000000                            			move.w	VDP_CTRL,d1
00000000                            		endif
00000000                            		btst	#1,d1
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr	- Address in VDP memory
00000000                            ;	type	- Type of VDP memory
00000000                            ;	rwd	- VDP command
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000021                  VRAM		EQU	%100001		; VRAM
00000000 =0000002B                  CRAM		EQU	%101011		; CRAM
00000000 =00000025                  VSRAM		EQU	%100101		; VSRAM
00000000 =0000000C                  READ		EQU	%001100		; VDP read
00000000 =00000007                  WRITE		EQU	%000111		; VDP write
00000000 =00000027                  DMA		EQU	%100111		; VDP DMA
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            vdpCmd		macro	ins, addr, type, rwd, end, end2
00000000                            		if narg=5
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14)), \end
00000000                            		elseif narg>=6
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))\end, \end2
00000000                            		else
00000000                            			\ins	((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in 68000 memory
00000000                            ;	dest	- Destination address in VDP memory
00000000                            ;	len	- Length of data in bytes
00000000                            ;	type	- Type of VDP memory
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dma68k		macro	src, dest, len, type, port
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(a6)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(a6)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, >>16, (a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, &$FFFF, -(sp)
00000000                            		move.w	(sp)+,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Fill VRAM with byte
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte	- Byte to fill VRAM with
00000000                            ;	addr	- Address in VRAM
00000000                            ;	len	- Length of fill in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaFill		macro	byte, addr, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.w	#$9780,(a6)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(a6)
00000000                            		move.w	#(\byte)<<8,-4(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Copy a region of VRAM to a location in VRAM
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in VRAM
00000000                            ;	dest	- Destination address in VRAM
00000000                            ;	len	- Length of copy in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaCopy		macro	src, dest, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(a6)
00000000                            		move.w	#$97C0,(a6)
00000000                            		move.l	#$000000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOn		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9193,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOff		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9100,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOff	macro
00000000                            		move.w	vdpReg1.w,d0
00000000                            		andi.b	#%10111111,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOn	macro
00000000                            		move.w	vdpReg1.w,d0
00000000                            		ori.b	#%01000000,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDDown	macros
00000000                            		move.l	#-$80000,rHUD_Accel.w		; Set to move HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDUp	macros
00000000                            		move.l	#$8000,rHUD_Accel.w		; Set to move HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Convert a string to the textbox's format and store as a line
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	str	- The string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLine		macro	str
00000000                            c		= 1
00000000                            		rept	strlen(\str)
00000000                            ochar			substr c, c, \str
00000000                            char			substr "\ochar"-$1F, "\ochar"-$1F, "skojh`aledisfsg\0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ABCDEFGHIJKLMNOPQRSTUVWXYZncmb"
00000000                            			dc.w	"\char"+$588
00000000                            c			= c+1
00000000                            		endr
00000000                            		dc.w	$FFFF
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a line break character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineBreak	macros
00000000                            		dc.w	$FFFF
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a message terminator character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineEnd	macros
00000000                            		dc.w	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an animation change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ani	- New animation script pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewAni	macro	ani
00000000                            		dc.w	$FFFE
00000000                            		dc.l	\ani
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an icon change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	icon	- New icon art pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewIcon	macro	icon
00000000                            		dc.w	$FFFD
00000000                            		dc.l	\icon
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a finished flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtEnd		macros
00000000                            		dc.w	$FFFC
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an entry to the level art animation script
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	duration	- Global duration
00000000                            ;	artaddr		- Source art
00000000                            ;	tileid		- Destination tile ID
00000000                            ;	numentries	- Number of entries
00000000                            ;	numvramtiles	- Number of tiles per entry
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lvlAniDat	macro	duration, artaddr, tileid, numentries, numvramtiles
00000000                            		dc.l	(\duration&$FF)<<24|\artaddr
00000000                            		dc.w	((\tileid&$7FF)<<5)
00000000                            		dc.b	\numentries, \numvramtiles
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Get a unique character set from a string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string		- String to go throuhg
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	unique_chars	- A string of unique characters found
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            getUniqueChars	macro	string
00000000                            unique_chars	substr 1,1,\string
00000000                            strpos		= 1
00000000                            		while strpos<strlen(\string)
00000000                            found			= 0
00000000                            pos			= 0
00000000                            char			substr strpos+1,strpos+1,\string
00000000                            			while (pos<strlen("\unique_chars"))&(found=0)
00000000                            uchar				substr pos+1,pos+1,"\unique_chars"
00000000                            				if strcmp("\uchar","\char")|strcmp("\char", " ")
00000000                            found					= 1
00000000                            				endif
00000000                            pos				= pos+1
00000000                            			endw
00000000                            			if found=0
00000000                            unique_chars			equs "\unique_chars\\char"
00000000                            			endif
00000000                            strpos			= strpos+1
00000000                            			endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Run objects macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            runObjects		macro
00000000                            		movea.w	objExecFirst.w,a0				; load first object slot into a0
00000000                            		move.l	_objAddress(a0),a1				; load its pointer to a1
00000000                            		jsr	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Next object macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            nextObject		macro
00000000                            		movea.w	_objNext(a0),a0				; load the next object address to a0
00000000                            		move.l	_objAddress(a0),a1				; load its pointer to a1
00000000                            		jmp	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	layer	- The destination display layer
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySprite		macro	layer, obj, fre, chk
00000000                            ;	if layer >= 8
00000000                            ;		inform 2,"Invalid display layer!"
00000000                            ;	endif
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\obj)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	#objDisplay+(\layer*dSize),_objDrawNext(\obj)	; put end marker as the next pointer
00000000                            		move.w	objDisplay+dPrev+(\layer*dSize).w,\fre		; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,_objDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,_objDrawNext(\fre)				;
00000000                            		move.w	\obj,objDisplay+dPrev+(\layer*dSize).w		; copy the pointer from the end marker to dst register
00000000                            ;		cmp.w	#objDisplay+(\layer*dSize),objDisplay+dPrev+(\layer*dSize).w	; special case: points to itself
00000000                            ;		bne.s	.no\@								; if no, skip
00000000                            ;		move.w	\obj,objDisplay+dPrev+(\layer*dSize).w				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list using an address register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg	- The address regsister containing target
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySpriteReg		macro	reg, obj, fre, chk
00000000                            	local layer
00000000                            layer EQUR	\reg							; convert register
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\reg)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	layer,_objDrawNext(\obj)				; put end marker as the next pointer
00000000                            		move.w	_objDrawPrev(layer),\fre				; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,_objDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,_objDrawNext(\fre)				;
00000000                            		move.w	\obj,_objDrawPrev(layer)				; copy the pointer from the end marker to dst register
00000000                            ;		cmp.w	_objDrawPrev(layer),layer				; special case: points to itself
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\obj,_objDrawPrev(layer)				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Remove a sprite from a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            removeSprite		macro	obj, fre, chk
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\obj)					; check if displayed already
00000000                            		beq.s	.yes\@						; if not, skip
00000000                            	endif
00000000                            		move.w	_objDrawPrev(\obj),\fre				; load the prev pointer to dst
00000000                            		move.w	_objDrawNext(\obj),_objDrawNext(\fre)			; copy the next object pointer from src to dst
00000000                            		move.w	_objDrawNext(\obj),\fre				; load the next pointer to dst
00000000                            		move.w	_objDrawPrev(\obj),_objDrawPrev(\fre)			; copy the prev object pointer from src to dst
00000000                            ;		cmp.w	_objDrawPrev(\obj),\fre				; special case: last object
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\fre,_objDrawNext(\fre)				; else, change to point to same address
00000000                            .no\@
00000000                            		clr.l	_objDrawNext(\obj)
00000000                            .yes\@
00000000                            	endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Offsets.asm"		; Offsets
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Game mode IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  gTitle		rs.l	1				; Title screen game mode
00000000 =00000004                  gLevel		rs.l	1				; Level game mode
00000000 =00000008                  gEnd		rs.l	1				; Ending game mode
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; V-INT routine IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  vLag		rs.w	1				; Lag updates
00000000 =00000002                  vGeneral	rs.w	1				; General updates
00000000 =00000004                  vLevel		rs.w	1				; Level updates
00000000 =00000006                  vLvlLoad	rs.w	1				; Level load updates
00000000 =00000008                  vTitle		rs.w	1				; Title screen updates
00000000 =0000000A                  vFade		rs.w	1				; Fade updates
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  zWWZ		rs.b	1				; Wacky Workbench
00000000                            
00000000 =00000001                  ZONE_COUNT	equ	__rs				; Number of zones
00000000                            
00000000 =00000000                  lWWZ		equ	zWWZ<<8				; Wacky Workbench
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Music definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	MusOff
00000000 =0000000A                  mFirst		rs.b	0
00000000 =0000000A                  mSega		rs.b	1				; SEGA jingle
00000000 =0000000B                  mWWZ		rs.b	1				; Wacky Workbench music
00000000 =0000000C                  mBoss		rs.b	1				; Boss music
00000000 =0000000D                  mInvincible	rs.b	1				; Invincibility music
00000000 =0000000E                  mEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; SFX definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	SFXoff
00000000 =00000082                  sFirst		rs.b	0
00000000 =00000082                  sLeap		rs.b	1				; Jump sound
00000000 =00000083                  sSkid		rs.b	1				; Skid sound
00000000 =00000084                  sHurt		rs.b	0				; Hurt sound
00000000 =00000084                  sDeath		rs.b	1				; Death sound
00000000 =00000085                  sPush		rs.b	1				; Push sound
00000000 =00000086                  sBubble		rs.b	1				; Bubble sound
00000000 =00000087                  sDrown		rs.b	1				; Drowning sound
00000000 =00000088                  sDrownWarn	rs.b	1				; Drown warning sound
00000000 =00000089                  sDrownCount	rs.b	1				; Drown countdown sound
00000000 =0000008A                  sCheckpoint	rs.b	1				; Checkpoint sound
00000000 =0000008B                  sSpikeMove	rs.b	1				; Spike movement sound
00000000 =0000008C                  sRing		rs.b	1				; Ring sound
00000000 =0000008D                  sRingLoss	rs.b	1				; Ring loss sound
00000000 =0000008E                  sSpring		rs.b	1				; Spring sound
00000000 =0000008F                  sShield		rs.b	1				; Shield sound
00000000 =00000090                  sSplash		rs.b	1				; Water splash sound
00000000 =00000091                  sBumper		rs.b	1				; Bumper sound
00000000 =00000092                  sSwitch		rs.b	1				; Switch sound
00000000 =00000093                  sSignpost	rs.b	1				; Signpost sound
00000000 =00000094                  sCollapse	rs.b	1				; Collapse sound
00000000 =00000095                  sWallSmash	rs.b	1				; Wall smash sound
00000000 =00000096                  sRumble		rs.b	1				; Rumble sound
00000000 =00000097                  sWarp		rs.b	1				; Warp sound
00000000 =00000098                  sBossHit	rs.b	1				; Boss hit sound
00000000 =00000099                  sBomb		rs.b	1				; Bomb sound
00000000 =0000009A                  sBreakItem	rs.b	1				; Break item sound
00000000 =0000009B                  sFloorBounce	rs.b	1				; Floor bounce sound
00000000 =0000009C                  sCharge		rs.b	1				; Charge sound
00000000 =0000009D                  sChargeStop	rs.b	1				; Charge stop sound
00000000 =0000009E                  sChargeRelease	rs.b	1				; Charge release sound
00000000 =0000009F                  sDiamBreak	rs.b	1				; Diamond break sound
00000000 =000000A0                  sEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Object SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  _objPrevDPLC	rs.b	0				; Previous DPLC ID (only used by a few objects)
00000000 =00000000                  _objAddress	rs.l	1				; Pointer to object code
00000000 =00000004                  _objNext	rs.w	1				; Pointer to next object in the linked list
00000000 =00000006                  _objPrev	rs.w	1				; Pointer to previous object in the linked list
00000000 =00000008                  _objDrawNext	rs.w	1				; Pointer to next object to display
00000000 =0000000A                  _objDrawPrev	rs.w	1				; Pointer to previous object to display
00000000                            
00000000 =0000000C                  _objFlags	rs.b	1				; Object flags
00000000 =0000000D                  _objRender	rs.b	1				; Render flags
00000000 =0000000E                  _objVRAM	rs.w	1				; Sprite tile properties
00000000 =00000010                  _objFrame	rs.b	0				; Mapping frame ID (top byte of the following long)
00000000 =00000010                  _objMapping	rs.l	1				; Sprite mappings
00000000                            
00000000 =00000014                  _objXPos	rs.l	1				; X position
00000000 =00000017                  _objDrawW	equ	__rs-1				; Sprite width
00000000 =00000018                  _objYPos	rs.l	1				; Y position
00000000 =0000001B                  _objDrawH	equ	__rs-1				; Sprite height
00000000 =0000001C                  _objXVel	rs.w	1				; X velocity
00000000 =0000001E                  _objYVel	rs.w	1				; Y velocity
00000000                            
00000000 =00000020                  _objAnim	rs.b	1				; Animation ID
00000000 =00000021                  _objPrevAnim	rs.b	1				; Saved animation ID
00000000 =00000022                  _objAnimFrame	rs.b	1				; Animation script frame ID
00000000 =00000023                  _objAnimTimer	rs.b	1				; Animation timer
00000000                            
00000000 =00000024                  _objSubtype	rs.b	1				; Subtype ID (top byte of the following long)
00000000 =00000025                  _objRoutine	rs.b	1				; Routine ID
00000000 =00000026                  _objRespawn	rs.w	1				; Respawn table entry pointer
00000000 =00000028                  _objStatus	rs.b	1				; Status flags
00000000 =00000029                  _objShield	rs.b	1				; Shield flags
00000000                            
00000000 =0000002A                  _objDynSSTs	rs.b	$60-__rs			; Dynamic SSTs
00000000 =00000060                  _objSize	rs.b	0				; Size of the SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Dynamic SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	_objDynSSTs
00000000 =0000002A                  _objColType	rs.b	1				; Collision type
00000000 =0000002B                  _objColStat	rs.b	1				; Collision status
00000000 =0000002B                  _objHitCnt	equ	_objColStat			; Boss hit count
00000000 =0000002C                  _objColW	rs.b	1				; Collision width
00000000 =0000002D                  _objColH	rs.b	1				; Collision height
00000000 =0000002E                  _objNextTilt	rs.b	1				; Next tilt value
00000000 =0000002F                  _objTilt	rs.b	1				; Tilt value
00000000 =00000030                  _objLvlSSTs	rs.b	0				; Beginning of dynamic level SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sub sprite SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	_objNextTilt			; Allow some reserved SSTs
00000000 =0000002E                  _objSubSSTs	rs.b	0				; Start of sub sprite SSTs
00000000 =0000002E                  _objSubCnt	rs.w	1				; Main sprite sub sprite count
00000000 =00000030                  _objSubStart	rs.b	0				; Actual sub sprite SSTs start
00000000 =00000000                  ct		=	0
00000000                            
00000000                            	rept	8					; Allow 8 sub sprites per object
00000000                            _objSub\$ct\XPos	rs.w	1			; Sub sprite X position
00000000                            _objSub\$ct\YPos	rs.w	1			; Sub sprite Y position
00000000                            _objSub\$ct\Free	rs.b	1			; Sub sprite free byte
00000000                            _objSub\$ct\Frame	rs.b	1			; Sub sprite mapping frame
00000000                            ct		=	ct+1
00000000                            	endr
00000000 =00000030                M _objsub0xpos	rs.w	1
00000000 =00000032                M _objsub0ypos	rs.w	1
00000000 =00000034                M _objsub0free	rs.b	1
00000000 =00000035                M _objsub0frame	rs.b	1
00000000 =00000001                M ct	=	ct+1
00000000 =00000036                M _objsub1xpos	rs.w	1
00000000 =00000038                M _objsub1ypos	rs.w	1
00000000 =0000003A                M _objsub1free	rs.b	1
00000000 =0000003B                M _objsub1frame	rs.b	1
00000000 =00000002                M ct	=	ct+1
00000000 =0000003C                M _objsub2xpos	rs.w	1
00000000 =0000003E                M _objsub2ypos	rs.w	1
00000000 =00000040                M _objsub2free	rs.b	1
00000000 =00000041                M _objsub2frame	rs.b	1
00000000 =00000003                M ct	=	ct+1
00000000 =00000042                M _objsub3xpos	rs.w	1
00000000 =00000044                M _objsub3ypos	rs.w	1
00000000 =00000046                M _objsub3free	rs.b	1
00000000 =00000047                M _objsub3frame	rs.b	1
00000000 =00000004                M ct	=	ct+1
00000000 =00000048                M _objsub4xpos	rs.w	1
00000000 =0000004A                M _objsub4ypos	rs.w	1
00000000 =0000004C                M _objsub4free	rs.b	1
00000000 =0000004D                M _objsub4frame	rs.b	1
00000000 =00000005                M ct	=	ct+1
00000000 =0000004E                M _objsub5xpos	rs.w	1
00000000 =00000050                M _objsub5ypos	rs.w	1
00000000 =00000052                M _objsub5free	rs.b	1
00000000 =00000053                M _objsub5frame	rs.b	1
00000000 =00000006                M ct	=	ct+1
00000000 =00000054                M _objsub6xpos	rs.w	1
00000000 =00000056                M _objsub6ypos	rs.w	1
00000000 =00000058                M _objsub6free	rs.b	1
00000000 =00000059                M _objsub6frame	rs.b	1
00000000 =00000007                M ct	=	ct+1
00000000 =0000005A                M _objsub7xpos	rs.w	1
00000000 =0000005C                M _objsub7ypos	rs.w	1
00000000 =0000005E                M _objsub7free	rs.b	1
00000000 =0000005F                M _objsub7frame	rs.b	1
00000000 =00000008                M ct	=	ct+1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sprite drawing input list definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset _objDrawPrev-6			; this awkward thing will make dPrev == _objDrawPrev
00000000 =00000004                  dNext		rs.w 1					; pointer to first display object in linked list
00000000 =00000006                  dN2		rs.w 1					; must be 0
00000000 =00000008                  dN1		rs.w 1					; must be 0
00000000 =0000000A                  dPrev		rs.w 1					; pointer to last display object in linked list
00000000 =00000008                  dSize =		__rs-dNext				; size of display layer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Solid object collision bits
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000003                  cStandBit	equ	3
00000000 =00000008                  cStand		equ	1<<cStandBit
00000000                            
00000000 =00000002                  cPushDelta	equ	2
00000000                            
00000000 =00000005                  cPushBit	equ	cStandBit+cPushDelta
00000000 =00000020                  cPush		equ	1<<cPushBit
00000000                            
00000000 =00000000                  cTouchSideBit	equ	0
00000000 =00000001                  cTouchSide	equ	1<<cTouchSideBit
00000000                            
00000000 =00000002                  cTouchBtmBit	equ	cTouchSideBit+cPushDelta
00000000 =00000004                  cTouchBtm	equ	1<<cTouchBtmBit
00000000                            
00000000 =00000004                  cTouchTopBit	equ	cTouchBtmBit+cPushDelta
00000000 =00000010                  cTouchTop	equ	1<<cTouchTopBit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Macro to calculate the RAM space used by objects without going over the given max size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	size	- Max size for this object SST space
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  curobj		=	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            maxObjRAM	macro	size
00000000                            curobj_size	=	0
00000000                            		while curobj_size<(\size)
00000000                            rObj_\$curobj		rs.b	_objSize
00000000                            curobj_size		=	curobj_size+_objSize
00000000                            curobj			=	curobj+1
00000000                            		endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level drawing variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  cXPos		rs.l	1				; Plane X position
00000000 =00000004                  cXPrev		rs.w	1				; Plane previous X position
00000000 =00000006                  cXPrevR		rs.w	1				; Plane previous X position (rounded)
00000000 =00000008                  cYPos		rs.l	1				; Plane Y position
00000000 =0000000C                  cYPrev		rs.w	1				; Plane previous Y position
00000000 =0000000E                  cYPrevR		rs.w	1				; Plane previous Y position (rounded)
00000000 =00000010                  cRBlks		rs.b	1				; Number of blocks in the first set of tiles in a row
00000000 =00000011                  cCBlks		rs.b	1				; Number of blocks in the first set of tiles in a column
00000000 =00000012                  cVDP		rs.l	1				; VDP command
00000000 =00000016                  cLayout		rs.w	1				; Layout offset
00000000 =00000018                  cUpdate		rs.l	1				; Update routine
00000000 =0000001C                  cRedraw		rs.w	1				; Redraw flag
00000000 =0000001E                  cSize2		rs.b	0				; Variable list size
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Variables.asm"		; Variables
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Standard variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	RAM_START
00000000                            
00000000                            		; --- BUFFERS ---
00000000                            
00000000 =00FF0000                  miscBuff	rs.b	0				; General buffer
00000000 =00FF0000                  chunkData	rs.b	$8000				; Chunk table (uses same space as general buffer)
00000000 =00FF8000                  miscBuff_End	rs.b	0
00000000                            
00000000                            		rsset	RAM_WORD_START
00000000                            
00000000 =FFFF8000                  kosMBuff	rs.b	$1000				; Kosinski decompression buffer
00000000                            
00000000 =FFFF9000                  dmaQueue	rs.b	$FC				; DMA queue buffer
00000000 =FFFF90FC                  dmaSlot		rs.w	1				; DMA queue buffer slot
00000000                            
00000000 =FFFF90FE                  hScrollBuff	rs.b	$380				; HScroll table
00000000 =FFFF947E                  hScrollBuff_End	rs.b	0				; ''
00000000                            
00000000 =FFFF947E                  vScrollBuff	rs.b	$50				; VScroll table
00000000 =FFFF94CE                  vScrollBuff_End	rs.b	0				; ''
00000000 =FFFF947E                  vScrollBuffFG	EQU	vScrollBuff			; VScroll foreground value
00000000 =FFFF9480                  vScrollBuffBG	EQU	vScrollBuff+2			; VScroll background value
00000000                            
00000000 =FFFF94CE                  spriteBuff	rs.b	$280				; Sprite table
00000000 =FFFF974E                  spriteBuff_End	rs.b	0				; ''
00000000                            
00000000                            ; NTP: we won't be able to save ram like this until we switch to SWAP mappings (and we'll need per-piece limit checks on lest we overwrite the water palette)
00000000                            ;palFadeBuffAlt	equ	spriteBuff_End-$100		; Target water palette buffer
00000000                            ;palFadeBuff	equ	spriteBuff_End-$80		; Target palette buffer
00000000                            
00000000 =FFFF974E                  palFadeBuffAlt	rs.b	$80				; Target water palette buffer
00000000 =FFFF97CE                  palFadeBuff	rs.b	$80				; Target palette buffer
00000000 =FFFF984E                  paletteBuffAlt	rs.b	$80				; Water palette buffer
00000000 =FFFF98CE                  paletteBuff	rs.b	$80				; Palette buffer
00000000                            
00000000 =FFFF994E                  kosVars		rs.b	0				; Kosinski decompression queue variables
00000000 =FFFF994E                  kosCount	rs.w	1				; Kosinski decompression queue count
00000000 =FFFF9950                  kosRegisters	rs.b	$1A				; Kosinski decompression stored registers
00000000 =FFFF996A                  kosStatusReg	rs.w	1				; Kosinski decompression stored SR
00000000 =FFFF996C                  kosBookmark	rs.l	1				; Kosinski decompression bookmark
00000000 =FFFF9970                  kosList		rs.b	$20				; Kosinski decompression queue
00000000 =FFFF9970                  kosSource	equ	kosList				; ''
00000000 =FFFF9974                  kosDestination	equ	kosList+4			; ''
00000000 =FFFF9990                  kosList_End	rs.b	0				; ''
00000000 =FFFF9990                  kosMModules	rs.w	1				; Kosinski moduled decompression modules left
00000000 =FFFF9992                  kosMLastSize	rs.w	1				; Kosinski moduled decompression last module size
00000000 =FFFF9994                  kosMList	rs.b	$20*6				; Kosinski moduled decompression queue
00000000 =FFFF9994                  kosMSource	equ	kosMList			; ''
00000000 =FFFF9998                  kosMDestination	equ	kosMList+4			; ''
00000000 =FFFF9A54                  kosMList_End	rs.b	0				; ''
00000000 =FFFF9A54                  kosVars_End	rs.b	0				; End of Kosinski decompression queue variables
00000000                            
00000000 =FFFF9A54                  objRespawn	rs.b	$300				; Object respawn table
00000000 =FFFF9D54                  objRespawn_End	rs.b	0				; ''
00000000                            
00000000 =FFFF9D54                  objMemory	rs.b	0				; Object SSTs
00000000                            		maxObjRAM $2400				; ''
00000000 =00000000                M curobj_size	=	0
00000000                          M 	while	curobj_size<($2400)
00000000 =FFFF9D54                M robj_0	rs.b	_objsize
00000000 =00000060                M curobj_size	=	curobj_size+_objsize
00000000 =00000001                M curobj	=	curobj+1
00000000 =FFFF9DB4                M robj_1	rs.b	_objsize
00000000 =000000C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000002                M curobj	=	curobj+1
00000000 =FFFF9E14                M robj_2	rs.b	_objsize
00000000 =00000120                M curobj_size	=	curobj_size+_objsize
00000000 =00000003                M curobj	=	curobj+1
00000000 =FFFF9E74                M robj_3	rs.b	_objsize
00000000 =00000180                M curobj_size	=	curobj_size+_objsize
00000000 =00000004                M curobj	=	curobj+1
00000000 =FFFF9ED4                M robj_4	rs.b	_objsize
00000000 =000001E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000005                M curobj	=	curobj+1
00000000 =FFFF9F34                M robj_5	rs.b	_objsize
00000000 =00000240                M curobj_size	=	curobj_size+_objsize
00000000 =00000006                M curobj	=	curobj+1
00000000 =FFFF9F94                M robj_6	rs.b	_objsize
00000000 =000002A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000007                M curobj	=	curobj+1
00000000 =FFFF9FF4                M robj_7	rs.b	_objsize
00000000 =00000300                M curobj_size	=	curobj_size+_objsize
00000000 =00000008                M curobj	=	curobj+1
00000000 =FFFFA054                M robj_8	rs.b	_objsize
00000000 =00000360                M curobj_size	=	curobj_size+_objsize
00000000 =00000009                M curobj	=	curobj+1
00000000 =FFFFA0B4                M robj_9	rs.b	_objsize
00000000 =000003C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000A                M curobj	=	curobj+1
00000000 =FFFFA114                M robj_a	rs.b	_objsize
00000000 =00000420                M curobj_size	=	curobj_size+_objsize
00000000 =0000000B                M curobj	=	curobj+1
00000000 =FFFFA174                M robj_b	rs.b	_objsize
00000000 =00000480                M curobj_size	=	curobj_size+_objsize
00000000 =0000000C                M curobj	=	curobj+1
00000000 =FFFFA1D4                M robj_c	rs.b	_objsize
00000000 =000004E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000D                M curobj	=	curobj+1
00000000 =FFFFA234                M robj_d	rs.b	_objsize
00000000 =00000540                M curobj_size	=	curobj_size+_objsize
00000000 =0000000E                M curobj	=	curobj+1
00000000 =FFFFA294                M robj_e	rs.b	_objsize
00000000 =000005A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000F                M curobj	=	curobj+1
00000000 =FFFFA2F4                M robj_f	rs.b	_objsize
00000000 =00000600                M curobj_size	=	curobj_size+_objsize
00000000 =00000010                M curobj	=	curobj+1
00000000 =FFFFA354                M robj_10	rs.b	_objsize
00000000 =00000660                M curobj_size	=	curobj_size+_objsize
00000000 =00000011                M curobj	=	curobj+1
00000000 =FFFFA3B4                M robj_11	rs.b	_objsize
00000000 =000006C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000012                M curobj	=	curobj+1
00000000 =FFFFA414                M robj_12	rs.b	_objsize
00000000 =00000720                M curobj_size	=	curobj_size+_objsize
00000000 =00000013                M curobj	=	curobj+1
00000000 =FFFFA474                M robj_13	rs.b	_objsize
00000000 =00000780                M curobj_size	=	curobj_size+_objsize
00000000 =00000014                M curobj	=	curobj+1
00000000 =FFFFA4D4                M robj_14	rs.b	_objsize
00000000 =000007E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000015                M curobj	=	curobj+1
00000000 =FFFFA534                M robj_15	rs.b	_objsize
00000000 =00000840                M curobj_size	=	curobj_size+_objsize
00000000 =00000016                M curobj	=	curobj+1
00000000 =FFFFA594                M robj_16	rs.b	_objsize
00000000 =000008A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000017                M curobj	=	curobj+1
00000000 =FFFFA5F4                M robj_17	rs.b	_objsize
00000000 =00000900                M curobj_size	=	curobj_size+_objsize
00000000 =00000018                M curobj	=	curobj+1
00000000 =FFFFA654                M robj_18	rs.b	_objsize
00000000 =00000960                M curobj_size	=	curobj_size+_objsize
00000000 =00000019                M curobj	=	curobj+1
00000000 =FFFFA6B4                M robj_19	rs.b	_objsize
00000000 =000009C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001A                M curobj	=	curobj+1
00000000 =FFFFA714                M robj_1a	rs.b	_objsize
00000000 =00000A20                M curobj_size	=	curobj_size+_objsize
00000000 =0000001B                M curobj	=	curobj+1
00000000 =FFFFA774                M robj_1b	rs.b	_objsize
00000000 =00000A80                M curobj_size	=	curobj_size+_objsize
00000000 =0000001C                M curobj	=	curobj+1
00000000 =FFFFA7D4                M robj_1c	rs.b	_objsize
00000000 =00000AE0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001D                M curobj	=	curobj+1
00000000 =FFFFA834                M robj_1d	rs.b	_objsize
00000000 =00000B40                M curobj_size	=	curobj_size+_objsize
00000000 =0000001E                M curobj	=	curobj+1
00000000 =FFFFA894                M robj_1e	rs.b	_objsize
00000000 =00000BA0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001F                M curobj	=	curobj+1
00000000 =FFFFA8F4                M robj_1f	rs.b	_objsize
00000000 =00000C00                M curobj_size	=	curobj_size+_objsize
00000000 =00000020                M curobj	=	curobj+1
00000000 =FFFFA954                M robj_20	rs.b	_objsize
00000000 =00000C60                M curobj_size	=	curobj_size+_objsize
00000000 =00000021                M curobj	=	curobj+1
00000000 =FFFFA9B4                M robj_21	rs.b	_objsize
00000000 =00000CC0                M curobj_size	=	curobj_size+_objsize
00000000 =00000022                M curobj	=	curobj+1
00000000 =FFFFAA14                M robj_22	rs.b	_objsize
00000000 =00000D20                M curobj_size	=	curobj_size+_objsize
00000000 =00000023                M curobj	=	curobj+1
00000000 =FFFFAA74                M robj_23	rs.b	_objsize
00000000 =00000D80                M curobj_size	=	curobj_size+_objsize
00000000 =00000024                M curobj	=	curobj+1
00000000 =FFFFAAD4                M robj_24	rs.b	_objsize
00000000 =00000DE0                M curobj_size	=	curobj_size+_objsize
00000000 =00000025                M curobj	=	curobj+1
00000000 =FFFFAB34                M robj_25	rs.b	_objsize
00000000 =00000E40                M curobj_size	=	curobj_size+_objsize
00000000 =00000026                M curobj	=	curobj+1
00000000 =FFFFAB94                M robj_26	rs.b	_objsize
00000000 =00000EA0                M curobj_size	=	curobj_size+_objsize
00000000 =00000027                M curobj	=	curobj+1
00000000 =FFFFABF4                M robj_27	rs.b	_objsize
00000000 =00000F00                M curobj_size	=	curobj_size+_objsize
00000000 =00000028                M curobj	=	curobj+1
00000000 =FFFFAC54                M robj_28	rs.b	_objsize
00000000 =00000F60                M curobj_size	=	curobj_size+_objsize
00000000 =00000029                M curobj	=	curobj+1
00000000 =FFFFACB4                M robj_29	rs.b	_objsize
00000000 =00000FC0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002A                M curobj	=	curobj+1
00000000 =FFFFAD14                M robj_2a	rs.b	_objsize
00000000 =00001020                M curobj_size	=	curobj_size+_objsize
00000000 =0000002B                M curobj	=	curobj+1
00000000 =FFFFAD74                M robj_2b	rs.b	_objsize
00000000 =00001080                M curobj_size	=	curobj_size+_objsize
00000000 =0000002C                M curobj	=	curobj+1
00000000 =FFFFADD4                M robj_2c	rs.b	_objsize
00000000 =000010E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002D                M curobj	=	curobj+1
00000000 =FFFFAE34                M robj_2d	rs.b	_objsize
00000000 =00001140                M curobj_size	=	curobj_size+_objsize
00000000 =0000002E                M curobj	=	curobj+1
00000000 =FFFFAE94                M robj_2e	rs.b	_objsize
00000000 =000011A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002F                M curobj	=	curobj+1
00000000 =FFFFAEF4                M robj_2f	rs.b	_objsize
00000000 =00001200                M curobj_size	=	curobj_size+_objsize
00000000 =00000030                M curobj	=	curobj+1
00000000 =FFFFAF54                M robj_30	rs.b	_objsize
00000000 =00001260                M curobj_size	=	curobj_size+_objsize
00000000 =00000031                M curobj	=	curobj+1
00000000 =FFFFAFB4                M robj_31	rs.b	_objsize
00000000 =000012C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000032                M curobj	=	curobj+1
00000000 =FFFFB014                M robj_32	rs.b	_objsize
00000000 =00001320                M curobj_size	=	curobj_size+_objsize
00000000 =00000033                M curobj	=	curobj+1
00000000 =FFFFB074                M robj_33	rs.b	_objsize
00000000 =00001380                M curobj_size	=	curobj_size+_objsize
00000000 =00000034                M curobj	=	curobj+1
00000000 =FFFFB0D4                M robj_34	rs.b	_objsize
00000000 =000013E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000035                M curobj	=	curobj+1
00000000 =FFFFB134                M robj_35	rs.b	_objsize
00000000 =00001440                M curobj_size	=	curobj_size+_objsize
00000000 =00000036                M curobj	=	curobj+1
00000000 =FFFFB194                M robj_36	rs.b	_objsize
00000000 =000014A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000037                M curobj	=	curobj+1
00000000 =FFFFB1F4                M robj_37	rs.b	_objsize
00000000 =00001500                M curobj_size	=	curobj_size+_objsize
00000000 =00000038                M curobj	=	curobj+1
00000000 =FFFFB254                M robj_38	rs.b	_objsize
00000000 =00001560                M curobj_size	=	curobj_size+_objsize
00000000 =00000039                M curobj	=	curobj+1
00000000 =FFFFB2B4                M robj_39	rs.b	_objsize
00000000 =000015C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003A                M curobj	=	curobj+1
00000000 =FFFFB314                M robj_3a	rs.b	_objsize
00000000 =00001620                M curobj_size	=	curobj_size+_objsize
00000000 =0000003B                M curobj	=	curobj+1
00000000 =FFFFB374                M robj_3b	rs.b	_objsize
00000000 =00001680                M curobj_size	=	curobj_size+_objsize
00000000 =0000003C                M curobj	=	curobj+1
00000000 =FFFFB3D4                M robj_3c	rs.b	_objsize
00000000 =000016E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003D                M curobj	=	curobj+1
00000000 =FFFFB434                M robj_3d	rs.b	_objsize
00000000 =00001740                M curobj_size	=	curobj_size+_objsize
00000000 =0000003E                M curobj	=	curobj+1
00000000 =FFFFB494                M robj_3e	rs.b	_objsize
00000000 =000017A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003F                M curobj	=	curobj+1
00000000 =FFFFB4F4                M robj_3f	rs.b	_objsize
00000000 =00001800                M curobj_size	=	curobj_size+_objsize
00000000 =00000040                M curobj	=	curobj+1
00000000 =FFFFB554                M robj_40	rs.b	_objsize
00000000 =00001860                M curobj_size	=	curobj_size+_objsize
00000000 =00000041                M curobj	=	curobj+1
00000000 =FFFFB5B4                M robj_41	rs.b	_objsize
00000000 =000018C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000042                M curobj	=	curobj+1
00000000 =FFFFB614                M robj_42	rs.b	_objsize
00000000 =00001920                M curobj_size	=	curobj_size+_objsize
00000000 =00000043                M curobj	=	curobj+1
00000000 =FFFFB674                M robj_43	rs.b	_objsize
00000000 =00001980                M curobj_size	=	curobj_size+_objsize
00000000 =00000044                M curobj	=	curobj+1
00000000 =FFFFB6D4                M robj_44	rs.b	_objsize
00000000 =000019E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000045                M curobj	=	curobj+1
00000000 =FFFFB734                M robj_45	rs.b	_objsize
00000000 =00001A40                M curobj_size	=	curobj_size+_objsize
00000000 =00000046                M curobj	=	curobj+1
00000000 =FFFFB794                M robj_46	rs.b	_objsize
00000000 =00001AA0                M curobj_size	=	curobj_size+_objsize
00000000 =00000047                M curobj	=	curobj+1
00000000 =FFFFB7F4                M robj_47	rs.b	_objsize
00000000 =00001B00                M curobj_size	=	curobj_size+_objsize
00000000 =00000048                M curobj	=	curobj+1
00000000 =FFFFB854                M robj_48	rs.b	_objsize
00000000 =00001B60                M curobj_size	=	curobj_size+_objsize
00000000 =00000049                M curobj	=	curobj+1
00000000 =FFFFB8B4                M robj_49	rs.b	_objsize
00000000 =00001BC0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004A                M curobj	=	curobj+1
00000000 =FFFFB914                M robj_4a	rs.b	_objsize
00000000 =00001C20                M curobj_size	=	curobj_size+_objsize
00000000 =0000004B                M curobj	=	curobj+1
00000000 =FFFFB974                M robj_4b	rs.b	_objsize
00000000 =00001C80                M curobj_size	=	curobj_size+_objsize
00000000 =0000004C                M curobj	=	curobj+1
00000000 =FFFFB9D4                M robj_4c	rs.b	_objsize
00000000 =00001CE0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004D                M curobj	=	curobj+1
00000000 =FFFFBA34                M robj_4d	rs.b	_objsize
00000000 =00001D40                M curobj_size	=	curobj_size+_objsize
00000000 =0000004E                M curobj	=	curobj+1
00000000 =FFFFBA94                M robj_4e	rs.b	_objsize
00000000 =00001DA0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004F                M curobj	=	curobj+1
00000000 =FFFFBAF4                M robj_4f	rs.b	_objsize
00000000 =00001E00                M curobj_size	=	curobj_size+_objsize
00000000 =00000050                M curobj	=	curobj+1
00000000 =FFFFBB54                M robj_50	rs.b	_objsize
00000000 =00001E60                M curobj_size	=	curobj_size+_objsize
00000000 =00000051                M curobj	=	curobj+1
00000000 =FFFFBBB4                M robj_51	rs.b	_objsize
00000000 =00001EC0                M curobj_size	=	curobj_size+_objsize
00000000 =00000052                M curobj	=	curobj+1
00000000 =FFFFBC14                M robj_52	rs.b	_objsize
00000000 =00001F20                M curobj_size	=	curobj_size+_objsize
00000000 =00000053                M curobj	=	curobj+1
00000000 =FFFFBC74                M robj_53	rs.b	_objsize
00000000 =00001F80                M curobj_size	=	curobj_size+_objsize
00000000 =00000054                M curobj	=	curobj+1
00000000 =FFFFBCD4                M robj_54	rs.b	_objsize
00000000 =00001FE0                M curobj_size	=	curobj_size+_objsize
00000000 =00000055                M curobj	=	curobj+1
00000000 =FFFFBD34                M robj_55	rs.b	_objsize
00000000 =00002040                M curobj_size	=	curobj_size+_objsize
00000000 =00000056                M curobj	=	curobj+1
00000000 =FFFFBD94                M robj_56	rs.b	_objsize
00000000 =000020A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000057                M curobj	=	curobj+1
00000000 =FFFFBDF4                M robj_57	rs.b	_objsize
00000000 =00002100                M curobj_size	=	curobj_size+_objsize
00000000 =00000058                M curobj	=	curobj+1
00000000 =FFFFBE54                M robj_58	rs.b	_objsize
00000000 =00002160                M curobj_size	=	curobj_size+_objsize
00000000 =00000059                M curobj	=	curobj+1
00000000 =FFFFBEB4                M robj_59	rs.b	_objsize
00000000 =000021C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005A                M curobj	=	curobj+1
00000000 =FFFFBF14                M robj_5a	rs.b	_objsize
00000000 =00002220                M curobj_size	=	curobj_size+_objsize
00000000 =0000005B                M curobj	=	curobj+1
00000000 =FFFFBF74                M robj_5b	rs.b	_objsize
00000000 =00002280                M curobj_size	=	curobj_size+_objsize
00000000 =0000005C                M curobj	=	curobj+1
00000000 =FFFFBFD4                M robj_5c	rs.b	_objsize
00000000 =000022E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005D                M curobj	=	curobj+1
00000000 =FFFFC034                M robj_5d	rs.b	_objsize
00000000 =00002340                M curobj_size	=	curobj_size+_objsize
00000000 =0000005E                M curobj	=	curobj+1
00000000 =FFFFC094                M robj_5e	rs.b	_objsize
00000000 =000023A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005F                M curobj	=	curobj+1
00000000 =FFFFC0F4                M robj_5f	rs.b	_objsize
00000000 =00002400                M curobj_size	=	curobj_size+_objsize
00000000 =00000060                M curobj	=	curobj+1
00000000 =FFFFC154                  objMemory_End	rs.b	0
00000000                            
00000000 =00000060                  OBJECT_COUNT	equ	(objMemory_End-objMemory)/_objSize
00000000                            
00000000 =FFFFC154                  objExecute	rs.b	0				; Object execution list variables (DO NOT REARRANGE THE ORDER OF THESE!)
00000000 =FFFFC154                  objExecExit	rs.l	1				; Pointer to a return intstruction that will exit object execution
00000000 =FFFFC158                  objExecFirst	rs.w	1				; Pointer to the first object to be executed in the list
00000000 =FFFFC15A                  objExecLast	rs.w	1				; Pointer to the last object to be executed in the list
00000000 =FFFFC15C                  objExecFree	rs.w	1				; Pointer to the next free slot in object memory
00000000 =FFFFC15E                  objExecute_End	rs.b	0
00000000                            
00000000 =FFFFC15A                  objDisplay	equ __rs-dnext
00000000                            		rs.b	dSize*8				; Sprite display input list (8 priority levels)
00000000 =FFFFC19E                  objDisplay_End	rs.b	0				; 
00000000                            
00000000 =FFFFC19E                  fgRowBuff	rs.b	$102				; Foreground horizontal plane buffer
00000000 =FFFFC2A0                  fgColBuff	rs.b	$82				; Foreground vertical plane buffer
00000000 =FFFFC322                  bgRowBuff	rs.b	$102				; Background horizontal plane buffer
00000000 =FFFFC424                  bgColBuff	rs.b	$82				; Background vertical plane buffer
00000000                            
00000000 =FFFFC4A6                  ampsVars		rs.b	0			; AMPS variables
00000000                            		include	"Sound/amps/code/ram.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =FFFFC4A6                  mFlags		rs.b 1		; various driver flags, see below
00000000 =FFFFC4A7                  mCtrPal		rs.b 1		; frame counter fo 50hz fix
00000000 =FFFFC4A8                  mVctSFX		rs.l 1		; address of voice table for sfx
00000000 =FFFFC4AC                  mComm		rs.b 8		; communications bytes
00000000 =FFFFC4B4                  mMasterVolFM	rs.b 0		; master volume for FM channels
00000000 =FFFFC4B4                  mFadeAddr	rs.l 1		; fading program address
00000000 =FFFFC4B8                  mTempoMain	rs.b 1		; music normal tempo
00000000 =FFFFC4B9                  mTempoSpeed	rs.b 1		; music speed shoes tempo
00000000 =FFFFC4BA                  mTempo		rs.b 1		; current tempo we are using right now
00000000 =FFFFC4BB                  mTempoCur	rs.b 1		; tempo counter/accumulator
00000000 =FFFFC4BC                  mQueue		rs.b 3		; sound queue
00000000 =FFFFC4BF                  mMasterVolPSG	rs.b 1		; master volume for PSG channels
00000000 =FFFFC4C0                  mMasterVolDAC	rs.b 1		; master volume for DAC channels
00000000 =FFFFC4C1                  mSpindash	rs.b 1		; spindash rev counter
00000000 =FFFFC4C2                  mContCtr	rs.b 1		; continous sfx loop counter
00000000 =FFFFC4C3                  mContLast	rs.b 1		; last continous sfx played
00000000                            		rs.w 0		; align channel data
00000000                            
00000000 =FFFFC4C4                  mDAC1		rs.b cSize	; DAC 1 data
00000000 =FFFFC4F0                  mDAC2		rs.b cSize	; DAC 2 data
00000000 =FFFFC51C                  mFM1		rs.b cSize	; FM 1 data
00000000 =FFFFC548                  mFM2		rs.b cSize	; FM 2 data
00000000 =FFFFC574                  mFM3		rs.b cSize	; FM 3 data
00000000 =FFFFC5A0                  mFM4		rs.b cSize	; FM 4 data
00000000 =FFFFC5CC                  mFM5		rs.b cSize	; FM 5 data
00000000 =FFFFC5F8                  mPSG1		rs.b cSize	; PSG 1 data
00000000 =FFFFC624                  mPSG2		rs.b cSize	; PSG 2 data
00000000 =FFFFC650                  mPSG3		rs.b cSize	; PSG 3 data
00000000 =FFFFC67C                  mSFXDAC1	rs.b cSizeSFX	; SFX DAC 1 data
00000000 =FFFFC698                  mSFXFM3		rs.b cSizeSFX	; SFX FM 3 data
00000000 =FFFFC6B4                  mSFXFM4		rs.b cSizeSFX	; SFX FM 4 data
00000000 =FFFFC6D0                  mSFXFM5		rs.b cSizeSFX	; SFX FM 5 data
00000000 =FFFFC6EC                  mSFXPSG1	rs.b cSizeSFX	; SFX PSG 1 data
00000000 =FFFFC708                  mSFXPSG2	rs.b cSizeSFX	; SFX PSG 2 data
00000000 =FFFFC724                  mSFXPSG3	rs.b cSizeSFX	; SFX PSG 3 data
00000000                            
00000000 =FFFFC740                  msChktracker	rs.b 1		; safe mode only: If set, bring up debugger
00000000                            		rsEven
00000000                          M 	rs.b	__rs&1
00000000 =FFFFC742                  mSize		rs.w 0		; end of the driver RAM
00000000                            ; ===========================================================================
00000000                            
00000000                            		; --- ENGINE VARIABLES ---
00000000                            
00000000 =FFFFC742                  ctrlDataP1	rs.b	0				; Controller 1 data
00000000 =FFFFC742                  ctrlHoldP1	rs.b	1				; Controller 1 held button data
00000000 =FFFFC743                  ctrlPressP1	rs.b	1				; Controller 1 pressed button data
00000000                            
00000000 =FFFFC744                  ctrlDataP2	rs.b	0				; Controller 2 data
00000000 =FFFFC744                  ctrlHoldP2	rs.b	1				; Controller 2 held button data
00000000 =FFFFC745                  ctrlPressP2	rs.b	1				; Controller 2 pressed button data
00000000                            
00000000 =FFFFC746                  hwVersion	rs.b	1				; Hardware version
00000000 =FFFFC747                  vIntFlag	rs.b	0				; V-INT flag
00000000 =FFFFC747                  vIntRoutine	rs.b	1				; V-INT routine
00000000                            
00000000 =FFFFC748                  palFadeVars	rs.b	0				; Palette fade properties
00000000 =FFFFC748                  palFadeStart	rs.b	1				; Palette fade start index
00000000 =FFFFC749                  palFadeLength	rs.b	1				; Palette fade size
00000000 =FFFFC74A                  palFadeVars_End	rs.b	0
00000000                            
00000000 =FFFFC74A                  lagCounter	rs.b	1				; Lag frame counter
00000000 =FFFFC74B                  hIntFlag	rs.b	1				; H-INT run flag
00000000                            
00000000 =FFFFC74C                  vIntJump	rs.w	1				; Header will point here for V-INT
00000000 =FFFFC74E                  vIntAddress	rs.l	1				; V-INT address
00000000                            
00000000 =FFFFC752                  hIntJump	rs.w	1				; Header will point here for H-INT
00000000 =FFFFC754                  hIntAddress	rs.l	1				; H-INT address
00000000                            
00000000 =FFFFC758                  frameCounter	rs.l	1				; Frame counter
00000000                            
00000000 =FFFFC75C                  opmode		rs.b	1				; Game opmode ID
00000000 =FFFFC75D                  spriteCount	rs.b	1				; Sprite count
00000000 =FFFFC75E                  pauseFlag	rs.b	1				; Pause flag
00000000 =FFFFC75F                  hIntUpdates	rs.b	1				; Level updates in H-INT flag
00000000                            
00000000 =FFFFC760                  hIntCounter	rs.b	0
00000000 =FFFFC760                  hIntCntReg	rs.b	1				; H-INT counter register
00000000 =FFFFC761                  hIntCntValue	rs.b	1				; H-INT counter value
00000000                            
00000000 =FFFFC762                  randomSeed	rs.l	1				; RNG seed
00000000                            
00000000 =FFFFC766                  vdpReg1		rs.w	1				; VDP register 1 register ID and value
00000000 =FFFFC768                  vdpWindowY	rs.w	1				; Window Y position (VDP register)
00000000                            
00000000 =FFFFC76A                  moveCheat	rs.b	1
00000000 =FFFFC76B                  artCheat	rs.b	1
00000000                            
00000000 =FFFFC76C                  oscillators	rs.b	0				; Oscillation numbers
00000000 =FFFFC76C                  oscControl	rs.w	1				; Oscillation control
00000000 =FFFFC76E                  oscValues	rs.w	$20				; Oscialltion data
00000000 =FFFFC7AE                  oscillators_End	rs.b	0				; ''
00000000                            
00000000                            		; --- GLOBAL VARIABLES ---
00000000                            
00000000 =FFFFC7AE                  levelID		rs.b	0				; Level ID
00000000 =FFFFC7AE                  zoneID		rs.b	1				; Zone ID
00000000 =FFFFC7AF                  actID		rs.b	1				; Act ID
00000000                            
00000000 =FFFFC7B0                  checkpoint	rs.b	0				; Checkpoint RAM
00000000 =FFFFC7B0                  chkIDLast	rs.b	1				; Last checkpoint hit
00000000                            		rs.b	1
00000000 =FFFFC7B2                  chkSavedXPos	rs.w	1				; Saved player X position
00000000 =FFFFC7B4                  chkSavedYPos	rs.w	1				; Saved player Y position
00000000 =FFFFC7B6                  checkpoint_End	rs.b	0				; End of checkpoint RAM
00000000                            
00000000 =FFFFC7B6                  objManager	rs.b	0
00000000 =FFFFC7B6                  objMgrInit	rs.b	1				; Object manager initialized flag
00000000                            
00000000 =FFFFC7B7                  rStartFall	rs.b	1				; Start level by falling flag
00000000                            
00000000 =FFFFC7B8                  objMgrLayout	rs.l	1				; Object position data pointer
00000000 =FFFFC7BC                  objMgrLoadR	rs.l	1				; Object data address (for going right)
00000000 =FFFFC7C0                  objMgrLoadL	rs.l	1				; Object data address (for going left)
00000000 =FFFFC7C4                  objMgrRespR	rs.w	1				; Object respawn address (for going right)
00000000 =FFFFC7C6                  objMgrRespL	rs.w	1				; Object respawn address (for going left)
00000000 =FFFFC7C8                  objMgrCoarseX	rs.w	1				; Object manager's coarse X position
00000000 =FFFFC7CA                  objMgrCoarseY	rs.w	1				; Object manager's coarse Y position
00000000 =FFFFC7CC                  objMgrCameraX	rs.w	1				; Object manager's camera X position
00000000 =FFFFC7CE                  objMgrCameraY	rs.w	1				; Object manager's camera Y position
00000000 =FFFFC7D0                  objManager_End	rs.b	0
00000000                            
00000000 =FFFFC7D0                  palCycTimer	rs.b	1				; Palette cycle timer
00000000 =FFFFC7D1                  palCycIndex	rs.b	1				; Palette cycle index
00000000                            
00000000                            		; --- LOCAL VARIABLES ---
00000000                            
00000000 =FFFFC7D2                  opmodeVars	rs.b	0				; Start of local game variables
00000000                            		rs.b	((-__rs)&$FFFF)-$100		; You have the rest of RAM here for local variables
00000000 =FFFFFF00                  opmodeVars_End	rs.b	0				; End of local game variables
00000000                            
00000000                            		; --- STACK SPACE ---
00000000                            
00000000 =FFFFFF00                  stackSpace	rs.b	$100				; Stack space
00000000 =00000000                  stack		rs.b	0				; ''
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Title screen variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	opmodeVars
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	opmodeVars
00000000 =FFFFC7D2                  blockData	rs.b	$1800				; Block table
00000000                            
00000000 =FFFFDFD2                  ringStatus	rs.b	$400				; Ring status table
00000000 =FFFFE3D2                  ringStatus_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE3D2                  ringCollect	rs.b	0				; Ring collection table
00000000 =FFFFE3D2                  ringColCount	rs.w	1				; Ring collection count
00000000 =FFFFE3D4                  ringColList	rs.b	$7E				; Ring collection list
00000000 =FFFFE452                  ringCollect_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE452                  scrollSects	rs.b	$384				; Scroll sections
00000000 =FFFFE7D6                  scrollSects_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE7D6                  collideList	rs.b	$80				; Collision response list
00000000 =FFFFE856                  collideList_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE856                  lvlLayout	rs.b	0				; Level layout ROM addresses
00000000 =FFFFE856                  lvlLayoutFG	rs.l	1				
00000000 =FFFFE85A                  lvlLayoutBG	rs.l	1				
00000000                            
00000000 =FFFFE85E                  ringCount	rs.w	1				; Ring count
00000000 =FFFFE860                  ringAnimFrame	rs.b	1				; Ring animation frame
00000000 =FFFFE861                  ringAnimTime	rs.b	1				; Ring animation timer
00000000                            
00000000 =FFFFE862                  ringLossAnimA	rs.w	1
00000000 =FFFFE864                  ringLossAnimT	rs.b	1
00000000 =FFFFE865                  ringLossAnimF	rs.b	1
00000000                            
00000000 =FFFFE866                  ringMgrRoutine	rs.b	1				; Ring manager routine
00000000 =FFFFE867                  hudUpdateRings	rs.b	1				; Update Ring counter in the HUD flag
00000000                            
00000000 =FFFFE868                  ringMgrLayout	rs.l	1				; Ring position data pointer
00000000 =FFFFE86C                  ringMgrLoadL	rs.l	1				; Ring data address for the left side of the screen
00000000 =FFFFE870                  ringMgrLoadR	rs.l	1				; Ring data address for the right side of the screen
00000000 =FFFFE874                  ringMgrStatPtr	rs.w	1				; Ring status address
00000000                            
00000000 =FFFFE876                  playerPtrP1	rs.w	1				; Player 1 object address
00000000 =FFFFE878                  shieldPtrP1	rs.w	1				; Player 1 shield address
00000000 =FFFFE87A                  invincPtrP1	rs.w	1				; Player 1 invincibility address
00000000 =FFFFE87C                  afterImgPtrP1	rs.w	1				; Player 1 after image address
00000000                            
00000000 =FFFFE87E                  playerPtrP2	rs.w	1				; Player 2 object address
00000000 =FFFFE880                  shieldPtrP2	rs.w	1				; Player 2 shield address
00000000 =FFFFE882                  invincPtrP2	rs.w	1				; Player 2 invincibility address
00000000 =FFFFE884                  afterImgPtrP2	rs.w	1				; Player 2 after image address
00000000                            
00000000 =FFFFE886                  waterObjPtr1	rs.w	1				; Water surface 1 address
00000000 =FFFFE888                  waterObjPtr2	rs.w	1				; Water surface 2 address
00000000                            
00000000 =FFFFE88A                  cameraVars	rs.b	0				; Camera RAM
00000000 =FFFFE88A                  fgCamVars	rs.b	cSize2				; Foreground variables
00000000 =FFFFE8A8                  bgCamVars	rs.b	cSize2				; Background variables
00000000                            
00000000 =FFFFE8C6                  targetMaxCamPos	rs.b	0				; Target maximum camera positions
00000000 =FFFFE8C6                  targetMaxCamX	rs.w	1				; Target maximum camera X position
00000000 =FFFFE8C8                  targetMaxCamY	rs.w	1				; Target maximum camera Y position
00000000                            
00000000 =FFFFE8CA                  maxCamPos	rs.b	0				; Maximum camera positions
00000000 =FFFFE8CA                  maxCamXPos	rs.w	1				; Maximum camera X position
00000000 =FFFFE8CC                  maxCamYPos	rs.w	1				; Maximum camera Y position
00000000                            
00000000 =FFFFE8CE                  targetMinCamPos	rs.b	0				; Target minimum camera positions
00000000 =FFFFE8CE                  targetMinCamX	rs.w	1				; Target minimum camera X position
00000000 =FFFFE8D0                  targetMinCamY	rs.w	1				; Target minimum camera Y position
00000000                            
00000000 =FFFFE8D2                  minCamPos	rs.b	0				; Minimum camera positions
00000000 =FFFFE8D2                  minCamXPos	rs.w	1				; Minimum camera X position
00000000 =FFFFE8D4                  minCamYPos	rs.w	1				; Minimum camera Y position
00000000                            
00000000 =FFFFE8D6                  panCamPos	rs.b	0
00000000 =FFFFE8D6                  panCamXPos	rs.w	1				; Camera X center
00000000 =FFFFE8D8                  panCamYPos	rs.w	1				; Distance from the player's Y position and the camera's
00000000                            
00000000 =FFFFE8DA                  camLocked	rs.b	0				; Camera locked flags
00000000 =FFFFE8DA                  camLockX	rs.b	1				; Camera locked horizontally flag
00000000 =FFFFE8DB                  camLockY	rs.b	1				; Camera locked vertically flag
00000000                            
00000000 =FFFFE8DC                  chgCamMaxY	rs.b	1				; Camera max Y position changing flag
00000000 =FFFFE8DD                  cameraVars_End	rs.b	0				; End of camera RAM
00000000                            
00000000 =FFFFE8DD                  debugMode	rs.b	1				; Debug placement mode
00000000                            
00000000 =FFFFE8DE                  plrCtrlData	rs.b	0				; Player control data
00000000 =FFFFE8DE                  plrCtrlHold	rs.b	1				; Player control held button data
00000000 =FFFFE8DF                  plrCtrlPress	rs.b	1				; Player control pressed button data
00000000                            
00000000 =FFFFE8E0                  lvlMusic	rs.b	1				; Level music ID
00000000 =FFFFE8E1                  bossMusic	rs.b	1				; Boss music ID
00000000                            
00000000 =FFFFE8E2                  primaryColPtr	rs.l	1				; Primary level collision data pointer
00000000 =FFFFE8E6                  secondaryColPtr	rs.l	1				; Secondary level collision data pointer
00000000                            
00000000 =FFFFE8EA                  currentColAddr	rs.l	1				; Current collsion address
00000000                            
00000000 =FFFFE8EE                  layerPosition	rs.w	1				; Fake layer position
00000000                            
00000000 =FFFFE8F0                  angleValPtr	rs.l	1				; Angle value array pointer
00000000 =FFFFE8F4                  normColArrayPtr	rs.l	1				; Normal height map array pointer
00000000 =FFFFE8F8                  rotColArrayPtr	rs.l	1				; Rotated height map array pointer
00000000                            
00000000 =FFFFE8FC                  got_objNextLvl	rs.b	1				; Flag to go to the next level
00000000 =FFFFE8FD                  bossDefeated	rs.b	1
00000000                            
00000000 =FFFFE8FE                  lvlHasWater	rs.b	1				; Water in level flag
00000000 =FFFFE8FF                  waterFullscr	rs.b	1				; Water fullscreen flag
00000000 =FFFFE900                  waterYPos	rs.w	1				; Water height
00000000 =FFFFE902                  destWaterYPos	rs.w	1				; Target water height
00000000                            
00000000 =FFFFE904                  lvlFrameCnt	rs.w	1				; Level frame counter
00000000 =FFFFE906                  lvlReload	rs.b	1				; Level reload flag
00000000 =FFFFE907                  timeOver	rs.b	1				; Time over flag
00000000                            
00000000 =FFFFE908                  dynEventRout	rs.b	1				; Dynamic event routine ID
00000000                            
00000000 =FFFFE909                  rFlooactIDive	rs.b	1				; Floor active flag
00000000 =FFFFE90A                  rFloorTimer	rs.w	1				; Floor timer
00000000                            
00000000 =FFFFE90C                  lvlAnimCntrs	rs.b	$10				; Level art animation counters
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Camera variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFE88A                  fgCamXPos	equ	fgCamVars+cXPos			; Camera X position
00000000 =FFFFE892                  fgCamYPos	equ	fgCamVars+cYPos			; Camera Y position
00000000 =FFFFE8A8                  bgCamXPos	equ	bgCamVars+cXPos			; Background camera X position
00000000 =FFFFE8B0                  bgCamYPos	equ	bgCamVars+cYPos			; Background camera Y position
00000000 =FFFFE8A6                  fgRedraw	equ	fgCamVars+cRedraw		; Foreground redraw flag
00000000 =FFFFE8C4                  bgRedraw	equ	bgCamVars+cRedraw		; Background redraw flag
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Variables for the vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFC74C                  vInterrupt	equ	vIntJump			; V-INT
00000000 =FFFFC752                  hInterrupt	equ	hIntJump			; H-INT
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Config/Error/debugger.asm"	; Debugger macro set
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000001                  isAMPS =		1		; Set to 1
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dem		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000DF                  fstr		equ		$DF				; flag to display as string (treat as offset, insert string from that offset)
00000000 =000000D0                  fasm		equ		$D0				; flag to display as code (treat as offset, decode from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            ;	* The "asm" flag will use "setpat" flag to switch text color, and will reset pattern to normal again.
00000000                            ;		you must reapply any pattern you used before yourself.
00000000                            ;	* The "asm" flag will overwrite $FF0000-$FF0080, so be careful when viewing RAM.
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  fsplit	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  fendl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  fpal0	equ		$E8				; use palette line #0
00000000 =000000EA                  fpal1	equ		$EA				; use palette line #1
00000000 =000000EC                  fpal2	equ		$EC				; use palette line #2
00000000 =000000EE                  fpal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            	pea		*(pc)
00000000                            	RaiseError2 \_
00000000                            	endm
00000000                            
00000000                            RaiseError2 &
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea	4*4(sp), a2
00000000                            		endc
00000000                            		lea	.str\@(pc), a1
00000000                            		jsr	ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea	__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	.instr_end\@
00000000                            	.str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	.instr_end\@:
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr	ErrorHandler.__extern__console_only
00000000                            		jsr	\1
00000000                            		if narg<=1		; HACK
00000000                            			bra.s	*
00000000                            		endif
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr	ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	while (__pos)
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            	endm
00000000                            		
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Header.asm"
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Based on MarkeyJester's shortened header and initialization
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Store a string in memory with a character limit (also pads to that limit if it doesn't exceed it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string	- The string
00000000                            ;	limit	- character limit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            headStr		macro	string, limit
00000000                            		local	p
00000000                            p =		*
00000000                            		dcb.b	\limit, " "
00000000                            		org	p
00000000                            		dc.b	\string
00000000                            		org	p+\limit
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		org	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 F0A1 000C                  		dc.l	($F0<<24)|PORT_C_CTRL-1		; Stack pointer (set like so for initialization routine) (also manufacture lineF exception)
00000004                            
00000004 0000 0000                  		dc.l	.PrgInit			; Entry pointer
00000008                            
00000008 0000 0000                  		dc.l	exBus				; Bus error
0000000C 0000 0000                  		dc.l	exAddr				; Address error
00000010 0000 0000                  		dc.l	exIll				; Illegal instruction error
00000014 0000 0000                  		dc.l	exDiv				; Division by zero error
00000018 0000 0000                  		dc.l	exChk				; CHK out of bounds error
0000001C 0000 0000                  		dc.l	Trapv				; TRAPV interrupt
00000020 0000 0000                  		dc.l	exPriv				; Privilege violation error
00000024 0000 0000                  		dc.l	exTrace				; TRACE interrupt
00000028 0000 0000                  		dc.l	exLineA				; Line A emulation
0000002C 0000 0000                  		dc.l	exLineF				; Line F emulation
00000030                            
00000030 0017                       .InitVals:	dc.w	$18-1				; Number of registers to set up
00000032 8004                       		dc.w	$8004				; VDP register base (preset for register 0 - H-INT disabled)
00000034 0100                       		dc.w	$100				; Register increment (also used for Z80 later)
00000036                            
00000036 34                         		dc.b	$34				; DMA enabled, V-INT enabled
00000037 30                         		dc.b	$C000/$400			; Plane A at $C000
00000038 34                         		dc.b	$D000/$400			; Plane W at $D000
00000039 07                         		dc.b	$E000/$2000			; Plane B at $E000
0000003A 7C                         		dc.b	$F800/$200			; Sprite table at $F800
0000003B 00                         		dc.b	$00				; Unused
0000003C 00                         		dc.b	$00				; BG color line 0 entry 0
0000003D 00                         		dc.b	$00				; Unused
0000003E 00                         		dc.b	$00				; Unused
0000003F FF                         		dc.b	$FF				; H-INT every 255th line
00000040 00                         		dc.b	$00				; EXT-INT off, VScroll by screen, HScroll by screen
00000041 81                         		dc.b	$81				; H40 width, interalce disabled, S/H disabled
00000042 3F                         		dc.b	$FC00/$400			; HScroll table at $FC00
00000043 00                         		dc.b	$00				; Unused
00000044 02                         		dc.b	$02				; Autoincrement by 2
00000045 01                         		dc.b	$01				; Plane size 64x32
00000046 00                         		dc.b	$00				; Disable window
00000047 00                         		dc.b	$00				; ''
00000048 FF                         		dc.b	$FF				; DMA length $FFFF
00000049 FF                         		dc.b	$FF				; ''
0000004A 00                         		dc.b	$00				; DMA source 0
0000004B 00                         		dc.b	$00				; ''
0000004C 80                         		dc.b	$80				; '' + VRAM fill mode
0000004D                            
0000004D 40                         		dc.b	$40				; Port initialization value
0000004E                            
0000004E                            		vdpCmd	dc.l,0,VRAM,DMA			; VDP DMA at $0000
0000004E 4000 0080                M 	dc.l	((((vram&dma)&3)<<30)|((0&$3fff)<<16)|(((vram&dma)&$fc)<<2)|((0&$c000)>>14))
00000052                            
00000052 000E 1FFD                  		dc.w	$E, $2000-2-1			; Checksum error color, amount of Z80 to clear
00000056 00A0 0000                  		dc.l	Z80_RAM				; Z80 RAM
0000005A 00A1 1100                  		dc.l	Z80_BUS_REQ			; Z80 bus request
0000005E 00A1 1200                  		dc.l	Z80_RESET			; Z80 reset
00000062                            
00000062                            		vdpCmd	dc.l,0,CRAM,WRITE		; CRAM WRITE at $0000
00000062 C000 0000                M 	dc.l	((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14))
00000066                            		vdpCmd	dc.l,0,VSRAM,WRITE		; VSRAM WRITE at $0000
00000066 4000 0010                M 	dc.l	((((vsram&write)&3)<<30)|((0&$3fff)<<16)|(((vsram&write)&$fc)<<2)|((0&$c000)>>14))
0000006A                            
0000006A 9FBF DFFF                  		dc.b	$9F, $BF, $DF, $FF		; PSG mute values
0000006E                            
0000006E F3C3                       		dc.b	$F3, $C3			; di and jp instructions for Z80
00000070                            
00000070 FFFF C752                  		dc.l	hInterrupt			; Horizontal interrupt
00000074 00C0 0000                  .VDPDPort:	dc.l	VDP_DATA			; Interrupt level 5
00000078 FFFF C74C                  		dc.l	vInterrupt			; Vertical interrupt
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ; Program initialization
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ICD_BLK		EQU	.PrgInit
0000007C                            .PrgInit:
0000007C                            		intsOff
0000007C 007C 0700                M 	ori	#$700,sr
00000080                            
00000080                            		; --- CHECK WARM BOOT ---
00000080                            
00000080 4A57                       		tst.w	(sp)				; Has port C been initialized already?
00000082 6600 0000                  		bne.w	.WarmBoot			; If so, branch
00000086                            
00000086 7800                       		moveq	#0,d4				; Register that holds 0
00000088 7C00                       		moveq	#0,d6				; Checksum value
0000008A                            
0000008A                            		; --- CHECK TMSS ---
0000008A                            
0000008A 162F FFF5                  		move.b	-$B(sp),d3			; Get hardware version
0000008E E903                       		asl.b	#4,d3				; ''
00000090 6700                       		beq.s	.NoTMSS				; If this is a non-TMSS system, branch
00000092 2F78 0100 3FF4             		move.l	$100.w,$3FF4(sp)		; Satisfy the TMSS
00000098                            
00000098                            .NoTMSS:
00000098                            
00000098                            		; --- SET UP VDP REGISTERS ---
00000098                            
00000098 2A78 0074                  		movea.l	.VDPDPort.w,a5			; VDP data port
0000009C 4DED 0004                  		lea	4(a5),a6			; VDP control port
000000A0                            
000000A0                            .WaitDMA:
000000A0 44D6                       		move.w	(a6),ccr			; Load status
000000A2 69FC                       		bvs.s	.WaitDMA			; If there's a DMA, wait
000000A4                            
000000A4 41F8 0030                  		lea	.InitVals.w,a0			; VDP registers
000000A8 4C98 0026                  		movem.w	(a0)+,d1/d2/d5			; Get number of entries, register base, and register increment
000000AC                            
000000AC                            .InitVDPRegs:
000000AC 3C82                       		move.w	d2,(a6)				; Set register data
000000AE D445                       		add.w	d5,d2				; Next register
000000B0 1418                       		move.b	(a0)+,d2			; Get register data
000000B2 51C9 FFF8                  		dbf	d1,.InitVDPRegs			; Loop
000000B6                            
000000B6                            		; --- CLEAR VRAM ---
000000B6                            
000000B6 2C98                       		move.l	(a0)+,(a6)			; Set DMA fill destination
000000B8 3C84                       		move.w	d4,(a6)				; Set DMA fill value
000000BA                            
000000BA                            		; --- CLEAR RAM ---
000000BA                            
000000BA 2444                       		movea.l	d4,a2				; End of RAM
000000BC 323C 3FFF                  		move.w	#(RAM_END-RAM_START)>>2-1,d1	; Longwords to clear
000000C0                            
000000C0                            .ClearRAM:
000000C0 2504                       		move.l	d4,-(a2)			; Clear RAM
000000C2 51C9 FFFC                  		dbf	d1,.ClearRAM			; Loop
000000C6                            
000000C6                            		; --- SET UP FOR Z80 ---
000000C6                            
000000C6 4CD8 1A01                  		movem.l	(a0)+,d0/a1/a3/a4		; Load Z80 addresses and values
000000CA 3685                       		move.w	d5,(a3)				; Request Z80 stop
000000CC                            
000000CC                            		; --- CLEAR CRAM AND VSRAM AND INITIALIZE JOYPADS ---
000000CC                            
000000CC 4441                       		neg.w	d1				; Run the next bit 2 times
000000CE                            
000000CE                            .InitVDPJoypads:
000000CE 2C98                       		move.l	(a0)+,(a6)			; Set VDP command
000000D0 761F                       		moveq	#$80>>2-1,d3			; Longwords to clear
000000D2                            
000000D2                            .ClearVDPMem:
000000D2 2A84                       		move.l	d4,(a5)				; Clear memory
000000D4 51CB FFFC                  		dbf	d3,.ClearVDPMem			; Loop
000000D8 3F02                       		move.w	d2,-(sp)			; Initialize port
000000DA 51C9 FFF2                  		dbf	d1,.InitVDPJoypads		; Loop
000000DE                            
000000DE 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
000000E0                            
000000E0                            		; --- MUTE PSG ---
000000E0                            
000000E0 7603                       		moveq	#4-1,d3				; Number of PSG channels
000000E2                            
000000E2                            .MutePSG:
000000E2 1D58 000D                  		move.b	(a0)+,$D(a6)			; Mute channel
000000E6 51CB FFFA                  		dbf	d3,.MutePSG			; Loop
000000EA                            
000000EA                            		; --- INITIALIZE Z80 ---
000000EA                            
000000EA 12D8                       		move.b	(a0)+,(a1)+			; Write di (disable Z80 interrupts)
000000EC 12D8                       		move.b	(a0)+,(a1)+			; Write jp (Will end up just looping forever at the beginning)
000000EE                            
000000EE                            .ClearZ80:
000000EE 12C4                       		move.b	d4,(a1)+			; Clear Z80
000000F0 51C8 FFFC                  		dbf	d0,.ClearZ80			; Loop
000000F4                            
000000F4 3884                       		move.w	d4,(a4)				; Reset the Z80
000000F6                            
000000F6                            		; --- CHECK THE CHECKSUM ---
000000F6                            
000000F6 41F8 0200                  		lea	$200.w,a0			; Start reading data at the end of the header
000000FA 2238 01A4                  		move.l	$1A4.w,d1			; Get ROM end address
000000FE                            
000000FE 6000                       		bra.s	.ChkChecksum			; Continue
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100                            ; Header
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100 5345 4741                  		dc.b	"SEGA"				; Hardware system ID
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            ; Program initialization (part 2)
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            .ChkChecksum:
00000104 DC58                       		add.w	(a0)+,d6			; Add ROM data to the checksum value
00000106 B288                       		cmp.l	a0,d1				; Are we at the end of the ROM?
00000108 64FA                       		bcc.s	.ChkChecksum			; If not, keep adding
0000010A BC78 018E                  		cmp.w	$18E.w,d6			; Is the checksum correct?
0000010E 6700                       		beq.s	.ChksumPassed			; If not, branch
00000110                            
00000110                            .ChksumError:
00000110                            		vdpCmd	move.l,0,CRAM,WRITE,(a6)	; Set background to red
00000110 2CBC C000 0000           M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),(a6)
00000116 2A80                       		move.l	d0,(a5)				; ''
00000118 60F6                       		bra.s	.ChksumError			; Loop here forever
0000011A                            
0000011A                            .ChksumPassed:
0000011A 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
0000011C 3684                       		move.w	d4,(a3)				; Start the Z80
0000011E                            
0000011E                            		; --- FINISH I/O INITIALIZATION ---
0000011E                            
0000011E 3F42 0004                  		move.w	d2,4(sp)			; Initialize port C
00000122                            
00000122                            .WarmBoot:
00000122 4FF8 0000                  		lea	stack.w,sp		; Set the stack pointer
00000126 4CD4 7FFF                  		movem.l	(a4),d0-a6			; Clear registers
0000012A                            
0000012A 4EF9 0000 0000             		jmp	GameInit			; Go to the game initialization
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            ; Header (part 2)
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            		headStr	"\NOTES", $20			; Notes
00000130                          M 	local	p
00000130 =00000130                M p	=	*
00000130 2020 2020 2020 2020 2020+M 	dcb.b	$20," "
00000150                          M 	org	p
00000130                          M 	dc.b	""
00000130                          M 	org	p+$20
00000150                            		headStr	"\GAME_NAME", $30		; International game name
00000150                          M 	local	p
00000150 =00000150                M p	=	*
00000150 2020 2020 2020 2020 2020+M 	dcb.b	$30," "
00000180                          M 	org	p
00000150 4865 6467 6562 7265 7720+M 	dc.b	"Hedgebrew Engine Project                        "
00000180                          M 	org	p+$30
00000180 474D 2030 3030 3030 3030+  		dc.b	"GM 00000000-00"		; Version
0000018E 0000                       		dc.w	0				; Checksum value (replaced by external program)
00000190                            		headStr	"\IO_SUPPORT", $10		; I/O support
00000190                          M 	local	p
00000190 =00000190                M p	=	*
00000190 2020 2020 2020 2020 2020+M 	dcb.b	$10," "
000001A0                          M 	org	p
00000190 4A                       M 	dc.b	"J"
00000191                          M 	org	p+$10
000001A0 0000 0000 003F FFFF        		dc.l	ROM_START, ROM_END-1		; ROM start and end addresses (replaced by external program)
000001A8 00FF 0000 00FF FFFF        		dc.l	RAM_START, RAM_END-1		; RAM start and end addresses
000001B0 2020 2020                  		dc.l	SRAM_SUPPORT			; SRAM support
000001B4 2020 2020 2020 2020        		dc.l	SRAM_START, SRAM_END		; SRAM start and end addresses
000001BC                            ; =========================================================================================================================================================
000001BC                            
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Entry point
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            GameInit:
000001BC                            		intsOff						; Disable interrupts
000001BC 007C 0700                M 	ori	#$700,sr
000001C0                            		
000001C0                            		clrRAM	RAM_START, RAM_END			; Clear RAM
000001C0                          M 	local	endaddr
000001C0                          M endaddr	equs	"ram_end"
000001C0 7000                     M 	moveq	#0,d0
000001C2 43F9 00FF 0000           M 	lea	ram_start,a1
000001C8 323C 3FFF                M 	move.w	#(((ram_end)-(ram_start))-((ram_start)&1))>>2-1,d1
000001CC 22C0                     M .clear_22:	move.l	d0,(a1)+
000001CE 51C9 FFFC                M 	dbf	d1,.clear_22
000001D2                            		
000001D2 6100 0000                  		bsr.w	InitDMAQueue				; Initialize the DMA queue
000001D6 6100 0000                  		bsr.w	InitVDP					; Initialize the VDP
000001DA 4EB9 0000 0000             		jsr	LoadDualPCM				; Load Dual PCM
000001E0                            		
000001E0 1039 00A1 0001             		move.b	HW_VERSION,d0				; Get hardware version
000001E6 0200 00C0                  		andi.b	#$C0,d0					; Just get region bits
000001EA 11C0 C746                  		move.b	d0,hwVersion.w				; Store in RAM
000001EE                            
000001EE 303C 4EF9                  		move.w	#$4EF9,d0				; JMP opcode
000001F2 31C0 C74C                  		move.w	d0,vIntJump.w				; Set the "JMP" command for V-INT
000001F6 31C0 C752                  		move.w	d0,hIntJump.w				; Set the "JMP" command for H-INT
000001FA 21FC 0000 0000 C74E        		move.l	#VInt_Standard,vIntAddress.w		; Set the V-INT pointer to the standard V-INT routine
00000202 21FC 0000 0000 C754        		move.l	#HInt_Water,hIntAddress.w			; Set the H-INT pointer to the standard V-INT routine
0000020A                            
0000020A 4278 9000                  		clr.w	dmaQueue.w				; Set stop token at the beginning of the DMA queue
0000020E 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w			; Reset the DMA queue slot
00000214                            
00000214 11FC 0000 C75C             		move.b	#gTitle,opmode.w			; Set game mode to "title"
0000021A 4EF9 0000 0000             		jmp	TitleScreen					; Go to the title screen
00000220                            
00000220                            ; =========================================================================================================================================================
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            ; Go to the correct game mode
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            GotoGameMode:
00000220 7000                       		moveq	#0,d0
00000222 1038 C75C                  		move.b	opmode.w,d0				; Get game mode ID
00000226 207B 0000                  		movea.l	.GameModes(pc,d0.w),a0			; Get pointer
0000022A 4ED0                       		jmp	(a0)					; Jump to it
0000022C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000022C                            .GameModes:
0000022C 0000 0000                  		dc.l	TitleScreen				; Title screen
00000230 0000 0000                  		dc.l	Level					; Level mode
00000234 0000 0000                  		dc.l	Ending					; Ending
00000238                            
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Function libraries
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            		include	"Libraries/VDP.asm"		; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Initialize the VDP
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; PARAMETERS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; RETURNS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            InitVDP:
00000238 31FC 8134 C766             		move.w	#$8134,vdpReg1.w		; Save VDP register 1 in RAM
0000023E 31FC 8AFF C760             		move.w	#$8AFF,hIntCntReg.w		; Save H-INT counter register in RAM
00000244                            
00000244 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; Clear the screen and other VDP data (64 tile width)
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; PARAMETERS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; RETURNS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ClearScreen:
00000248 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0000024E                            		dmaFill	0,$C000,$3000			; Clear planes
0000024E 3CBC 8F01                M 	move.w	#$8f01,(a6)
00000252 2CBC 942F 93FF           M 	move.l	#$94009300|(((($3000)-1)&$ff00)<<8)|((($3000)-1)&$ff),(a6)
00000258 3CBC 9780                M 	move.w	#$9780,(a6)
0000025C 2CBC 4000 0083           M 	move.l	#$40000080|((($c000)&$3fff)<<16)|((($c000)&$c000)>>14),(a6)
00000262 3D7C 0000 FFFC           M 	move.w	#(0)<<8,-4(a6)
00000268                          M 	waitdma	(a6)
00000268                          M .wait_24:
00000268 3216                     M 	move.w	(a6),d1
0000026A 0801 0001                M 	btst	#1,d1
0000026E 66F8                     M 	bne.s	.wait_24
00000270 3CBC 8F02                M 	move.w	#$8f02,(a6)
00000274                            
00000274                            		clrRAM	hScrollBuff, vScrollBuff_End	; Clear scroll tables
00000274                          M 	local	endaddr
00000274                          M endaddr	equs	"vscrollbuff_end"
00000274 7000                     M 	moveq	#0,d0
00000276 43F8 90FE                M 	lea	(hscrollbuff).w,a1
0000027A 323C 00F3                M 	move.w	#(((vscrollbuff_end)-(hscrollbuff))-((hscrollbuff)&1))>>2-1,d1
0000027E 22C0                     M .clear_25:	move.l	d0,(a1)+
00000280 51C9 FFFC                M 	dbf	d1,.clear_25
00000284                            		
00000284 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Load a plane map
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; PARAMETERS:
00000288                            ;	d0.l	- VDP command for writing the data to VRAM
00000288                            ;	d1.w	- Width in tiles (minus 1)
00000288                            ;	d2.w	- Height in tiles (minus 1)
00000288                            ;	d3.w	- Base tile properties for each tile
00000288                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
00000288                            ;	a1.l	- Plane map address
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; RETURNS:
00000288                            ;	Nothing
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            LoadPlaneMap:
00000288                            LoadPlaneMap_H64:
00000288 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
0000028E 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000290                            
00000290                            LoadPlaneMap_H32:
00000290 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
00000296 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000298                            
00000298                            LoadPlaneMap_H128:
00000298 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
0000029E                            
0000029E                            LoadPlaneMap_Custom:
0000029E                            .RowLoop:
0000029E 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002A4 3801                       		move.w	d1,d4				; Store width
000002A6                            
000002A6                            .TileLoop:
000002A6 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002A8 DA43                       		add.w	d3,d5				; Add base tile properties
000002AA 33C5 00C0 0000             		move.w	d5,VDP_DATA			; Save in VRAM
000002B0 51CC FFF4                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002B4 D086                       		add.l	d6,d0				; Next row
000002B6 51CA FFE6                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002BA 4E75                       		rts
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; Load a plane map into RAM
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; PARAMETERS:
000002BC                            ;	d1.w	- Width in tiles (minus 1)
000002BC                            ;	d2.w	- Height in tiles (minus 1)
000002BC                            ;	d3.w	- Base tile properties for each tile
000002BC                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
000002BC                            ;	a0.l	- Buffer to load into
000002BC                            ;	a1.l	- Plane map address
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; RETURNS:
000002BC                            ;	Nothing
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            LoadPlaneMap_RAM:
000002BC                            .RowLoop:
000002BC 2448                       		movea.l	a0,a2				; Copy buffer address
000002BE 3801                       		move.w	d1,d4				; Store width
000002C0                            
000002C0                            .TileLoop:
000002C0 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002C2 DA43                       		add.w	d3,d5				; Add base tile properties
000002C4 34C5                       		move.w	d5,(a2)+			; Save in RAM
000002C6 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002CA D0FC 0080                  		adda.w	#$80,a0				; Next row
000002CE 51CA FFEC                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002D2 4E75                       		rts
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; Fill the plane map with a value in a specific region
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; PARAMETERS:
000002D4                            ;	d0.l	- VDP command for writing the data to VRAM
000002D4                            ;	d1.w	- Width in tiles (minus 1)
000002D4                            ;	d2.w	- Height in tiles (minus 1)
000002D4                            ;	d3.w	- Value to fill plane map with
000002D4                            ;	d6.l	- Delta value for drawing to the next row
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; RETURNS:
000002D4                            ;	Nothing
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            FillPlaneMap:
000002D4                            FillPlaneMap_H64:
000002D4 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
000002DA 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002DC                            
000002DC                            FillPlaneMap_H32:
000002DC 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
000002E2 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002E4                            
000002E4                            FillPlaneMap_H128:
000002E4 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
000002EA                            
000002EA                            FillPlaneMap_Custom:
000002EA                            .RowLoop:
000002EA 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002F0 3801                       		move.w	d1,d4				; Store width
000002F2                            
000002F2                            .TileLoop:
000002F2 33C3 00C0 0000             		move.w	d3,VDP_DATA			; Save value in VRAM
000002F8 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002FC D086                       		add.l	d6,d0				; Next row
000002FE 51CA FFEA                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000302 4E75                       		rts
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Queue a VDP DMA command to VRAM, to be issued the next time ProcessDMAQueue is called. Can be called a maximum of 18 times before the queue needs
00000304                            ; to be cleared by issuing the commands (this checks for overflow)
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; PARAMETERS:
00000304                            ; 	d1.l	- Source address
00000304                            ; 	d2.w	- Destination address
00000304                            ; 	d3.w	- Transfer length
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; RETURNS:
00000304                            ;	Nothing
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is disabled by default because you can simply align the art in ROM
00000304                            ; and avoid the issue altogether. It is here so that you have a high-performance routine to do the job in situations where you can't align it in ROM.
00000304 =00000001                  Use128kbSafeDMA		= 1
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to mask interrupts while updating the DMA queue. This fixes many race conditions in the DMA funcion, but it costs 46(6/1) cycles. The
00000304                            ; better way to handle these race conditions would be to make unsafe callers (such as S3&K's KosM decoder) prevent these by masking off interrupts
00000304                            ; before calling and then restore interrupts after.
00000304 =00000000                  UseVIntSafeDMA		= 0
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to assume that transfer length is always less than $7FFF. Only makes sense if Use128kbSafeDMA is 1. Moreover, setting this to 1 will
00000304                            ; cause trouble on a 64kB DMA, so make sure you never do one if you set it to 1! Enabling this saves 4(1/0) cycles on the case where a DMA is
00000304                            ; broken in two and both transfers are properly queued, and nothing at all otherwise.
00000304 =00000000                  AssumeMax7FFFXfer	= 0&Use128kbSafeDMA
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Convenience macros, for increased maintainability of the code.
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Like vdpComm, but starting from an address contained in a register
00000304 =00000001                  vdpCommReg_defined = 1
00000304                            vdpCommReg	macro	reg, type, rwd, clr
00000304                            		local	cd
00000304                            cd		= \type&\rwd
00000304                            		lsl.l	#2,\reg				; Move high bits into (word-swapped) position, accidentally moving everything else
00000304                            		if ((cd)&3)<>0
00000304                            			addq.w	#((cd)&3),\reg		; Add upper access type bits
00000304                            		endif
00000304                            		ror.w	#2,\reg				; Put upper access type bits into place, also moving all other bits into their correct
00000304                            							; (word-swapped) places
00000304                            		swap	\reg				; Put all bits in proper places
00000304                            		if \clr<>0
00000304                            			andi.w	#3,\reg			; Strip whatever junk was in upper word of reg
00000304                            		endif
00000304                            		if ((cd)&$FC)=$20
00000304                            			tas.b	\reg			; Add in the DMA flag -- tas fails on memory, but works on registers
00000304                            		elseif ((cd)&$FC)<>0
00000304                            			ori.w	#(((cd)&$FC)*4),\reg	; Add in missing access type bits
00000304                            		endif
00000304                            		endm
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            QueueDMATransfer:
00000304                            
00000304 3278 90FC                  		movea.w	dmaSlot.w,a1
00000308 B2FC 90FC                  		cmpa.w	#dmaSlot,a1
0000030C 6700                       		beq.s	.Done				; Return if there's no more room in the queue
0000030E                            
0000030E E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00000310                            
00000310 3003                       			move.w  d3,d0			; d0 = length of transfer in words
00000312                            			; Compute position of last transferred word. This handles 2 cases:
00000312                            			; (1) zero length DMAs transfer length actually transfer $10000 words
00000312                            			; (2) (source+length)&$FFFF = 0
00000312 5340                       			subq.w  #1,d0
00000314 D041                       			add.w   d1,d0			; d0 = ((src_address >> 1) & $FFFF) + ((xferlen >> 1) - 1)
00000316 6500                       			bcs.s   .DoubleTransfer		; Carry set = ($10000 << 1) = $20000, or new 128kB block
00000318                            
00000318                            		; Store VDP commands for specifying DMA into the queue
00000318 4841                       		swap	d1				; Want the high byte first
0000031A 303C 977F                  		move.w	#$977F,d0			; Command to specify source address & $FE0000, plus bitmask for the given byte
0000031E C001                       		and.b	d1,d0				; Mask in source address & $FE0000, stripping high bit in the process
00000320 32C0                       		move.w	d0,(a1)+			; Store command
00000322 3203                       		move.w	d3,d1				; Put length together with (source address & $01FFFE) >> 1...
00000324 03C9 0001                  		movep.l	d1,1(a1)			; ... and stuff them all into RAM in their proper places (movep for the win)
00000328 43E9 0008                  		lea	8(a1),a1			; Skip past all of these commands
0000032C                            
0000032C                            		vdpCommReg d2,VRAM,DMA,1		; Make DMA destination command
0000032C                          M 	local	cd
0000032C =00000021                M cd	=	vram&dma
0000032C E58A                     M 	lsl.l	#2,d2
0000032E 5242                     M 	addq.w	#((cd)&3),d2
00000330 E45A                     M 	ror.w	#2,d2
00000332 4842                     M 	swap	d2
00000334 0242 0003                M 	andi.w	#3,d2
00000338 4AC2                     M 	tas.b	d2
0000033A 22C2                       		move.l	d2,(a1)+			; Store command
0000033C                            
0000033C 4251                       		clr.w	(a1)				; Put a stop token at the end of the used part of the queue
0000033E 31C9 90FC                  		move.w	a1,dmaSlot.w			; Set the next free slot address, potentially undoing the above clr (this is intentional!)
00000342                            
00000342                            .Done:
00000342 4E75                       		rts
00000344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000344                            .DoubleTransfer:
00000344                            			; Hand-coded version to break the DMA transfer into two smaller transfers
00000344                            			; that do not cross a 128kB boundary. This is done much faster (at the cost
00000344                            			; of space) than by the method of saving parameters and calling the normal
00000344                            			; DMA function twice, as Sonic3_Complete does.
00000344                            			; d0 is the number of words-1 that got over the end of the 128kB boundary
00000344 5240                       			addq.w	#1,d0			; Make d0 the number of words past the 128kB boundary
00000346 9640                       			sub.w	d0,d3			; First transfer will use only up to the end of the 128kB boundary
00000348                            
00000348                            			; Store VDP commands for specifying DMA into the queue
00000348 4841                       			swap	d1			; Want the high byte first
0000034A                            
0000034A                            			; Sadly, all registers we can spare are in use right now, so we can't use
0000034A                            			; no-cost RAM source safety.
0000034A 0241 007F                  			andi.w	#$7F,d1			; Strip high bit
0000034E 0041 9700                  			ori.w	#$9700,d1		; Command to specify source address & $FE0000
00000352 32C1                       			move.w	d1,(a1)+		; Store command
00000354 5201                       			addq.b	#1,d1			; Advance to next 128kB boundary (**)
00000356 3341 000C                  			move.w	d1,12(a1)		; Store it now (safe to do in all cases, as we will overwrite later if queue got filled) (**)
0000035A 3203                       			move.w	d3,d1			; Put length together with (source address & $01FFFE) >> 1...
0000035C 03C9 0001                  			movep.l	d1,1(a1)		; ... and stuff them all into RAM in their proper places (movep for the win)
00000360 43E9 0008                  			lea	8(a1),a1		; Skip past all of these commands
00000364                            
00000364 3602                       			move.w	d2,d3			; Save for later
00000366                            			vdpCommReg d2,VRAM,DMA,1	; Make DMA destination command
00000366                          M 	local	cd
00000366 =00000021                M cd	=	vram&dma
00000366 E58A                     M 	lsl.l	#2,d2
00000368 5242                     M 	addq.w	#((cd)&3),d2
0000036A E45A                     M 	ror.w	#2,d2
0000036C 4842                     M 	swap	d2
0000036E 0242 0003                M 	andi.w	#3,d2
00000372 4AC2                     M 	tas.b	d2
00000374 22C2                       			move.l	d2,(a1)+		; Store command
00000376                            
00000376 B2FC 90FC                  			cmpa.w	#dmaSlot,a1		; Did this command fill the queue?
0000037A 6700                       			beq.s	.SkipSecondTransfer	; Branch if so
0000037C                            
0000037C                            			; Store VDP commands for specifying DMA into the queue
0000037C                            			; The source address high byte was done above already in the comments marked
0000037C                            			; with (**)
0000037C 7400                       				moveq	#0,d2		; Need a zero for a 128kB block start
0000037E 3400                       				move.w	d0,d2		; Copy number of words on this new block...
00000380 05C9 0003                  				movep.l	d2,3(a1)	; ... and stuff it all into RAM at the proper places (movep for the win)
00000384 43E9 000A                  			lea	10(a1),a1		; Skip past all of these commands
00000388                            
00000388                            			; d1 contains length up to the end of the 128kB boundary
00000388 D241                       			add.w	d1,d1			; Convert it into byte length...
0000038A D243                       			add.w	d3,d1			; ... and offset destination by the correct amount
0000038C                            			vdpCommReg d1,VRAM,DMA,1	; Make DMA destination command
0000038C                          M 	local	cd
0000038C =00000021                M cd	=	vram&dma
0000038C E589                     M 	lsl.l	#2,d1
0000038E 5241                     M 	addq.w	#((cd)&3),d1
00000390 E459                     M 	ror.w	#2,d1
00000392 4841                     M 	swap	d1
00000394 0241 0003                M 	andi.w	#3,d1
00000398 4AC1                     M 	tas.b	d1
0000039A 22C1                       			move.l	d1,(a1)+		; Store command
0000039C                            
0000039C 4251                       			clr.w	(a1)			; Put a stop token at the end of the used part of the queue
0000039E 31C9 90FC                  			move.w	a1,dmaSlot.w		; Set the next free slot address, potentially undoing the above clr (this is intentional!)
000003A2                            
000003A2 4E75                       			rts
000003A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A4                            .SkipSecondTransfer:
000003A4 3289                       			move.w	a1,(a1)			; Set the next free slot address, overwriting what the second (**) instruction did
000003A6                            	
000003A6 4E75                       			rts
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; Issue all the queued VDP DMA commands from QueueDMATransfer, resets the queue when it's done
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; PARAMETERS:
000003A8                            ;	a6.l	- VDP control port
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; RETURNS:
000003A8                            ;	Nothing
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ProcessDMAQueue:
000003A8 43F8 9000                  		lea	dmaQueue.w,a1
000003AC 31C9 90FC                  		move.w	a1,dmaSlot.w
000003B0                            
000003B0                            		rept (dmaSlot-dmaQueue)/(7*2)
000003B0                            			move.w	(a1)+,d0
000003B0                            			beq.w	.Done			; Branch if we reached a stop token
000003B0                            			
000003B0                            			move.w	d0,(a6)			; Issue a set of VDP commands...
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            		endr
000003B0 3019                     M 	move.w	(a1)+,d0
000003B2 6700 0000                M 	beq.w	.done
000003B6 3C80                     M 	move.w	d0,(a6)
000003B8 2C99                     M 	move.l	(a1)+,(a6)
000003BA 2C99                     M 	move.l	(a1)+,(a6)
000003BC 3C99                     M 	move.w	(a1)+,(a6)
000003BE 3C99                     M 	move.w	(a1)+,(a6)
000003C0 3019                     M 	move.w	(a1)+,d0
000003C2 6700 0000                M 	beq.w	.done
000003C6 3C80                     M 	move.w	d0,(a6)
000003C8 2C99                     M 	move.l	(a1)+,(a6)
000003CA 2C99                     M 	move.l	(a1)+,(a6)
000003CC 3C99                     M 	move.w	(a1)+,(a6)
000003CE 3C99                     M 	move.w	(a1)+,(a6)
000003D0 3019                     M 	move.w	(a1)+,d0
000003D2 6700 0000                M 	beq.w	.done
000003D6 3C80                     M 	move.w	d0,(a6)
000003D8 2C99                     M 	move.l	(a1)+,(a6)
000003DA 2C99                     M 	move.l	(a1)+,(a6)
000003DC 3C99                     M 	move.w	(a1)+,(a6)
000003DE 3C99                     M 	move.w	(a1)+,(a6)
000003E0 3019                     M 	move.w	(a1)+,d0
000003E2 6700 0000                M 	beq.w	.done
000003E6 3C80                     M 	move.w	d0,(a6)
000003E8 2C99                     M 	move.l	(a1)+,(a6)
000003EA 2C99                     M 	move.l	(a1)+,(a6)
000003EC 3C99                     M 	move.w	(a1)+,(a6)
000003EE 3C99                     M 	move.w	(a1)+,(a6)
000003F0 3019                     M 	move.w	(a1)+,d0
000003F2 6700 0000                M 	beq.w	.done
000003F6 3C80                     M 	move.w	d0,(a6)
000003F8 2C99                     M 	move.l	(a1)+,(a6)
000003FA 2C99                     M 	move.l	(a1)+,(a6)
000003FC 3C99                     M 	move.w	(a1)+,(a6)
000003FE 3C99                     M 	move.w	(a1)+,(a6)
00000400 3019                     M 	move.w	(a1)+,d0
00000402 6700 0000                M 	beq.w	.done
00000406 3C80                     M 	move.w	d0,(a6)
00000408 2C99                     M 	move.l	(a1)+,(a6)
0000040A 2C99                     M 	move.l	(a1)+,(a6)
0000040C 3C99                     M 	move.w	(a1)+,(a6)
0000040E 3C99                     M 	move.w	(a1)+,(a6)
00000410 3019                     M 	move.w	(a1)+,d0
00000412 6700 0000                M 	beq.w	.done
00000416 3C80                     M 	move.w	d0,(a6)
00000418 2C99                     M 	move.l	(a1)+,(a6)
0000041A 2C99                     M 	move.l	(a1)+,(a6)
0000041C 3C99                     M 	move.w	(a1)+,(a6)
0000041E 3C99                     M 	move.w	(a1)+,(a6)
00000420 3019                     M 	move.w	(a1)+,d0
00000422 6700 0000                M 	beq.w	.done
00000426 3C80                     M 	move.w	d0,(a6)
00000428 2C99                     M 	move.l	(a1)+,(a6)
0000042A 2C99                     M 	move.l	(a1)+,(a6)
0000042C 3C99                     M 	move.w	(a1)+,(a6)
0000042E 3C99                     M 	move.w	(a1)+,(a6)
00000430 3019                     M 	move.w	(a1)+,d0
00000432 6700 0000                M 	beq.w	.done
00000436 3C80                     M 	move.w	d0,(a6)
00000438 2C99                     M 	move.l	(a1)+,(a6)
0000043A 2C99                     M 	move.l	(a1)+,(a6)
0000043C 3C99                     M 	move.w	(a1)+,(a6)
0000043E 3C99                     M 	move.w	(a1)+,(a6)
00000440 3019                     M 	move.w	(a1)+,d0
00000442 6700 0000                M 	beq.w	.done
00000446 3C80                     M 	move.w	d0,(a6)
00000448 2C99                     M 	move.l	(a1)+,(a6)
0000044A 2C99                     M 	move.l	(a1)+,(a6)
0000044C 3C99                     M 	move.w	(a1)+,(a6)
0000044E 3C99                     M 	move.w	(a1)+,(a6)
00000450 3019                     M 	move.w	(a1)+,d0
00000452 6700 0000                M 	beq.w	.done
00000456 3C80                     M 	move.w	d0,(a6)
00000458 2C99                     M 	move.l	(a1)+,(a6)
0000045A 2C99                     M 	move.l	(a1)+,(a6)
0000045C 3C99                     M 	move.w	(a1)+,(a6)
0000045E 3C99                     M 	move.w	(a1)+,(a6)
00000460 3019                     M 	move.w	(a1)+,d0
00000462 6700 0000                M 	beq.w	.done
00000466 3C80                     M 	move.w	d0,(a6)
00000468 2C99                     M 	move.l	(a1)+,(a6)
0000046A 2C99                     M 	move.l	(a1)+,(a6)
0000046C 3C99                     M 	move.w	(a1)+,(a6)
0000046E 3C99                     M 	move.w	(a1)+,(a6)
00000470 3019                     M 	move.w	(a1)+,d0
00000472 6700 0000                M 	beq.w	.done
00000476 3C80                     M 	move.w	d0,(a6)
00000478 2C99                     M 	move.l	(a1)+,(a6)
0000047A 2C99                     M 	move.l	(a1)+,(a6)
0000047C 3C99                     M 	move.w	(a1)+,(a6)
0000047E 3C99                     M 	move.w	(a1)+,(a6)
00000480 3019                     M 	move.w	(a1)+,d0
00000482 6700 0000                M 	beq.w	.done
00000486 3C80                     M 	move.w	d0,(a6)
00000488 2C99                     M 	move.l	(a1)+,(a6)
0000048A 2C99                     M 	move.l	(a1)+,(a6)
0000048C 3C99                     M 	move.w	(a1)+,(a6)
0000048E 3C99                     M 	move.w	(a1)+,(a6)
00000490 3019                     M 	move.w	(a1)+,d0
00000492 6700 0000                M 	beq.w	.done
00000496 3C80                     M 	move.w	d0,(a6)
00000498 2C99                     M 	move.l	(a1)+,(a6)
0000049A 2C99                     M 	move.l	(a1)+,(a6)
0000049C 3C99                     M 	move.w	(a1)+,(a6)
0000049E 3C99                     M 	move.w	(a1)+,(a6)
000004A0 3019                     M 	move.w	(a1)+,d0
000004A2 6700 0000                M 	beq.w	.done
000004A6 3C80                     M 	move.w	d0,(a6)
000004A8 2C99                     M 	move.l	(a1)+,(a6)
000004AA 2C99                     M 	move.l	(a1)+,(a6)
000004AC 3C99                     M 	move.w	(a1)+,(a6)
000004AE 3C99                     M 	move.w	(a1)+,(a6)
000004B0 3019                     M 	move.w	(a1)+,d0
000004B2 6700 0000                M 	beq.w	.done
000004B6 3C80                     M 	move.w	d0,(a6)
000004B8 2C99                     M 	move.l	(a1)+,(a6)
000004BA 2C99                     M 	move.l	(a1)+,(a6)
000004BC 3C99                     M 	move.w	(a1)+,(a6)
000004BE 3C99                     M 	move.w	(a1)+,(a6)
000004C0 3019                     M 	move.w	(a1)+,d0
000004C2 6700 0000                M 	beq.w	.done
000004C6 3C80                     M 	move.w	d0,(a6)
000004C8 2C99                     M 	move.l	(a1)+,(a6)
000004CA 2C99                     M 	move.l	(a1)+,(a6)
000004CC 3C99                     M 	move.w	(a1)+,(a6)
000004CE 3C99                     M 	move.w	(a1)+,(a6)
000004D0 7000                       		moveq	#0,d0
000004D2                            
000004D2                            .Done:
000004D2 31C0 9000                  		move.w	d0,dmaQueue.w
000004D6 4E75                       		rts
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; Initialize the DMA queue
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; PARAMETERS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; RETURNS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            InitDMAQueue:
000004D8 43F8 9000                  		lea	dmaQueue.w,a1
000004DC 32BC 0000                  		move.w	#0,(a1)
000004E0 31C9 90FC                  		move.w	a1,dmaSlot.w
000004E4 223C 9695 9493             		move.l	#$96959493,d1
000004EA =00000000                  c		= 0
000004EA                            		rept (dmaSlot-dmaQueue)/(7*2)
000004EA                            			movep.l	d1,2+c(a1)
000004EA                            c			= c+14
000004EA                            		endr
000004EA 03C9 0002                M 	movep.l	d1,2+c(a1)
000004EE =0000000E                M c	=	c+14
000004EE 03C9 0010                M 	movep.l	d1,2+c(a1)
000004F2 =0000001C                M c	=	c+14
000004F2 03C9 001E                M 	movep.l	d1,2+c(a1)
000004F6 =0000002A                M c	=	c+14
000004F6 03C9 002C                M 	movep.l	d1,2+c(a1)
000004FA =00000038                M c	=	c+14
000004FA 03C9 003A                M 	movep.l	d1,2+c(a1)
000004FE =00000046                M c	=	c+14
000004FE 03C9 0048                M 	movep.l	d1,2+c(a1)
00000502 =00000054                M c	=	c+14
00000502 03C9 0056                M 	movep.l	d1,2+c(a1)
00000506 =00000062                M c	=	c+14
00000506 03C9 0064                M 	movep.l	d1,2+c(a1)
0000050A =00000070                M c	=	c+14
0000050A 03C9 0072                M 	movep.l	d1,2+c(a1)
0000050E =0000007E                M c	=	c+14
0000050E 03C9 0080                M 	movep.l	d1,2+c(a1)
00000512 =0000008C                M c	=	c+14
00000512 03C9 008E                M 	movep.l	d1,2+c(a1)
00000516 =0000009A                M c	=	c+14
00000516 03C9 009C                M 	movep.l	d1,2+c(a1)
0000051A =000000A8                M c	=	c+14
0000051A 03C9 00AA                M 	movep.l	d1,2+c(a1)
0000051E =000000B6                M c	=	c+14
0000051E 03C9 00B8                M 	movep.l	d1,2+c(a1)
00000522 =000000C4                M c	=	c+14
00000522 03C9 00C6                M 	movep.l	d1,2+c(a1)
00000526 =000000D2                M c	=	c+14
00000526 03C9 00D4                M 	movep.l	d1,2+c(a1)
0000052A =000000E0                M c	=	c+14
0000052A 03C9 00E2                M 	movep.l	d1,2+c(a1)
0000052E =000000EE                M c	=	c+14
0000052E 03C9 00F0                M 	movep.l	d1,2+c(a1)
00000532 =000000FC                M c	=	c+14
00000532 4E75                       		rts
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; Load a palette into the main palette buffer
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; PARAMETERS:
00000534                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000534                            ;	a0.l	- Pointer to palette data
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            LoadPalette:
00000534 43F8 98CE                  		lea	paletteBuff.w,a1			; Main palette buffer
00000538 6000                       		bra.s	LoadPalToBuf			; Load the palette
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; Load a palette into the target palette buffer
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; PARAMETERS:
0000053A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000053A                            ;	a0.l	- Pointer to palette data
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            LoadTargetPal:
0000053A 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
0000053E 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; Load a palette into the main water palette buffer
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; PARAMETERS:
00000540                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000540                            ;	a0.l	- Pointer to palette data
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            LoadWaterPal:
00000540 43F8 984E                  		lea	paletteBuffAlt.w,a1		; Main water palette buffer
00000544 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; Load a palette into the target water palette buffer
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; PARAMETERS:
00000546                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000546                            ;	a0.l	- Pointer to palette data
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            LoadTargetWaterPal:
00000546 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; Load a palette into a palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; PARAMETERS:
0000054A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000054A                            ;	a0.l	- Pointer to palette data
0000054A                            ;	a1.l	- Pointer to destination buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            LoadPalToBuf:
0000054A 32D8                       		move.w	(a0)+,(a1)+			; Copy palette data
0000054C 51C8 FFFC                  		dbf	d0,LoadPalToBuf			; Loop
00000550 4E75                       		rts
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; Fade the palette to black
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; PARAMETERS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; RETURNS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            FadeToBlack:
00000552 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000558                            
00000558                            FadeToBlack_Custom:
00000558 7807                       		moveq	#7,d4				; Set repeat times
0000055A                            		
0000055A                            .FadeLoop:
0000055A                            		rept	2
0000055A                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
0000055A                            			bsr.w	VSync_Routine		; Do V-SYNC
0000055A                            		endr
0000055A 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000560 6100 0000                M 	bsr.w	vsync_routine
00000564 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000056A 6100 0000                M 	bsr.w	vsync_routine
0000056E 6100                       		bsr.s	FadeToBlack_Once		; Fade the colors once
00000570 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
00000574 4E75                       		rts
00000576                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000576                            FadeToBlack_Once:
00000576 7000                       		moveq	#0,d0
00000578 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
0000057C 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000580 D0C0                       		adda.w	d0,a0				; ''
00000582 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000586                            
00000586                            .FadeLoop:
00000586 6100                       		bsr.s	.FadeColor			; Fade a color			
00000588 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000058C                            
0000058C 7000                       		moveq	#0,d0
0000058E 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
00000592 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000596 D0C0                       		adda.w	d0,a0				; ''
00000598 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000059C                            
0000059C                            .FadeLoopWater:
0000059C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000059E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000005A2 4E75                       		rts
000005A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005A4                            .FadeColor:
000005A4 3A10                       		move.w	(a0),d5				; Load color
000005A6 6700                       		beq.s	.NoRed				; If the color is already black, branch
000005A8 3205                       		move.w	d5,d1				; Copy color
000005AA 1401                       		move.b	d1,d2				; Load green and red
000005AC 1601                       		move.b	d1,d3				; Load only red
000005AE                            
000005AE 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000005B2 6700                       		beq.s	.NoBlue				; If blue is finished, branch
000005B4 0445 0200                  		subi.w	#$200,d5			; Decrease blue
000005B8                            
000005B8                            .NoBlue:
000005B8 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000005BC 6700                       		beq.s	.NoGreen			; If green is finished, branch
000005BE 0445 0020                  		subi.w	#$20,d5				; Decrease green
000005C2                            
000005C2                            .NoGreen:
000005C2 0203 000E                  		andi.b	#$E,d3				; Get only red
000005C6 6700                       		beq.s	.NoRed				; If red is finished, branch
000005C8 5545                       		subq.w	#2,d5				; Decrease red
000005CA                            
000005CA                            .NoRed:
000005CA 30C5                       		move.w	d5,(a0)+			; Save the color
000005CC 4E75                       		rts
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; Fade the palette from black to the target palette
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; PARAMETERS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; RETURNS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            FadeFromBlack:
000005CE 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
000005D4                            
000005D4                            FadeFromBlack_Custom:
000005D4 780E                       		moveq	#$E,d4				; Maximum color check
000005D6                            
000005D6                            .FadeLoop:
000005D6                            		rept	2
000005D6                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
000005D6                            			bsr.w	VSync_Routine		; Do V-SYNC
000005D6                            		endr
000005D6 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000005DC 6100 0000                M 	bsr.w	vsync_routine
000005E0 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000005E6 6100 0000                M 	bsr.w	vsync_routine
000005EA 6100                       		bsr.s	FadeFromBlack_Once		; Fade the colors once
000005EC 5504                       		subq.b	#2,d4				; Decrement color check
000005EE 66E6                       		bne.s	.FadeLoop			; If we are not done, branch
000005F0                            
000005F0 11FC 000A C747             		move.b	#vFade,vIntRoutine.w		; Set V-INT routine
000005F6 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
000005FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005FA                            FadeFromBlack_Once:
000005FA 7000                       		moveq	#0,d0
000005FC 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000600 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
00000604 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000608 D0C0                       		adda.w	d0,a0				; ''
0000060A D2C0                       		adda.w	d0,a1				; ''
0000060C 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000610                            
00000610                            .FadeLoop:
00000610 6100                       		bsr.s	.FadeColor			; Fade a color			
00000612 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000616                            
00000616 7000                       		moveq	#0,d0
00000618 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000061C 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
00000620 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000624 D0C0                       		adda.w	d0,a0				; ''
00000626 D2C0                       		adda.w	d0,a1				; ''
00000628 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000062C                            
0000062C                            .FadeLoopWater:
0000062C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000062E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000632 4E75                       		rts
00000634                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000634                            .FadeColor:
00000634 1A11                       		move.b	(a1),d5				; Load blue
00000636 3219                       		move.w	(a1)+,d1			; Load green and red
00000638 1401                       		move.b	d1,d2				; Load red
0000063A E809                       		lsr.b	#4,d1				; Get only green
0000063C 0202 000E                  		andi.b	#$E,d2				; Get only red
00000640                            
00000640 3610                       		move.w	(a0),d3				; Load current color
00000642 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000644 6200                       		bhi.s	.NoBlue				; If not, branch
00000646 0643 0200                  		addi.w	#$200,d3			; Increase blue
0000064A                            
0000064A                            .NoBlue:
0000064A B801                       		cmp.b	d1,d4				; Should the green fade?
0000064C 6200                       		bhi.s	.NoGreen			; If not, branch
0000064E 0643 0020                  		addi.w	#$20,d3				; Increase green
00000652                            
00000652                            .NoGreen:
00000652 B802                       		cmp.b	d2,d4				; Should the red fade?
00000654 6200                       		bhi.s	.NoRed				; If not, branch
00000656 5443                       		addq.w	#2,d3				; Increase red
00000658                            
00000658                            .NoRed:
00000658 30C3                       		move.w	d3,(a0)+			; Save the color
0000065A 4E75                       		rts
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; Fade the palette to white
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; PARAMETERS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; RETURNS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            FadeToWhite:
0000065C 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000662                            
00000662                            FadeToWhite_Custom:
00000662 7807                       		moveq	#7,d4				; Set repeat times
00000664                            
00000664                            .FadeLoop:
00000664                            		rept	2
00000664                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
00000664                            			bsr.w	VSync_Routine		; Do V-SYNC
00000664                            		endr
00000664 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000066A 6100 0000                M 	bsr.w	vsync_routine
0000066E 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000674 6100 0000                M 	bsr.w	vsync_routine
00000678 6100                       		bsr.s	FadeToWhite_Once		; Fade the colors once
0000067A 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
0000067E 4E75                       		rts
00000680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000680                            FadeToWhite_Once:
00000680 7000                       		moveq	#0,d0
00000682 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000686 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
0000068A D0C0                       		adda.w	d0,a0				; ''
0000068C 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000690                            
00000690                            .FadeLoop:
00000690 6100                       		bsr.s	.FadeColor			; Fade a color			
00000692 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000696                            
00000696 7000                       		moveq	#0,d0
00000698 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000069C 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000006A0 D0C0                       		adda.w	d0,a0				; ''
000006A2 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000006A6                            
000006A6                            .FadeLoopWater:
000006A6 6100                       		bsr.s	.FadeColor			; Fade a color			
000006A8 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000006AC 4E75                       		rts
000006AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006AE                            .FadeColor:
000006AE 3A10                       		move.w	(a0),d5				; Load color
000006B0 0C45 0EEE                  		cmpi.w	#$EEE,d5			; Is it already white?
000006B4 6700                       		beq.s	.NoRed				; If so, branch
000006B6 3205                       		move.w	d5,d1				; Copy color
000006B8 1401                       		move.b	d1,d2				; Load green and red
000006BA 1601                       		move.b	d1,d3				; Load only red
000006BC                            
000006BC 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000006C0 0C41 0E00                  		cmpi.w	#$E00,d1			; Is blue finished?
000006C4 6700                       		beq.s	.NoBlue				; If do, branch
000006C6 0645 0200                  		addi.w	#$200,d5			; Increase blue
000006CA                            
000006CA                            .NoBlue:
000006CA 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000006CE 0C02 00E0                  		cmpi.b	#$E0,d2				; Is green finished?
000006D2 6700                       		beq.s	.NoGreen			; If so, branch
000006D4 0645 0020                  		addi.w	#$20,d5				; Increase green
000006D8                            
000006D8                            .NoGreen:
000006D8 0203 000E                  		andi.b	#$E,d3				; Get only red
000006DC 0C03 000E                  		cmpi.b	#$E,d3				; Is red finished?
000006E0 6700                       		beq.s	.NoRed				; If so, branch
000006E2 5445                       		addq.w	#2,d5				; Increase red
000006E4                            
000006E4                            .NoRed:
000006E4 30C5                       		move.w	d5,(a0)+			; Save the color
000006E6 4E75                       		rts
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; Fade the palette from white to the target palette
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; PARAMETERS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; RETURNS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            FadeFromWhite:
000006E8 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
000006EE                            
000006EE                            FadeFromWhite_Custom:
000006EE 7800                       		moveq	#0,d4				; Minimum color check
000006F0                            		
000006F0                            .FadeLoop:
000006F0                            		rept	2
000006F0                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
000006F0                            			bsr.w	VSync_Routine		; Do V-SYNC
000006F0                            		endr
000006F0 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000006F6 6100 0000                M 	bsr.w	vsync_routine
000006FA 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000700 6100 0000                M 	bsr.w	vsync_routine
00000704 6100                       		bsr.s	FadeFromWhite_Once		; Fade the colors once
00000706 5404                       		addq.b	#2,d4				; Decrement color check
00000708 0C04 000E                  		cmpi.b	#$E,d4				; Are we done?
0000070C 66E2                       		bne.s	.FadeLoop			; If not, branch
0000070E                            
0000070E 11FC 000A C747             		move.b	#vFade,vIntRoutine.w		; Set V-INT routine
00000714 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
00000718                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000718                            FadeFromWhite_Once:
00000718 7000                       		moveq	#0,d0
0000071A 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
0000071E 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
00000722 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000726 D0C0                       		adda.w	d0,a0				; ''
00000728 D2C0                       		adda.w	d0,a1				; ''
0000072A 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000072E                            
0000072E                            .FadeLoop:
0000072E 6100                       		bsr.s	.FadeColor			; Fade a color			
00000730 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000734                            
00000734 7000                       		moveq	#0,d0
00000736 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000073A 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
0000073E 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000742 D0C0                       		adda.w	d0,a0				; ''
00000744 D2C0                       		adda.w	d0,a1				; ''
00000746 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000074A                            
0000074A                            .FadeLoopWater:
0000074A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000074C 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000750 4E75                       		rts
00000752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000752                            .FadeColor:
00000752 1A11                       		move.b	(a1),d5				; Load blue
00000754 3219                       		move.w	(a1)+,d1			; Load green and red
00000756 1401                       		move.b	d1,d2				; Load red
00000758 E809                       		lsr.b	#4,d1				; Get only green
0000075A 0202 000E                  		andi.b	#$E,d2				; Get only red
0000075E                            
0000075E 3610                       		move.w	(a0),d3				; Load current color
00000760 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000762 6500                       		bcs.s	.NoBlue				; If not, branch
00000764 0443 0200                  		subi.w	#$200,d3			; Decrease blue
00000768                            
00000768                            .NoBlue:
00000768 B801                       		cmp.b	d1,d4				; Should the green fade?
0000076A 6500                       		bcs.s	.NoGreen			; If not, branch
0000076C 0443 0020                  		subi.w	#$20,d3				; Decrease green
00000770                            
00000770                            .NoGreen:
00000770 B802                       		cmp.b	d2,d4				; Should the red fade?
00000772 6500                       		bcs.s	.NoRed				; If not, branch
00000774 5543                       		subq.w	#2,d3				; Decrease red
00000776                            
00000776                            .NoRed:
00000776 30C3                       		move.w	d3,(a0)+			; Save the color
00000778 4E75                       		rts
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; Fade the palette from the current palette to the target palette
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; PARAMETERS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; RETURNS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            FadeToPalette:
0000077A 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000780                            
00000780                            FadeToPalette_Custom:
00000780 7000                       		moveq	#0,d0
00000782 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000786 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
0000078A D0C0                       		adda.w	d0,a0				; ''
0000078C                            
0000078C 7807                       		moveq	#7,d4				; Set repeat times
0000078E                            
0000078E                            .FadeLoop:
0000078E                            		rept	2
0000078E                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
0000078E                            			bsr.w	VSync_Routine		; Do V-SYNC
0000078E                            		endr
0000078E 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000794 6100 0000                M 	bsr.w	vsync_routine
00000798 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000079E 6100 0000                M 	bsr.w	vsync_routine
000007A2 6100                       		bsr.s	FadeToPalette_Once		; Fade the colors once
000007A4 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
000007A8 4E75                       		rts
000007AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007AA                            FadeToPalette_Once:
000007AA 7000                       		moveq	#0,d0
000007AC 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
000007B0 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
000007B4 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000007B8 D0C0                       		adda.w	d0,a0				; ''
000007BA D2C0                       		adda.w	d0,a1				; ''
000007BC 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000007C0                            
000007C0                            .FadeLoop:
000007C0 6100                       		bsr.s	.FadeColor			; Fade a color			
000007C2 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
000007C6                            
000007C6 7000                       		moveq	#0,d0
000007C8 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
000007CC 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
000007D0 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000007D4 D0C0                       		adda.w	d0,a0				; ''
000007D6 D2C0                       		adda.w	d0,a1				; ''
000007D8 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000007DC                            
000007DC                            .FadeLoopWater:
000007DC 6100                       		bsr.s	.FadeColor			; Fade a color			
000007DE 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000007E2 4E75                       		rts
000007E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E4                            .FadeColor:
000007E4 3610                       		move.w	(a0),d3				; Get color
000007E6 B659                       		cmp.w	(a1)+,d3			; Has the color already reached the target color?
000007E8 6700                       		beq.s	.NoRed				; If so, branch
000007EA                            		
000007EA 3229 FFFE                  		move.w	-2(a1),d1			; Get green and red
000007EE 1401                       		move.b	d1,d2				; Get red only
000007F0 0202 000E                  		andi.b	#$E,d2				; ''
000007F4 E809                       		lsr.b	#4,d1				; Get green only
000007F6                            
000007F6 1A29 FFFE                  		move.b	-2(a1),d5			; Get blue
000007FA BA10                       		cmp.b	(a0),d5				; Does blue need to fade?
000007FC 6700                       		beq.s	.NoBlue				; If not, branch
000007FE 6500                       		bcs.s	.DecBlue			; If it needs to be decreased, branch
00000800 0643 0200                  		addi.w	#$200,d3			; Increase blue
00000804 6000                       		bra.s	.NoBlue				; Continue
00000806                            
00000806                            .DecBlue:
00000806 0443 0200                  		subi.w	#$200,d3			; Decrease blue
0000080A                            
0000080A                            .NoBlue:
0000080A 3A10                       		move.w	(a0),d5				; Get green
0000080C E80D                       		lsr.b	#4,d5				; ''
0000080E B205                       		cmp.b	d5,d1				; Does green need to fade?
00000810 6700                       		beq.s	.NoGreen			; If not, branch
00000812 6500                       		bcs.s	.DecGreen			; If it needs to be decreased, branch
00000814 0603 0020                  		addi.b	#$20,d3				; Increase green
00000818 6000                       		bra.s	.NoGreen			; Continue
0000081A                            
0000081A                            .DecGreen:
0000081A 0403 0020                  		subi.b	#$20,d3				; Decrease green
0000081E                            
0000081E                            .NoGreen:
0000081E 3A10                       		move.w	(a0),d5				; Get red
00000820 0205 000E                  		andi.b	#$E,d5				; ''
00000824 B405                       		cmp.b	d5,d2				; Does red need to fade?
00000826 6700                       		beq.s	.NoRed				; If not, branch
00000828 6500                       		bcs.s	.DecRed				; If it needs to be decreased, branch
0000082A 5403                       		addq.b	#2,d3				; Increase red
0000082C 6000                       		bra.s	.NoRed				; Continue
0000082E                            
0000082E                            .DecRed:
0000082E 5503                       		subq.b	#2,d3				; Decrease red
00000830                            
00000830                            .NoRed:
00000830 30C3                       		move.w	d3,(a0)+			; Save new color
00000832 4E75                       		rts
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            ; Initialize the sprite table
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            InitSpriteTable:
00000834 7000                       		moveq	#0,d0
00000836 41F8 94CE                  		lea	spriteBuff.w,a0			; Sprite table buffer
0000083A 7201                       		moveq	#1,d1				; Link value
0000083C 7E4F                       		moveq	#($280/8)-1,d7			; Number of sprites
0000083E                            
0000083E                            .Loop:
0000083E 3080                       		move.w	d0,(a0)				; Move off screen
00000840 1141 0003                  		move.b	d1,3(a0)			; Set link value
00000844 5241                       		addq.w	#1,d1				; Increment link value
00000846 5048                       		addq.w	#8,a0				; Next sprite
00000848 51CF FFF4                  		dbf	d7,.Loop			; Loop
0000084C 1140 FFFB                  		move.b	d0,-5(a0)			; Set final link value to 0
00000850 4E75                       		rts
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; Draw the sprites from mappings
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; PARAMETERS:
00000852                            ;	d0.w	- X position
00000852                            ;	d1.w	- Y position
00000852                            ;	d4.w	- Number of sprites to draw
00000852                            ;	d5.w	- Sprite tile properties
00000852                            ;	d6.b	- Render flags
00000852                            ;	d7.w	- Max number of sprites left to draw
00000852                            ;	a1.l	- Mappings frame data
00000852                            ;	a6.l	- Sprite table buffer
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; RETURNS:
00000852                            ;	Nothing
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            DrawSprite:
00000852 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000854 6500                       		bcs.s	DrawSprite_FlipX		; If so, branch
00000856 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
00000858 6500 0000                  		bcs.w	DrawSprite_FlipY		; If so, branch
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            ; Draw the sprites from mappings with no flip checks
0000085C                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            DrawSprite_Loop:
0000085C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000085E 4882                       		ext.w	d2				; ''
00000860 D441                       		add.w	d1,d2				; Add onto Y position
00000862 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000864 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000866 524E                       		addq.w	#1,a6				; Skip link data
00000868 3419                       		move.w	(a1)+,d2			; Get tile properties
0000086A D445                       		add.w	d5,d2				; Add base tile properties
0000086C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000086E 3419                       		move.w	(a1)+,d2			; Get X offset
00000870 D440                       		add.w	d0,d2				; Add onto X position
00000872 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000874 5347                       		subq.w	#1,d7				; Decrement sprite count
00000876 5BCC FFE4                  		dbmi	d4,DrawSprite_Loop		; Loop if there are still enough sprites left
0000087A                            		
0000087A                            DrawSprite_End:
0000087A 4E75                       		rts
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            ; Draw the sprites from mappings, horizontally flipped
0000087C                            ; (Parameters inherited from DrawSprite)
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            DrawSprite_FlipX:
0000087C E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000087E 6500                       		bcs.s	DrawSprite_FlipXY		; If so, branch
00000880                            
00000880                            .Loop:
00000880 1419                       		move.b	(a1)+,d2			; Get Y offset
00000882 4882                       		ext.w	d2				; ''
00000884 D441                       		add.w	d1,d2				; Add onto Y position
00000886 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000888 1C19                       		move.b	(a1)+,d6			; Get sprite size
0000088A 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
0000088C 524E                       		addq.w	#1,a6				; Skip link data
0000088E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000890 D445                       		add.w	d5,d2				; Add base tile properties
00000892 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
00000896 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000898 3419                       		move.w	(a1)+,d2			; Get X offset
0000089A 4442                       		neg.w	d2				; Negate it
0000089C 1C3B 6000                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008A0 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008A2 D440                       		add.w	d0,d2				; Add onto X position
000008A4 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008A6 5347                       		subq.w	#1,d7				; Decrement sprite count
000008A8 5BCC FFD6                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000008AC 4E75                       		rts
000008AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008AE                            DrawSprite_XFlipOff:
000008AE 0808 0808                  		dc.b	8, 8, 8, 8
000008B2 1010 1010                  		dc.b	$10, $10, $10, $10
000008B6 1818 1818                  		dc.b	$18, $18, $18, $18
000008BA 2020 2020                  		dc.b	$20, $20, $20, $20
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            ; Draw the sprites from mappings, horizontally and vertically flipped
000008BE                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            DrawSprite_FlipXY:
000008BE 1419                       		move.b	(a1)+,d2			; Get Y offset
000008C0 4882                       		ext.w	d2				; ''
000008C2 4442                       		neg.w	d2				; Negate it
000008C4 1C11                       		move.b	(a1),d6				; Get sprite sizes
000008C6 1C3B 6000                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
000008CA 9446                       		sub.w	d6,d2				; Subtract from the Y offset
000008CC D441                       		add.w	d1,d2				; Add onto Y position
000008CE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008D0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000008D2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000008D4 524E                       		addq.w	#1,a6				; Skip link data
000008D6 3419                       		move.w	(a1)+,d2			; Get tile properties
000008D8 D445                       		add.w	d5,d2				; Add base tile properties
000008DA 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
000008DE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008E0 3419                       		move.w	(a1)+,d2			; Get X offset
000008E2 4442                       		neg.w	d2				; Negate it
000008E4 1C3B 60C8                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008E8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008EA D440                       		add.w	d0,d2				; Add onto X position
000008EC 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008EE 5347                       		subq.w	#1,d7				; Decrement sprite count
000008F0 5BCC FFCC                  		dbmi	d4,DrawSprite_FlipXY		; Loop if there are still enough sprites left
000008F4 4E75                       		rts
000008F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008F6                            DrawSprite_YFlipOff:
000008F6 0810 1820                  		dc.b	8, $10, $18, $20
000008FA 0810 1820                  		dc.b	8, $10, $18, $20
000008FE 0810 1820                  		dc.b	8, $10, $18, $20
00000902 0810 1820                  		dc.b	8, $10, $18, $20
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            ; Draw the sprites from mappings, vertically flipped
00000906                            ; (Parameters inherited from DrawSprite)
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            DrawSprite_FlipY:
00000906 1419                       		move.b	(a1)+,d2			; Get Y offset
00000908 4882                       		ext.w	d2				; ''
0000090A 4442                       		neg.w	d2				; Negate it
0000090C 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
0000090E 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000912 1C3B 60E2                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
00000916 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000918 D441                       		add.w	d1,d2				; Add onto Y position
0000091A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000091C 544E                       		addq.w	#2,a6				; Skip link data
0000091E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000920 D445                       		add.w	d5,d2				; Add base tile properties
00000922 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000926 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000928 3419                       		move.w	(a1)+,d2			; Get X offset
0000092A D440                       		add.w	d0,d2				; Add onto X position
0000092C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000092E 5347                       		subq.w	#1,d7				; Decrement sprite count
00000930 5BCC FFD4                  		dbmi	d4,DrawSprite_FlipY		; Loop if there are still enough sprites left
00000934 4E75                       		rts
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; Draw the sprites from mappings (with boundary checks)
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; PARAMETERS:
00000936                            ;	d0.w	- X position
00000936                            ;	d1.w	- Y position
00000936                            ;	d4.w	- Number of sprites to draw
00000936                            ;	d5.w	- Sprite tile properties
00000936                            ;	d6.b	- Render flags
00000936                            ;	d7.w	- Max number of sprites left to draw
00000936                            ;	a1.l	- Mappings frame data
00000936                            ;	a6.l	- Sprite table buffer
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; RETURNS:
00000936                            ;	Nothing
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            DrawSprite_BoundChk:
00000936 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000938 6500                       		bcs.s	DrawSprite_BndChk_FlipX		; If so, branch
0000093A E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000093C 6500 0000                  		bcs.w	DrawSprite_BndChk_FlipY		; If so, branch
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            ; Draw the sprites from mappings (with boundary checks) with no flip checks
00000940                            ; (Parameters inherited from DrawSprite_BoundChk, minus d6, a.k.a. render flags)
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            DrawSprBndChk_Loop:
00000940 1419                       		move.b	(a1)+,d2			; Get Y offset
00000942 4882                       		ext.w	d2				; ''
00000944 D441                       		add.w	d1,d2				; Add onto Y position
00000946 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000094A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000094C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000950 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000952 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000954 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000956 524E                       		addq.w	#1,a6				; Skip link data
00000958 3419                       		move.w	(a1)+,d2			; Get tile properties
0000095A D445                       		add.w	d5,d2				; Add base tile properties
0000095C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000095E 3419                       		move.w	(a1)+,d2			; Get X offset
00000960 D440                       		add.w	d0,d2				; Add onto X position
00000962 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000966 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000968 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
0000096C 6400                       		bhs.s	.Next_XOffScr			; If so, branch
0000096E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000970 5347                       		subq.w	#1,d7				; Decrement sprite count
00000972 5BCC FFCC                  		dbmi	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000976 4E75                       		rts
00000978                            
00000978                            .Next_XOffScr:
00000978 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
0000097A 51CC FFC4                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
0000097E 4E75                       		rts
00000980                            
00000980                            .Next_YOffScr:
00000980 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings in the mappings
00000982 51CC FFBC                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000986 4E75                       		rts
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            ; Draw the sprites from mappings (with boundary checks), horizontally flipped
00000988                            ; (Parameters inherited from DrawSprite_BoundChk)
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            DrawSprite_BndChk_FlipX:
00000988 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000098A 6500                       		bcs.s	DrawSprite_BndChk_FlipXY	; If so, branch
0000098C                            
0000098C                            .Loop:
0000098C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000098E 4882                       		ext.w	d2				; ''
00000990 D441                       		add.w	d1,d2				; Add onto Y position
00000992 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000996 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000998 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
0000099C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
0000099E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009A0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000009A2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000009A4 524E                       		addq.w	#1,a6				; Skip link data
000009A6 3419                       		move.w	(a1)+,d2			; Get tile properties
000009A8 D445                       		add.w	d5,d2				; Add base tile properties
000009AA 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
000009AE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009B0 3419                       		move.w	(a1)+,d2			; Get X offset
000009B2 4442                       		neg.w	d2				; Negate it
000009B4 1C3B 6000                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
000009B8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000009BA D440                       		add.w	d0,d2				; Add onto X position
000009BC 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000009C0 6300                       		bls.s	.Next_XOffScr			; If so, branch
000009C2 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000009C6 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000009C8 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009CA 5347                       		subq.w	#1,d7				; Decrement sprite count
000009CC 5BCC FFBE                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000009D0 4E75                       		rts
000009D2                            
000009D2                            .Next_XOffScr:
000009D2 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000009D4 51CC FFB6                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009D8 4E75                       		rts
000009DA                            
000009DA                            .Next_YOffScr:
000009DA 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
000009DC 51CC FFAE                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009E0 4E75                       		rts
000009E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E2                            DrwSprBndChk_XFlips:
000009E2 0808 0808                  		dc.b	8, 8, 8, 8
000009E6 1010 1010                  		dc.b	$10, $10, $10, $10
000009EA 1818 1818                  		dc.b	$18, $18, $18, $18
000009EE 2020 2020                  		dc.b	$20, $20, $20, $20
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            ; Draw the sprites from mappings (with boundary checks), horizontally and vertically flipped
000009F2                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            DrawSprite_BndChk_FlipXY:
000009F2 1419                       		move.b	(a1)+,d2			; Get Y offset
000009F4 4882                       		ext.w	d2				; ''
000009F6 4442                       		neg.w	d2				; Negate it
000009F8 1C11                       		move.b	(a1),d6				; Get sprite sizes
000009FA 1C3B 6000                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
000009FE 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A00 D441                       		add.w	d1,d2				; Add onto Y position
00000A02 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A06 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A08 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A0C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A0E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A10 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000A12 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000A14 524E                       		addq.w	#1,a6				; Skip link data
00000A16 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A18 D445                       		add.w	d5,d2				; Add base tile properties
00000A1A 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
00000A1E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A20 3419                       		move.w	(a1)+,d2			; Get X offset
00000A22 4442                       		neg.w	d2				; Negate it
00000A24 1C3B 60BC                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
00000A28 9446                       		sub.w	d6,d2				; Subtract the new X offset
00000A2A D440                       		add.w	d0,d2				; Add onto X position
00000A2C 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A30 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A32 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A36 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000A38 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A3A 5347                       		subq.w	#1,d7				; Decrement sprite count
00000A3C 5BCC FFB4                  		dbmi	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A40 4E75                       		rts
00000A42                            
00000A42                            .Next_XOffScr:
00000A42 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000A44 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A48 4E75                       		rts
00000A4A                            
00000A4A                            .Next_YOffScr:
00000A4A 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000A4C 51CC FFA4                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A50 4E75                       		rts
00000A52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A52                            DrwSprBndChk_YFlips:
00000A52 0810 1820                  		dc.b	8, $10, $18, $20
00000A56 0810 1820                  		dc.b	8, $10, $18, $20
00000A5A 0810 1820                  		dc.b	8, $10, $18, $20
00000A5E 0810 1820                  		dc.b	8, $10, $18, $20
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            ; Draw the sprites from mappings (with boundary checks), vertically flipped
00000A62                            ; (Parameters inherited from DrawSprite_BoundChk)
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            DrawSprite_BndChk_FlipY:
00000A62 1419                       		move.b	(a1)+,d2			; Get Y offset
00000A64 4882                       		ext.w	d2				; ''
00000A66 4442                       		neg.w	d2				; Negate it
00000A68 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
00000A6A 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000A6E 1C3B 60E2                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
00000A72 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A74 D441                       		add.w	d1,d2				; Add onto Y position
00000A76 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A7A 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A7C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A80 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A82 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A84 544E                       		addq.w	#2,a6				; Skip link data
00000A86 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A88 D445                       		add.w	d5,d2				; Add base tile properties
00000A8A 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000A8E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A90 3419                       		move.w	(a1)+,d2			; Get X offset
00000A92 D440                       		add.w	d0,d2				; Add onto X position
00000A94 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A98 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A9A 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A9E 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000AA0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000AA2 5347                       		subq.w	#1,d7				; Decrement sprite count
00000AA4 5BCC FFBC                  		dbmi	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AA8 4E75                       		rts
00000AAA                            
00000AAA                            .Next_XOffScr:
00000AAA 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000AAC 51CC FFB4                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB0 4E75                       		rts
00000AB2                            
00000AB2                            .Next_YOffScr:
00000AB2 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000AB4 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB8 4E75                       		rts
00000ABA                            ; =========================================================================================================================================================
00000ABA                            		include	"Libraries/Joypad.asm"		; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; Read joypad input
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; PARAMETERS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; RETURNS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ReadJoypads:
00000ABA 41F8 C742                  	lea	ctrlDataP1.w,a0			; 8	; load RAM space for joypad data
00000ABE 43F9 00A1 0002             	lea	PORT_A_DATA-1,a1		; 12	; load I/O data port A
00000AC4 7000                       	moveq	#%00000000,d0			; 4	; prepare TH = 0 request value
00000AC6 7240                       	moveq	#%01000000,d1			; 4	; prepare TH = 1 request value
00000AC8                            
00000AC8                            	; Repeat the following twice to
00000AC8                            	; collect input from both pads
00000AC8                            	rept	2
00000AC8                            		move.w	d0,(a1)			; 8	; set TH = 0 (burn 8 cycles to wait for returned data by setting up bitmasks below)
00000AC8                            		moveq	#%00110000,d2		; 4	; button bitmask mask for TH = 0
00000AC8                            		moveq	#%00111111,d3		; 4	; button bitmask for TH = 1
00000AC8                            		and.w	(a1),d2			; 8	; collect current button data for TH = 0 (A and Start)
00000AC8                            		move.w	d1,(a1)			; 8	; set TH = 1 (burn 8 cycles again below to wait)
00000AC8                            		add.b	d2,d2			; 4	; shift TH = 0 button bits to the left by two
00000AC8                            		add.b	d2,d2			; 4	; (A and start will be bits $6 and $7 in saved data)
00000AC8                            		and.w	(a1)+,d3		; 8	; collect current button data for TH = 1 (Up, Down, Left, Right, B, and C)
00000AC8                            		or.b	d3,d2			; 4	; combine collected button bits
00000AC8                            		not.b	d2			; 4	; flip bits (now pressed = 1 and not pressed = 0)
00000AC8                            		move.b	(a0),d3			; 8	; d3 = last collected button data
00000AC8                            		eor.b	d2,d3			; 4	; remove any currently pressed buttons from d3
00000AC8                            		move.b	d2,(a0)+		; 8	; save d2 (current button presses) as current held buttons
00000AC8                            		and.b	d2,d3			; 4	; limit d3 (pressed buttons) to only include current buttons
00000AC8                            		move.b	d3,(a0)+		; 8	; save all pressed buttons for this frame
00000AC8                            	endr
00000AC8 3280                     M 	move.w	d0,(a1)
00000ACA 7430                     M 	moveq	#%00110000,d2
00000ACC 763F                     M 	moveq	#%00111111,d3
00000ACE C451                     M 	and.w	(a1),d2
00000AD0 3281                     M 	move.w	d1,(a1)
00000AD2 D402                     M 	add.b	d2,d2
00000AD4 D402                     M 	add.b	d2,d2
00000AD6 C659                     M 	and.w	(a1)+,d3
00000AD8 8403                     M 	or.b	d3,d2
00000ADA 4602                     M 	not.b	d2
00000ADC 1610                     M 	move.b	(a0),d3
00000ADE B503                     M 	eor.b	d2,d3
00000AE0 10C2                     M 	move.b	d2,(a0)+
00000AE2 C602                     M 	and.b	d2,d3
00000AE4 10C3                     M 	move.b	d3,(a0)+
00000AE6 3280                     M 	move.w	d0,(a1)
00000AE8 7430                     M 	moveq	#%00110000,d2
00000AEA 763F                     M 	moveq	#%00111111,d3
00000AEC C451                     M 	and.w	(a1),d2
00000AEE 3281                     M 	move.w	d1,(a1)
00000AF0 D402                     M 	add.b	d2,d2
00000AF2 D402                     M 	add.b	d2,d2
00000AF4 C659                     M 	and.w	(a1)+,d3
00000AF6 8403                     M 	or.b	d3,d2
00000AF8 4602                     M 	not.b	d2
00000AFA 1610                     M 	move.b	(a0),d3
00000AFC B503                     M 	eor.b	d2,d3
00000AFE 10C2                     M 	move.b	d2,(a0)+
00000B00 C602                     M 	and.b	d2,d3
00000B02 10C3                     M 	move.b	d3,(a0)+
00000B04                            
00000B04 4E75                       	rts					; 16	; return
00000B06                            
00000B06                            ; =========================================================================================================================================================
00000B06                            		include	"Libraries/Decompression.asm"	; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; Kosinski decompression (General purpose)
00000B06                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; PARAMETERS:
00000B06                            ;	a0.l	- Source address
00000B06                            ;	a1.l	- Destination address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; RETURNS:
00000B06                            ;	a1.l	- End of decompressed data address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06 =00000001                  _Kos_UseLUT			equ	1
00000B06 =00000003                  _Kos_LoopUnroll			equ	3
00000B06 =00000001                  _Kos_ExtremeUnrolling		equ	1
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_RunBitStream macro
00000B06                            		dbra	d2,.skip\@
00000B06                            		moveq	#7,d2				; Set repeat count to 8.
00000B06                            		move.b	d1,d0				; Use the remaining 8 bits.
00000B06                            		not.w	d3				; Have all 16 bits been used up?
00000B06                            		bne.s	.skip\@				; Branch if not.
00000B06                            		move.b	(a0)+,d0			; Get desc field low-byte.
00000B06                            		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B06                            	if _Kos_UseLUT=1
00000B06                            		move.b	(a4,d0.w),d0			; Invert bit order...
00000B06                            		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B06                            	endif
00000B06                            .skip\@:
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_ReadBit macro
00000B06                            	if _Kos_UseLUT=1
00000B06                            		add.b	d0,d0				; Get a bit from the bitstream.
00000B06                            	else
00000B06                            		lsr.b	#1,d0				; Get a bit from the bitstream.
00000B06                            	endif
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            KosDec:
00000B06 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00000B08 7000                       		moveq	#0,d0
00000B0A 7200                       		moveq	#0,d1
00000B0C 49FA 0000                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00000B10 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00000B12 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B14 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
00000B18 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B1C 7407                       		moveq	#7,d2				; Set repeat count to 8.
00000B1E 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00000B20 6000                       		bra.s	.FetchNewCode
00000B22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B22                            .FetchCodeLoop:
00000B22                            		; Code 1 (Uncompressed byte).
00000B22                            		_Kos_RunBitStream
00000B22 51CA 0000                M 	dbra	d2,.skip_30
00000B26 7407                     M 	moveq	#7,d2
00000B28 1001                     M 	move.b	d1,d0
00000B2A 4643                     M 	not.w	d3
00000B2C 6600                     M 	bne.s	.skip_30
00000B2E 1018                     M 	move.b	(a0)+,d0
00000B30 1218                     M 	move.b	(a0)+,d1
00000B32 1034 0000                M 	move.b	(a4,d0.w),d0
00000B36 1234 1000                M 	move.b	(a4,d1.w),d1
00000B3A                          M .skip_30:
00000B3A 12D8                       		move.b	(a0)+,(a1)+
00000B3C                             
00000B3C                            .FetchNewCode:
00000B3C                            		_Kos_ReadBit
00000B3C D000                     M 	add.b	d0,d0
00000B3E 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00000B40                             
00000B40                            		; Codes 00 and 01.
00000B40 7AFF                       		moveq	#-1,d5
00000B42 4BD1                       		lea	(a1),a5
00000B44                            		_Kos_RunBitStream
00000B44 51CA 0000                M 	dbra	d2,.skip_32
00000B48 7407                     M 	moveq	#7,d2
00000B4A 1001                     M 	move.b	d1,d0
00000B4C 4643                     M 	not.w	d3
00000B4E 6600                     M 	bne.s	.skip_32
00000B50 1018                     M 	move.b	(a0)+,d0
00000B52 1218                     M 	move.b	(a0)+,d1
00000B54 1034 0000                M 	move.b	(a4,d0.w),d0
00000B58 1234 1000                M 	move.b	(a4,d1.w),d1
00000B5C                          M .skip_32:
00000B5C                            		_Kos_ReadBit
00000B5C D000                     M 	add.b	d0,d0
00000B5E 6500 0000                  		bcs.w	.Code_01
00000B62                             
00000B62                            		; Code 00 (Dictionary ref. short).
00000B62                            		_Kos_RunBitStream
00000B62 51CA 0000                M 	dbra	d2,.skip_34
00000B66 7407                     M 	moveq	#7,d2
00000B68 1001                     M 	move.b	d1,d0
00000B6A 4643                     M 	not.w	d3
00000B6C 6600                     M 	bne.s	.skip_34
00000B6E 1018                     M 	move.b	(a0)+,d0
00000B70 1218                     M 	move.b	(a0)+,d1
00000B72 1034 0000                M 	move.b	(a4,d0.w),d0
00000B76 1234 1000                M 	move.b	(a4,d1.w),d1
00000B7A                          M .skip_34:
00000B7A                            		_Kos_ReadBit
00000B7A D000                     M 	add.b	d0,d0
00000B7C 6500                       		bcs.s	.Copy45
00000B7E                            		_Kos_RunBitStream
00000B7E 51CA 0000                M 	dbra	d2,.skip_36
00000B82 7407                     M 	moveq	#7,d2
00000B84 1001                     M 	move.b	d1,d0
00000B86 4643                     M 	not.w	d3
00000B88 6600                     M 	bne.s	.skip_36
00000B8A 1018                     M 	move.b	(a0)+,d0
00000B8C 1218                     M 	move.b	(a0)+,d1
00000B8E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B92 1234 1000                M 	move.b	(a4,d1.w),d1
00000B96                          M .skip_36:
00000B96                            		_Kos_ReadBit
00000B96 D000                     M 	add.b	d0,d0
00000B98 6500                       		bcs.s	.Copy3
00000B9A                            		_Kos_RunBitStream
00000B9A 51CA 0000                M 	dbra	d2,.skip_38
00000B9E 7407                     M 	moveq	#7,d2
00000BA0 1001                     M 	move.b	d1,d0
00000BA2 4643                     M 	not.w	d3
00000BA4 6600                     M 	bne.s	.skip_38
00000BA6 1018                     M 	move.b	(a0)+,d0
00000BA8 1218                     M 	move.b	(a0)+,d1
00000BAA 1034 0000                M 	move.b	(a4,d0.w),d0
00000BAE 1234 1000                M 	move.b	(a4,d1.w),d1
00000BB2                          M .skip_38:
00000BB2 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BB4 DAC5                       		adda.w	d5,a5
00000BB6 12DD                       		move.b	(a5)+,(a1)+
00000BB8 12DD                       		move.b	(a5)+,(a1)+
00000BBA 6080                       		bra.s	.FetchNewCode
00000BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BBC                            .Copy3:
00000BBC                            		_Kos_RunBitStream
00000BBC 51CA 0000                M 	dbra	d2,.skip_39
00000BC0 7407                     M 	moveq	#7,d2
00000BC2 1001                     M 	move.b	d1,d0
00000BC4 4643                     M 	not.w	d3
00000BC6 6600                     M 	bne.s	.skip_39
00000BC8 1018                     M 	move.b	(a0)+,d0
00000BCA 1218                     M 	move.b	(a0)+,d1
00000BCC 1034 0000                M 	move.b	(a4,d0.w),d0
00000BD0 1234 1000                M 	move.b	(a4,d1.w),d1
00000BD4                          M .skip_39:
00000BD4 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BD6 DAC5                       		adda.w	d5,a5
00000BD8 12DD                       		move.b	(a5)+,(a1)+
00000BDA 12DD                       		move.b	(a5)+,(a1)+
00000BDC 12DD                       		move.b	(a5)+,(a1)+
00000BDE 6000 FF5C                  		bra.w	.FetchNewCode
00000BE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE2                            .Copy45:
00000BE2                            		_Kos_RunBitStream
00000BE2 51CA 0000                M 	dbra	d2,.skip_40
00000BE6 7407                     M 	moveq	#7,d2
00000BE8 1001                     M 	move.b	d1,d0
00000BEA 4643                     M 	not.w	d3
00000BEC 6600                     M 	bne.s	.skip_40
00000BEE 1018                     M 	move.b	(a0)+,d0
00000BF0 1218                     M 	move.b	(a0)+,d1
00000BF2 1034 0000                M 	move.b	(a4,d0.w),d0
00000BF6 1234 1000                M 	move.b	(a4,d1.w),d1
00000BFA                          M .skip_40:
00000BFA                            		_Kos_ReadBit
00000BFA D000                     M 	add.b	d0,d0
00000BFC 6500                       		bcs.s	.Copy5
00000BFE                            		_Kos_RunBitStream
00000BFE 51CA 0000                M 	dbra	d2,.skip_42
00000C02 7407                     M 	moveq	#7,d2
00000C04 1001                     M 	move.b	d1,d0
00000C06 4643                     M 	not.w	d3
00000C08 6600                     M 	bne.s	.skip_42
00000C0A 1018                     M 	move.b	(a0)+,d0
00000C0C 1218                     M 	move.b	(a0)+,d1
00000C0E 1034 0000                M 	move.b	(a4,d0.w),d0
00000C12 1234 1000                M 	move.b	(a4,d1.w),d1
00000C16                          M .skip_42:
00000C16 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C18 DAC5                       		adda.w	d5,a5
00000C1A 12DD                       		move.b	(a5)+,(a1)+
00000C1C 12DD                       		move.b	(a5)+,(a1)+
00000C1E 12DD                       		move.b	(a5)+,(a1)+
00000C20 12DD                       		move.b	(a5)+,(a1)+
00000C22 6000 FF18                  		bra.w	.FetchNewCode
00000C26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C26                            .Copy5:
00000C26                            		_Kos_RunBitStream
00000C26 51CA 0000                M 	dbra	d2,.skip_43
00000C2A 7407                     M 	moveq	#7,d2
00000C2C 1001                     M 	move.b	d1,d0
00000C2E 4643                     M 	not.w	d3
00000C30 6600                     M 	bne.s	.skip_43
00000C32 1018                     M 	move.b	(a0)+,d0
00000C34 1218                     M 	move.b	(a0)+,d1
00000C36 1034 0000                M 	move.b	(a4,d0.w),d0
00000C3A 1234 1000                M 	move.b	(a4,d1.w),d1
00000C3E                          M .skip_43:
00000C3E 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C40 DAC5                       		adda.w	d5,a5
00000C42 12DD                       		move.b	(a5)+,(a1)+
00000C44 12DD                       		move.b	(a5)+,(a1)+
00000C46 12DD                       		move.b	(a5)+,(a1)+
00000C48 12DD                       		move.b	(a5)+,(a1)+
00000C4A 12DD                       		move.b	(a5)+,(a1)+
00000C4C 6000 FEEE                  		bra.w	.FetchNewCode
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            .Code_01:
00000C50 7800                       		moveq	#0,d4				; d4 will contain copy count.
00000C52                            		; Code 01 (Dictionary ref. long / special).
00000C52                            		_Kos_RunBitStream
00000C52 51CA 0000                M 	dbra	d2,.skip_44
00000C56 7407                     M 	moveq	#7,d2
00000C58 1001                     M 	move.b	d1,d0
00000C5A 4643                     M 	not.w	d3
00000C5C 6600                     M 	bne.s	.skip_44
00000C5E 1018                     M 	move.b	(a0)+,d0
00000C60 1218                     M 	move.b	(a0)+,d1
00000C62 1034 0000                M 	move.b	(a4,d0.w),d0
00000C66 1234 1000                M 	move.b	(a4,d1.w),d1
00000C6A                          M .skip_44:
00000C6A 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00000C6C 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00000C6E 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00000C70 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00000C72 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
00000C74 C847                       		and.w	d7,d4				; d4 = %00000CCC.
00000C76 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00000C78                             
00000C78                            		; special mode (extended counter)
00000C78 1818                       		move.b	(a0)+,d4			; Read cnt
00000C7A 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00000C7C 5304                       		subq.b	#1,d4
00000C7E 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00000C82                             
00000C82 DAC5                       		adda.w	d5,a5
00000C84 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C86 3C04                       		move.w	d4,d6
00000C88 4646                       		not.w	d6
00000C8A CC47                       		and.w	d7,d6
00000C8C DC46                       		add.w	d6,d6
00000C8E E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00000C90 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
00000C94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C94                            .LargeCopy:
00000C94                            	rept (1<<_Kos_LoopUnroll)
00000C94                            		move.b	(a5)+,(a1)+
00000C94                            	endr
00000C94 12DD                     M 	move.b	(a5)+,(a1)+
00000C96 12DD                     M 	move.b	(a5)+,(a1)+
00000C98 12DD                     M 	move.b	(a5)+,(a1)+
00000C9A 12DD                     M 	move.b	(a5)+,(a1)+
00000C9C 12DD                     M 	move.b	(a5)+,(a1)+
00000C9E 12DD                     M 	move.b	(a5)+,(a1)+
00000CA0 12DD                     M 	move.b	(a5)+,(a1)+
00000CA2 12DD                     M 	move.b	(a5)+,(a1)+
00000CA4 51CC FFEE                  		dbra	d4,.LargeCopy
00000CA8 6000 FE92                  		bra.w	.FetchNewCode
00000CAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CAC                            .StreamCopy:
00000CAC DAC5                       		adda.w	d5,a5
00000CAE 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000CB0 BF44                       		eor.w	d7,d4
00000CB2 D844                       		add.w	d4,d4
00000CB4 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00000CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CB8                            .MediumCopy:
00000CB8                            	rept 8
00000CB8                            		move.b	(a5)+,(a1)+
00000CB8                            	endr
00000CB8 12DD                     M 	move.b	(a5)+,(a1)+
00000CBA 12DD                     M 	move.b	(a5)+,(a1)+
00000CBC 12DD                     M 	move.b	(a5)+,(a1)+
00000CBE 12DD                     M 	move.b	(a5)+,(a1)+
00000CC0 12DD                     M 	move.b	(a5)+,(a1)+
00000CC2 12DD                     M 	move.b	(a5)+,(a1)+
00000CC4 12DD                     M 	move.b	(a5)+,(a1)+
00000CC6 12DD                     M 	move.b	(a5)+,(a1)+
00000CC8 6000 FE72                  		bra.w	.FetchNewCode
00000CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCC                            .Quit:
00000CCC 4E75                       		rts
00000CCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCE                            KosDec_ByteMap:
00000CCE 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00000CDE 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00000CEE 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00000CFE 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
00000D0E 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
00000D1E 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
00000D2E 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
00000D3E 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
00000D4E 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
00000D5E 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00000D6E 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00000D7E 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00000D8E 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00000D9E 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00000DAE 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00000DBE 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; Enigma decompression (Mainly for plane mappings)
00000DCE                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; PARAMETERS:
00000DCE                            ;	d0.w	- Base tile properties (tile ID, flags, etc.)
00000DCE                            ;	a0.l	- Source address
00000DCE                            ;	a1.l	- Destination address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; RETURNS:
00000DCE                            ;	a1.l	- End of decompressed data address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            EniDec:
00000DCE                            		push.l d0-d7/a1-a5
00000DCE 48E7 FF7C                M 	movem.l	d0-d7/a1-a5,-(sp)
00000DD2 3640                       		movea.w d0,a3				; Store base tile properties
00000DD4 1018                       		move.b	(a0)+,d0
00000DD6 4880                       		ext.w	d0
00000DD8 3A40                       		movea.w d0,a5				; Store first byte, extended to word
00000DDA 1818                       		move.b	(a0)+,d4			; Store second byte
00000DDC E70C                       		lsl.b	#3,d4				; Multiply by 8
00000DDE 3458                       		movea.w (a0)+,a2			; Store third and fourth byte
00000DE0 D4CB                       		adda.w	a3,a2				; Add base tile properties
00000DE2 3858                       		movea.w (a0)+,a4			; Store fifth and sixth byte
00000DE4 D8CB                       		adda.w	a3,a4				; Add base tile properties
00000DE6 1A18                       		move.b	(a0)+,d5			; Store seventh byte
00000DE8 E145                       		asl.w	#8,d5				; Shift up by a byte
00000DEA 1A18                       		move.b	(a0)+,d5			; Store eigth byte in lower register byte
00000DEC 7C10                       		moveq	#$10,d6				; 16 bits = 2 bytes
00000DEE                            
00000DEE                            EniDec_Loop:
00000DEE 7007                       		moveq	#7,d0				; Process 7 bits at a time
00000DF0 3E06                       		move.w	d6,d7
00000DF2 9E40                       		sub.w	d0,d7
00000DF4 3205                       		move.w	d5,d1
00000DF6 EE69                       		lsr.w	d7,d1
00000DF8 0241 007F                  		andi.w	#$7F,d1				; Keep only lower 7 bits
00000DFC 3401                       		move.w	d1,d2
00000DFE 0C41 0040                  		cmpi.w	#$40,d1				; Is Bit 6 set?
00000E02 6400                       		bcc.s	.getnext			; If so, branch
00000E04 7006                       		moveq	#6,d0				; If not, process 6 bits instead of 7
00000E06 E24A                       		lsr.w	#1,d2				; Bitfield now becomes TTSSSS isntead of TTTSSSS
00000E08                            
00000E08                            .getnext:
00000E08 6100 0000                  		bsr.w	EniDec_ChkGetNextByte
00000E0C 0242 000F                  		andi.w	#$F,d2				; Keep only lower nibble
00000E10 E849                       		lsr.w	#4,d1				; Store upper nibble (max value = 7)
00000E12 D241                       		add.w	d1,d1
00000E14 4EFB 1000                  		jmp	EniDec_JmpTable(pc,d1.w)
00000E18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E18                            EniDec_Sub0:
00000E18 32CA                       		move.w	a2,(a1)+			; Write to destination
00000E1A 524A                       		addq.w	#1,a2				; Increment
00000E1C 51CA FFFA                  		dbf	d2,EniDec_Sub0			; Repeat
00000E20 60CC                       		bra.s	EniDec_Loop
00000E22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E22                            EniDec_Sub4:
00000E22 32CC                       		move.w	a4,(a1)+			; Write to destination
00000E24 51CA FFFC                  		dbf	d2,EniDec_Sub4			; Repeat
00000E28 60C4                       		bra.s	EniDec_Loop
00000E2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E2A                            EniDec_Sub8:
00000E2A 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E2E                            
00000E2E                            .loop1:
00000E2E 32C1                       		move.w	d1,(a1)+
00000E30 51CA FFFC                  		dbf	d2,.loop1
00000E34 60B8                       		bra.s	EniDec_Loop
00000E36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E36                            EniDec_SubA:
00000E36 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E3A                            
00000E3A                            .loop2:
00000E3A 32C1                       		move.w	d1,(a1)+
00000E3C 5241                       		addq.w	#1,d1
00000E3E 51CA FFFA                  		dbf	d2,.loop2
00000E42 60AA                       		bra.s	EniDec_Loop
00000E44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E44                            EniDec_SubC:
00000E44 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E48                            
00000E48                            .loop3:
00000E48 32C1                       		move.w	d1,(a1)+
00000E4A 5341                       		subq.w	#1,d1
00000E4C 51CA FFFA                  		dbf	d2,.loop3
00000E50 609C                       		bra.s	EniDec_Loop
00000E52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E52                            EniDec_SubE:
00000E52 0C42 000F                  		cmpi.w	#$F,d2
00000E56 6700                       		beq.s	EniDec_End
00000E58                            
00000E58                            .loop4:
00000E58 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E5C 32C1                       		move.w	d1,(a1)+
00000E5E 51CA FFF8                  		dbf	d2,.loop4
00000E62 608A                       		bra.s	EniDec_Loop
00000E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E64                            EniDec_JmpTable:
00000E64 60B2                       		bra.s	EniDec_Sub0
00000E66 60B0                       		bra.s	EniDec_Sub0
00000E68 60B8                       		bra.s	EniDec_Sub4
00000E6A 60B6                       		bra.s	EniDec_Sub4
00000E6C 60BC                       		bra.s	EniDec_Sub8
00000E6E 60C6                       		bra.s	EniDec_SubA
00000E70 60D2                       		bra.s	EniDec_SubC
00000E72 60DE                       		bra.s	EniDec_SubE
00000E74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E74                            EniDec_End:
00000E74 5348                       		subq.w	#1,a0
00000E76 0C46 0010                  		cmpi.w	#16,d6				; Were we going to start on a completely new byte?
00000E7A 6600                       		bne.s	.norollback			; If not, branch
00000E7C 5348                       		subq.w	#1,a0
00000E7E                            
00000E7E                            .norollback:
00000E7E 3008                       		move.w	a0,d0
00000E80 E248                       		lsr.w	#1,d0				; Are we on an odd byte?
00000E82 6400                       		bcc.s	.evendest			; If not, branch
00000E84 5248                       		addq.w	#1,a0				; Ensure we're on an even byte
00000E86                            
00000E86                            .evendest:
00000E86                            		pop.l	d0-d7/a1-a5
00000E86 4CDF 3EFF                M 	movem.l	(sp)+,d0-d7/a1-a5
00000E8A 4E75                       		rts
00000E8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E8C                            EniDec_GetInlineCopyVal:
00000E8C 360B                       		move.w	a3,d3				; Store base tile properties
00000E8E 1204                       		move.b	d4,d1
00000E90 D201                       		add.b	d1,d1
00000E92 6400                       		bcc.s	.nopriority			; If d4 was < $80
00000E94 5346                       		subq.w	#1,d6				; Get next bit number
00000E96 0D05                       		btst	d6,d5				; Is the bit set?
00000E98 6700                       		beq.s	.nopriority			; If not, branch
00000E9A 0043 8000                  		ori.w	#(1<<15),d3			; Set high priority bit
00000E9E                            
00000E9E                            .nopriority:
00000E9E D201                       		add.b	d1,d1
00000EA0 6400                       		bcc.s	.nopal1				; If d4 < $40
00000EA2 5346                       		subq.w	#1,d6				; Get next bit number
00000EA4 0D05                       		btst	d6,d5				; Is the bit set?
00000EA6 6700                       		beq.s	.nopal1				; If not, branch
00000EA8 0643 4000                  		addi.w	#(2<<13),d3			; Set the second palette bit
00000EAC                            
00000EAC                            .nopal1:
00000EAC D201                       		add.b	d1,d1
00000EAE 6400                       		bcc.s	.nopal0				; If d4 was < $20
00000EB0 5346                       		subq.w	#1,d6				; Get next bit number
00000EB2 0D05                       		btst	d6,d5				; Is the bit set?
00000EB4 6700                       		beq.s	.nopal0				; If not, branch
00000EB6 0643 2000                  		addi.w	#(1<<13),d3			; Set the first palette bit
00000EBA                            
00000EBA                            .nopal0:
00000EBA D201                       		add.b	d1,d1
00000EBC 6400                       		bcc.s	.noyflip			; If d4 was < $10
00000EBE 5346                       		subq.w	#1,d6				; Get next bit number
00000EC0 0D05                       		btst	d6,d5				; Is the bit set?
00000EC2 6700                       		beq.s	.noyflip			; If not, branch
00000EC4 0043 1000                  		ori.w	#(1<<12),d3			; Set the Y flip bit
00000EC8                            
00000EC8                            .noyflip:
00000EC8 D201                       		add.b	d1,d1
00000ECA 6400                       		bcc.s	.noxflip			; If d4 was < 8
00000ECC 5346                       		subq.w	#1,d6				; Get next bit number
00000ECE 0D05                       		btst	d6,d5				; Is the bit set?
00000ED0 6700                       		beq.s	.noxflip			; If not, branch
00000ED2 0043 0800                  		ori.w	#(1<<11),d3			; Set the X flip bit
00000ED6                            
00000ED6                            .noxflip:
00000ED6 3205                       		move.w	d5,d1
00000ED8 3E06                       		move.w	d6,d7				; Get remaining bits
00000EDA 9E4D                       		sub.w	a5,d7				; Subtract minimum bit number
00000EDC 6400                       		bcc.s	.GotEnoughBits			; If we're beyond that, branch
00000EDE 3C07                       		move.w	d7,d6
00000EE0 0646 0010                  		addi.w	#16,d6				; 16 bits = 2 bytes
00000EE4 4447                       		neg.w	d7				; Calculate bit deficit
00000EE6 EF69                       		lsl.w	d7,d1				; Make space for this many bits
00000EE8 1A10                       		move.b	(a0),d5				; Get next byte
00000EEA EF3D                       		rol.b	d7,d5				; Make the upper X bits the lower X bits
00000EEC DE47                       		add.w	d7,d7
00000EEE CA7B 7000                  		and.w	EniDec_AndVals-2(pc,d7.w),d5	; Only keep X lower bits
00000EF2 D245                       		add.w	d5,d1				; Compensate for the bit deficit
00000EF4                            
00000EF4                            .AddBits:
00000EF4 300D                       		move.w	a5,d0
00000EF6 D040                       		add.w	d0,d0
00000EF8 C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000EFC D243                       		add.w	d3,d1				; Add base tile properties
00000EFE 1A18                       		move.b	(a0)+,d5			; Get current byte, move onto next byte
00000F00 E14D                       		lsl.w	#8,d5				; Shift up by a byte
00000F02 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F04 4E75                       		rts
00000F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F06                            .GotEnoughBits:
00000F06 6700                       		beq.s	.GotExactCount			; If the exact number of bits are leftover, branch
00000F08 EE69                       		lsr.w	d7,d1				; Remove unneeded bits
00000F0A 300D                       		move.w	a5,d0
00000F0C D040                       		add.w	d0,d0
00000F0E C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000F12 D243                       		add.w	d3,d1				; Add base tile properties
00000F14 300D                       		move.w	a5,d0				; Store number of bits used up by inline copy
00000F16 6000                       		bra.s	EniDec_ChkGetNextByte		; Move onto next byte
00000F18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F18                            .GotExactCount:
00000F18 7C10                       		moveq	#16,d6				; 16 bits = 2 bytes
00000F1A 60D8                       		bra.s	.AddBits
00000F1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F1C                            EniDec_AndVals:
00000F1C 0001 0003 0007 000F        		dc.w	1, 3, 7, $F
00000F24 001F 003F 007F 00FF        		dc.w	$1F, $3F, $7F, $FF
00000F2C 01FF 03FF 07FF 0FFF        		dc.w	$1FF, $3FF, $7FF, $FFF
00000F34 1FFF 3FFF 7FFF FFFF        		dc.w	$1FFF, $3FFF, $7FFF, $FFFF
00000F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F3C                            EniDec_ChkGetNextByte:
00000F3C 9C40                       		sub.w	d0,d6
00000F3E 0C46 0009                  		cmpi.w	#9,d6
00000F42 6400                       		bcc.s	.Done
00000F44 5046                       		addq.w	#8,d6				; 8 bits = 1 byte
00000F46 E145                       		asl.w	#8,d5				; Shift up by a byte
00000F48 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F4A                            
00000F4A                            .Done:
00000F4A 4E75                       		rts
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; Load a Kosinski Moduled Queue
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; PARAMETERS:
00000F4C                            ;	a3.l	- Queue pointer
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; RETURNS:
00000F4C                            ;	Nothing
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            LoadKosMQueue:
00000F4C 3C1B                       		move.w	(a3)+,d6			; Get number of entries
00000F4E 6B00                       		bmi.s	.End				; If it's negative, branch
00000F50                            
00000F50                            .Queue:
00000F50 225B                       		movea.l	(a3)+,a1			; Get art pointer
00000F52 341B                       		move.w	(a3)+,d2			; Get VRAM address
00000F54 6100                       		bsr.s	QueueKosMData			; Queue
00000F56 51CE FFF8                  		dbf	d6,.Queue			; Loop
00000F5A                            
00000F5A                            .End:
00000F5A 4E75                       		rts
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; Adds a Kosinski Moduled archive to the module queue
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; PARAMETERS:
00000F5C                            ;	d2.w	- Destination in VRAM
00000F5C                            ;	a1.l	- Address of the archive
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; RETURNS:
00000F5C                            ;	Nothing
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            QueueKosMData:
00000F5C 45F8 9994                  		lea	kosMList.w,a2
00000F60 4A92                       		tst.l	(a2)				; Is the first slot free?
00000F62 6700                       		beq.s	ProcessKosM_Init		; If it is, branch
00000F64                            		
00000F64                            .FindFreeSlot:
00000F64 5C4A                       		addq.w	#6,a2				; Otherwise, check next slot
00000F66 4A92                       		tst.l	(a2)
00000F68 66FA                       		bne.s	.FindFreeSlot
00000F6A 24C9                       		move.l	a1,(a2)+			; Store source address
00000F6C 34C2                       		move.w	d2,(a2)+			; Store destination VRAM address
00000F6E 4E75                       		rts
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; Initializes processing of the first module on the queue
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; PARAMETERS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; RETURNS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ProcessKosM_Init:
00000F70 3619                       		move.w	(a1)+,d3			; Get uncompressed size
00000F72 0C43 A000                  		cmpi.w	#$A000,d3
00000F76 6600                       		bne.s	.GotSize
00000F78 363C 8000                  		move.w	#$8000,d3			; $A000 means $8000 for some reason
00000F7C                            
00000F7C                            .GotSize:
00000F7C E24B                       		lsr.w	#1,d3
00000F7E 3003                       		move.w	d3,d0
00000F80 EB58                       		rol.w	#5,d0
00000F82 0240 001F                  		andi.w	#$1F,d0				; Get number of complete modules
00000F86 11C0 9990                  		move.b	d0,kosMModules.w
00000F8A 0283 0000 07FF             		andi.l	#$7FF,d3			; Get size of last module in words
00000F90 6600                       		bne.s	.GotLeftover			; Branch if it's non-zero
00000F92 5338 9990                  		subq.b	#1,kosMModules.w		; Otherwise decrement the number of modules
00000F96 263C 0000 0800             		move.l	#$800,d3			; And take the size of the last module to be $800 words
00000F9C                            
00000F9C                            .GotLeftover:
00000F9C 31C3 9992                  		move.w	d3,kosMLastSize.w
00000FA0 31C2 9998                  		move.w	d2,kosMDestination.w
00000FA4 21C9 9994                  		move.l	a1,kosMSource.w
00000FA8 5238 9990                  		addq.b	#1,kosMModules.w		; Store total number of modules
00000FAC 4E75                       		rts
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; Processes the first module on the queue
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; PARAMETERS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; RETURNS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ProcessKosM:
00000FAE 4A38 9990                  		tst.b	kosMModules.w
00000FB2 6600                       		bne.s	.ModulesLeft
00000FB4                            
00000FB4                            .Done:
00000FB4 4E75                       		rts
00000FB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FB6                            .ModulesLeft:
00000FB6 6B00                       		bmi.s	.DecompressionStarted
00000FB8 0C78 0004 994E             		cmpi.w	#(kosList_End-kosList)/8,kosCount.w
00000FBE 64F4                       		bhs.s	.Done				; Branch if the Kosinski decompression queue is full
00000FC0 2278 9994                  		movea.l	kosMList.w,a1
00000FC4 45F8 8000                  		lea	kosMBuff.w,a2
00000FC8 6100 0000                  		bsr.w	QueueKosData			; Add current module to decompression queue
00000FCC 0038 0080 9990             		ori.b	#$80,kosMModules.w		; And set bit to signify decompression in progress
00000FD2 4E75                       		rts
00000FD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FD4                            .DecompressionStarted:
00000FD4 4A78 994E                  		tst.w	kosCount.w
00000FD8 66DA                       		bne.s	.Done				; Branch if the decompression isn't complete
00000FDA                            
00000FDA                            		; Otherwise, DMA the decompressed data to VRAM
00000FDA 0238 007F 9990             		andi.b	#$7F,kosMModules.w
00000FE0 263C 0000 0800             		move.l	#$1000/2,d3
00000FE6 5338 9990                  		subq.b	#1,kosMModules.w
00000FEA 6600                       		bne.s	.Skip				; Branch if it isn't the last module
00000FEC 3638 9992                  		move.w	kosMLastSize.w,d3
00000FF0                            
00000FF0                            .Skip:
00000FF0 3438 9998                  		move.w	kosMDestination.w,d2
00000FF4 3002                       		move.w	d2,d0
00000FF6 D043                       		add.w	d3,d0
00000FF8 D043                       		add.w	d3,d0
00000FFA 31C0 9998                  		move.w	d0,kosMDestination.w		; Set new destination
00000FFE 2038 9994                  		move.l	kosMList.w,d0
00001002 2238 9970                  		move.l	kosList.w,d1
00001006 9081                       		sub.l	d1,d0
00001008 0280 0000 000F             		andi.l	#$F,d0
0000100E D280                       		add.l	d0,d1				; Round to the nearest $10 boundary
00001010 21C1 9994                  		move.l	d1,kosMList.w		; And set new source
00001014 223C FFFF 8000             		move.l	#kosMBuff,d1
0000101A 6100 F2E8                  		bsr.w	QueueDMATransfer
0000101E 4A38 9990                  		tst.b	kosMModules.w
00001022 6600 0000                  		bne.w	.Exit				; Return if this wasn't the last module
00001026 41F8 9994                  		lea	kosMList.w,a0
0000102A 43F8 999A                  		lea	(kosMList+6).w,a1
0000102E                            	rept (kosMList_End-kosMList)/6-1
0000102E                            		move.l	(a1)+,(a0)+			; Otherwise, shift all entries up
0000102E                            		move.w	(a1)+,(a0)+
0000102E                            	endr
0000102E 20D9                     M 	move.l	(a1)+,(a0)+
00001030 30D9                     M 	move.w	(a1)+,(a0)+
00001032 20D9                     M 	move.l	(a1)+,(a0)+
00001034 30D9                     M 	move.w	(a1)+,(a0)+
00001036 20D9                     M 	move.l	(a1)+,(a0)+
00001038 30D9                     M 	move.w	(a1)+,(a0)+
0000103A 20D9                     M 	move.l	(a1)+,(a0)+
0000103C 30D9                     M 	move.w	(a1)+,(a0)+
0000103E 20D9                     M 	move.l	(a1)+,(a0)+
00001040 30D9                     M 	move.w	(a1)+,(a0)+
00001042 20D9                     M 	move.l	(a1)+,(a0)+
00001044 30D9                     M 	move.w	(a1)+,(a0)+
00001046 20D9                     M 	move.l	(a1)+,(a0)+
00001048 30D9                     M 	move.w	(a1)+,(a0)+
0000104A 20D9                     M 	move.l	(a1)+,(a0)+
0000104C 30D9                     M 	move.w	(a1)+,(a0)+
0000104E 20D9                     M 	move.l	(a1)+,(a0)+
00001050 30D9                     M 	move.w	(a1)+,(a0)+
00001052 20D9                     M 	move.l	(a1)+,(a0)+
00001054 30D9                     M 	move.w	(a1)+,(a0)+
00001056 20D9                     M 	move.l	(a1)+,(a0)+
00001058 30D9                     M 	move.w	(a1)+,(a0)+
0000105A 20D9                     M 	move.l	(a1)+,(a0)+
0000105C 30D9                     M 	move.w	(a1)+,(a0)+
0000105E 20D9                     M 	move.l	(a1)+,(a0)+
00001060 30D9                     M 	move.w	(a1)+,(a0)+
00001062 20D9                     M 	move.l	(a1)+,(a0)+
00001064 30D9                     M 	move.w	(a1)+,(a0)+
00001066 20D9                     M 	move.l	(a1)+,(a0)+
00001068 30D9                     M 	move.w	(a1)+,(a0)+
0000106A 20D9                     M 	move.l	(a1)+,(a0)+
0000106C 30D9                     M 	move.w	(a1)+,(a0)+
0000106E 20D9                     M 	move.l	(a1)+,(a0)+
00001070 30D9                     M 	move.w	(a1)+,(a0)+
00001072 20D9                     M 	move.l	(a1)+,(a0)+
00001074 30D9                     M 	move.w	(a1)+,(a0)+
00001076 20D9                     M 	move.l	(a1)+,(a0)+
00001078 30D9                     M 	move.w	(a1)+,(a0)+
0000107A 20D9                     M 	move.l	(a1)+,(a0)+
0000107C 30D9                     M 	move.w	(a1)+,(a0)+
0000107E 20D9                     M 	move.l	(a1)+,(a0)+
00001080 30D9                     M 	move.w	(a1)+,(a0)+
00001082 20D9                     M 	move.l	(a1)+,(a0)+
00001084 30D9                     M 	move.w	(a1)+,(a0)+
00001086 20D9                     M 	move.l	(a1)+,(a0)+
00001088 30D9                     M 	move.w	(a1)+,(a0)+
0000108A 20D9                     M 	move.l	(a1)+,(a0)+
0000108C 30D9                     M 	move.w	(a1)+,(a0)+
0000108E 20D9                     M 	move.l	(a1)+,(a0)+
00001090 30D9                     M 	move.w	(a1)+,(a0)+
00001092 20D9                     M 	move.l	(a1)+,(a0)+
00001094 30D9                     M 	move.w	(a1)+,(a0)+
00001096 20D9                     M 	move.l	(a1)+,(a0)+
00001098 30D9                     M 	move.w	(a1)+,(a0)+
0000109A 20D9                     M 	move.l	(a1)+,(a0)+
0000109C 30D9                     M 	move.w	(a1)+,(a0)+
0000109E 20D9                     M 	move.l	(a1)+,(a0)+
000010A0 30D9                     M 	move.w	(a1)+,(a0)+
000010A2 20D9                     M 	move.l	(a1)+,(a0)+
000010A4 30D9                     M 	move.w	(a1)+,(a0)+
000010A6 20D9                     M 	move.l	(a1)+,(a0)+
000010A8 30D9                     M 	move.w	(a1)+,(a0)+
000010AA 4298                       		clr.l	(a0)+				; And mark the last slot as free
000010AC 4258                       		clr.w	(a0)+
000010AE 2038 9994                  		move.l	kosMList.w,d0
000010B2 6700                       		beq.s	.Exit				; Return if the queue is now empty
000010B4 2240                       		movea.l	d0,a1
000010B6 3438 9998                  		move.w	kosMDestination.w,d2
000010BA 6000 FEB4                  		bra.w	ProcessKosM_Init
000010BE                            
000010BE                            .Exit:
000010BE 4E75                       		rts
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; Adds Kosinski-compressed data to the decompression queue
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; PARAMETERS:
000010C0                            ;	a1.l	- Compressed data address
000010C0                            ;	a2.l	- Decompression destination in RAM
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; RETURNS:
000010C0                            ;	Nothing
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            QueueKosData:
000010C0 3038 994E                  		move.w	kosCount.w,d0
000010C4 E748                       		lsl.w	#3,d0
000010C6 47F8 9970                  		lea	kosList.w,a3
000010CA 2789 0000                  		move.l	a1,(a3,d0.w)			; Store source
000010CE 278A 0004                  		move.l	a2,4(a3,d0.w)			; Store destination
000010D2 5278 994E                  		addq.w	#1,kosCount.w
000010D6 4E75                       		rts
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; Checks if V-INT occured in the middle of Kosinski queue processing and stores the location from which processing is to resume if it did
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; PARAMETERS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; RETURNS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            SetKosBookmark:
000010D8 4A78 994E                  		tst.w	kosCount.w
000010DC 6A00                       		bpl.s	.Done				; Branch if a decompression wasn't in progress
000010DE 202F 0042                  		move.l	$42(sp),d0			; Check address V-INT is supposed to rte to
000010E2 0C80 0000 0000             		cmpi.l	#ProcessKos_Main,d0
000010E8 6500                       		bcs.s	.Done
000010EA 0C80 0000 0000             		cmpi.l	#ProcessKos_Done,d0
000010F0 6400                       		bcc.s	.Done
000010F2 21EF 0042 996C             		move.l	$42(sp),kosBookmark.w
000010F8 2F7C 0000 0000 0042        		move.l	#BackupKosRegs,$42(sp)		; Force V-INT to rte here instead if needed
00001100                            
00001100                            .Done:
00001100 4E75                       		rts
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; Processes the first entry in the Kosinski decompression queue
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; PARAMETERS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; RETURNS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ProcessKos:
00001102 4A78 994E                  		tst.w	kosCount.w
00001106 6700 0000                  		beq.w	ProcessKos_Done
0000110A 6B00 0000                  		bmi.w	RestoreKosBookmark		; Branch if a decompression was interrupted by V-int
0000110E                            
0000110E                            ProcessKos_Main:
0000110E 0078 8000 994E             		ori.w	#$8000,kosCount.w	; Set sign bit to signify decompression in progress
00001114 2078 9970                  		movea.l	kosList.w,a0
00001118 2278 9974                  		movea.l	kosDestination.w,a1
0000111C                            		
0000111C                            		; What follows is identical to the normal Kosinski decompressor
0000111C 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
0000111E 7000                       		moveq	#0,d0
00001120 7200                       		moveq	#0,d1
00001122 49FA FBAA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00001126 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00001128 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
0000112A 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
0000112E 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00001132 7407                       		moveq	#7,d2				; Set repeat count to 8.
00001134 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00001136 6000                       		bra.s	.FetchNewCode
00001138                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001138                            .FetchCodeLoop:
00001138                            		; Code 1 (Uncompressed byte).
00001138                            		_Kos_RunBitStream
00001138 51CA 0000                M 	dbra	d2,.skip_47
0000113C 7407                     M 	moveq	#7,d2
0000113E 1001                     M 	move.b	d1,d0
00001140 4643                     M 	not.w	d3
00001142 6600                     M 	bne.s	.skip_47
00001144 1018                     M 	move.b	(a0)+,d0
00001146 1218                     M 	move.b	(a0)+,d1
00001148 1034 0000                M 	move.b	(a4,d0.w),d0
0000114C 1234 1000                M 	move.b	(a4,d1.w),d1
00001150                          M .skip_47:
00001150 12D8                       		move.b	(a0)+,(a1)+
00001152                            
00001152                            .FetchNewCode:
00001152                            		_Kos_ReadBit
00001152 D000                     M 	add.b	d0,d0
00001154 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00001156                            
00001156                            		; Codes 00 and 01.
00001156 7AFF                       		moveq	#-1,d5
00001158 4BD1                       		lea	(a1),a5
0000115A                            		_Kos_RunBitStream
0000115A 51CA 0000                M 	dbra	d2,.skip_49
0000115E 7407                     M 	moveq	#7,d2
00001160 1001                     M 	move.b	d1,d0
00001162 4643                     M 	not.w	d3
00001164 6600                     M 	bne.s	.skip_49
00001166 1018                     M 	move.b	(a0)+,d0
00001168 1218                     M 	move.b	(a0)+,d1
0000116A 1034 0000                M 	move.b	(a4,d0.w),d0
0000116E 1234 1000                M 	move.b	(a4,d1.w),d1
00001172                          M .skip_49:
00001172                            		_Kos_ReadBit
00001172 D000                     M 	add.b	d0,d0
00001174 6500 0000                  		bcs.w	.Code_01
00001178                            
00001178                            		; Code 00 (Dictionary ref. short).
00001178                            		_Kos_RunBitStream
00001178 51CA 0000                M 	dbra	d2,.skip_51
0000117C 7407                     M 	moveq	#7,d2
0000117E 1001                     M 	move.b	d1,d0
00001180 4643                     M 	not.w	d3
00001182 6600                     M 	bne.s	.skip_51
00001184 1018                     M 	move.b	(a0)+,d0
00001186 1218                     M 	move.b	(a0)+,d1
00001188 1034 0000                M 	move.b	(a4,d0.w),d0
0000118C 1234 1000                M 	move.b	(a4,d1.w),d1
00001190                          M .skip_51:
00001190                            		_Kos_ReadBit
00001190 D000                     M 	add.b	d0,d0
00001192 6500                       		bcs.s	.Copy45
00001194                            		_Kos_RunBitStream
00001194 51CA 0000                M 	dbra	d2,.skip_53
00001198 7407                     M 	moveq	#7,d2
0000119A 1001                     M 	move.b	d1,d0
0000119C 4643                     M 	not.w	d3
0000119E 6600                     M 	bne.s	.skip_53
000011A0 1018                     M 	move.b	(a0)+,d0
000011A2 1218                     M 	move.b	(a0)+,d1
000011A4 1034 0000                M 	move.b	(a4,d0.w),d0
000011A8 1234 1000                M 	move.b	(a4,d1.w),d1
000011AC                          M .skip_53:
000011AC                            		_Kos_ReadBit
000011AC D000                     M 	add.b	d0,d0
000011AE 6500                       		bcs.s	.Copy3
000011B0                            		_Kos_RunBitStream
000011B0 51CA 0000                M 	dbra	d2,.skip_55
000011B4 7407                     M 	moveq	#7,d2
000011B6 1001                     M 	move.b	d1,d0
000011B8 4643                     M 	not.w	d3
000011BA 6600                     M 	bne.s	.skip_55
000011BC 1018                     M 	move.b	(a0)+,d0
000011BE 1218                     M 	move.b	(a0)+,d1
000011C0 1034 0000                M 	move.b	(a4,d0.w),d0
000011C4 1234 1000                M 	move.b	(a4,d1.w),d1
000011C8                          M .skip_55:
000011C8 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011CA DAC5                       		adda.w	d5,a5
000011CC 12DD                       		move.b	(a5)+,(a1)+
000011CE 12DD                       		move.b	(a5)+,(a1)+
000011D0 6080                       		bra.s	.FetchNewCode
000011D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011D2                            .Copy3:
000011D2                            		_Kos_RunBitStream
000011D2 51CA 0000                M 	dbra	d2,.skip_56
000011D6 7407                     M 	moveq	#7,d2
000011D8 1001                     M 	move.b	d1,d0
000011DA 4643                     M 	not.w	d3
000011DC 6600                     M 	bne.s	.skip_56
000011DE 1018                     M 	move.b	(a0)+,d0
000011E0 1218                     M 	move.b	(a0)+,d1
000011E2 1034 0000                M 	move.b	(a4,d0.w),d0
000011E6 1234 1000                M 	move.b	(a4,d1.w),d1
000011EA                          M .skip_56:
000011EA 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011EC DAC5                       		adda.w	d5,a5
000011EE 12DD                       		move.b	(a5)+,(a1)+
000011F0 12DD                       		move.b	(a5)+,(a1)+
000011F2 12DD                       		move.b	(a5)+,(a1)+
000011F4 6000 FF5C                  		bra.w	.FetchNewCode
000011F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011F8                            .Copy45:
000011F8                            		_Kos_RunBitStream
000011F8 51CA 0000                M 	dbra	d2,.skip_57
000011FC 7407                     M 	moveq	#7,d2
000011FE 1001                     M 	move.b	d1,d0
00001200 4643                     M 	not.w	d3
00001202 6600                     M 	bne.s	.skip_57
00001204 1018                     M 	move.b	(a0)+,d0
00001206 1218                     M 	move.b	(a0)+,d1
00001208 1034 0000                M 	move.b	(a4,d0.w),d0
0000120C 1234 1000                M 	move.b	(a4,d1.w),d1
00001210                          M .skip_57:
00001210                            		_Kos_ReadBit
00001210 D000                     M 	add.b	d0,d0
00001212 6500                       		bcs.s	.Copy5
00001214                            		_Kos_RunBitStream
00001214 51CA 0000                M 	dbra	d2,.skip_59
00001218 7407                     M 	moveq	#7,d2
0000121A 1001                     M 	move.b	d1,d0
0000121C 4643                     M 	not.w	d3
0000121E 6600                     M 	bne.s	.skip_59
00001220 1018                     M 	move.b	(a0)+,d0
00001222 1218                     M 	move.b	(a0)+,d1
00001224 1034 0000                M 	move.b	(a4,d0.w),d0
00001228 1234 1000                M 	move.b	(a4,d1.w),d1
0000122C                          M .skip_59:
0000122C 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000122E DAC5                       		adda.w	d5,a5
00001230 12DD                       		move.b	(a5)+,(a1)+
00001232 12DD                       		move.b	(a5)+,(a1)+
00001234 12DD                       		move.b	(a5)+,(a1)+
00001236 12DD                       		move.b	(a5)+,(a1)+
00001238 6000 FF18                  		bra.w	.FetchNewCode
0000123C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000123C                            .Copy5:
0000123C                            		_Kos_RunBitStream
0000123C 51CA 0000                M 	dbra	d2,.skip_60
00001240 7407                     M 	moveq	#7,d2
00001242 1001                     M 	move.b	d1,d0
00001244 4643                     M 	not.w	d3
00001246 6600                     M 	bne.s	.skip_60
00001248 1018                     M 	move.b	(a0)+,d0
0000124A 1218                     M 	move.b	(a0)+,d1
0000124C 1034 0000                M 	move.b	(a4,d0.w),d0
00001250 1234 1000                M 	move.b	(a4,d1.w),d1
00001254                          M .skip_60:
00001254 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00001256 DAC5                       		adda.w	d5,a5
00001258 12DD                       		move.b	(a5)+,(a1)+
0000125A 12DD                       		move.b	(a5)+,(a1)+
0000125C 12DD                       		move.b	(a5)+,(a1)+
0000125E 12DD                       		move.b	(a5)+,(a1)+
00001260 12DD                       		move.b	(a5)+,(a1)+
00001262 6000 FEEE                  		bra.w	.FetchNewCode
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            .Code_01:
00001266 7800                       		moveq	#0,d4				; d4 will contain copy count.
00001268                            		; Code 01 (Dictionary ref. long / special).
00001268                            		_Kos_RunBitStream
00001268 51CA 0000                M 	dbra	d2,.skip_61
0000126C 7407                     M 	moveq	#7,d2
0000126E 1001                     M 	move.b	d1,d0
00001270 4643                     M 	not.w	d3
00001272 6600                     M 	bne.s	.skip_61
00001274 1018                     M 	move.b	(a0)+,d0
00001276 1218                     M 	move.b	(a0)+,d1
00001278 1034 0000                M 	move.b	(a4,d0.w),d0
0000127C 1234 1000                M 	move.b	(a4,d1.w),d1
00001280                          M .skip_61:
00001280 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001282 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001284 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00001286 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00001288 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000128A C847                       		and.w	d7,d4				; d4 = %00000CCC.
0000128C 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
0000128E                            
0000128E                            		; special mode (extended counter)
0000128E 1818                       		move.b	(a0)+,d4			; Read cnt
00001290 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00001292 5304                       		subq.b	#1,d4
00001294 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00001298                            
00001298 DAC5                       		adda.w	d5,a5
0000129A 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000129C 3C04                       		move.w	d4,d6
0000129E 4646                       		not.w	d6
000012A0 CC47                       		and.w	d7,d6
000012A2 DC46                       		add.w	d6,d6
000012A4 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
000012A6 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
000012AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012AA                            .LargeCopy:
000012AA                            	rept (1<<_Kos_LoopUnroll)
000012AA                            		move.b	(a5)+,(a1)+
000012AA                            	endr
000012AA 12DD                     M 	move.b	(a5)+,(a1)+
000012AC 12DD                     M 	move.b	(a5)+,(a1)+
000012AE 12DD                     M 	move.b	(a5)+,(a1)+
000012B0 12DD                     M 	move.b	(a5)+,(a1)+
000012B2 12DD                     M 	move.b	(a5)+,(a1)+
000012B4 12DD                     M 	move.b	(a5)+,(a1)+
000012B6 12DD                     M 	move.b	(a5)+,(a1)+
000012B8 12DD                     M 	move.b	(a5)+,(a1)+
000012BA 51CC FFEE                  		dbra	d4,.LargeCopy
000012BE 6000 FE92                  		bra.w	.FetchNewCode
000012C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012C2                            .StreamCopy:
000012C2 DAC5                       		adda.w	d5,a5
000012C4 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
000012C6 BF44                       		eor.w	d7,d4
000012C8 D844                       		add.w	d4,d4
000012CA 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            .MediumCopy:
000012CE                            	rept 8
000012CE                            		move.b	(a5)+,(a1)+
000012CE                            	endr
000012CE 12DD                     M 	move.b	(a5)+,(a1)+
000012D0 12DD                     M 	move.b	(a5)+,(a1)+
000012D2 12DD                     M 	move.b	(a5)+,(a1)+
000012D4 12DD                     M 	move.b	(a5)+,(a1)+
000012D6 12DD                     M 	move.b	(a5)+,(a1)+
000012D8 12DD                     M 	move.b	(a5)+,(a1)+
000012DA 12DD                     M 	move.b	(a5)+,(a1)+
000012DC 12DD                     M 	move.b	(a5)+,(a1)+
000012DE 6000 FE72                  		bra.w	.FetchNewCode
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            .Quit:	
000012E2 21C8 9970                  		move.l	a0,kosList.w
000012E6 21C9 9974                  		move.l	a1,kosDestination.w
000012EA 0278 7FFF 994E             		andi.w	#$7FFF,kosCount.w		; Clear decompression in progress bit
000012F0 5378 994E                  		subq.w	#1,kosCount.w
000012F4 6700                       		beq.s	ProcessKos_Done			; Branch if there aren't any entries remaining in the queue
000012F6 41F8 9970                  		lea	kosList.w,a0
000012FA 43F8 9978                  		lea	(kosList+8).w,a1		; Otherwise, shift all entries up
000012FE                            	rept (kosList_End-kosList)/8-1
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            	endr
000012FE 20D9                     M 	move.l	(a1)+,(a0)+
00001300 20D9                     M 	move.l	(a1)+,(a0)+
00001302 20D9                     M 	move.l	(a1)+,(a0)+
00001304 20D9                     M 	move.l	(a1)+,(a0)+
00001306 20D9                     M 	move.l	(a1)+,(a0)+
00001308 20D9                     M 	move.l	(a1)+,(a0)+
0000130A                            
0000130A                            ProcessKos_Done:
0000130A 4E75                       		rts
0000130C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000130C                            RestoreKosBookmark:
0000130C 4CB8 007F 9950             		movem.w	kosRegisters.w,d0-d6
00001312 4CF8 2300 995E             		movem.l	(kosRegisters+2*7).w,a0-a1/a5
00001318 2F38 996C                  		move.l	kosBookmark.w,-(sp)
0000131C 3F38 996A                  		move.w	kosStatusReg.w,-(sp)
00001320 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00001322 49FA F9AA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT poiner
00001326 4E73                       		rte
00001328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001328                            BackupKosRegs:
00001328 40F8 996A                  		move	sr,kosStatusReg.w
0000132C 48B8 007F 9950             		movem.w	d0-d6,kosRegisters.w
00001332 48F8 2300 995E             		movem.l	a0-a1/a5,(kosRegisters+2*7).w
00001338 4E75                       		rts
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; Load Kosinski compressed art into VRAM
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; PARAMETERS:
0000133A                            ;	a0.l	- Source address
0000133A                            ;	a1.l	- Destination address
0000133A                            ;	a2.w	- VRAM address
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; RETURNS:
0000133A                            ;	Nothing
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            LoadKosArt:
0000133A 2649                       		movea.l	a1,a3				; Save destination address
0000133C 6100 F7C8                  		bsr.w	KosDec				; Decompress the art
00001340                            
00001340 93CB                       		suba.l	a3,a1				; Get size of decompressed art
00001342 3609                       		move.w	a1,d3				; ''
00001344 E24B                       		lsr.w	#1,d3				; Divide by 2 for DMA
00001346 220B                       		move.l	a3,d1				; Use destination address for DMA source
00001348 340A                       		move.w	a2,d2				; Get destination VRAM address
0000134A 6000 EFB8                  		bra.w	QueueDMATransfer		; Queue a DMA transfer
0000134E                            ; =========================================================================================================================================================
0000134E                            		include	"Libraries/Math.asm"		; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; Get a pseudo random number
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; PARAMETERS:
0000134E                            ;	Nothing
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; RETURNS:
0000134E                            ;	d0.l	- Random number
0000134E                            ;	d1.l	- New seed
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            RandomNumber:
0000134E 2238 C762                  		move.l	randomSeed.w,d1			; Get seed
00001352 6600                       		bne.s	.Generate			; If it's already initialized, branch
00001354 223C 2A6D 365B             		move.l	#$2A6D365B,d1			; Initialize the seed
0000135A                            
0000135A                            .Generate:
0000135A 2001                       		move.l	d1,d0				; Do a bunch of calculations to get a "random" number
0000135C E581                       		asl.l	#2,d1				; ''
0000135E D280                       		add.l	d0,d1				; ''
00001360 E781                       		asl.l	#3,d1				; ''
00001362 D280                       		add.l	d0,d1				; ''
00001364 3001                       		move.w	d1,d0				; ''
00001366 4841                       		swap	d1				; ''
00001368 D041                       		add.w	d1,d0				; ''
0000136A 3200                       		move.w	d0,d1				; ''
0000136C 4841                       		swap	d1				; ''
0000136E 21C1 C762                  		move.l	d1,randomSeed.w			; Set new seed
00001372 4E75                       		rts
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; Calculate the sine and cosine of an angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; PARAMETERS:
00001374                            ;	d0.b	- Angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; RETURNS:
00001374                            ;	d0.w	- Sine value
00001374                            ;	d1.w	- Cosine value	
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            CalcSine:
00001374 0240 00FF                  		andi.w	#$FF,d0				; Only allow angles 0-$FF
00001378 5040                       		addq.w	#8,d0				; Turn into offset
0000137A D040                       		add.w	d0,d0				; ''
0000137C 323B 0000                  		move.w	SineTable-$10+$80(pc,d0.w),d1	; Get cosine value
00001380 303B 0000                  		move.w	SineTable-$10(pc,d0.w),d0	; Get sine value
00001384 4E75                       		rts
00001386                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001386                            SineTable:
00001386 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000013A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000013C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000013E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001406 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001426 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001446 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001466 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001486 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000014A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000014C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000014E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001506 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001526 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001546 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001566 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001586 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000015A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000015C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000015E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001606 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001626 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001646 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001666 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001686 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000016A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000016C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000016E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001706 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001726 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001746 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001766 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; Calculate the arctangent of y/x
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; PARAMETERS:
00001786                            ;	d1.w	- X position
00001786                            ;	d2.w	- Y position
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; RETURNS:
00001786                            ;	d0.w	- The angle
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            CalcArcTan:
00001786                            		push.l	d3-d4
00001786 48E7 1800                M 	movem.l	d3-d4,-(sp)
0000178A 7600                       		moveq	#0,d3
0000178C 7800                       		moveq	#0,d4
0000178E 3601                       		move.w	d1,d3
00001790 3802                       		move.w	d2,d4
00001792 8843                       		or.w	d3,d4
00001794 6700                       		beq.s	GetArcTan_Zero			; Special case when both x and y are zero
00001796 3802                       		move.w	d2,d4
00001798                            		
00001798 4A43                       		tst.w	d3
0000179A 6A00                       		bpl.s	.NotNeg
0000179C 4443                       		neg.w	d3
0000179E                            
0000179E                            .NotNeg:
0000179E 4A44                       		tst.w	d4
000017A0 6A00                       		bpl.s	.NotNeg2
000017A2 4444                       		neg.w	d4
000017A4                            
000017A4                            .NotNeg2:
000017A4 B843                       		cmp.w	d3,d4
000017A6 6400                       		bhs.s	.NotGreater			; If |y| >= |x|
000017A8 E18C                       		lsl.l	#8,d4
000017AA 88C3                       		divu.w	d3,d4
000017AC 7000                       		moveq	#0,d0
000017AE 103B 4000                  		move.b	ArcTanTable(pc,d4.w),d0
000017B2 6000                       		bra.s	.Skip
000017B4                            
000017B4                            .NotGreater:
000017B4 E18B                       		lsl.l	#8,d3
000017B6 86C4                       		divu.w	d4,d3
000017B8 7040                       		moveq	#$40,d0
000017BA 903B 3000                  		sub.b	ArcTanTable(pc,d3.w),d0		; arctan(y/x) = 90 - arctan(x/y)
000017BE                            
000017BE                            .Skip:
000017BE 4A41                       		tst.w	d1
000017C0 6A00                       		bpl.s	.Skip2
000017C2 4440                       		neg.w	d0
000017C4 0640 0080                  		addi.w	#$80,d0				; Place angle in appropriate quadrant
000017C8                            
000017C8                            .Skip2:
000017C8 4A42                       		tst.w	d2
000017CA 6A00                       		bpl.s	.Skip3
000017CC 4440                       		neg.w	d0
000017CE 0640 0100                  		addi.w	#$100,d0			; Place angle in appropriate quadrant
000017D2                            
000017D2                            .Skip3:
000017D2                            		pop.l	d3-d4
000017D2 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017D6 4E75                       		rts
000017D8                            
000017D8                            GetArcTan_Zero:
000017D8 303C 0040                  		move.w	#$40,d0				; Angle = 90 degrees
000017DC                            		pop.l	d3-d4
000017DC 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017E0 4E75                       		rts
000017E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000017E2                            ArcTanTable:
000017E2 0000 0000 0101             		dc.b	$00, $00, $00, $00, $01, $01
000017E8 0101 0101 0202             		dc.b	$01, $01, $01, $01, $02, $02
000017EE 0202 0202 0303             		dc.b	$02, $02, $02, $02, $03, $03
000017F4 0303 0303 0304             		dc.b	$03, $03, $03, $03, $03, $04
000017FA 0404 0404 0405             		dc.b	$04, $04, $04, $04, $04, $05
00001800 0505 0505 0506             		dc.b	$05, $05, $05, $05, $05, $06
00001806 0606 0606 0606             		dc.b	$06, $06, $06, $06, $06, $06
0000180C 0707 0707 0707             		dc.b	$07, $07, $07, $07, $07, $07
00001812 0808 0808 0808             		dc.b	$08, $08, $08, $08, $08, $08
00001818 0809 0909 0909             		dc.b	$08, $09, $09, $09, $09, $09
0000181E 090A 0A0A 0A0A             		dc.b	$09, $0A, $0A, $0A, $0A, $0A
00001824 0A0A 0B0B 0B0B             		dc.b	$0A, $0A, $0B, $0B, $0B, $0B
0000182A 0B0B 0B0C 0C0C             		dc.b	$0B, $0B, $0B, $0C, $0C, $0C
00001830 0C0C 0C0C 0D0D             		dc.b	$0C, $0C, $0C, $0C, $0D, $0D
00001836 0D0D 0D0D 0D0E             		dc.b	$0D, $0D, $0D, $0D, $0D, $0E
0000183C 0E0E 0E0E 0E0E             		dc.b	$0E, $0E, $0E, $0E, $0E, $0E
00001842 0F0F 0F0F 0F0F             		dc.b	$0F, $0F, $0F, $0F, $0F, $0F
00001848 0F10 1010 1010             		dc.b	$0F, $10, $10, $10, $10, $10
0000184E 1010 1111 1111             		dc.b	$10, $10, $11, $11, $11, $11
00001854 1111 1111 1212             		dc.b	$11, $11, $11, $11, $12, $12
0000185A 1212 1212 1213             		dc.b	$12, $12, $12, $12, $12, $13
00001860 1313 1313 1313             		dc.b	$13, $13, $13, $13, $13, $13
00001866 1314 1414 1414             		dc.b	$13, $14, $14, $14, $14, $14
0000186C 1414 1415 1515             		dc.b	$14, $14, $14, $15, $15, $15
00001872 1515 1515 1515             		dc.b	$15, $15, $15, $15, $15, $15
00001878 1616 1616 1616             		dc.b	$16, $16, $16, $16, $16, $16
0000187E 1616 1717 1717             		dc.b	$16, $16, $17, $17, $17, $17
00001884 1717 1717 1718             		dc.b	$17, $17, $17, $17, $17, $18
0000188A 1818 1818 1818             		dc.b	$18, $18, $18, $18, $18, $18
00001890 1818 1919 1919             		dc.b	$18, $18, $19, $19, $19, $19
00001896 1919 1919 1919             		dc.b	$19, $19, $19, $19, $19, $19
0000189C 1A1A 1A1A 1A1A             		dc.b	$1A, $1A, $1A, $1A, $1A, $1A
000018A2 1A1A 1A1B 1B1B             		dc.b	$1A, $1A, $1A, $1B, $1B, $1B
000018A8 1B1B 1B1B 1B1B             		dc.b	$1B, $1B, $1B, $1B, $1B, $1B
000018AE 1B1C 1C1C 1C1C             		dc.b	$1B, $1C, $1C, $1C, $1C, $1C
000018B4 1C1C 1C1C 1C1C             		dc.b	$1C, $1C, $1C, $1C, $1C, $1C
000018BA 1D1D 1D1D 1D1D             		dc.b	$1D, $1D, $1D, $1D, $1D, $1D
000018C0 1D1D 1D1D 1D1E             		dc.b	$1D, $1D, $1D, $1D, $1D, $1E
000018C6 1E1E 1E1E 1E1E             		dc.b	$1E, $1E, $1E, $1E, $1E, $1E
000018CC 1E1E 1E1E 1F1F             		dc.b	$1E, $1E, $1E, $1E, $1F, $1F
000018D2 1F1F 1F1F 1F1F             		dc.b	$1F, $1F, $1F, $1F, $1F, $1F
000018D8 1F1F 1F1F 2020             		dc.b	$1F, $1F, $1F, $1F, $20, $20
000018DE 2020 2020 2000             		dc.b	$20, $20, $20, $20, $20, $00
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            ; Initialize oscillation
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            InitOscillation:
000018E4 43F8 C76C                  		lea	oscillators.w,a1
000018E8 45FA 0000                  		lea	OscInitData(pc),a2
000018EC 7200                       		moveq	#(OscInitData_End-OscInitData)>>1-1,d1
000018EE                            
000018EE                            .LoadData:
000018EE 32DA                       		move.w	(a2)+,(a1)+
000018F0 51C9 FFFC                  		dbf	d1,.LoadData
000018F4 4E75                       		rts
000018F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018F6                            OscInitData:
000018F6 007D                       		dc.w	%0000000001111101
000018F8 0080 0000                  		dc.w	$0080, $0000
000018FC 0080 0000                  		dc.w	$0080, $0000
00001900 0080 0000                  		dc.w	$0080, $0000
00001904 0080 0000                  		dc.w	$0080, $0000
00001908 0080 0000                  		dc.w	$0080, $0000
0000190C 0080 0000                  		dc.w	$0080, $0000
00001910 0080 0000                  		dc.w	$0080, $0000
00001914 0080 0000                  		dc.w	$0080, $0000
00001918 0080 0000                  		dc.w	$0080, $0000
0000191C 3848 00EE                  		dc.w	$3848, $00EE
00001920 2080 00B4                  		dc.w	$2080, $00B4
00001924 3080 010E                  		dc.w	$3080, $010E
00001928 5080 01C2                  		dc.w	$5080, $01C2
0000192C 7080 0276                  		dc.w	$7080, $0276
00001930 0080 0000                  		dc.w	$0080, $0000
00001934 4000 00FE                  		dc.w	$4000, $00FE
00001938                            OscInitData_End:
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            ; Update oscillation
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            UpdateOscillation:
00001938 43F8 C76C                  		lea	oscillators.w,a1
0000193C 45FA 0000                  		lea	OscUpdateData(pc),a2
00001940 3619                       		move.w	(a1)+,d3
00001942 7200                       		moveq	#(OscUpdateData_End-OscUpdateData)>>2-1,d1
00001944                            
00001944                            .OscLoop:
00001944 341A                       		move.w	(a2)+,d2
00001946 381A                       		move.w	(a2)+,d4
00001948 0303                       		btst	d1,d3
0000194A 6600                       		bne.s	.Sub
0000194C 3029 0002                  		move.w	2(a1),d0
00001950 D042                       		add.w	d2,d0
00001952 3340 0002                  		move.w	d0,2(a1)
00001956 D151                       		add.w	d0,(a1)
00001958 B811                       		cmp.b	(a1),d4
0000195A 6200                       		bhi.s	.DoLoop
0000195C 03C3                       		bset	d1,d3
0000195E 6000                       		bra.s	.DoLoop
00001960                            
00001960                            .Sub:
00001960 3029 0002                  		move.w	2(a1),d0
00001964 9042                       		sub.w	d2,d0
00001966 3340 0002                  		move.w	d0,2(a1)
0000196A D151                       		add.w	d0,(a1)
0000196C B811                       		cmp.b	(a1),d4
0000196E 6300                       		bls.s	.DoLoop
00001970 0383                       		bclr	d1,d3
00001972                            
00001972                            .DoLoop:
00001972 5849                       		addq.w	#4,a1
00001974 51C9 FFCE                  		dbf	d1,.OscLoop
00001978                            
00001978 31C3 C76C                  		move.w	d3,oscControl.w
0000197C                            
0000197C                            .End:
0000197C 4E75                       		rts
0000197E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000197E                            OscUpdateData:
0000197E 0002 0010                  		dc.w	$02, $10
00001982 0002 0018                  		dc.w	$02, $18
00001986 0002 0020                  		dc.w	$02, $20
0000198A 0002 0030                  		dc.w	$02, $30
0000198E 0004 0020                  		dc.w	$04, $20
00001992 0008 0008                  		dc.w	$08, $08
00001996 0008 0040                  		dc.w	$08, $40
0000199A 0004 0040                  		dc.w	$04, $40
0000199E 0002 0038                  		dc.w	$02, $38
000019A2 0002 0038                  		dc.w	$02, $38
000019A6 0002 0020                  		dc.w	$02, $20
000019AA 0003 0030                  		dc.w	$03, $30
000019AE 0005 0050                  		dc.w	$05, $50
000019B2 0007 0070                  		dc.w	$07, $70
000019B6 0002 0040                  		dc.w	$02, $40
000019BA 0002 0040                  		dc.w	$02, $40
000019BE                            OscUpdateData_End:
000019BE                            ; =========================================================================================================================================================
000019BE                            		include	"Libraries/Object.asm"		; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; Initialize object lists
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; PARAMETERS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; RETURNS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            InitObjectList:
000019BE                            		clrRAM	objRespawn,objMemory_End		; Clear respawn table and object memory
000019BE                          M 	local	endaddr
000019BE                          M endaddr	equs	"objmemory_end"
000019BE 7000                     M 	moveq	#0,d0
000019C0 43F8 9A54                M 	lea	(objrespawn).w,a1
000019C4 323C 09BF                M 	move.w	#(((objmemory_end)-(objrespawn))-((objrespawn)&1))>>2-1,d1
000019C8 22C0                     M .clear_65:	move.l	d0,(a1)+
000019CA 51C9 FFFC                M 	dbf	d1,.clear_65
000019CE                            
000019CE                            	; setup tail object
000019CE 31FC C154 C158             		move.w	#objExecExit,objExecFirst.w		; set the first object as the tail object
000019D4 31FC C154 C15A             		move.w	#objExecExit,objExecLast.w		; set the last object as the tail object
000019DA 21FC 0000 0000 C154        		move.l	#.rts,objExecExit.w		; set the next rts as the tail object pointer
000019E2                            
000019E2                            	; setup free object list
000019E2 41F8 9D54                  		lea	objMemory.w,a0			; load the objects list into a0
000019E6 31C8 C15C                  		move.w	a0,objExecFree.w			; set the first object as the first free object
000019EA 705E                       		moveq	#OBJECT_COUNT-2,d0		; load object count to d0
000019EC 7260                       		moveq	#_objSize,d1			; load object size to d1
000019EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019EE                            
000019EE                            .load
000019EE D0C1                       		add.w	d1,a0				; go to the next object now
000019F0 3148 FFA6                  		move.w	a0,_objPrev-_objSize(a0)		; save new previous pointer
000019F4 42A8 0008                  		clr.l	_objDrawNext(a0)			; clear the display link values
000019F8 51C8 FFF4                  		dbf	d0,.load			; loop for every object
000019FC                            
000019FC 4268 0006                  		clr.w	_objPrev(a0)			; set the last previous pointer to 0
00001A00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A00                            
00001A00                            	; reset display table
00001A00 43F8 C156                  		lea	objDisplay-dNext.w,a1		; get display table address to a1
00001A04 7207                       		moveq	#8-1,d1				; loop for all the layers
00001A06                            
00001A06                            .dsp
00001A06 3349 000E                  		move.w	a1,dPrev+dNext(a1)		; update prev pointer
00001A0A 5849                       		addq.w	#dNext,a1			; advance to the actual address
00001A0C 3349 0004                  		move.w	a1,dNext(a1)			; update next pointer
00001A10                            
00001A10 42A9 0006                  		clr.l	dN2(a1)				; clear the list end pointers
00001A14 5849                       		addq.w	#dSize-dNext,a1			; go to the next layer
00001A16 51C9 FFEE                  		dbf	d1,.dsp				; loop for all layers
00001A1A                            
00001A1A                            .rts
00001A1A 4E75                       		rts
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; Find the first free object space available
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; PARAMETERS:
00001A1C                            ;	Nothing
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; RETURNS:
00001A1C                            ;	a1.l	- Pointer to the SST space in the free object space
00001A1C                            ;	a2.l	- Trashed
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            FindFreeObj:
00001A1C 3038 C15C                  		move.w	objExecFree.w,d0			; get pointer to the next free object
00001A20 6700                       		beq.s	.rts				; if it's a null pointer (z=1), return
00001A22 3240                       		movea.w	d0,a1				; load to a1
00001A24 31E9 0006 C15C             		move.w	_objPrev(a1),objExecFree.w		; copy the next free object pointer to list start
00001A2A                            
00001A2A 3478 C15A                  		move.w	objExecLast.w,a2			; load last object to a2
00001A2E 31C9 C15A                  		move.w	a1,objExecLast.w			; save as the new last object
00001A32 336A 0004 0004             		move.w	_objNext(a2),_objNext(a1)		; copy the next pointer from old tail to new object
00001A38 3549 0004                  		move.w	a1,_objNext(a2)			; save new object as next pointer for old tail
00001A3C 334A 0006                  		move.w	a2,_objPrev(a1)			; save old tail as prev pointer for new object
00001A40                            
00001A40                            .rts:
00001A40 4E75                       		rts
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; Delete another object
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; PARAMETERS:
00001A42                            ;	a1.l	- Pointer to object space to clear
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; RETURNS:
00001A42                            ;	a1.l	- Trashed
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            DeleteOtherObj:
00001A42 4850                       		pea	(a0)
00001A44 2049                       		move.l	a1,a0
00001A46 6100                       		bsr.s	DeleteObject
00001A48                            		pop.l	a0
00001A48 205F                     M 	move.l	(sp)+,a0
00001A4A 4E75                       		rts
00001A4C                            
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; Delete the current object
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; PARAMETERS:
00001A4C                            ;	Nothing
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; RETURNS:
00001A4C                            ;	a1.l	- Trashed
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            DeleteObject:
00001A4C                            	removeSprite	a0, a1, 1			; remove object display
00001A4C 4A68 0008                M 	tst.w	_objdrawnext(a0)
00001A50 6700                     M 	beq.s	.yes_67
00001A52 3268 000A                M 	move.w	_objdrawprev(a0),a1
00001A56 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00001A5C 3268 0008                M 	move.w	_objdrawnext(a0),a1
00001A60 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
00001A66                          M .no_67
00001A66 42A8 0008                M 	clr.l	_objdrawnext(a0)
00001A6A                          M .yes_67
00001A6A 3268 0006                  		move.w	_objPrev(a0),a1			; copy previous pointer to a1
00001A6E 3368 0004 0004             		move.w	_objNext(a0),_objNext(a1)		; copy next pointer to previous object
00001A74 3268 0004                  		move.w	_objNext(a0),a1			; get next object to a1
00001A78 3368 0006 0006             		move.w	_objPrev(a0),_objPrev(a1)		; copy previous pointer
00001A7E                            
00001A7E 3178 C15C 0006             		move.w	objExecFree.w,_objPrev(a0)		; get the head of the free list to previous pointer of this object
00001A84 31C8 C15C                  		move.w	a0,objExecFree.w			; save as the new head of free list
00001A88                            
00001A88                            ; clear object memory
00001A88 7000                       		moveq	#0,d0				; clear d0
00001A8A 7214                       		moveq	#(((_objSize-_objDrawPrev)>>2)-1),d1	; set loop count
00001A8C                            
00001A8C 4852                       		pea	(a2)				; backup a2
00001A8E 45E8 000A                  		lea	_objDrawPrev(a0),a2		; load the first property to clear to a2
00001A92                            		
00001A92                            .clrLoop:
00001A92 24C0                       		move.l	d0,(a2)+			; clear a longword of the object slot's memory
00001A94 51C9 FFFC                  		dbf	d1,.clrLoop			; loop through to clear all object properties
00001A98                            
00001A98 34C0                       		move.w	d0,(a2)+			; clear the last word of data if the object ram per slot does not divide evenly by 4
00001A9A                            
00001A9A                            		pop.l	a2				; restore a2
00001A9A 245F                     M 	move.l	(sp)+,a2
00001A9C 4E75                       		rts
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; Render object sprites
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; PARAMETERS:
00001A9E                            ;	Nothing
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; RETURNS:
00001A9E                            ;	Nothing
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            RendeobjMemory:
00001A9E 7E4F                       		moveq	#($280/8)-1,d7			; Max sprite count
00001AA0 7C00                       		moveq	#0,d6				; Render flags
00001AA2                            
00001AA2 47F8 E88A                  		lea	fgCamVars.w,a3			; Foreground camera variables
00001AA6 4BF8 C15E                  		lea	objDisplay+dNext.w,a5	; Sprite input table
00001AAA 4DF8 94CE                  		lea	spriteBuff.w,a6			; Sprite table buffer
00001AAE                            
00001AAE 0C38 0004 C75C             		cmpi.b	#gLevel,opmode.w		; Are we in level mode?
00001AB4                            ;		bne.s	.PrioLvlLoop			; If not, branch
00001AB4                            ;		jsr	Level_RenderHUDAndRings		; Render the HUD & Rings (in that order)
00001AB4                            
00001AB4                            .PrioLvlLoop:
00001AB4 3055                       		move.w	(a5),a0				; Load priority level address to a0
00001AB6 504D                       		add.w	#dSize,a5			; Skip bunch of shit
00001AB8 4A68 0008                  		tst.w	_objDrawNext(a0)			; Is the next pointer for a valid object?
00001ABC 6700 0000                  		beq.w	.NextPrioLvl			; If not, branch
00001AC0                            
00001AC0                            .ObjectLoop:
00001AC0                            	;	movea.w	(a4)+,a0			; Get object SST address
00001AC0 4A90                       		tst.l	_objAddress(a0)			; Is this object slot used?
00001AC2 6700 0000                  		beq.w	.NextObject			; If not, branch
00001AC6                            
00001AC6 0228 007F 000D             		andi.b	#$7F,_objRender(a0)		; Clear on-screen flag
00001ACC 1C28 000D                  		move.b	_objRender(a0),d6			; Store render flags
00001AD0 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00001AD4 3228 0018                  		move.w	_objYPos(a0),d1			; Get Y position
00001AD8                            
00001AD8 0806 0006                  		btst	#6,d6				; Is the multi sprite flag set?
00001ADC 6600 0000                  		bne.w	.MultiDraw			; If so, branch
00001AE0 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001AE4 6700                       		beq.s	.Render				; If not, branch
00001AE6                            
00001AE6 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001AE8 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001AEC                            
00001AEC                            .Render:
00001AEC 7400                       		moveq	#0,d2
00001AEE 1428 0017                  		move.b	_objDrawW(a0),d2			; Get sprite width
00001AF2 3600                       		move.w	d0,d3				; Get sprite X position
00001AF4 D642                       		add.w	d2,d3				; Add width
00001AF6 6B00                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001AF8 3600                       		move.w	d0,d3				; Get sprite X position
00001AFA 9642                       		sub.w	d2,d3				; Subtract width
00001AFC 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001B00 6C00                       		bge.s	.NextObject			; If so, branch
00001B02 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001B06                            
00001B06 7400                       		moveq	#0,d2
00001B08 1428 001B                  		move.b	_objDrawH(a0),d2			; Get sprite height
00001B0C 3601                       		move.w	d1,d3				; Get sprite Y position
00001B0E D642                       		add.w	d2,d3				; Add height
00001B10 6B00                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001B12 3601                       		move.w	d1,d3				; Get sprite Y position
00001B14 9642                       		sub.w	d2,d3				; Subtract height
00001B16 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001B1A 6C00                       		bge.s	.NextObject			; If so, branch
00001B1C 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001B20                            
00001B20 0028 0080 000D             		ori.b	#$80,_objRender(a0)		; Set on-screen flag
00001B26 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B28 6B00                       		bmi.s	.NextObject			; If not, branch
00001B2A                            
00001B2A 2828 0010                  		move.l	_objMapping(a0),d4			; Get mappings pointer
00001B2E 6700                       		beq.s	.NextObject			; If blank, branch
00001B30 2244                       		movea.l	d4,a1				; Store it
00001B32 7800                       		moveq	#0,d4
00001B34 0806 0005                  		btst	#5,d6				; Is the static sprite flag set
00001B38 6600                       		bne.s	.Static				; If so, branch
00001B3A 1828 0010                  		move.b	_objFrame(a0),d4			; Get mapping frame
00001B3E D844                       		add.w	d4,d4				; Turn into offset
00001B40 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001B44 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001B46 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001B48 6B00                       		bmi.s	.NextObject			; If there are no sprites to draw, branch
00001B4A                            
00001B4A                            .Static:
00001B4A 3A28 000E                  		move.w	_objVRAM(a0),d5			; Get sprite tile properties
00001B4E 6100 ED02                  		bsr.w	DrawSprite			; Draw the sprites
00001B52                            
00001B52                            .NextObject:	
00001B52 3068 0008                  		move.w	_objDrawNext(a0),a0		; Load next object to a0
00001B56 4A68 0008                  		tst.w	_objDrawNext(a0)			; Check the next pointer for valid object
00001B5A 6600 FF64                  		bne.w	.ObjectLoop			; If there are still some sprites to draw in this priority level, branch
00001B5E                            
00001B5E                            .NextPrioLvl:
00001B5E BAFC C19E                  		cmpa.w	#objDisplay_End,a5		; Are we at the end of the input table?
00001B62 6500 FF50                  		blo.w	.PrioLvlLoop			; If not, branch
00001B66                            
00001B66 3C07                       		move.w	d7,d6				; Get remaining sprite count
00001B68 6B00                       		bmi.s	.SetDrawnSprites		; If we have filled the entire sprite table, branch
00001B6A 7000                       		moveq	#0,d0
00001B6C                            
00001B6C                            .FillRest:
00001B6C 3C80                       		move.w	d0,(a6)				; Move sprite off screen
00001B6E 504E                       		addq.w	#8,a6				; Next sprite
00001B70 51CF FFFA                  		dbf	d7,.FillRest			; Loop
00001B74                            
00001B74                            .SetDrawnSprites:
00001B74 0446 004F                  		subi.w	#($280/8)-1,d6			; Get number of sprites drawn
00001B78 4446                       		neg.w	d6				; ''
00001B7A 11C6 C75D                  		move.b	d6,spriteCount.w		; Store it
00001B7E                            
00001B7E 4E75                       		rts
00001B80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001B80                            .MultiDraw:
00001B80 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001B84 6700                       		beq.s	.RenderMain			; If not, branch
00001B86                            
00001B86 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001B88 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001B8C                            
00001B8C                            .RenderMain:
00001B8C 7400                       		moveq	#0,d2
00001B8E 1428 0017                  		move.b	_objDrawW(a0),d2			; Get main sprite width
00001B92 3600                       		move.w	d0,d3				; Get main sprite X position
00001B94 D642                       		add.w	d2,d3				; Add width
00001B96 6BBA                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001B98 3600                       		move.w	d0,d3				; Get main sprite X position
00001B9A 9642                       		sub.w	d2,d3				; Subtract width
00001B9C 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001BA0 6CB0                       		bge.s	.NextObject			; If so, branch
00001BA2 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001BA6                            
00001BA6 1428 001B                  		move.b	_objDrawH(a0),d2			; Get main sprite height
00001BAA 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BAC D642                       		add.w	d2,d3				; Add height
00001BAE 6BA2                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001BB0 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BB2 9642                       		sub.w	d2,d3				; Subtract height
00001BB4 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001BB8 6C98                       		bge.s	.NextObject			; If so, branch
00001BBA 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001BBE                            
00001BBE 0028 0080 000D             		ori.b	#$80,_objRender(a0)		; Set on-screen flag
00001BC4 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BC6 6B00 FF8A                  		bmi.w	.NextObject			; If not, branch
00001BCA                            
00001BCA 3A28 000E                  		move.w	_objVRAM(a0),d5			; Get sprite tile properties
00001BCE 2828 0010                  		move.l	_objMapping(a0),d4			; Get mappings pointer
00001BD2 6700 FF7E                  		beq.w	.NextObject			; If blank, branch
00001BD6 2444                       		movea.l	d4,a2				; Store it
00001BD8 7800                       		moveq	#0,d4
00001BDA 1828 0010                  		move.b	_objFrame(a0),d4			; Get mapping frame
00001BDE D844                       		add.w	d4,d4				; Turn into offset
00001BE0 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001BE2 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001BE6 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001BE8 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001BEA 6B00                       		bmi.s	.RenderSubSprites		; If there are no sprites to draw, branch
00001BEC 3606                       		move.w	d6,d3				; Store render flags
00001BEE 6100 ED46                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001BF2 3C03                       		move.w	d3,d6				; Restore render flags
00001BF4                            
00001BF4 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BF6 6B00 FF5A                  		bmi.w	.NextObject			; If not, branch
00001BFA                            
00001BFA                            .RenderSubSprites:
00001BFA 3628 002E                  		move.w	_objSubCnt(a0),d3			; Get sub sprite count
00001BFE 5343                       		subq.w	#1,d3				; Subtract 1
00001C00 6B00 FF50                  		bmi.w	.NextObject			; If there are no sprites to draw, branch
00001C04 41E8 0030                  		lea	_objSubStart(a0),a0		; Get sub sprite SSTs start
00001C08                            
00001C08                            .RenderSubSprs_Loop:
00001C08 3018                       		move.w	(a0)+,d0			; Get X position
00001C0A 0640 0080                  		addi.w	#128,d0				; Move on screen
00001C0E 3218                       		move.w	(a0)+,d1			; Get Y position
00001C10 0641 0080                  		addi.w	#128,d1				; Move on screen
00001C14                            
00001C14 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001C18 6700                       		beq.s	.RenderSub			; If not, branch
00001C1A                            
00001C1A 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001C1C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001C20                            
00001C20                            .RenderSub:
00001C20 3818                       		move.w	(a0)+,d4			; Get mapping frame
00001C22 D844                       		add.w	d4,d4				; Turn into offset
00001C24 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001C26 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001C2A 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001C2C 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001C2E 6B00                       		bmi.s	.RenderSubSprs_ChkLoop		; If there are no sprites to draw, branch
00001C30                            		push.w	d6				; Store render flags
00001C30 3F06                     M 	move.w	d6,-(sp)
00001C32 6100 ED02                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001C36                            		pop.w	d6				; Restore render flags
00001C36 3C1F                     M 	move.w	(sp)+,d6
00001C38                            
00001C38                            .RenderSubSprs_ChkLoop:
00001C38 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001C3A 5BCB FFCC                  		dbmi	d3,.RenderSubSprs_Loop		; If so, loop
00001C3E 6000 FF12                  		bra.w	.NextObject			; Continue on rendering other sprites
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; Animate an object's sprite
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; PARAMETERS:
00001C42                            ;	a0.l	- Object space pointer
00001C42                            ;	a1.l	- Animation script pointer
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; RETURNS:
00001C42                            ;	Nothing
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            AnimateObject:
00001C42 7000                       		moveq	#0,d0
00001C44 1028 0020                  		move.b	_objAnim(a0),d0			; Get animation ID
00001C48 B028 0021                  		cmp.b	_objPrevAnim(a0),d0			; Has it changed?
00001C4C 6700                       		beq.s	.Run				; If not, branch
00001C4E 1140 0021                  		move.b	d0,_objPrevAnim(a0)			; Save the new ID
00001C52 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00001C56 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001C5A                            
00001C5A                            .Run:
00001C5A 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00001C5E 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00001C60 D040                       		add.w	d0,d0				; Turn ID into offset
00001C62 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00001C66 1151 0023                  		move.b	(a1),_objAnimTimer(a0)		; Set new animation timer
00001C6A                            
00001C6A 7200                       		moveq	#0,d1
00001C6C 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get current value in the script
00001C70 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00001C74 0C00 00FA                  		cmpi.b	#$FA,d0				; Is it a command value?
00001C78 6400                       		bhs.s	.CmdReset			; If so, branch
00001C7A                            
00001C7A                            .Next:
00001C7A 1140 0010                  		move.b	d0,_objFrame(a0)			; Set mapping frame ID
00001C7E 1028 0028                  		move.b	_objStatus(a0),d0			; Get status
00001C82 0200 0003                  		andi.b	#3,d0				; Only get flip bits
00001C86 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
00001C8C 8128 000D                  		or.b	d0,_objRender(a0)			; Set flip bits
00001C90 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Advance into the animation script
00001C94                            
00001C94                            .Wait:
00001C94 4E75                       		rts
00001C96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C96                            .CmdReset:
00001C96 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00001C98 6600                       		bne.s	.CmdJump			; If not, branch
00001C9A 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00001C9E 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00001CA2 60D6                       		bra.s	.Next				; Continue
00001CA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CA4                            .CmdJump:
00001CA4 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00001CA6 6600                       		bne.s	.CmdSetAnim			; If not, branch
00001CA8 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00001CAC 9128 0022                  		sub.b	d0,_objAnimFrame(a0)		; Go back
00001CB0 9200                       		sub.b	d0,d1				; ''
00001CB2 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00001CB6 60C2                       		bra.s	.Next				; Continue
00001CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CB8                            .CmdSetAnim:
00001CB8 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00001CBA 6600                       		bne.s	.CmdNextRout			; If not, branch
00001CBC 1171 1002 0020             		move.b	2(a1,d1.w),_objAnim(a0)		; Set new animation ID
00001CC2 4E75                       		rts
00001CC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CC4                            .CmdNextRout:
00001CC4 5200                       		addq.b	#1,d0				; Is this flag $FC (next routine)?
00001CC6 6600                       		bne.s	.CmdReset2ndRout		; If not, branch
00001CC8 5428 0025                  		addq.b	#2,_objRoutine(a0)			; Next routine
00001CCC 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001CD0 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Next animation frame
00001CD4 4E75                       		rts
00001CD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CD6                            .CmdReset2ndRout:
00001CD6 5200                       		addq.b	#1,d0				; Is this flag $FB (reset secondary routine)?
00001CD8 6600                       		bne.s	.CmdNext2ndRout			; If not, branch
00001CDA 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001CDE                            ;		clr.b	oWFZRout(a0)			; Reset routine
00001CDE 4E75                       		rts
00001CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE0                            .CmdNext2ndRout:
00001CE0 5200                       		addq.b	#1,d0				; Is this flag $FA (next secondary routine)?
00001CE2 6600                       		bne.s	.CmdEnd				; If not, branch
00001CE4                            ;		addq.b	#2,oWFZRout(a0)			; Next routine
00001CE4 4E75                       		rts
00001CE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE6                            .CmdEnd:
00001CE6 4E75                       		rts
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; Load object DPLCs
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; PARAMETERS:
00001CE8                            ;	d4.w	- Target VRAM address
00001CE8                            ;	d6.l	- Pointer to uncompressed art
00001CE8                            ;	a2.l	- Pointer to DPLCs
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; RETURNS:
00001CE8                            ;	Nothing
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            LoadObjDPLCs:
00001CE8 7000                       		moveq	#0,d0
00001CEA 1028 0010                  		move.b	_objFrame(a0),d0			; Get mapping frame
00001CEE B010                       		cmp.b	_objPrevDPLC(a0),d0		; Do we need to update the art?
00001CF0 6700                       		beq.s	.End				; If not, branch
00001CF2 1080                       		move.b	d0,_objPrevDPLC(a0)		; Save the frame ID so we don't constantly load the art
00001CF4 D040                       		add.w	d0,d0				; Turn ID into offset
00001CF6 D4F2 0000                  		adda.w	(a2,d0.w),a2			; Get pointer to DPLC data for the frame
00001CFA 3A1A                       		move.w	(a2)+,d5			; Get DPLC entry count
00001CFC 5345                       		subq.w	#1,d5				; Subtract 1
00001CFE 6B00                       		bmi.s	.End				; If there are no more entires left, branch
00001D00                            
00001D00                            .ReadEntries:
00001D00 7200                       		moveq	#0,d1
00001D02 321A                       		move.w	(a2)+,d1			; Get DPLC entry data
00001D04 3601                       		move.w	d1,d3				; Copy that
00001D06 E04B                       		lsr.w	#8,d3				; Get tile count
00001D08 0243 00F0                  		andi.w	#$F0,d3				; ''
00001D0C 0643 0010                  		addi.w	#$10,d3				; ''
00001D10 0241 0FFF                  		andi.w	#$FFF,d1			; Get offset in art data
00001D14 EB89                       		lsl.l	#5,d1				; ''
00001D16 D286                       		add.l	d6,d1				; Get pointer in art data
00001D18 3404                       		move.w	d4,d2				; Copy VRAM address
00001D1A D843                       		add.w	d3,d4				; Add tile count to VRAM address
00001D1C D843                       		add.w	d3,d4				; ''
00001D1E 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the art
00001D22 51CD FFDC                  		dbf	d5,.ReadEntries			; Loop
00001D26                            
00001D26                            .End:
00001D26 4E75                       		rts
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; Move an object by it's velocity values
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; PARAMETERS:
00001D28                            ;	a0.l	- Object space pointer
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; RETURNS:
00001D28                            ;	Nothing
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ObjectMove:
00001D28 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00001D2C 48C0                       		ext.l	d0				; ''
00001D2E E188                       		lsl.l	#8,d0				; Shift
00001D30 D1A8 0014                  		add.l	d0,_objXPos(a0)			; Add to the X position
00001D34 3028 001E                  		move.w	_objYVel(a0),d0			; Get Y velocity
00001D38 48C0                       		ext.l	d0				; ''
00001D3A E188                       		lsl.l	#8,d0				; Shift
00001D3C D1A8 0018                  		add.l	d0,_objYPos(a0)			; Add to the Y position
00001D40 4E75                       		rts
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; Move an object by it's velocity values (with gravity)
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; PARAMETERS:
00001D42                            ;	a0.l	- Object space pointer
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; RETURNS:
00001D42                            ;	Nothing
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ObjectMoveAndFall:
00001D42 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00001D46 48C0                       		ext.l	d0				; ''
00001D48 E188                       		lsl.l	#8,d0				; Shift
00001D4A D1A8 0014                  		add.l	d0,_objXPos(a0)			; Add to the X position
00001D4E 3028 001E                  		move.w	_objYVel(a0),d0			; Get Y velocity
00001D52 0668 000C 001E             		addi.w	#$0C,_objYVel(a0)			; Apply gravity
00001D58 48C0                       		ext.l	d0				; ''
00001D5A E188                       		lsl.l	#8,d0				; Shift
00001D5C D1A8 0018                  		add.l	d0,_objYPos(a0)			; Add to the Y position
00001D60 4E75                       		rts
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; Check if a specific object is nearby
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; PARAMETERS:
00001D62                            ;	a0.l	- Current object space pointer
00001D62                            ;	a1.l	- Range data pointer
00001D62                            ;	a2.l	- Object to check's space pointer
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; RETURNS:
00001D62                            ;	d0.w	- Return status (0 if not in range, other object's space pointer if in range)
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            CheckObjInRange:
00001D62 7000                       		moveq	#0,d0
00001D64 322A 0014                  		move.w	_objXPos(a2),d1			; Get other object's position
00001D68 342A 0018                  		move.w	_objYPos(a2),d2			; ''
00001D6C 3628 0014                  		move.w	_objXPos(a0),d3			; Get current object's position
00001D70 3828 0018                  		move.w	_objYPos(a0),d4			; ''
00001D74 D659                       		add.w	(a1)+,d3			; Get left boundary
00001D76 3A03                       		move.w	d3,d5				; Copy
00001D78 DA59                       		add.w	(a1)+,d5			; Get right boundary
00001D7A D859                       		add.w	(a1)+,d4			; Get top boundary
00001D7C 3C04                       		move.w	d4,d6				; Copy
00001D7E DC59                       		add.w	(a1)+,d6			; Get bottom boundary
00001D80 B243                       		cmp.w	d3,d1				; Is the object past the left boundary?
00001D82 6500                       		blo.s	.End				; If not, branch
00001D84 B245                       		cmp.w	d5,d1				; Is the object within the horizontal range?
00001D86 6400                       		bhs.s	.End				; If not, branch
00001D88 B444                       		cmp.w	d4,d2				; Is the object past the top boundary?
00001D8A 6500                       		blo.s	.End				; If not, branch
00001D8C B446                       		cmp.w	d6,d2				; Is the object within the vertical range?
00001D8E 6400                       		bhs.s	.End				; If not, branch
00001D90 300A                       		move.w	a2,d0				; Copy other object's RAM space pointer as the return status
00001D92                            
00001D92                            .End:
00001D92 4E75                       		rts
00001D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D94                            ; Object manager
00001D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D94                            ObjectManager:
00001D94 4A38 C7B6                  		tst.b	objMgrInit.w
00001D98 6600                       		bne.s	ObjectManagerMain
00001D9A                            
00001D9A                            ObjectManagerInit:
00001D9A 50F8 C7B6                  		st	objMgrInit.w			; Set the init flag
00001D9E                            
00001D9E 2078 C7B8                  		movea.l	objMgrLayout.w,a0		; Get object data pointer
00001DA2 21C8 C7BC                  		move.l	a0,objMgrLoadR.w
00001DA6 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store address of object layout
00001DAA                            
00001DAA 47F8 9A54                  		lea	objRespawn.w,a3			; Object respawn table
00001DAE                            
00001DAE 3C38 E88A                  		move.w	fgCamXPos.w,d6			; Camera's X position
00001DB2 0446 0080                  		subi.w	#$80,d6				; Subtract 128
00001DB6 6400                       		bhs.s	.NoReset			; Branch if it doesn't go past the left boundary
00001DB8 7C00                       		moveq	#0,d6				; Cap at left boundary
00001DBA                            
00001DBA                            .NoReset:
00001DBA 0246 FF80                  		andi.w	#$FF80,d6			; Keep in chunks of 128 pixels
00001DBE                            
00001DBE 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get address of the object loader for the right side of the screen
00001DC2                            
00001DC2                            .ChkObjsLeft:
00001DC2 BC50                       		cmp.w	(a0),d6				; Compare object position
00001DC4 6300                       		bls.s	.ChkDone			; If higher than d6, branch
00001DC6 5C48                       		addq.w	#6,a0				; Next object
00001DC8 524B                       		addq.w	#1,a3				; Next respawn table index
00001DCA 60F6                       		bra.s	.ChkObjsLeft			; Loop
00001DCC                            
00001DCC                            .ChkDone:
00001DCC 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001DD0 31CB C7C6                  		move.w	a3,objMgrRespL.w			; ''
00001DD4                            
00001DD4 47F8 9A54                  		lea	objRespawn.w,a3			; Object respawn table
00001DD8                            
00001DD8 2078 C7C0                  		movea.l	objMgrLoadL.w,a0
00001DDC 0446 0080                  		subi.w	#$80,d6				; Subtract from camera's X position again
00001DE0 6500                       		bcs.s	.ChkDone2			; But is done to account for the object loader later on
00001DE2                            
00001DE2                            .ChkObjsRight:
00001DE2 BC50                       		cmp.w	(a0),d6				; Compate object position
00001DE4 6300                       		bls.s	.ChkDone2			; If higher than d6, branch
00001DE6 5C48                       		addq.w	#6,a0				; Next object
00001DE8 524B                       		addq.w	#1,a3				; Next respawn table index
00001DEA 60F6                       		bra.s	.ChkObjsRight			; Loop
00001DEC                            
00001DEC                            .ChkDone2:
00001DEC 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001DF0 31CB C7C4                  		move.w	a3,objMgrRespR.w			; ''
00001DF4                            
00001DF4 31FC FFFF C7CC             		move.w	#-1,objMgrCameraX.w			; Reset manager's camera X position
00001DFA 3038 E892                  		move.w	fgCamYPos.w,d0			; Get camera's Y position
00001DFE 0240 FF80                  		andi.w	#$FF80,d0			; Keep in range
00001E02 31C0 C7CE                  		move.w	d0,objMgrCameraY.w			; Store it so unnecessary Y checks shouldn't be done
00001E06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001E06                            ObjectManagerMain:
00001E06 3238 E892                  		move.w	fgCamYPos.w,d1			; Get camera's Y position
00001E0A 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E0E 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E12 31C1 C7CA                  		move.w	d1,objMgrCoarseY.w		; Store this
00001E16                            
00001E16 3238 E88A                  		move.w	fgCamXPos.w,d1			; Get camera's X position
00001E1A 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E1E 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E22 31C1 C7C8                  		move.w	d1,objMgrCoarseX.w		; Store this
00001E26                            		
00001E26 49F9 0000 0000             		lea	Level_ObjIndex,a4		; Level object index
00001E2C                            
00001E2C 3638 E892                  		move.w	fgCamYPos.w,d3			; Get camera's Y position
00001E30 0243 FF80                  		andi.w	#$FF80,d3			; Keep in range
00001E34 3803                       		move.w	d3,d4				; Copy
00001E36 0644 0200                  		addi.w	#$200,d4			; Lower Y boundary
00001E3A 0443 0080                  		subi.w	#$80,d3				; Upper Y boundary
00001E3E 6A00                       		bpl.s	.SetNoWrap			; If still positive, branch
00001E40 7600                       		moveq	#0,d3				; Cap at upper level boundary
00001E42                            
00001E42                            .SetNoWrap:
00001E42 3A3C 0FFF                  		move.w	#$FFF,d5
00001E46 3C38 E88A                  		move.w	fgCamXPos.w,d6			; Get camera's X position
00001E4A 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001E4E BC78 C7CC                  		cmp.w	objMgrCameraX.w,d6			; Check against last range
00001E52 6700 0000                  		beq.w	Level_LoadObjs_SameXRange	; Branch if they are the same
00001E56 6C00                       		bge.s	Level_LoadObjs_Forward		; If new range is greater than the last, branch
00001E58                            
00001E58 31C6 C7CC                  		move.w	d6,objMgrCameraX.w			; Set new range
00001E5C                            
00001E5C 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001E60 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001E64                            
00001E64 0446 0080                  		subi.w	#$80,d6				; Subtract 128 from the X position
00001E68 6500                       		blo.s	.EndLoad			; If outside of the level boundary, branch
00001E6A                            
00001E6A 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E6E 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E70                            
00001E70                            .LoadLoop:
00001E70 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is in range
00001E74 6C00                       		bge.s	.EndLoadRst			; If not, branch
00001E76 5D88                       		subq.l	#6,a0				; Get actual object address
00001E78 534B                       		subq.w	#1,a3				; Get acutal respawn table address
00001E7A                            
00001E7A 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E7E 6700                       		beq.s	.LoadFail			; Branch if it could not be loaded
00001E80 5D88                       		subq.l	#6,a0
00001E82 60EC                       		bra.s	.LoadLoop			; Attempt to load another object
00001E84                            
00001E84                            .LoadFail:
00001E84 5C88                       		addq.l	#6,a0				; Undo object loading
00001E86 524B                       		addq.w	#1,a3
00001E88 6000                       		bra.s	.EndLoad
00001E8A                            .EndLoadRst:
00001E8A 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001E8E                            
00001E8E                            .EndLoad:
00001E8E 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001E92 31CB C7C4                  		move.w	a3,objMgrRespR.w
00001E96                            
00001E96 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get current objects on the right side of the screen
00001E9A 3678 C7C6                  		movea.w	objMgrRespL.w,a3			; And the appropriate respawn list
00001E9E                            
00001E9E 0646 0300                  		addi.w	#$300,d6			; Load 2 chunks forward
00001EA2                            
00001EA2                            .ChkLoop:
00001EA2 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is out of range
00001EA6 6E00                       		bgt.s	.ChkDone			; If so, branch
00001EA8 5D88                       		subq.l	#6,a0				; Get the object before this
00001EAA 534B                       		subq.w	#1,a3				; And its respawn index
00001EAC 60F4                       		bra.s	.ChkLoop			; Check next object
00001EAE                            
00001EAE                            .ChkDone:
00001EAE 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001EB2 31CB C7C6                  		move.w	a3,objMgrRespL.w
00001EB6 6000                       		bra.s	Level_LoadObjs_SameXRange	; Continue
00001EB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001EB8                            Level_LoadObjs_Forward:
00001EB8 31C6 C7CC                  		move.w	d6,objMgrCameraX.w			; Set new range
00001EBC                            
00001EBC 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get current objects on the right side of the screen
00001EC0 3678 C7C6                  		movea.w	objMgrRespL.w,a3			; And the appropriate respawn list
00001EC4                            
00001EC4 0646 0280                  		addi.w	#$280,d6			; Load 2 chunks forward
00001EC8                            
00001EC8 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001ECC 6700                       		beq.s	.EndLoad			; Branch if it failed
00001ECE                            
00001ECE                            .LoadLoop:
00001ECE BC50                       		cmp.w	(a0),d6				; Check if the last obhect is in range
00001ED0 6300                       		bls.s	.EndLoadRst			; If not, branch
00001ED2 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001ED6 6700                       		beq.s	.EndLoad			; If it failed to, branch
00001ED8 524B                       		addq.w	#1,a3				; Get acutal respawn table address
00001EDA 60F2                       		bra.s	.LoadLoop
00001EDC                            
00001EDC                            .EndLoadRst:
00001EDC 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001EE0                            
00001EE0                            .EndLoad:
00001EE0 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001EE4 31CB C7C6                  		move.w	a3,objMgrRespL.w
00001EE8                            
00001EE8 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001EEC 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001EF0                            
00001EF0 0446 0300                  		subi.w	#$300,d6			; Check 1 chunk backwards
00001EF4 6500                       		blo.s	.ChkDone			; If outside of level, branch
00001EF6                            
00001EF6                            .ChkLoop:
00001EF6 BC50                       		cmp.w	(a0),d6				; Check if the last object is out of range
00001EF8 6300                       		bls.s	.ChkDone			; If so, branch
00001EFA 5C88                       		addq.l	#6,a0				; Get the object before this
00001EFC 524B                       		addq.w	#1,a3				; And its respawn index
00001EFE 60F6                       		bra.s	.ChkLoop			; Check next object
00001F00                            
00001F00                            .ChkDone:
00001F00 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001F04 31CB C7C4                  		move.w	a3,objMgrRespR.w
00001F08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F08                            Level_LoadObjs_SameXRange:
00001F08 3C38 E892                  		move.w	fgCamYPos.w,d6			; Get camera's X position
00001F0C 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001F10 3606                       		move.w	d6,d3				; Copy
00001F12 BC78 C7CE                  		cmp.w	objMgrCameraY.w,d6			; Check against last range
00001F16 6700 0000                  		beq.w	.LoadEnd			; Branch if they are the same
00001F1A 6C00                       		bge.s	.MovingDown			; If the new raqnge is greater than the last, branch
00001F1C                            
00001F1C 0443 0080                  		subi.w	#$80,d3				; Loop 1 chunk up
00001F20 6B00 0000                  		bmi.w	.LoadEnd
00001F24 6000                       		bra.s	.YCheck
00001F26                            
00001F26                            .MovingDown:
00001F26 0643 0180                  		addi.w	#$180,d3			; Look 1 chunk down
00001F2A                            
00001F2A                            .YCheck:
00001F2A 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001F2E 6700                       		beq.s	.LoadEnd			; If failed, branch
00001F30                            		
00001F30 3803                       		move.w	d3,d4				; Copy Y position
00001F32 0644 0080                  		addi.w	#$80,d4				; Look one chunk down
00001F36 3A3C 0FFF                  		move.w	#$FFF,d5
00001F3A                            
00001F3A 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001F3E 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001F42 2E38 C7BC                  		move.l	objMgrLoadR.w,d7			; Get current objects on the right side of the screen
00001F46 9E88                       		sub.l	a0,d7				; Subtract the left position from the right
00001F48 6700                       		beq.s	.LoadEndRst			; Branch if no objects
00001F4A 5488                       		addq.l	#2,a0				; Align to object's Y position
00001F4C                            
00001F4C                            .LoadNext:
00001F4C 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F4E 6B00                       		bmi.s	.LoadFail			; If so, branch
00001F50                            
00001F50 3210                       		move.w	(a0),d1				; Get object's Y position
00001F52 C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F54 B243                       		cmp.w	d3,d1
00001F56 6500                       		blo.s	.LoadFail			; Branch if out of range in the top
00001F58 B244                       		cmp.w	d4,d1
00001F5A 6200                       		bhi.s	.LoadFail			; Branch if out of range in the botoom
00001F5C                            
00001F5C 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F60 3368 FFFE 0014             		move.w	-2(a0),_objXPos(a1)			; Set X position
00001F66 3210                       		move.w	(a0),d1				; Get object's Y position
00001F68 3401                       		move.w	d1,d2				; Copy it
00001F6A C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F6C 3341 0018                  		move.w	d1,_objYPos(a1)			; Set Y position
00001F70                            
00001F70 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F72 0242 0003                  		andi.w	#3,d2				; ''
00001F76 1342 000D                  		move.b	d2,_objRender(a1)			; Set render flags
00001F7A 1342 0028                  		move.b	d2,_objStatus(a1)			; Set status
00001F7E                            
00001F7E 1428 0002                  		move.b	2(a0),d2			; Get ID
00001F82 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001F84 D442                       		add.w	d2,d2
00001F86 22B4 2000                  		move.l	(a4,d2.w),_objAddress(a1)		; Set address
00001F8A                            
00001F8A 1368 0003 0024             		move.b	3(a0),_objSubtype(a1)		; Set subtype
00001F90 334B 0026                  		move.w	a3,_objRespawn(a1)			; Set respawn address
00001F94                            
00001F94 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00001F98 6700                       		beq.s	.LoadEnd			; If none could be loaded, branch
00001F9A                            
00001F9A                            .LoadFail:
00001F9A 5C88                       		addq.l	#6,a0				; Next object
00001F9C 524B                       		addq.w	#1,a3				; ''
00001F9E 5D87                       		subq.l	#6,d7				; Subtract the size of the entry
00001FA0 66AA                       		bne.s	.LoadNext			; If there are some objects remaining, branch
00001FA2                            
00001FA2                            .LoadEndRst:
00001FA2 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001FA6                            
00001FA6                            .LoadEnd:
00001FA6 31C6 C7CE                  		move.w	d6,objMgrCameraY.w		; Store manager's camera Y position
00001FAA 4E75                       		rts
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            ; Load an object from the object layout
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            ; PARAMETERS:
00001FAC                            ;	d3.w	- Upper boundary
00001FAC                            ;	d4.w	- Lower boundary
00001FAC                            ;	d5.w	- Y position limit
00001FAC                            ;	a0.l	- Index of object layout
00001FAC                            ;	a1.l	- Target object
00001FAC                            ;	a3.l	- Respawn table address
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            Level_LoadObject:
00001FAC 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001FAE 6A00                       		bpl.s	.NotLoaded			; If not, branch
00001FB0 5C88                       		addq.l	#6,a0				; Next object
00001FB2 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FB4 4E75                       		rts
00001FB6                            
00001FB6                            .NotLoaded:
00001FB6 3E18                       		move.w	(a0)+,d7			; X position
00001FB8 3218                       		move.w	(a0)+,d1			; Y position
00001FBA 3401                       		move.w	d1,d2				; Copy
00001FBC 6B00                       		bmi.s	.LoadNoY			; If the object is set to ignore Y checks, branch
00001FBE C245                       		and.w	d5,d1				; Keey Y in range
00001FC0 B243                       		cmp.w	d3,d1
00001FC2 6500                       		bcs.s	.End				; Branch if in range
00001FC4 B244                       		cmp.w	d4,d1
00001FC6 6300                       		bls.s	.Spawn				; Branch if in range
00001FC8                            
00001FC8                            .End:
00001FC8 5448                       		addq.w	#2,a0				; Next objeect
00001FCA 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FCC 4E75                       		rts
00001FCE                            
00001FCE                            .LoadNoY:
00001FCE C245                       		and.w	d5,d1				; Keey Y in range
00001FD0                            
00001FD0                            .Spawn:
00001FD0 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001FD4 3347 0014                  		move.w	d7,_objXPos(a1)			; Store X position
00001FD8 3341 0018                  		move.w	d1,_objYPos(a1)			; Store Y position
00001FDC                            
00001FDC E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001FDE 0242 0003                  		andi.w	#3,d2				; ''
00001FE2 1342 000D                  		move.b	d2,_objRender(a1)			; Set render flags
00001FE6 1342 0028                  		move.b	d2,_objStatus(a1)			; Set status
00001FEA                            
00001FEA 1418                       		move.b	(a0)+,d2			; Get ID
00001FEC D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001FEE D442                       		add.w	d2,d2
00001FF0 22B4 2000                  		move.l	(a4,d2.w),_objAddress(a1)		; Set address
00001FF4                            
00001FF4 1358 0024                  		move.b	(a0)+,_objSubtype(a1)		; Set subtype
00001FF8 334B 0026                  		move.w	a3,_objRespawn(a1)			; Set respawn address
00001FFC                            		
00001FFC 6000 FA1E                  		bra.w	FindFreeObj			; Find a free object slot
00002000                            		
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; Check if the object is in range on the camera. If it isn't, delete it
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; PARAMETERS:
00002000                            ;	a0.l	- Object space pointer
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; RETURNS:
00002000                            ;	Nothing
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            CheckObjActive:
00002000 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00002004                            
00002004                            CheckObjActive2:
00002004 0240 FF80                  		andi.w	#$FF80,d0			; Only allow multiples of $80
00002008 9078 C7C8                  		sub.w	objMgrCoarseX.w,d0		; Subtract the camera's coarse X position
0000200C 0C40 0280                  		cmpi.w	#$280,d0			; Has it gone offscreen?
00002010 6200                       		bhi.s	.Delete				; If so, branch
00002012 4E75                       		rts
00002014                            
00002014                            .Delete:
00002014 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table entry address
00002018 6700                       		beq.s	.DoDelete			; If 0, branch
0000201A 3440                       		movea.w	d0,a2
0000201C 0892 0007                  		bclr	#7,(a2)				; Mark as gone
00002020                            
00002020                            .DoDelete:
00002020 4EF8 1A4C                  		jmp	DeleteObject.w			; Delete the object
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; Get orientation to player
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; PARAMETERS:
00002024                            ;	a0.l	- Object space pointer
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; RETURNS:
00002024                            ;	a1.l	- Player object
00002024                            ;	d0.w	- 0 if player is left from object, 2 if right
00002024                            ;	d1.w	- 0 if player is above object, 2 if below
00002024                            ;	d2.w	- Player's horizontal distance to object
00002024                            ;	d3.w	- Player's vertical distance to object
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            GetOrientToPlayer:
00002024 7000                       		moveq	#0,d0
00002026 7200                       		moveq	#0,d1
00002028                            
00002028 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get player object
0000202C                            
0000202C 3428 0014                  		move.w	_objXPos(a0),d2			; Get horizonal distance
00002030 9469 0014                  		sub.w	_objXPos(a1),d2			; ''
00002034 6A00                       		bpl.s	.GetY				; Branch if the player is left from the object
00002036 5440                       		addq.w	#2,d0				; Set flag to indicate that the player is right from the object
00002038                            
00002038                            .GetY:
00002038 3628 0018                  		move.w	_objYPos(a0),d3			; Get vertical distance
0000203C 9669 0018                  		sub.w	_objYPos(a1),d3			; ''
00002040 6400                       		bhs.s	.End				; Branch if the player is above the object
00002042 5441                       		addq.w	#2,d1				; Set flag to indicate that the player is below the object
00002044                            
00002044                            .End:
00002044 4E75                       		rts
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; Cap an object's speed
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; PARAMETERS:
00002046                            ;	a0.l	- Object space pointer
00002046                            ;	d0.w	- Max X speed
00002046                            ;	d1.w	- Max Y speed
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; RETURNS:
00002046                            ;	Nothing
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            CapObjSpeed:
00002046 3428 001C                  		move.w	_objXVel(a0),d2			; Get X velocity
0000204A 6A00                       		bpl.s	.ChkRight			; If we are going right, branch
0000204C 4440                       		neg.w	d0				; Get absolute speed
0000204E B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002050 6400                       		bhs.s	.ChkUp				; If not, branch
00002052 3400                       		move.w	d0,d2				; Cap the speed
00002054 6000                       		bra.s	.ChkUp				; Continue
00002056                            
00002056                            .ChkRight:
00002056 B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002058 6300                       		bls.s	.ChkUp				; If not, branch
0000205A 3400                       		move.w	d0,d2				; Cap the speed
0000205C                            
0000205C                            .ChkUp:
0000205C 3628 001E                  		move.w	_objYVel(a0),d3			; Get Y velocity
00002060 6A00                       		bpl.s	.ChkDown			; If we are going right, branch
00002062 4441                       		neg.w	d1				; Get absolute speed
00002064 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
00002066 6400                       		bhs.s	.UpdateVel			; If not, branch
00002068 3601                       		move.w	d1,d3				; Cap the speed
0000206A 6000                       		bra.s	.UpdateVel			; Continue
0000206C                            
0000206C                            .ChkDown:
0000206C B641                       		cmp.w	d1,d3				; Has it gone over the limit?
0000206E 6300                       		bls.s	.UpdateVel			; If not, branch
00002070 3601                       		move.w	d1,d3				; Cap the speed
00002072                            
00002072                            .UpdateVel:
00002072 3142 001C                  		move.w	d2,_objXVel(a0)			; Set X velocity
00002076 3142 001E                  		move.w	d2,_objYVel(a0)			; Set Y velocity
0000207A 4E75                       		rts
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; Load a child object	NTP: no idea wtf to do about this one. do we even need it since all objects are kinda linked anyway? we'll have to see
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; PARAMETERS:
0000207C                            ;	a2.l	- Object data
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; RETURNS:
0000207C                            ;	Nothing
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; LoadChildObject:
0000207C 6100 F99E                  		bsr.w	FindFreeObj			; Find a free object slot
00002080 6600                       		bne.s	.End				; If there is non, branch
00002082 301A                       		move.w	(a2)+,d0			; Get parent object SST
00002084 3388 0000                  		move.w	a0,(a1,d0.w)			; Store parent object
00002088 301A                       		move.w	(a2)+,d0			; Get child object SST
0000208A 3189 0000                  		move.w	a1,(a0,d0.w)			; Store child object
0000208E 229A                       		move.l	(a2)+,_objAddress(a1)			; Set object pointer
00002090 135A 0024                  		move.b	(a2)+,_objSubtype(a1)		; Set subtype
00002094 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)			; Set X
0000209A 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)			; Set Y
000020A0                            
000020A0                            .End:
000020A0 4E75                       		rts
000020A2                            ; =========================================================================================================================================================
000020A2                            		include	"Libraries/Interrupt.asm"	; Interrupt functions
000020A2                            ; =========================================================================================================================================================
000020A2                            ; Interrupt functions
000020A2                            ; =========================================================================================================================================================
000020A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A2                            ; Vertical Interrupts
000020A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A2                            VInt_Standard:
000020A2                            		intsOff					; Turn interrupts off
000020A2 007C 0700                M 	ori	#$700,sr
000020A6                            		push.l	d0-a6				; Save registers
000020A6 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000020AA                            		
000020AA 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
000020B0 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
000020B4                            
000020B4                            .WaitForVBLANK:
000020B4 3016                       		move.w	(a6),d0				; Get VDP status
000020B6 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
000020BA 67F8                       		beq.s	.WaitForVBLANK			; If not, wait
000020BC                            
000020BC 0838 0006 C746             		btst	#6,hwVersion.w		; Is this a PAL system?
000020C2 6700                       		beq.s	.SetVScroll			; If not, branch
000020C4 303C 0700                  		move.w	#$700,d0			; Do a delay
000020C8 51C8 FFFE                  		dbf	d0,*				; ''
000020CC                            
000020CC                            .SetVScroll:
000020CC                            		dma68k	vScrollBuff,0,$50,VSRAM		; Load VScroll buffer into VSRAM
000020CC 2CBC 9400 9328           M 	move.l	#$94009300|(((($50)/2)&$ff00)<<8)|((($50)/2)&$ff),(a6)
000020D2 2CBC 96CA 953F           M 	move.l	#$96009500|((((vscrollbuff)/2)&$ff00)<<8)|(((vscrollbuff)/2)&$ff),(a6)
000020D8 3CBC 977F                M 	move.w	#$9700|(((vscrollbuff)>>17)&$7f),(a6)
000020DC                          M 	vdpcmd	move.w,0,vsram,dma,>>16,(a6)
000020DC 3CBC 4000                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000020E0                          M 	vdpcmd	move.w,0,vsram,dma,&$ffff,-(sp)
000020E0 3F3C 0090                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000020E4 3C9F                     M 	move.w	(sp)+,(a6)
000020E6                            
000020E6 4A38 C747                  		tst.b	vIntRoutine.w			; Is the game lagging?
000020EA 6700 0000                  		beq.w	VInt_Lag_Main			; If so, branch
000020EE 4238 C74A                  		clr.b	lagCounter.w			; Clear lag frame counter
000020F2                            
000020F2 7000                       		moveq	#0,d0
000020F4 1038 C747                  		move.b	vIntRoutine.w,d0		; Get V-INT routine ID
000020F8 4238 C747                  		clr.b	vIntRoutine.w			; Clear V-INT routine ID
000020FC 50F8 C74B                  		st	hIntFlag.w			; Allow the H-INT to run
00002100 303B 0000                  		move.w	VInt_Routines(pc,d0.w),d0	; Get V-INT routine offset
00002104 4EBB 0000                  		jsr	VInt_Routines(pc,d0.w)		; Jump to the routine
00002108                            
00002108                            VInt_FinishUpdates:
00002108 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
0000210E                            
0000210E                            VInt_End:
0000210E 52B8 C758                  		addq.l	#1,frameCounter.w		; Increment frame count
00002112 6100 F23A                  		bsr.w	RandomNumber			; Generate a random number
00002116                            		
00002116                            		pop.l	d0-a6				; Restore registers
00002116 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000211A                            		intsOn					; Turn interrupts on
0000211A 027C F8FF                M 	andi	#$f8ff,sr
0000211E                            		lagOn					; Turn on the lag-o-meter
0000211E 4E73                       		rte
00002120                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002120                            ; V-INT routines
00002120                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002120                            VInt_Routines:
00002120 0000                       		dc.w	VInt_Lag-VInt_Routines		; Lag routine
00002122 0000                       		dc.w	VInt_General-VInt_Routines	; General routine
00002124 0000                       		dc.w	VInt_Level-VInt_Routines	; Level routine
00002126 0000                       		dc.w	VInt_LevelLoad-VInt_Routines	; Level load routine
00002128 0000                       		dc.w	VInt_Title-VInt_Routines	; Title screen routine
0000212A 0000                       		dc.w	VInt_Fade-VInt_Routines		; Fade routine
0000212C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000212C                            ; V-INT lag routine
0000212C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000212C                            VInt_Lag:
0000212C 584F                       		addq.w	#4,sp				; Don't return to caller
0000212E                            
0000212E                            VInt_Lag_Main:
0000212E 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
00002132 6600                       		bne.s	.WaterPal			; If so, branch
00002134                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
00002134 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000213A 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002140 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
00002144                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002144 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002148                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002148 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000214C 3C9F                     M 	move.w	(sp)+,(a6)
0000214E 6000                       		bra.s	.Cont				; Continue
00002150                            
00002150                            .WaterPal:
00002150                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002150 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002156 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
0000215C 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002160                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002160 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002164                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002164 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002168 3C9F                     M 	move.w	(sp)+,(a6)
0000216A                            
0000216A                            .Cont:	
0000216A 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
0000216E                            
0000216E 5238 C74A                  		addq.b	#1,lagCounter.w		; Increment lag counter
00002172 6000 FF94                  		bra.w	VInt_FinishUpdates		; Go update SMPS
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            ; V-INT general routine
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            VInt_General:
00002176 6100 0000                  		bsr.w	VInt_Update			; Do updates
0000217A 6000 EF5C                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
0000217E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000217E                            ; V-INT level load routine
0000217E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000217E                            VInt_LevelLoad:
0000217E 6100 E93A                  		bsr.w	ReadJoypads			; Read joypads
00002182                            
00002182 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
00002186 6600                       		bne.s	.WaterPal			; If so, branch
00002188                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
00002188 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000218E 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002194 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
00002198                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002198 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000219C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000219C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021A0 3C9F                     M 	move.w	(sp)+,(a6)
000021A2 6000                       		bra.s	.Cont				; Continue
000021A4                            
000021A4                            .WaterPal:
000021A4                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
000021A4 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021AA 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
000021B0 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
000021B4                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021B4 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021B8                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021B8 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021BC 3C9F                     M 	move.w	(sp)+,(a6)
000021BE                            
000021BE                            .Cont:
000021BE 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
000021C2                            		
000021C2                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
000021C2 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000021C8 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
000021CE 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
000021D2                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000021D2 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000021D6                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000021D6 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000021DA 3C9F                     M 	move.w	(sp)+,(a6)
000021DC                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
000021DC 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
000021E2 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
000021E8 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
000021EC                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
000021EC 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
000021F0                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
000021F0 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
000021F4 3C9F                     M 	move.w	(sp)+,(a6)
000021F6 6100 E1B0                  		bsr.w	ProcessDMAQueue			; Process DMA queue
000021FA                            		
000021FA 6000 EEDC                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000021FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021FE                            ; V-INT level routine
000021FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021FE                            VInt_Level:
000021FE 43F8 E88A                  		lea	fgCamVars.w,a1			; Foreground level drawing variables
00002202 47F8 C2A0                  		lea	fgColBuff.w,a3		; Foreground column plane buffer
00002206 49F8 C19E                  		lea	fgRowBuff.w,a4		; Foreground row plane buffer
0000220A 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the foreground plane
00002210 43F8 E8A8                  		lea	bgCamVars.w,a1			; Background level drawing variables
00002214 47F8 C424                  		lea	bgColBuff.w,a3		; Background column plane buffer
00002218 49F8 C322                  		lea	bgRowBuff.w,a4		; Background row plane buffer
0000221C 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the background plane
00002222                            
00002222 6100 E896                  		bsr.w	ReadJoypads			; Read joypads
00002226                            
00002226 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
0000222A 6600                       		bne.s	.WaterPal			; If so, branch
0000222C                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
0000222C 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002232 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002238 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
0000223C                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000223C 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002240                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002240 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002244 3C9F                     M 	move.w	(sp)+,(a6)
00002246 6000                       		bra.s	.Cont				; Continue
00002248                            
00002248                            .WaterPal:
00002248                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002248 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000224E 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
00002254 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002258                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002258 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000225C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000225C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002260 3C9F                     M 	move.w	(sp)+,(a6)
00002262                            
00002262                            .Cont:
00002262 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
00002266                            
00002266                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
00002266 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
0000226C 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
00002272 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
00002276                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
00002276 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000227A                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000227A 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
0000227E 3C9F                     M 	move.w	(sp)+,(a6)
00002280                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002280 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002286 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
0000228C 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
00002290                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002290 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002294                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002294 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002298 3C9F                     M 	move.w	(sp)+,(a6)
0000229A 6100 E10C                  		bsr.w	ProcessDMAQueue			; Process DMA queue
0000229E                            		
0000229E 0C38 005C C761             		cmpi.b	#92,hIntCntValue.w		; Would V-INT be unable to do updates in the next frame?
000022A4 6400                       		bhs.s	.DoUpdates			; If not, branch
000022A6 50F8 C75F                  		st	hIntUpdates.W		; Set updates in H-INT flag
000022AA 584F                       		addq.w	#4,sp				; Skip SMPS update routine afterwards
000022AC 6100 EE2A                  		bsr.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022B0 6000 FE5C                  		bra.w	VInt_End			; Continue
000022B4                            
000022B4                            .DoUpdates:
000022B4 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
000022BA 6000 EE1C                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022BE                            ; V-INT title screen update routine
000022BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022BE                            VInt_Title:
000022BE 4E75                       		rts
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            ;		bsr.w	ReadJoypads			; Read joypads
000022C0                            ;
000022C0                            ;		move.l	#$C0000000,VDP_CTRL		; Write palette to CRAM
000022C0                            ;		lea	paletteBuff.w,a0			; ''
000022C0                            ;		moveq	#$80>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WritePal:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WritePal			; ''
000022C0                            ;
000022C0                            ;		move.l	#$78000003,VDP_CTRL		; Write sprite data to VRAM
000022C0                            ;		lea	spriteBuff.w,a0			; ''
000022C0                            ;		move.w	#$280>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WriteSprs:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WriteSprs			; ''
000022C0                            ;
000022C0                            ;		move.l	#$7C000003,VDP_CTRL		; Write HScroll table to VRAM
000022C0                            ;		lea	hScrollBuff.w,a0			; ''
000022C0                            ;		move.w	#$380>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WriteHScrl:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WriteHScrl			; ''
000022C0                            ;		rts
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            ; Do standard updates in V-INT
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            VInt_Update:
000022C0                            	; NTP: We don't want to update sprites during a fade, thus it's not shared with the below interrupt routine
000022C0                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
000022C0 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000022C6 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
000022CC 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
000022D0                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000022D0 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000022D4                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000022D4 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022D8 3C9F                     M 	move.w	(sp)+,(a6)
000022DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022DA                            ; V-INT fade routine
000022DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022DA                            VInt_Fade:
000022DA 6100 E7DE                  		bsr.w	ReadJoypads			; Read joypads
000022DE                            
000022DE 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
000022E2 6600                       		bne.s	.WaterPal			; If so, branch
000022E4                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
000022E4 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000022EA 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
000022F0 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
000022F4                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000022F4 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000022F8                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000022F8 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000022FC 3C9F                     M 	move.w	(sp)+,(a6)
000022FE 6000                       		bra.s	.Cont				; Continue
00002300                            
00002300                            .WaterPal:
00002300                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002300 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002306 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
0000230C 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002310                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002310 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002314                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002314 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002318 3C9F                     M 	move.w	(sp)+,(a6)
0000231A                            
0000231A                            .Cont:
0000231A 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
0000231E                            
0000231E                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
0000231E 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002324 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
0000232A 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
0000232E                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
0000232E 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002332                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002332 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002336 3C9F                     M 	move.w	(sp)+,(a6)
00002338 6000 E06E                  		bra.w	ProcessDMAQueue			; Process DMA queue
0000233C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233C                            ; V-INT routine that only runs the SMPS driver
0000233C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233C                            VInt_RunSMPS:
0000233C                            		push.l	d0-a6				; Save registers
0000233C 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002340                            		
00002340                            .WaitForVBLANK:
00002340 3039 00C0 0004             		move.w	VDP_CTRL,d0			; Get VDP status
00002346 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
0000234A 67F4                       		beq.s	.WaitForVBLANK			; If not, wait
0000234C                            
0000234C 0838 0006 C746             		btst	#6,hwVersion.w		; Is this a PAL system?
00002352 6700                       		beq.s	.UpdateSMPS			; If not, branch
00002354 303C 0700                  		move.w	#$700,d0			; Do a delay
00002358 51C8 FFFE                  		dbf	d0,*				; ''
0000235C                            
0000235C                            .UpdateSMPS:
0000235C 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002362                            
00002362 52B8 C758                  		addq.l	#1,frameCounter.w		; Increment frame count
00002366 6100 EFE6                  		bsr.w	RandomNumber			; Generate a random number
0000236A                            		
0000236A                            		pop.l	d0-a6				; Restore registers
0000236A 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000236E 4E73                       		rte
00002370                            
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; Wait for the vertical interrupt to run and finish
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; PARAMETERS:
00002370                            ;	Nothing
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; RETURNS:
00002370                            ;	Nothing
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            VSync:
00002370 50F8 C747                  		st	vIntFlag.w			; Set V-INT flag
00002374                            
00002374                            VSync_Routine:
00002374                            		intsOn					; Enable interrupts
00002374 027C F8FF                M 	andi	#$f8ff,sr
00002378                            		lagOff					; Turn off the lag-o-meter
00002378                            
00002378                            .Wait:
00002378 4A38 C747                  		tst.b	vIntFlag.w			; Has the V-INT run yet?
0000237C 66FA                       		bne.s	.Wait				; If not, wait some more
0000237E 4E75                       		rts
00002380                            
00002380                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002380                            ; Horizontal interrupt for palette swapping (for water)
00002380                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002380                            HInt_Water:
00002380                            		intsOff					; Disable interrupts
00002380 007C 0700                M 	ori	#$700,sr
00002384                            
00002384 4A38 C74B                  		tst.b	hIntFlag.w			; Is the H-INT allowed to run?
00002388 6700                       		beq.s	.End				; If not, branch
0000238A 4238 C74B                  		clr.b	hIntFlag.w			; Clear the H-INT flag
0000238E                            
0000238E                            		push.l	a0-a1				; Save registers
0000238E 48E7 00C0                M 	movem.l	a0-a1,-(sp)
00002392                            
00002392 43F9 00C0 0000             		lea	VDP_DATA,a1			; VDP data port
00002398 337C 8AFF 0004             		move.w	#$8AFF,4(a1)			; Don't do any more H-INT calls for the rest of the frame
0000239E 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette
000023A2                            		vdpCmd	move.l, 0, CRAM, WRITE, 4(a1)	; Set VDP command
000023A2 237C C000 0000 0004      M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),4(a1)
000023AA                            		rept	32
000023AA                            			move.l	(a0)+,(a1)		; Tranfer palette
000023AA                            		endr
000023AA 2298                     M 	move.l	(a0)+,(a1)
000023AC 2298                     M 	move.l	(a0)+,(a1)
000023AE 2298                     M 	move.l	(a0)+,(a1)
000023B0 2298                     M 	move.l	(a0)+,(a1)
000023B2 2298                     M 	move.l	(a0)+,(a1)
000023B4 2298                     M 	move.l	(a0)+,(a1)
000023B6 2298                     M 	move.l	(a0)+,(a1)
000023B8 2298                     M 	move.l	(a0)+,(a1)
000023BA 2298                     M 	move.l	(a0)+,(a1)
000023BC 2298                     M 	move.l	(a0)+,(a1)
000023BE 2298                     M 	move.l	(a0)+,(a1)
000023C0 2298                     M 	move.l	(a0)+,(a1)
000023C2 2298                     M 	move.l	(a0)+,(a1)
000023C4 2298                     M 	move.l	(a0)+,(a1)
000023C6 2298                     M 	move.l	(a0)+,(a1)
000023C8 2298                     M 	move.l	(a0)+,(a1)
000023CA 2298                     M 	move.l	(a0)+,(a1)
000023CC 2298                     M 	move.l	(a0)+,(a1)
000023CE 2298                     M 	move.l	(a0)+,(a1)
000023D0 2298                     M 	move.l	(a0)+,(a1)
000023D2 2298                     M 	move.l	(a0)+,(a1)
000023D4 2298                     M 	move.l	(a0)+,(a1)
000023D6 2298                     M 	move.l	(a0)+,(a1)
000023D8 2298                     M 	move.l	(a0)+,(a1)
000023DA 2298                     M 	move.l	(a0)+,(a1)
000023DC 2298                     M 	move.l	(a0)+,(a1)
000023DE 2298                     M 	move.l	(a0)+,(a1)
000023E0 2298                     M 	move.l	(a0)+,(a1)
000023E2 2298                     M 	move.l	(a0)+,(a1)
000023E4 2298                     M 	move.l	(a0)+,(a1)
000023E6 2298                     M 	move.l	(a0)+,(a1)
000023E8 2298                     M 	move.l	(a0)+,(a1)
000023EA                            		pop.l	a0-a1				; Restore registers
000023EA 4CDF 0300                M 	movem.l	(sp)+,a0-a1
000023EE                            		
000023EE 4A38 C75F                  		tst.b	hIntUpdates.w		; Do we need to do level updates in here?
000023F2 6600                       		bne.s	.DoUpdates			; If so, branch
000023F4                            
000023F4                            .End:
000023F4 4E73                       		rte
000023F6                            
000023F6                            .DoUpdates:
000023F6 4238 C75F                  		clr.b	hIntUpdates.w		; Clear the update flag
000023FA                            		push.l	d0-a6				; Save registers
000023FA 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000023FE 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002404 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002408 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
0000240E 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002414                            		pop.l	d0-a6				; Restore registers
00002414 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
00002418 4E73                       		rte
0000241A                            ; =========================================================================================================================================================
0000241A                            
0000241A                            ; =========================================================================================================================================================
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            ; Opmode Main Code
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            		include	"Opmodes/Title/Main.asm"
0000241A                            ; =========================================================================================================================================================
0000241A                            ; Title splash screen
0000241A                            ; =========================================================================================================================================================
0000241A                            locVRAM:	macro loc,controlport
0000241A                            		move.l	#($40000000+(((loc)&$3FFF)<<16)+(((loc)&$C000)>>14)),(VDP_CTRL).l
0000241A                            		endm
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            TitleScreen:
0000241A                                    playSnd #Mus_Stop,  1
0000241A 11FC 0003 C4BC           M 	move.b	#mus_stop,(mqueue+((1)-1)).w
00002420 6100 E130                          bsr.w    FadeToBlack
00002424 4BF9 00C0 0004                     lea     (VDP_CTRL).l,   a5
0000242A 3ABC 8004                          move.w  #$8004, (a5)
0000242E 3ABC 8230                          move.w  #$8230, (a5)
00002432 3ABC 8407                          move.w  #$8407, (a5)
00002436 3ABC 8700                          move.w  #$8700, (a5)
0000243A 3ABC 8B00                          move.w  #$8B00, (a5)
0000243E 3038 9000                          move.w  (dmaQueue).w,   d0
00002442 0200 00BF                          andi.b  #$BF,   d0
00002446 33C0 00C0 0004                     move.w  d0, (VDP_CTRL).l
0000244C                            
0000244C 6100 DDFA                          bsr.w   ClearScreen
00002450                                    locVRAM 0
00002450 23FC 4000 0000 00C0 0004 M 	move.l	#($40000000+(((loc)&$3fff)<<16)+(((loc)&$c000)>>14)),(vdp_ctrl).l
0000245A                            
0000245A 41F9 0000 0000             		lea	WWZ_Pal,a0			; Load palette to target buffer
00002460 303C 0000                  		move.w	#(WWZ_Pal_End-WWZ_Pal)>>1-1,d0
00002464 6100 E0D4                  		bsr.w	LoadTargetPal			; ''
00002468                            
00002468 6100 E164                          bsr.w   FadeFromBlack
0000246C                                 ;   RaiseError  "End of title successfully reached"
0000246C                                .loop:
0000246C 11FC 0004 C75C             		move.b	#gLevel,opmode.w			; Set game mode to "title"
00002472 4EF9 0000 0000             		jmp	Level					; Go to the title screen
00002478 60F2                       		bra.s	.loop
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
0000247A                            ;		playSnd	#Mus_Stop, 1			; Stop sound
0000247A                            ;
0000247A                            ;		bsr.w	FadeToBlack			; Fade to black
0000247A                            ;
0000247A                            ;		intsOff					; Disable interrupts
0000247A                            ;		clrRAM	kosVars
0000247A                            ;		clrRAM	checkpoint
0000247A                            ;		clrRAM	opmodeVars
0000247A                            ;		clrRAM	objMemory
0000247A                            ;
0000247A                            ;		lea	VDP_CTRL,a5
0000247A                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
0000247A                            ;		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
0000247A                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
0000247A                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
0000247A                            ;		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
0000247A                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
0000247A                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
0000247A                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
0000247A                            ;		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
0000247A                            ;		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
0000247A                            ;
0000247A                            ;		bsr.w	ClearScreen			; Clear screen
0000247A                            ;
0000247A                            ;		lea	palFadeBuff.w,a0			; Fade target palette
0000247A                            ;		moveq	#$80>>2-1,d0			; Size
0000247A                            ;
0000247A                            ;.FillPal:
0000247A                            ;		move.l	#$0EEE0EEE,(a0)+		; Fill palette with white
0000247A                            ;		dbf	d0,.FillPal			; Loop
0000247A                            ;
0000247A                            ;		bsr.w	FadeFromBlack			; Fade from black
0000247A                            ;		
0000247A                            ;		bsr.w	SEGA_FMV			; Run SEGA FMV
0000247A                            ;
0000247A                            ;TitleScreen2:
0000247A                            ;		intsOff
0000247A                            ;
0000247A                            ;		clr.b	artCheat.w
0000247A                            ;		clrRAM	opmodeVars
0000247A                            ;		clrRAM	objMemory
0000247A                            ;
0000247A                            ;		move.w	#$8200|($C000/$400),VDP_CTRL	; Reset plane A address
0000247A                            ;		bsr.w	FadeToWhite			; Fade to white
0000247A                            ;
0000247A                            ;		intsOff
0000247A                            ;		bsr.w	ClearScreen			; Clear screen
0000247A                            ;
0000247A                            ;		lea	MapEni_TitleBG,a0		; Decompress background mappings
0000247A                            ;		lea	miscBuff,a1			; Decompress into RAM
0000247A                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
0000247A                            ;		bsr.w	EniDec				; Decompress!
0000247A                            ;
0000247A                            ;		lea	miscBuff,a1			; Load mappings
0000247A                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
0000247A                            ;		moveq	#$27,d1				; $28x$1C tiles
0000247A                            ;		moveq	#$1B,d2				; ''
0000247A                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
0000247A                            ;		bsr.w	LoadPlaneMap			; Load the map
0000247A                            ;
0000247A                            ;		lea	MapEni_TitleLogo,a0		; Decompress logo mappings
0000247A                            ;		lea	miscBuff,a1			; Decompress into RAM
0000247A                            ;		move.w	#$8370,d0			; Base tile properties: Tile ID 1, no flags
0000247A                            ;		bsr.w	EniDec				; Decompress!
0000247A                            ;
0000247A                            ;		lea	miscBuff,a1			; Load mappings
0000247A                            ;		move.l	#$41040003,d0			; At (0, 0) on plane A
0000247A                            ;		moveq	#$E,d1				; $28x$1C tiles
0000247A                            ;		moveq	#$C,d2				; ''
0000247A                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
0000247A                            ;		bsr.w	LoadPlaneMap			; Load the map
0000247A                            ;
0000247A                            ;		lea	Pal_Title,a0			; Load palette to target buffer
0000247A                            ;		move.w	#(Pal_Title_End-Pal_Title)>>1-1,d0
0000247A                            ;		bsr.w	LoadTargetPal			; ''
0000247A                            ;
0000247A                            ;		lea	ArtKosM_TitleBG,a1		; Load background art
0000247A                            ;		move.w	#$20,d2				; ''
0000247A                            ;		bsr.w	QueueKosMData			; ''
0000247A                            ;
0000247A                            ;		lea	ArtKosM_TitleLogo,a1		; Load logo art
0000247A                            ;		move.w	#$6E00,d2			; ''
0000247A                            ;		bsr.w	QueueKosMData			; ''
0000247A                            ;
0000247A                            ;		lea	ArtKosM_TtlSonic,a1		; Load Sonic art
0000247A                            ;		move.w	#$4000,d2			; ''
0000247A                            ;		bsr.w	QueueKosMData			; ''
0000247A                            ;
0000247A                            ;		lea	ArtKosM_TtlBird,a1		; Load bird art
0000247A                            ;		move.w	#$8400,d2			; ''
0000247A                            ;		bsr.w	QueueKosMData			; ''
0000247A                            ;
0000247A                            ;		lea	ArtKosM_TtlGlove,a1		; Load glove art
0000247A                            ;		move.w	#$8600,d2			; ''
0000247A                            ;		bsr.w	QueueKosMData			; ''
0000247A                            ;
0000247A                            ;.WaitPLCs:
0000247A                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
0000247A                            ;		jsr	ProcessKos.w			; Process Kosinski queue
0000247A                            ;		jsr	VSync_Routine.w			; V-SYNC
0000247A                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
0000247A                            ;		tst.b	kosMModules.w			; Are there still modules left?
0000247A                            ;		bne.s	.WaitPLCs			; If so, branch
0000247A                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
0000247A                            ;		jsr	VSync_Routine.w			; V-SYNC
0000247A                            ;		
0000247A                            ;		move.l	#ObjTtlSonic,rObj_0.w		; Load the Sonic object
0000247A                            ;		move.w	#320+96,(rObj_0+oX).w		; Set X
0000247A                            ;		move.w	#128,(rObj_0+oY).w		; Set Y
0000247A                            ;
0000247A                            ;		move.l	#ObjTtlBird,rObj_1.w		; Load the bird object
0000247A                            ;		move.w	#-64,(rObj_1+oX).w		; Set X
0000247A                            ;		move.w	#64,(rObj_1+oY).w		; Set Y
0000247A                            ;
0000247A                            ;		move.l	#ObjTtlGlove,rObj_2.w		; Load the glove object
0000247A                            ;		move.w	#224,(rObj_2+oX).w		; Set X
0000247A                            ;		move.w	#320,(rObj_2+oY).w		; Set Y
0000247A                            ;
0000247A                            ;		jsr	RunObjects.w			; Run objects
0000247A                            ;		jsr	RendeobjMemory.w			; Render objects
0000247A                            ;
0000247A                            ;		clr.w	palCycTimer.w		; Reset palette cycle
0000247A                            ;
0000247A                            ;		bsr.w	FadeFromWhite			; Fade from white
0000247A                            ;
0000247A                            ;		lea	SampleList+$C0,a3		; Play title screen music
0000247A                            ;		jsr	PlayDAC1			; ''
0000247A                            ;
0000247A                            ;.Loop:
0000247A                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
0000247A                            ;		bsr.w	VSync_Routine			; ''
0000247A                            ;
0000247A                            ;		bsr.s	Title_Updates			; Do updates
0000247A                            ;		
0000247A                            ;		jsr	RunObjects.w			; Run objects
0000247A                            ;		jsr	RendeobjMemory.w			; Render objects
0000247A                            ;
0000247A                            ;		lea	FreeMove_Cheat(pc),a0
0000247A                            ;		lea	moveCheat.w,a1
0000247A                            ;		lea	rCheatEntry.w,a2
0000247A                            ;		bsr.w	Title_ChkCheats
0000247A                            ;		lea	Art_Cheat(pc),a0
0000247A                            ;		lea	artCheat.w,a1
0000247A                            ;		lea	rCheatEntry2.w,a2
0000247A                            ;		bsr.w	Title_ChkCheats
0000247A                            ;
0000247A                            ;		tst.b	artCheat.w
0000247A                            ;		bne.w	BinbowieArt
0000247A                            ;
0000247A                            ;		tst.b	ctrlPressP1.w			; Has start been pressed
0000247A                            ;		bpl.s	.Loop				; If so, branch
0000247A                            ;
0000247A                            ;		st	(rObj_2+oGloveFlag).w		; Set the punch flag
0000247A                            ;
0000247A                            ;		lea	SampleList+$E0,a3		; Punch
0000247A                            ;		jsr	PlayDAC1			; ''
0000247A                            ;
0000247A                            ;.PunchLoop:
0000247A                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
0000247A                            ;		bsr.w	VSync_Routine			; ''
0000247A                            ;
0000247A                            ;		bsr.s	Title_Updates			; Do updates
0000247A                            ;
0000247A                            ;		jsr	RunObjects.w			; Run objects
0000247A                            ;		jsr	RendeobjMemory.w			; Render objects
0000247A                            ;		
0000247A                            ;		tst.b	(rObj_2+oGloveTime).w		; Has the timer run out?
0000247A                            ;		bpl.s	.PunchLoop			; If not, loop
0000247A                            ;		
0000247A                            ;		st	rStartFall.w			; Set flag to start the level by falling
0000247A                            ;
0000247A                            ;		move.b	#gLevel,opmode.w		; Set game mode to "level"
0000247A                            ;		jmp	Level				; Go to level
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ; Palette cycle
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;Title_Updates:
0000247A                            ;		move.b	rLogoAngle.w,d0		; Get logo hover angle
0000247A                            ;		addq.b	#4,rLogoAngle.w		; Increment angle
0000247A                            ;		jsr	CalcSine.w			; Get sine
0000247A                            ;		asr.w	#5,d0				; ''
0000247A                            ;		move.w	d0,vScrollBuffFG.w		; Set logo's Y position
0000247A                            ;
0000247A                            ;		subq.b	#1,palCycTimer.w		; Decrement timer
0000247A                            ;		bpl.s	.End				; If it hasn't run out, branch
0000247A                            ;		move.b	#6,palCycTimer.w		; Reset timer
0000247A                            ;		
0000247A                            ;		moveq	#0,d0
0000247A                            ;		move.b	palCycIndex.w,d0		; Get index
0000247A                            ;		mulu.w	#$C,d0				; Turn into offset
0000247A                            ;		lea	PalCyc_Title(pc,d0.w),a0	; Get pointer to palette data
0000247A                            ;		lea	(paletteBuff+$14).w,a1		; Palette
0000247A                            ;		move.w	(a0)+,(a1)+			; Load palette
0000247A                            ;		move.w	(a0)+,(a1)+			; ''
0000247A                            ;		move.w	(a0)+,(a1)+			; ''
0000247A                            ;		move.w	(a0)+,(a1)+			; ''
0000247A                            ;		move.w	(a0)+,(a1)+			; ''
0000247A                            ;		move.w	(a0)+,(a1)+			; ''
0000247A                            ;		
0000247A                            ;		addq.b	#1,palCycIndex.w		; Increment index
0000247A                            ;		cmpi.b	#6,palCycIndex.w		; Has it reached the end?
0000247A                            ;		bcs.s	.End				; If not, branch
0000247A                            ;		clr.b	palCycIndex.w		; Reset index
0000247A                            
0000247A                            ;.End:
0000247A                            ;		rts
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;PalCyc_Title:
0000247A                            ;		dc.w	$00E, $08E, $0EE, $0E0, $E00, $808
0000247A                            ;		dc.w	$08E, $0EE, $0E0, $E00, $808, $00E
0000247A                            ;		dc.w	$0EE, $0E0, $E00, $808, $00E, $08E
0000247A                            ;		dc.w	$0E0, $E00, $808, $00E, $08E, $0EE
0000247A                            ;		dc.w	$E00, $808, $00E, $08E, $0EE, $0E0
0000247A                            ;		dc.w	$808, $00E, $08E, $0EE, $0E0, $E00
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ; Check for cheats
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;Title_ChkCheats:
0000247A                            ;		tst.b	(a1)
0000247A                            ;		bne.s	.End
0000247A                            ;		move.w	(a2),d0
0000247A                            ;		adda.w	d0,a0
0000247A                            ;		move.b	ctrlPressP1.w,d0
0000247A                            ;		cmp.b	(a0),d0
0000247A                            ;		bne.s	.ResetCheat
0000247A                            ;		addq.w	#1,(a2)
0000247A                            ;		tst.b	d0
0000247A                            ;		bne.s	.End
0000247A                            ;		st	(a1)
0000247A                            ;		playSnd	#sRing, 2
0000247A                            ;		rts
0000247A                            ;
0000247A                            ;.ResetCheat:
0000247A                            ;		tst.b	d0
0000247A                            ;		beq.s	.End
0000247A                            ;		clr.w	(a2)
0000247A                            ;
0000247A                            ;.End:
0000247A                            ;		rts
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;FreeMove_Cheat:
0000247A                            ;		dc.b	1, 2, 4, 8, 0, $FF
0000247A                            ;		even
0000247A                            ;Art_Cheat:
0000247A                            ;		dc.b	1, 1, 2, 2, 4, 8, 4, 8, $40, $10, $40, $10, 0, $FF
0000247A                            ;		even
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ; BinBowie's art
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;BinbowieArt:
0000247A                            ;		bsr.w	FadeToWhite			; Fade to white
0000247A                            ;		
0000247A                            ;		lea	SampleList,a3
0000247A                            ;		jsr	PlayDAC1
0000247A                            ;
0000247A                            ;		intsOff
0000247A                            ;
0000247A                            ;		jsr	ClearScreen.w
0000247A                            ;
0000247A                            ;		lea	MapEni_BinBowieArt(pc),a0	; Decompress mappings
0000247A                            ;		lea	miscBuff,a1			; Decompress into RAM
0000247A                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
0000247A                            ;		bsr.w	EniDec				; Decompress!
0000247A                            ;
0000247A                            ;		lea	miscBuff,a1			; Load mappings
0000247A                            ;		move.l	#$40000003,d0			; At (0, 0) on plane A
0000247A                            ;		moveq	#$27,d1				; $28x$1C tiles
0000247A                            ;		moveq	#$1B,d2				; ''
0000247A                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
0000247A                            ;		bsr.w	LoadPlaneMap			; Load the map
0000247A                            ;
0000247A                            ;		lea	Pal_BinBowieArt,a0		; Load palette to target buffer
0000247A                            ;		move.w	#(Pal_BinBowieArt_End-Pal_BinBowieArt)>>1-1,d0
0000247A                            ;		bsr.w	LoadTargetPal			; ''
0000247A                            ;
0000247A                            ;		lea	ArtKosM_BinBowieArt,a1		; Load art
0000247A                            ;		move.w	#$20,d2				; ''
0000247A                            ;		bsr.w	QueueKosMData			; ''
0000247A                            ;
0000247A                            ;.WaitPLCs:
0000247A                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
0000247A                            ;		jsr	ProcessKos.w			; Process Kosinski queue
0000247A                            ;		jsr	VSync_Routine.w			; V-SYNC
0000247A                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
0000247A                            ;		tst.b	kosMModules.w			; Are there still modules left?
0000247A                            ;		bne.s	.WaitPLCs			; If so, branch
0000247A                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
0000247A                            ;		jsr	VSync_Routine.w			; V-SYNC
0000247A                            ;
0000247A                            ;		jsr	FadeFromWhite.w
0000247A                            ;
0000247A                            ;		lea	SampleList+$100,a3
0000247A                            ;		jsr	PlayDAC1
0000247A                            ;
0000247A                            ;.Loop:
0000247A                            ;		move.b	#vTitle,vIntRoutine.w		; Level load V-INT routine
0000247A                            ;		jsr	ProcessKos.w			; Process Kosinski queue
0000247A                            ;		move.b	ctrlPressP1.w,d0
0000247A                            ;		andi.b	#%10010000,d0
0000247A                            ;		beq.s	.Loop
0000247A                            ;
0000247A                            ;		jmp	TitleScreen2
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ; Objects
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;		include	"Title Screen/Objects/Sonic/Code.asm"
0000247A                            ;		include	"Title Screen/Objects/Bird/Code.asm"
0000247A                            ;		include	"Title Screen/Objects/Glove/Code.asm"
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ; Art
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;ArtKosM_TitleBG:
0000247A                            ;		incbin	"Title Screen/Data/Art - Background.kosm.bin"
0000247A                            ;		even
0000247A                            ;ArtKosM_TitleLogo:
0000247A                            ;		incbin	"Title Screen/Data/Art - Logo.kosm.bin"
0000247A                            ;		even
0000247A                            ;ArtKosM_BinBowieArt:
0000247A                            ;		incbin	"Title Screen/Data/Art - BinBowie.kosm.bin"
0000247A                            ;		even
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ; Plane mappings
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;MapEni_TitleBG:
0000247A                            ;		incbin	"Title Screen/Data/Map - Background.eni.bin"
0000247A                            ;		even
0000247A                            ;MapEni_TitleLogo:
0000247A                            ;		incbin	"Title Screen/Data/Map - Logo.eni.bin"
0000247A                            ;		even
0000247A                            ;MapEni_BinBowieArt:
0000247A                            ;		incbin	"Title Screen/Data/Map - BinBowie.eni.bin"
0000247A                            ;		even
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ; Palette
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;Pal_Title:
0000247A                            ;		incbin	"Title Screen/Data/Palette.pal.bin"
0000247A                            ;Pal_Title_End:
0000247A                            ;		even
0000247A                            ;Pal_BinBowieArt:
0000247A                            ;		incbin	"Title Screen/Data/BinBowie Palette.pal.bin"
0000247A                            ;Pal_BinBowieArt_End:
0000247A                            ;		even
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ; SEGA FMV
0000247A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000247A                            ;		include	"Title Screen/SEGA FMV/FMV.asm"
0000247A                            ; =========================================================================================================================================================
0000247A                            		include	"Opmodes/Gameplay/Main.asm"
0000247A                            ; =========================================================================================================================================================
0000247A                            ; Level
0000247A                            ; =========================================================================================================================================================
0000247A                            Level:
0000247A                            		playSnd	#Mus_FadeOut, 1			; Fade out sound
0000247A 11FC 0002 C4BC           M 	move.b	#mus_fadeout,(mqueue+((1)-1)).w
00002480                            
00002480 4EB8 0552                  		jsr	FadeToBlack			; Fade to black
00002484                            
00002484                            Level_NoFade:
00002484                            		; --- Set up the VDP ---
00002484                            
00002484                            		intsOff					; Disable interrupts
00002484 007C 0700                M 	ori	#$700,sr
00002488                            		displayOff				; Disable display
00002488 3038 C766                M 	move.w	vdpreg1.w,d0
0000248C 0200 00BF                M 	andi.b	#%10111111,d0
00002490 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
00002496                            
00002496 4BF9 00C0 0004             		lea	VDP_CTRL,a5			; VDP control port
0000249C 3ABC 8004                  		move.w	#$8004,(a5)			; Disable H-INT
000024A0 3ABC 8230                  		move.w	#$8230,(a5)			; Plane A at $C000
000024A4 3ABC 8407                  		move.w	#$8407,(a5)			; Plane B at $E000
000024A8 3ABC 8720                  		move.w	#$8720,(a5)			; Set background color to palette line 2, entry 0
000024AC 3ABC 8B03                  		move.w	#$8B03,(a5)			; V-Scroll by screen, H-Scroll by scanline
000024B0 3ABC 9001                  		move.w	#$9001,(a5)			; 64x32 cell plane area
000024B4 303C 9200                  		move.w	#$9200,d0			; Make the window invisible
000024B8 31C0 C768                  		move.w	d0,vdpWindowY.w			; ''
000024BC 3A80                       		move.w	d0,(a5)				; ''
000024BE 4278 9000                  		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
000024C2 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
000024C8                            
000024C8 4EB8 0248                  		jsr	ClearScreen.w			; Clear the screen
000024CC                            
000024CC                            		; --- Clear some RAM ---
000024CC                            
000024CC                            		clrRAM	kosVars			; Clear Kosinski queue variables
000024CC                          M 	local	endaddr
000024CC                          M endaddr	equs	"kosvars_End"
000024CC 7000                     M 	moveq	#0,d0
000024CE 43F8 994E                M 	lea	(kosvars).w,a1
000024D2 323C 0040                M 	move.w	#(((kosvars_end)-(kosvars))-((kosvars)&1))>>2-1,d1
000024D6 22C0                     M .clear_136:	move.l	d0,(a1)+
000024D8 51C9 FFFC                M 	dbf	d1,.clear_136
000024DC 32C0                     M 	move.w	d0,(a1)+
000024DE                            		clrRAM	opmodeVars			; Clear variables
000024DE                          M 	local	endaddr
000024DE                          M endaddr	equs	"opmodevars_End"
000024DE 7000                     M 	moveq	#0,d0
000024E0 43F8 C7D2                M 	lea	(opmodevars).w,a1
000024E4 323C 0DCA                M 	move.w	#(((opmodevars_end)-(opmodevars))-((opmodevars)&1))>>2-1,d1
000024E8 22C0                     M .clear_137:	move.l	d0,(a1)+
000024EA 51C9 FFFC                M 	dbf	d1,.clear_137
000024EE 32C0                     M 	move.w	d0,(a1)+
000024F0                            		clrRAM	oscillators			; Clear oscillation data
000024F0                          M 	local	endaddr
000024F0                          M endaddr	equs	"oscillators_End"
000024F0 7000                     M 	moveq	#0,d0
000024F2 43F8 C76C                M 	lea	(oscillators).w,a1
000024F6 323C 000F                M 	move.w	#(((oscillators_end)-(oscillators))-((oscillators)&1))>>2-1,d1
000024FA 22C0                     M .clear_138:	move.l	d0,(a1)+
000024FC 51C9 FFFC                M 	dbf	d1,.clear_138
00002500 32C0                     M 	move.w	d0,(a1)+
00002502                            
00002502                            		; --- Do some final initializing and play the level music ---
00002502                            
00002502 11FC 0003 E861             		move.b	#3,ringAnimTime.w		; Set ring animation timer
00002508 31FC 001E E90A             		move.w	#30,rFloorTimer.w		; Set floor timer
0000250E 4278 C7D0                  		clr.w	palCycTimer.w		; Reset palette cycle
00002512                            
00002512 41FA 0000                  		lea	Level_MusicIDs(pc),a0		; Music ID list
00002516 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
0000251A E218                       		ror.b	#1,d0				; Turn into offset
0000251C EE48                       		lsr.w	#7,d0				; ''
0000251E 1030 0000                  		move.b	(a0,d0.w),d0			; Get music ID
00002522 11C0 E8E0                  		move.b	d0,lvlMusic.w		; Store it
00002526                            		playSnd	d0, 1				; Play it
00002526 11C0 C4BC                M 	move.b	d0,(mqueue+((1)-1)).w
0000252A                            
0000252A                            		intsOn					; Enable interrupts
0000252A 027C F8FF                M 	andi	#$f8ff,sr
0000252E                            
0000252E                            		; --- Load level data ---
0000252E                            
0000252E 47F9 0000 0000             		lea	PLC_LevelMain,a3		; Load main level PLCs
00002534 4EB8 0F4C                  		jsr	LoadKosMQueue.w			; ''
00002538                            
00002538 4EB8 19BE                  		jsr	InitObjectList.w
0000253C                            
0000253C 4EB8 1A1C                  		jsr	FindFreeObj.w
00002540 22BC 0000 0000             		move.l	#ObjPlayer,_objAddress(a1)		; Load Player object
00002546 31C9 E876                  		move.w	a1,playerPtrP1.w		; Store the address
0000254A                            
0000254A 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
0000254E 6700                       		beq.s	.NoSurface			; If not, branch
00002550                            
00002550                            							; Load water surfaces
00002550 4EB8 1A1C                  		jsr	FindFreeObj.w
00002554 22BC 0000 0000             		move.l	#ObjWaterSurface,_objAddress(a1)
0000255A 337C 0060 0014             		move.w	#$60,_objXPos(a1)
00002560 31C9 E886                  		move.w	a1,waterObjPtr1.w		; Store the address
00002564                            
00002564 4EB8 1A1C                  		jsr	FindFreeObj.w
00002568 22BC 0000 0000             		move.l	#ObjWaterSurface,_objAddress(a1)
0000256E 337C 0120 0014             		move.w	#$120,_objXPos(a1)
00002574 31C9 E888                  		move.w	a1,waterObjPtr2.w		; Store the address
00002578                            
00002578                            .NoSurface:
00002578 6100 0000                  		bsr.w	Level_LoadData			; Load level data
0000257C                            
0000257C                            .WaitPLCs:
0000257C 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002582 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
00002586 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
0000258A 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
0000258E 4A38 9990                  		tst.b	kosMModules.w			; Are there still modules left?
00002592 66E8                       		bne.s	.WaitPLCs			; If so, branch
00002594                            
00002594 4238 E8FE                  		clr.b	lvlHasWater.w			; Clear the water flag
00002598                            
00002598 41FA 0000                  		lea	Level_WatelevelIDs(pc),a0	; Water heights
0000259C 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
000025A0 E218                       		ror.b	#1,d0				; Turn into offset
000025A2 EC48                       		lsr.w	#6,d0				; ''
000025A4 3030 0000                  		move.w	(a0,d0.w),d0			; Get water height
000025A8 6B00                       		bmi.s	.NoWater			; If it's negative, branch
000025AA 31C0 E900                  		move.w	d0,waterYPos.w		; Set the water height
000025AE 31C0 E902                  		move.w	d0,destWaterYPos.w
000025B2                            
000025B2 50F8 E8FE                  		st	lvlHasWater.w			; Set the water flag
000025B6 33FC 8014 00C0 0004        		move.w	#$8014,VDP_CTRL			; Enable H-INT
000025BE 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
000025C2 33F8 C760 00C0 0004        		move.w	hIntCntReg.w,VDP_CTRL		; Set H-INT counter
000025CA                            
000025CA                            .NoWater:
000025CA 31FC 00A0 E8D6             		move.w	#320/2,panCamXPos.w		; Set camera X center
000025D0                            
000025D0 4EB8 18E4                  		jsr	InitOscillation.w		; Initialize oscillation
000025D4                            
000025D4 6100 0000                  		bsr.w	Level_HandleCamera		; Initialize the camera
000025D8                            	;	bsr.w	Level_InitHUD			; Initialize the HUD
000025D8 6100 0000                  		bsr.w	Level_WaterHeight		; Initialize water height
000025DC                            
000025DC 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
000025E0                            
000025E0                            		; --- Load the planes ---
000025E0                            
000025E0                            		intsOff					; Disable interrupts
000025E0 007C 0700                M 	ori	#$700,sr
000025E4 21FC 0000 233C C74E        		move.l	#VInt_RunSMPS,vIntAddress.w	; Swap V-INT
000025EC                            		intsOn					; Enable interrupts
000025EC 027C F8FF                M 	andi	#$f8ff,sr
000025F0 6100 0000                  		bsr.w	Level_InitPlanes		; Initialize the planes
000025F4                            		intsOff					; Disable interrupts
000025F4 007C 0700                M 	ori	#$700,sr
000025F8 21FC 0000 20A2 C74E        		move.l	#VInt_Standard,vIntAddress.w	; Swap V-INT
00002600                            		intsOn					; Enable interrupts
00002600 027C F8FF                M 	andi	#$f8ff,sr
00002604 11FC 0006 C747             		move.b	#vLvlLoad,vIntRoutine.w		; Level load V-INT routine
0000260A 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
0000260E                            
0000260E                            		; --- Load the level objects and rings ---
0000260E                            
0000260E 51F8 C7B6                  		sf	objMgrInit.w			; Reset object manager routine
00002612 6100 0000                  		bsr.w	Level_RingsManager		; Initialize the ring manager
00002616 4EB8 1D94                  		jsr	ObjectManager.w			; Run the object manager
0000261A                            	runObjects
0000261A 3078 C158                M 	movea.w	objexecfirst.w,a0
0000261E 2250                     M 	move.l	_objaddress(a0),a1
00002620 4E91                     M 	jsr	(a1)
00002622 4EB8 1A9E                  		jsr	RendeobjMemory.w			; Render objects
00002626                            
00002626 4238 E906                  		clr.b	lvlReload.w			; Clear the level reload flag
0000262A                            
0000262A                            		displayOn				; Enable display
0000262A 3038 C766                M 	move.w	vdpreg1.w,d0
0000262E 0000 0040                M 	ori.b	#%01000000,d0
00002632 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
00002638 4EB8 05CE                  		jsr	FadeFromBlack.w			; Fade from black
0000263C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000263C                            ; Main loop
0000263C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000263C                            .Loop:
0000263C 11FC 0004 C747             		move.b	#vLevel,vIntRoutine.w		; Level V-INT routine
00002642 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
00002646 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
0000264A                            
0000264A 4EB8 0000                  		jsr	CheckPause.w			; Check for pausing
0000264E 5278 E904                  		addq.w	#1,lvlFrameCnt.w			; Increment frame counter
00002652                            
00002652 4EB8 1938                  		jsr	UpdateOscillation.w		; Update oscillation
00002656                            
00002656 6100 0000                  		bsr.w	Level_RingsManager		; Run the ring manager
0000265A 4EB8 1D94                  		jsr	ObjectManager.w			; Run the object manager
0000265E                            
0000265E                            	runObjects
0000265E 3078 C158                M 	movea.w	objexecfirst.w,a0
00002662 2250                     M 	move.l	_objaddress(a0),a1
00002664 4E91                     M 	jsr	(a1)
00002666                            
00002666 4A38 E906                  		tst.b	lvlReload.w			; Does the level need to be reloaded?
0000266A 6600 FE0E                  		bne.w	Level				; If so, branch
0000266E                            
0000266E 6100 0000                  		bsr.w	Level_HandleCamera		; Handle the camera
00002672 6100 0000                  		bsr.w	Level_UpdatePlanes		; Update the planes (draw new tiles and scroll)
00002676 6100 0000                  		bsr.w	Level_UpdateWaterSurface	; Update the water surface
0000267A                            
0000267A 4EB8 1A9E                  		jsr	RendeobjMemory.w			; Render objects
0000267E                            
0000267E 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
00002682 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
00002686 6100 0000                  		bsr.w	Level_PalCycle			; Do palette cycling
0000268A 6100 0000                  		bsr.w	Level_DynEvents			; Run dynamic events
0000268E                            
0000268E 5338 E861                  		subq.b	#1,ringAnimTime.w		; Decrement ring animation timer
00002692 6A00                       		bpl.s	.NoRingAni			; If it hasn't run out, branch
00002694 11FC 0003 E861             		move.b	#3,ringAnimTime.w		; Reset animation timer
0000269A 5238 E860                  		addq.b	#1,ringAnimFrame.w			; Next ring frame
0000269E 0238 0007 E860             		andi.b	#7,ringAnimFrame.w			; Limit it
000026A4                            
000026A4 7000                       		moveq	#0,d0
000026A6 1038 E860                  		move.b	ringAnimFrame.w,d0			; Get ring frame
000026AA EF48                       		lsl.w	#7,d0				; Convert to offset
000026AC 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
000026B2 D280                       		add.l	d0,d1				; ''
000026B4 343C D780                  		move.w	#$D780,d2			; VRAM address
000026B8 363C 0040                  		move.w	#$80/2,d3			; Size
000026BC 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
000026C0                            
000026C0                            .NoRingAni:
000026C0 4A38 E864                  		tst.b	ringLossAnimT.w
000026C4 6700                       		beq.s	.NoRingLossAni
000026C6 7000                       		moveq	#0,d0
000026C8 1038 E864                  		move.b	ringLossAnimT.w,d0
000026CC D078 E862                  		add.w	ringLossAnimA.w,d0
000026D0 31C0 E862                  		move.w	d0,ringLossAnimA.w
000026D4 E158                       		rol.w	#8,d0
000026D6 0240 0007                  		andi.w	#7,d0
000026DA 11C0 E865                  		move.b	d0,ringLossAnimF.w
000026DE 5338 E864                  		subq.b	#1,ringLossAnimT.w
000026E2                            
000026E2 7000                       		moveq	#0,d0
000026E4 1038 E865                  		move.b	ringLossAnimF.w,d0		; Get ring frame
000026E8 EF48                       		lsl.w	#7,d0				; Convert to offset
000026EA 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
000026F0 D280                       		add.l	d0,d1				; ''
000026F2 343C D680                  		move.w	#$D680,d2			; VRAM address
000026F6 363C 0040                  		move.w	#$80/2,d3			; Size
000026FA 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
000026FE                            
000026FE                            .NoRingLossAni:
000026FE 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002702                            
00002702 0C38 0004 C75C             		cmpi.b	#gLevel,opmode.w		; Is the game mode level?
00002708 6700 FF32                  		beq.w	.Loop				; If so, branch
0000270C 4EF8 0220                  		jmp	GotoGameMode.w			; Go to the correct game mode
00002710                            
00002710                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002710                            ; Check for pausing
00002710                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002710                            CheckPause:
00002710 4A38 C75E                  		tst.b	pauseFlag.w			; Is the game already paused?
00002714 6600                       		bne.s	.SetPause			; If so, branch
00002716 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
0000271C 6700                       		beq.s	.End				; If not, branch
0000271E                            
0000271E                            .SetPause:
0000271E 50F8 C75E                  		st	pauseFlag.w			; Pause the game
00002722                            		AMPS_MUSPAUSE				; Pause the music
00002722 11FC 0008 C4BE           M 	move.b	#mus_pause,mqueue+2.w
00002728                            
00002728                            .PauseLoop:
00002728 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; General V-INT routine
0000272E 6100 FC44                  		bsr.w	VSync_Routine			; V-SYNC
00002732 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
00002738 67EE                       		beq.s	.PauseLoop			; If not, branch
0000273A                            
0000273A                            		AMPS_MUSUNPAUSE				; Unpause the music
0000273A 11FC 0009 C4BE           M 	move.b	#mus_unpause,mqueue+2.w
00002740 4238 C75E                  		clr.b	pauseFlag.w			; Unpause the game
00002744                            
00002744                            .End:
00002744 4E75                       		rts
00002746                            
00002746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002746                            ; Level functions
00002746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002746                            		include	"Opmodes/Gameplay/Level Drawing.asm"
00002746                            ; =========================================================================================================================================================
00002746                            ; Level drawing functions (Based on Sonic Crackers' and S3K's level drawing engine)
00002746                            ; =========================================================================================================================================================
00002746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002746                            ; Initialize the planes
00002746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002746                            ; PARAMETERS:
00002746                            ;	Nothing
00002746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002746                            ; RETURNS:
00002746                            ;	Nothing
00002746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002746                            Level_InitPlanes:
00002746 43F8 E88A                  		lea	fgCamVars.w,a1			; Get foreground level drawing RAM
0000274A 47F8 C2A0                  		lea	fgColBuff.w,a3			; Get foreground column plane buffer
0000274E 49F8 C19E                  		lea	fgRowBuff.w,a4			; Get foreground row plane buffer
00002752                            
00002752 237C 4000 0003 0012        		move.l	#$40000003,cVDP(a1)		; Set the base VDP command for drawing tiles
0000275A 4269 0016                  		clr.w	cLayout(a1)			; Set the offset for the level layout (foreground)
0000275E                            		
0000275E 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002762 E218                       		ror.b	#1,d0				; Turn into offset
00002764 E648                       		lsr.w	#3,d0				; ''
00002766 41F9 0000 0000             		lea	Level_RenderRouts,a0		; Get initialization routine list
0000276C 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
00002772 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002776 4E90                       		jsr	(a0)				; Jump to it
00002778                            
00002778 31E9 0008 947E             		move.w	cYPos(a1),vScrollBuffFG.w		; Set the V-Scroll value for the foreground
0000277E                            
0000277E 43F8 E8A8                  		lea	bgCamVars.w,a1			; Get background level drawing RAM
00002782 47F8 C424                  		lea	bgColBuff.w,a3			; Get background column plane buffer
00002786 49F8 C322                  		lea	bgRowBuff.w,a4			; Get background row plane buffer
0000278A                            		
0000278A 237C 6000 0003 0012        		move.l	#$60000003,cVDP(a1)		; Set the base VDP command for drawing tils
00002792 337C 0004 0016             		move.w	#4,cLayout(a1)			; Set the offset for the level layout (background)
00002798                            		
00002798 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
0000279C E218                       		ror.b	#1,d0				; Turn into offset
0000279E E648                       		lsr.w	#3,d0				; ''
000027A0 41F9 0000 0000             		lea	Level_RenderRouts+4,a0		; Get initialization routine list
000027A6 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
000027AC 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
000027B0 4E90                       		jsr	(a0)				; Jump to it
000027B2                            
000027B2 31E9 0008 9480             		move.w	cYPos(a1),vScrollBuffBG.w		; Set the V-Scroll value for the background
000027B8 4E75                       		rts
000027BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027BA                            ; Update the planes
000027BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027BA                            Level_UpdatePlanes:
000027BA 43F8 E88A                  		lea	fgCamVars.w,a1			; Get foreground level drawing RAM
000027BE 47F8 C2A0                  		lea	fgColBuff.w,a3		; Get foreground column plane buffer
000027C2 49F8 C19E                  		lea	fgRowBuff.w,a4		; Get foreground row plane buffer
000027C6                            		
000027C6 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
000027CA 4E90                       		jsr	(a0)				; Jump to it
000027CC                            		
000027CC 43F8 E8A8                  		lea	bgCamVars.w,a1			; Get background level drawing RAM
000027D0 47F8 C424                  		lea	bgColBuff.w,a3		; Get background column plane buffer
000027D4 49F8 C322                  		lea	bgRowBuff.w,a4		; Get background row plane buffer
000027D8                            
000027D8 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
000027DC 4E90                       		jsr	(a0)				; Jump to it
000027DE                            
000027DE 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
000027E2 3552 0004                  		move.w	cXPos(a2),cXPrev(a2)		; Update the previous X position for the foreground
000027E6 356A 0008 000C             		move.w	cYPos(a2),cYPrev(a2)		; Update the previous Y position for the foreground
000027EC 31EA 0008 947E             		move.w	cYPos(a2),vScrollBuffFG.w		; Set the V-Scroll value for the foreground
000027F2 3351 0004                  		move.w	cXPos(a1),cXPrev(a1)		; Update the previous X position for the background
000027F6 3369 0008 000C             		move.w	cYPos(a1),cYPrev(a1)		; Update the previous Y position for the background
000027FC 31E9 0008 9480             		move.w	cYPos(a1),vScrollBuffBG.w		; Set the V-Scroll value for the background
00002802                            
00002802 4E75                       		rts
00002804                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002804                            ; General foreground initialization
00002804                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002804                            General_InitFG:
00002804 6000 0000                  		bra.w	Level_RefreshPlane		; Refresh the plane
00002808                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002808                            ; General background initialization
00002808                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002808                            General_InitBG:
00002808 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
0000280C 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
0000280E E240                       		asr.w	#1,d0				; Divide by 2
00002810 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002812 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002816 E240                       		asr.w	#1,d0				; Divide by 2
00002818 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
0000281C                            
0000281C 6100 0000                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00002820                            		
00002820 6000 0000                  		bra.w	ScrollStaticBG			; Set up the scroll offsets
00002824                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002824                            ; General foreground update
00002824                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002824                            General_UpdateFG:
00002824 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002828                            		
00002828 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
0000282A 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
0000282C 6000 0000                  		bra.w	Level_UpdatePlane		; Update the plane
00002830                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002830                            ; General background update
00002830                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002830                            General_UpdateBG:
00002830 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002834 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002836 E240                       		asr.w	#1,d0				; Divide by 2
00002838 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
0000283A 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
0000283E E240                       		asr.w	#1,d0				; Divide by 2
00002840 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002844                            
00002844 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002848 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
0000284A 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
0000284C 6100 0000                  		bsr.w	Level_UpdatePlane		; Update the plane
00002850                            		
00002850 6000 0000                  		bra.w	ScrollStaticBG			; Scroll the planes
00002854                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002854                            ; Draw new tiles in the level
00002854                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002854                            ; PARAMETERS:
00002854                            ;	a1.l	- Camera RAM
00002854                            ;	a2.l	- Plane buffer for columns
00002854                            ;	a3.l	- Plane buffer for rows
00002854                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002854                            ; RETURNS:
00002854                            ;	Nothing
00002854                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002854                            VInt_DrawLevel:
00002854 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002858 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
0000285C                            
0000285C 3013                       		move.w	(a3),d0				; Get high VDP command word
0000285E 6700 0000                  		beq.w	VInt_DrawLvlRows2		; If it's 0, branch
00002862 425B                       		clr.w	(a3)+				; Reset high VDP command word in buffer
00002864 3CBC 8F80                  		move.w	#$8F80,(a6)			; Set auto-increment to $80
00002868                            
00002868                            		; --- DRAW THE FIRST HALF OF THE COLUMN ---
00002868                            
00002868 3200                       		move.w	d0,d1				; Save high VDP command
0000286A 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
0000286C 7C00                       		moveq	#0,d6
0000286E 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
00002872 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002874                            
00002874 3C80                       		move.w	d0,(a6)				; Set VDP command
00002876 3C84                       		move.w	d4,(a6)				; ''
00002878 6000                       		bra.s	.DrawCol1_1_Start		; Start
0000287A                            
0000287A                            .DrawCol1_1_Loop:
0000287A 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
0000287C                            
0000287C                            .DrawCol1_1_Start:
0000287C 51CE FFFC                  		dbf	d6,.DrawCol1_1_Loop		; Loop
00002880                            
00002880 3403                       		move.w	d3,d2				; Wrap to the top of the plane
00002882 0642 007C                  		addi.w	#$7C,d2				; ''
00002886 C042                       		and.w	d2,d0				; ''
00002888                            
00002888 3C80                       		move.w	d0,(a6)				; Set VDP command
0000288A 3C84                       		move.w	d4,(a6)				; ''
0000288C                            
0000288C                            .DrawCol1_2_Loop:
0000288C 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
0000288E 51CF FFFC                  		dbf	d7,.DrawCol1_2_Loop		; Loop
00002892                            
00002892                            		; --- DRAW THE SECOND HALF OF THE COLUMN ---
00002892                            
00002892 5441                       		addq.w	#2,d1				; Move over to the right
00002894 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002896 7C00                       		moveq	#0,d6
00002898 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
0000289C 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
0000289E                            
0000289E 3C81                       		move.w	d1,(a6)				; Set VDP command
000028A0 3C84                       		move.w	d4,(a6)				; ''
000028A2 6000                       		bra.s	.DrawCol2_1_Start		; Start
000028A4                            
000028A4                            .DrawCol2_1_Loop:
000028A4 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000028A6                            
000028A6                            .DrawCol2_1_Start:
000028A6 51CE FFFC                  		dbf	d6,.DrawCol2_1_Loop		; Loop
000028AA                            
000028AA 3403                       		move.w	d3,d2				; Wrap to the top of the plane
000028AC 0642 007E                  		addi.w	#$7E,d2				; ''
000028B0 C242                       		and.w	d2,d1				; ''
000028B2                            
000028B2 3C81                       		move.w	d1,(a6)				; Set VDP command
000028B4 3C84                       		move.w	d4,(a6)				; ''
000028B6                            
000028B6                            .DrawCol2_2_Loop:
000028B6 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000028B8 51CF FFFC                  		dbf	d7,.DrawCol2_2_Loop		; Loop
000028BC                            
000028BC 3CBC 8F02                  		move.w	#$8F02,(a6)			; Autoincrement by 2
000028C0 6000                       		bra.s	VInt_DrawLvlRows2		; Continue
000028C2                            
000028C2                            VInt_DrawLvlRows:
000028C2 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
000028C6 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
000028CA                            
000028CA                            VInt_DrawLvlRows2:
000028CA 3014                       		move.w	(a4),d0				; Get high VDP command
000028CC 6700 0000                  		beq.w	.End				; If it's 0, branch
000028D0 425C                       		clr.w	(a4)+				; Don't run this again unless necessary
000028D2                            		
000028D2                            		; --- DRAW THE FIRST HALF OF THE ROW ---
000028D2                            
000028D2 3200                       		move.w	d0,d1				; Save high VDP command
000028D4 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
000028D6 7C00                       		moveq	#0,d6
000028D8 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
000028DC 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000028DE                            
000028DE 3C80                       		move.w	d0,(a6)				; Set VDP command
000028E0 3C84                       		move.w	d4,(a6)				; ''
000028E2 6000                       		bra.s	.DrawRow1_1_Start		; Start
000028E4                            
000028E4                            .DrawRow1_1_Loop:
000028E4 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028E6                            
000028E6                            .DrawRow1_1_Start:
000028E6 51CE FFFC                  		dbf	d6,.DrawRow1_1_Loop		; Loop
000028EA                            
000028EA 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
000028EC 0642 0F00                  		addi.w	#$F00,d2			; ''
000028F0 C042                       		and.w	d2,d0				; ''
000028F2                            
000028F2 3C80                       		move.w	d0,(a6)				; Set VDP command
000028F4 3C84                       		move.w	d4,(a6)				; ''
000028F6                            
000028F6                            .DrawRow1_2_Loop:
000028F6 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028F8 51CF FFFC                  		dbf	d7,.DrawRow1_2_Loop		; Loop
000028FC                            
000028FC                            		; --- DRAW THE SECOND HALF OF THE ROW ---
000028FC                            
000028FC 0641 0080                  		addi.w	#$80,d1				; Move over down
00002900 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002902 7C00                       		moveq	#0,d6
00002904 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002908 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
0000290A                            
0000290A 3C81                       		move.w	d1,(a6)				; Set VDP command
0000290C 3C84                       		move.w	d4,(a6)				; ''
0000290E 6000                       		bra.s	.DrawRow2_1_Start		; Start
00002910                            
00002910                            .DrawRow2_1_Loop:
00002910 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002912                            
00002912                            .DrawRow2_1_Start:
00002912 51CE FFFC                  		dbf	d6,.DrawRow2_1_Loop		; Loop
00002916                            
00002916 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002918 0642 0F80                  		addi.w	#$F80,d2			; ''
0000291C C242                       		and.w	d2,d1				; ''
0000291E                            
0000291E 3C81                       		move.w	d1,(a6)				; Set VDP command
00002920 3C84                       		move.w	d4,(a6)				; ''
00002922                            
00002922                            .DrawRow2_2_Loop:
00002922 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002924 51CF FFFC                  		dbf	d7,.DrawRow2_2_Loop		; Loop
00002928                            
00002928                            .End:
00002928 4E75                       		rts
0000292A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292A                            ; Handle plane drawing
0000292A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292A                            ; PARAMETERS:
0000292A                            ;	d4.w	- Number of blocks per column
0000292A                            ;	d5.w	- Number of blocks per row
0000292A                            ;	a1.l	- Camera variables
0000292A                            ;	a2.l	- Layout pointer
0000292A                            ;	a3.l	- Column plane buffer
0000292A                            ;	a4.l	- Row plane buffer
0000292A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292A                            ; RETURNS:
0000292A                            ;	Nothing
0000292A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292A                            Level_UpdatePlane:
0000292A                            		push.l	d5/a4				; Push row plane buffer address
0000292A 48E7 0408                M 	movem.l	d5/a4,-(sp)
0000292E 6100                       		bsr.s	Level_UpdatePlaneX		; Handle horizontal plane updating
00002930                            		pop.l	d5/a4				; Restore row plane buffer address
00002930 4CDF 1020                M 	movem.l	(sp)+,d5/a4
00002934 3805                       		move.w	d5,d4				; Number of blocks per column
00002936                            		; Continue to update the plane vertically
00002936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002936                            ; Handle plane drawing (vertical redrawing only)
00002936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002936                            ; PARAMETERS:
00002936                            ;	d4.w	- Number of blocks per row
00002936                            ;	a1.l	- Camera variables
00002936                            ;	a4.l	- Row plane buffer
00002936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002936                            ; RETURNS:
00002936                            ;	Nothing
00002936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002936                            Level_UpdatePlaneY:
00002936 3029 0008                  		move.w	cYPos(a1),d0			; Get Y
0000293A 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
0000293E 3229 000E                  		move.w	cYPrevR(a1),d1			; Get previous y (rounded)
00002942 3340 000E                  		move.w	d0,cYPrevR(a1)			; Save new rounded y
00002946                            		
00002946 9240                       		sub.w	d0,d1				; Get distance travelled
00002948 6700                       		beq.s	.End				; If a new row doesn't need to be drawn, branch
0000294A 6B00                       		bmi.s	.DrawDown			; If a new column needs to be drawn on the bottom of the screen, branch
0000294C                            		
0000294C                            .DrawUp:
0000294C 3011                       		move.w	cXPos(a1),d0			; Get X
0000294E 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002952 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002956                            
00002956                            .DrawDown:
00002956 3011                       		move.w	cXPos(a1),d0			; Get X
00002958 3229 000C                  		move.w	cYPrev(a1),d1			; Get Y
0000295C 0641 00F0                  		addi.w	#224+16,d1			; Go to the bottom of the screen
00002960 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002964                            
00002964                            .End:
00002964 4E75                       		rts
00002966                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002966                            ; Handle plane drawing (horizontal redrawing only)
00002966                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002966                            ; PARAMETERS:
00002966                            ;	d4.w	- Number of blocks per column
00002966                            ;	a1.l	- Camera variables
00002966                            ;	a3.l	- Column plane buffer
00002966                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002966                            ; RETURNS:
00002966                            ;	Nothing
00002966                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002966                            Level_UpdatePlaneX:
00002966 3011                       		move.w	cXPos(a1),d0			; Get X
00002968 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
0000296C 3229 0006                  		move.w	cXPrevR(a1),d1			; Get previous X (rounded)
00002970 3340 0006                  		move.w	d0,cXPrevR(a1)			; Save new rounded X
00002974                            		
00002974 9240                       		sub.w	d0,d1				; Get distance travelled
00002976 6700                       		beq.s	.End				; If a new column doesn't need to be drawn, branch
00002978 6B00                       		bmi.s	.DrawRight			; If a new column needs to be drawn on the right side of the screen, branch
0000297A                            		
0000297A                            .DrawLeft:
0000297A 3011                       		move.w	cXPos(a1),d0			; Get X
0000297C 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002980 6000 0000                  		bra.w	Level_GetCol			; Draw a column
00002984                            		
00002984                            .DrawRight:
00002984 3029 0004                  		move.w	cXPrev(a1),d0			; Get previous X
00002988 0640 0150                  		addi.w	#320+16,d0			; Go to the right side of the screen
0000298C 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002990 6000 0000                  		bra.w	Level_GetCol			; Draw a column
00002994                            
00002994                            .End:
00002994 4E75                       		rts
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            ; Macro to calculate the high VDP command word for the plane buffer
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            ; PARAMETERS:
00002996                            ;	a1.l	- Camera variables
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            ; RETURNS:
00002996                            ;	d2.w	- The high VDP command word
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            calcHiVDP	macro
00002996                            		move.w	d0,d2				; Copy X
00002996                            		move.w	d1,d3				; Copy Y
00002996                            		lsl.w	#4,d3				; Multiply Y by $10
00002996                            		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002996                            		lsr.w	#2,d2				; Divide X by 4
00002996                            		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
00002996                            		add.w	d3,d2				; Add Y onto X
00002996                            		or.w	cVDP(a1),d2			; Combine with high VDP command word
00002996                            		endm
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            ; Macro to get an address in chunk data relative to a position
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            ; PARAMETERS:
00002996                            ;	d1.l	- $FFFFXXXX
00002996                            ;	a2.l	- Layout data
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            ; RETURNS:
00002996                            ;	a6.l	- Pointer in chunk data to the correct block
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            getChunk	macro
00002996                            		moveq	#-1,d1				; Prepare chunk pointer
00002996                            		move.b	(a2,d0.w),d1			; Get chunk ID
00002996                            		andi.w	#$FF,d1				; ''
00002996                            		lsl.w	#7,d1				; Turn into offset
00002996                            		movea.l	d1,a6				; Store into a6
00002996                            		endm
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            ; Get a block row and store it in a plane buffer
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            ; PARAMETERS:
00002996                            ;	d0.w	- X position
00002996                            ;	d1.w	- Y position
00002996                            ;	d4.w	- Number of blocks to draw (minus 1)
00002996                            ;	a1.l	- Camera variables
00002996                            ;	a4.l	- Row plane buffer
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            ; RETURNS:
00002996                            ;	Nothing
00002996                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002996                            Level_GetRow:
00002996 45F8 E856                  		lea	lvlLayout.w,a2			; Get level layout pointer address
0000299A D4E9 0016                  		adda.w	cLayout(a1),a2			; Add camera offset value
0000299E 2452                       		movea.l	(a2),a2				; Load address stored within the pointer
000029A0                            
000029A0 47F8 C7D2                  		lea	blockData.w,a3			; Get block table address
000029A4 4BEC 0082                  		lea	$82(a4),a5			; Store plane buffer address for the bottom tiles in the row
000029A8                            
000029A8                            		calcHiVDP				; Get high VDP command word
000029A8 3400                     M 	move.w	d0,d2
000029AA 3601                     M 	move.w	d1,d3
000029AC E94B                     M 	lsl.w	#4,d3
000029AE 0243 0F00                M 	andi.w	#$f00,d3
000029B2 E44A                     M 	lsr.w	#2,d2
000029B4 0242 007C                M 	andi.w	#$7c,d2
000029B8 D443                     M 	add.w	d3,d2
000029BA 8469 0012                M 	or.w	cvdp(a1),d2
000029BE 38C2                       		move.w	d2,(a4)+			; Store it
000029C0                            
000029C0 3400                       		move.w	d0,d2				; Get X
000029C2 E44A                       		lsr.w	#2,d2				; Divide X by 4
000029C4 0242 007C                  		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
000029C8 3A3C 0080                  		move.w	#512/4,d5			; Get max row size in pixels divided by 4
000029CC 9A42                       		sub.w	d2,d5				; Get number of pixels (divided by 4) that the first set of tiles for a row takes up
000029CE 0245 007C                  		andi.w	#$7C,d5				; Only allow 0-$7C with multiples of 4
000029D2 E44D                       		lsr.w	#2,d5				; Divide by 4
000029D4 1345 0010                  		move.b	d5,cRBlks(a1)			; Set tile count for the first set of tiles for a row
000029D8                            		
000029D8 E648                       		lsr.w	#3,d0				; Get X within chunk data
000029DA 3400                       		move.w	d0,d2				; ''
000029DC 0242 000E                  		andi.w	#$E,d2				; ''
000029E0 3601                       		move.w	d1,d3				; Get Y within chunk data
000029E2 0243 0070                  		andi.w	#$70,d3				; ''
000029E6 D443                       		add.w	d3,d2				; Combine X and Y to get chunk offset
000029E8                            		
000029E8 E848                       		lsr.w	#4,d0				; Get X within layout data
000029EA 0240 00FF                  		andi.w	#$FF,d0				; ''
000029EE 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
000029F2 EC49                       		lsr.w	#6,d1				; ''
000029F4                            
000029F4 D072 1002                  		add.w	2(a2,d1.w),d0			; Combine X and Y to get layout offset
000029F8                            		getChunk				; Get chunk pointer at current location
000029F8 72FF                     M 	moveq	#-1,d1
000029FA 1232 0000                M 	move.b	(a2,d0.w),d1
000029FE 0241 00FF                M 	andi.w	#$ff,d1
00002A02 EF49                     M 	lsl.w	#7,d1
00002A04 2C41                     M 	movea.l	d1,a6
00002A06                            
00002A06                            .DrawBlock_Loop:
00002A06 3A36 2000                  		move.w	(a6,d2.w),d5			; Get block properties
00002A0A 3C05                       		move.w	d5,d6				; ''
00002A0C 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002A10 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002A12                            		
00002A12 2E33 5000                  		move.l	(a3,d5.w),d7			; Get block tiles
00002A16 2A33 5004                  		move.l	4(a3,d5.w),d5			; ''
00002A1A                            
00002A1A 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002A1E 6700                       		beq.s	.ChkYFlip			; If not, branch
00002A20 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002A26 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002A2C 4847                       		swap	d7				; ''
00002A2E 4845                       		swap	d5				; ''
00002A30                            
00002A30                            .ChkYFlip:
00002A30 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002A34 6700                       		beq.s	.DrawBlock			; If not, branch
00002A36 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002A3C 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002A42 CF45                       		exg.l	d7,d5				; ''
00002A44                            
00002A44                            .DrawBlock:
00002A44 28C7                       		move.l	d7,(a4)+			; Save the tiles in the plane buffers
00002A46 2AC5                       		move.l	d5,(a5)+			; ''
00002A48                            
00002A48 5442                       		addq.w	#2,d2				; Go to the next block
00002A4A 0242 000E                  		andi.w	#$E,d2				; Have we gone outside of the chunk?
00002A4E 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002A50                            		
00002A50 5240                       		addq.w	#1,d0				; Next chunk
00002A52                            		getChunk				; ''
00002A52 72FF                     M 	moveq	#-1,d1
00002A54 1232 0000                M 	move.b	(a2,d0.w),d1
00002A58 0241 00FF                M 	andi.w	#$ff,d1
00002A5C EF49                     M 	lsl.w	#7,d1
00002A5E 2C41                     M 	movea.l	d1,a6
00002A60                            
00002A60                            .DrawBlock_Cont:
00002A60 D443                       		add.w	d3,d2				; Recombine X and Y to get chunk offset
00002A62 51CC FFA2                  		dbf	d4,.DrawBlock_Loop		; Loop
00002A66                            
00002A66 4E75                       		rts
00002A68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A68                            ; Get a block column and store it in a plane buffer
00002A68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A68                            ; PARAMETERS:
00002A68                            ;	d0.w	- X position
00002A68                            ;	d1.w	- Y position
00002A68                            ;	d4.w	- Number of blocks to draw (minus 1)
00002A68                            ;	a1.l	- Camera RAM
00002A68                            ;	a3.l	- Column plane buffer
00002A68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A68                            ; RETURNS:
00002A68                            ;	Nothing
00002A68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A68                            Level_GetCol:
00002A68 45F8 E856                  		lea	lvlLayout.w,a2			; Get level layout pointer address
00002A6C D4E9 0016                  		adda.w	cLayout(a1),a2			; Add camera offset value
00002A70 2452                       		movea.l	(a2),a2				; Load address stored within the pointer
00002A72                            		
00002A72 49F8 C7D2                  		lea	blockData.w,a4			; Get block table address
00002A76 4BEB 0042                  		lea	$42(a3),a5			; Store plane buffer address for the right tiles in the column
00002A7A                            		
00002A7A                            		calcHiVDP				; Get high VDP command word
00002A7A 3400                     M 	move.w	d0,d2
00002A7C 3601                     M 	move.w	d1,d3
00002A7E E94B                     M 	lsl.w	#4,d3
00002A80 0243 0F00                M 	andi.w	#$f00,d3
00002A84 E44A                     M 	lsr.w	#2,d2
00002A86 0242 007C                M 	andi.w	#$7c,d2
00002A8A D443                     M 	add.w	d3,d2
00002A8C 8469 0012                M 	or.w	cvdp(a1),d2
00002A90 36C2                       		move.w	d2,(a3)+			; Store it
00002A92                            
00002A92 3601                       		move.w	d1,d3				; Get Y
00002A94 E94B                       		lsl.w	#4,d3				; Multiply by $10
00002A96 0243 0F00                  		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002A9A 3A3C 1000                  		move.w	#256*16,d5			; Get max column size in pixels times 16
00002A9E 9A43                       		sub.w	d3,d5				; Get number of pixels (times 16) that the first set of tiles for a column takes up
00002AA0 0245 0F00                  		andi.w	#$F00,d5			; Only allow 0-$F00 with multiples of $100
00002AA4 E04D                       		lsr.w	#8,d5				; Divide by $100
00002AA6 1345 0011                  		move.b	d5,cCBlks(a1)			; Set tile count for the first set of tiles for a column
00002AAA                            
00002AAA E648                       		lsr.w	#3,d0				; Get X within chunk data
00002AAC 3400                       		move.w	d0,d2				; ''
00002AAE 0242 000E                  		andi.w	#$E,d2				; ''
00002AB2 3601                       		move.w	d1,d3				; Get Y within chunk data
00002AB4 0243 0070                  		andi.w	#$70,d3				; ''
00002AB8 D642                       		add.w	d2,d3				; Combine X and Y to get chunk offset
00002ABA                            
00002ABA E848                       		lsr.w	#4,d0				; Get X within layout data
00002ABC 0240 00FF                  		andi.w	#$FF,d0				; ''
00002AC0 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
00002AC4 EC49                       		lsr.w	#6,d1				; ''				
00002AC6 48A7 C000                  		movem.w	d0-d1,-(sp)			; Backup layout X and Y 
00002ACA                            		
00002ACA D072 1002                  		add.w	2(a2,d1.w),d0			; Combine X and Y to get layout offset
00002ACE                            		getChunk				; Get chunk pointer at current location
00002ACE 72FF                     M 	moveq	#-1,d1
00002AD0 1232 0000                M 	move.b	(a2,d0.w),d1
00002AD4 0241 00FF                M 	andi.w	#$ff,d1
00002AD8 EF49                     M 	lsl.w	#7,d1
00002ADA 2C41                     M 	movea.l	d1,a6
00002ADC                            
00002ADC                            .DrawBlock_Loop:
00002ADC 3A36 3000                  		move.w	(a6,d3.w),d5			; Get block properties
00002AE0 3C05                       		move.w	d5,d6				; ''
00002AE2 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002AE6 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002AE8                            		
00002AE8 3E05                       		move.w	d5,d7				; Get block tiles
00002AEA 2A34 7002                  		move.l	2(a4,d7.w),d5			; ''
00002AEE 3A07                       		move.w	d7,d5				; ''
00002AF0 2E34 5000                  		move.l	(a4,d5.w),d7			; ''
00002AF4 3E34 5004                  		move.w	4(a4,d5.w),d7			; ''
00002AF8 3A34 5006                  		move.w	6(a4,d5.w),d5			; ''
00002AFC                            
00002AFC 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002B00 6700                       		beq.s	.ChkYFlip			; If not, branch
00002B02 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002B08 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002B0E CF45                       		exg.l	d7,d5				; ''
00002B10                            
00002B10                            .ChkYFlip:
00002B10 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002B14 6700                       		beq.s	.DrawBlock			; If not, branch
00002B16 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002B1C 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002B22 4847                       		swap	d7				; ''
00002B24 4845                       		swap	d5				; ''
00002B26                            
00002B26                            .DrawBlock:
00002B26 26C7                       		move.l	d7,(a3)+			; Save the tiles in the plane buffers
00002B28 2AC5                       		move.l	d5,(a5)+			; ''
00002B2A                            
00002B2A 0643 0010                  		addi.w	#$10,d3				; Go to the next block
00002B2E 0243 0070                  		andi.w	#$70,d3				; Have we gone outside of the chunk?
00002B32 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002B34                            
00002B34 4C9F 0003                  		movem.w	(sp)+,d0-d1			; Get saved layout X and Y from the stack
00002B38 5441                       		addq.w	#2,d1				; Increase layout data Y offset to the next pointer
00002B3A 48A7 C000                  		movem.w	d0-d1,-(sp)			; Push a backup copy back onto the stack
00002B3E                            		
00002B3E D072 1002                  		add.w	2(a2,d1.w),d0			; Next chunk
00002B42                            		getChunk				; ''
00002B42 72FF                     M 	moveq	#-1,d1
00002B44 1232 0000                M 	move.b	(a2,d0.w),d1
00002B48 0241 00FF                M 	andi.w	#$ff,d1
00002B4C EF49                     M 	lsl.w	#7,d1
00002B4E 2C41                     M 	movea.l	d1,a6
00002B50                            
00002B50                            .DrawBlock_Cont:
00002B50 D642                       		add.w	d2,d3				; Recombine X and Y to get chunk offset
00002B52 51CC FF88                  		dbf	d4,.DrawBlock_Loop		; Loop
00002B56                            
00002B56 4C9F 0003                  		movem.w	(sp)+,d0-d1			; Discard backup layout X and Y from the stack 
00002B5A 4E75                       		rts
00002B5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B5C                            ; Refresh a plane
00002B5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B5C                            ; PARAMETERS:
00002B5C                            ;	a1.l	- Camera variables
00002B5C                            ;	a4.l	- Row plane buffer
00002B5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B5C                            ; RETURNS:
00002B5C                            ;	Nothing
00002B5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B5C                            Level_RefreshPlane:
00002B5C 3011                       		move.w	cXPos(a1),d0			; Get X position
00002B5E 3340 0004                  		move.w	d0,cXPrev(a1)			; Store as previous X position
00002B62 0240 FFF0                  		andi.w	#$FFF0,d0			; Only get multiples of $10
00002B66 3340 0006                  		move.w	d0,cXPrevR(a1)			; Store as previous X position (rounded)
00002B6A                            		
00002B6A 3229 0008                  		move.w	cYPos(a1),d1			; Get Y position
00002B6E 3341 000C                  		move.w	d1,cYPrev(a1)			; Store as previous Y position
00002B72 0241 FFF0                  		andi.w	#$FFF0,d1			; Only get multiples of $10
00002B76 3341 000E                  		move.w	d1,cYPrevR(a1)			; Store as previous Y position (rounded)
00002B7A                            		
00002B7A 781F                       		moveq	#(512/16)-1,d4			; Number of rows to draw
00002B7C 7C0F                       		moveq	#(256/16)-1,d6			; Number of blocks per row
00002B7E                            		
00002B7E                            		push.l	a4				; Save plane buffer address
00002B7E 2F0C                     M 	move.l	a4,-(sp)
00002B80                            		
00002B80                            .DrawRows:
00002B80                            		push.w	d0/d1/d4/d6			; Save registers
00002B80 48A7 CA00                M 	movem.w	d0/d1/d4/d6,-(sp)
00002B84 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002B88 6100 FE0C                  		bsr.w	Level_GetRow			; Transfer the row to the plane buffer
00002B8C 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002B90 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002B96 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002B9A 6100 FD26                  		bsr.w	VInt_DrawLvlRows		; Draw the new row
00002B9E                            		pop.w	d0/d1/d4/d6			; Restore registers
00002B9E 4C9F 0053                M 	movem.w	(sp)+,d0/d1/d4/d6
00002BA2                            		
00002BA2 0641 0010                  		addi.w	#$10,d1				; Increment Y
00002BA6 51CE FFD8                  		dbf	d6,.DrawRows			; Loop
00002BAA                            		
00002BAA                            		pop.l	a4				; Restore a3
00002BAA 285F                     M 	move.l	(sp)+,a4
00002BAC 4E75                       		rts
00002BAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BAE                            ; Check if the plane needs to be redrawn
00002BAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BAE                            ; PARAMETERS:
00002BAE                            ;	a1.l	- Camera RAM
00002BAE                            ;	a3.l	- Row plane buffer
00002BAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BAE                            ; RETURNS:
00002BAE                            ;	Nothing
00002BAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BAE                            Level_ChkRedrawPlane:
00002BAE 4A29 001C                  		tst.b	cRedraw(a1)			; Does this plane need to be redrawn?
00002BB2                            		; Comment out the following line to disable blast processing :^)
00002BB2 6700                       		beq.s	.End				; If not, branch
00002BB4 4229 001C                  		clr.b	cRedraw(a1)			; Clear the redraw flag
00002BB8 60A2                       		bra.s	Level_RefreshPlane		; Redraw the plane
00002BBA                            
00002BBA                            .End:
00002BBA 4E75                       		rts
00002BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BBC                            ; Scroll sections macro
00002BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BBC =00008000                  SCROLL_AUTOMATIC	EQU	$8000			; Automatic scroll flag
00002BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BBC                            scrollInit	macro	label
00002BBC                            SCROLL_LABEL	equs	"\label"
00002BBC                            \label\:	dc.w	((\label\_End-\label\-2)/6)-1	; Number of sections
00002BBC                            		endm
00002BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BBC                            scrollEnd	macro
00002BBC                            \SCROLL_LABEL\_End:					; End label
00002BBC                            		endm
00002BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BBC                            scrollSection	macro
00002BBC                            	if narg<3
00002BBC                            		dc.w	\2, 0, \1			; Speed, 0, Size
00002BBC                            	else
00002BBC                            		dc.w	\2, \3, \1			; Speed, Flags, Size
00002BBC                            	endif
00002BBC                            		endm
00002BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BBC                            ; Do section scrolling
00002BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BBC                            ; PARAMERERS:
00002BBC                            ;	a1.l	- Background camera RAM
00002BBC                            ;	a3.l	- Scroll section data
00002BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BBC                            ; RETURNS:
00002BBC                            ;	Nothing
00002BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BBC                            ScrollSections:
00002BBC 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing variables
00002BC0 49F8 E452                  		lea	scrollSects.w,a4		; Deformation offset buffer
00002BC4 4BF8 90FE                  		lea	hScrollBuff.w,a5			; Horizontal scroll buffer
00002BC8                            
00002BC8 301B                       		move.w	(a3)+,d0			; Get the total number of scroll sections
00002BCA                            
00002BCA 3812                       		move.w	cXPos(a2),d4			; Get camera speed
00002BCC 986A 0004                  		sub.w	cXPrev(a2),d4			; ''
00002BD0 48C4                       		ext.l	d4				; ''
00002BD2 E184                       		asl.l	#8,d4				; Shift over to use for calculation speeds
00002BD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BD4                            		; Update each section offset
00002BD4                            		push.w	d0/a4				; Save registers
00002BD4 48A7 8008                M 	movem.w	d0/a4,-(sp)
00002BD8                            
00002BD8                            .ScrollSects:
00002BD8 361B                       		move.w	(a3)+,d3			; Get section speed
00002BDA 48C3                       		ext.l	d3				; ''
00002BDC                            
00002BDC 4A5B                       		tst.w	(a3)+				; Is this section set to scroll automatically?
00002BDE 6A00                       		bpl.s	.NotAuto			; If not, branch
00002BE0 3C04                       		move.w	d4,d6				; Get camera speed
00002BE2 CDC3                       		muls.w	d3,d6				; Multiply by section speed
00002BE4 E183                       		asl.l	#8,d3				; Shift section speed
00002BE6 D686                       		add.l	d6,d3				; Add camera speed to section speed
00002BE8 6000                       		bra.s	.ApplySpeed			; Apply that speed
00002BEA                            
00002BEA                            .NotAuto:
00002BEA C7C4                       		muls.w	d4,d3				; Multiply the the background's X scroll offset with the speed
00002BEC                            
00002BEC                            .ApplySpeed:
00002BEC D79C                       		add.l	d3,(a4)+			; Set the new section offset
00002BEE 38DB                       		move.w	(a3)+,(a4)+			; Save the section size for later
00002BF0 51C8 FFE6                  		dbf	d0,.ScrollSects			; If there are still sections to check, loop
00002BF4                            
00002BF4                            		pop.w	d0/a4				; Restore registers
00002BF4 4C9F 1001                M 	movem.w	(sp)+,d0/a4
00002BF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BF8                            		; Set the scroll offsets on screen
00002BF8 3A3C 00E0                  		move.w	#224,d5				; Scanline counter
00002BFC 3C29 0008                  		move.w	cYPos(a1),d6			; Get the background's Y position
00002C00                            		
00002C00                            .FindStart:
00002C00 221C                       		move.l	(a4)+,d1			; Get section offset
00002C02 9C5C                       		sub.w	(a4)+,d6			; Subtract the size of the section
00002C04 6B00                       		bmi.s	.FoundStart			; If the current section is on screen, branch
00002C06 51C8 FFF8                  		dbf	d0,.FindStart			; If not, continue the search
00002C0A 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002C0C 4441                       		neg.w	d1				; Make it scroll the right direction
00002C0E 4841                       		swap	d1				; Fix which planes the scroll values go to
00002C10 4441                       		neg.w	d1				; Make the background scroll the right direction
00002C12 6000                       		bra.s	.LastSection			; If there are no more sections to go through, branch
00002C14                            
00002C14                            .FoundStart:
00002C14 4446                       		neg.w	d6				; Get remaining size of the section
00002C16 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002C18 4441                       		neg.w	d1				; Make it scroll the right direction
00002C1A 4841                       		swap	d1				; Fix which planes the scroll values go to
00002C1C 4441                       		neg.w	d1				; Make the background scroll the right direction
00002C1E 6000                       		bra.s	.CheckScroll			; Go set some scroll offsets
00002C20                            
00002C20                            .NextSection:
00002C20 321C                       		move.w	(a4)+,d1			; Set scroll offset
00002C22 4441                       		neg.w	d1				; Make the section scroll the correct way
00002C24 2C1C                       		move.l	(a4)+,d6			; Get section size
00002C26                            		
00002C26                            .CheckScroll:
00002C26 9A46                       		sub.w	d6,d5				; Subtract that from the scanline count
00002C28 6B00                       		bmi.s	.EndSection			; If there is still screen space to cover, loop
00002C2A 5346                       		subq.w	#1,d6				; Convert for use with dbf
00002C2C                            
00002C2C                            .Scroll:
00002C2C 2AC1                       		move.l	d1,(a5)+			; Scroll the section
00002C2E 51CE FFFC                  		dbf	d6,.Scroll			; Repeat
00002C32 51C8 FFEC                  		dbf	d0,.NextSection			; If there are any sections left, branch
00002C36 5245                       		addq.w	#1,d5				; Add 1 so that the foreground can still scroll properly
00002C38                            		
00002C38                            .EndSection:
00002C38 DA46                       		add.w	d6,d5				; Get remaining screen space
00002C3A                            		
00002C3A                            .LastSection:
00002C3A 5345                       		subq.w	#1,d5				; Convert to use with dbf
00002C3C 6B00                       		bmi.s	.End				; If there are none, exit
00002C3E                            
00002C3E                            .FillScroll:
00002C3E 2AC1                       		move.l	d1,(a5)+			; Set previous scroll values
00002C40 51CD FFFC                  		dbf	d5,.FillScroll			; Repeat
00002C44                            
00002C44                            .End:
00002C44 4E75                       		rts
00002C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C46                            ; Static background scrolling (no parallax)
00002C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C46                            ; PARAMERERS:
00002C46                            ;	a1.l	- Background camera RAM
00002C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C46                            ; RETURNS:
00002C46                            ;	Nothing
00002C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C46                            ScrollStaticBG:
00002C46 45F8 E88A                  		lea	fgCamVars.w,a2		; Get foreground level drawing variables
00002C4A 4BF8 90FE                  		lea	hScrollBuff.w,a5		; Horizontal scroll buffer
00002C4E                            		
00002C4E 2212                       		move.l	cXPos(a2),d1			; Get foreground X position
00002C50 4481                       		neg.l	d1				; Negate it so it scrolls properly
00002C52 3211                       		move.w	cXPos(a1),d1			; Get background X position
00002C54 4441                       		neg.w	d1				; Negate it so it scrolls properly
00002C56                            
00002C56 303C 00DF                  		move.w	#224-1,d0			; Number of scanlines to scroll
00002C5A                            
00002C5A                            .Scroll:
00002C5A 2AC1                       		move.l	d1,(a5)+			; Set the scroll offsets
00002C5C 51C8 FFFC                  		dbf	d0,.Scroll			; Repeat
00002C60 4E75                       		rts
00002C62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C62                            ; Generate fake layer art
00002C62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C62                            ; PARAMETERS:
00002C62                            ;	a0.l	- Layer art data pointer
00002C62                            ;	a1.l	- Layer tile ID mappings pointer
00002C62                            ;	d0.w	- Layer offset
00002C62                            ;	d1.l	- Buffer pointer
00002C62                            ;	d2.w	- VRAM destination address
00002C62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C62                            Level_UpdateLayer:
00002C62                            		; Prepare for transfer
00002C62 3619                       		move.w	(a1)+,d3			; Get number of tiles to copy
00002C64 2441                       		movea.l	d1,a2				; Copy layer buffer pointer
00002C66                            		
00002C66                            		; Queue a DMA transfer for later
00002C66                            		push.l	d0/d3/a1			; Save registers
00002C66 48E7 9040                M 	movem.l	d0/d3/a1,-(sp)
00002C6A 5243                       		addq.w	#1,d3				; Get size of transfer
00002C6C E94B                       		lsl.w	#4,d3				; ''
00002C6E 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the transfer
00002C72                            		pop.l	d0/d3/a1			; Restore registers
00002C72 4CDF 0209                M 	movem.l	(sp)+,d0/d3/a1
00002C76                            
00002C76                            		; Copy the tiles for the layer
00002C76 D040                       		add.w	d0,d0				; Double it
00002C78 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to layer data for the offset
00002C7C                            		
00002C7C                            .CopyTiles:
00002C7C 3219                       		move.w	(a1)+,d1			; Get tile offset
00002C7E 47F0 1000                  		lea	(a0,d1.w),a3			; Get pointer to tile data
00002C82 24DB                       		move.l	(a3)+,(a2)+			; Copy tile data
00002C84 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C86 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C88 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C8A 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C8C 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C8E 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C90 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C92 51CB FFE8                  		dbf	d3,.CopyTiles			; Loop
00002C96                            
00002C96                            .End
00002C96 4E75                       		rts
00002C98                            ; =========================================================================================================================================================
00002C98                            		include	"Opmodes/Gameplay/Level Collision.asm"
00002C98                            ; =========================================================================================================================================================
00002C98                            ; Level collision functions
00002C98                            ; =========================================================================================================================================================
00002C98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C98                            ; Check if a player object has touched any level collision
00002C98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C98                            PlayerChkCollision:
00002C98 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00002C9E 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00002CA4 6700                       		beq.s	.NotPrimary			; If not, branch
00002CA6 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00002CAC                            
00002CAC                            .NotPrimary:
00002CAC 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
00002CB0                            		
00002CB0 3228 001C                  		move.w	_objXVel(a0),d1			; Get X velocity
00002CB4 3428 001E                  		move.w	_objYVel(a0),d2			; Get Y velocity
00002CB8 4EB8 1786                  		jsr	CalcArcTan.w			; Get the angle
00002CBC 0400 0020                  		subi.b	#$20,d0				; Shift it over
00002CC0 0200 00C0                  		andi.b	#$C0,d0				; Get the quadrant
00002CC4 0C00 0040                  		cmpi.b	#$40,d0				; Are we hitting a left wall?
00002CC8 6700 0000                  		beq.w	PlayerHitLWall			; If so, branch
00002CCC 0C00 0080                  		cmpi.b	#$80,d0				; Are we hitting a ceiling?
00002CD0 6700 0000                  		beq.w	PlayerHitCeilAndWalls		; If so, branch
00002CD4 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we hitting a right wall?
00002CD8 6700 0000                  		beq.w	PlayerHitRWall			; If so, branch
00002CDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CDC                            PlayerHitFloorAndWalls:
00002CDC 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002CE0 4A41                       		tst.w	d1				; Have we hit the wall?
00002CE2 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002CE4 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
00002CE8 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00002CEC                            
00002CEC                            .NoLeftHit:
00002CEC 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002CF0 4A41                       		tst.w	d1				; Have we hit the wall?
00002CF2 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002CF4 D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00002CF8 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00002CFC                            
00002CFC                            .NoRightHit:
00002CFC 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002D00 4A41                       		tst.w	d1				; Have we hit the floor?
00002D02 6A00                       		bpl.s	.End				; If not, branch
00002D04                            
00002D04 1428 001E                  		move.b	_objYVel(a0),d2			; Get the integer part of the Y velocity
00002D08 5002                       		addq.b	#8,d2				; Get the max distance we have to have from the floor in order to collide with it
00002D0A 4402                       		neg.b	d2				; Negate it since we are in the floor
00002D0C B202                       		cmp.b	d2,d1				; Is the chosen primary distance small enough?
00002D0E 6C00                       		bge.s	.TouchFloor			; If so, branch
00002D10 B002                       		cmp.b	d2,d0				; What about the other angle that was found?
00002D12 6D00                       		blt.s	.End				; If not, branch
00002D14                            
00002D14                            .TouchFloor:
00002D14 1143 0000                  		move.b	d3,_objAngle(a0)			; Set the angle
00002D18 D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the floor
00002D1C 1003                       		move.b	d3,d0				; Copy angle
00002D1E 0600 0020                  		addi.b	#$20,d0				; Shift it
00002D22 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002D26 6600                       		bne.s	.HitWall			; If so, branch
00002D28 1003                       		move.b	d3,d0				; Copy angle
00002D2A 0600 0010                  		addi.b	#$10,d0				; Shift it
00002D2E 0200 0020                  		andi.b	#$20,d0				; Are we on a slope?
00002D32 6700                       		beq.s	.HitFloor			; If not, branch
00002D34 E0E8 001E                  		asr	_objYVel(a0)			; Divide the Y velocity by 2
00002D38 6000                       		bra.s	.HitSlope			; Continue
00002D3A                            
00002D3A                            .HitFloor:
00002D3A 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00002D3E 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
00002D44 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002D48                            
00002D48                            .HitWall:
00002D48 4268 001C                  		clr.w	_objXVel(a0)			; Stop X movement
00002D4C 0C68 0FC0 001E             		cmpi.w	#$FC0,_objYVel(a0)			; Cap the Y velocity at $FC0
00002D52 6F00                       		ble.s	.HitSlope			; ''
00002D54 317C 0FC0 001E             		move.w	#$FC0,_objYVel(a0)			; ''
00002D5A                            
00002D5A                            .HitSlope:
00002D5A 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002D5E 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
00002D64 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002D66 6A00                       		bpl.s	.End				; If so, branch
00002D68 4468 0000                  		neg.w	_objGVel(a0)			; Negate the ground velocity
00002D6C                            
00002D6C                            .End:
00002D6C 4E75                       		rts
00002D6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D6E                            PlayerHitLWall:
00002D6E 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002D72 4A41                       		tst.w	d1				; Have we hit the wall?
00002D74 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002D76 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
00002D7A 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00002D7E 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
00002D84                            
00002D84                            .ChkCeil:
00002D84 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002D88 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D8A 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002D8C 4441                       		neg.w	d1				; Get the distance inside the ceiling
00002D8E 0C41 0014                  		cmpi.w	#$14,d1				; Are we too far into the ceiling?
00002D92 6400                       		bhs.s	.ChkRightWall			; If so, branch
00002D94 D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
00002D98 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
00002D9C 6A00                       		bpl.s	.End				; If not, branch
00002D9E 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00002DA2                            
00002DA2                            .End:
00002DA2 4E75                       		rts
00002DA4                            
00002DA4                            .ChkRightWall:
00002DA4 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002DA8 4A41                       		tst.w	d1				; Have we hit the wall?
00002DAA 6A00                       		bpl.s	.End2				; If not, branch
00002DAC D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00002DB0 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00002DB4                            		
00002DB4                            .End2:
00002DB4 4E75                       		rts
00002DB6                            
00002DB6                            .ChkFloor:
00002DB6 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
00002DBA 6B00                       		bmi.s	.End3				; If so, branch
00002DBC 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002DC0 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002DC2 6A00                       		bpl.s	.End3				; If not, branch
00002DC4 D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
00002DC8 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
00002DCC 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00002DD0 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
00002DD6 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002DDA                            		
00002DDA                            .End3:
00002DDA 4E75                       		rts
00002DDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DDC                            PlayerHitCeilAndWalls:
00002DDC 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002DE0 4A41                       		tst.w	d1				; Have we hit the wall?
00002DE2 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002DE4 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
00002DE8 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00002DEC                            
00002DEC                            .NoLeftHit:
00002DEC 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002DF0 4A41                       		tst.w	d1				; Have we hit the wall?
00002DF2 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002DF4 D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00002DF8 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00002DFC                            
00002DFC                            .NoRightHit:
00002DFC 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002E00 4A41                       		tst.w	d1				; Have we hit the floor?
00002E02 6A00                       		bpl.s	.End				; If not, branch
00002E04 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move out of ceiling
00002E08 1003                       		move.b	d3,d0				; Get angle
00002E0A 0600 0020                  		addi.b	#$20,d0				; Shift it
00002E0E 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002E12 6600                       		bne.s	.HitWall			; If so, branch
00002E14 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00002E18 4E75                       		rts
00002E1A                            
00002E1A                            .HitWall:
00002E1A 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
00002E1E 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002E22 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
00002E28 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002E2A 6A00                       		bpl.s	.End				; If so, branch
00002E2C 4468 0000                  		neg.w	_objGVel(a0)			; Negate the ground velocity
00002E30                            
00002E30                            .End:
00002E30 4E75                       		rts
00002E32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E32                            PlayerHitRWall:
00002E32 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002E36 4A41                       		tst.w	d1				; Have we hit the wall?
00002E38 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002E3A D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00002E3E 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00002E42 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
00002E48                            
00002E48                            .ChkCeil:
00002E48 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002E4C 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002E4E 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002E50 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move out of the ceiling
00002E54 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
00002E58 6A00                       		bpl.s	.End				; If not, branch
00002E5A 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00002E5E                            
00002E5E                            .End:
00002E5E 4E75                       		rts
00002E60                            
00002E60                            .ChkFloor:
00002E60 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
00002E64 6B00                       		bmi.s	.End2				; If so, branch
00002E66 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002E6A 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002E6C 6A00                       		bpl.s	.End2				; If not, branch
00002E6E D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
00002E72 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
00002E76 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00002E7A 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
00002E80 6000                       		bra.s	PlayerResetOnFloor		; Reset status on floor
00002E82                            		
00002E82                            .End2:
00002E82 4E75                       		rts
00002E84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E84                            ; Reset a player object's status on the floor
00002E84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E84                            PlayerResetOnFloor:
00002E84                            		playSnd	#sSkid, 2			; Play skid sound
00002E84 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
00002E8A 4A28 0000                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
00002E8E 6600                       		bne.s	PlayerResetOnFloorPart3	; If so, branch
00002E90 4228 0020                  		clr.b	_objAnim(a0)			; Set walking animation
00002E94                            		
00002E94                            PlayerResetOnFloorPart2:
00002E94 0828 0002 0028             		btst	#2,_objStatus(a0)			; Was Sonic rolling?
00002E9A 6700                       		beq.s	PlayerResetOnFloorPart3	; If so, branch
00002E9C 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Clear roll flag
00002EA2 1168 0000 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
00002EA8 1168 0000 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00002EAE 4228 0020                  		clr.b	_objAnim(a0)			; Set walking animation
00002EB2                            	;	subq.w	#5,_objYPos(a0)			; Align with floor
00002EB2                            
00002EB2                            PlayerResetOnFloorPart3:
00002EB2 0228 00DD 0028             		andi.b	#$DD,_objStatus(a0)		; Clear "pushing", and "jumping" flag
00002EB8 4228 0000                  		clr.b	_objJumping(a0)			; Clear jumping flag
00002EBC 4228 0000                  		clr.b	_objFlipAngle(a0)			; Reset flip angle
00002EC0 4228 0000                  		clr.b	_objFlipTurned(a0)			; Reset flip inverted flag
00002EC4 4228 0000                  		clr.b	_objFlipRemain(a0)			; Reset flips remaining
00002EC8 4E75                       		rts
00002ECA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ECA                            ; Calculate the room in front of a player object
00002ECA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ECA                            PlayerCalcRoomInFront:
00002ECA 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00002ED0 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00002ED6 6700                       		beq.s	.NotPrimary			; If not, branch
00002ED8 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00002EDE                            
00002EDE                            .NotPrimary:
00002EDE 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
00002EE2                            		
00002EE2 2628 0014                  		move.l	_objXPos(a0),d3			; Get X position
00002EE6 2428 0018                  		move.l	_objYPos(a0),d2			; Get Y position
00002EEA 3228 001C                  		move.w	_objXVel(a0),d1			; Get X velocity
00002EEE 48C1                       		ext.l	d1				; ''
00002EF0 E181                       		asl.l	#8,d1				; Shift it
00002EF2 D681                       		add.l	d1,d3				; Add onto X position
00002EF4 3228 001E                  		move.w	_objYVel(a0),d1			; Get Y velocity
00002EF8 48C1                       		ext.l	d1				; ''
00002EFA E181                       		asl.l	#8,d1				; Shift it
00002EFC D481                       		add.l	d1,d2				; Add onto Y position
00002EFE 4842                       		swap	d2				; Get actual Y
00002F00 4843                       		swap	d3				; Get actual X
00002F02 1140 002E                  		move.b	d0,_objNextTilt(a0)		; Set primary angle
00002F06 1140 002F                  		move.b	d0,_objTilt(a0)			; Set secondary angle
00002F0A 1200                       		move.b	d0,d1				; Copy angle
00002F0C 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00002F10 6700                       		beq.s	.DownUp				; If not, branch
00002F12 5200                       		addq.b	#1,d0				; Shift the angle
00002F14                            
00002F14                            .DownUp:
00002F14 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
00002F18 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002F1C 6700 0000                  		beq.w	PlayerChkFloorDist_Part2	; If quadrant 0, get the floor distance
00002F20 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002F24 6700 0000                  		beq.w	PlayerChkCeilingDist_Part2	; If so, branch
00002F28 0201 0038                  		andi.b	#$38,d1				; Are we on a flat enough surface?
00002F2C 6600                       		bne.s	.ChkWall			; If not, branch
00002F2E 5042                       		addq.w	#8,d2				; Add 8 to the Y position
00002F30                            
00002F30                            .ChkWall:
00002F30 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002F34 6700 0000                  		beq.w	PlayerChkLeftWallDist_Part2	; If so, branch
00002F38 6000 0000                  		bra.w	PlayerChkRightWallDist_Part2	; Get the right wall distance
00002F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F3C                            ; Calculate the room over a player object
00002F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F3C                            PlayerCalcRoomOverHead:
00002F3C 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00002F42 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00002F48 6700                       		beq.s	.NotPrimary			; If not, branch
00002F4A 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00002F50                            
00002F50                            .NotPrimary:
00002F50 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
00002F54 1140 002E                  		move.b	d0,_objNextTilt(a0)		; Set primary angle
00002F58 1140 002F                  		move.b	d0,_objTilt(a0)			; Set secondary angle
00002F5C                            		
00002F5C 0600 0020                  		addi.b	#$20,d0				; Shift the angle
00002F60 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002F64 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002F68 6700 0000                  		beq.w	PlayerChkLeftCeilDist		; If so, branch
00002F6C 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002F70 6700 0000                  		beq.w	PlayerChkCeiling		; If so, branch
00002F74 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0?
00002F78 6700 0000                  		beq.w	PlayerChkRightCeilDist		; If so, branch
00002F7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F7C                            ; Get the distance between the floor and a player object (with primary and secondary angles)
00002F7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F7C                            PlayerChkFloor:
00002F7C 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00002F82 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00002F88 6700                       		beq.s	.NotPrimary			; If not, branch
00002F8A 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00002F90                            
00002F90                            .NotPrimary:
00002F90 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Get top solid bits
00002F94                            		
00002F94                            		; Get the angle on the bottom right sensor
00002F94 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00002F98 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00002F9C 7000                       		moveq	#0,d0
00002F9E 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00002FA2 4880                       		ext.w	d0				; ''
00002FA4 D440                       		add.w	d0,d2				; Add onto Y position
00002FA6 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00002FAA 4880                       		ext.w	d0				; ''
00002FAC D640                       		add.w	d0,d3				; Add onto X position
00002FAE 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00002FB2 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FB6 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002FB8 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FBC                            		push.w	d1				; Save the primary floor distance
00002FBC 3F01                     M 	move.w	d1,-(sp)
00002FBE                            
00002FBE                            		; Get the angle on the bottom left sensor
00002FBE 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00002FC2 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00002FC6 7000                       		moveq	#0,d0
00002FC8 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00002FCC 4880                       		ext.w	d0				; ''
00002FCE D440                       		add.w	d0,d2				; Add onto Y position
00002FD0 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00002FD4 4880                       		ext.w	d0				; ''
00002FD6 9640                       		sub.w	d0,d3				; Subtract from X position
00002FD8 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00002FDC 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FE0 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002FE2 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FE6                            		
00002FE6                            		; Update the object's angle
00002FE6                            		pop.w	d0				; Restore the primary floor distance
00002FE6 301F                     M 	move.w	(sp)+,d0
00002FE8 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FEA                            PlayerPickAngle:
00002FEA 1628 002F                  		move.b	_objTilt(a0),d3			; Get secondary angle
00002FEE B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00002FF0 6F00                       		ble.s	.ChkSetAngle			; If not, branch
00002FF2 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00002FF6 C141                       		exg.l	d0,d1				; Switch floor distance values
00002FF8                            		
00002FF8                            .ChkSetAngle:
00002FF8 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002FFC 6700                       		beq.s	.End				; If not, branch
00002FFE 1602                       		move.b	d2,d3				; Set the new angle value
00003000                            		
00003000                            .End:
00003000 4E75                       		rts
00003002                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003002                            ; Get the distance between the floor and the player object
00003002                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003002                            PlayerChkFloorDist:
00003002 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003006 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000300A                            
0000300A                            PlayerChkFloorDist_Part2:
0000300A 0642 000A                  		addi.w	#10,d2				; Check 10 pixels down
0000300E 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003012 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003016 4246                       		clr.w	d6				; No flip bits
00003018 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000301C 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
0000301E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000301E                            PlayerGetPrimaryAngle:
0000301E 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003022 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00003026 6700                       		beq.s	.End				; If not, branch
00003028 1602                       		move.b	d2,d3				; Set the new angle value
0000302A                            		
0000302A                            .End:
0000302A 4E75                       		rts
0000302C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000302C                            sub_F846:
0000302C 3628 0014                  		move.w	_objXPos(a0),d3
00003030 3428 0018                  		move.w	_objYPos(a0),d2
00003034 5942                       		subq.w	#4,d2
00003036 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
0000303C 0C28 000D 0000             		cmpi.b	#$D,_objLRBSolid(a0)		; Are we on the primary path?
00003042 6700                       		beq.s	.NotPrimary			; If not, branch
00003044 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
0000304A                            
0000304A                            .NotPrimary:
0000304A 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000304E 4214                       		clr.b	(a4)				; Clear it
00003050 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003054 4246                       		clr.w	d6				; No flip bits
00003056 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Solidity bits
0000305A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000305E 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003062 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003066 6700                       		beq.s	.End				; If not, branch
00003068 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
0000306A                            
0000306A                            .End:
0000306A 4E75                       		rts
0000306C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000306C                            ; Check for the edge of a floor
0000306C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000306C                            PlayerChkFloorEdge:
0000306C 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003070                            
00003070                            PlayerChkFloorEdge_Part2:
00003070 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003074 7000                       		moveq	#0,d0
00003076 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000307A 4880                       		ext.w	d0				; ''
0000307C D440                       		add.w	d0,d2				; Add onto Y position
0000307E                            
0000307E                            PlayerChkFloorEdge_Part3:
0000307E 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00003084 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
0000308A 6700                       		beq.s	.NotPrimary			; If not, branch
0000308C 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003092                            
00003092                            .NotPrimary:
00003092 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003096 4214                       		clr.b	(a4)				; Clear it
00003098 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000309C 4246                       		clr.w	d6				; No flip bits
0000309E 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Solidity bits
000030A2 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000030A6 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000030AA 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000030AE 6700                       		beq.s	.End				; If not, branch
000030B0 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
000030B2                            
000030B2                            .End:
000030B2 4E75                       		rts
000030B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030B4                            ; Get the distance between the floor and an object
000030B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030B4                            ObjCheckFloorDist:
000030B4 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000030B8                            		
000030B8                            ObjCheckFloorDist_Part2:
000030B8 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000030BC                            
000030BC                            ObjCheckFloorDist_Part3:
000030BC 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000030C0 4880                       		ext.w	d0				; ''
000030C2 D440                       		add.w	d0,d2				; Add onto Y position
000030C4 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000030C8 4214                       		clr.b	(a4)				; Clear it
000030CA 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000030CE 4246                       		clr.w	d6				; No flip bits
000030D0 7A0C                       		moveq	#$C,d5				; Solidity bits
000030D2 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000030D6 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000030DA 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000030DE 6700                       		beq.s	.End				; If not, branch
000030E0 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
000030E2                            
000030E2                            .End:
000030E2 4E75                       		rts
000030E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030E4                            ; Get the distance between a right ceiling and a player object
000030E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030E4                            PlayerChkRightCeilDist:
000030E4                            		; Get the angle on the bottom right (rotated) sensor
000030E4 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000030E8 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000030EC 7000                       		moveq	#0,d0
000030EE 1028 002C                  		move.b	_objColW(a0),d0			; Get collision height
000030F2 4880                       		ext.w	d0				; ''
000030F4 9440                       		sub.w	d0,d2				; Subtract from Y position
000030F6 1028 002D                  		move.b	_objColH(a0),d0			; Get collision width
000030FA 4880                       		ext.w	d0				; ''
000030FC D640                       		add.w	d0,d3				; Add onto X position
000030FE 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003102 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003106 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003108 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000310C                            		push.w	d1				; Save the primary floor distance
0000310C 3F01                     M 	move.w	d1,-(sp)
0000310E                            
0000310E                            		; Get the angle on the bottom left (rotated) sensor
0000310E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003112 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003116 7000                       		moveq	#0,d0
00003118 1028 002C                  		move.b	_objColW(a0),d0			; Get collision height
0000311C 4880                       		ext.w	d0				; ''
0000311E D440                       		add.w	d0,d2				; Add onto Y position
00003120 1028 002D                  		move.b	_objColH(a0),d0			; Get collision width
00003124 4880                       		ext.w	d0				; ''
00003126 D640                       		add.w	d0,d3				; Add onto X position
00003128 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
0000312C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003130 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003132 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003136                            
00003136                            		; Update the object's angle
00003136                            		pop.w	d0				; Restore the primary floor distance
00003136 301F                     M 	move.w	(sp)+,d0
00003138 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
0000313C 6000 FEAC                  		bra.w	PlayerPickAngle		; Get the angle
00003140                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003140                            ; Get the distance between a right wall and a player object
00003140                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003140                            PlayerChkRightWallDist:
00003140 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003144 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003148                            
00003148                            PlayerChkRightWallDist_Part2:
00003148 0643 000A                  		addi.w	#10,d3				; Check 10 pixels to the right
0000314C 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003150 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003154 4246                       		clr.w	d6				; No flip bits
00003156 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000315A 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
0000315E 6000 FEBE                  		bra.w	PlayerGetPrimaryAngle		; Get angle
00003162                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003162                            ; Get the distance between a right wall and an object
00003162                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003162                            ObjCheckRightWallDist:
00003162 D668 0014                  		add.w	_objXPos(a0),d3			; Add X position
00003166 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000316A 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000316E 4214                       		clr.b	(a4)				; Clear it
00003170 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003174 4246                       		clr.w	d6				; No flip bits
00003176 7A0D                       		moveq	#$D,d5				; Solidity bits
00003178 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000317C 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003180 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003184 6700                       		beq.s	.End				; If not, branch
00003186 163C 00C0                  		move.b	#-$40,d3			; Angle value for when the object touched an odd angle (usually $FF)
0000318A                            
0000318A                            .End:
0000318A 4E75                       		rts
0000318C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000318C                            ; Get the distance between a ceiling and a player object (with primary and secondary angles)
0000318C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000318C                            PlayerChkCeiling:
0000318C                            		; Get the angle on the bottom right sensor
0000318C 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003190 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003194 7000                       		moveq	#0,d0
00003196 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000319A 4880                       		ext.w	d0				; ''
0000319C 9440                       		sub.w	d0,d2				; Subtract from Y position
0000319E 0A42 000F                  		eori.w	#$F,d2				; Flip it
000031A2 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000031A6 4880                       		ext.w	d0				; ''
000031A8 D640                       		add.w	d0,d3				; Add onto X position
000031AA 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000031AE 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031B2 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000031B6 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000031BA                            		push.w	d1				; Save the primary floor distance
000031BA 3F01                     M 	move.w	d1,-(sp)
000031BC                            
000031BC                            		; Get the angle on the bottom left sensor
000031BC 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000031C0 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000031C4 7000                       		moveq	#0,d0
000031C6 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000031CA 4880                       		ext.w	d0				; ''
000031CC 9440                       		sub.w	d0,d2				; Subtract from Y position
000031CE 0A42 000F                  		eori.w	#$F,d2				; Flip it
000031D2 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000031D6 4880                       		ext.w	d0				; ''
000031D8 9640                       		sub.w	d0,d3				; Subtract from X position
000031DA 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000031DE 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031E2 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000031E6 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000031EA                            		
000031EA                            		; Update the object's angle
000031EA                            		pop.w	d0				; Restore the primary floor distance
000031EA 301F                     M 	move.w	(sp)+,d0
000031EC 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
000031F0 6000 FDF8                  		bra.w	PlayerPickAngle		; Get the angle
000031F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031F4                            ; Get the distance between a ceiling and a player object
000031F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031F4                            PlayerChkCeilingDist:
000031F4 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000031F8 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000031FC                            
000031FC                            PlayerChkCeilingDist_Part2:
000031FC 0442 000A                  		subi.w	#10,d2				; Check 10 pixels up
00003200 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003204 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003208 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000320C 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003210 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003214 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003218 6000 FE04                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000321C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000321C                            ; Get the distance between a ceiling and an object
0000321C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000321C                            ObjCheckCeilingDist:
0000321C 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003220 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003224 7000                       		moveq	#0,d0
00003226 1028 002D                  		move.b	_objColH(a0),d0		; Get collision height
0000322A 4880                       		ext.w	d0				; ''
0000322C 9440                       		sub.w	d0,d2				; Subtract it from Y position
0000322E 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003232 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003236 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000323A 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000323E 7A0D                       		moveq	#$D,d5				; Solidity bits
00003240 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003244 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003248 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000324C 6700                       		beq.s	.End				; If not, branch
0000324E 163C 0080                  		move.b	#$80,d3				; Angle value for when the object touched an odd angle (usually $FF)
00003252                            
00003252                            .End:
00003252 4E75                       		rts
00003254                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003254                            ; Get the distance between a left ceiling and a player object
00003254                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003254                            PlayerChkLeftCeilDist:
00003254                            		; Get the angle on the bottom right (rotated) sensor
00003254 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003258 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000325C 7000                       		moveq	#0,d0
0000325E 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003262 4880                       		ext.w	d0				; ''
00003264 9440                       		sub.w	d0,d2				; Subtract from Y position
00003266 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000326A 4880                       		ext.w	d0				; ''
0000326C 9640                       		sub.w	d0,d3				; Subtract from X position
0000326E 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003272 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003276 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000327A 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000327E 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003282                            		push.w	d1				; Save the primary floor distance
00003282 3F01                     M 	move.w	d1,-(sp)
00003284                            
00003284                            		; Get the angle on the bottom left (rotated) sensor
00003284 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003288 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000328C 7000                       		moveq	#0,d0
0000328E 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003292 4880                       		ext.w	d0				; ''
00003294 D440                       		add.w	d0,d2				; Add onto Y position
00003296 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000329A 4880                       		ext.w	d0				; ''
0000329C 9640                       		sub.w	d0,d3				; Subtract from X position
0000329E 0A43 000F                  		eori.w	#$F,d3				; Flip it
000032A2 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000032A6 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000032AA 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000032AE 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000032B2                            
000032B2                            		; Update the object's angle
000032B2                            		pop.w	d0				; Restore the primary floor distance
000032B2 301F                     M 	move.w	(sp)+,d0
000032B4 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000032B8 6000 FD30                  		bra.w	PlayerPickAngle		; Get the angle
000032BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032BC                            ; Get the distance between a left wall and a player object
000032BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032BC                            PlayerChkLeftWallDist:
000032BC 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000032C0 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000032C4                            
000032C4                            PlayerChkLeftWallDist_Part2:
000032C4 0443 000A                  		subi.w	#10,d3				; Check 10 pixels to the left
000032C8 0A43 000F                  		eori.w	#$F,d3				; Flip it
000032CC 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000032D0 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000032D4 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000032D8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000032DC 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000032E0 6000 FD3C                  		bra.w	PlayerGetPrimaryAngle		; Get angle
000032E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032E4                            ; Get the distance between a left wall and an object
000032E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032E4                            ObjCheckLeftWallDist:
000032E4 D668 0014                  		add.w	_objXPos(a0),d3			; Add X position
000032E8 0A43 000F                  		eori.w	#$F,d3				; Flip it
000032EC 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000032F0 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000032F4 4214                       		clr.b	(a4)				; Clear it
000032F6 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000032FA 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000032FE 7A0D                       		moveq	#$D,d5				; Solidity bits
00003300 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003304 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003308 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000330C 6700                       		beq.s	.End				; If not, branch
0000330E 163C 0040                  		move.b	#$40,d3				; Angle value for when the object touched an odd angle (usually $FF)
00003312                            
00003312                            .End:
00003312 4E75                       		rts
00003314                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003314                            ; Move a player object along on the ground
00003314                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003314                            PlayerAnglePos:
00003314 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
0000331A 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00003320 6700                       		beq.s	.NotPrimary			; If not, branch
00003322 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003328                            
00003328                            .NotPrimary:
00003328 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Get top solid bits
0000332C 0828 0003 0028             		btst	#3,_objStatus(a0)			; Are we standing on a player object?
00003332 6700                       		beq.s	.NotOnObj			; If not, branch
00003334 4268 002E                  		clr.w	_objNextTilt(a0)			; Set the angles to 0
00003338 4E75                       		rts
0000333A                            
0000333A                            .NotOnObj:
0000333A 317C 0303 002E             		move.w	#$0303,_objNextTilt(a0)		; Set the angles to 3
00003340                            		
00003340                            		; Get which quadrant the object is in on the ground
00003340                            		; This makes it so that angles:
00003340                            		; 	$E0-$20 = Quadrant 0 (floor)
00003340                            		;	$1F-$5F = Quadrant $40 (left wall)
00003340                            		;	$60-$A0 = Quadrant $80 (ceiling)
00003340                            		;	$A1-$DF = Quadrant $C0 (right wall)
00003340 1028 0000                  		move.b	_objAngle(a0),d0			; Get the angle
00003344 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00003348 6700                       		beq.s	.DownUp				; If not, branch
0000334A 5200                       		addq.b	#1,d0				; Shift the angle
0000334C                            
0000334C                            .DownUp:
0000334C 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
00003350 0200 00C0                  		andi.b	#$C0,d0				; Get which quadrant we are in (use $E0 instaead of $C0 for 8 directions)
00003354 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40 (left wall)?
00003358 6700 0000                  		beq.w	PlayerMoveLWall		; If so, branch
0000335C 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80 (ceiling)?
00003360 6700 0000                  		beq.w	PlayerMoveCeiling		; Is so, branch
00003364 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0 (right wall)?
00003368 6700 0000                  		beq.w	PlayerMoveRWall		; If so, branch
0000336C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000336C                            ; Move the object along the floor
0000336C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000336C                            PlayerMoveFloor:
0000336C                            		; Get the angle on the bottom right sensor
0000336C 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003370 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003374 7000                       		moveq	#0,d0
00003376 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000337A 4880                       		ext.w	d0				; ''
0000337C D440                       		add.w	d0,d2				; Add onto Y position
0000337E 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003382 4880                       		ext.w	d0				; ''
00003384 D640                       		add.w	d0,d3				; Add onto X position
00003386 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
0000338A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000338E 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003390 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003394                            		push.w	d1				; Save the primary floor distance
00003394 3F01                     M 	move.w	d1,-(sp)
00003396                            
00003396                            		; Get the angle on the bottom left sensor
00003396 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000339A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000339E 7000                       		moveq	#0,d0
000033A0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000033A4 4880                       		ext.w	d0				; ''
000033A6 D440                       		add.w	d0,d2				; Add onto Y position
000033A8 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000033AC 4880                       		ext.w	d0				; ''
000033AE 9640                       		sub.w	d0,d3				; Add onto X position
000033B0 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000033B4 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000033B8 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000033BA 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000033BE                            		
000033BE                            		; Update the object's angle
000033BE                            		pop.w	d0				; Restore the primary floor distance
000033BE 301F                     M 	move.w	(sp)+,d0
000033C0 6100 0000                  		bsr.w	PlayerSetAngle			; Set the new angle
000033C4                            		
000033C4                            		; Check if the object has hit a wall or is about to fall
000033C4 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000033C6 6700                       		beq.s	.End				; If so, branch
000033C8 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000033CA 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000033CE 6D00                       		blt.s	.End				; If so, branch
000033D0 D368 0018                  		add.w	d1,_objYPos(a0)			; Move us on to the surface
000033D4                            
000033D4                            .End:
000033D4 4E75                       		rts
000033D6                            
000033D6                            .ChkFall:
000033D6 1028 001C                  		move.b	_objXVel(a0),d0			; Get the integer part of the X velocity
000033DA 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000033DC 4400                       		neg.b	d0				; Force it to be positive
000033DE                            
000033DE                            .GetMinDist:
000033DE 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
000033E0 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000033E4 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000033E6 103C 000E                  		move.b	#$E,d0				; ''
000033EA                            
000033EA                            .ChkDist:
000033EA B200                       		cmp.b	d0,d1				; Are we about to fall off?
000033EC 6E00                       		bgt.s	.SetAir				; If so, branch
000033EE D368 0018                  		add.w	d1,_objYPos(a0)			; Move us on to the surface
000033F2 4E75                       		rts
000033F4                            
000033F4                            .SetAir:
000033F4 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
000033FA 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00003400 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00003406 4E75                       		rts
00003408                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003408                            ; Set the objects's angle
00003408                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003408                            PlayerSetAngle:
00003408 1428 002F                  		move.b	_objTilt(a0),d2			; Get secondary angle
0000340C B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
0000340E 6F00                       		ble.s	.ChkSetAngle			; If not, branch
00003410 1428 002E                  		move.b	_objNextTilt(a0),d2		; Get primary angle
00003414 3200                       		move.w	d0,d1				; Get primary floor distance
00003416                            		
00003416                            .ChkSetAngle:
00003416 0802 0000                  		btst	#0,d2				; Is this an odd angle (usually $FF)?
0000341A 6600                       		bne.s	.LatchOnFlat			; If so, branch
0000341C 1002                       		move.b	d2,d0				; Get angle change
0000341E 9028 0000                  		sub.b	_objAngle(a0),d0			; ''
00003422 6A00                       		bpl.s	.ChkDist			; ''
00003424 4400                       		neg.b	d0				; ''
00003426                            
00003426                            .ChkDist:
00003426 0C00 0020                  		cmpi.b	#$20,d0				; Has the player moved $20 degrees or more?
0000342A 6400                       		bhs.s	.LatchOnFlat			; If so, branch
0000342C 1142 0000                  		move.b	d2,_objAngle(a0)			; Set the new angle value
00003430 4E75                       		rts
00003432                            
00003432                            .LatchOnFlat:
00003432 1428 0000                  		move.b	_objAngle(a0),d2			; Get old angle value
00003436 0602 0020                  		addi.b	#$20,d2				; Shift the angle
0000343A 0202 00C0                  		andi.b	#$C0,d2				; Flatten the angle
0000343E 1142 0000                  		move.b	d2,_objAngle(a0)			; Set the new angle value
00003442 4E75                       		rts
00003444                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003444                            ; Move the object along the right wall
00003444                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003444                            PlayerMoveRWall:
00003444                            		; Get the angle on the bottom right (rotated) sensor
00003444 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003448 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000344C 7000                       		moveq	#0,d0
0000344E 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003452 4880                       		ext.w	d0				; ''
00003454 9440                       		sub.w	d0,d2				; Add onto Y position
00003456 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000345A 4880                       		ext.w	d0				; ''
0000345C D640                       		add.w	d0,d3				; Add onto X position
0000345E 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003462 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003466 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003468 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000346C                            		push.w	d1				; Save the primary floor distance
0000346C 3F01                     M 	move.w	d1,-(sp)
0000346E                            
0000346E                            		; Get the angle on the bottom left (rotated) sensor
0000346E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003472 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003476 7000                       		moveq	#0,d0
00003478 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000347C 4880                       		ext.w	d0				; ''
0000347E D440                       		add.w	d0,d2				; Add onto Y position
00003480 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003484 4880                       		ext.w	d0				; ''
00003486 D640                       		add.w	d0,d3				; Add onto X position
00003488 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
0000348C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003490 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003492 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003496                            		
00003496                            		; Update the object's angle
00003496                            		pop.w	d0				; Restore the primary floor distance
00003496 301F                     M 	move.w	(sp)+,d0
00003498 6100 FF6E                  		bsr.w	PlayerSetAngle			; Set the new angle
0000349C                            
0000349C                            		; Check if the object has hit a wall or is about to fall
0000349C 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
0000349E 6700                       		beq.s	.End				; If so, branch
000034A0 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000034A2 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000034A6 6D00                       		blt.s	.End				; If so, branch
000034A8 D368 0014                  		add.w	d1,_objXPos(a0)			; Move us on to the surface
000034AC                            
000034AC                            .End:
000034AC 4E75                       		rts
000034AE                            
000034AE                            .ChkFall:
000034AE 1028 001E                  		move.b	_objYVel(a0),d0			; Get the integer part of the Y velocity
000034B2 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000034B4 4400                       		neg.b	d0				; Force it to be positive
000034B6                            
000034B6                            .GetMinDist:
000034B6 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
000034B8 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000034BC 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000034BE 103C 000E                  		move.b	#$E,d0				; ''
000034C2                            
000034C2                            .ChkDist:
000034C2 B200                       		cmp.b	d0,d1				; Are we about to fall off?
000034C4 6E00                       		bgt.s	.SetAir				; If so, branch
000034C6 D368 0014                  		add.w	d1,_objXPos(a0)			; Move us on to the surface
000034CA 4E75                       		rts
000034CC                            
000034CC                            .SetAir:
000034CC 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
000034D2 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
000034D8 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
000034DE 4E75                       		rts
000034E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034E0                            ; Move the object along the ceiling
000034E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034E0                            PlayerMoveCeiling:
000034E0                            		; Get the angle on the bottom right (rotated) sensor
000034E0 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000034E4 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000034E8 7000                       		moveq	#0,d0
000034EA 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000034EE 4880                       		ext.w	d0				; ''
000034F0 9440                       		sub.w	d0,d2				; Subtract from the Y position
000034F2 0A42 000F                  		eori.w	#$F,d2				; Flip it
000034F6 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000034FA 4880                       		ext.w	d0				; ''
000034FC D640                       		add.w	d0,d3				; Add onto X position
000034FE 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003502 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003506 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000350A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000350E                            		push.w	d1				; Save the primary floor distance
0000350E 3F01                     M 	move.w	d1,-(sp)
00003510                            
00003510                            		; Get the angle on the bottom left (rotated) sensor
00003510 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003514 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003518 7000                       		moveq	#0,d0
0000351A 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000351E 4880                       		ext.w	d0				; ''
00003520 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003522 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003526 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000352A 4880                       		ext.w	d0				; ''
0000352C 9640                       		sub.w	d0,d3				; Subtract from the X position
0000352E 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003532 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003536 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000353A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000353E                            		
0000353E                            		; Update the object's angle
0000353E                            		pop.w	d0				; Restore the primary floor distance
0000353E 301F                     M 	move.w	(sp)+,d0
00003540 6100 FEC6                  		bsr.w	PlayerSetAngle			; Set the new angle
00003544                            		
00003544                            		; Check if the object has hit a wall or is about to fall
00003544 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003546 6700                       		beq.s	.End				; If so, branch
00003548 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
0000354A 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
0000354E 6D00                       		blt.s	.End				; If so, branch
00003550 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move us on to the surface
00003554                            
00003554                            .End:
00003554 4E75                       		rts
00003556                            
00003556                            .ChkFall:
00003556 1028 001C                  		move.b	_objXVel(a0),d0			; Get the integer part of the X velocity
0000355A 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
0000355C 4400                       		neg.b	d0				; Force it to be positive
0000355E                            
0000355E                            .GetMinDist:
0000355E 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
00003560 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003564 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003566 103C 000E                  		move.b	#$E,d0				; ''
0000356A                            
0000356A                            .ChkDist:
0000356A B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000356C 6E00                       		bgt.s	.SetAir				; If so, branch
0000356E 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move us on to the surface
00003572 4E75                       		rts
00003574                            
00003574                            .SetAir:
00003574 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
0000357A 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00003580 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00003586 4E75                       		rts
00003588                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003588                            ; Move the object along the left wall
00003588                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003588                            PlayerMoveLWall:
00003588                            		; Get the angle on the bottom right (rotated) sensor
00003588 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000358C 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003590 7000                       		moveq	#0,d0
00003592 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003596 4880                       		ext.w	d0				; ''
00003598 9440                       		sub.w	d0,d2				; Subtract from the Y position
0000359A 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000359E 4880                       		ext.w	d0				; ''
000035A0 9640                       		sub.w	d0,d3				; Subtract from X position
000035A2 0A43 000F                  		eori.w	#$F,d3				; Flip it
000035A6 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000035AA 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000035AE 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000035B2 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000035B6                            		push.w	d1				; Save the primary floor distance
000035B6 3F01                     M 	move.w	d1,-(sp)
000035B8                            
000035B8                            		; Get the angle on the bottom left (rotated) sensor
000035B8 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000035BC 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000035C0 7000                       		moveq	#0,d0
000035C2 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000035C6 4880                       		ext.w	d0				; ''
000035C8 D440                       		add.w	d0,d2				; Add onto Y position
000035CA 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000035CE 4880                       		ext.w	d0				; ''
000035D0 9640                       		sub.w	d0,d3				; Subtract from X position
000035D2 0A43 000F                  		eori.w	#$F,d3				; Flip it
000035D6 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000035DA 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000035DE 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000035E2 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000035E6                            		
000035E6                            		; Update the object's angle
000035E6                            		pop.w	d0				; Restore the primary floor distance
000035E6 301F                     M 	move.w	(sp)+,d0
000035E8 6100 FE1E                  		bsr.w	PlayerSetAngle			; Set the new angle
000035EC                            		
000035EC                            		; Check if the object has hit a wall or is about to fall
000035EC 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000035EE 6700                       		beq.s	.End				; If so, branch
000035F0 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000035F2 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000035F6 6D00                       		blt.s	.End				; If so, branch
000035F8 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move us on to the surface
000035FC                            
000035FC                            .End:
000035FC 4E75                       		rts
000035FE                            
000035FE                            .ChkFall:
000035FE 1028 001E                  		move.b	_objYVel(a0),d0			; Get the integer part of the Y velocity
00003602 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003604 4400                       		neg.b	d0				; Force it to be positive
00003606                            
00003606                            .GetMinDist:
00003606 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
00003608 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000360C 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
0000360E 103C 000E                  		move.b	#$E,d0				; ''
00003612                            
00003612                            .ChkDist:
00003612 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003614 6E00                       		bgt.s	.SetAir				; If so, branch
00003616 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move us on to the surface
0000361A 4E75                       		rts
0000361C                            
0000361C                            .SetAir:
0000361C 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00003622 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00003628 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
0000362E 4E75                       		rts
00003630                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003630                            ; Find the nearest floor from the object's position
00003630                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003630                            ; PARAMETERS:
00003630                            ;	d2.w	- Y position of the object's bottom sensor
00003630                            ;	d3.w	- X position of the object's bottom sensor
00003630                            ;	d5.w	- Bit to chect for solidity
00003630                            ;	d6.w	- Flip bits (for walls and ceilings)
00003630                            ;	a3.w	- Distance in pixels to check for blocks above or below the sensor
00003630                            ;	a4.w	- Pointer to where the angle value will be stored
00003630                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003630                            ; RETURNS:
00003630                            ;	d1.w	- The distance from the object to the floor
00003630                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003630                            ;	(a4).w	- The floor angle
00003630                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003630                            Level_FindFloor:
00003630 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003634 3011                       		move.w	(a1),d0				; Get block ID
00003636 3800                       		move.w	d0,d4				; Copy that
00003638 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
0000363C 6700                       		beq.s	.IsBlank			; If it's blank, branch
0000363E 0B04                       		btst	d5,d4				; Is the block solid?
00003640 6600                       		bne.s	.IsSolid			; If so, branch
00003642                            
00003642                            .IsBlank:
00003642 D44B                       		add.w	a3,d2				; Check below the sensor
00003644 6100 0000                  		bsr.w	Level_FindFloor2		; Try to find a solid block there
00003648 944B                       		sub.w	a3,d2				; Restore Y position of sensor
0000364A 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
0000364E 4E75                       		rts
00003650                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003650                            .IsSolid:
00003650 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003654 D040                       		add.w	d0,d0				; Turn ID into offset
00003656 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
0000365A 0240 00FF                  		andi.w	#$FF,d0				; ''
0000365E 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003660                            
00003660 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003664 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003668 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
0000366A                            
0000366A 3203                       		move.w	d3,d1				; Get the object's X position
0000366C 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003670 6700                       		beq.s	.NoXFlip			; If not, branch
00003672 4641                       		not.w	d1				; Flip the X position
00003674 4414                       		neg.b	(a4)				; Flip the angle
00003676                            		
00003676                            .NoXFlip:
00003676 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000367A 6700                       		beq.s	.NoYFlip			; If not, branch
0000367C 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003680 4414                       		neg.b	(a4)				; ''
00003682 0414 0040                  		subi.b	#$40,(a4)			; ''
00003686                            
00003686                            .NoYFlip:
00003686 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
0000368A D240                       		add.w	d0,d1				; Add the collision block's offset
0000368C                            
0000368C 2478 E8F4                  		movea.l	normColArrayPtr.w,a2		; Get the normal collision array
00003690 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003694 4880                       		ext.w	d0				; ''
00003696 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003698 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000369C 6700                       		beq.s	.NoYFlip2			; If not, branch
0000369E 4440                       		neg.w	d0				; Flip the height
000036A0                            
000036A0                            .NoYFlip2:
000036A0 4A40                       		tst.w	d0				; Check the height
000036A2 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000036A4 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000036A6 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
000036AA 6700                       		beq.s	.MaxFloor			; If so, branch
000036AC 3202                       		move.w	d2,d1				; Get the object's Y position
000036AE 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000036B2 D041                       		add.w	d1,d0				; Add onto the height
000036B4 323C 000F                  		move.w	#$F,d1				; Get actual distance
000036B8 9240                       		sub.w	d0,d1				; ''
000036BA 4E75                       		rts
000036BC                            
000036BC                            .NegHeight:
000036BC 3202                       		move.w	d2,d1				; Get the object's Y position
000036BE 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000036C2 D041                       		add.w	d1,d0				; Add onto the height
000036C4 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000036C8                            
000036C8                            .MaxFloor:
000036C8 944B                       		sub.w	a3,d2				; Check above the sensor
000036CA 6100                       		bsr.s	Level_FindFloor2		; Try to find a solid block there
000036CC D44B                       		add.w	a3,d2				; Restore Y position of sensor
000036CE 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
000036D2 4E75                       		rts
000036D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036D4                            Level_FindFloor2:
000036D4 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
000036D8 3011                       		move.w	(a1),d0				; Get block ID
000036DA 3800                       		move.w	d0,d4				; Copy that
000036DC 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
000036E0 6700                       		beq.s	.IsBlank			; If it's blank, branch
000036E2 0B04                       		btst	d5,d4				; Is the block solid?
000036E4 6600                       		bne.s	.IsSolid			; If so, branch
000036E6                            
000036E6                            .IsBlank:
000036E6 323C 000F                  		move.w	#$F,d1				; Get max distance
000036EA 3002                       		move.w	d2,d0				; Get the object's Y position
000036EC 0240 000F                  		andi.w	#$F,d0				; Get the Y offset in the height
000036F0 9240                       		sub.w	d0,d1				; Get actual distance
000036F2 4E75                       		rts
000036F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036F4                            .IsSolid:
000036F4 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
000036F8 D040                       		add.w	d0,d0				; Turn ID into offset
000036FA 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000036FE 0240 00FF                  		andi.w	#$FF,d0				; ''
00003702 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003704                            
00003704 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003708 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
0000370C E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
0000370E                            
0000370E 3203                       		move.w	d3,d1				; Get the object's X position
00003710 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003714 6700                       		beq.s	.NoXFlip			; If not, branch
00003716 4641                       		not.w	d1				; Flip the X position
00003718 4414                       		neg.b	(a4)				; Flip the angle
0000371A                            
0000371A                            .NoXFlip:
0000371A 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000371E 6700                       		beq.s	.NoYFlip			; If not, branch
00003720 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003724 4414                       		neg.b	(a4)				; ''
00003726 0414 0040                  		subi.b	#$40,(a4)			; ''
0000372A                            
0000372A                            .NoYFlip:
0000372A 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
0000372E D240                       		add.w	d0,d1				; Add the collision block's offset
00003730                            
00003730 2478 E8F4                  		movea.l	normColArrayPtr.w,a2		; Get the normal collision array
00003734 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003738 4880                       		ext.w	d0				; ''
0000373A BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
0000373C 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003740 6700                       		beq.s	.NoYFlip2			; If not, branch
00003742 4440                       		neg.w	d0				; Flip the height
00003744                            
00003744                            .NoYFlip2:
00003744 4A40                       		tst.w	d0				; Check the height
00003746 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003748 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
0000374A 3202                       		move.w	d2,d1				; Get the object's Y position
0000374C 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003750 D041                       		add.w	d1,d0				; Add onto the height
00003752 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003756 9240                       		sub.w	d0,d1				; ''
00003758 4E75                       		rts
0000375A                            
0000375A                            .NegHeight:
0000375A 3202                       		move.w	d2,d1				; Get the object's Y position
0000375C 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003760 D041                       		add.w	d1,d0				; Add onto the height
00003762 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003766 4641                       		not.w	d1				; Flip the height
00003768 4E75                       		rts
0000376A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000376A                            ; Find the nearest wall from the object's position
0000376A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000376A                            ; PARAMETERS:
0000376A                            ;	d2.w	- Y position of the object's bottom sensor
0000376A                            ;	d3.w	- X position of the object's bottom sensor
0000376A                            ;	d5.w	- Bit to chect for solidity
0000376A                            ;	d6.w	- Flip bits (for walls and ceilings)
0000376A                            ;	a3.w	- Distance in pixels to check for blocks left of or right of the sensor
0000376A                            ;	a4.w	- Pointer to where the angle value will be stored
0000376A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000376A                            ; RETURNS:
0000376A                            ;	d1.w	- The distance from the object to the floor
0000376A                            ;	(a1).w	- The block ID in the chunk where the object is standing
0000376A                            ;	(a4).w	- The floor angle
0000376A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000376A                            Level_FindWall:
0000376A 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
0000376E 3011                       		move.w	(a1),d0				; Get block ID
00003770 3800                       		move.w	d0,d4				; Copy that
00003772 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003776 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003778 0B04                       		btst	d5,d4				; Is the block solid?
0000377A 6600                       		bne.s	.IsSolid			; If so, branch
0000377C                            
0000377C                            .IsBlank:
0000377C D64B                       		add.w	a3,d3				; Check right to the sensor
0000377E 6100 0000                  		bsr.w	Level_FindWall2			; Try to find a solid block there
00003782 964B                       		sub.w	a3,d3				; Restore X position of sensor
00003784 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003788 4E75                       		rts
0000378A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000378A                            .IsSolid:
0000378A 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
0000378E D040                       		add.w	d0,d0				; Turn ID into offset
00003790 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003794 0240 00FF                  		andi.w	#$FF,d0				; ''
00003798 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
0000379A                            
0000379A 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
0000379E 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
000037A2 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
000037A4                            
000037A4 3202                       		move.w	d2,d1				; Get the object's Y position
000037A6 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000037AA 6700                       		beq.s	.NoYFlip			; If not, branch
000037AC 4641                       		not.w	d1				; Flip the Y position
000037AE 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
000037B2 4414                       		neg.b	(a4)				; ''
000037B4 0414 0040                  		subi.b	#$40,(a4)			; ''
000037B8                            
000037B8                            .NoYFlip:
000037B8 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
000037BC 6700                       		beq.s	.NoXFlip			; If not, branch
000037BE 4414                       		neg.b	(a4)				; Flip the angle
000037C0                            
000037C0                            .NoXFlip:
000037C0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
000037C4 D240                       		add.w	d0,d1				; Add the collision block's offset
000037C6                            
000037C6 2478 E8F8                  		movea.l	rotColArrayPtr.w,a2		; Get the normal collision array
000037CA 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
000037CE 4880                       		ext.w	d0				; ''
000037D0 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
000037D2 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
000037D6 6700                       		beq.s	.NoYFlip2			; If not, branch
000037D8 4440                       		neg.w	d0				; Flip the height
000037DA                            
000037DA                            .NoYFlip2:
000037DA 4A40                       		tst.w	d0				; Check the height
000037DC 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000037DE 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000037E0 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
000037E4 6700                       		beq.s	.MaxFloor			; If so, branch
000037E6 3203                       		move.w	d3,d1				; Get the object's X position
000037E8 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000037EC D041                       		add.w	d1,d0				; Add onto the height
000037EE 323C 000F                  		move.w	#$F,d1				; Get actual distance
000037F2 9240                       		sub.w	d0,d1				; ''
000037F4 4E75                       		rts
000037F6                            
000037F6                            .NegHeight:
000037F6 3203                       		move.w	d3,d1				; Get the object's X position
000037F8 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000037FC D041                       		add.w	d1,d0				; Add onto the height
000037FE 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003802                            
00003802                            .MaxFloor:
00003802 964B                       		sub.w	a3,d3				; Check left to the sensor
00003804 6100                       		bsr.s	Level_FindWall2			; Try to find a solid block there
00003806 D64B                       		add.w	a3,d3				; Restore X position of sensor
00003808 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
0000380C 4E75                       		rts
0000380E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000380E                            Level_FindWall2:
0000380E 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003812 3011                       		move.w	(a1),d0				; Get block ID
00003814 3800                       		move.w	d0,d4				; Copy that
00003816 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
0000381A 6700                       		beq.s	.IsBlank			; If it's blank, branch
0000381C 0B04                       		btst	d5,d4				; Is the block solid?
0000381E 6600                       		bne.s	.IsSolid			; If so, branch
00003820                            
00003820                            .IsBlank:
00003820 323C 000F                  		move.w	#$F,d1				; Get max distance
00003824 3003                       		move.w	d3,d0				; Get the object's X position
00003826 0240 000F                  		andi.w	#$F,d0				; Get the X offset in the height
0000382A 9240                       		sub.w	d0,d1				; Get actual distance
0000382C 4E75                       		rts
0000382E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000382E                            .IsSolid:
0000382E 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003832 D040                       		add.w	d0,d0				; Turn ID into offset
00003834 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003838 0240 00FF                  		andi.w	#$FF,d0				; ''
0000383C 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
0000383E                            
0000383E 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003842 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003846 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003848                            
00003848 3202                       		move.w	d2,d1				; Get the object's Y position
0000384A 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000384E 6700                       		beq.s	.NoYFlip			; If not, branch
00003850 4641                       		not.w	d1				; Flip the Y position
00003852 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003856 4414                       		neg.b	(a4)				; ''
00003858 0414 0040                  		subi.b	#$40,(a4)			; ''
0000385C                            
0000385C                            .NoYFlip:
0000385C 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003860 6700                       		beq.s	.NoXFlip			; If not, branch
00003862 4414                       		neg.b	(a4)				; Flip the angle
00003864                            
00003864                            .NoXFlip:
00003864 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003868 D240                       		add.w	d0,d1				; Add the collision block's offset
0000386A                            
0000386A 2478 E8F8                  		movea.l	rotColArrayPtr.w,a2		; Get the normal collision array
0000386E 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003872 4880                       		ext.w	d0				; ''
00003874 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003876 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
0000387A 6700                       		beq.s	.NoYFlip2			; If not, branch
0000387C 4440                       		neg.w	d0				; Flip the height
0000387E                            
0000387E                            .NoYFlip2:
0000387E 4A40                       		tst.w	d0				; Check the height
00003880 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003882 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003884 3203                       		move.w	d3,d1				; Get the object's X position
00003886 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
0000388A D041                       		add.w	d1,d0				; Add onto the height
0000388C 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003890 9240                       		sub.w	d0,d1				; ''
00003892 4E75                       		rts
00003894                            
00003894                            .NegHeight:
00003894 3203                       		move.w	d3,d1				; Get the object's X position
00003896 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
0000389A D041                       		add.w	d1,d0				; Add onto the height
0000389C 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000038A0 4641                       		not.w	d1				; Flip the height
000038A2 4E75                       		rts
000038A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000038A4                            ; Find the nearest block in the level from the player
000038A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000038A4                            ; PARAMETERS:
000038A4                            ;	d2.w	- Y position of the object's sensor
000038A4                            ;	d3.w	- X position of the object's sensor
000038A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000038A4                            ; RETURNS:
000038A4                            ;	(a1).w	- The block ID in the chunk where the object is standing
000038A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000038A4                            Level_FindBlock:
000038A4 2278 E856                  		movea.l	lvlLayout.w,a1			; Get level layout pointer address
000038A8                            
000038A8 3002                       		move.w	d2,d0				; Get the object's Y position
000038AA 0240 0780                  		andi.w	#$780,d0			; Get Y within layout data
000038AE EC48                       		lsr.w	#6,d0				; ''						
000038B0 3031 0002                  		move.w	2(a1,d0.w),d0			; Get chunk row offset
000038B4                            		
000038B4 3203                       		move.w	d3,d1				; Get the object's X position
000038B6 E649                       		lsr.w	#3,d1				; Divide by 8
000038B8 3801                       		move.w	d1,d4				; Save for later
000038BA                            		
000038BA E849                       		lsr.w	#4,d1				; Divide by 16 to get the offset of the chunk in the chunk row
000038BC 0241 00FF                  		andi.w	#$FF,d1				; Only 256 chunks per row
000038C0 D041                       		add.w	d1,d0				; Get offset in the level layout
000038C2                            
000038C2 72FF                       		moveq	#-1,d1				; Prepare the chunk table pointer
000038C4 4241                       		clr.w	d1				; ''
000038C6                            		
000038C6 1231 0000                  		move.b	(a1,d0.w),d1			; Get chunk ID
000038CA D241                       		add.w	d1,d1				; Turn into offset
000038CC 323B 1000                  		move.w	.ChunkOffsets(pc,d1.w),d1	; Get offset in chunk table
000038D0 3002                       		move.w	d2,d0				; Get the object's Y position
000038D2                            		
000038D2 0240 0070                  		andi.w	#$70,d0				; Get Y position within chunk
000038D6 D240                       		add.w	d0,d1				; Add onto the offset
000038D8 0244 000E                  		andi.w	#$E,d4				; Get the previously saved X position divided by 8 (for the row offset)
000038DC D244                       		add.w	d4,d1				; Add onto the offset
000038DE                            		
000038DE 2241                       		movea.l	d1,a1				; Get pointer in chunk table
000038E0 4E75                       		rts
000038E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000038E2                            .ChunkOffsets:
000038E2 =00000000                  c		= 0
000038E2                            		rept	256
000038E2                            			dc.w	c
000038E2                            c			= c+$80
000038E2                            		endr
000038E2 0000                     M 	dc.w	c
000038E4 =00000080                M c	=	c+$80
000038E4 0080                     M 	dc.w	c
000038E6 =00000100                M c	=	c+$80
000038E6 0100                     M 	dc.w	c
000038E8 =00000180                M c	=	c+$80
000038E8 0180                     M 	dc.w	c
000038EA =00000200                M c	=	c+$80
000038EA 0200                     M 	dc.w	c
000038EC =00000280                M c	=	c+$80
000038EC 0280                     M 	dc.w	c
000038EE =00000300                M c	=	c+$80
000038EE 0300                     M 	dc.w	c
000038F0 =00000380                M c	=	c+$80
000038F0 0380                     M 	dc.w	c
000038F2 =00000400                M c	=	c+$80
000038F2 0400                     M 	dc.w	c
000038F4 =00000480                M c	=	c+$80
000038F4 0480                     M 	dc.w	c
000038F6 =00000500                M c	=	c+$80
000038F6 0500                     M 	dc.w	c
000038F8 =00000580                M c	=	c+$80
000038F8 0580                     M 	dc.w	c
000038FA =00000600                M c	=	c+$80
000038FA 0600                     M 	dc.w	c
000038FC =00000680                M c	=	c+$80
000038FC 0680                     M 	dc.w	c
000038FE =00000700                M c	=	c+$80
000038FE 0700                     M 	dc.w	c
00003900 =00000780                M c	=	c+$80
00003900 0780                     M 	dc.w	c
00003902 =00000800                M c	=	c+$80
00003902 0800                     M 	dc.w	c
00003904 =00000880                M c	=	c+$80
00003904 0880                     M 	dc.w	c
00003906 =00000900                M c	=	c+$80
00003906 0900                     M 	dc.w	c
00003908 =00000980                M c	=	c+$80
00003908 0980                     M 	dc.w	c
0000390A =00000A00                M c	=	c+$80
0000390A 0A00                     M 	dc.w	c
0000390C =00000A80                M c	=	c+$80
0000390C 0A80                     M 	dc.w	c
0000390E =00000B00                M c	=	c+$80
0000390E 0B00                     M 	dc.w	c
00003910 =00000B80                M c	=	c+$80
00003910 0B80                     M 	dc.w	c
00003912 =00000C00                M c	=	c+$80
00003912 0C00                     M 	dc.w	c
00003914 =00000C80                M c	=	c+$80
00003914 0C80                     M 	dc.w	c
00003916 =00000D00                M c	=	c+$80
00003916 0D00                     M 	dc.w	c
00003918 =00000D80                M c	=	c+$80
00003918 0D80                     M 	dc.w	c
0000391A =00000E00                M c	=	c+$80
0000391A 0E00                     M 	dc.w	c
0000391C =00000E80                M c	=	c+$80
0000391C 0E80                     M 	dc.w	c
0000391E =00000F00                M c	=	c+$80
0000391E 0F00                     M 	dc.w	c
00003920 =00000F80                M c	=	c+$80
00003920 0F80                     M 	dc.w	c
00003922 =00001000                M c	=	c+$80
00003922 1000                     M 	dc.w	c
00003924 =00001080                M c	=	c+$80
00003924 1080                     M 	dc.w	c
00003926 =00001100                M c	=	c+$80
00003926 1100                     M 	dc.w	c
00003928 =00001180                M c	=	c+$80
00003928 1180                     M 	dc.w	c
0000392A =00001200                M c	=	c+$80
0000392A 1200                     M 	dc.w	c
0000392C =00001280                M c	=	c+$80
0000392C 1280                     M 	dc.w	c
0000392E =00001300                M c	=	c+$80
0000392E 1300                     M 	dc.w	c
00003930 =00001380                M c	=	c+$80
00003930 1380                     M 	dc.w	c
00003932 =00001400                M c	=	c+$80
00003932 1400                     M 	dc.w	c
00003934 =00001480                M c	=	c+$80
00003934 1480                     M 	dc.w	c
00003936 =00001500                M c	=	c+$80
00003936 1500                     M 	dc.w	c
00003938 =00001580                M c	=	c+$80
00003938 1580                     M 	dc.w	c
0000393A =00001600                M c	=	c+$80
0000393A 1600                     M 	dc.w	c
0000393C =00001680                M c	=	c+$80
0000393C 1680                     M 	dc.w	c
0000393E =00001700                M c	=	c+$80
0000393E 1700                     M 	dc.w	c
00003940 =00001780                M c	=	c+$80
00003940 1780                     M 	dc.w	c
00003942 =00001800                M c	=	c+$80
00003942 1800                     M 	dc.w	c
00003944 =00001880                M c	=	c+$80
00003944 1880                     M 	dc.w	c
00003946 =00001900                M c	=	c+$80
00003946 1900                     M 	dc.w	c
00003948 =00001980                M c	=	c+$80
00003948 1980                     M 	dc.w	c
0000394A =00001A00                M c	=	c+$80
0000394A 1A00                     M 	dc.w	c
0000394C =00001A80                M c	=	c+$80
0000394C 1A80                     M 	dc.w	c
0000394E =00001B00                M c	=	c+$80
0000394E 1B00                     M 	dc.w	c
00003950 =00001B80                M c	=	c+$80
00003950 1B80                     M 	dc.w	c
00003952 =00001C00                M c	=	c+$80
00003952 1C00                     M 	dc.w	c
00003954 =00001C80                M c	=	c+$80
00003954 1C80                     M 	dc.w	c
00003956 =00001D00                M c	=	c+$80
00003956 1D00                     M 	dc.w	c
00003958 =00001D80                M c	=	c+$80
00003958 1D80                     M 	dc.w	c
0000395A =00001E00                M c	=	c+$80
0000395A 1E00                     M 	dc.w	c
0000395C =00001E80                M c	=	c+$80
0000395C 1E80                     M 	dc.w	c
0000395E =00001F00                M c	=	c+$80
0000395E 1F00                     M 	dc.w	c
00003960 =00001F80                M c	=	c+$80
00003960 1F80                     M 	dc.w	c
00003962 =00002000                M c	=	c+$80
00003962 2000                     M 	dc.w	c
00003964 =00002080                M c	=	c+$80
00003964 2080                     M 	dc.w	c
00003966 =00002100                M c	=	c+$80
00003966 2100                     M 	dc.w	c
00003968 =00002180                M c	=	c+$80
00003968 2180                     M 	dc.w	c
0000396A =00002200                M c	=	c+$80
0000396A 2200                     M 	dc.w	c
0000396C =00002280                M c	=	c+$80
0000396C 2280                     M 	dc.w	c
0000396E =00002300                M c	=	c+$80
0000396E 2300                     M 	dc.w	c
00003970 =00002380                M c	=	c+$80
00003970 2380                     M 	dc.w	c
00003972 =00002400                M c	=	c+$80
00003972 2400                     M 	dc.w	c
00003974 =00002480                M c	=	c+$80
00003974 2480                     M 	dc.w	c
00003976 =00002500                M c	=	c+$80
00003976 2500                     M 	dc.w	c
00003978 =00002580                M c	=	c+$80
00003978 2580                     M 	dc.w	c
0000397A =00002600                M c	=	c+$80
0000397A 2600                     M 	dc.w	c
0000397C =00002680                M c	=	c+$80
0000397C 2680                     M 	dc.w	c
0000397E =00002700                M c	=	c+$80
0000397E 2700                     M 	dc.w	c
00003980 =00002780                M c	=	c+$80
00003980 2780                     M 	dc.w	c
00003982 =00002800                M c	=	c+$80
00003982 2800                     M 	dc.w	c
00003984 =00002880                M c	=	c+$80
00003984 2880                     M 	dc.w	c
00003986 =00002900                M c	=	c+$80
00003986 2900                     M 	dc.w	c
00003988 =00002980                M c	=	c+$80
00003988 2980                     M 	dc.w	c
0000398A =00002A00                M c	=	c+$80
0000398A 2A00                     M 	dc.w	c
0000398C =00002A80                M c	=	c+$80
0000398C 2A80                     M 	dc.w	c
0000398E =00002B00                M c	=	c+$80
0000398E 2B00                     M 	dc.w	c
00003990 =00002B80                M c	=	c+$80
00003990 2B80                     M 	dc.w	c
00003992 =00002C00                M c	=	c+$80
00003992 2C00                     M 	dc.w	c
00003994 =00002C80                M c	=	c+$80
00003994 2C80                     M 	dc.w	c
00003996 =00002D00                M c	=	c+$80
00003996 2D00                     M 	dc.w	c
00003998 =00002D80                M c	=	c+$80
00003998 2D80                     M 	dc.w	c
0000399A =00002E00                M c	=	c+$80
0000399A 2E00                     M 	dc.w	c
0000399C =00002E80                M c	=	c+$80
0000399C 2E80                     M 	dc.w	c
0000399E =00002F00                M c	=	c+$80
0000399E 2F00                     M 	dc.w	c
000039A0 =00002F80                M c	=	c+$80
000039A0 2F80                     M 	dc.w	c
000039A2 =00003000                M c	=	c+$80
000039A2 3000                     M 	dc.w	c
000039A4 =00003080                M c	=	c+$80
000039A4 3080                     M 	dc.w	c
000039A6 =00003100                M c	=	c+$80
000039A6 3100                     M 	dc.w	c
000039A8 =00003180                M c	=	c+$80
000039A8 3180                     M 	dc.w	c
000039AA =00003200                M c	=	c+$80
000039AA 3200                     M 	dc.w	c
000039AC =00003280                M c	=	c+$80
000039AC 3280                     M 	dc.w	c
000039AE =00003300                M c	=	c+$80
000039AE 3300                     M 	dc.w	c
000039B0 =00003380                M c	=	c+$80
000039B0 3380                     M 	dc.w	c
000039B2 =00003400                M c	=	c+$80
000039B2 3400                     M 	dc.w	c
000039B4 =00003480                M c	=	c+$80
000039B4 3480                     M 	dc.w	c
000039B6 =00003500                M c	=	c+$80
000039B6 3500                     M 	dc.w	c
000039B8 =00003580                M c	=	c+$80
000039B8 3580                     M 	dc.w	c
000039BA =00003600                M c	=	c+$80
000039BA 3600                     M 	dc.w	c
000039BC =00003680                M c	=	c+$80
000039BC 3680                     M 	dc.w	c
000039BE =00003700                M c	=	c+$80
000039BE 3700                     M 	dc.w	c
000039C0 =00003780                M c	=	c+$80
000039C0 3780                     M 	dc.w	c
000039C2 =00003800                M c	=	c+$80
000039C2 3800                     M 	dc.w	c
000039C4 =00003880                M c	=	c+$80
000039C4 3880                     M 	dc.w	c
000039C6 =00003900                M c	=	c+$80
000039C6 3900                     M 	dc.w	c
000039C8 =00003980                M c	=	c+$80
000039C8 3980                     M 	dc.w	c
000039CA =00003A00                M c	=	c+$80
000039CA 3A00                     M 	dc.w	c
000039CC =00003A80                M c	=	c+$80
000039CC 3A80                     M 	dc.w	c
000039CE =00003B00                M c	=	c+$80
000039CE 3B00                     M 	dc.w	c
000039D0 =00003B80                M c	=	c+$80
000039D0 3B80                     M 	dc.w	c
000039D2 =00003C00                M c	=	c+$80
000039D2 3C00                     M 	dc.w	c
000039D4 =00003C80                M c	=	c+$80
000039D4 3C80                     M 	dc.w	c
000039D6 =00003D00                M c	=	c+$80
000039D6 3D00                     M 	dc.w	c
000039D8 =00003D80                M c	=	c+$80
000039D8 3D80                     M 	dc.w	c
000039DA =00003E00                M c	=	c+$80
000039DA 3E00                     M 	dc.w	c
000039DC =00003E80                M c	=	c+$80
000039DC 3E80                     M 	dc.w	c
000039DE =00003F00                M c	=	c+$80
000039DE 3F00                     M 	dc.w	c
000039E0 =00003F80                M c	=	c+$80
000039E0 3F80                     M 	dc.w	c
000039E2 =00004000                M c	=	c+$80
000039E2 4000                     M 	dc.w	c
000039E4 =00004080                M c	=	c+$80
000039E4 4080                     M 	dc.w	c
000039E6 =00004100                M c	=	c+$80
000039E6 4100                     M 	dc.w	c
000039E8 =00004180                M c	=	c+$80
000039E8 4180                     M 	dc.w	c
000039EA =00004200                M c	=	c+$80
000039EA 4200                     M 	dc.w	c
000039EC =00004280                M c	=	c+$80
000039EC 4280                     M 	dc.w	c
000039EE =00004300                M c	=	c+$80
000039EE 4300                     M 	dc.w	c
000039F0 =00004380                M c	=	c+$80
000039F0 4380                     M 	dc.w	c
000039F2 =00004400                M c	=	c+$80
000039F2 4400                     M 	dc.w	c
000039F4 =00004480                M c	=	c+$80
000039F4 4480                     M 	dc.w	c
000039F6 =00004500                M c	=	c+$80
000039F6 4500                     M 	dc.w	c
000039F8 =00004580                M c	=	c+$80
000039F8 4580                     M 	dc.w	c
000039FA =00004600                M c	=	c+$80
000039FA 4600                     M 	dc.w	c
000039FC =00004680                M c	=	c+$80
000039FC 4680                     M 	dc.w	c
000039FE =00004700                M c	=	c+$80
000039FE 4700                     M 	dc.w	c
00003A00 =00004780                M c	=	c+$80
00003A00 4780                     M 	dc.w	c
00003A02 =00004800                M c	=	c+$80
00003A02 4800                     M 	dc.w	c
00003A04 =00004880                M c	=	c+$80
00003A04 4880                     M 	dc.w	c
00003A06 =00004900                M c	=	c+$80
00003A06 4900                     M 	dc.w	c
00003A08 =00004980                M c	=	c+$80
00003A08 4980                     M 	dc.w	c
00003A0A =00004A00                M c	=	c+$80
00003A0A 4A00                     M 	dc.w	c
00003A0C =00004A80                M c	=	c+$80
00003A0C 4A80                     M 	dc.w	c
00003A0E =00004B00                M c	=	c+$80
00003A0E 4B00                     M 	dc.w	c
00003A10 =00004B80                M c	=	c+$80
00003A10 4B80                     M 	dc.w	c
00003A12 =00004C00                M c	=	c+$80
00003A12 4C00                     M 	dc.w	c
00003A14 =00004C80                M c	=	c+$80
00003A14 4C80                     M 	dc.w	c
00003A16 =00004D00                M c	=	c+$80
00003A16 4D00                     M 	dc.w	c
00003A18 =00004D80                M c	=	c+$80
00003A18 4D80                     M 	dc.w	c
00003A1A =00004E00                M c	=	c+$80
00003A1A 4E00                     M 	dc.w	c
00003A1C =00004E80                M c	=	c+$80
00003A1C 4E80                     M 	dc.w	c
00003A1E =00004F00                M c	=	c+$80
00003A1E 4F00                     M 	dc.w	c
00003A20 =00004F80                M c	=	c+$80
00003A20 4F80                     M 	dc.w	c
00003A22 =00005000                M c	=	c+$80
00003A22 5000                     M 	dc.w	c
00003A24 =00005080                M c	=	c+$80
00003A24 5080                     M 	dc.w	c
00003A26 =00005100                M c	=	c+$80
00003A26 5100                     M 	dc.w	c
00003A28 =00005180                M c	=	c+$80
00003A28 5180                     M 	dc.w	c
00003A2A =00005200                M c	=	c+$80
00003A2A 5200                     M 	dc.w	c
00003A2C =00005280                M c	=	c+$80
00003A2C 5280                     M 	dc.w	c
00003A2E =00005300                M c	=	c+$80
00003A2E 5300                     M 	dc.w	c
00003A30 =00005380                M c	=	c+$80
00003A30 5380                     M 	dc.w	c
00003A32 =00005400                M c	=	c+$80
00003A32 5400                     M 	dc.w	c
00003A34 =00005480                M c	=	c+$80
00003A34 5480                     M 	dc.w	c
00003A36 =00005500                M c	=	c+$80
00003A36 5500                     M 	dc.w	c
00003A38 =00005580                M c	=	c+$80
00003A38 5580                     M 	dc.w	c
00003A3A =00005600                M c	=	c+$80
00003A3A 5600                     M 	dc.w	c
00003A3C =00005680                M c	=	c+$80
00003A3C 5680                     M 	dc.w	c
00003A3E =00005700                M c	=	c+$80
00003A3E 5700                     M 	dc.w	c
00003A40 =00005780                M c	=	c+$80
00003A40 5780                     M 	dc.w	c
00003A42 =00005800                M c	=	c+$80
00003A42 5800                     M 	dc.w	c
00003A44 =00005880                M c	=	c+$80
00003A44 5880                     M 	dc.w	c
00003A46 =00005900                M c	=	c+$80
00003A46 5900                     M 	dc.w	c
00003A48 =00005980                M c	=	c+$80
00003A48 5980                     M 	dc.w	c
00003A4A =00005A00                M c	=	c+$80
00003A4A 5A00                     M 	dc.w	c
00003A4C =00005A80                M c	=	c+$80
00003A4C 5A80                     M 	dc.w	c
00003A4E =00005B00                M c	=	c+$80
00003A4E 5B00                     M 	dc.w	c
00003A50 =00005B80                M c	=	c+$80
00003A50 5B80                     M 	dc.w	c
00003A52 =00005C00                M c	=	c+$80
00003A52 5C00                     M 	dc.w	c
00003A54 =00005C80                M c	=	c+$80
00003A54 5C80                     M 	dc.w	c
00003A56 =00005D00                M c	=	c+$80
00003A56 5D00                     M 	dc.w	c
00003A58 =00005D80                M c	=	c+$80
00003A58 5D80                     M 	dc.w	c
00003A5A =00005E00                M c	=	c+$80
00003A5A 5E00                     M 	dc.w	c
00003A5C =00005E80                M c	=	c+$80
00003A5C 5E80                     M 	dc.w	c
00003A5E =00005F00                M c	=	c+$80
00003A5E 5F00                     M 	dc.w	c
00003A60 =00005F80                M c	=	c+$80
00003A60 5F80                     M 	dc.w	c
00003A62 =00006000                M c	=	c+$80
00003A62 6000                     M 	dc.w	c
00003A64 =00006080                M c	=	c+$80
00003A64 6080                     M 	dc.w	c
00003A66 =00006100                M c	=	c+$80
00003A66 6100                     M 	dc.w	c
00003A68 =00006180                M c	=	c+$80
00003A68 6180                     M 	dc.w	c
00003A6A =00006200                M c	=	c+$80
00003A6A 6200                     M 	dc.w	c
00003A6C =00006280                M c	=	c+$80
00003A6C 6280                     M 	dc.w	c
00003A6E =00006300                M c	=	c+$80
00003A6E 6300                     M 	dc.w	c
00003A70 =00006380                M c	=	c+$80
00003A70 6380                     M 	dc.w	c
00003A72 =00006400                M c	=	c+$80
00003A72 6400                     M 	dc.w	c
00003A74 =00006480                M c	=	c+$80
00003A74 6480                     M 	dc.w	c
00003A76 =00006500                M c	=	c+$80
00003A76 6500                     M 	dc.w	c
00003A78 =00006580                M c	=	c+$80
00003A78 6580                     M 	dc.w	c
00003A7A =00006600                M c	=	c+$80
00003A7A 6600                     M 	dc.w	c
00003A7C =00006680                M c	=	c+$80
00003A7C 6680                     M 	dc.w	c
00003A7E =00006700                M c	=	c+$80
00003A7E 6700                     M 	dc.w	c
00003A80 =00006780                M c	=	c+$80
00003A80 6780                     M 	dc.w	c
00003A82 =00006800                M c	=	c+$80
00003A82 6800                     M 	dc.w	c
00003A84 =00006880                M c	=	c+$80
00003A84 6880                     M 	dc.w	c
00003A86 =00006900                M c	=	c+$80
00003A86 6900                     M 	dc.w	c
00003A88 =00006980                M c	=	c+$80
00003A88 6980                     M 	dc.w	c
00003A8A =00006A00                M c	=	c+$80
00003A8A 6A00                     M 	dc.w	c
00003A8C =00006A80                M c	=	c+$80
00003A8C 6A80                     M 	dc.w	c
00003A8E =00006B00                M c	=	c+$80
00003A8E 6B00                     M 	dc.w	c
00003A90 =00006B80                M c	=	c+$80
00003A90 6B80                     M 	dc.w	c
00003A92 =00006C00                M c	=	c+$80
00003A92 6C00                     M 	dc.w	c
00003A94 =00006C80                M c	=	c+$80
00003A94 6C80                     M 	dc.w	c
00003A96 =00006D00                M c	=	c+$80
00003A96 6D00                     M 	dc.w	c
00003A98 =00006D80                M c	=	c+$80
00003A98 6D80                     M 	dc.w	c
00003A9A =00006E00                M c	=	c+$80
00003A9A 6E00                     M 	dc.w	c
00003A9C =00006E80                M c	=	c+$80
00003A9C 6E80                     M 	dc.w	c
00003A9E =00006F00                M c	=	c+$80
00003A9E 6F00                     M 	dc.w	c
00003AA0 =00006F80                M c	=	c+$80
00003AA0 6F80                     M 	dc.w	c
00003AA2 =00007000                M c	=	c+$80
00003AA2 7000                     M 	dc.w	c
00003AA4 =00007080                M c	=	c+$80
00003AA4 7080                     M 	dc.w	c
00003AA6 =00007100                M c	=	c+$80
00003AA6 7100                     M 	dc.w	c
00003AA8 =00007180                M c	=	c+$80
00003AA8 7180                     M 	dc.w	c
00003AAA =00007200                M c	=	c+$80
00003AAA 7200                     M 	dc.w	c
00003AAC =00007280                M c	=	c+$80
00003AAC 7280                     M 	dc.w	c
00003AAE =00007300                M c	=	c+$80
00003AAE 7300                     M 	dc.w	c
00003AB0 =00007380                M c	=	c+$80
00003AB0 7380                     M 	dc.w	c
00003AB2 =00007400                M c	=	c+$80
00003AB2 7400                     M 	dc.w	c
00003AB4 =00007480                M c	=	c+$80
00003AB4 7480                     M 	dc.w	c
00003AB6 =00007500                M c	=	c+$80
00003AB6 7500                     M 	dc.w	c
00003AB8 =00007580                M c	=	c+$80
00003AB8 7580                     M 	dc.w	c
00003ABA =00007600                M c	=	c+$80
00003ABA 7600                     M 	dc.w	c
00003ABC =00007680                M c	=	c+$80
00003ABC 7680                     M 	dc.w	c
00003ABE =00007700                M c	=	c+$80
00003ABE 7700                     M 	dc.w	c
00003AC0 =00007780                M c	=	c+$80
00003AC0 7780                     M 	dc.w	c
00003AC2 =00007800                M c	=	c+$80
00003AC2 7800                     M 	dc.w	c
00003AC4 =00007880                M c	=	c+$80
00003AC4 7880                     M 	dc.w	c
00003AC6 =00007900                M c	=	c+$80
00003AC6 7900                     M 	dc.w	c
00003AC8 =00007980                M c	=	c+$80
00003AC8 7980                     M 	dc.w	c
00003ACA =00007A00                M c	=	c+$80
00003ACA 7A00                     M 	dc.w	c
00003ACC =00007A80                M c	=	c+$80
00003ACC 7A80                     M 	dc.w	c
00003ACE =00007B00                M c	=	c+$80
00003ACE 7B00                     M 	dc.w	c
00003AD0 =00007B80                M c	=	c+$80
00003AD0 7B80                     M 	dc.w	c
00003AD2 =00007C00                M c	=	c+$80
00003AD2 7C00                     M 	dc.w	c
00003AD4 =00007C80                M c	=	c+$80
00003AD4 7C80                     M 	dc.w	c
00003AD6 =00007D00                M c	=	c+$80
00003AD6 7D00                     M 	dc.w	c
00003AD8 =00007D80                M c	=	c+$80
00003AD8 7D80                     M 	dc.w	c
00003ADA =00007E00                M c	=	c+$80
00003ADA 7E00                     M 	dc.w	c
00003ADC =00007E80                M c	=	c+$80
00003ADC 7E80                     M 	dc.w	c
00003ADE =00007F00                M c	=	c+$80
00003ADE 7F00                     M 	dc.w	c
00003AE0 =00007F80                M c	=	c+$80
00003AE0 7F80                     M 	dc.w	c
00003AE2 =00008000                M c	=	c+$80
00003AE2                            ; =========================================================================================================================================================
00003AE2                            		include	"Opmodes/Gameplay/Level Functions.asm"
00003AE2                            ; =========================================================================================================================================================
00003AE2                            ; General level functions
00003AE2                            ; =========================================================================================================================================================
00003AE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AE2                            ; Load level data
00003AE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AE2                            Level_LoadData:
00003AE2                            		; --- Initialize the start position and camera ---
00003AE2                            
00003AE2 47F9 0000 0000             		lea	Level_SizeStartPos,a3		; Get size and start position data
00003AE8 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003AEC E218                       		ror.b	#1,d0				; Turn into offset
00003AEE E848                       		lsr.w	#4,d0				; ''
00003AF0 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003AF4                            
00003AF4 42B8 E8CE                  		clr.l	targetMinCamPos.w		; Set target minimum camera values
00003AF8 42B8 E8D2                  		clr.l	minCamPos.w			; Set minimum camera values
00003AFC 21D3 E8C6                  		move.l	(a3),targetMaxCamPos.w		; Set target maximum camera values
00003B00 21DB E8CA                  		move.l	(a3)+,maxCamPos.w		; Set maximum camera values
00003B04                            
00003B04 31FC 0060 E8D8             		move.w	#(224/2)-16,panCamYPos.w	; Set camera Y distance
00003B0A                            
00003B0A 3078 E876                  		movea.w	playerPtrP1.w,a0		; Player object
00003B0E 321B                       		move.w	(a3)+,d1			; Get starting X position
00003B10 3141 0014                  		move.w	d1,_objXPos(a0)			; Set the player's X position
00003B14 3013                       		move.w	(a3),d0				; Get starting Y position
00003B16 3140 0018                  		move.w	d0,_objYPos(a0)			; Set the player's Y position
00003B1A                            
00003B1A 4A38 C7B7                  		tst.b	rStartFall.w			; Should we start the level by falling?
00003B1E 6700                       		beq.s	.InitCam			; If not, branch
00003B20 08E8 0002 000C             		bset	#2,_objFlags(a0)
00003B26 7272                       		moveq	#$72,d1				; Reset Sonic's X position
00003B28 3141 0014                  		move.w	d1,_objXPos(a0)			; ''
00003B2C 70E0                       		moveq	#-32,d0				; Reset Sonic's Y position
00003B2E 3140 0018                  		move.w	d0,_objYPos(a0)			; ''
00003B32                            
00003B32                            .InitCam:
00003B32 4A38 C7B0                  		tst.b	chkIDLast.w		; Has a checkpoint been hit?
00003B36 6700                       		beq.s	.SetCam				; If not, branch
00003B38 6100 0000                  		bsr.w	Level_LoadSavedInfo		; Load data
00003B3C 3228 0014                  		move.w	_objXPos(a0),d1			; Get X position
00003B40 3028 0018                  		move.w	_objYPos(a0),d0			; Get Y position
00003B44                            
00003B44                            .SetCam:
00003B44 0441 00A0                  		subi.w	#320/2,d1			; Get camera's X position
00003B48 6C00                       		bge.s	.ChkMaxX			; If it doesn't go beyond the left boundary, branch
00003B4A 7200                       		moveq	#0,d1				; Cap it
00003B4C                            
00003B4C                            .ChkMaxX:
00003B4C 3438 E8CA                  		move.w	maxCamXPos.w,d2		; Get max camera X position
00003B50 B242                       		cmp.w	d2,d1				; Have we gone beyond it?
00003B52 6500                       		bcs.s	.SetCamX			; If not, branch
00003B54 3202                       		move.w	d2,d1				; Cap it
00003B56                            
00003B56                            .SetCamX:	
00003B56 31C1 E88A                  		move.w	d1,fgCamXPos.w			; Set the camera's X position
00003B5A                            
00003B5A 0440 0060                  		subi.w	#(224/2)-16,d0			; Get camera's Y position
00003B5E 6C00                       		bge.s	.ChkMaxY			; If it doesn't go beyond the upper boundary, branch
00003B60 7000                       		moveq	#0,d0				; Cap it
00003B62                            
00003B62                            .ChkMaxY:
00003B62 3438 E8CC                  		move.w	maxCamYPos.w,d2		; Get max camera Y position
00003B66 B042                       		cmp.w	d2,d0				; Have we gone beyond it?
00003B68 6D00                       		blt.s	.SetCamY			; If not, branch
00003B6A 3002                       		move.w	d2,d0				; Cap it
00003B6C                            
00003B6C                            .SetCamY:	
00003B6C 31C0 E892                  		move.w	d0,fgCamYPos.w			; Set the camera's Y position
00003B70                            
00003B70                            		; --- Load level data ---
00003B70                            
00003B70 47F9 0000 0000             		lea	Level_DataPointers,a3		; Level data pointers
00003B76 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003B7A E218                       		ror.b	#1,d0				; Turn into offset
00003B7C E448                       		lsr.w	#2,d0				; ''
00003B7E 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003B82                            
00003B82 205B                       		movea.l	(a3)+,a0			; Get chunk data pointer
00003B84 43F9 00FF 0000             		lea	chunkData,a1			; Decompress into chunk table
00003B8A 4EB8 0B06                  		jsr	KosDec.w			; ''
00003B8E                            
00003B8E 205B                       		movea.l	(a3)+,a0			; Get block data pointer
00003B90 43F8 C7D2                  		lea	blockData.w,a1			; Decompress into block table
00003B94 4EB8 0B06                  		jsr	KosDec.w			; ''
00003B98                            
00003B98 225B                       		movea.l	(a3)+,a1			; Get tile data pointer
00003B9A 7400                       		moveq	#0,d2				; Store in the beginning of VRAM
00003B9C 4EB8 0F5C                  		jsr	QueueKosMData.w			; Queue for decompression
00003BA0                            
00003BA0 205B                       		movea.l	(a3)+,a0			; Get palette data pointer
00003BA2 3018                       		move.w	(a0)+,d0			; Size of palette data
00003BA4 4EB8 053A                  		jsr	LoadTargetPal.w			; Load the palette
00003BA8                            
00003BA8 21DB E856                  		move.l	(a3)+,lvlLayoutFG.w		; Move layout addresses to variables
00003BAC 21DB E85A                  		move.l	(a3)+,lvlLayoutBG.w
00003BB0                            
00003BB0 21DB C7B8                  		move.l	(a3)+,objMgrLayout.w		; Set object position data pointer
00003BB4 21DB E868                  		move.l	(a3)+,ringMgrLayout.w		; Set ring position data pointer
00003BB8 265B                       		movea.l	(a3)+,a3			; Get collision data pointers
00003BBA 201B                       		move.l	(a3)+,d0			; Get collision data address
00003BBC 21C0 E8EA                  		move.l	d0,currentColAddr.w			; Set collision address to primary
00003BC0 21C0 E8E2                  		move.l	d0,primaryColPtr.w			; Set primary collision data pointer
00003BC4 5280                       		addq.l	#1,d0				; Increment address for secondary collision
00003BC6 21C0 E8E6                  		move.l	d0,secondaryColPtr.w			; Set secondary collision data pointer
00003BCA 43F8 E8F0                  		lea	angleValPtr.w,a1		; Collision pointers
00003BCE 22DB                       		move.l	(a3)+,(a1)+			; Set angle value array pointer
00003BD0 22DB                       		move.l	(a3)+,(a1)+			; Set normal hiehgt map array pointer
00003BD2 229B                       		move.l	(a3)+,(a1)			; Set rotated hiehgt map array pointer
00003BD4                            
00003BD4 47F9 0000 0000             		lea	Level_PLCs,a3			; Get PLC list pointer
00003BDA 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003BDE E218                       		ror.b	#1,d0				; Turn into offset
00003BE0 EA48                       		lsr.w	#5,d0				; ''
00003BE2 2673 0000                  		movea.l	(a3,d0.w),a3			; Get pointer to the correct pointers
00003BE6 4EF8 0F4C                  		jmp	LoadKosMQueue.w			; Load the PLCs
00003BEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BEA                            ; Update the water surface
00003BEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BEA                            Level_UpdateWaterSurface:
00003BEA 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
00003BEE 6700                       		beq.s	.End				; If not, branch
00003BF0 3238 E88A                  		move.w	fgCamXPos.w,d1			; Get camera X position
00003BF4 0838 0000 E905             		btst	#0,(lvlFrameCnt+1).w		; Are we on an odd frame?
00003BFA 6700                       		beq.s	.SetXPos			; If not, branch
00003BFC 0641 0020                  		addi.w	#$20,d1				; Shift X position
00003C00                            
00003C00                            .SetXPos:
00003C00 3001                       		move.w	d1,d0				; Copy X postion
00003C02 0640 0060                  		addi.w	#$60,d0				; Add surface #1's X position
00003C06 3078 E886                  		movea.w	waterObjPtr1.w,a0
00003C0A 3140 0014                  		move.w	d0,_objXPos(a0)			; Set it
00003C0E 0641 0120                  		addi.w	#$120,d1			; Add surface #2's X position
00003C12 3078 E888                  		movea.w	waterObjPtr2.w,a0
00003C16 3141 0014                  		move.w	d1,_objXPos(a0)			; Set it
00003C1A                            
00003C1A                            .End:
00003C1A 4E75                       		rts
00003C1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C1C                            ; Handle water height
00003C1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C1C                            Level_WaterHeight:
00003C1C 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
00003C20 6700                       		beq.s	.End				; If not, branch
00003C22 6100 0000                  		bsr.w	Level_MoveWater			; Move the water when appropriate
00003C26 4238 E8FF                  		clr.b	waterFullscr.w		; Clear water fullscreen flag
00003C2A                            
00003C2A 7201                       		moveq	#1,d1				; Water movement speed
00003C2C 3038 E902                  		move.w	destWaterYPos.w,d0		; Get destination water level
00003C30 9078 E900                  		sub.w	waterYPos.w,d0		; Is the current water level at that destination?
00003C34 6700                       		beq.s	.ChkOnScr			; If so, branch
00003C36 6400                       		bcc.s	.MoveDown			; If it needs to go down, branch
00003C38 4441                       		neg.w	d1				; Go up
00003C3A                            
00003C3A                            .MoveDown:
00003C3A D378 E900                  		add.w	d1,waterYPos.w		; Move water
00003C3E                            
00003C3E                            .ChkOnScr:
00003C3E 3038 E900                  		move.w	waterYPos.w,d0		; Get water height
00003C42 9078 E892                  		sub.w	fgCamYPos.w,d0			; Get camera's Y position
00003C46 6700                       		beq.s	.Fullscreen			; If they are the same, branch
00003C48 6400                       		bcc.s	.ChkBottom			; If the water height is below the top of the camera, branch
00003C4A                            		
00003C4A                            .Fullscreen:
00003C4A 50F8 E8FF                  		st	waterFullscr.w		; Set water fullscreen flag
00003C4E 50F8 C761                  		st	hIntCntValue.w			; Set H-INT counter to be offscreen
00003C52 4E75                       		rts
00003C54                            
00003C54                            .ChkBottom:
00003C54 0C40 00DF                  		cmpi.w	#224-1,d0			; Is the water below the camera?
00003C58 6500                       		blo.s	.SetCounter			; If not, branch
00003C5A 70FF                       		moveq	#-1,d0				; Set H-INT counter to be offscreen
00003C5C                            
00003C5C                            .SetCounter:
00003C5C 11C0 C761                  		move.b	d0,hIntCntValue.w			; Set H-INT counter
00003C60                            
00003C60                            .End:
00003C60 4E75                       		rts
00003C62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C62                            Level_MoveWater:
00003C62 4E75                       		rts
00003C64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C64                            ; Do level palette cycling
00003C64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C64                            Level_PalCycle:
00003C64 41F9 0000 0000             		lea	Level_PalCycRouts,a0		; Palette cycle routines
00003C6A 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003C6E E218                       		ror.b	#1,d0				; Turn into offset
00003C70 EA48                       		lsr.w	#5,d0				; ''
00003C72 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003C76 4ED0                       		jmp	(a0)				; Jump to it
00003C78                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C78                            ; Do level art animation
00003C78                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C78                            Level_AnimateArt:
00003C78 41F9 0000 0000             		lea	Level_AniArtRouts,a0		; Animated art routines
00003C7E 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003C82 E218                       		ror.b	#1,d0				; Turn into offset
00003C84 EA48                       		lsr.w	#5,d0				; ''
00003C86 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003C8A 4ED0                       		jmp	(a0)				; Jump to it
00003C8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C8C                            ; Do dynamic events
00003C8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C8C                            Level_DynEvents:
00003C8C 41F9 0000 0000             		lea	Level_DynEvenRouts,a0		; Dynamic events routines
00003C92 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003C96 E218                       		ror.b	#1,d0				; Turn into offset
00003C98 EA48                       		lsr.w	#5,d0				; ''
00003C9A 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003C9E 4ED0                       		jmp	(a0)				; Jump to it
00003CA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CA0                            ; Handle the camera
00003CA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CA0                            Level_HandleCamera:
00003CA0 3078 E876                  		movea.w	playerPtrP1.w,a0		; Get player object
00003CA4                            		
00003CA4 4A38 E8DA                  		tst.b	camLockX.w			; Is the camera locked horizontally?
00003CA8 6600                       		bne.s	.ChkY				; If so, branch
00003CAA 43F8 E88A                  		lea	fgCamXPos.w,a1			; Get foreground level variables
00003CAE 6100                       		bsr.s	Level_MoveCameraX		; Move the camera horiozntally
00003CB0                            		
00003CB0                            .ChkY:
00003CB0 4A38 E8DB                  		tst.b	camLockY.w			; Is the camera locked vertically?
00003CB4 6600                       		bne.s	.ChkMaxY			; If not, branch
00003CB6 43F8 E892                  		lea	fgCamYPos.w,a1			; Get foreground level variables
00003CBA 3638 E8D8                  		move.w	panCamYPos.w,d3		; Get camera Y distance
00003CBE 6100 0000                  		bsr.w	Level_MoveCameraY		; Move the camera vertically
00003CC2                            
00003CC2                            .ChkMaxY:
00003CC2 7202                       		moveq	#2,d1				; Target camera scroll speed
00003CC4 3038 E8C8                  		move.w	targetMaxCamY.w,d0		; Get distance between target and actual target max camera Y position
00003CC8 9078 E8CC                  		sub.w	maxCamYPos.w,d0		; ''
00003CCC 6700                       		beq.s	.End				; If it's 0, branch
00003CCE 6400                       		bcc.s	.MoveDown			; If it's positive, branch
00003CD0 3038 E892                  		move.w	fgCamYPos.w,d0			; Get current camera Y position
00003CD4 B078 E8C8                  		cmp.w	targetMaxCamY.w,d0		; Is it past the boundary?
00003CD8 6300                       		bls.s	.ScrollUp			; If not, branch
00003CDA 31C0 E8CC                  		move.w	d0,maxCamYPos.w		; Set max camera Y position
00003CDE 0278 FFFE E8CC             		andi.w	#$FFFE,maxCamYPos.w		; Keep it a multiple of 2
00003CE4                            
00003CE4                            .ScrollUp:
00003CE4 9378 E8CC                  		sub.w	d1,maxCamYPos.w		; Scroll up
00003CE8 50F8 E8DC                  		st	chgCamMaxY.w			; Indicate that the max Y boundary is changing
00003CEC                            
00003CEC                            
00003CEC                            .End:
00003CEC 4E75                       		rts
00003CEE                            
00003CEE                            .MoveDown:
00003CEE 3038 E892                  		move.w	fgCamYPos.w,d0			; Get current camera Y position
00003CF2 5040                       		addq.w	#8,d0				; ''
00003CF4 B078 E8CC                  		cmp.w	maxCamYPos.w,d0		; Is it past the boundary?
00003CF8 6500                       		bcs.s	.ScrollDown			; If not, branch
00003CFA 0828 0001 0028             		btst	#1,_objStatus(a0)		; Is the player in the air?
00003D00 6700                       		beq.s	.ScrollDown			; If not, branch
00003D02 D241                       		add.w	d1,d1				; Scroll down faster
00003D04 D241                       		add.w	d1,d1				; ''
00003D06                            
00003D06                            .ScrollDown:
00003D06 D378 E8CC                  		add.w	d1,maxCamYPos.w		; Scroll down
00003D0A 50F8 E8DC                  		st	chgCamMaxY.w			; Indicate that the max Y boundary is changing
00003D0E 4E75                       		rts
00003D10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D10                            Level_MoveCameraX:
00003D10 3028 0014                  		move.w	_objXPos(a0),d0			; Get the player's X position
00003D14 9051                       		sub.w	(a1),d0				; Get distance from the camera's X position
00003D16 9078 E8D6                  		sub.w	panCamXPos.w,d0		; Subtract center
00003D1A 6D00                       		blt.s	.MoveLeft			; If we are going left, branch
00003D1C 6C00                       		bge.s	.MoveRight			; If we are going right, branch
00003D1E 4E75                       		rts
00003D20                            
00003D20                            .MoveLeft:
00003D20 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the camera moving more than 16 pixels per frame?
00003D24 6E00                       		bgt.s	.ChkLeftBound			; If not, branch
00003D26 303C FFF0                  		move.w	#-16,d0				; Keep the camera from moving too fast
00003D2A                            
00003D2A                            .ChkLeftBound:
00003D2A D051                       		add.w	(a1),d0				; Add back the camera's X position
00003D2C B078 E8D2                  		cmp.w	minCamXPos.w,d0		; Have we gone past the left boundary?
00003D30 6E00                       		bgt.s	.SetCamX			; If not, branch
00003D32 3038 E8D2                  		move.w	minCamXPos.w,d0		; Cap at the left boundary
00003D36 6000                       		bra.s	.SetCamX			; Continue
00003D38                            
00003D38                            .MoveRight:
00003D38 0C40 0010                  		cmpi.w	#16,d0				; Is the camera moving more than 16 pixels per frame?
00003D3C 6500                       		blo.s	.ChkRightBound			; If not, branch
00003D3E 303C 0010                  		move.w	#16,d0				; Keep the camera from moving too fast
00003D42                            
00003D42                            .ChkRightBound:
00003D42 D051                       		add.w	(a1),d0				; Add back the camera's X position
00003D44 B078 E8CA                  		cmp.w	maxCamXPos.w,d0		; Has the camera gone beyond the right boundary?
00003D48 6D00                       		blt.s	.SetCamX			; If not, branch
00003D4A 3038 E8CA                  		move.w	maxCamXPos.w,d0		; Cap at the right boundary
00003D4E                            
00003D4E                            .SetCamX:
00003D4E 3280                       		move.w	d0,(a1)				; Set the new camera X position
00003D50 4E75                       		rts
00003D52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D52                            Level_MoveCameraY:
00003D52 7200                       		moveq	#0,d1
00003D54 3028 0018                  		move.w	_objYPos(a0),d0			; Get the player's Y position
00003D58 9051                       		sub.w	(a1),d0				; Get distance from the camera's Y position
00003D5A                            
00003D5A 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is the player rolling?
00003D60 6700                       		beq.s	.NoRoll				; If not, branch
00003D62 5B40                       		subq.w	#5,d0				; Move up some
00003D64                            
00003D64                            .NoRoll:
00003D64 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is the player in the air?
00003D6A 6700                       		beq.s	.ChkBoundCross_Ground		; If not, branch
00003D6C                            
00003D6C                            .ChkBoundCross_Air:
00003D6C 0640 0020                  		addi.w	#$20,d0				; You have 32 pixels above and below to move without disturbing the camera
00003D70 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003D72 6500                       		bcs.s	.ScrollFast			; If the player is above the boundary, branch
00003D74 0440 0040                  		subi.w	#$40,d0				; Subtract 64
00003D78 6400                       		bcc.s	.ScrollFast			; If the player is below the boundary, branch
00003D7A                            
00003D7A 4A38 E8DC                  		tst.b	chgCamMaxY.w			; Is the max Y boundary changing?
00003D7E 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003D80 6000                       		bra.s	.NoScroll			; Continue
00003D82                            
00003D82                            .ChkBoundCross_Ground:
00003D82 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003D84 6600                       		bne.s	.DecideScrollType		; If the player moved, branch
00003D86 4A38 E8DC                  		tst.b	chgCamMaxY.w			; Is the max Y boundary changing?
00003D8A 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003D8C                            
00003D8C                            .NoScroll:
00003D8C 4E75                       		rts		
00003D8E                            
00003D8E                            .DecideScrollType:
00003D8E 0C43 0060                  		cmpi.w	#(224/2)-16,d3			; Is the camera Y distance normal?
00003D92 6600                       		bne.s	.ScrollSlow			; If not, branch
00003D94                            
00003D94 3228 0000                  		move.w	_objGVel(a0),d1			; Get the players' ground velocity
00003D98 6A00                       		bpl.s	.Positive			; If it's positive, branch
00003D9A 4441                       		neg.w	d1				; Force it to be positive
00003D9C                            
00003D9C                            .Positive:
00003D9C 0C41 0800                  		cmpi.w	#$800,d1			; Is the player travelling very fast?
00003DA0 6400                       		bhs.s	.ScrollFast			; If so, branch
00003DA2                            
00003DA2                            .ScrollMedium:
00003DA2 323C 0600                  		move.w	#6<<8,d1			; Cap camera movement at 6 if going too fast
00003DA6 0C40 0006                  		cmpi.w	#6,d0				; Is the player going down too fast?
00003DAA 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003DAC 0C40 FFFA                  		cmpi.w	#-6,d0				; Is the player going up too fast?
00003DB0 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003DB2 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003DB4                            
00003DB4                            .ScrollSlow:
00003DB4 323C 0200                  		move.w	#2<<8,d1			; Cap camera movement at 2 if going too fast
00003DB8 0C40 0002                  		cmpi.w	#2,d0				; Is the player going down too fast?
00003DBC 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003DBE 0C40 FFFE                  		cmpi.w	#-2,d0				; Is the player going up too fast?
00003DC2 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003DC4 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003DC6                            
00003DC6                            .ScrollFast:
00003DC6 323C 1000                  		move.w	#16<<8,d1			; Cap camera movement at 16 if going too fast
00003DCA 0C40 0010                  		cmpi.w	#16,d0				; Is the player going down too fast?
00003DCE 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003DD0 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the player going up too fast?
00003DD4 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003DD6 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003DD8                            
00003DD8                            .ScrollMaxYChange:
00003DD8 7000                       		moveq	#0,d0				; Distance for the camera to move = 0
00003DDA 11C0 E8DC                  		move.b	d0,chgCamMaxY.w		; Clear the max Y boundary changing flag
00003DDE                            		
00003DDE                            .ScrollUpOrDown:
00003DDE 7200                       		moveq	#0,d1
00003DE0 3200                       		move.w	d0,d1				; Get position difference
00003DE2 D251                       		add.w	(a1),d1				; Add old camera Y position
00003DE4 4A40                       		tst.w	d0				; Is the camera to scroll down?
00003DE6 6A00                       		bpl.s	.ScrollDown			; If so, branch
00003DE8 6000 0000                  		bra.w	.ScrollUp			; Scroll up
00003DEC                            
00003DEC                            .ScrollUpMax:
00003DEC 4441                       		neg.w	d1				; Make the value negative, since we are going up
00003DEE 48C1                       		ext.l	d1
00003DF0 E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003DF2 D291                       		add.l	(a1),d1				; Add the camera's Y position
00003DF4 4841                       		swap	d1				; Get the actual Y position
00003DF6                            
00003DF6                            .ScrollUp:
00003DF6 B278 E8D4                  		cmp.w	minCamYPos.w,d1		; Has the camera gone beyond the upper boundary?
00003DFA 6E00                       		bgt.s	.DoScroll			; If not, branch
00003DFC 3238 E8D4                  		move.w	minCamYPos.w,d1		; Cap at upper boundary
00003E00 6000                       		bra.s	.DoScroll			; Continue
00003E02                            
00003E02                            .ScrollDownMax:
00003E02 48C1                       		ext.l	d1
00003E04 E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003E06 D291                       		add.l	(a1),d1				; Add the camera's Y position
00003E08 4841                       		swap	d1				; Get the actual Y position
00003E0A                            
00003E0A                            .ScrollDown:
00003E0A B278 E8CC                  		cmp.w	maxCamYPos.w,d1		; Has the camera gone beyond the lower boundary?
00003E0E 6D00                       		blt.s	.DoScroll			; If not, branch
00003E10 3238 E8CC                  		move.w	maxCamYPos.w,d1		; Cap at lower boundary
00003E14                            
00003E14                            .DoScroll:
00003E14 4841                       		swap	d1				; Put Y coordinate in the higher word
00003E16 2281                       		move.l	d1,(a1)				; Set Y position
00003E18 4E75                       		rts
00003E1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E1A                            ; Level ring manager
00003E1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E1A                            Level_RingsManager:
00003E1A 7000                       		moveq	#0,d0
00003E1C 1038 E866                  		move.b	ringMgrRoutine.w,d0		; Get routine
00003E20 303B 0000                  		move.w	.Routines(pc,d0.w),d0		; Get offset
00003E24 4EFB 0000                  		jmp	.Routines(pc,d0.w)		; Jump to the right routine
00003E28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E28                            .Routines:
00003E28 0000                       		dc.w	Level_RingsManagerInit-.Routines
00003E2A 0000                       		dc.w	Level_RingsManagerMain-.Routines
00003E2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E2C                            ; Ring manager initialization
00003E2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E2C                            Level_RingsManagerInit:
00003E2C 5438 E866                  		addq.b	#2,ringMgrRoutine.w		; The next time the manager is run, only go to the main routine
00003E30                            		
00003E30 6100 0000                  		bsr.w	Level_RingsManagerSetup	; Prepare the tables and load the ring data
00003E34                            
00003E34                            		; Set up the addresses to use in the current location of the level
00003E34                            
00003E34                            		; Start at the left side of the screen
00003E34                            		; We get the location of the first ring that shows up at the left side of the screen in the data and store that
00003E34                            
00003E34 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get current ring data address for the left side of the screen
00003E38 45F8 DFD2                  		lea	ringStatus.w,a2		; Ring status table
00003E3C 3838 E88A                  		move.w	fgCamXPos.w,d4			; Get camera's X position
00003E40 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003E42 6200                       		bhi.s	.CheckLeftSide			; Branch if not beyond 0
00003E44 7801                       		moveq	#1,d4				; Cap left side to 1
00003E46 6000                       		bra.s	.CheckLeftSide			; Start checking
00003E48                            
00003E48                            .NextLeftRing:
00003E48 5849                       		addq.w	#4,a1				; Next ring in ring data
00003E4A 544A                       		addq.w	#2,a2				; Next ring in status table
00003E4C                            
00003E4C                            .CheckLeftSide:
00003E4C B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003E4E 62F8                       		bhi.s	.NextLeftRing			; If not, get the next ring
00003E50 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store starting ring data address
00003E54 31CA E874                  		move.w	a2,ringMgrStatPtr.w		; Store ring status address
00003E58                            
00003E58                            		; Now the right side of the screen
00003E58                            		; We get the location of the first ring that goes beyond the right side of the screen in the data and store that
00003E58                            
00003E58 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003E5C 6000                       		bra.s	.CheckRightSide			; Start checking
00003E5E                            
00003E5E                            .NextRightRing:
00003E5E 5849                       		addq.w	#4,a1				; Next ring in ring data
00003E60                            
00003E60                            .CheckRightSide:
00003E60 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003E62 62FA                       		bhi.s	.NextRightRing			; If not, get the next ring
00003E64 21C9 E870                  		move.l	a1,ringMgrLoadR.w		; Store ending ring data address
00003E68 4E75                       		rts
00003E6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E6A                            ; Ring manager main routine
00003E6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E6A                            Level_RingsManagerMain:
00003E6A 6100 0000                  		bsr.w	Level_RingsManagerDoCollect	; Handle ring collection
00003E6E                            
00003E6E 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get the current starting address for the ring data
00003E72 3478 E874                  		movea.w	ringMgrStatPtr.w,a2		; Get the current starting address for the status table
00003E76                            		
00003E76                            		; Get the new starting addresses for ring data
00003E76                            		; This is done by getting to a point from the current starting address where there's a ring onscreen
00003E76                            		; and then going back to get the very first ring that's on screen
00003E76                            
00003E76 3838 E88A                  		move.w	fgCamXPos.w,d4			; Get camera's X position
00003E7A 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003E7C 6200                       		bhi.s	.CheckNewLeftSide		; Branch if not beyond 0
00003E7E 7801                       		moveq	#1,d4				; Cap left side to 1
00003E80 6000                       		bra.s	.CheckNewLeftSide		; Start checking
00003E82                            
00003E82                            .NextNewLeftRing:
00003E82 5849                       		addq.w	#4,a1				; Next ring in ring data
00003E84 544A                       		addq.w	#2,a2				; Next ring in status table
00003E86                            
00003E86                            .CheckNewLeftSide:
00003E86 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003E88 62F8                       		bhi.s	.NextNewLeftRing		; If not, get the next ring
00003E8A 6000                       		bra.s	.CheckNewLeftSide2		; Start checking
00003E8C                            
00003E8C                            .NextNewLeftRing2:
00003E8C 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003E8E 554A                       		subq.w	#2,a2				; Previous ring in status table
00003E90                            
00003E90                            .CheckNewLeftSide2:
00003E90 B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the left boundary?
00003E94 63F6                       		bls.s	.NextNewLeftRing2		; If not, get the next ring
00003E96 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store starting ring data address
00003E9A 31CA E874                  		move.w	a2,ringMgrStatPtr.w		; Store ring status address
00003E9E                            
00003E9E                            		; Now get the new ending addresses for ring data
00003E9E                            		; This is done by getting to a point from the current starting address where there's a ring at the right of the left boundary
00003E9E                            		; and then going back to get the very first ring that's on screen on the left side
00003E9E                            
00003E9E 2278 E870                  		movea.l	ringMgrLoadR.w,a1		; Get the current ending address for the ring data
00003EA2                            
00003EA2 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003EA6 6000                       		bra.s	.CheckNewRightSide		; Start checking
00003EA8                            
00003EA8                            .NextNewRightRing:
00003EA8 5849                       		addq.w	#4,a1				; Next ring in ring data
00003EAA                            
00003EAA                            .CheckNewRightSide:
00003EAA B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003EAC 62FA                       		bhi.s	.NextNewRightRing		; If not, get the next ring
00003EAE 6000                       		bra.s	.CheckNewRightSide2		; Start checking
00003EB0                            
00003EB0                            .NextNewRightRing2:
00003EB0 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003EB2                            
00003EB2                            .CheckNewRightSide2:
00003EB2 B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the right boundary?
00003EB6 63F8                       		bls.s	.NextNewRightRing2		; If not, get the next ring
00003EB8 21C9 E870                  		move.l	a1,ringMgrLoadR.w		; Store ending ring data address
00003EBC 4E75                       		rts
00003EBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EBE                            ; Handle ring collection
00003EBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EBE                            Level_RingsManagerDoCollect:
00003EBE 45F8 E3D2                  		lea	ringCollect.w,a2			; Ring collection table
00003EC2 321A                       		move.w	(a2)+,d1			; Get consumed ring count
00003EC4 5341                       		subq.w	#1,d1				; SutbactID 1
00003EC6 6500                       		bcs.s	.End				; If there are no consumed rings to handle, branch
00003EC8                            
00003EC8                            .Loop:
00003EC8 301A                       		move.w	(a2)+,d0			; Get ring status address
00003ECA 67FC                       		beq.s	.Loop				; If 0, get the next ring
00003ECC 3240                       		movea.w	d0,a1				; Save in a1
00003ECE 5311                       		subq.b	#1,(a1)				; Decrement timer
00003ED0 6600                       		bne.s	.Next				; If nonzero, branch
00003ED2 12BC 0006                  		move.b	#6,(a1)				; Reset timer
00003ED6 5229 0001                  		addq.b	#1,1(a1)			; Increment frame
00003EDA                            							; Is it the last frame?
00003EDA 0C29 0000 0001             		cmpi.b	#(CMap_Ring_Sparkle_Last-CMap_Ring)/8,1(a1)
00003EE0 6600                       		bne.s	.Next				; If not, branch
00003EE2 32BC FFFF                  		move.w	#-1,(a1)			; Set timer and frame to -1
00003EE6 426A FFFE                  		clr.w	-2(a2)				; Set address in collection table to 0
00003EEA 5378 E3D2                  		subq.w	#1,ringColCount.w		; Decrement collection table count
00003EEE                            
00003EEE                            .Next:
00003EEE 51C9 FFD8                  		dbf	d1,.Loop			; Loop
00003EF2                            
00003EF2                            .End:
00003EF2 4E75                       		rts
00003EF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EF4                            ; Set up the tables and load ring data
00003EF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EF4                            Level_RingsManagerSetup:
00003EF4                            		; Clear tables
00003EF4                            		clrRAM	ringStatus
00003EF4                          M 	local	endaddr
00003EF4                          M endaddr	equs	"ringstatus_End"
00003EF4 7000                     M 	moveq	#0,d0
00003EF6 43F8 DFD2                M 	lea	(ringstatus).w,a1
00003EFA 323C 00FF                M 	move.w	#(((ringstatus_end)-(ringstatus))-((ringstatus)&1))>>2-1,d1
00003EFE 22C0                     M .clear_183:	move.l	d0,(a1)+
00003F00 51C9 FFFC                M 	dbf	d1,.clear_183
00003F04                            		clrRAM	ringCollect
00003F04                          M 	local	endaddr
00003F04                          M endaddr	equs	"ringcollect_End"
00003F04 7000                     M 	moveq	#0,d0
00003F06 43F8 E3D2                M 	lea	(ringcollect).w,a1
00003F0A 323C 001F                M 	move.w	#(((ringcollect_end)-(ringcollect))-((ringcollect)&1))>>2-1,d1
00003F0E 22C0                     M .clear_184:	move.l	d0,(a1)+
00003F10 51C9 FFFC                M 	dbf	d1,.clear_184
00003F14                            
00003F14 2278 E868                  		movea.l	ringMgrLayout.w,a1		; Get ring data pointer
00003F18 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store address
00003F1C 5849                       		addq.w	#4,a1				; Increment address by 4
00003F1E 7A00                       		moveq	#0,d5				; Initialize the ring counter
00003F20 303C 01FE                  		move.w	#$1FE,d0			; Max number of ring
00003F24                            
00003F24                            .GetRingCount:
00003F24 4A99                       		tst.l	(a1)+				; Have all the ring been counted?
00003F26 6B00                       		bmi.s	.Exit				; If so, branch
00003F28 5245                       		addq.w	#1,d5				; Increment ring counter
00003F2A 51C8 FFF8                  		dbf	d0,.GetRingCount		; Loop
00003F2E                            
00003F2E                            .Exit:
00003F2E 4E75                       		rts
00003F30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F30                            ; Do ring collision for the player
00003F30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F30                            PlayeringCollectlision:
00003F30 0C28 0069 0000             		cmpi.b	#105,_objInvulTime(a0)		; Is the player able to collect rings while hurt?
00003F36 6400 0000                  		bhs.w	.End				; If it hasn't been long enough, branch
00003F3A 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get starting address of ring data
00003F3E 2478 E870                  		movea.l	ringMgrLoadR.w,a2		; Get starting address of status table
00003F42 B5C9                       		cmpa.l	a1,a2				; Are there any rings to test collision with?
00003F44 6700 0000                  		beq.w	.End				; If not, branch
00003F48 3878 E874                  		movea.w	ringMgrStatPtr.w,a4
00003F4C 3428 0014                  		move.w	_objXPos(a0),d2			; Player's X position
00003F50 3628 0018                  		move.w	_objYPos(a0),d3			; Player's Y position
00003F54 5142                       		subq.w	#8,d2				; Subtract 8 from X
00003F56 7A00                       		moveq	#0,d5
00003F58 1A28 002D                  		move.b	_objColH(a0),d5			; Player's collision height
00003F5C 5705                       		subq.b	#3,d5				; Subtract 3 from collision height
00003F5E 9645                       		sub.w	d5,d3				; Subtract from Y
00003F60 323C 0006                  		move.w	#6,d1
00003F64 3C3C 000C                  		move.w	#$C,d6
00003F68 383C 0010                  		move.w	#$10,d4				; Width
00003F6C DA45                       		add.w	d5,d5				; Double the height
00003F6E                            
00003F6E                            .NextRing:
00003F6E 4A54                       		tst.w	(a4)				; Is the current ring already consumed?
00003F70 6600                       		bne.s	.GetNext			; If so, get the next ring
00003F72 3011                       		move.w	(a1),d0				; Get ring's X position
00003F74 9041                       		sub.w	d1,d0				; Subtract the player's X from the ring's X
00003F76 9042                       		sub.w	d2,d0				; Check collision
00003F78 6400                       		bcc.s	.ChkCol
00003F7A D046                       		add.w	d6,d0
00003F7C 6500                       		bcs.s	.ChkCol2
00003F7E 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003F82                            
00003F82                            .ChkCol:
00003F82 B044                       		cmp.w	d4,d0				; Check collision
00003F84 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003F88                            
00003F88                            .ChkCol2:
00003F88 3029 0002                  		move.w	2(a1),d0			; Do Y collision check
00003F8C 9041                       		sub.w	d1,d0
00003F8E 9043                       		sub.w	d3,d0
00003F90 6400                       		bcc.s	.ChkCol3
00003F92 D046                       		add.w	d6,d0
00003F94 6500                       		bcs.s	.Collect
00003F96 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003F9A                            
00003F9A                            .ChkCol3:
00003F9A B045                       		cmp.w	d5,d0
00003F9C 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003FA0                            
00003FA0                            .Collect:
00003FA0                            							; Consume the ring
00003FA0 38BC 0000                  		move.w	#(6<<8)|((CMap_Ring_Sparkle-CMap_Ring)/8),(a4)
00003FA4 6100                       		bsr.s	CollectRing			; Collect it
00003FA6 47F8 E3D4                  		lea	ringColList.w,a3		; Get collection list
00003FAA                            
00003FAA                            .Consume:
00003FAA 4A5B                       		tst.w	(a3)+				; Has this slot been used up?
00003FAC 66FC                       		bne.s	.Consume			; If not, get the next one
00003FAE 370C                       		move.w	a4,-(a3)			; Save the status table RAM address for the current ring
00003FB0 5278 E3D2                  		addq.w	#1,ringColCount.w		; Add to the number of rings consumed
00003FB4                            
00003FB4                            .GetNext:
00003FB4 5849                       		addq.w	#4,a1				; Next ring in ring data
00003FB6 544C                       		addq.w	#2,a4				; Next ring in status table
00003FB8 B5C9                       		cmpa.l	a1,a2				; Have we reached the end?
00003FBA 6600 FFB2                  		bne.w	.NextRing			; If not, loop
00003FBE                            
00003FBE                            .End:
00003FBE 4E75                       		rts
00003FC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FC0                            ; Collect a ring
00003FC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FC0                            CollectRing:
00003FC0 5278 E85E                  		addq.w	#1,ringCount.w			; Incremment ring count
00003FC4 50F8 E867                  		st	hudUpdateRings.w			; Update ring counter in HUD
00003FC8                            		playSnd	#sRing, 2			; Play ring sound
00003FC8 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00003FCE 4E75                       		rts
00003FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FD0                            ; Render the HUD
00003FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FD0                            Level_RenderHUDAndRings:
00003FD0 7C00                       		moveq	#0,d6				; Clear render flags
00003FD2 7802                       		moveq	#1*2,d4				; Standard frame
00003FD4 4A78 E85E                  		tst.w	ringCount.w			; Do we have 0 rings?
00003FD8 6600                       		bne.s	.Not0Rings			; If not, branch
00003FDA 0838 0003 E905             		btst	#3,(lvlFrameCnt+1).w		; Can the timer blink?
00003FE0 6600                       		bne.s	.Not0Rings			; If not, branch
00003FE2 7800                       		moveq	#0*2,d4				; Set frame to blink the timer
00003FE4                            
00003FE4                            .Not0Rings:
00003FE4 3A3C 8680                  		move.w	#$8680,d5			; Tile properties
00003FE8                            		
00003FE8 303C 0090                  		move.w	#16+128,d0			; X position
00003FEC 323C 0088                  		move.w	#8+128,d1			; Y position
00003FF0 43FA 0000                  		lea	Map_HUD(pc),a1			; Mappings
00003FF4 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get address of frame
00003FF8 3819                       		move.w	(a1)+,d4			; Get number of sprites in the frame
00003FFA 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00003FFC 4EB8 0852                  		jsr	DrawSprite.w			; Draw the HUD frame
00004000                            
00004000                            .RenderingCount:
00004000 2078 E86C                  		movea.l	ringMgrLoadL.w,a0			; Get starting address of ring data
00004004 2438 E870                  		move.l	ringMgrLoadR.w,d2			; Get ending address of ring data
00004008 9488                       		sub.l	a0,d2				; Get length of the data to read
0000400A 6700                       		beq.s	.End				; If zero length, branch
0000400C 3878 E874                  		movea.w	ringMgrStatPtr.w,a4		; Get starting address of status table
00004010 43FA 0000                  		lea	CMap_Ring(pc),a1		; Get mappings pointer
00004014 3A3C 00F0                  		move.w	#224+16,d5			; Get bottom screen boundary
00004018                            		
00004018                            .Loop:
00004018 4A5C                       		tst.w	(a4)+				; Is this ring collected?
0000401A 6B00                       		bmi.s	.Next				; If so, branch
0000401C 3228 0002                  		move.w	2(a0),d1			; Get Y position
00004020 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract camera's Y position to get screen position
00004024 5041                       		addq.w	#8,d1				; Add 8
00004026 B245                       		cmp.w	d5,d1				; Is it below the bottom of the screen?
00004028 6400                       		bhs.s	.Next				; If so, branch
0000402A 0641 0078                  		addi.w	#120,d1				; Add 120 to move it within screen space
0000402E 3010                       		move.w	(a0),d0				; Get X position
00004030 9053                       		sub.w	cXPos(a3),d0			; Subtract camera's X position to get screen position
00004032 0640 0080                  		addi.w	#128,d0				; Add 128 to move it within screen space
00004036 7C00                       		moveq	#0,d6
00004038 1C2C FFFF                  		move.b	-1(a4),d6			; Get frame
0000403C                            
0000403C                            .Draw:
0000403C E74E                       		lsl.w	#3,d6				; Turn frame ID into offset
0000403E 45F1 6000                  		lea	(a1,d6.w),a2			; Get address of frame map data
00004042 D25A                       		add.w	(a2)+,d1			; Add Y offset
00004044 3CC1                       		move.w	d1,(a6)+			; Save Y position
00004046 3C1A                       		move.w	(a2)+,d6			; Get sprite size
00004048 1C86                       		move.b	d6,(a6)				; Save it
0000404A 544E                       		addq.w	#2,a6				; Skip link value
0000404C 3CDA                       		move.w	(a2)+,(a6)+			; Save base tile ID and properites
0000404E D05A                       		add.w	(a2)+,d0			; Add X offset
00004050 3CC0                       		move.w	d0,(a6)+			; Save X position
00004052 5347                       		subq.w	#1,d7				; Decrement the number of sprites left available
00004054                            
00004054                            .Next:
00004054 5848                       		addq.w	#4,a0				; Next ring in ring data
00004056 5942                       		subq.w	#4,d2				; Decrement the ring count
00004058 66BE                       		bne.s	.Loop				; If there are still rings to check, loop
0000405A                            
0000405A                            .End:
0000405A 4E75                       		rts
0000405C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000405C                            ; Custom mappings format.
0000405C                            ; Differences include...
0000405C                            ;	No offset table (each sprite assumed to be 8 bytes)
0000405C                            ;	No 'sprite pieces per frame' value (hardcoded to 1)
0000405C                            ;	Sign-extended Y-pos value
0000405C                            ;	Sign-extended sprite size value
0000405C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000405C                            CMap_Ring:
0000405C                            		; Main ring frame
0000405C FFF8                       		dc.w	$FFF8
0000405E 0005                       		dc.w	$0005
00004060 26BC                       		dc.w	$0000+$26BC
00004062 FFF8                       		dc.w	$FFF8
00004064                            
00004064                            CMap_Ring_Sparkle:
00004064                            		; Ring sparkle frame 1
00004064 FFF8                       		dc.w	$FFF8
00004066 0005                       		dc.w	$0005
00004068 26B8                       		dc.w	$0000+$26B8
0000406A FFF8                       		dc.w	$FFF8
0000406C                            		; Ring sparkle frame 2
0000406C FFF8                       		dc.w	$FFF8
0000406E 0005                       		dc.w	$0005
00004070 3EB8                       		dc.w	($0000+$26B8)|$1800
00004072 FFF8                       		dc.w	$FFF8
00004074                            		; Ring sparkle frame 3
00004074 FFF8                       		dc.w	$FFF8
00004076 0005                       		dc.w	$0005
00004078 2EB8                       		dc.w	($0000+$26B8)|$800
0000407A FFF8                       		dc.w	$FFF8
0000407C                            		; Ring sparkle frame 4
0000407C FFF8                       		dc.w	$FFF8
0000407E 0005                       		dc.w	$0005
00004080 36B8                       		dc.w	($0000+$26B8)|$1000
00004082 FFF8                       		dc.w	$FFF8
00004084                            CMap_Ring_Sparkle_Last:
00004084                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004084                            ; HUD mappings
00004084                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004084                            Map_HUD:	
00004084 0000 0000                  		dc.w Map_HUD_4-Map_HUD, Map_HUD_18-Map_HUD	
00004088                            
00004088 0003                       Map_HUD_4:	dc.b 0, 3	
0000408A 000D 0002 0000             		dc.b 0, $D, 0, 2, 0, 0	
00004090 0001 0000 0020             		dc.b 0, 1, 0, 0, 0, $20	
00004096 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30
0000409C                            
0000409C 0003                       Map_HUD_18:	dc.b 0, 3	
0000409E 000D 2002 0000             		dc.b 0, $D, $20, 2, 0, 0	
000040A4 0001 2000 0020             		dc.b 0, 1, $20, 0, 0, $20	
000040AA 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
000040B0                            		even
000040B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040B0                            ; Update the HUD
000040B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040B0                            ; PARAMETERS:
000040B0                            ;	a5.l	- VDP data port
000040B0                            ;	a6.l	- VDP control port
000040B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040B0                            ; RETURNS:
000040B0                            ;	Nothing
000040B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040B0                            Level_UpdateHUD:
000040B0 4A38 E867                  		tst.b	hudUpdateRings.w		; Does the ring counter need to be updated?
000040B4 6700                       		beq.s	.End				; If not, branch
000040B6 6B00                       		bmi.s	.DontZero			; If the flag is negative, branch
000040B8 6100 0000                  		bsr.w	Level_HUDResetRings		; Reset the ring counter
000040BC                            
000040BC                            .DontZero:
000040BC 4238 E867                  		clr.b	hudUpdateRings.w		; Clear update value
000040C0                            		vdpCmd	move.l,$D140,VRAM,WRITE,d0	; Set VDP command
000040C0 203C 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),d0
000040C6 7200                       		moveq	#0,d1
000040C8 3238 E85E                  		move.w	ringCount.w,d1			; Ring count
000040CC 6000                       		bra.s	.UpdateRings			; Update the rings counter
000040CE                            
000040CE                            .End
000040CE 4E75                       		rts
000040D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040D0                            .UpdateRings:
000040D0 7800                       		moveq	#0,d4				; Reset the "draw digit" flag
000040D2 45F9 0000 0000             		lea	HUDMod_100,a2			; Start with the 100s digit
000040D8 7C02                       		moveq	#3-1,d6				; Number of digits to draw
000040DA 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers
000040E0                            		
000040E0                            .LoadDigit_Loop:
000040E0 7400                       		moveq	#0,d2				; Reset the digit
000040E2 261A                       		move.l	(a2)+,d3			; Get the number that's used to calculute what the current digit is
000040E4                            		
000040E4                            .GetDigit:
000040E4 9283                       		sub.l	d3,d1				; Subtract
000040E6 6500                       		bcs.s	.InitDrawDigit			; If it's gone below 0, branch
000040E8 5242                       		addq.w	#1,d2				; Increment digit
000040EA 60F8                       		bra.s	.GetDigit			; Loop until the digit is corret
000040EC                            
000040EC                            .InitDrawDigit:
000040EC D283                       		add.l	d3,d1				; Add back
000040EE 4A42                       		tst.w	d2				; Is the digit 0?
000040F0 6700                       		beq.s	.DrawDigit			; If so, branch
000040F2 50C4                       		st	d4				; Set the "draw digit" flag
000040F4                            
000040F4                            .DrawDigit:
000040F4 4A04                       		tst.b	d4				; Should we draw the digit?
000040F6 6700                       		beq.s	.NextDigit			; If not, branch
000040F8 ED4A                       		lsl.w	#6,d2				; Multiply the digit by $40
000040FA 2C80                       		move.l	d0,(a6)				; Set the VDP command
000040FC 47F1 2000                  		lea	(a1,d2.w),a3			; Get address of the digit art
00004100                            		rept	16
00004100                            			move.l	(a3)+,(a5)		; Load the digit art
00004100                            		endr
00004100 2A9B                     M 	move.l	(a3)+,(a5)
00004102 2A9B                     M 	move.l	(a3)+,(a5)
00004104 2A9B                     M 	move.l	(a3)+,(a5)
00004106 2A9B                     M 	move.l	(a3)+,(a5)
00004108 2A9B                     M 	move.l	(a3)+,(a5)
0000410A 2A9B                     M 	move.l	(a3)+,(a5)
0000410C 2A9B                     M 	move.l	(a3)+,(a5)
0000410E 2A9B                     M 	move.l	(a3)+,(a5)
00004110 2A9B                     M 	move.l	(a3)+,(a5)
00004112 2A9B                     M 	move.l	(a3)+,(a5)
00004114 2A9B                     M 	move.l	(a3)+,(a5)
00004116 2A9B                     M 	move.l	(a3)+,(a5)
00004118 2A9B                     M 	move.l	(a3)+,(a5)
0000411A 2A9B                     M 	move.l	(a3)+,(a5)
0000411C 2A9B                     M 	move.l	(a3)+,(a5)
0000411E 2A9B                     M 	move.l	(a3)+,(a5)
00004120                            		
00004120                            .NextDigit:
00004120 0680 0040 0000             		addi.l	#$400000,d0			; Next digit
00004126 51CE FFB8                  		dbf	d6,.LoadDigit_Loop		; Loop
0000412A 4E75                       		rts
0000412C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000412C 0000 0064                  HUDMod_100:	dc.l	100
00004130 0000 000A                  HUDMod_10:	dc.l	10
00004134 0000 0001                  HUDMod_1:	dc.l	1
00004138                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004138                            ; Initialize the HUD
00004138                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004138                            Level_InitHUD:
00004138 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP data port
0000413E 4BEE FFFC                  		lea	-4(a6),a5			; VDP control port
00004142                            		
00004142                            Level_HUDResetRings:
00004142                            		vdpCmd	move.l,$D140,VRAM,WRITE,(a6)	; Set VDP command
00004142 2CBC 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),(a6)
00004148 45FA 0000                  		lea	HUD_RingsBase(pc),a2		; Tile base
0000414C 343C 0002                  		move.w	#3-1,d2				; Length
00004150                            
00004150 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers art
00004156                            
00004156                            .LoadTiles:
00004156 101A                       		move.b	(a2)+,d0			; Get digit
00004158 4880                       		ext.w	d0
0000415A ED48                       		lsl.w	#6,d0				; Turn into offset
0000415C 47F1 0000                  		lea	(a1,d0.w),a3			; Get address of digit art
00004160                            
00004160                            		rept	8*2
00004160                            			move.l	(a3)+,(a5)		; Load art
00004160                            		endr
00004160 2A9B                     M 	move.l	(a3)+,(a5)
00004162 2A9B                     M 	move.l	(a3)+,(a5)
00004164 2A9B                     M 	move.l	(a3)+,(a5)
00004166 2A9B                     M 	move.l	(a3)+,(a5)
00004168 2A9B                     M 	move.l	(a3)+,(a5)
0000416A 2A9B                     M 	move.l	(a3)+,(a5)
0000416C 2A9B                     M 	move.l	(a3)+,(a5)
0000416E 2A9B                     M 	move.l	(a3)+,(a5)
00004170 2A9B                     M 	move.l	(a3)+,(a5)
00004172 2A9B                     M 	move.l	(a3)+,(a5)
00004174 2A9B                     M 	move.l	(a3)+,(a5)
00004176 2A9B                     M 	move.l	(a3)+,(a5)
00004178 2A9B                     M 	move.l	(a3)+,(a5)
0000417A 2A9B                     M 	move.l	(a3)+,(a5)
0000417C 2A9B                     M 	move.l	(a3)+,(a5)
0000417E 2A9B                     M 	move.l	(a3)+,(a5)
00004180                            
00004180 51CA FFD4                  		dbf	d2,.LoadTiles			; Loop
00004184                            
00004184 4E75                       		rts
00004186                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004186                            HUD_RingsBase:
00004186 0A0A 00                    		dc.b	$A, $A, 0			; Ring count
0000418A 00                         		even
0000418A                            
0000418A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000418A                            ; Animate the level art
0000418A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000418A                            ; LEVEL ANIMATION SCRIPTS
0000418A                            ;
0000418A                            ; The AniArt_D_objAnimmate subroutine uses these scripts to reload certain tiles,
0000418A                            ; thus animating them. All the relevant art must be uncompressed, because
0000418A                            ; otherwise the subroutine would spend so much time waiting for the art to be
0000418A                            ; decompressed that the VBLANK window would close before all the animating was done.
0000418A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000418A                            ;	zoneanimdecl -1, ArtUnc_Flowers1, ArtTile_ArtUnc_Flowers1, 6, 2
0000418A                            ;		-1			Global frame duration. If -1, then each frame will use its own duration, instead
0000418A                            ;		ArtUnc_Flowers1		Source address
0000418A                            ;		ArtTile_ArtUnc_Flowers1	Destination VRAM address
0000418A                            ;		6			Number of frames
0000418A                            ;		2			Number of tiles to load into VRAM for each frame
0000418A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000418A                            ;	dc.b   0,$7F			Start of the script proper
0000418A                            ;		0			Tile ID of first tile in ArtUnc_Flowers1 to transfer
0000418A                            ;		$7F			Frame duration. Only here if global duration is -1
0000418A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000418A                            AniArt_D_objAnimmate:
0000418A 47F8 E90C                  		lea	lvlAnimCntrs.w,a3		; Level art animation counters
0000418E 3C1A                       		move.w	(a2)+,d6			; Get number of scripts in list
00004190 6A00                       		bpl.s	.ListNotEmpty			; If there are any, continue
00004192 4E75                       		rts
00004194                            
00004194                            .ListNotEmpty:
00004194                            .Loop:
00004194 5313                       		subq.b	#1,(a3)				; Tick down frame duration
00004196 6400                       		bcc.s	.NextScript			; If frame isn't over, move on to next script
00004198                            
00004198                            .NextFrame:
00004198 7000                       		moveq	#0,d0
0000419A 102B 0001                  		move.b	1(a3),d0			; Get current frame
0000419E B02A 0006                  		cmp.b	6(a2),d0			; Have we processed the last frame in the script?
000041A2 6500                       		blo.s	.NotLastFrame			; If not, branch
000041A4 7000                       		moveq	#0,d0				; If so, reset to first frame
000041A6 1740 0001                  		move.b	d0,1(a3)			; ''
000041AA                            
000041AA                            .NotLastFrame:
000041AA 522B 0001                  		addq.b	#1,1(a3)			; Consider this frame processed; set counter to next frame
000041AE 1692                       		move.b	(a2),(a3)			; Set frame duration to global duration value
000041B0 6A00                       		bpl.s	.GlobalDuration
000041B2 D040                       		add.w	d0,d0				; If script uses per-frame durations, use those instead
000041B4 16B2 0009                  		move.b	9(a2,d0.w),(a3)			; Set frame duration to current frame's duration value
000041B8                            
000041B8                            .GlobalDuration:
000041B8 1032 0008                  		move.b	8(a2,d0.w),d0			; Get tile ID
000041BC EB48                       		lsl.w	#5,d0				; Turn it into an offset
000041BE 342A 0004                  		move.w	4(a2),d2			; Get VRAM destination address
000041C2 2212                       		move.l	(a2),d1				; Get ROM source address
000041C4 0281 00FF FFFF             		andi.l	#$FFFFFF,d1			; ''
000041CA D280                       		add.l	d0,d1				; Offset into art, to get the address of new frame
000041CC 7600                       		moveq	#0,d3
000041CE 162A 0007                  		move.b	7(a2),d3			; Get size of art to be transferred 
000041D2 E94B                       		lsl.w	#4,d3				; Turn it into actual size (in words)
000041D4 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a DMA transfer
000041D8                            
000041D8                            .NextScript:
000041D8 102A 0006                  		move.b	6(a2),d0			; Get total size of frame data
000041DC 4A12                       		tst.b	(a2)				; Is per-frame duration data present?
000041DE 6A00                       		bpl.s	.GlobalDuration2		; If not, keep the current size; it's correct
000041E0 D000                       		add.b	d0,d0				; Double size to account for the additional frame duration data
000041E2                            
000041E2                            .GlobalDuration2:
000041E2 5200                       		addq.b	#1,d0
000041E4 0240 00FE                  		andi.w	#$FE,d0				; Round to next even address, if it isn't already
000041E8 45F2 0008                  		lea	8(a2,d0.w),a2			; Advance to next script in list
000041EC 544B                       		addq.w	#2,a3				; Advance to next script's slot in a3 (usually Anim_Counters)
000041EE 51CE FFA4                  		dbf	d6,.Loop			; Loop
000041F2 4E75                       		rts
000041F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041F4                            ; Set an object as solid and check for collision
000041F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041F4                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For _objStatus):
000041F4                            ;	XXPXSXAX
000041F4                            ;	X	- Unused
000041F4                            ;	P	- Pushing flag
000041F4                            ;	S	- Standing on flag
000041F4                            ;	A	- In air flag (for the player)
000041F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041F4                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For d6):
000041F4                            ;	XXXTXBXS
000041F4                            ;	X	- Unused
000041F4                            ;	T	- Touch top flag
000041F4                            ;	B	- Touch bottom flag
000041F4                            ;	S	- Touch side flag
000041F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041F4                            ; PARAMETERS:
000041F4                            ;	d1.w	- Object width
000041F4                            ;	d2.w	- Object height / 2 (when jumping)
000041F4                            ;	d3.w	- Object height / 2 (when walking)
000041F4                            ;	d4.w	- Object x-axis position
000041F4                            ;	a0.l	- Object space pointer
000041F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041F4                            ; RETURNS:
000041F4                            ;	See object collision return values above
000041F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041F4                            SolidObject:
000041F4 7C00                       		moveq	#0,d6				; Clear collision flag register
000041F6 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
000041FA 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
00004200 6700 0000                  		beq.w	SolidObject_ChkColOnScr		; If not, branch
00004204 3401                       		move.w	d1,d2				; Copy object width
00004206 D442                       		add.w	d2,d2				; Double it
00004208 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
0000420E 6600                       		bne.s	.NotOnTop			; If so, branch
00004210 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
00004214 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004218 D041                       		add.w	d1,d0				; Add width
0000421A 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
0000421C B042                       		cmp.w	d2,d0				; Compare with the width
0000421E 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004220                            
00004220                            .NotOnTop:
00004220 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
00004226 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
0000422C 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
00004232 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004236 7800                       		moveq	#0,d4				; Set collision status to 0
00004238 4E75                       		rts
0000423A                            
0000423A                            .IsOnTop:
0000423A 3404                       		move.w	d4,d2				; Copy X position to d2
0000423C 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
00004240 7800                       		moveq	#0,d4				; Set collision status to 0
00004242 4E75                       		rts
00004244                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004244                            ; Set an object as solid and check for collision (even if off screen)
00004244                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004244                            ; PARAMETERS:
00004244                            ;	d1.w	- Object width
00004244                            ;	d2.w	- Object height / 2 (when jumping)
00004244                            ;	d3.w	- Object height / 2 (when walking)
00004244                            ;	d4.w	- Object x-axis position
00004244                            ;	a0.l	- Object space pointer
00004244                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004244                            ; RETURNS:
00004244                            ;	See object collision return values above
00004244                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004244                            SolidObject_Always:
00004244 7C00                       		moveq	#0,d6				; Clear collision flag register
00004246 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
0000424A 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
00004250 6700 0000                  		beq.w	SolidObject_ChkCollision	; If not, branch
00004254 3401                       		move.w	d1,d2				; Copy object width
00004256 D442                       		add.w	d2,d2				; Double it
00004258 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
0000425E 6600                       		bne.s	.NotOnTop			; If so, branch
00004260 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
00004264 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004268 D041                       		add.w	d1,d0				; Add width
0000426A 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
0000426C B042                       		cmp.w	d2,d0				; Compare with the width
0000426E 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004270                            
00004270                            .NotOnTop:
00004270 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
00004276 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
0000427C 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
00004282 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004286 7800                       		moveq	#0,d4				; Set collision status to 0
00004288 4E75                       		rts
0000428A                            
0000428A                            .IsOnTop:
0000428A 3404                       		move.w	d4,d2				; Copy X position to d2
0000428C 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
00004290 7800                       		moveq	#0,d4				; Set collision status to 0
00004292 4E75                       		rts
00004294                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004294                            ; Set an object as a solid slope and check for collision
00004294                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004294                            ; PARAMETERS:
00004294                            ;	d1.w	- Object width
00004294                            ;	d2.w	- Object height / 2 (when jumping)
00004294                            ;	d3.w	- Object height / 2 (when walking)
00004294                            ;	d4.w	- Object x-axis position
00004294                            ;	a0.l	- Object space pointer
00004294                            ;	a2.l	- Slope height data pointer
00004294                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004294                            ; RETURNS:
00004294                            ;	See object collision return values above
00004294                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004294                            SlopedSolid:
00004294 7C00                       		moveq	#0,d6				; Clear collision flag register
00004296 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
0000429A 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
000042A0 6700 0000                  		beq.w	SlopedSolid_ChkCollision	; If not, branch
000042A4 3401                       		move.w	d1,d2				; Copy object width
000042A6 D442                       		add.w	d2,d2				; Double it
000042A8 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000042AE 6600                       		bne.s	.NotOnTop			; If so, branch
000042B0 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
000042B4 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
000042B8 D041                       		add.w	d1,d0				; Add width
000042BA 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000042BC B042                       		cmp.w	d2,d0				; Compare with the width
000042BE 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000042C0                            
000042C0                            .NotOnTop:
000042C0 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
000042C6 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
000042CC 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
000042D2 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
000042D6 7800                       		moveq	#0,d4				; Set collision status to 0
000042D8 4E75                       		rts
000042DA                            
000042DA                            .IsOnTop:
000042DA 3404                       		move.w	d4,d2				; Copy X position to d2
000042DC 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Move the player on top of the current object
000042E0 7800                       		moveq	#0,d4				; Set collision status to 0
000042E2 4E75                       		rts
000042E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000042E4                            SlopedSolid_ChkCollision:
000042E4 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
000042E8 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract current object's X position
000042EC D041                       		add.w	d1,d0				; Add width to it
000042EE 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
000042F2 3601                       		move.w	d1,d3				; Copy width to d3
000042F4 D643                       		add.w	d3,d3				; Double it
000042F6 B043                       		cmp.w	d3,d0				; Compare to the X position
000042F8 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
000042FC 3A00                       		move.w	d0,d5				; Copy the X position to d5
000042FE 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X-flipped?
00004304 6700                       		beq.s	.NoFlip				; If not, branch
00004306 4645                       		not.w	d5				; Logical notation on d5
00004308 DA43                       		add.w	d3,d5				; Add width
0000430A                            
0000430A                            .NoFlip:
0000430A E24D                       		lsr.w	#1,d5				; Divide by 2
0000430C 1632 5000                  		move.b	(a2,d5.w),d3			; Get height of this segment
00004310 9612                       		sub.b	(a2),d3				; Subtract first bytes from the value
00004312 4883                       		ext.w	d3				; Sign extend to word
00004314 3A28 0018                  		move.w	_objYPos(a0),d5			; Get the current object's Y position
00004318 9A43                       		sub.w	d3,d5				; Subtract the height from the Y position
0000431A 1629 002D                  		move.b	_objColH(a1),d3			; Get the player's collision height
0000431E 4883                       		ext.w	d3				; Sign extend to word
00004320 D443                       		add.w	d3,d2				; Add collision height to the object height
00004322 3629 0018                  		move.w	_objYPos(a1),d3			; Get the player's Y position
00004326 9645                       		sub.w	d5,d3				; Subtract d5
00004328 5843                       		addq.w	#4,d3				; Add 4
0000432A D642                       		add.w	d2,d3				; Add height and collision height
0000432C 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
00004330 3802                       		move.w	d2,d4				; Copy height and collision height
00004332 D844                       		add.w	d4,d4				; Double it
00004334 B644                       		cmp.w	d4,d3				; Compare to Y position
00004336 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
0000433A 6000 0000                  		bra.w	SolidObject_ChkBounds		; If anything else, we are colliding
0000433E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000433E                            SolidObject_ChkColOnScr:
0000433E 4A28 000D                  		tst.b	_objRender(a0)			; Is the object on screen?
00004342 6A00 0000                  		bpl.w	SolidObject_TestClearPush	; If not, branch
00004346                            
00004346                            SolidObject_ChkCollision:
00004346 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
0000434A 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
0000434E D041                       		add.w	d1,d0				; Add width
00004350 3601                       		move.w	d1,d3				; Copy width
00004352 D643                       		add.w	d3,d3				; Double it
00004354 B043                       		cmp.w	d3,d0				; Compare with the X position
00004356 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
0000435A                            		
0000435A 1829 0000                  		move.b	_objInitColH(a1),d4		; Get the player's default collision height
0000435E 4884                       		ext.w	d4				; Sign extend to word
00004360 D842                       		add.w	d2,d4				; Add height
00004362 1629 002D                  		move.b	_objColH(a1),d3			; Get the player's collision height
00004366 4883                       		ext.w	d3				; Sign extend to word
00004368 D443                       		add.w	d3,d2				; Add to height
0000436A 3629 0018                  		move.w	_objYPos(a1),d3			; Get player's Y position
0000436E 9668 0018                  		sub.w	_objYPos(a0),d3			; Subtract the current object's Y position
00004372 5843                       		addq.w	#4,d3				; Add 4
00004374 D642                       		add.w	d2,d3				; Add height
00004376 0243 0FFF                  		andi.w	#$FFF,d3			; Keep in range
0000437A D842                       		add.w	d2,d4				; Add height
0000437C B644                       		cmp.w	d4,d3				; Compare with the Y position
0000437E 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
00004382                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004382                            SolidObject_ChkBounds:
00004382 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
00004386 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If so, branch
0000438A 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is the player dead?
00004390 6400 0000                  		bcc.w	SolidObject_End			; If so, branch
00004394 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
00004398 6600 0000                  		bne.w	SolidObject_End			; If so, branch
0000439C                            
0000439C 3A00                       		move.w	d0,d5				; Copy X offset
0000439E B240                       		cmp.w	d0,d1				; Check against the "middle" of the object
000043A0 6400                       		bcc.s	.IsLeft				; If the player is left of the middle, branch
000043A2 D241                       		add.w	d1,d1				; Double collision width
000043A4 9041                       		sub.w	d1,d0				; Subtract from X offset
000043A6 3A00                       		move.w	d0,d5				; Copy X offset
000043A8 4445                       		neg.w	d5				; Negate offset
000043AA                            
000043AA                            .IsLeft:
000043AA 3203                       		move.w	d3,d1				; Copy Y offset
000043AC B443                       		cmp.w	d3,d2				; Check against the "middle" of the object
000043AE 6400                       		bcc.s	.IsAbove			; If the player is above of the middle, branch
000043B0 5943                       		subq.w	#4,d3				; Subtract 4 from the collision height
000043B2 9644                       		sub.w	d4,d3				; Subtract height from the collision height
000043B4 3203                       		move.w	d3,d1				; Copy Y offset
000043B6 4441                       		neg.w	d1				; Negate offset
000043B8                            
000043B8                            .IsAbove:
000043B8 BA41                       		cmp.w	d1,d5
000043BA 6200 0000                  		bhi.w	SolidObject_UpDown		; Branch if we are in the object less vertically than horizontally(?)
000043BE 0C41 0004                  		cmpi.w	#4,d1
000043C2 6300 0000                  		bls.w	SolidObject_UpDown		; I assume this ensures the corners are not solid until some point
000043C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043C6                            SolidObject_Sides:
000043C6 4A40                       		tst.w	d0
000043C8 6700                       		beq.s	.AlignPlayer			; Branch if we are in the middle of the object?
000043CA 6B00                       		bmi.s	.ChkRight			; Branch if we are right of the object
000043CC 4A69 001C                  		tst.w	_objXVel(a1)			; Is the player moving left?
000043D0 6B00                       		bmi.s	.AlignPlayer			; If so, branch
000043D2 6000                       		bra.s	.ClearGroundVel			; If else player is moving right, branch
000043D4                            
000043D4                            .ChkRight:
000043D4 4A69 001C                  		tst.w	_objXVel(a1)
000043D8 6A00                       		bpl.s	.AlignPlayer			; Branch if player is moving right
000043DA                            
000043DA                            .ClearGroundVel:
000043DA 4269 0000                  		clr.w	_objGVel(a1)			; Stop the player from moving
000043DE 4269 001C                  		clr.w	_objXVel(a1)			; Clear the player's X velocity
000043E2                            
000043E2                            .AlignPlayer:
000043E2 9169 0014                  		sub.w	d0,_objXPos(a1)			; Align player to the side of the object
000043E6 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000043EC 6600                       		bne.s	.InAir				; If so, branch
000043EE 08E8 0005 0028             		bset	#cPushBit,_objStatus(a0)		; Set the pushing bit
000043F4 08E9 0005 0028             		bset	#cPushBit,_objStatus(a1)		; Set the player's pushing bit
000043FA 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
000043FE 7801                       		moveq	#1,d4				; Set collision status to 1
00004400 4E75                       		rts
00004402                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004402                            .InAir:
00004402 6100                       		bsr.s	SolidObject_ClearPush		; Clear pushing bits
00004404 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
00004408 7801                       		moveq	#1,d4				; Set collision status to 1
0000440A 4E75                       		rts
0000440C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000440C                            SolidObject_TestClearPush:
0000440C 0828 0005 0028             		btst	#cPushBit,_objStatus(a0)		; Is the player pushing this object?
00004412 6700                       		beq.s	SolidObject_End			; If not, branch
00004414 0C29 0002 0020             		cmpi.b	#2,_objAnim(a1)			; Is the player jumping/rolling?
0000441A 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
0000441C 0C29 0017 0020             		cmpi.b	#$17,_objAnim(a1)			; Is the player in using the drowning animation
00004422 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
00004424 0C29 001A 0020             		cmpi.b	#$1A,_objAnim(a1)			; Is the player in using the hurt animation
0000442A 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
0000442C 337C 0001 0020             		move.w	#1,_objAnim(a1)			; Make the player use the walking animation
00004432                            
00004432                            SolidObject_ClearPush:
00004432 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Clear the pushing bit
00004438 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; Clear the player's pushing bit
0000443E                            
0000443E                            SolidObject_End:
0000443E 7800                       		moveq	#0,d4				; Set collision status to 0
00004440 4E75                       		rts
00004442                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004442                            SolidObject_UpDown:
00004442 4A43                       		tst.w	d3				; Is the player below the middle of the object?
00004444 6B00                       		bmi.s	SolidObject_Below		; If so, branch
00004446 0C43 0010                  		cmpi.w	#$10,d3				; Is the player 16 pixels or less above the middle of the object?
0000444A 6500                       		bcs.s	SolidObject_Above		; If so, branch
0000444C 60BE                       		bra.s	SolidObject_TestClearPush	; If not, the player is not colliding
0000444E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000444E                            SolidObject_Below:
0000444E 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving vertically?
00004452 6700                       		beq.s	.CheckCrush			; If so, branch
00004454 6A00                       		bpl.s	.SetY				; If the player's moving down, branch
00004456 4A43                       		tst.w	d3				; Is the player above the middle of the object?
00004458 6A00                       		bpl.s	.SetY				; If so, branch
0000445A 4269 001E                  		clr.w	_objYVel(a1)			; Clear the player's Y velocity
0000445E                            
0000445E                            .SetY:
0000445E 9769 0018                  		sub.w	d3,_objYPos(a1)			; Push the player below the object
00004462 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
00004466 78FE                       		moveq	#-2,d4				; Set the collision status to -2
00004468 4E75                       		rts
0000446A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000446A                            .CheckCrush:
0000446A 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004470 66EC                       		bne.s	.SetY				; If so, branch
00004472 3800                       		move.w	d0,d4				; Get x offset
00004474 6A00                       		bpl.s	.NoNeg				; If it's positive branch
00004476 4444                       		neg.w	d4				; Negate it (absolute value)
00004478                            
00004478                            .NoNeg:
00004478 0C44 0010                  		cmpi.w	#$10,d4				; Is the player near the edge of object collision?
0000447C 6500 FF48                  		blo.w	SolidObject_Sides		; If so, branch
00004480                            		
00004480                            		push.l	a0				; Store the current object's address
00004480 2F08                     M 	move.l	a0,-(sp)
00004482 2049                       		movea.l	a1,a0				; Replace with the player's address
00004484 4EB9 0000 0000             		jsr	ObjPlayer_GetKilled		; Kill the player
0000448A                            		pop.l	a0				; Restore the current object's address
0000448A 205F                     M 	move.l	(sp)+,a0
0000448C 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
00004490 78FE                       		moveq	#-2,d4				; Set collision status to -2
00004492 4E75                       		rts
00004494                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004494                            SolidObject_Above:
00004494 5943                       		subq.w	#4,d3				; Get the sub Y offset
00004496                            		
00004496                            		; This next bit ensures the player does not collide with the top when next to the walls
00004496                            		; recalculates object width.
00004496                            
00004496 7200                       		moveq	#0,d1
00004498 1228 002C                  		move.b	_objColW(a0),d1			; Get the current object's width
0000449C 3401                       		move.w	d1,d2				; Copy it
0000449E D442                       		add.w	d2,d2				; Double it
000044A0                            		
000044A0 D269 0014                  		add.w	_objXPos(a1),d1			; Add the player's X position
000044A4 9268 0014                  		sub.w	_objXPos(a0),d1			; Subtract the current object's X position
000044A8 6B00                       		bmi.s	.NoCollision			; If the player is not colliding, branch
000044AA                            		
000044AA B242                       		cmp.w	d2,d1				; Is the plauer colliding from the right?
000044AC 6400                       		bcc.s	.NoCollision			; If the player is not colliding, branch
000044AE                            		
000044AE 5369 0018                  		subq.w	#1,_objYPos(a1)			; Subtract 1 from the player's Y position
000044B2 9769 0018                  		sub.w	d3,_objYPos(a1)			; Move the player above the object
000044B6 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
000044BA 6B00                       		bmi.s	.NoCollision			; If so, branch
000044BC 6100 0000                  		bsr.w	RideObject_SetRide		; Allow the player to stand on top (and set the "ride" bit)
000044C0 08C6 0004                  		bset	#cTouchTopBit,d6		; Set "touch top" flag
000044C4 78FF                       		moveq	#-1,d4				; Set collision status to -1
000044C6 4E75                       		rts
000044C8                            
000044C8                            .NoCollision:
000044C8 7800                       		moveq	#0,d4				; Set collision status to 0
000044CA 4E75                       		rts
000044CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044CC                            ; Set an object as a platform and check for collision
000044CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044CC                            ; PARAMETERS:
000044CC                            ;	d1.w	- Object's width
000044CC                            ;	d2.w	- Object's width*2 (only for Platform_ChkBridgeCol)
000044CC                            ;	d3.w	- Object's height
000044CC                            ;	d4.w	- Object x-axis position
000044CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044CC                            ; RETURNS:
000044CC                            ;	See object collision return values above (side and bottom collision doesn't apply here)
000044CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044CC                            PlatformObject:
000044CC 7C00                       		moveq	#0,d6				; Clear collision flag register
000044CE 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get the player RAM
000044D2 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the object?
000044D8 6700 0000                  		beq.w	Platform_ChkCollision		; If not, branch
000044DC 3401                       		move.w	d1,d2				; Copy the object's width
000044DE D442                       		add.w	d2,d2				; Double it
000044E0 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000044E6 6600                       		bne.s	.NotOnTop			; If so, branch
000044E8 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
000044EC 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
000044F0 D041                       		add.w	d1,d0				; Add width
000044F2 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
000044F4 B042                       		cmp.w	d2,d0				; Compare with the width
000044F6 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
000044F8                            
000044F8                            .NotOnTop:
000044F8 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the player's standing on object bit
000044FE 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
00004504 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
0000450A 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
0000450E 7800                       		moveq	#0,d4				; Set the collision status to 0
00004510 4E75                       		rts
00004512                            
00004512                            .OnTop:
00004512 3404                       		move.w	d4,d2				; Copy X position
00004514 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Make the player stand on top of this object
00004518 7800                       		moveq	#0,d4				; Set the collision status to 0
0000451A 4E75                       		rts
0000451C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000451C                            Platform_ChkBridgeCol:
0000451C 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
00004520 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
00004524 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004528 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
0000452C D041                       		add.w	d1,d0				; Add width
0000452E 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004532 B042                       		cmp.w	d2,d0				; Compare with width
00004534 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004538 6000                       		bra.s	Platform_ChkCol_Cont		; Continue
0000453A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000453A                            Platform_ChkCollision:
0000453A 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
0000453E 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
00004542 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004546 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
0000454A D041                       		add.w	d1,d0				; Add width
0000454C 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004550 D241                       		add.w	d1,d1				; Double width
00004552 B041                       		cmp.w	d1,d0				; Compare with width
00004554 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004558                            
00004558                            Platform_ChkCol_Cont:
00004558 3028 0018                  		move.w	_objYPos(a0),d0			; Get the object's Y position
0000455C 9043                       		sub.w	d3,d0				; Subtract the height from it
0000455E                            
0000455E                            PlatformObject_ChkYRange:
0000455E 3429 0018                  		move.w	_objYPos(a1),d2			; Get the player's Y position
00004562 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
00004566 4881                       		ext.w	d1				; Sign extend it
00004568 D242                       		add.w	d2,d1				; Add the Y position to the collision height
0000456A 5841                       		addq.w	#4,d1				; Add 4
0000456C 9041                       		sub.w	d1,d0				; SubactID the result from the Y position
0000456E 6200 0000                  		bhi.w	PlatformObject_End		; If it's greater than 0, branch
00004572 0C40 FFF0                  		cmpi.w	#-$10,d0			; Is the result less than -16?
00004576 6500 0000                  		bcs.w	PlatformObject_End		; If so, branch
0000457A 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
0000457E 6600 0000                  		bne.w	PlatformObject_End		; If so, branch
00004582 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
00004586 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
0000458A 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)		; Is the player dead?
00004590 6400 0000                  		bcc.w	PlatformObject_End		; If so, branch
00004594 D440                       		add.w	d0,d2				; Add the previous result to the Y position
00004596 5642                       		addq.w	#3,d2				; Add 3
00004598 3342 0018                  		move.w	d2,_objYPos(a1)			; Add to the player's Y position
0000459C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000459C                            ; Set the player on top of the object
0000459C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000459C                            ; PARAMETERS:
0000459C                            ;	a0.l	- Object space pointer
0000459C                            ;	a1.l	- Player object space pointer
0000459C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000459C                            ; RETURNS:
0000459C                            ;	Nothing
0000459C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000459C                            RideObject_SetRide:
0000459C 0829 0003 0028             		btst	#cStandBit,_objStatus(a1)		; Is the player standing on the object?
000045A2 6700                       		beq.s	.IsStanding			; If not, branch
000045A4 3669 0000                  		movea.w	_objInteract(a1),a3		; Get the object the player is standing on
000045A8 08AB 0003 0028             		bclr	#cStandBit,_objStatus(a3)		; Clear its standing on object bit
000045AE 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
000045B2                            
000045B2                            .IsStanding:
000045B2 3348 0000                  		move.w	a0,_objInteract(a1)		; Set it as the object the player is standing on
000045B6 4229 0000                  		clr.b	_objAngle(a1)			; Clear the player's angle
000045BA 4269 001E                  		clr.w	_objYVel(a1)			; Clear the player's Y velocity
000045BE 3369 001C 0000             		move.w	_objXVel(a1),_objGVel(a1)		; Set the player's X velocity as its ground velocity
000045C4 08E9 0003 0028             		bset	#cStandBit,_objStatus(a1)		; Set the player's standing on object bit
000045CA 08E8 0003 0028             		bset	#cStandBit,_objStatus(a0)		; Set the player standing on this object bir
000045D0 08A9 0001 0028             		bclr	#1,_objStatus(a1)			; Clear the player's in midair bit
000045D6 6700                       		beq.s	PlatformObject_End		; If it was already clear, branch
000045D8 2F08                       		move.l	a0,-(sp)			; Store the current object's address
000045DA 2049                       		movea.l	a1,a0				; Replace it with the player's address
000045DC 6100 E8A6                  		bsr.w	PlayerResetOnFloor		; Reset the player's variables to make it touch the floor
000045E0 205F                       		movea.l	(sp)+,a0			; Restore the current object's address
000045E2                            
000045E2                            PlatformObject_End:
000045E2 4E75                       		rts
000045E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045E4                            ; Set an object as a solid slope and check for collision
000045E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045E4                            ; PARAMETERS:
000045E4                            ;	d1.w	- Object width
000045E4                            ;	d3.w	- Object height
000045E4                            ;	d4.w	- Object x-axis position
000045E4                            ;	a0.l	- Object space pointer
000045E4                            ;	a2.l	- Slope height data pointer
000045E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045E4                            ; RETURNS:
000045E4                            ;	See object collision return values above (side and bottom collision doesn't apply here)
000045E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045E4                            SlopedPlatform:
000045E4 7C00                       		moveq	#0,d6				; Clear collision flag register
000045E6 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get the player RAM
000045EA 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the object?
000045F0 6700 0000                  		beq.w	SlopedPlarform_ChkCol		; If not branch
000045F4 3401                       		move.w	d1,d2				; Copy the object's width
000045F6 D442                       		add.w	d2,d2				; Double it
000045F8 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000045FE 6600                       		bne.s	.NotOnTop			; If so, branch
00004600 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004604 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004608 D041                       		add.w	d1,d0				; Add width
0000460A 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
0000460C B042                       		cmp.w	d2,d0				; Compare with the width
0000460E 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
00004610                            
00004610                            .NotOnTop:
00004610 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the player's standing on object bit
00004616 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
0000461C 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
00004622 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004626 7800                       		moveq	#0,d4				; Set the collision status to 0
00004628 4E75                       		rts
0000462A                            
0000462A                            .OnTop:
0000462A 3404                       		move.w	d4,d2				; Copy X position
0000462C 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Make the player stand on top of this object
00004630 7800                       		moveq	#0,d4				; Set the collision status to 0
00004632 4E75                       		rts
00004634                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004634                            SlopedPlarform_ChkCol:
00004634 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
00004638 6B00 FFA8                  		bmi.w	PlatformObject_End		; If so, branch
0000463C 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004640 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004644 D041                       		add.w	d1,d0				; Add width
00004646 6B00 FF9A                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
0000464A D241                       		add.w	d1,d1				; Double width
0000464C B041                       		cmp.w	d1,d0				; Compare with width
0000464E 6400 FF92                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004652 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X flipped?
00004658 6700                       		beq.s	.NoXFlip			; If not, skip
0000465A 4640                       		not.w	d0				; Logical notation
0000465C D041                       		add.w	d1,d0				; Add width
0000465E                            
0000465E                            .NoXFlip:
0000465E E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004660 1632 0000                  		move.b	(a2,d0.w),d3			; Get height of the next segment
00004664 4883                       		ext.w	d3				; Sign extend to word
00004666 3028 0018                  		move.w	_objYPos(a0),d0			; Get the current object's Y position
0000466A 9043                       		sub.w	d3,d0				; Subtract the height from the Y position
0000466C 6000 FEF0                  		bra.w	PlatformObject_ChkYRange	; Check the Y range
00004670                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004670                            ; Move the player along a platform/solid object
00004670                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004670                            ; PARAMETERS:
00004670                            ;	d2.w	- X position of the platform
00004670                            ;	d3.w	- Height of the platform
00004670                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004670                            ; RETURNS:
00004670                            ;	Nothing
00004670                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004670                            PlayerMoveOnPtfm:
00004670 3028 0018                  		move.w	_objYPos(a0),d0			; Get the current object's Y position
00004674 9043                       		sub.w	d3,d0				; Subtract height
00004676 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
0000467A 6B00                       		bmi.s	.End				; If so, branch
0000467C 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is the player dead?
00004682 6400                       		bcc.s	.End				; If so, branch
00004684 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
00004688 6600                       		bne.s	.End				; If so, branch
0000468A 7200                       		moveq	#0,d1
0000468C 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
00004690 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004692 3340 0018                  		move.w	d0,_objYPos(a1)			; Set as the player's Y position
00004696 9468 0014                  		sub.w	_objXPos(a0),d2			; Subtract the current object's X position from the suggest X position
0000469A 9569 0014                  		sub.w	d2,_objXPos(a1)			; Subtract the difference from the X position of the player
0000469E                            		;tst.b	(Shield_Flag).w			; Does the player have a shield?
0000469E                            		;beq.s	.End				; If not branch
0000469E                            		;move.w	d0,(Object_Space_7+oY).w	; Apply to the shield's Y position
0000469E                            		;sub.w	d2,(Object_Space_7+oX).w	; Apply to the shield's X position
0000469E                            
0000469E                            .End:
0000469E 4E75                       		rts
000046A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046A0                            ; Move the player along a sloped platform/solid object
000046A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046A0                            ; PARAMETERS:
000046A0                            ;	d3.w	- Height of the platform
000046A0                            ;	d4.w	- X position of the platform
000046A0                            ;	a2.l	- Slope height data pointer
000046A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046A0                            ; RETURNS:
000046A0                            ;	Nothing
000046A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046A0                            PlayerMoveOnSlope:
000046A0 0829 0003 0028             		btst	#cStandBit,_objStatus(a1)		; Is the player standing on the object?
000046A6 6700                       		beq.s	.End				; If not, branch
000046A8 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
000046AC 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
000046B0 D041                       		add.w	d1,d0				; Add width
000046B2 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
000046B4 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X flipped?
000046BA 6700                       		beq.s	.NoXFlip			; If not, branch
000046BC 4640                       		not.w	d0				; Logical notation on d0
000046BE D041                       		add.w	d1,d0				; Add width
000046C0                            
000046C0                            .NoXFlip:
000046C0 1232 0000                  		move.b	(a2,d0.w),d1			; Get Y offset
000046C4 4881                       		ext.w	d1				; Sign extend to word
000046C6 3028 0018                  		move.w	_objYPos(a0),d0			; Get current object's Y position
000046CA 9041                       		sub.w	d1,d0				; Subtract the Y offset
000046CC 7200                       		moveq	#0,d1
000046CE 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
000046D2 9041                       		sub.w	d1,d0				; Subtract from the Y position
000046D4 3340 0018                  		move.w	d0,_objYPos(a1)			; Set as the player's Y position
000046D8 9468 0014                  		sub.w	_objXPos(a0),d2			; Subtract the current object's X position from the suggest X position
000046DC 9569 0014                  		sub.w	d2,_objXPos(a1)			; Subtract the difference from the X position of the player
000046E0                            
000046E0                            .End:
000046E0 4E75                       		rts
000046E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046E2                            ; Do object collision for the player object
000046E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046E2                            PlayerDoObjCollision:
000046E2 4EB8 3F30                  		jsr	PlayeringCollectlision		; Do ring collision
000046E6                            		
000046E6 3428 0014                  		move.w	_objXPos(a0),d2			; Get X position
000046EA 3628 0018                  		move.w	_objYPos(a0),d3			; Get Y position
000046EE 5142                       		subq.w	#8,d2				; Get left sensor X
000046F0 7A00                       		moveq	#0,d5
000046F2 1A28 002D                  		move.b	_objColH(a0),d5			; Get collision height
000046F6 5705                       		subq.b	#3,d5				; Subtract 3
000046F8 9645                       		sub.w	d5,d3				; Get left sensor Y
000046FA 383C 0010                  		move.w	#$10,d4				; Get right sensor delta X
000046FE DA45                       		add.w	d5,d5				; Get right sensor delta Y
00004700                            
00004700 49F8 E7D6                  		lea	collideList.w,a4			; Get collision response list
00004704 3C1C                       		move.w	(a4)+,d6			; Get count
00004706 6700                       		beq.s	.End				; If there are no objects to test, branch
00004708                            
00004708                            .ObjLoop:
00004708 325C                       		movea.w	(a4)+,a1			; Get object
0000470A 1029 002A                  		move.b	_objColType(a1),d0			; Does touching it do anything?
0000470E 6600                       		bne.s	.ChkPosition			; If so, branch
00004710                            
00004710                            .NextObj:
00004710 5546                       		subq.w	#2,d6				; Decrement count
00004712 66F4                       		bne.s	.ObjLoop			; Branch if there are still objects to check
00004714 7000                       		moveq	#0,d0				; Reset d0
00004716                            
00004716                            .End:
00004716 4278 E7D6                  		clr.w	collideList.w			; Clear the collision response list count
0000471A 4E75                       		rts
0000471C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000471C                            .ChkPosition:
0000471C 7200                       		moveq	#0,d1
0000471E 1229 002C                  		move.b	_objColW(a1),d1			; Get object width
00004722 3029 0014                  		move.w	_objXPos(a1),d0			; Get object X position
00004726 9041                       		sub.w	d1,d0				; Get left side of object
00004728 9042                       		sub.w	d2,d0				; Is the player right of the left side of the object?
0000472A 6400                       		bcc.s	.ChkRightSide			; If so, branch
0000472C D241                       		add.w	d1,d1				; Get right side delta X
0000472E D041                       		add.w	d1,d0				; Is the player right of the right side of the object?
00004730 6500                       		bcs.s	.ChkHeight			; If not, branch
00004732 60DC                       		bra.s	.NextObj			; The player isn't touching the object horizontally; check the next object
00004734                            
00004734                            .ChkRightSide:
00004734 B044                       		cmp.w	d4,d0				; Is the player inside the object horizontally?
00004736 62D8                       		bhi.s	.NextObj			; If not, branch
00004738                            
00004738                            .ChkHeight:
00004738 7200                       		moveq	#0,d1
0000473A 1229 002D                  		move.b	_objColH(a1),d1			; Get object height
0000473E 3029 0018                  		move.w	_objYPos(a1),d0			; Get object Y position
00004742 9041                       		sub.w	d1,d0				; Get top of object
00004744 9043                       		sub.w	d3,d0				; Is the player below the top of the object?
00004746 6400                       		bcc.s	.ChkBottom			; If so, branch
00004748 D241                       		add.w	d1,d1				; Get bottom delta Y
0000474A D240                       		add.w	d0,d1				; Is the player below the bottom of the object?
0000474C 6500                       		bcs.s	.ChkType			; If not, branch
0000474E 60C0                       		bra.s	.NextObj			; The player isn't touching the object vertically; check the next object
00004750                            
00004750                            .ChkBottom:
00004750 B045                       		cmp.w	d5,d0				; Is the player inside the object vertically?
00004752 62BC                       		bhi.s	.NextObj			; If not, branch
00004754                            
00004754                            .ChkType:
00004754 7000                       		moveq	#0,d0
00004756 1029 002A                  		move.b	_objColType(a1),d0			; Get collision type
0000475A 4EFB 0000                  		jmp	.CollisionTypes-2(pc,d0.w)	; Go to the appropriate routine
0000475E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000475E                            .CollisionTypes:
0000475E 6000                       		bra.s	.Enemy				; Enemy
00004760 6000                       		bra.s	.Indestructable			; Indestructable
00004762                            
00004762                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004762                            .Enemy:
00004762 0C28 0002 0020             		cmpi.b	#2,_objAnim(a0)			; Are we rolling?
00004768 6600 0000                  		bne.w	.ChkHurt			; If not, branch
0000476C                            
0000476C                            .ChkBoss:
0000476C 4A29 002B                  		tst.b	_objHitCnt(a1)			; Do we have a hit count?
00004770 6700                       		beq.s	.Kill				; If not, branch
00004772 4468 001C                  		neg.w	_objXVel(a0)			; Bounce backwards
00004776 4468 001E                  		neg.w	_objYVel(a0)			; ''
0000477A 4229 002A                  		clr.b	_objColType(a1)			; Indicate that we have hit the boss
0000477E 5329 002B                  		subq.b	#1,_objHitCnt(a1)			; Decrement hit count
00004782 6600                       		bne.s	.BossEnd			; If it hasn't reached 0, branch
00004784 08E9 0007 0028             		bset	#7,_objStatus(a1)			; Set the "killed" flag
0000478A                            
0000478A                            .BossEnd:
0000478A 4E75                       		rts
0000478C                            
0000478C                            .Kill:
0000478C 08E9 0007 0028             		bset	#7,_objStatus(a1)			; Set the "killed" flag
00004792 22BC 0000 0000             		move.l	#ObjExplosion,_objAddress(a1)		; Change into an explosion
00004798 4229 002A                  		clr.b	_objColType(a1)			; Indicate that we have hit the boss
0000479C 4229 0025                  		clr.b	_objRoutine(a1)			; Reset the routine ID
000047A0 4A68 001E                  		tst.w	_objYVel(a0)			; Are we going up?
000047A4 6B00                       		bmi.s	.MoveDown			; If so, branch
000047A6 3028 0018                  		move.w	_objYPos(a0),d0			; Are we below the object?
000047AA B069 0018                  		cmp.w	_objYPos(a1),d0			; ''
000047AE 6400                       		bhs.s	.MoveUp				; If so, branch
000047B0 4468 001E                  		neg.w	_objYVel(a0)			; Bounce up
000047B4 4E75                       		rts
000047B6                            
000047B6                            .MoveDown:
000047B6 0668 0100 001E             		addi.w	#$100,_objYVel(a0)			; Move down
000047BC 4E75                       		rts
000047BE                            
000047BE                            .MoveUp:
000047BE 0468 0100 001E             		subi.w	#$100,_objYVel(a0)			; Move up
000047C4 4E75                       		rts
000047C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047C6                            .Indestructable: 
000047C6                            ;---------------------------------------------------------------------------------------------------------------------------------------------------------
000047C6                            .ChkHurt:
000047C6 4A68 0000                  		tst.w	_objInvulTime(a0)			; Are we invulnerable?
000047CA 6600                       		bne.s	.NoHurt				; If so, branch
000047CC 2449                       		movea.l	a1,a2				; Copy harmful object's pointer
000047CE 4EF9 0000 0000             		jmp	ObjPlayer_GetHurt		; Get hurts
000047D4                            
000047D4                            .NoHurt:
000047D4 4E75                       		rts
000047D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047D6                            ; Add a new entry to the collision response list
000047D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047D6                            AddToColResponse:
000047D6 43F8 E7D6                  		lea	collideList.w,a1			; Get collision response list
000047DA 0C51 007E                  		cmpi.w	#$7E,(a1)			; Is it full?
000047DE 6400                       		bhs.s	.End				; If so, branch
000047E0 5451                       		addq.w	#2,(a1)				; Add a new entry
000047E2 D2D1                       		adda.w	(a1),a1				; Get entry pointer
000047E4 3288                       		move.w	a0,(a1)				; Store entry
000047E6                            
000047E6                            .End:
000047E6 4E75                       		rts
000047E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047E8                            ; Save some info in a level (mainly for checkpoints)
000047E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047E8                            ; PARAMETERS:
000047E8                            ;	a0.l	- Object space pointer
000047E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047E8                            ; RETURNS:
000047E8                            ;	Nothing
000047E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047E8                            Level_SaveInfo:
000047E8 31E8 0014 C7B2             		move.w	_objXPos(a0),chkSavedXPos.w		; Save X position
000047EE 31E8 0018 C7B4             		move.w	_objYPos(a0),chkSavedYPos.w		; Save Y position
000047F4 4E75                       		rts
000047F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047F6                            ; Load some info in a level (mainly for checkpoints)
000047F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047F6                            ; PARAMETERS:
000047F6                            ;	a0.l	- Object space pointer
000047F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047F6                            ; RETURNS:
000047F6                            ;	Nothing
000047F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047F6                            Level_LoadSavedInfo:
000047F6 3178 C7B2 0014             		move.w	chkSavedXPos.w,_objXPos(a0)		; Load X position
000047FC 3178 C7B4 0018             		move.w	chkSavedYPos.w,_objYPos(a0)		; Load Y position
00004802 4E75                       		rts
00004804                            ; =========================================================================================================================================================
00004804                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004804                            ; Music IDs
00004804                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004804                            Level_MusicIDs:
00004804 0B0B                       		dc.b	mWWZ, mWWZ
00004806                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004806                            ; Level water heights (-1 for no water)
00004806                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004806                            Level_WatelevelIDs:
00004806                            		;dc.w	$490, -1			; Wacky Workbench
00004806 FFFF FFFF                  		dc.w	-1, -1
0000480A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000480A                            ; Level data pointers
0000480A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000480A                            ; FORMAT:
0000480A                            ;	dc.l	CHUNKS, BLOCKS, TILES, PALETTE
0000480A                            ;	dc.l	FG LAYOUT, BG LAYOUT 
0000480A                            ;	dc.l	OBJECTS, RINGS, COLLISION
0000480A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000480A                            Level_DataPointers:
0000480A 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks, WWZ_Tiles, WWZ_Pal
0000481A 0000 0000 0000 0000        		dc.l	WWZ_FGLayout, WWZ_BGLayout
00004822 0000 0000 0000 0000 0000+  		dc.l	WWZ_Objects, WWZ_Rings, WWZ_Collision
0000482E                            
0000482E 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks, WWZ_Tiles, WWZ_Pal
0000483E 0000 0000 0000 0000        		dc.l	WWZ_FGLayout, WWZ_BGLayout
00004846 0000 0000 0000 0000 0000+  		dc.l	WWZ_Objects, WWZ_Rings, WWZ_Collision
00004852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004852                            ; Size and start position data
00004852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004852                            Level_SizeStartPos:
00004852 3000 0580                  		dc.w	$3000, $580
00004856                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
0000485A 3000 0580                  		dc.w	$3000, $580
0000485E                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004862                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004862                            ; Dynamic events routines
00004862                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004862                            Level_DynEvenRouts:
00004862 0000 0000                  		dc.l	DynEv_WWZ			; Wacky Workbench
00004866 0000 0000                  		dc.l	DynEv_WWZ
0000486A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000486A                            ; Wacky Workbench dynamic events routine
0000486A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000486A                            DynEv_WWZ:
0000486A 31FC 0000 E8CA             		move.w	#0,	maxCamXPos
00004870 31FC 0000 E8CC             		move.w	#0,	maxCamYPos
00004876 7000                       		moveq	#0,d0
00004878 1038 E908                  		move.b	dynEventRout.w,d0
0000487C 303B 0000                  		move.w	.Index(pc,d0.w),d0
00004880 4EFB 0000                  		jmp	.Index(pc,d0.w)
00004884                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004884                            .Index:
00004884 0000                       		dc.w	.WaitBoss-.Index
00004886 0000                       		dc.w	.Done-.Index
00004888                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004888                            .WaitBoss:
00004888                            
00004888                            
00004888                            .Done:
00004888 4E75                       		rts
0000488A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000488A                            ; Palette cycle routines
0000488A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000488A                            Level_PalCycRouts:
0000488A 0000 0000                  		dc.l	PalCycle_WWZ			; Wacky Workbench
0000488E 0000 0000                  		dc.l	PalCycle_WWZ
00004892                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004892                            ; Wacky Workbench palette cycle routine
00004892                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004892                            PalCycle_WWZ:
00004892 4A38 E909                  		tst.b	rFlooactIDive.w		; Is the floor active?
00004896 6600                       		bne.s	.Flash				; If so, branch
00004898                            
00004898 5378 E90A                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
0000489C 6A00                       		bpl.s	.ResetPal			; If it hasn't run out, branch
0000489E 50F8 E909                  		st	rFlooactIDive.w		; Set the floor active flag
000048A2 31FC 00B4 E90A             		move.w	#180,rFloorTimer.w		; Set the floor timer
000048A8                            
000048A8                            .ResetPal:
000048A8 4278 C7D0                  		clr.w	palCycTimer.w		; Reset the palette cycle
000048AC 31FC 0C28 9930             		move.w	#$C28,(paletteBuff+$62).w		; Set the floor color to be deactivated
000048B2 31FC 0E48 98B0             		move.w	#$E48,(paletteBuffAlt+$62).w	; ''
000048B8 4E75                       		rts
000048BA                            
000048BA                            .Flash:
000048BA 5378 E90A                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
000048BE 6A00                       		bpl.s	.UpdatePal			; If it hasn't run out, branch
000048C0 4238 E909                  		clr.b	rFlooactIDive.w		; Clear the floor active flag
000048C4 31FC 001E E90A             		move.w	#30,rFloorTimer.w		; Set the floor timer
000048CA                            
000048CA                            .UpdatePal:
000048CA 5338 C7D0                  		subq.b	#1,palCycTimer.w		; Decrement the palette cycle timer
000048CE 6A00                       		bpl.s	.End				; If it hasn't run out, branch
000048D0 11FC 0001 C7D0             		move.b	#1,palCycTimer.w		; Reset the palette cycle timer
000048D6                            
000048D6 7000                       		moveq	#0,d0
000048D8 1038 C7D1                  		move.b	palCycIndex.w,d0		; Get the palette cycle index
000048DC D040                       		add.w	d0,d0				; Turn into offset
000048DE                            							; Set the floor color
000048DE 31FB 0000 9930             		move.w	PalCyc_WWZFloor(pc,d0.w),(paletteBuff+$62).w
000048E4 31FB 0000 98B0             		move.w	PalCyc_WWZFloorUW(pc,d0.w),(paletteBuffAlt+$62).w
000048EA                            
000048EA 5238 C7D1                  		addq.b	#1,palCycIndex.w		; Increment the palette cycle index
000048EE 0C38 0005 C7D1             		cmpi.b	#5,palCycIndex.w		; Has it reached the end of the cycle?
000048F4 6500                       		bcs.s	.End				; If not, branch
000048F6 4238 C7D1                  		clr.b	palCycIndex.w		; Reset the palette cycle index
000048FA                            
000048FA                            .End:
000048FA 4E75                       		rts
000048FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048FC                            PalCyc_WWZFloor:
000048FC 0C28 0000 00EE 0000 0EEE   		dc.w	$C28, $000, $0EE, $000, $EEE
00004906                            PalCyc_WWZFloorUW:
00004906 0E48 0220 02EE 0220 0EEE   		dc.w	$E48, $220, $2EE, $220, $EEE
00004910                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004910                            ; Animated art routines
00004910                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004910                            Level_AniArtRouts:
00004910 0000 0000                  		dc.l	AniArt_WWZ			; Wacky Workbench
00004914 0000 0000                  		dc.l	AniArt_WWZ
00004918                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004918                            ; Wacky Workbench animated art routine
00004918                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004918                            AniArt_WWZ:
00004918 45FA 0000                  		lea	.AniData(pc),a2			; Tutorial animated art data
0000491C 6000 F86C                  		bra.w	AniArt_D_objAnimmate		; Handle animations
00004920                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004920                            .AniData:
00004920 0002                       		dc.w	2
00004922                            
00004922                            		lvlAniDat 3, ArtUnc_Electricity, $162, 4, 8
00004922 0000 0000                M 	dc.l	(3&$ff)<<24|artunc_electricity
00004926 2C40                     M 	dc.w	(($162&$7ff)<<5)
00004928 0408                     M 	dc.b	4,8
0000492A 0008 1018                  		dc.b	0, 8, $10, $18
0000492E                            
0000492E                            		lvlAniDat 1, ArtUnc_ElectricOrbs, $15E, $E, 4
0000492E 0000 0000                M 	dc.l	(1&$ff)<<24|artunc_electricorbs
00004932 2BC0                     M 	dc.w	(($15e&$7ff)<<5)
00004934 0E04                     M 	dc.b	$e,4
00004936 0004 0400 0404 0804 0408+  		dc.b	0, 4, 4, 0, 4, 4, 8, 4, 4, 8, $C, 4, 4, $C
00004944                            
00004944                            		lvlAniDat 4, ArtUnc_Sirens, $A8, 8, 4
00004944 0000 0000                M 	dc.l	(4&$ff)<<24|artunc_sirens
00004948 1500                     M 	dc.w	(($a8&$7ff)<<5)
0000494A 0804                     M 	dc.b	8,4
0000494C 0004 0408 0C0C 0C0C        		dc.b	0, 4, 4, 8, $C, $C, $C, $C
00004954                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004954                            ; Level drawing initialization and update routines
00004954                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004954                            ; PARAMETERS:
00004954                            ;	a1.l	- Camera RAM
00004954                            ;	a3.l	- Row plane buffer
00004954                            ;	a4.l	- Column plane buffer
00004954                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004954                            ; RETURNS:
00004954                            ;	Nothing
00004954                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004954                            Level_RenderRouts:
00004954 0000 2804                  		dc.l	General_InitFG			; Wacky Workbench
00004958 0000 0000                  		dc.l	WWZ_InitBG
0000495C 0000 2824                  		dc.l	General_UpdateFG
00004960 0000 0000                  		dc.l	WWZ_UpdateBG
00004964 0000 2804                  		dc.l	General_InitFG
00004968 0000 0000                  		dc.l	WWZ_InitBG
0000496C 0000 2824                  		dc.l	General_UpdateFG
00004970 0000 0000                  		dc.l	WWZ_UpdateBG
00004974                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004974                            ; Wacky Workbench background initialization
00004974                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004974                            WWZ_InitBG:
00004974 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground camera RAM
00004978 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
0000497C E440                       		asr.w	#2,d0				; Divide by $20
0000497E 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004982                            
00004982 6100 E1D8                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00004986                            
00004986 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
0000498A 6000 E230                  		bra.w	ScrollSections			; Scroll the planes
0000498E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000498E                            ; Wacky Workbench background update
0000498E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000498E                            WWZ_UpdateBG:
0000498E 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground camera RAM
00004992 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004996 E440                       		asr.w	#2,d0				; Divide by $20
00004998 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
0000499C                            
0000499C 6100 E210                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
000049A0 781F                       		moveq	#(512/16)-1,d4			; Number of blocks per column
000049A2 6100 DF92                  		bsr.w	Level_UpdatePlaney		; Update the plane
000049A6                            
000049A6 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
000049AA 6000 E210                  		bra.w	ScrollSections			; Scroll the planes
000049AE                            ; --------------------------------------------------------------------------------------------------------------------------------------
000049AE                            		scrollInit WWZ_Scroll
000049AE                          M scroll_label	equs	"wwz_scroll"
000049AE 0000                     M wwz_scroll:	dc.w	((wwz_scroll_end-wwz_scroll-2)/6)-1
000049B0                            
000049B0                            		; CEILING LIGHTS
000049B0                            		scrollSection	 48, $80
000049B0 0080 0000 0030           M 	dc.w	$80,0,48
000049B6                            		scrollSection	 32, $60
000049B6 0060 0000 0020           M 	dc.w	$60,0,32
000049BC                            		scrollSection	 32, $50
000049BC 0050 0000 0020           M 	dc.w	$50,0,32
000049C2                            		scrollSection	 24, $40
000049C2 0040 0000 0018           M 	dc.w	$40,0,24
000049C8                            		scrollSection	 24, $38
000049C8 0038 0000 0018           M 	dc.w	$38,0,24
000049CE                            		scrollSection	 16, $30
000049CE 0030 0000 0010           M 	dc.w	$30,0,16
000049D4                            		scrollSection	 16, $2C
000049D4 002C 0000 0010           M 	dc.w	$2c,0,16
000049DA                            		scrollSection	 16, $28
000049DA 0028 0000 0010           M 	dc.w	$28,0,16
000049E0                            		scrollSection	 16, $24
000049E0 0024 0000 0010           M 	dc.w	$24,0,16
000049E6                            		scrollSection	 16, $20
000049E6 0020 0000 0010           M 	dc.w	$20,0,16
000049EC                            
000049EC                            		; BACK WALL
000049EC                            		scrollSection	160, $40
000049EC 0040 0000 00A0           M 	dc.w	$40,0,160
000049F2                            
000049F2                            		; FRONT WALL
000049F2                            		scrollSection	368, $80
000049F2 0080 0000 0170           M 	dc.w	$80,0,368
000049F8                            
000049F8                            		scrollEnd
000049F8                          M wwz_scroll_end:
000049F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F8                            ; Main level PLCs
000049F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F8                            PLC_LevelMain:
000049F8 000A                       		dc.w	$A
000049FA 0000 0000                  		dc.l	ArtKosM_Chkpoint
000049FE AFC0                       		dc.w	$AFC0
00004A00 0000 0000                  		dc.l	ArtKosM_Monitor
00004A04 B100                       		dc.w	$B100
00004A06 0000 0000                  		dc.l	ArtKosM_SpringH
00004A0A B740                       		dc.w	$B740
00004A0C 0000 0000                  		dc.l	ArtKosM_SpringV
00004A10 B940                       		dc.w	$B940
00004A12 0000 0000                  		dc.l	ArtKosM_SpringD
00004A16 BB20                       		dc.w	$BB20
00004A18 0000 0000                  		dc.l	ArtKosM_HUD
00004A1C D000                       		dc.w	$D000
00004A1E 0000 0000                  		dc.l	ArtKosM_WaterSurface
00004A22 D200                       		dc.w	$D200
00004A24 0000 0000                  		dc.l	ArtKosM_SpikesN
00004A28 D500                       		dc.w	$D500
00004A2A 0000 0000                  		dc.l	ArtKosM_SpikesS
00004A2E D580                       		dc.w	$D580
00004A30 0000 0000                  		dc.l	ArtKosM_RingSparkle
00004A34 D700                       		dc.w	$D700
00004A36 0000 0000                  		dc.l	ArtKosM_Explosion
00004A3A D800                       		dc.w	$D800
00004A3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A3C                            ; Level PLCs
00004A3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A3C                            Level_PLCs:
00004A3C 0000 0000                  		dc.l	PLC_WWZ
00004A40 0000 0000                  		dc.l	PLC_WWZ
00004A44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A44                            ; Wacky Workbench PLCs
00004A44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A44                            PLC_WWZ:
00004A44 0000                       		dc.w	0
00004A46 0000 0000                  		dc.l	ArtKosM_Bumper
00004A4A 6B60                       		dc.w	$6B60
00004A4C                            	;	dc.l	ArtKosM_Orbinaut
00004A4C                            	;	dc.w	$71A0
00004A4C                            	;	dc.l	ArtKosM_Diamond
00004A4C                            	;	dc.w	$7580
00004A4C                            	;	dc.l	ArtKosM_CNZBarrel
00004A4C                            	;	dc.w	$7A00
00004A4C                            	;	dc.l	ArtKosM_Slicer
00004A4C                            	;	dc.w	$8000
00004A4C                            	;	dc.l	ArtKosM_ShlCrker
00004A4C                            	;	dc.w	$8400
00004A4C                            	;	dc.l	ArtKosM_Asteron
00004A4C                            	;	dc.w	$8880
00004A4C                            	;	dc.l	ArtKosM_Harpoon
00004A4C                            	;	dc.w	$8A60
00004A4C                            	;	dc.l	ArtKosM_WFZBoss
00004A4C                            	;	dc.w	$9000
00004A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A4C                            ; Object index
00004A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A4C                            Level_ObjIndex:
00004A4C 0000 0000                  		dc.l	ObjEnemy
00004A50 0000 0000                  		dc.l	ObjSpike
00004A54 0000 0000                  		dc.l	ObjSpring
00004A58 0000 0000                  		dc.l	ObjCheckpoint
00004A5C 0000 0000                  		dc.l	ObjNull			;ObjSlicer
00004A60 0000 0000                  		dc.l	ObjNull			;ObjShlCrker
00004A64 0000 0000                  		dc.l	ObjNull			;ObjAsteron
00004A68 0000 0000                  		dc.l	ObjNull			;ObjWFZBoss
00004A6C 0000 0000                  		dc.l	ObjWallSpring
00004A70 0000 0000                  		dc.l	ObjNull			;ObjHarpoon
00004A74 0000 0000                  		dc.l	ObjBallMode
00004A78 0000 0000                  		dc.l	ObjAttack
00004A7C 0000 0000                  		dc.l	ObjNull			;ObjCNZBarrel
00004A80 0000 0000                  		dc.l	ObjNull			;ObjDiamond
00004A84 0000 0000                  		dc.l	ObjNull			;ObjOrbinaut
00004A88                            
00004A88                            ; =========================================================================================================================================================
00004A88                            		include	"Opmodes/Ending/Main.asm"
00004A88                            ; =========================================================================================================================================================
00004A88                            ; End splash screen
00004A88                            ; =========================================================================================================================================================
00004A88                            
00004A88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A88                            Ending:
00004A88 60FE                       		bra.s	Ending
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ;		playSnd	#Mus_Stop, 1			; Stop sound
00004A8A                            ;
00004A8A                            ;		intsOff					; Disable interrupts
00004A8A                            ;
00004A8A                            ;		lea	VDP_CTRL,a5
00004A8A                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00004A8A                            ;		move.w	#$8134,(a5)			; $8134 - Disable display, enable V-INT, enable DMA, V28
00004A8A                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00004A8A                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00004A8A                            ;		move.w	#$9001,(a5)			; $9001 - 64x32 cell plane area
00004A8A                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
00004A8A                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00004A8A                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00004A8A                            ;		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
00004A8A                            ;		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
00004A8A                            ;
00004A8A                            ;		jsr	ClearScreen.w			; Clear screen
00004A8A                            ;
00004A8A                            ;		lea	MapEni_End(pc),a0		; Decompress background mappings
00004A8A                            ;		lea	miscBuff,a1			; Decompress into RAM
00004A8A                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00004A8A                            ;		jsr	EniDec.w			; Decompress!
00004A8A                            ;
00004A8A                            ;		lea	miscBuff,a1			; Load mappings
00004A8A                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
00004A8A                            ;		moveq	#$27,d1				; $28x$1C tiles
00004A8A                            ;		moveq	#$1B,d2				; ''
00004A8A                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00004A8A                            ;		jsr	LoadPlaneMap.w			; Load the map
00004A8A                            ;
00004A8A                            ;		lea	ArtKosM_End,a1			; Load background art
00004A8A                            ;		move.w	#$20,d2				; ''
00004A8A                            ;		jsr	QueueKosMData.w			; ''
00004A8A                            ;
00004A8A                            ;.WaitPLCs:
00004A8A                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00004A8A                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00004A8A                            ;		jsr	VSync_Routine.w			; V-SYNC
00004A8A                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00004A8A                            ;		tst.b	kosMModules.w			; Are there still modules left?
00004A8A                            ;		bne.s	.WaitPLCs			; If so, branch
00004A8A                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00004A8A                            ;		jsr	VSync_Routine.w			; V-SYNC
00004A8A                            ;
00004A8A                            ;		lea	SampleList+$F0,a3
00004A8A                            ;		jsr	PlayDAC1
00004A8A                            ;
00004A8A                            ;		lea	Pal_End(pc),a0			; Load palette to target buffer
00004A8A                            ;		move.w	#(Pal_End_End-Pal_End)>>1-1,d0	; ''
00004A8A                            ;		jsr	LoadPalette.w			; ''
00004A8A                            ;
00004A8A                            ;		displayOn
00004A8A                            ;
00004A8A                            ;.Loop:
00004A8A                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
00004A8A                            ;		jsr	VSync_Routine.w			; ''
00004A8A                            ;		bra.s	.Loop
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ; Art
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ;ArtKosM_End:
00004A8A                            ;		incbin	"Ending/Data/Art - Background.kosm.bin"
00004A8A                            ;		even
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ; Plane mappings
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ;MapEni_End:
00004A8A                            ;		incbin	"Ending/Data/Map - Background.eni.bin"
00004A8A                            ;		even
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ; Palette
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ;Pal_End:
00004A8A                            ;		incbin	"Ending/Data/Palette.pal.bin"
00004A8A                            ;Pal_End_End:
00004A8A                            ;		even
00004A8A                            ; =========================================================================================================================================================
00004A8A                            
00004A8A                            ; =========================================================================================================================================================
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ; Object Code
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            ObjNull:
00004A8A 4EF8 1A4C                  		jmp	DeleteObject
00004A8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8E                            		include	"Objects/Player/Code.asm"		; Player object
00004A8E                            ; =========================================================================================================================================================
00004A8E                            ; Sonic object
00004A8E                            ; =========================================================================================================================================================
00004A8E =00000300                  TOP_SPD		EQU	$300				; Top speed
00004A8E =0000000C                  ACC_SPD		EQU	$C				; Acceleration
00004A8E =00000080                  DEC_SPD		EQU	$80				; Deceleration
00004A8E =00000180                  JUMP_HEIGHT	EQU	$180				; Jump height
00004A8E =00000180                  MIN_JMP_HEIGHT	EQU	$180				; Minimum jump height
00004A8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8E                            		rsset	_objLvlSSTs
00004A8E =00000030                  _objInitColH	rs.b	1				; Initial collision height
00004A8E =00000031                  _objInitColW	rs.b	1				; Initial collision width
00004A8E =00000032                  _objTopSolid	rs.b	1				; Top solid bit
00004A8E =00000033                  _objLRBSolid	rs.b	1				; LRB solid bit
00004A8E =00000034                  _objTopSpd	rs.w	1				; Top speed
00004A8E =00000036                  _objAccel	rs.w	1				; Acceleration
00004A8E =00000038                  _objDecel	rs.w	1				; Deceleration
00004A8E =0000003A                  _objFlipDir	rs.w	0				; Flip direction
00004A8E =0000003A                  _objGVel	rs.w	1				; Ground velocity
00004A8E =0000003C                  _objInteract	rs.w	1				; Interacted object space pointer
00004A8E =0000003E                  _objAirTimer	rs.b	1				; Air timer
00004A8E =0000003F                  _objMoveLock	rs.b	1				; Move lock timer
00004A8E =00000040                  _objJumping	rs.b	1				; Jumping flag
00004A8E =00000041                  _objAngle	rs.b	1				; Angle
00004A8E =00000042                  _objInvulTime	rs.b	1				; Invulnerability timer
00004A8E =00000043                  _objDeathTimer	rs.b	1				; Death timer
00004A8E =00000044                  _objScrlDelay	rs.b	1				; Look up and down scroll delay counter
00004A8E =00000045                  _objDashFlag	rs.b	1				; Dash flags
00004A8E =00000046                  _objDashTimer	rs.b	1				; Dash timer
00004A8E =00000047                  _objFlipAngle	rs.b	1				; Flip angle about the X axis
00004A8E =00000048                  _objFlipTurned	rs.b	1				; Inverted flip flag
00004A8E =00000049                  _objFlipRemain	rs.b	1				; Remaining flips to do
00004A8E =0000004A                  _objFlipSpeed	rs.b	1				; Flip speed
00004A8E =0000004B                  _objBallMode	rs.b	1				; Ball mode flag
00004A8E =0000004C                  _objHangAniTime	rs.b	1				; Hang animation timer
00004A8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8E                            ObjPlayer:
00004A8E 7000                       		moveq	#0,d0
00004A90 1028 0025                  		move.b	_objRoutine(a0),d0			; Get routine ID
00004A94 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00004A98                            	nextObject
00004A98 3068 0004                M 	movea.w	_objnext(a0),a0
00004A9C 2250                     M 	move.l	_objaddress(a0),a1
00004A9E 4ED1                     M 	jmp	(a1)
00004AA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA0                            .Index:
00004AA0 6000 0000                  		bra.w	ObjPlayer_Init			; Initialization(00)
00004AA4 6000 0000                  		bra.w	ObjPlayer_Main			; Main		(04)
00004AA8 6000 0000                  		bra.w	ObjPlayer_Hurt			; Hurt		(08)
00004AAC 6000 0000                  		bra.w	ObjPlayer_Dead			; Dead		(0C)
00004AB0 6000 0000                  		bra.w	ObjPlayer_Gone			; Gone		(10)
00004AB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AB4                            ; Initialization routine
00004AB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AB4                            ObjPlayer_Init:
00004AB4 5828 0025                  		addq.b	#4,_objRoutine(a0)			; Next routine
00004AB8                            
00004AB8 117C 0007 002C             		move.b	#7,_objColW(a0)			; Collision width
00004ABE 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Collision height
00004AC4 1168 002C 0031             		move.b	_objColW(a0),_objInitColW(a0)		; Set initial collision width
00004ACA 1168 002D 0030             		move.b	_objColH(a0),_objInitColH(a0)		; Set initial collision height
00004AD0 217C 0000 0000 0010        		move.l	#Map_ObjPlayer,_objMapping(a0)		; Mappings
00004AD8 317C 0780 000E             		move.w	#$780,_objVRAM(a0)			; Sprite tile properties
00004ADE                            	displaySprite	2,a0,a1,0			; Priority
00004ADE 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00004AE4 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00004AE8 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00004AEC 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00004AF0 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00004AF4                          M .no_208
00004AF4 117C 0018 0017             		move.b	#$18,_objDrawW(a0)			; Sprite width
00004AFA 117C 0018 001B             		move.b	#$18,_objDrawH(a0)			; Sprite height
00004B00 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00004B06                            
00004B06 117C 000C 0032             		move.b	#$C,_objTopSolid(a0)		; Top solid bit
00004B0C 117C 000D 0033             		move.b	#$D,_objLRBSolid(a0)		; LRB solid bit
00004B12 117C 001E 003E             		move.b	#$1E,_objAirTimer(a0)		; Set air timer
00004B18 50D0                       		st	_objPrevDPLC(a0)			; Reset saved DPLC frame
00004B1A 4228 0049                  		clr.b	_objFlipRemain(a0)			; No flips remaining
00004B1E 117C 0004 004A             		move.b	#4,_objFlipSpeed(a0)		; Flip speed
00004B24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B24                            ; Main routine
00004B24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B24                            ObjPlayer_Main:
00004B24 4A38 C76A                  		tst.b	moveCheat.w
00004B28 6700                       		beq.s	.NoPlacementEnter
00004B2A 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00004B30 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00004B32 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00004B38 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00004B3E 4E75                       		rts
00004B40                            
00004B40                            .NoPlacementEnter:
00004B40 0828 0002 000C             		btst	#2,_objFlags(a0)			; Are the controls locked?
00004B46 6600                       		bne.s	.Update				; If so, branch
00004B48 31F8 C742 E8DE             		move.w	ctrlDataP1.w,plrCtrlData.w		; Set the player's control data
00004B4E                            
00004B4E                            .Update:
00004B4E                            	;	btst	#1,_objStatus(a0)
00004B4E                            	;	bne.s	.NotOnGround
00004B4E                            
00004B4E                            ;.NotOnGround:
00004B4E 6100 0000                  		bsr.w	ObjPlayer_Water			; Handle Sonic in water
00004B52 6100 0000                  		bsr.w	ObjPlayer_GetPhysics		; Update Sonic's physics
00004B56 6100 0000                  		bsr.w	ObjPlayer_DoModes		; Do modes
00004B5A 6100 0000                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00004B5E 4EB8 46E2                  		jsr	PlayerDoObjCollision		; Do object collision
00004B62                            
00004B62 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00004B66 6100 0000                  		bsr.w	ObjPlayer_Display		; Display sprite
00004B6A 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00004B6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6E                            ; Handle the extended camera
00004B6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6E                            ObjPlayer_ExtendedCam:
00004B6E 3238 E8D6                  		move.w	panCamXPos.w,d1		; Get camera X center
00004B72 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
00004B76 6A00                       		bpl.s	.PosGVel			; Get absolute value
00004B78 4440                       		neg.w	d0				; ''
00004B7A                            
00004B7A                            .PosGVel:
00004B7A 0C40 0600                  		cmpi.w	#$600,d0			; Is Sonic going at 6 pixels/frame?
00004B7E 6500                       		bcs.s	.ResetXShift			; If not, branch
00004B80 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving right?
00004B84 6A00                       		bpl.s	.MoveRight			; If so, branch
00004B86 5441                       		addq.w	#2,d1				; Move right
00004B88 0C41 00E0                  		cmpi.w	#$E0,d1				; Cap it
00004B8C 6500                       		bcs.s	.SetShift			; ''
00004B8E 323C 00E0                  		move.w	#$E0,d1				; ''
00004B92 6000                       		bra.s	.SetShift			; Continue
00004B94                            
00004B94                            .MoveRight:
00004B94 5541                       		subq.w	#2,d1				; Move left
00004B96 0C41 0060                  		cmpi.w	#$60,d1				; Cap it
00004B9A 6400                       		bcc.s	.SetShift			; ''
00004B9C 323C 0060                  		move.w	#$60,d1				; ''
00004BA0 6000                       		bra.s	.SetShift			; Continue
00004BA2                            
00004BA2                            .ResetXShift:
00004BA2 0C41 00A0                  		cmpi.w	#$A0,d1				; Are we already back at the center?
00004BA6 6700                       		beq.s	.SetShift			; If so, branch
00004BA8 6400                       		bcc.s	.ReduceShift			; If we have to go back left, branch
00004BAA 5441                       		addq.w	#2,d1				; Move back right
00004BAC 6000                       		bra.s	.SetShift			; Continue
00004BAE                            
00004BAE                            .ReduceShift:
00004BAE 5541                       		subq.w	#2,d1				; Move back left
00004BB0                            
00004BB0                            .SetShift:
00004BB0 31C1 E8D6                  		move.w	d1,panCamXPos.w		; Set camera X center
00004BB4 4E75                       		rts
00004BB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BB6                            ; Update Sonic's physics
00004BB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BB6                            ObjPlayer_GetPhysics:
00004BB6 7000                       		moveq	#0,d0
00004BB8 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00004BBE 6700                       		beq.s	.GetOffset			; If not, branch
00004BC0 7008                       		moveq	#8,d0				; Set the underwater bit
00004BC2                            
00004BC2                            .GetOffset:
00004BC2 43FB 0000                  		lea	ObjPlayer_Physics(pc,d0.w),a1	; Get pointer to correct physics values
00004BC6 2159 0034                  		move.l	(a1)+,_objTopSpd(a0)		; Set top speed and acceleration
00004BCA 3151 0038                  		move.w	(a1),_objDecel(a0)			; Set deceleration
00004BCE 4E75                       		rts
00004BD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD0                            ; Physics values
00004BD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD0                            ; FORMAT:
00004BD0                            ;	dc.w	TOP SPEED, ACCELERATION, DECELERATION, 0
00004BD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD0                            ObjPlayer_Physics:
00004BD0 0300 000C 0080 0000        		dc.w	TOP_SPD,     ACC_SPD,     DEC_SPD,     0; Normal
00004BD8 0180 0006 0040 0000        		dc.w	TOP_SPD/2,   ACC_SPD/2,   DEC_SPD/2,   0; Underwater
00004BE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BE0                            ; Handle Sonic in the water
00004BE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BE0                            ObjPlayer_Water:
00004BE0 4A38 E8FE                  	tst.b	lvlHasWater.w			; Is there water in the level?
00004BE4 6600                       	bne.s	.HandleWater			; If so, branch
00004BE6                            
00004BE6                            .End:
00004BE6 4E75                       	rts
00004BE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BE8                            .HandleWater:
00004BE8 3038 E900                  		move.w	waterYPos.w,d0		; Get water height
00004BEC B068 0018                  		cmp.w	_objYPos(a0),d0			; Is Lover in the water?
00004BF0 6C00                       		bge.s	.NotInWater			; If not, branch
00004BF2                            
00004BF2 08E8 0006 0028             		bset	#6,_objStatus(a0)			; Set the "in water" flag
00004BF8 66EC                       		bne.s	.End				; If Lover is already in the water, branch
00004BFA                            
00004BFA E0E8 001C                  		asr.w	_objXVel(a0)			; Make Lover move slower
00004BFE E0E8 001E                  		asr.w	_objYVel(a0)
00004C02 E0E8 001E                  		asr.w	_objYVel(a0)
00004C06 67DE                       		beq.s	.End				; If a splash doesn't need to be created, branch
00004C08                            
00004C08                            		playSnd	#sSplash, 2			; Play splash sound
00004C08 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00004C0E 4E75                       		rts
00004C10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C10                            .NotInWater:
00004C10 08A8 0006 0028             		bclr	#6,_objStatus(a0)			; Clear "in water" flag
00004C16 67CE                       		beq.s	.End				; If Lover was already out of the water, branch
00004C18                            
00004C18 0C28 0010 0025             		cmpi.b	#$10,_objRoutine(a0)			; Is Lover falling back from getting hurt?
00004C1E 6700                       		beq.s	.ChkSplash			; If so, branch
00004C20 E1E8 001E                  		asl	_objYVel(a0)			; Make Lover move faster vertically
00004C24                            
00004C24                            .ChkSplash:
00004C24 4A68 001E                  		tst.w	_objYVel(a0)			; Does a splash need to be created?
00004C28 67BC                       		beq.s	.End				; If not, branch
00004C2A                            
00004C2A 0C68 F000 001E             		cmpi.w	#-$1000,_objYVel(a0)		; Is Lover moving more than -$10 pixels per frame?
00004C30 6E00                       		bgt.s	.PlaySplashSnd			; If not, branch
00004C32 317C F000 001E             		move.w	#-$1000,_objYVel(a0)		; Cap the speed
00004C38                            
00004C38                            .PlaySplashSnd:
00004C38                            		playSnd	#sSplash, 2			; Play splash sound
00004C38 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00004C3E 4E75                       		rts
00004C40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C40                            ; Do Sonic's modes
00004C40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C40                            ObjPlayer_DoModes:
00004C40 0828 0000 000C             		btst	#0,_objFlags(a0)			; Is running Sonic's mode disabled?
00004C46 6600                       		bne.s	.NoMode				; If so, branch
00004C48                            
00004C48 7000                       		moveq	#0,d0
00004C4A 1028 0028                  		move.b	_objStatus(a0),d0			; Get status
00004C4E 0240 0006                  		andi.w	#6,d0				; Only get mode bits
00004C52 D040                       		add.w	d0,d0
00004C54 4EBB 0000                  		jsr	ObjPlayer_Modes(pc,d0.w)	; Jump to the right routine
00004C58                            
00004C58 6100 FF14                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
00004C5C 6100 0000                  		bsr.w	ObjPlayer_ChkBounce		; Check for bouncy floor collision
00004C60 6100 0000                  		bsr.w	ObjPlayer_ChkHang		; Check for hanging
00004C64 6000 0000                  		bra.w	ObjPlayer_ChkElectric		; Check for electricity
00004C68                            
00004C68                            .NoMode:
00004C68 4E75                       		rts
00004C6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C6A                            ; Sonic's modes
00004C6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C6A                            ObjPlayer_Modes:
00004C6A 6000 0000                  		bra.w	ObjPlayer_MdGround		; Ground
00004C6E 6000 0000                  		bra.w	ObjPlayer_MdAir			; Air
00004C72 6000 0000                  		bra.w	ObjPlayer_MdRoll		; Roll
00004C76 6000 0000                  		bra.w	ObjPlayer_MdJump		; Jumping
00004C7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C7A                            ; Ground mode
00004C7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C7A                            ObjPlayer_MdGround:
00004C7A                            ;		bsr.w	ObjPlayer_Peelout		; Handle the peelout
00004C7A                            ;		bsr.w	ObjPlayer_Spindash		; Handle the spindash
00004C7A 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00004C7E 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
00004C82                            ;		bsr.w	ObjPlayer_ChkRoll		; Check for rolling
00004C82 6100 0000                  		bsr.w	ObjPlayer_MoveGround		; Do movement on the ground
00004C86 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00004C8A 4EB8 3314                  		jsr	PlayerAnglePos			; Update position and angle along the ground
00004C8E                            
00004C8E 6100 0000                  		bsr.w	ObjPlayer_SlopePush		; Affect Sonic's speed on a slope
00004C92 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
00004C96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C96                            ; Misc. updates
00004C96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C96                            ObjPlayer_MiscUpdates:
00004C96 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer finished?
00004C9A 6700                       		beq.s	.NoMoveLock			; If so, branch
00004C9C 5328 003F                  		subq.b	#1,_objMoveLock(a0)		; Decrement the timer
00004CA0                            
00004CA0                            .NoMoveLock:
00004CA0 4EB8 302C                  		jsr	sub_F846
00004CA4 4A41                       		tst.w	d1
00004CA6 6B00 0000                  		bmi.w	ObjPlayer_GetKilled
00004CAA 4EB8 32BC                  		jsr	PlayerChkLeftWallDist		; Check for left wall collision
00004CAE 4A41                       		tst.w	d1				; Has Sonic entered the wall?
00004CB0 6A00                       		bpl.s	.ChkRight			; If not, branch
00004CB2 9368 0014                  		sub.w	d1,_objXPos(a0)			; Fix Sonic's X position
00004CB6                            
00004CB6                            .ChkRight:
00004CB6 4EB8 3140                  		jsr	PlayerChkRightWallDist		; Check for right wall collision
00004CBA 4A41                       		tst.w	d1				; Has Sonic entered the wall?
00004CBC 6A00                       		bpl.s	.End				; If not, branch
00004CBE D368 0014                  		add.w	d1,_objXPos(a0)			; Fix Sonic's X position
00004CC2                            
00004CC2                            .End:
00004CC2 4E75                       		rts
00004CC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CC4                            ; Air and jump modes
00004CC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CC4                            ObjPlayer_MdJump:
00004CC4                            ObjPlayer_MdAir:
00004CC4 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00004CC8 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
00004CCC                            
00004CCC 4268 003C                  		clr.w	_objInteract(a0)			; Sonic cannot be interacting with objects while in midair
00004CD0 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; ''
00004CD6                            
00004CD6 0828 0003 000C             		btst	#3,_objFlags(a0)			; Is Sonic hanging?
00004CDC 6700                       		beq.s	.DoModes			; If not, branch
00004CDE 6100 0000                  		bsr.w	ObjPlayer_Hang			; Hang
00004CE2 6000                       		bra.s	.DoCol				; Continue
00004CE4                            
00004CE4                            .DoModes:
00004CE4 6100 0000                  		bsr.w	ObjPlayer_JumpHeight		; Handle jump height
00004CE8 6100 0000                  		bsr.w	ObjPlayer_MoveAir		; Do movement
00004CEC 4EB8 1D42                  		jsr	ObjectMoveAndFall.w		; Allow movement
00004CF0 0C68 1000 001E             		cmpi.w	#$1000,_objYVel(a0)		; Is Sonic moving down too fasr?
00004CF6 6F00                       		ble.s	.NoCap				; If not, branch
00004CF8 317C 1000 001E             		move.w	#$1000,_objYVel(a0)		; Cap the downward speed
00004CFE                            
00004CFE                            .NoCap:
00004CFE 6100 0000                  		bsr.w	ObjPlayer_JumpAngle		; Reset Sonic's angle in mid air
00004D02                            
00004D02                            .DoCol:
00004D02 0828 0006 0028             		btst	#6,_objStatus(a0)
00004D08 6700                       		beq.s	.NoWater
00004D0A 0468 0028 001E             		subi.w	#$28,_objYVel(a0)
00004D10                            
00004D10                            .NoWater:
00004D10 4EB8 2C98                  		jsr	PlayerChkCollision		; Check for level collision
00004D14 6080                       		bra.s	ObjPlayer_MiscUpdates
00004D16                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D16                            ; Roll mode
00004D16                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D16                            ObjPlayer_MdRoll:
00004D16 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00004D1A 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
00004D1E                            
00004D1E                            .NoJump:
00004D1E 6100 0000                  		bsr.w	ObjPlayer_RollSlopePush		; Push Sonic on a slope while rolling
00004D22 6100 0000                  		bsr.w	ObjPlayer_MoveRoll		; Do movement
00004D26 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00004D2A 4EB8 3314                  		jsr	PlayerAnglePos			; Update position and angle along the ground
00004D2E                            
00004D2E 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
00004D32 6000 FF62                  		bra.w	ObjPlayer_MiscUpdates		; Do misc. updates
00004D36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D36                            ; Do movement on the ground
00004D36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D36                            ObjPlayer_MoveGround:
00004D36 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
00004D3A 3A28 0036                  		move.w	_objAccel(a0),d5			; Get acceleration
00004D3E 3828 0038                  		move.w	_objDecel(a0),d4			; Get deceleration
00004D42                            
00004D42 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer active?
00004D46 6600 0000                  		bne.w	.ResetScr			; If so, branch
00004D4A                            
00004D4A 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left held?
00004D50 6700                       		beq.s	.NotLeft			; If so, branch
00004D52 6100 0000                  		bsr.w	ObjPlayer_MoveLeft		; Move left
00004D56                            
00004D56                            .NotLeft:
00004D56 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right held?
00004D5C 6700                       		beq.s	.NotRight			; If so, branch
00004D5E 6100 0000                  		bsr.w	ObjPlayer_MoveRight		; Move right
00004D62                            
00004D62                            .NotRight:
00004D62 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00004D66 0600 0020                  		addi.b	#$20,d0				; Shift it
00004D6A 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00004D6E 6600 0000                  		bne.w	.ResetScr			; If Sonic is not on the floor, branch
00004D72 4A68 003A                  		tst.w	_objGVel(a0)			; Has Sonic already been halted?
00004D76 6600 0000                  		bne.w	.ResetScr			; If not, branch
00004D7A                            
00004D7A 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
00004D80 117C 0005 0020             		move.b	#5,_objAnim(a0)			; Set to ducking animation
00004D86                            
00004D86 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is Sonic standing on an object?
00004D8C 6700 0000                  		beq.w	.ChkBalance			; If not, branch
00004D90 3268 003C                  		movea.w	_objInteract(a0),a1		; Get interacted object
00004D94 4A29 0028                  		tst.b	_objStatus(a1)			; Is Sonic standing on it?
00004D98 6B00                       		bmi.s	.ChkLookUp			; If not, branch
00004D9A 7200                       		moveq	#0,d1
00004D9C 1229 002C                  		move.b	_objColW(a1),d1			; Get width of object
00004DA0 3401                       		move.w	d1,d2				; Copy it
00004DA2 D442                       		add.w	d2,d2				; Double the copy
00004DA4 5942                       		subq.w	#4,d2				; Subtract 4 from the copy
00004DA6 D268 0014                  		add.w	_objXPos(a0),d1			; Add Sonic's X position
00004DAA 9269 0014                  		sub.w	_objXPos(a1),d1			; Subtract the object's X position
00004DAE 0C41 0004                  		cmpi.w	#4,d1				; Is Sonic balancing on the left side of it?
00004DB2 6D00                       		blt.s	.BalanceOnObjLeft		; If so, branch
00004DB4 B242                       		cmp.w	d2,d1				; Is Sonic balacning on the right side of it?
00004DB6 6C00                       		bge.s	.BalanceOnObjRight		; If so, branch
00004DB8 6000                       		bra.s	.ChkLookUp			; Continue
00004DBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DBA                            .ChkBalance:
00004DBA 4EB8 3002                  		jsr	PlayerChkFloorDist		; Get floor distance
00004DBE 0C41 000C                  		cmpi.w	#$C,d1				; Is Sonic balancing?
00004DC2 6D00                       		blt.s	.ChkLookUp			; If not, branch
00004DC4 0C28 0003 002E             		cmpi.b	#3,_objNextTilt(a0)		; Is Sonic balancing on the right side?
00004DCA 6600                       		bne.s	.ChkLeftBalance			; If not, branch
00004DCC                            
00004DCC                            .BalanceOnObjRight:
00004DCC 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
00004DD2 6000                       		bra.s	.SetBalanceAnim			; Set the animation
00004DD4                            
00004DD4                            .ChkLeftBalance:
00004DD4 0C28 0003 002F             		cmpi.b	#3,_objTilt(a0)			; Is Sonic balancing on the left side?
00004DDA 6600                       		bne.s	.ChkLookUp			; If not, branch
00004DDC                            
00004DDC                            .BalanceOnObjLeft:
00004DDC 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
00004DE2                            
00004DE2                            .SetBalanceAnim:
00004DE2 117C 0006 0020             		move.b	#6,_objAnim(a0)			; Set balancing animation
00004DE8 6000                       		bra.s	.ResetScr			; Continue
00004DEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DEA                            .ChkLookUp:
00004DEA 0838 0000 E8DE             		btst	#0,plrCtrlHold.w		; Is the up button being held?
00004DF0 6700                       		beq.s	.ChkDown			; If not, branch
00004DF2 117C 0007 0020             		move.b	#7,_objAnim(a0)			; Set to looking up animation
00004DF8                            
00004DF8 5228 0044                  		addq.b	#1,_objScrlDelay(a0)		; Increment scroll delay counter
00004DFC 0C28 0078 0044             		cmpi.b	#$78,_objScrlDelay(a0)		; Has it reached $78?
00004E02 6500                       		blo.s	.ResetScrPart2			; If not, branch
00004E04 117C 0078 0044             		move.b	#$78,_objScrlDelay(a0)		; Cap at $78
00004E0A 0C78 00C8 E8D8             		cmpi.w	#200,panCamYPos.w		; Has the camera finished scrolling?
00004E10 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
00004E12 5478 E8D8                  		addq.w	#2,panCamYPos.w		; Scroll the camera
00004E16 6000                       		bra.s	.UpdateSpdOnGround		; Continue
00004E18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E18                            .ChkDown:
00004E18 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is the down button being held?
00004E1E 6700                       		beq.s	.ResetScr			; If not, branch
00004E20 117C 0008 0020             		move.b	#8,_objAnim(a0)			; Set to ducking animation
00004E26                            
00004E26 5228 0044                  		addq.b	#1,_objScrlDelay(a0)		; Increment scroll delay counter
00004E2A 0C28 0078 0044             		cmpi.b	#$78,_objScrlDelay(a0)		; Has it reached $78?
00004E30 6500                       		blo.s	.ResetScrPart2			; If not, branch
00004E32 117C 0078 0044             		move.b	#$78,_objScrlDelay(a0)		; Cap at $78
00004E38 0C78 0008 E8D8             		cmpi.w	#8,panCamYPos.w		; Has the camera finished scrolling?
00004E3E 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
00004E40 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera
00004E44 6000                       		bra.s	.UpdateSpdOnGround		; Continue
00004E46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E46                            .ResetScr:
00004E46 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00004E4A                            
00004E4A                            .ResetScrPart2:
00004E4A 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00004E50 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
00004E52 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00004E54 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00004E58                            
00004E58                            .ScrollUp:
00004E58 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00004E5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E5C                            .UpdateSpdOnGround:
00004E5C 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
00004E60 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
00004E64 6600                       		bne.s	.ApplySpeed			; If so, branch
00004E66                            
00004E66 3028 003A                  		move.w	_objGVel(a0),d0			; Get current ground velocity
00004E6A 6700                       		beq.s	.ApplySpeed			; If it's already 0, branch
00004E6C 6B00                       		bmi.s	.SettleLeft			; Settle left if going left
00004E6E                            
00004E6E                            .SettleRight:
00004E6E 9045                       		sub.w	d5,d0				; Slow down
00004E70 6A00                       		bpl.s	.SetSpeed			; If it's not done, branch
00004E72 7000                       		moveq	#0,d0				; Stop the movement
00004E74 6000                       		bra.s	.SetSpeed			; Continue
00004E76                            
00004E76                            .SettleLeft:
00004E76 D045                       		add.w	d5,d0				; Slow down
00004E78 6B00                       		bmi.s	.SetSpeed			; If it's not done, branch
00004E7A 7000                       		moveq	#0,d0				; Stop the movement
00004E7C                            
00004E7C                            .SetSpeed:
00004E7C 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
00004E80                            
00004E80                            .ApplySpeed:
00004E80 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00004E84 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
00004E88 C3E8 003A                  		muls.w	_objGVel(a0),d1			; Multiply cosine with ground velocity
00004E8C C1E8 003A                  		muls.w	_objGVel(a0),d0			; Multiply sine with ground velocity
00004E90 E081                       		asr.l	#8,d1				; Shift the values over
00004E92 E080                       		asr.l	#8,d0				; ''
00004E94 3141 001C                  		move.w	d1,_objXVel(a0)			; Set the X velocity
00004E98 3140 001E                  		move.w	d0,_objYVel(a0)			; Set the Y velocity
00004E9C                            
00004E9C                            ObjPlayer_CheckWalls:
00004E9C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00004EA0 0200 003F                  		andi.b	#$3F,d0				; Is Sonic on an angle?
00004EA4 6700                       		beq.s	.Skip				; If not, branch
00004EA6 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00004EAA 0600 0040                  		addi.b	#$40,d0				; Is Sonic on an upwards wall or ceiling?
00004EAE 6B00                       		bmi.s	.End				; If so, branch
00004EB0                            
00004EB0                            .Skip:
00004EB0 7240                       		moveq	#$40,d1				; If going left, make the modifier $40
00004EB2 4A68 003A                  		tst.w	_objGVel(a0)			; Check speed
00004EB6 6700                       		beq.s	.End				; Branch if not moving
00004EB8 6B00                       		bmi.s	.CheckPush			; Branch if going left
00004EBA 4441                       		neg.w	d1				; Negate the modifier
00004EBC                            
00004EBC                            .CheckPush:
00004EBC 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00004EC0 D001                       		add.b	d1,d0				; Add modifier
00004EC2                            		push.w	d0				; Save it
00004EC2 3F00                     M 	move.w	d0,-(sp)
00004EC4 4EB8 2ECA                  		jsr	PlayerCalcRoomInFront		; Calculate the distance in front of Sonic
00004EC8                            		pop.w	d0				; Restore angle
00004EC8 301F                     M 	move.w	(sp)+,d0
00004ECA 4A41                       		tst.w	d1				; Is Sonic pushing into anything?
00004ECC 6A00                       		bpl.s	.End				; If not, branch
00004ECE E141                       		asl.w	#8,d1				; Shift distance inside the collision
00004ED0 0600 0020                  		addi.b	#$20,d0				; Add $20 to the angle
00004ED4 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic pushing on a ceiling?
00004ED8 6700                       		beq.s	.PushCeiling			; If so, branch
00004EDA 0C00 0040                  		cmpi.b	#$40,d0				; Is Sonic pushing on a right wall?
00004EDE 6700                       		beq.s	.PushRightWall			; If so, branch
00004EE0 0C00 0080                  		cmpi.b	#$80,d0				; Is Sonic pushing on a floor?
00004EE4 6700                       		beq.s	.PushFloor			; If so, branch
00004EE6 D368 001C                  		add.w	d1,_objXVel(a0)			; Push out to the right
00004EEA 4268 003A                  		clr.w	_objGVel(a0)			; Stop moving
00004EEE 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing right?
00004EF4 6600                       		bne.s	.End				; If not, branch
00004EF6 08E8 0005 0028             		bset	#5,_objStatus(a0)			; Start pushing
00004EFC 4E75                       		rts
00004EFE                            
00004EFE                            .PushFloor:
00004EFE 9368 001E                  		sub.w	d1,_objYVel(a0)			; Push out upwards
00004F02 4E75                       		rts
00004F04                            
00004F04                            .PushRightWall:
00004F04 9368 001C                  		sub.w	d1,_objXVel(a0)			; Push out to the left
00004F08 4268 003A                  		clr.w	_objGVel(a0)			; Stop moving
00004F0C 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00004F12 6700                       		beq.s	.End				; If not, branch
00004F14 08E8 0005 0028             		bset	#5,_objStatus(a0)			; Start pushing
00004F1A 4E75                       		rts
00004F1C                            
00004F1C                            .PushCeiling:
00004F1C D368 001E                  		add.w	d1,_objYVel(a0)			; Push out downwards
00004F20                            
00004F20                            .End:
00004F20 4E75                       		rts
00004F22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F22                            ; Move left on the ground
00004F22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F22                            ObjPlayer_MoveLeft:
00004F22 3028 003A                  		move.w	_objGVel(a0),d0			; Get current speed
00004F26 6700                       		beq.s	.SetFlip			; If not moving yet, branch
00004F28 6A00                       		bpl.s	.Skid				; If moving right, check for skidding
00004F2A                            
00004F2A                            .SetFlip:
00004F2A 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Set flip flag
00004F30 6600                       		bne.s	.MoveLeft			; If it was already set, branch
00004F32 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
00004F38 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00004F3E                            
00004F3E                            .MoveLeft:
00004F3E 9045                       		sub.w	d5,d0				; Subtract acceleration
00004F40 3206                       		move.w	d6,d1				; Get top speed
00004F42 4441                       		neg.w	d1				; Negate it
00004F44 B041                       		cmp.w	d1,d0				; Is Sonic moving faster than the top speed?
00004F46 6E00                       		bgt.s	.SetSpeed			; If not, branch
00004F48 D045                       		add.w	d5,d0				; Add acceleration back
00004F4A B041                       		cmp.w	d1,d0				; Is Sonic still moving faster than the top speed?
00004F4C 6F00                       		ble.s	.SetSpeed			; If not, branch
00004F4E 3001                       		move.w	d1,d0				; Cap at the top speed
00004F50                            
00004F50                            .SetSpeed:
00004F50 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
00004F54 4228 0020                  		clr.b	_objAnim(a0)			; Set animation to moving
00004F58                            
00004F58                            .End:
00004F58 4E75                       		rts
00004F5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F5A                            .Skid:
00004F5A 9044                       		sub.w	d4,d0				; Subtract deceleration
00004F5C 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
00004F5E                            
00004F5E                            .Compare:
00004F5E B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
00004F60 6C00                       		bge.s	.SetSkidSpeed			; If not branch
00004F62 7080                       		moveq	#-$80,d0			; Set speed to -$80
00004F64                            
00004F64                            .SetSkidSpeed:
00004F64 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
00004F68 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00004F6C 0600 0020                  		addi.b	#$20,d0				; Shift it
00004F70 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
00004F74 66E2                       		bne.s	.End				; If so, branch
00004F76 0C40 0400                  		cmpi.w	#$400,d0			; Is Sonic's speed at least 4 pixels per frame?
00004F7A 6DDC                       		blt.s	.End				; If not, branch
00004F7C 117C 000D 0020             		move.b	#$D,_objAnim(a0)			; Set animation to skidding
00004F82 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Clear flip flag
00004F88                            		playSnd	#sSkid, 2			; Play skid sound
00004F88 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
00004F8E 4E75                       		rts
00004F90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F90                            ; Move right on the ground
00004F90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F90                            ObjPlayer_MoveRight:
00004F90 3028 003A                  		move.w	_objGVel(a0),d0			; Get current speed
00004F94 6B00                       		bmi.s	.Skid				; If it's negative, skid
00004F96 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Clear flip flag
00004F9C 6700                       		beq.s	.MoveRight			; Branch if it was already cleared
00004F9E 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
00004FA4 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00004FAA                            
00004FAA                            .MoveRight:
00004FAA D045                       		add.w	d5,d0				; Add acceleration
00004FAC B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
00004FAE 6D00                       		blt.s	.SetSpeed			; If not, branch
00004FB0 9045                       		sub.w	d5,d0				; Subtract acceleration back
00004FB2 B046                       		cmp.w	d6,d0				; Is Sonic still going at the top speed?
00004FB4 6C00                       		bge.s	.SetSpeed			; If not, branch
00004FB6 3006                       		move.w	d6,d0				; Cap at top speed
00004FB8                            
00004FB8                            .SetSpeed:
00004FB8 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
00004FBC 4228 0020                  		clr.b	_objAnim(a0)			; Set animation to moving
00004FC0                            
00004FC0                            .End:
00004FC0 4E75                       		rts
00004FC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FC2                            .Skid:
00004FC2 D044                       		add.w	d4,d0				; Add deceleration
00004FC4 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
00004FC6                            
00004FC6                            .Compare:
00004FC6 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
00004FC8 6F00                       		ble.s	.SetSkidSpeed			; If not, branch
00004FCA 303C 0080                  		move.w	#$80,d0				; Set speed to $80
00004FCE                            
00004FCE                            .SetSkidSpeed:
00004FCE 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
00004FD2 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00004FD6 0600 0020                  		addi.b	#$20,d0				; Shift it
00004FDA 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
00004FDE 66E0                       		bne.s	.End				; If so, branch
00004FE0 0C40 FC00                  		cmpi.w	#-$400,d0			; Is Sonic's speed at least -4 pixels per frame?
00004FE4 6EDA                       		bgt.s	.End				; If not, branch
00004FE6 117C 000D 0020             		move.b	#$D,_objAnim(a0)			; Set animation to skidding
00004FEC 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Set flip flag
00004FF2                            
00004FF2 4E75                       		rts
00004FF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FF4                            ; Do movement while rolling
00004FF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FF4                            ObjPlayer_MoveRoll:
00004FF4 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
00004FF8 E346                       		asl.w	#1,d6				; ''
00004FFA 3A28 0036                  		move.w	_objAccel(a0),d5			; Get acceleration
00004FFE E245                       		asr.w	#1,d5				; ''
00005000 3828 0038                  		move.w	_objDecel(a0),d4			; Get deceleration
00005004 E444                       		asr.w	#2,d4				; ''
00005006                            
00005006 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer active?
0000500A 6600 0000                  		bne.w	.UpdateSpd			; If so, branch
0000500E                            
0000500E 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left being held?
00005014 6700                       		beq.s	.ChkRight			; If not, branch
00005016 6100 0000                  		bsr.w	ObjPlayer_RollLeft		; Handle left movement
0000501A                            
0000501A                            .ChkRight:
0000501A 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right being held?
00005020 6700                       		beq.s	.Decelerate			; If not, branch
00005022 6100 0000                  		bsr.w	ObjPlayer_RollRight		; Handle right movement
00005026                            
00005026                            .Decelerate:
00005026 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
0000502A 6700                       		beq.s	.ChkStop			; If Sonic isn't moving, branch
0000502C 6B00                       		bmi.s	.DecLeft			; If Sonic is moving left, branch
0000502E                            
0000502E 9045                       		sub.w	d5,d0				; Decelerate
00005030 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
00005032 7000                       		moveq	#0,d0				; Cap at 0
00005034                            
00005034                            .SetGVel:
00005034 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
00005038 6000                       		bra.s	.ChkStop			; Continue
0000503A                            
0000503A                            .DecLeft:
0000503A D045                       		add.w	d5,d0				; Decelerate
0000503C 6400                       		bcc.s	.SetGVel2			; If Sonic hasn't stopped yet, branch
0000503E 7000                       		moveq	#0,d0				; Cap at 0
00005040                            
00005040                            .SetGVel2:
00005040 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
00005044                            
00005044                            .ChkStop:
00005044 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic still moving?
00005048 6600                       		bne.s	.UpdateSpd			; If so, branch
0000504A                            
0000504A 4A28 004B                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
0000504E 6600                       		bne.s	.KeepRoll			; If so, branch
00005050 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Stop rolling
00005056 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
0000505C 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
00005062 117C 0005 0020             		move.b	#5,_objAnim(a0)			; Use standing animation
00005068                            	;	subq.w	#5,_objYPos(a0)			; Align Sonic with the ground
00005068 6000                       		bra.s	.UpdateSpd			; Continue
0000506A                            
0000506A                            .KeepRoll:
0000506A 317C 0400 003A             		move.w	#$400,_objGVel(a0)			; Speed up again
00005070 0828 0000 0028             		btst	#0,_objStatus(a0)			; Are we facing right?
00005076 6700                       		beq.s	.UpdateSpd			; If so, branch
00005078 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
0000507C                            
0000507C                            .UpdateSpd:
0000507C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005080 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
00005084 C1E8 003A                  		muls.w	_objGVel(a0),d0			; Multiply sine with ground velocity
00005088 E080                       		asr.l	#8,d0				; Shift over
0000508A 3140 001E                  		move.w	d0,_objYVel(a0)			; Set Y velocity
0000508E C3E8 003A                  		muls.w	_objGVel(a0),d1			; Multiply cosine with ground velocity
00005092 E081                       		asr.l	#8,d1				; Shift over
00005094                            
00005094 0C41 1000                  		cmpi.w	#$1000,d1			; Is the speed > $10 pixels per frame?
00005098 6F00                       		ble.s	.ChkLeftSpd			; If not, branch
0000509A 323C 1000                  		move.w	#$1000,d1			; Cap the speed
0000509E                            
0000509E                            .ChkLeftSpd:
0000509E 0C41 F000                  		cmpi.w	#-$1000,d1			; Is the speed < -$10 pixels per frame?
000050A2 6C00                       		bge.s	.SetXVel			; If not, branch
000050A4 323C F000                  		move.w	#-$1000,d1			; Cap the speed
000050A8                            
000050A8                            .SetXVel:
000050A8 3141 001C                  		move.w	d1,_objXVel(a0)			; Set X velocity
000050AC 6000 FDEE                  		bra.w	ObjPlayer_CheckWalls		; Check wall collision
000050B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050B0                            ; Handle left movement for rolling
000050B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050B0                            ObjPlayer_RollLeft:
000050B0 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
000050B4 6700                       		beq.s	.SetLeft			; If Sonic isn't moving, branch
000050B6 6A00                       		bpl.s	.Dec				; If Sonic is moving right, branch
000050B8                            
000050B8                            .SetLeft:
000050B8 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
000050BE 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use rolling animation
000050C4 4E75                       		rts
000050C6                            
000050C6                            .Dec:
000050C6 9044                       		sub.w	d4,d0				; Decelerate
000050C8 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
000050CA 303C FF80                  		move.w	#-$80,d0			; Set new speed
000050CE                            
000050CE                            .SetGVel:
000050CE 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
000050D2 4E75                       		rts
000050D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050D4                            ; Handle left movement for rolling
000050D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050D4                            ObjPlayer_RollRight:
000050D4 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
000050D8 6B00                       		bmi.s	.Dec				; If Sonic is moving left, branch
000050DA 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
000050E0 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use rolling animation
000050E6 4E75                       		rts
000050E8                            
000050E8                            .Dec:
000050E8 D044                       		add.w	d4,d0				; Decelerate
000050EA 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
000050EC 303C 0080                  		move.w	#$80,d0				; Set new speed
000050F0                            
000050F0                            .SetGVel:
000050F0 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
000050F4 4E75                       		rts
000050F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050F6                            ; Do movement in the air
000050F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050F6                            ObjPlayer_MoveAir:
000050F6 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
000050FA 3A28 0036                  		move.w	_objAccel(a0),d5			; Get accleration
000050FE DA45                       		add.w	d5,d5				; Double it
00005100 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00005104                            
00005104 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left being held?
0000510A 6700                       		beq.s	.NotLeft			; If not, branch
0000510C 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
00005112 9045                       		sub.w	d5,d0				; Subtract acceleration
00005114 3206                       		move.w	d6,d1				; Get top speed
00005116 4441                       		neg.w	d1				; Negate it
00005118 B041                       		cmp.w	d1,d0				; Has Sonic reached the top speed?
0000511A 6E00                       		bgt.s	.NotLeft			; If not, branch
0000511C D045                       		add.w	d5,d0				; Add acceleration back
0000511E B041                       		cmp.w	d1,d0				; Is Sonic still at top speed?
00005120 6F00                       		ble.s	.NotLeft			; If not, branch
00005122 3001                       		move.w	d1,d0				; Cap at top speed
00005124                            
00005124                            .NotLeft:
00005124 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right being held?
0000512A 6700                       		beq.s	.NotRight			; If not, branch
0000512C 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
00005132 D045                       		add.w	d5,d0				; Add acceleration
00005134 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
00005136 6D00                       		blt.s	.NotRight			; If not, branch
00005138 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000513A B046                       		cmp.w	d6,d0				; Is Sonic still at top speed?
0000513C 6C00                       		bge.s	.NotRight			; If not, branch
0000513E 3006                       		move.w	d6,d0				; Cap at top speed
00005140                            
00005140                            .NotRight:
00005140 3140 001C                  		move.w	d0,_objXVel(a0)			; Set X velocity
00005144                            
00005144                            .ResetScr
00005144 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
0000514A 6700                       		beq.s	.DecelerateAtPeak		; If so, branch
0000514C 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000514E 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005152                            
00005152                            .ScrollUp:
00005152 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005156                            
00005156                            .DecelerateAtPeak:
00005156 0C68 FC00 001E             		cmpi.w	#-$400,_objYVel(a0)		; Is Sonic at least going -4 pixels per frame up?
0000515C 6500                       		bcs.s	.End				; If not, branch
0000515E 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00005162 3200                       		move.w	d0,d1				; Save it
00005164 EA41                       		asr.w	#5,d1				; Turn it into the acceleration
00005166 6700                       		beq.s	.End				; If it's 0, branch
00005168 6B00                       		bmi.s	.DecLeft			; If it's negative, branch
0000516A                            
0000516A                            .DecRight:
0000516A 9041                       		sub.w	d1,d0				; Subtract accleration
0000516C 6400                       		bcc.s	.DecSetSpeed			; If it's not negative, branch
0000516E 7000                       		moveq	#0,d0				; Cap at 0
00005170 6000                       		bra.s	.DecSetSpeed			; Continue
00005172                            
00005172                            .DecLeft:
00005172 9041                       		sub.w	d1,d0				; Subtract acceleration
00005174 6500                       		bcs.s	.DecSetSpeed			; If it's not positive, branch
00005176 7000                       		moveq	#0,d0				; Cap at 0
00005178                            
00005178                            .DecSetSpeed:
00005178 3140 001C                  		move.w	d0,_objXVel(a0)			; Set thhe X velocity
0000517C                            
0000517C                            .End:
0000517C 4E75                       		rts
0000517E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000517E                            ; Handle level boundaries
0000517E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000517E                            ObjPlayer_LvlBound:
0000517E 4A68 001E                  		tst.w	_objYVel(a0)
00005182 6A00                       		bpl.s	.XBound
00005184 3228 0018                  		move.w	_objYPos(a0),d1
00005188 0641 0010                  		addi.w	#$10,d1
0000518C 3038 E8D4                  		move.w	minCamYPos.w,d0		; Get upper boundary position
00005190 B041                       		cmp.w	d1,d0				; Has Sonic touched the upper boundary?
00005192 6F00                       		ble.s	.XBound				; If so, branch
00005194 3140 0018                  		move.w	d0,_objYPos(a0)
00005198 4268 001E                  		clr.w	_objYVel(a0)
0000519C 4268 003A                  		clr.w	_objGVel(a0)
000051A0                            
000051A0                            .XBound:
000051A0 2228 0014                  		move.l	_objXPos(a0),d1			; Get X position
000051A4 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
000051A8 48C0                       		ext.l	d0
000051AA E180                       		asl.l	#8,d0				; Shift it
000051AC D280                       		add.l	d0,d1				; Add to X position
000051AE 4841                       		swap	d1				; Get actual X position
000051B0 3038 E8D2                  		move.w	minCamXPos.w,d0		; Get left boundary position
000051B4 0640 0010                  		addi.w	#$10,d0				; ''
000051B8 B041                       		cmp.w	d1,d0				; Has Sonic touched the left boundary?
000051BA 6E00                       		bgt.s	.TouchedSide			; If so, branch
000051BC 3038 E8CA                  		move.w	maxCamXPos.w,d0		; Get max camera X position
000051C0 0640 0128                  		addi.w	#320-24,d0			; Get right boundary position
000051C4 B041                       		cmp.w	d1,d0				; Has Sonic touched the right boundary?
000051C6 6F00                       		ble.s	.TouchedSide			; If so, branch
000051C8                            
000051C8                            .ChkBottom:
000051C8 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get max camera Y position
000051CC 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
000051D0 B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic touched the bottom boundary?
000051D4 6D00                       		blt.s	.TouchedBottom			; If so, branch
000051D6 4E75                       		rts
000051D8                            
000051D8                            .TouchedBottom:
000051D8 3038 E8C8                  		move.w	targetMaxCamY.w,d0		; Get target max camera Y position
000051DC 3238 E8CC                  		move.w	maxCamYPos.w,d1		; Get current max camera Y position
000051E0 B240                       		cmp.w	d0,d1				; Are they the same?
000051E2 6D00                       		blt.s	.NoKill				; If not, branch
000051E4 6000 0000                  		bra.w	ObjPlayer_GetKilled		; Get Sonic killed
000051E8                            
000051E8                            .NoKill:
000051E8 4E75                       		rts
000051EA                            
000051EA                            .TouchedSide:
000051EA 4268 001C                  		clr.w	_objXVel(a0)			; Stop X movement
000051EE 3140 0014                  		move.w	d0,_objXPos(a0)			; Move Sonic out of the boundary
000051F2 4228 0016                  		clr.b	_objXPos+2(a0)			; Clear the subpixel of the X position
000051F6 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
000051FA 60CC                       		bra.s	.ChkBottom			; Continue
000051FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000051FC                            ; Handle peelout
000051FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000051FC                            ObjPlayer_Peelout:
000051FC 4A28 0045                  		tst.b	_objDashFlag(a0)			; Is Sonic doing the peelout?
00005200 6700                       		beq.s	.ChkUp				; If not, branch
00005202 6B00                       		bmi.s	.ChkLaunch			; If so, branch
00005204 4E75                       		rts
00005206                            
00005206                            .ChkUp:
00005206 0C28 0007 0020             		cmpi.b	#7,_objAnim(a0)			; Is Sonic looking up?
0000520C 6600 0000                  		bne.w	.End				; If not, branch
00005210 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get controller bits
00005214 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
00005218 6700 0000                  		beq.w	.End				; If not, branch
0000521C                            
0000521C 4228 0020                  		clr.b	_objAnim(a0)			; Set to peelout charge animation
00005220 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset the dash timer
00005224 317C 000C 003A             		move.w	#$C,_objGVel(a0)			; Reset ground velocity
0000522A 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005230 6700                       		beq.s	.SetAni				; If so, branch
00005232 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005236                            
00005236                            .SetAni:
00005236                            		playSnd	#sCharge, 2			; Play charge sound
00005236 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000523C                            
0000523C 588F                       		addq.l	#4,sp				; Don't return to caller
0000523E 50E8 0045                  		st	_objDashFlag(a0)			; Set the peelout flag
00005242 4EF8 3314                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005246                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005246                            .ChkLaunch:
00005246 0838 0000 E8DE             		btst	#0,plrCtrlHold.w		; Is up being held?
0000524C 6600 0000                  		bne.w	.Charge				; If so, branch
00005250 4228 0045                  		clr.b	_objDashFlag(a0)			; Clear the dash flag
00005254                            
00005254 0C28 001E 0046             		cmpi.b	#30,_objDashTimer(a0)		; Has Sonic charged up enough?
0000525A 6600                       		bne.s	.StopSound			; If not, branch
0000525C                            
0000525C 4228 0020                  		clr.b	_objAnim(a0)			; Reset animation
00005260 317C 0C00 003A             		move.w	#$C00,_objGVel(a0)			; Set ground velocity
00005266 0828 0006 0028             		btst	#6,_objStatus(a0)
0000526C 6700                       		beq.s	.NoWater
0000526E E2E8 003A                  		lsr.w	_objGVel(a0)
00005272                            
00005272                            .NoWater:
00005272 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005278 6700                       		beq.s	.FinishDash			; If not, branch
0000527A 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
0000527E                            
0000527E                            .FinishDash:
0000527E                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000527E 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
00005284                            
00005284 6000                       		bra.s	.DoUpdates			; Continue
00005286                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005286                            .Charge:
00005286 0C28 001E 0046             		cmpi.b	#30,_objDashTimer(a0)		; Has Sonic charged enough?
0000528C 6700                       		beq.s	.DoUpdates			; If so, branch
0000528E 5228 0046                  		addq.b	#1,_objDashTimer(a0)		; Increment the timer
00005292 0668 0066 003A             		addi.w	#$66,_objGVel(a0)			; Increment ground velocity to handle animation and extended camera
00005298 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
0000529E 6700                       		beq.s	.DoUpdates			; If so, branch
000052A0 0468 00CC 003A             		subi.w	#$66*2,_objGVel(a0)		; Go the other way
000052A6 6000                       		bra.s	.DoUpdates			; Continue
000052A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052A8                            .StopSound:
000052A8 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
000052AC                            
000052AC                            		playSnd	#sChargeStop, 2			; Play charge stop sound
000052AC 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
000052B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052B2                            .DoUpdates:
000052B2 588F                       		addq.l	#4,sp				; Don't return to caller
000052B4 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
000052BA 6700                       		beq.s	.FinishUpdates			; If so, branch
000052BC 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
000052BE 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
000052C2                            
000052C2                            .ScrollUp:
000052C2 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
000052C6                            
000052C6                            .FinishUpdates:
000052C6 4EF8 3314                  		jmp	PlayerAnglePos			; Update position and angle along the ground
000052CA                            
000052CA                            .End:
000052CA 4E75                       		rts
000052CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052CC                            ; Handle spindash
000052CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052CC                            ObjPlayer_Spindash:
000052CC 4A28 0045                  		tst.b	_objDashFlag(a0)			; Is Sonic doing the spindash?
000052D0 6700                       		beq.s	.ChkDown			; If not, branch
000052D2 6A00                       		bpl.s	.ChkLaunch			; If so, branch
000052D4 4E75                       		rts
000052D6                            
000052D6                            .ChkDown:
000052D6 0C28 0008 0020             		cmpi.b	#8,_objAnim(a0)			; Is Sonic ducking?
000052DC 6600 0000                  		bne.w	.End				; If not, branch
000052E0 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get controller bits
000052E4 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
000052E8 6700 0000                  		beq.w	.End				; If not, branch
000052EC                            
000052EC 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset the dash timer
000052F0 317C 000C 003A             		move.w	#$C,_objGVel(a0)			; Reset ground velocity
000052F6 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000052FC 6700                       		beq.s	.SetAni				; If so, branch
000052FE 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005302                            
00005302                            .SetAni:
00005302 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005308 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
0000530E                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
0000530E 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set to spin animation
00005314                            
00005314                            		playSnd	#sCharge, 2			; Play charge sound
00005314 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000531A                            
0000531A 588F                       		addq.l	#4,sp				; Don't return to caller
0000531C 117C 0001 0045             		move.b	#1,_objDashFlag(a0)		; Set the spindash flag
00005322 4EF8 3314                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005326                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005326                            .ChkLaunch:
00005326 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is down being held?
0000532C 6600 0000                  		bne.w	.Charge				; If so, branch
00005330 4228 0045                  		clr.b	_objDashFlag(a0)			; Clear the dash flag
00005334                            
00005334 0C28 002D 0046             		cmpi.b	#45,_objDashTimer(a0)		; Has Sonic charged up enough?
0000533A 6600                       		bne.s	.StopSound			; If not, branch
0000533C                            
0000533C 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set the roll flag
00005342 317C 0C00 003A             		move.w	#$C00,_objGVel(a0)			; Set ground velocity
00005348 0828 0006 0028             		btst	#6,_objStatus(a0)
0000534E 6700                       		beq.s	.NoWater
00005350 E2E8 003A                  		lsr.w	_objGVel(a0)
00005354                            
00005354                            .NoWater:
00005354 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
0000535A 6700                       		beq.s	.FinishDash			; If not, branch
0000535C 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005360                            
00005360                            .FinishDash:
00005360                            		playSnd	#sChargeRelease, 2		; Play charge release sound
00005360 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
00005366                            
00005366 6000                       		bra.s	.DoUpdates			; Continue
00005368                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005368                            .Charge:
00005368 0C28 002D 0046             		cmpi.b	#45,_objDashTimer(a0)		; Has Sonic charged enough?
0000536E 6700                       		beq.s	.DoUpdates			; If so, branch
00005370 5228 0046                  		addq.b	#1,_objDashTimer(a0)		; Increment the timer
00005374 0668 0046 003A             		addi.w	#$46,_objGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000537A 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005380 6700                       		beq.s	.DoUpdates			; If so, branch
00005382 0468 008C 003A             		subi.w	#$46*2,_objGVel(a0)		; Go the other way
00005388 6000                       		bra.s	.DoUpdates			; Continue
0000538A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000538A                            .StopSound:
0000538A 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
0000538E 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00005394 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
0000539A                            	;	subq.w	#5,_objYPos(a0)			; Align Sonic with the ground
0000539A                            
0000539A                            		playSnd	#sChargeStop, 2			; Play charge stop sound
0000539A 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
000053A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053A0                            .DoUpdates:
000053A0 588F                       		addq.l	#4,sp				; Don't return to caller
000053A2 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
000053A8 6700                       		beq.s	.FinishUpdates			; If so, branch
000053AA 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
000053AC 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
000053B0                            
000053B0                            .ScrollUp:
000053B0 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
000053B4                            
000053B4                            .FinishUpdates:
000053B4 4EF8 3314                  		jmp	PlayerAnglePos			; Update position and angle along the ground
000053B8                            
000053B8                            .End:
000053B8 4E75                       		rts
000053BA                            		
000053BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053BA                            ; Check for fire attack
000053BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053BA                            ObjPlayer_ChkAttack:
000053BA 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get pressed buttons
000053BE 0200 0010                  		andi.b	#$10,d0				; Are B pressed?
000053C2 4A00                       		tst.b	d0
000053C4 6700 0000                  		beq.w	.End				; If not, branch
000053C8                            		
000053C8 4EB8 1A1C                  		jsr	FindFreeObj.w
000053CC 6700                       		beq.s	.End
000053CE 22BC 0000 0000             		move.l	#ObjAttack,_objAddress(a1)
000053D4 137C 001E 0017             		move.b	#30,_objDrawW(a1)
000053DA 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000053E0 6700                       		beq.s	.cont			; If so, branch
000053E2 337C 0001 0024             		move.w	#1,	_objSubtype(a1)
000053E8                            	.cont:
000053E8 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
000053EE 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
000053F4                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
000053F4 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
000053FA                            		
000053FA                            .End:
000053FA 4E75                       		rts
000053FC                            		
000053FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053FC                            ; Check for jumping
000053FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053FC                            ObjPlayer_ChkJump:
000053FC 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get pressed buttons
00005400 0200 0020                  		andi.b	#$20,d0				; Are C pressed?
00005404 4A38 C76A                  		tst.b	moveCheat.w
00005408 6700                       		beq.s	.NoDebug
0000540A 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
0000540E                            
0000540E                            .NoDebug:
0000540E 4A00                       		tst.b	d0
00005410 6700 0000                  		beq.w	.End				; If not, branch
00005414                            
00005414 7000                       		moveq	#0,d0
00005416 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000541A 0600 0080                  		addi.b	#$80,d0				; Shift it to check the ceiling
0000541E 4EB8 2F3C                  		jsr	PlayerCalcRoomOverHead		; Get room over Sonic's head
00005422 0C41 0006                  		cmpi.w	#6,d1				; Is it at least 6 pixels?
00005426 6D00 0000                  		blt.w	.End				; If not, branch
0000542A                            
0000542A 343C 0180                  		move.w	#JUMP_HEIGHT,d2			; Standard jump height
0000542E 0828 0006 0028             		btst	#6,_objStatus(a0)
00005434 6700                       		beq.s	.NoWater
00005436 0442 0300                  		subi.w	#$300,d2
0000543A                            
0000543A                            .NoWater:
0000543A 7000                       		moveq	#0,d0
0000543C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005440 0400 0040                  		subi.b	#$40,d0				; Shift it
00005444 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
00005448 C3C2                       		muls.w	d2,d1				; Mutliply cosine with jump height
0000544A C1C2                       		muls.w	d2,d0				; Mutliply sine with jump height
0000544C E081                       		asr.l	#8,d1				; Shift the values over
0000544E E080                       		asr.l	#8,d0				; ''
00005450 D368 001C                  		add.w	d1,_objXVel(a0)			; Add to X velocity
00005454 D168 001E                  		add.w	d0,_objYVel(a0)			; Add to Y velocity
00005458 0028 0006 0028             		ori.b	#6,_objStatus(a0)			; Set "in air" and roll flags
0000545E 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00005464 584F                       		addq.w	#4,sp				; Do not return to collaer
00005466 50E8 0040                  		st	_objJumping(a0)			; Set the jumping flag
0000546A                            		playSnd	#sLeap, 2			; Play jump sound
0000546A 11FC 0082 C4BD           M 	move.b	#sleap,(mqueue+((2)-1)).w
00005470 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005476 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
0000547C                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
0000547C 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set jumping animation
00005482                            
00005482                            .End:
00005482 4E75                       		rts
00005484                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005484                            ; Handle variable jumping
00005484                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005484                            ObjPlayer_JumpHeight:
00005484                            	;	tst.b	_objJumping(a0)			; Is Sonic jumping?
00005484                            	;	beq.s	.UpVelCap			; If not, branch
00005484                            
00005484 323C FE80                  		move.w	#-MIN_JMP_HEIGHT,d1		; Standard minimum height
00005488 B268 001E                  		cmp.w	_objYVel(a0),d1			; Is Sonic jumping at least hte minimum height?
0000548C 6F00                       		ble.s	.End				; If not, branch
0000548E 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
00005492 0200 0020                  		andi.b	#$20,d0				; Are A, B, or C pressed?
00005496 4A38 C76A                  		tst.b	moveCheat.w
0000549A 6700                       		beq.s	.NoDebug
0000549C 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
000054A0                            
000054A0                            .NoDebug:
000054A0 4A00                       		tst.b	d0
000054A2 6600                       		bne.s	.End				; If not, branch
000054A4 3141 001E                  		move.w	d1,_objYVel(a0)			; Set to minimum height
000054A8                            
000054A8                            .End:
000054A8 4E75                       		rts
000054AA                            
000054AA                            .UpVelCap:
000054AA 4A28 004B                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
000054AE 66F8                       		bne.s	.End				; If so, branch
000054B0 0C68 F040 001E             		cmpi.w	#-$FC0,_objYVel(a0)		; Cap Y velocity at -$FC0 when going up
000054B6 6CF0                       		bge.s	.End				; ''
000054B8 317C F040 001E             		move.w	#-$FC0,_objYVel(a0)		; ''
000054BE 4E75                       		rts
000054C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054C0                            ; Gradually reset Sonic's angle in mid air
000054C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054C0                            ObjPlayer_JumpAngle:
000054C0 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000054C4 6700                       		beq.s	ObjPlayer_JumpFlip		; If it's already reset, branch
000054C6 6A00                       		bpl.s	.Decrease			; If it's positive, branch
000054C8                            
000054C8                            .Increase:
000054C8 5400                       		addq.b	#2,d0				; Increase angle
000054CA 6B00                       		bmi.s	.SetAngle			; If it's not reset, branch
000054CC 7000                       		moveq	#0,d0				; Reset the angle
000054CE 6000                       		bra.s	.SetAngle
000054D0                            
000054D0                            .Decrease:
000054D0 5500                       		subq.b	#2,d0				; Decrease angle
000054D2 6A00                       		bpl.s	.SetAngle			; If it's not reset, branch
000054D4 7000                       		moveq	#0,d0				; Reset the angle
000054D6                            
000054D6                            .SetAngle:
000054D6 1140 0041                  		move.b	d0,_objAngle(a0)			; Set the new angle
000054DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054DA                            ; Update Sonic's angle while he's tumbling in the air
000054DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054DA                            ObjPlayer_JumpFlip:
000054DA 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Get flip angle
000054DE 6700                       		beq.s	.End				; If it's 0, branch
000054E0 4A68 003A                  		tst.w	_objFlipDir(a0)			; Is Sonic flipping left?
000054E4 6B00                       		bmi.s	.FlipLeft			; IF so, branch
000054E6                            
000054E6                            .FlipRight:
000054E6 1228 004A                  		move.b	_objFlipSpeed(a0),d1		; Get flip speed
000054EA D001                       		add.b	d1,d0				; Add to angle
000054EC 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
000054EE 5328 0049                  		subq.b	#1,_objFlipRemain(a0)		; Decrement flips remaining
000054F2 6400                       		bcc.s	.FlipSet			; If there are still some left
000054F4 4228 0049                  		clr.b	_objFlipRemain(a0)			; Clear flips remaining
000054F8 7000                       		moveq	#0,d0				; Reset angle
000054FA 6000                       		bra.s	.FlipSet			; Continue
000054FC                            
000054FC                            .FlipLeft:
000054FC 4A28 0048                  		tst.b	_objFlipTurned(a0)			; Is the flipping inverted?
00005500 66E4                       		bne.s	.FlipRight			; If so, branch
00005502 1228 004A                  		move.b	_objFlipSpeed(a0),d1		; Get flip speed
00005506 9001                       		sub.b	d1,d0				; Subtract from angle
00005508 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
0000550A 5328 0049                  		subq.b	#1,_objFlipRemain(a0)		; Decrement flips remaining
0000550E 6400                       		bcc.s	.FlipSet			; If there are still some left
00005510 4228 0049                  		clr.b	_objFlipRemain(a0)			; Clear flips remaining
00005514 7000                       		moveq	#0,d0				; Reset angle
00005516                            
00005516                            .FlipSet:
00005516 1140 0047                  		move.b	d0,_objFlipAngle(a0)		; Update the angle
0000551A                            
0000551A                            .End:
0000551A 4E75                       		rts
0000551C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000551C                            ; Check for rolling
0000551C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000551C                            ObjPlayer_ChkRoll:
0000551C 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
00005520 6A00                       		bpl.s	.ChkSpd				; Get absolute value
00005522 4440                       		neg.w	d0				; ''
00005524                            
00005524                            .ChkSpd:
00005524 0C40 0080                  		cmpi.w	#$80,d0				; Is Sonic going fast enough?
00005528 6500                       		bcs.s	.NoRoll				; If not, branch
0000552A 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
0000552E 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
00005532 6600                       		bne.s	.NoRoll				; If not, branch
00005534 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is down being held?
0000553A 6600                       		bne.s	ObjPlayer_DoRoll			; If so, branch
0000553C                            
0000553C                            .NoRoll:
0000553C 4E75                       		rts
0000553E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000553E                            ; Make Sonic roll
0000553E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000553E                            ObjPlayer_DoRoll:
0000553E 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
00005544 6600                       		bne.s	.End				; If so, branch
00005546 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
0000554C                            
0000554C 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005552 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005558                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005558 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
0000555E                            
0000555E 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving already?
00005562 6600                       		bne.s	.End				; IF not, branch
00005564 317C 0200 003A             		move.w	#$200,_objGVel(a0)			; Set speed
0000556A                            
0000556A                            .End:
0000556A 4E75                       		rts
0000556C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000556C                            ; Slow Sonic down as he goes up a slope or speed him up when he does down one
0000556C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000556C                            ObjPlayer_SlopePush:
0000556C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005570 0600 0060                  		addi.b	#$60,d0				; Shift it
00005574 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep slope or ceiling?
00005578 6400                       		bcc.s	.End				; If not, branch
0000557A 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000557E 4EB8 1374                  		jsr	CalcSine.w			; Get the sine of it
00005582 C1FC 0020                  		muls.w	#$20,d0				; Multiple it by $20
00005586 E080                       		asr.l	#8,d0				; Shift it
00005588 4A68 003A                  		tst.w	_objGVel(a0)			; Check speed
0000558C 6700                       		beq.s	.End				; If Sonic is not moving, branch
0000558E D168 003A                  		add.w	d0,_objGVel(a0)			; Add to ground velocity
00005592                            
00005592                            .End:
00005592 4E75                       		rts
00005594                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005594                            ; Check if Sonic is to fall off a slope
00005594                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005594                            ObjPlayer_FallOffSlope:
00005594 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer, active?
00005598 6600                       		bne.s	.End				; If so, branch
0000559A 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000559E 0600 0020                  		addi.b	#$20,d0				; Shift it
000055A2 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
000055A6 6700                       		beq.s	.End				; If Sonic is on the floor, branch
000055A8 3028 003A                  		move.w	_objGVel(a0),d0			; Get speed
000055AC 6A00                       		bpl.s	.ChkSpeed			; If it's already positive, branch
000055AE 4440                       		neg.w	d0				; Force it to be positive
000055B0                            
000055B0                            .ChkSpeed:
000055B0 0C40 0280                  		cmpi.w	#$280,d0			; Is Sonic going at least 2.5 pixels per frame?
000055B4 6400                       		bcc.s	.End				; If so, branch
000055B6 4268 003A                  		clr.w	_objGVel(a0)			; Stop movement
000055BA 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
000055C0 117C 001E 003F             		move.b	#$1E,_objMoveLock(a0)		; Set move lock timer
000055C6                            
000055C6                            .End:
000055C6 4E75                       		rts
000055C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000055C8                            ; Affect Sonic's speed on slopes while rolling
000055C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000055C8                            ObjPlayer_RollSlopePush:
000055C8 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000055CC 0600 0060                  		addi.b	#$60,d0				; ''
000055D0 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep enough slope?
000055D4 6400                       		bcc.s	.End				; If not, branch
000055D6                            
000055D6 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000055DA 4EB8 1374                  		jsr	CalcSine.w			; Get sine
000055DE C1FC 0050                  		muls.w	#$50,d0				; Multiply sine by $50
000055E2 E080                       		asr.l	#8,d0				; Shift over
000055E4                            
000055E4 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving right?
000055E8 6B00                       		bmi.s	.PushLeft			; If not, branch
000055EA 4A40                       		tst.w	d0				; Is the push speed positive?
000055EC 6A00                       		bpl.s	.Push				; If so, branch
000055EE E480                       		asr.l	#2,d0				; Shift over more
000055F0                            
000055F0                            .Push:
000055F0 D168 003A                  		add.w	d0,_objGVel(a0)			; Add push speed
000055F4 4E75                       		rts
000055F6                            
000055F6                            .PushLeft:
000055F6 4A40                       		tst.w	d0				; Is the push speed negative?
000055F8 6B00                       		bmi.s	.Push2				; If so, branch
000055FA E480                       		asr.l	#2,d0				; Shift over more
000055FC                            
000055FC                            .Push2:
000055FC D168 003A                  		add.w	d0,_objGVel(a0)			; Add push speed
00005600                            
00005600                            .End:
00005600 4E75                       		rts
00005602                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005602                            ; Check for bouncy floor collision
00005602                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005602                            ObjPlayer_ChkBounce:
00005602 4A38 E909                  		tst.b	rFlooactIDive.w		; Is the floor active?
00005606 6700 0000                  		beq.w	.End				; If so, branch
0000560A                            
0000560A 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is Sonic in the air?
00005610 6700                       		beq.s	.ChkDown			; If not, branch
00005612                            
00005612 4A68 001E                  		tst.w	_objYVel(a0)			; Is Sonic falling?
00005616 6700 0000                  		beq.w	.ChkBounceUp			; If not, branch
0000561A 6B00 0000                  		bmi.w	.ChkBounceUp			; ''
0000561E                            
0000561E                            .ChkDown:
0000561E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of left sensor
00005622 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005626 4880                       		ext.w	d0				; ''
00005628 D440                       		add.w	d0,d2				; ''
0000562A 5442                       		addq.w	#2,d2				; ''
0000562C 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of left sensor
00005630 1028 002C                  		move.b	_objColW(a0),d0			; ''
00005634 4880                       		ext.w	d0				; ''
00005636 9640                       		sub.w	d0,d3				; ''
00005638 4EB8 38A4                  		jsr	Level_FindBlock			; Get the block located there
0000563C 3011                       		move.w	(a1),d0				; ''
0000563E 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005642 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005646 6700                       		beq.s	.Bounce				; If so, branch
00005648                            
00005648 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of right sensor
0000564C 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005650 4880                       		ext.w	d0				; ''
00005652 D440                       		add.w	d0,d2				; ''
00005654 5442                       		addq.w	#2,d2				; ''
00005656 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of right sensor
0000565A 1028 002C                  		move.b	_objColW(a0),d0			; ''
0000565E 4880                       		ext.w	d0				; ''
00005660 D640                       		add.w	d0,d3				; ''
00005662 4EB8 38A4                  		jsr	Level_FindBlock			; Get the block located there
00005666 3011                       		move.w	(a1),d0				; ''
00005668 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000566C 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005670 6600                       		bne.s	.End				; If not, branch
00005672                            
00005672                            .Bounce:
00005672 317C EA00 001E             		move.w	#-$1600,_objYVel(a0)		; Bounce Sonic up
00005678 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set in air flag
0000567E 4228 0040                  		clr.b	_objJumping(a0)			; Clear jump flag
00005682 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset dash timer
00005686 4228 0045                  		clr.b	_objDashFlag(a0)			; Reset dash flag
0000568A                            
0000568A                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000568A 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
00005690                            
00005690 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
00005696 6600                       		bne.s	.End				; If so, branch
00005698 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
0000569E 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
000056A4 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
000056AA                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
000056AA 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
000056B0                            
000056B0                            .End:
000056B0 4E75                       		rts
000056B2                            
000056B2                            .ChkBounceUp:
000056B2 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of left sensor
000056B6 1028 002D                  		move.b	_objColH(a0),d0			; ''
000056BA 4880                       		ext.w	d0				; ''
000056BC 9440                       		sub.w	d0,d2				; ''
000056BE 5542                       		subq.w	#2,d2				; ''
000056C0 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of left sensor
000056C4 1028 002C                  		move.b	_objColW(a0),d0			; ''
000056C8 4880                       		ext.w	d0				; ''
000056CA 9640                       		sub.w	d0,d3				; ''
000056CC 4EB8 38A4                  		jsr	Level_FindBlock			; Get the block located there
000056D0 3011                       		move.w	(a1),d0				; ''
000056D2 0240 03FF                  		andi.w	#$3FF,d0			; ''
000056D6 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
000056DA 6700                       		beq.s	.BounceUp			; If so, branch
000056DC                            
000056DC 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of right sensor
000056E0 1028 002D                  		move.b	_objColH(a0),d0			; ''
000056E4 4880                       		ext.w	d0				; ''
000056E6 9440                       		sub.w	d0,d2				; ''
000056E8 5542                       		subq.w	#2,d2				; ''
000056EA 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of right sensor
000056EE 1028 002C                  		move.b	_objColW(a0),d0			; ''
000056F2 4880                       		ext.w	d0				; ''
000056F4 D640                       		add.w	d0,d3				; ''
000056F6 4EB8 38A4                  		jsr	Level_FindBlock			; Get the block located there
000056FA 3011                       		move.w	(a1),d0				; ''
000056FC 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005700 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005704 66AA                       		bne.s	.End				; If not, branch
00005706                            
00005706                            .BounceUp:
00005706 588F                       		addq.l	#4,sp				; Don't return to caller
00005708                            
00005708 317C 1600 001E             		move.w	#$1600,_objYVel(a0)		; Bounce Sonic up
0000570E 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set in air flag
00005714 4228 0040                  		clr.b	_objJumping(a0)			; Clear jump flag
00005718 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset dash timer
0000571C 4228 0045                  		clr.b	_objDashFlag(a0)			; Reset dash flag
00005720                            
00005720                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
00005720 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
00005726                            
00005726 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
0000572C 6600                       		bne.s	.End2				; If so, branch
0000572E 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
00005734 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
0000573A 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005740                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005740 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
00005746                            
00005746                            .End2:
00005746 4E75                       		rts
00005748                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005748                            ; Check for bars to hang on to
00005748                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005748                            ObjPlayer_ChkHang:
00005748 0828 0003 000C             		btst	#3,_objFlags(a0)			; Are we already hanging?
0000574E 6600                       		bne.s	.End				; If so, branch
00005750                            
00005750 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005754 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005758 0442 0018                  		subi.w	#$18,d2				; ''
0000575C 4EB8 38A4                  		jsr	Level_FindBlock			; Get the block located there
00005760 3011                       		move.w	(a1),d0				; ''
00005762 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005766 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
0000576A 6600                       		bne.s	.End				; If not, branch
0000576C                            
0000576C 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Clear roll flag
00005772 42A8 001C                  		clr.l	_objXVel(a0)			; Stop movement
00005776 4268 003A                  		clr.w	_objGVel(a0)			; ''
0000577A 08E8 0003 000C             		bset	#3,_objFlags(a0)			; Set hanging flag
00005780 117C 000A 0020             		move.b	#$A,_objAnim(a0)			; Set hanging animation
00005786 117C 0007 004C             		move.b	#7,_objHangAniTime(a0)		; Animation timer
0000578C                            	;	move.w	_objYPos(a0),d0			; Align with bar
0000578C 0440 0018                  		subi.w	#$18,d0				; ''
00005790 0240 FFF0                  		andi.w	#$FFF0,d0			; ''
00005794 0640 0018                  		addi.w	#$18,d0				; ''
00005798 3140 0018                  		move.w	d0,_objYPos(a0)			; ''
0000579C 4228 0041                  		clr.b	_objAngle(a0)			; Reset angle
000057A0 08A8 0001 000D             		bclr	#1,_objRender(a0)			; ''
000057A6                            
000057A6                            .End:
000057A6 4E75                       		rts
000057A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000057A8                            ; Hang onto the bars
000057A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000057A8                            ObjPlayer_Hang:
000057A8 3628 0014                  		move.w	_objXPos(a0),d3			; X position
000057AC 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
000057B0 0442 0018                  		subi.w	#$18,d2				; ''
000057B4 4EB8 38A4                  		jsr	Level_FindBlock			; Get the block located there
000057B8 3011                       		move.w	(a1),d0				; ''
000057BA 0240 03FF                  		andi.w	#$3FF,d0			; ''
000057BE 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
000057C2 6600                       		bne.s	.FallOff			; If not, branch
000057C4 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get control press bits
000057C8 0200 0070                  		andi.b	#$70,d0				; Are we jumping off?
000057CC 6700                       		beq.s	.MoveX				; If not, branch
000057CE                            
000057CE                            .FallOff:
000057CE 08A8 0003 000C             		bclr	#3,_objFlags(a0)			; Stop hanging
000057D4 0668 0010 0018             		addi.w	#$10,_objYPos(a0)			; Fall off
000057DA 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
000057E0 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
000057E6 4E75                       		rts
000057E8                            
000057E8                            .MoveX:
000057E8 7002                       		moveq	#2,d0				; X speed
000057EA 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Are we going left?
000057F0 6700                       		beq.s	.ChkRight			; If not, branch
000057F2 4440                       		neg.w	d0				; Go the other way
000057F4 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face to the left
000057FA 08E8 0000 000D             		bset	#0,_objRender(a0)			; ''
00005800 6000                       		bra.s	.DoMove				; Continue
00005802                            
00005802                            .ChkRight:
00005802 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Are we going left?
00005808 6700                       		beq.s	.ResetScr			; If not, branch
0000580A 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face to the right
00005810 08A8 0000 000D             		bclr	#0,_objRender(a0)			; ''
00005816                            
00005816                            .DoMove:
00005816 D168 0014                  		add.w	d0,_objXPos(a0)			; Move
0000581A 5328 004C                  		subq.b	#1,_objHangAniTime(a0)		; Decrement animation timer
0000581E 6A00                       		bpl.s	.ResetScr			; If it hasn't run out, branch
00005820 117C 0007 004C             		move.b	#7,_objHangAniTime(a0)		; Reset timer
00005826 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Increment animation frame
0000582A 0C28 0004 0022             		cmpi.b	#4,_objAnimFrame(a0)		; Have we reached the last one?
00005830 6500                       		bcs.s	.ResetScr			; If not, branch
00005832 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation frame
00005836                            
00005836                            .ResetScr:
00005836 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
0000583A 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005840 6700                       		beq.s	.End				; If so, branch
00005842 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005844 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005848                            
00005848                            .ScrollUp:
00005848 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
0000584C                            
0000584C                            .End:
0000584C 4E75                       		rts
0000584E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000584E                            ; Check for electricity
0000584E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000584E                            ObjPlayer_ChkElectric:
0000584E 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005852 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005856 4EB8 38A4                  		jsr	Level_FindBlock			; Get the block located there
0000585A 3011                       		move.w	(a1),d0				; ''
0000585C 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005860                            
00005860 43FA 0000                  		lea	.Blocks(pc),a1			; BLocks to check
00005864 7C02                       		moveq	#2,d6				; ''
00005866                            
00005866                            .ChkBlocks:
00005866 B059                       		cmp.w	(a1)+,d0			; have we touched this block?
00005868 6700                       		beq.s	ObjPlayer_GetHurt		; If so, branch
0000586A 51CE FFFA                  		dbf	d6,.ChkBlocks			; Loop
0000586E 4E75                       		rts
00005870                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005870 0082 0083 0084             .Blocks:	dc.w	$82, $83, $84
00005876                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005876                            ; Get Sonic hurt
00005876                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005876                            ObjPlayer_GetHurt:
00005876                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
00005876 4A68 0008                M 	tst.w	_objdrawnext(a0)
0000587A 6600                     M 	bne.s	.no_224
0000587C 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005882 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005886 3149 000A                M 	move.w	a1,_objdrawprev(a0)
0000588A 3348 0008                M 	move.w	a0,_objdrawnext(a1)
0000588E 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005892                          M .no_224
00005892 4A28 0042                  		tst.b	_objInvulTime(a0)			; Are we invulnerable?
00005896 6600 0000                  		bne.w	.End				; If so, branch
0000589A 4A78 E85E                  		tst.w	ringCount.w			; Does Sonic have any rings?
0000589E 6700 0000                  		beq.w	ObjPlayer_GetKilled		; If not, branch
000058A2 4EB8 1A1C                  		jsr	FindFreeObj.w
000058A6 6700                       		beq.s	.Hurt
000058A8 22BC 0000 0000             		move.l	#ObjRingLoss,_objAddress(a1)
000058AE 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
000058B4 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
000058BA                            
000058BA                            .Hurt:
000058BA 117C 0008 0025             		move.b	#8,_objRoutine(a0)			; Set to hurt routine
000058C0 4EB8 2E94                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
000058C4 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
000058C8 08A8 0000 000C             		bclr	#0,_objFlags(a0)			; Allow modes
000058CE 08A8 0003 000C             		bclr	#3,_objFlags(a0)			; Stop hanging
000058D4 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set the "in air" flag
000058DA 117C 001A 0020             		move.b	#$1A,_objAnim(a0)			; Set to hurt animation
000058E0 117C 0078 0042             		move.b	#$78,_objInvulTime(a0)		; Set invulnerable timer
000058E6                            
000058E6 317C FC00 001E             		move.w	#-$400,_objYVel(a0)		; Make Sonic bounce away
000058EC 317C FE00 001C             		move.w	#-$200,_objXVel(a0)		; ''
000058F2 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
000058F8 6700                       		beq.s	.ChkReverse			; If not, branch
000058FA 317C FE00 001E             		move.w	#-$200,_objYVel(a0)		; Make Sonic bounce away slower
00005900 317C FF00 001C             		move.w	#-$100,_objXVel(a0)
00005906                            
00005906                            .ChkReverse:
00005906 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
0000590A B06A 0014                  		cmp.w	_objXPos(a2),d0			; Is Sonic left of the object that hurt him?
0000590E 6500                       		bcs.s	.ChkSnd				; If so, branch
00005910 4468 001C                  		neg.w	_objXVel(a0)			; Make Sonic bounce the other way if on the right side
00005914                            
00005914                            .ChkSnd:
00005914 4268 003A                  		clr.w	_objGVel(a0)			; Reset ground velocity
00005918                            
00005918                            	;	cmpi.l	#ObjSpike,_objAddress(a2)		; Did Sonic hit a spike?
00005918                            	;	beq.s	.End				; If not, branch
00005918                            		playSnd	#sHurt, 2			; Play hurt sound
00005918 11FC 0084 C4BD           M 	move.b	#shurt,(mqueue+((2)-1)).w
0000591E                            
0000591E                            .End:
0000591E 70FF                       		moveq	#-1,d0				; Set return status
00005920 4E75                       		rts
00005922                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005922                            ; Hurt routine
00005922                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005922                            ObjPlayer_Hurt:
00005922 4A38 C76A                  		tst.b	moveCheat.w
00005926 6700                       		beq.s	.NoPlacementEnter
00005928 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
0000592E 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00005930 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00005936 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
0000593C 4E75                       		rts
0000593E                            
0000593E                            .NoPlacementEnter:
0000593E 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00005942 0668 0030 001E             		addi.w	#$30,_objYVel(a0)			; Apply gravity
00005948 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
0000594E 6700                       		beq.s	.NotWater			; If not, branch
00005950 0468 0020 001E             		subi.w	#$20,_objYVel(a0)			; Reduce gravity underwater
00005956                            
00005956                            .NotWater:
00005956 117C 001A 0020             		move.b	#$1A,_objAnim(a0)			; Force the hurt animation
0000595C 6100                       		bsr.s	.ChkStop			; Check if Sonic has hit the ground or the bottom boundary
0000595E                            
0000595E 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005964 6700                       		beq.s	.Cont				; If so, branch
00005966 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005968 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
0000596C                            
0000596C                            .ScrollUp:
0000596C 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005970                            
00005970                            .Cont:
00005970 6100 F80C                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00005974 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005978 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
0000597C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000597C                            .ChkStop:
0000597C 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get bottom boundary
00005980 0640 00E0                  		addi.w	#224,d0				; ''
00005984 B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic hit it?
00005988 6D00                       		blt.s	ObjPlayer_GetKilled		; If so, branch
0000598A                            
0000598A 4EB8 2C98                  		jsr	PlayerChkCollision		; Check for level collision
0000598E 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is Sonic still in midair?
00005994 6600                       		bne.s	.End				; If so, branch
00005996                            
00005996 7000                       		moveq	#0,d0
00005998 3140 001E                  		move.w	d0,_objYVel(a0)			; Stop Sonic's movement
0000599C 3140 001C                  		move.w	d0,_objXVel(a0)			; ''
000059A0 3140 003A                  		move.w	d0,_objGVel(a0)			; ''
000059A4 1140 000C                  		move.b	d0,_objFlags(a0)			; Allow Sonic to move
000059A8 1140 0020                  		move.b	d0,_objAnim(a0)			; Reset animation
000059AC 117C 0004 0025             		move.b	#4,_objRoutine(a0)			; Set back to main routine
000059B2                            
000059B2                            .End:
000059B2 4E75                       		rts
000059B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000059B4                            ; Get Sonic killed
000059B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000059B4                            ObjPlayer_GetKilled:
000059B4                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
000059B4 4A68 0008                M 	tst.w	_objdrawnext(a0)
000059B8 6600                     M 	bne.s	.no_226
000059BA 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
000059C0 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
000059C4 3149 000A                M 	move.w	a1,_objdrawprev(a0)
000059C8 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000059CC 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
000059D0                          M .no_226
000059D0 117C 000C 0025             		move.b	#$C,_objRoutine(a0)			; Set to the death routine
000059D6 4EB8 2E94                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
000059DA 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
000059DE 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set the "in air" flag
000059E4 117C 0018 0020             		move.b	#$18,_objAnim(a0)			; Set to death animation
000059EA                            
000059EA 317C F900 001E             		move.w	#-$700,_objYVel(a0)		; Make Sonic bounce up
000059F0 4268 001C                  		clr.w	_objXVel(a0)			; Lock Sonic horizontally
000059F4 4268 003A                  		clr.w	_objGVel(a0)			; ''
000059F8 31FC FFFF E8DA             		move.w	#$FFFF,camLocked.w		; Lock the camera
000059FE                            
000059FE                            	;	cmpi.l	#ObjSpike,_objAddress(a2)		; Did Sonic hit a spike?
000059FE                            	;	beq.s	.End				; If not, branch
000059FE                            		playSnd	#sDeath,2			; Play death sound
000059FE 11FC 0084 C4BD           M 	move.b	#sdeath,(mqueue+((2)-1)).w
00005A04                            
00005A04                            .End:
00005A04 70FF                       		moveq	#-1,d0				; Set return status
00005A06 4E75                       		rts
00005A08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A08                            ; Death routine
00005A08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A08                            ObjPlayer_Dead:
00005A08 4A38 C76A                  		tst.b	moveCheat.w
00005A0C 6700                       		beq.s	.NoPlacementEnter
00005A0E 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00005A14 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00005A16 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00005A1C 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00005A22 4E75                       		rts
00005A24                            
00005A24                            .NoPlacementEnter:
00005A24 117C 0018 0020             		move.b	#$18,_objAnim(a0)			; Force the death animation
00005A2A 0068 8000 000E             		ori.w	#$8000,_objVRAM(a0)		; Force high priority
00005A30 6100                       		bsr.s	ObjPlayer_ChkBound		; Check for when Sonic goes off screen
00005A32 4EB8 1D42                  		jsr	ObjectMoveAndFall.w		; Allow movement
00005A36 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005A3A 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A3E                            ObjPlayer_ChkBound:
00005A3E 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get bottom boundary
00005A42 0640 0100                  		addi.w	#$100,d0			; ''
00005A46 B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic hit it?
00005A4A 6C00                       		bge.s	.End				; If not, branch
00005A4C                            
00005A4C 117C 0010 0025             		move.b	#$10,_objRoutine(a0)			; Go to gone routine
00005A52 117C 003C 0043             		move.b	#60,_objDeathTimer(a0)		; Set death timer to 1 second
00005A58                            
00005A58                            .End:
00005A58 4E75                       		rts
00005A5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A5A                            ; Wait for level reload or game/time over
00005A5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A5A                            ObjPlayer_Gone:
00005A5A 4A28 0043                  		tst.b	_objDeathTimer(a0)
00005A5E 6700                       		beq.s	.End
00005A60 5328 0043                  		subq.b	#1,_objDeathTimer(a0)		; Decrement the death counter
00005A64 6600                       		bne.s	.End				; If it hasn't run out, branch
00005A66 50F8 E906                  		st	lvlReload.w			; Reload the level
00005A6A                            
00005A6A                            .End:
00005A6A 4E75                       		rts
00005A6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A6C                            ; Display Sonic's sprite
00005A6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A6C                            ObjPlayer_Display:
00005A6C 1028 0042                  		move.b	_objInvulTime(a0),d0		; Get invulnerability timer
00005A70 6700                       		beq.s	.Display			; If it's 0, branch
00005A72 5328 0042                  		subq.b	#1,_objInvulTime(a0)		; Decrement invulnerability timer
00005A76 E648                       		lsr.w	#3,d0				; Can Sonic's sprite be displayed?
00005A78 6500                       		bcs.s	.Display			; If so, branch
00005A7A                            	removeSprite	a0,a1,1				; Remove sprite if displayed
00005A7A 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005A7E 6700                     M 	beq.s	.yes_228
00005A80 3268 000A                M 	move.w	_objdrawprev(a0),a1
00005A84 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00005A8A 3268 0008                M 	move.w	_objdrawnext(a0),a1
00005A8E 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
00005A94                          M .no_228
00005A94 42A8 0008                M 	clr.l	_objdrawnext(a0)
00005A98                          M .yes_228
00005A98 4E75                       		rts
00005A9A                            
00005A9A                            .Display:
00005A9A                            	displaySprite	2,a0,a1,1			; Add sprite if not already being displayed
00005A9A 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005A9E 6600                     M 	bne.s	.no_229
00005AA0 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005AA6 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005AAA 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005AAE 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005AB2 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005AB6                          M .no_229
00005AB6 4E75                       		rts
00005AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005AB8                            ; Load Sonic's DPLCs
00005AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005AB8                            ObjPlayer_LoadDPLCs:
00005AB8 45F9 0000 0000             		lea	DPLC_ObjPlayer,a2		; DPLCs
00005ABE 383C F000                  		move.w	#$F000,d4			; VRAM location
00005AC2 2C3C 0000 0000             		move.l	#ArtUnc_Sonic,d6		; Art
00005AC8 4EF8 1CE8                  		jmp	LoadObjDPLCs.w			; Load DPLCs
00005ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005ACC                            ; Animate Sonic's sprite
00005ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005ACC                            ObjPlayer_Animate:
00005ACC 43F9 0000 0000             		lea	Ani_ObjPlayer,a1			; Animation script
00005AD2 7000                       		moveq	#0,d0
00005AD4 1028 0020                  		move.b	_objAnim(a0),d0			; Get animation ID
00005AD8 B028 0021                  		cmp.b	_objPrevAnim(a0),d0			; Has it changed?
00005ADC 6700                       		beq.s	.Run				; If not, branch
00005ADE 1140 0021                  		move.b	d0,_objPrevAnim(a0)			; Save the new ID
00005AE2 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00005AE6 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005AEA 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00005AF0                            
00005AF0                            .Run:
00005AF0 D040                       		add.w	d0,d0				; Turn ID into offset
00005AF2 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00005AF6 1011                       		move.b	(a1),d0				; Get first byte
00005AF8 6B00                       		bmi.s	.WalkRunAnim			; If this is a special animation, branch
00005AFA 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00005AFE 0201 0001                  		andi.b	#1,d1				; Only get horizontal flip bit
00005B02 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
00005B08 8328 000D                  		or.b	d1,_objRender(a0)			; Set flip bits
00005B0C 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00005B10 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00005B12 1140 0023                  		move.b	d0,_objAnimTimer(a0)		; Set new animation timer
00005B16                            
00005B16                            .GetFrame:
00005B16 7200                       		moveq	#0,d1
00005B18 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get current value in the script
00005B1C 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00005B20 0C00 00FD                  		cmpi.b	#$FD,d0				; Is it a command value?
00005B24 6400                       		bhs.s	.CmdReset			; If so, branch
00005B26                            
00005B26                            .Next:
00005B26 1140 0010                  		move.b	d0,_objFrame(a0)			; Set mapping frame ID
00005B2A 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Advance into the animation script
00005B2E                            
00005B2E                            .Wait:
00005B2E 4E75                       		rts
00005B30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B30                            .CmdReset:
00005B30 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00005B32 6600                       		bne.s	.CmdJump			; If not, branch
00005B34 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00005B38 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00005B3C 60E8                       		bra.s	.Next				; Continue
00005B3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B3E                            .CmdJump:
00005B3E 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00005B40 6600                       		bne.s	.CmdSetAnim			; If not, branch
00005B42 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00005B46 9128 0022                  		sub.b	d0,_objAnimFrame(a0)		; Go back
00005B4A 9200                       		sub.b	d0,d1				; ''
00005B4C 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00005B50 60D4                       		bra.s	.Next				; Continue
00005B52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B52                            .CmdSetAnim:
00005B52 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00005B54 6600                       		bne.s	.CmdEnd				; If not, branch
00005B56 1171 1002 0020             		move.b	2(a1,d1.w),_objAnim(a0)		; Set new animation ID
00005B5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B5C                            .CmdEnd:
00005B5C 4E75                       		rts
00005B5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B5E                            .WalkRunAnim:
00005B5E 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00005B62 6ACA                       		bpl.s	.Wait				; If it hasn't run out, branch
00005B64 5200                       		addq.b	#1,d0				; Is the animation walking/running?
00005B66 6600 0000                  		bne.w	.RollAnim			; If not, branch
00005B6A                            
00005B6A 7000                       		moveq	#0,d0
00005B6C 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Is Sonic tumbling in the air?
00005B70 6600 0000                  		bne.w	.TumbleAnim			; If so, branch
00005B74                            
00005B74 7200                       		moveq	#0,d1				; Intial flip bits
00005B76 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005B7A 6B00                       		bmi.s	.ChkStatus			; If it's negative, branch
00005B7C 6700                       		beq.s	.ChkStatus			; If it's zero, branch
00005B7E 5300                       		subq.b	#1,d0				; Decrement angle if it's positive
00005B80                            
00005B80                            .ChkStatus:
00005B80 1428 0028                  		move.b	_objStatus(a0),d2			; Get status
00005B84 0202 0001                  		andi.b	#1,d2				; Is Sonic mirrored horizontally?
00005B88 6600                       		bne.s	.ChkFlip			; If so, branch
00005B8A 4600                       		not.b	d0				; Reverse angle
00005B8C                            
00005B8C                            .ChkFlip:
00005B8C 0600 0010                  		addi.b	#$10,d0				; Shift angle
00005B90 6A00                       		bpl.s	.SetFlags			; If it's positive, branch
00005B92 7203                       		moveq	#3,d1				; Flags to flip Sonic's sprite
00005B94                            
00005B94                            .SetFlags:
00005B94 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits
00005B9A B302                       		eor.b	d1,d2				; Flip
00005B9C 8528 000D                  		or.b	d2,_objRender(a0)			; Set in render flags
00005BA0                            
00005BA0 0828 0005 0028             		btst	#5,_objStatus(a0)			; Is Sonic pushing?
00005BA6 6600 0000                  		bne.w	.DoPushAnim			; If so, branch
00005BAA                            
00005BAA E808                       		lsr.b	#4,d0				; Divide angle by $10
00005BAC 0200 0006                  		andi.b	#6,d0				; Get angle section
00005BB0                            
00005BB0 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00005BB4 6A00                       		bpl.s	.GetAnim			; If it's already positive, branch
00005BB6 4442                       		neg.w	d2				; Force it to be positive
00005BB8                            
00005BB8                            .GetAnim:
00005BB8 43F9 0000 0000             		lea	SonicAni_Sprint,a1		; Sprinting animation
00005BBE 4A00                       		tst.b	d0
00005BC0 6600                       		bne.s	.ChkRun
00005BC2 0C42 0C00                  		cmpi.w	#$C00,d2			; Is Sonic sprinting?
00005BC6 6400                       		bcc.s	.SkipWalk			; If so, branch
00005BC8                            
00005BC8                            .ChkRun:
00005BC8 43F9 0000 0000             		lea	SonicAni_Run,a1			; Running animation
00005BCE 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic running?
00005BD2 6400                       		bcc.s	.SkipWalk			; If so, branch
00005BD4 43F9 0000 0000             		lea	SonicAni_Walk,a1		; Walking animation
00005BDA 1200                       		move.b	d0,d1				; Multiply angle section ID by 3
00005BDC E209                       		lsr.b	#1,d1				; ''
00005BDE D001                       		add.b	d1,d0				; ''
00005BE0                            
00005BE0                            .SkipWalk:
00005BE0 D000                       		add.b	d0,d0				; Double the offset
00005BE2 1600                       		move.b	d0,d3				; Copy the oofset
00005BE4 4442                       		neg.w	d2				; Get animation speed
00005BE6 0642 0800                  		addi.w	#$800,d2			; ''
00005BEA 6A00                       		bpl.s	.SetTimer			; ''
00005BEC 7400                       		moveq	#0,d2				; ''
00005BEE                            
00005BEE                            .SetTimer:
00005BEE E04A                       		lsr.w	#8,d2				; ''
00005BF0 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
00005BF4 6100 FF20                  		bsr.w	.GetFrame			; Get the next frame
00005BF8 D728 0010                  		add.b	d3,_objFrame(a0)			; Add angle offset
00005BFC 4E75                       		rts
00005BFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BFE                            .TumbleAnim:
00005BFE 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Get flip angle
00005C02 7200                       		moveq	#0,d1
00005C04 1428 0028                  		move.b	_objStatus(a0),d2			; Get status
00005C08 0202 0001                  		andi.b	#1,d2				; Are we are facing left?
00005C0C 6600                       		bne.s	.TumbleLeft			; If so, branch
00005C0E                            
00005C0E 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits
00005C14 0600 000B                  		addi.b	#$B,d0				; Get map frame
00005C18 80FC 0016                  		divu.w	#$16,d0				; ''
00005C1C 0600 0068                  		addi.b	#$68,d0				; ''
00005C20 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00005C24 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005C28 4E75                       		rts
00005C2A                            
00005C2A                            .TumbleLeft:
00005C2A 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits
00005C30 4A28 0048                  		tst.b	_objFlipTurned(a0)			; Is flipping inverted?
00005C34 6700                       		beq.s	.NotInverted			; If not, branch
00005C36 0028 0001 000D             		ori.b	#1,_objRender(a0)			; Face left
00005C3C 0600 000B                  		addi.b	#$B,d0				; Get map frame
00005C40 6000                       		bra.s	.SetLeftFrame			; Continue
00005C42                            
00005C42                            .NotInverted:
00005C42 0028 0003 000D             		ori.b	#3,_objRender(a0)			; Face left and be upside down
00005C48 4400                       		neg.b	d0				; Get map frame
00005C4A 0600 008F                  		addi.b	#$8F,d0				; ''
00005C4E                            
00005C4E                            .SetLeftFrame:
00005C4E 80FC 0016                  		divu.w	#$16,d0				; Continue getting map frame
00005C52 0600 0068                  		addi.b	#$68,d0				; ''
00005C56 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00005C5A 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005C5E 4E75                       		rts
00005C60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C60                            .RollAnim:
00005C60 5200                       		addq.b	#1,d0				; Is the animation rolling?
00005C62 6600                       		bne.s	.PushAnim			; If not, branch
00005C64                            
00005C64 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00005C68 6A00                       		bpl.s	.GetAnim2			; If it's already negative, branch
00005C6A 4442                       		neg.w	d2				; Force it to be negative
00005C6C                            
00005C6C                            .GetAnim2:
00005C6C 43F9 0000 0000             		lea	SonicAni_Roll2,a1		; Use fast animation
00005C72 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic rolling fast enough?
00005C76 6400                       		bcc.s	.PrepareTimer			; If so, branch
00005C78 43F9 0000 0000             		lea	SonicAni_Roll,a1		; Use slower animation
00005C7E                            
00005C7E                            .PrepareTimer:
00005C7E 4442                       		neg.w	d2				; Get animation speed
00005C80 0642 0400                  		addi.w	#$400,d2			; ''
00005C84 6A00                       		bpl.s	.SetTimer2			; ''
00005C86 7400                       		moveq	#0,d2				; ''
00005C88                            
00005C88                            .SetTimer2:
00005C88 E04A                       		lsr.w	#8,d2				; ''
00005C8A 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
00005C8E                            
00005C8E 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00005C92 0201 0001                  		andi.b	#1,d1				; Get horizontal flip flag only
00005C96 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits in render flags
00005C9C 8328 000D                  		or.b	d1,_objRender(a0)			; Set new flip bits
00005CA0                            
00005CA0 6000 FE74                  		bra.w	.GetFrame			; Get the next frame
00005CA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CA4                            .PushAnim:
00005CA4 5200                       		addq.b	#1,d0				; Is the animation rolling?
00005CA6 6600                       		bne.s	.HangAnim			; If not, branch
00005CA8                            
00005CA8                            .DoPushAnim:
00005CA8 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00005CAC 6B00                       		bmi.s	.GetAnim3			; If it's already negative, branch
00005CAE 4442                       		neg.w	d2				; Force it to be negative
00005CB0                            
00005CB0                            .GetAnim3:
00005CB0 0642 0800                  		addi.w	#$800,d2			; Get animation speed
00005CB4 6A00                       		bpl.s	.SetTimer3			; ''
00005CB6 7400                       		moveq	#0,d2				; ''
00005CB8                            
00005CB8                            .SetTimer3:
00005CB8 EC4A                       		lsr.w	#6,d2				; ''
00005CBA 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
00005CBE 43F9 0000 0000             		lea	SonicAni_Push,a1		; Pushing animation
00005CC4 6000 FE50                  		bra.w	.GetFrame			; Get the next frame
00005CC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CC8                            .HangAnim:
00005CC8 7200                       		moveq	#0,d1
00005CCA 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get animation frame
00005CCE 1171 1001 0010             		move.b	1(a1,d1.w),_objFrame(a0)		; Set map frame
00005CD4 4228 0023                  		clr.b	_objAnimTimer(a0)			; Clear animation timer
00005CD8 4E75                       		rts
00005CDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CDA                            ; Handle debug placement mode
00005CDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CDA                            DebugPlacement:
00005CDA 7000                       		moveq	#0,d0
00005CDC 1038 E8DD                  		move.b	debugMode.w,d0		; Get debug placement mode routine
00005CE0 0240 0002                  		andi.w	#2,d0				; Only allow 0, 2, 4, and 6
00005CE4 D040                       		add.w	d0,d0				; Double it
00005CE6 4EBB 0000                  		jsr	.Routines(pc,d0.w)		; Go to the correct routine
00005CEA                            	nextObject
00005CEA 3068 0004                M 	movea.w	_objnext(a0),a0
00005CEE 2250                     M 	move.l	_objaddress(a0),a1
00005CF0 4ED1                     M 	jmp	(a1)
00005CF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CF2                            .Routines:
00005CF2 6000 0000                  		bra.w	Debug_Init			; Initialization(00*2)
00005CF6 6000 0000                  		bra.w	Debug_Main			; Main		(02*2)
00005CFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CFA                            Debug_Init:
00005CFA 5438 E8DD                  		addq.b	#2,debugMode.w		; Next routine
00005CFE 4228 0010                  		clr.b	_objFrame(a0)			; Reset mapping frame
00005D02 4228 0020                  		clr.b	_objAnim(a0)			; Reset animation
00005D06 4268 003A                  		clr.w	_objGVel(a0)			; Reset ground velocity
00005D0A 4278 E8DA                  		clr.w	camLocked.w			; Unlock the camera
00005D0E 4228 004B                  		clr.b	_objBallMode(a0)			; Reset ball mode
00005D12 4228 0041                  		clr.b	_objAngle(a0)			; Reset angle
00005D16 117C 0004 0025             		move.b	#4,_objRoutine(a0)			; Set routine to main
00005D1C                            
00005D1C 3028 003C                  		move.w	_objInteract(a0),d0		; Get object interacted with last
00005D20 6700                       		beq.s	.NoInteract			; If there is none, branch
00005D22 3240                       		movea.w	d0,a1
00005D24 08A9 0003 0028             		bclr	#3,_objStatus(a1)			; Clear flags
00005D2A 08A9 0005 0028             		bclr	#5,_objStatus(a1)			; ''
00005D30 4268 003C                  		clr.w	_objInteract(a0)			; No more interaction
00005D34                            
00005D34                            .NoInteract:
00005D34 4228 000C                  		clr.b	_objFlags(a0)			; Reset flags
00005D38 4228 0028                  		clr.b	_objStatus(a0)			; Reset status
00005D3C 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
00005D42 117C 0001 0010             		move.b	#1,_objFrame(a0)			; Display the standing frame
00005D48 6100 FD6E                  		bsr.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D4C                            Debug_Main:
00005D4C 6100 EE20                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
00005D50 6100                       		bsr.s	Debug_Control			; Control
00005D52                            	displaySprite	2,a0,a2,1
00005D52 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005D56 6600                     M 	bne.s	.no_231
00005D58 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005D5E 3478 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a2
00005D62 314A 000A                M 	move.w	a2,_objdrawprev(a0)
00005D66 3548 0008                M 	move.w	a0,_objdrawnext(a2)
00005D6A 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005D6E                          M .no_231
00005D6E 4E75                       		rts
00005D70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D70                            Debug_Control:
00005D70 7006                       		moveq	#6,d0				; Speed
00005D72 0838 0000 C742             		btst	#0,ctrlHoldP1.w			; Is up being held?
00005D78 6700                       		beq.s	.NoUp				; If not, branch
00005D7A 9168 0018                  		sub.w	d0,_objYPos(a0)			; Move up
00005D7E                            
00005D7E                            .NoUp:
00005D7E 0838 0001 C742             		btst	#1,ctrlHoldP1.w			; Is down being held?
00005D84 6700                       		beq.s	.NoDown				; If not, branch
00005D86 D168 0018                  		add.w	d0,_objYPos(a0)			; Move down
00005D8A                            
00005D8A                            .NoDown:
00005D8A 0838 0002 C742             		btst	#2,ctrlHoldP1.w			; Is left being held?
00005D90 6700                       		beq.s	.NoLeft				; If not, branch
00005D92 9168 0014                  		sub.w	d0,_objXPos(a0)			; Move left
00005D96                            
00005D96                            .NoLeft:
00005D96 0838 0003 C742             		btst	#3,ctrlHoldP1.w			; Is right being held?
00005D9C 6700                       		beq.s	.NoRight			; If not, branch
00005D9E D168 0014                  		add.w	d0,_objXPos(a0)			; Move right
00005DA2                            
00005DA2                            .NoRight:
00005DA2 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00005DA8 6700                       		beq.s	.ChkWrap			; If not, branch
00005DAA 7000                       		moveq	#0,d0
00005DAC 11C0 E8DD                  		move.b	d0,debugMode.w		; Disable debug placement mode
00005DB0 1140 0016                  		move.b	d0,_objXPos+2(a0)			; Reset X subpixel
00005DB4 1140 001A                  		move.b	d0,_objYPos+2(a0)			; Reset Y subpixel
00005DB8 3140 001C                  		move.w	d0,_objXVel(a0)			; Reset X velocity
00005DBC 3140 001E                  		move.w	d0,_objYVel(a0)			; Reset Y velocity
00005DC0 3140 003A                  		move.w	d0,_objGVel(a0)			; Reset ground velocity
00005DC4 0228 0001 0028             		andi.b	#1,_objStatus(a0)			; Reset status
00005DCA 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00005DD0 20BC 0000 4A8E             		move.l	#ObjPlayer,_objAddress(a0)		; Use normal Sonic object
00005DD6 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00005DDC 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
00005DE2                            
00005DE2                            .ChkWrap:
00005DE2 4E75                       		rts
00005DE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DE4                            ; Data
00005DE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DE4                            Map_ObjPlayer:
00005DE4                            		include	"Objects/Player/Mappings.asm"
00005DE4                            Map_79b3:
00005DE4 0000                       Map_79b3_0: 	dc.w Map_79b3_8-Map_79b3
00005DE6 0000                       Map_79b3_2: 	dc.w Map_79b3_A-Map_79b3
00005DE8 0000                       Map_79b3_4: 	dc.w Map_79b3_12-Map_79b3
00005DEA 0000                       Map_79b3_6: 	dc.w Map_79b3_1A-Map_79b3
00005DEC 0000                       Map_79b3_8: 	dc.b $0, $0
00005DEE 0001                       Map_79b3_A: 	dc.b $0, $1
00005DF0 FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00005DF6 0001                       Map_79b3_12: 	dc.b $0, $1
00005DF8 FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00005DFE 0001                       Map_79b3_1A: 	dc.b $0, $1
00005E00 FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00005E06                            	even
00005E06                            		even
00005E06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E06                            DPLC_ObjPlayer:
00005E06                            		include	"Objects/Player/DPLCs.asm"
00005E06                            DPLC_bf0f:
00005E06 0000                       DPLC_bf0f_0: 	dc.w DPLC_bf0f_8-DPLC_bf0f
00005E08 0000                       DPLC_bf0f_2: 	dc.w DPLC_bf0f_A-DPLC_bf0f
00005E0A 0000                       DPLC_bf0f_4: 	dc.w DPLC_bf0f_E-DPLC_bf0f
00005E0C 0000                       DPLC_bf0f_6: 	dc.w DPLC_bf0f_12-DPLC_bf0f
00005E0E 0000                       DPLC_bf0f_8: 	dc.b $0, $0
00005E10 0001                       DPLC_bf0f_A: 	dc.b $0, $1
00005E12 3000                       	dc.b $30, $0
00005E14 0001                       DPLC_bf0f_E: 	dc.b $0, $1
00005E16 3008                       	dc.b $30, $8
00005E18 0001                       DPLC_bf0f_12: 	dc.b $0, $1
00005E1A 3004                       	dc.b $30, $4
00005E1C                            	even
00005E1C                            		even
00005E1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E1C                            Ani_ObjPlayer:
00005E1C                            		include	"Objects/Player/Animations.asm"
00005E1C                            ; ---------------------------------------------------------------------------
00005E1C                            ; Animation script - Sonic
00005E1C                            ; ---------------------------------------------------------------------------
00005E1C                            SonicAniData:
00005E1C 0000                       		dc.w SonicAni_Blank-SonicAniData
00005E1E 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E20 0000                       		dc.w SonicANi_Flap-SonicAniData
00005E22 0000                       		dc.w SonicANi_Flap-SonicAniData
00005E24 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E26 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E28 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E2A 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E2C 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E2E 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E30 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E32 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E34 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E36 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E38 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E3A 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E3C 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E3E 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E40 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E42 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E44 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E46 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E48 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E4A 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E4C 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E4E 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E50 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E52 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E54 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E56 0000                       		dc.w SonicANi_Blank-SonicAniData
00005E58 0000                       		dc.w SonicANi_FlapB-SonicAniData
00005E5A 0101 FD00                  SonicAni_Blank:		dc.b 1, 1, $FD, 0
00005E5E                            		even
00005E5E 03FD 1E                    SonicANi_Flap:		dc.b	3,	$FD,	$1E
00005E61 0301 0203 0201 FD00        SonicANi_FlapB:		dc.b	3,	1,	2,	3,	2,	1, $FD,	0
00005E69                            sonicani_sprint:
00005E69                            sonicani_run:
00005E69                            sonicani_walk:
00005E69                            sonicani_roll2:
00005E69                            sonicani_roll:
00005E69                            sonicani_push:
00005E6A 00                         		even
00005E6A                            ; =========================================================================================================================================================
00005E6A                            		include	"Objects/Ring/Code.asm"		; Ring loss object
00005E6A                            ; =========================================================================================================================================================
00005E6A                            ; Water surface object
00005E6A                            ; =========================================================================================================================================================
00005E6A                            		rsset	_objLvlSSTs
00005E6A                            
00005E6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E6A                            ObjRingLoss:
00005E6A 2248                       		movea.l	a0,a1
00005E6C 7A00                       		moveq	#0,d5
00005E6E 3A3C 0001                  		move.w	#1,d5
00005E72 7020                       		moveq	#32,d0
00005E74 BA40                       		cmp.w	d0,d5
00005E76 6500                       		bcs.s	.BelowMax
00005E78 3A00                       		move.w	d0,d5
00005E7A                            
00005E7A                            .BelowMax:
00005E7A 5345                       		subq.w	#1,d5
00005E7C 47F9 0000 0000             		lea	ObjLostRing_Speeds,a3
00005E82 6000                       		bra.s	.MakeRings
00005E84                            
00005E84                            .Loop:
00005E84 4EB8 1A1C                  		jsr	FindFreeObj.w
00005E88 6700                       		beq.s	.ResetCounter
00005E8A                            
00005E8A                            .MakeRings:
00005E8A 22BC 0000 0000             		move.l	#ObjLostRing,_objAddress(a1)
00005E90 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
00005E96 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
00005E9C 237C 0000 0000 0010        		move.l	#Map_ObjLostRing,_objMapping(a1)	; Mappings
00005EA4 337C 26B4 000E             		move.w	#$26B4,_objVRAM(a1)		; Tile properties
00005EAA 137C 0004 000D             		move.b	#4,_objRender(a1)			; Render flags
00005EB0                            	displaySprite	3,a1,a2,0			; Priority
00005EB0 337C C172 0008           M 	move.w	#objdisplay+(3*dsize),_objdrawnext(a1)
00005EB6 3478 C17C                M 	move.w	objdisplay+dprev+(3*dsize).w,a2
00005EBA 334A 000A                M 	move.w	a2,_objdrawprev(a1)
00005EBE 3549 0008                M 	move.w	a1,_objdrawnext(a2)
00005EC2 31C9 C17C                M 	move.w	a1,objdisplay+dprev+(3*dsize).w
00005EC6                          M .no_232
00005EC6 137C 0008 0017             		move.b	#8,_objDrawW(a1)			; Sprite width
00005ECC 137C 0008 001B             		move.b	#8,_objDrawH(a1)			; Sprite height
00005ED2 137C 0008 002C             		move.b	#8,_objColW(a1)			; Collision width
00005ED8 137C 0008 002D             		move.b	#8,_objColH(a1)			; Collision height
00005EDE 335B 001C                  		move.w	(a3)+,_objXVel(a1)
00005EE2 335B 001E                  		move.w	(a3)+,_objYVel(a1)
00005EE6 51CD FF9C                  		dbf	d5,.Loop
00005EEA 11FC 00FF E864             		move.b	#-1,ringLossAnimT.w
00005EF0                            
00005EF0                            .ResetCounter:
00005EF0 4278 E85E                  		clr.w	ringCount.w
00005EF4 11FC 0001 E867             		move.b	#1,hudUpdateRings.w
00005EFA                            		playSnd	#sRingLoss, 2
00005EFA 11FC 008D C4BD           M 	move.b	#sringloss,(mqueue+((2)-1)).w
00005F00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F00                            ObjLostRing:
00005F00 4EB8 1D28                  		jsr	ObjectMove.w
00005F04 0668 0018 001E             		addi.w	#$18,_objYVel(a0)
00005F0A 6B00                       		bmi.s	.ChkCol
00005F0C 1038 C75B                  		move.b	(frameCounter+3).w,d0
00005F10 D048                       		add.w	a0,d0
00005F12 0200 0006                  		andi.b	#6,d0
00005F16 6600                       		bne.s	.ChkCol
00005F18 4EB8 30B4                  		jsr	ObjCheckFloorDist
00005F1C 4A41                       		tst.w	d1
00005F1E 6A00                       		bpl.s	.ChkCol
00005F20 D368 0018                  		add.w	d1,_objYPos(a0)
00005F24 3028 001E                  		move.w	_objYVel(a0),d0
00005F28 E440                       		asr.w	#2,d0
00005F2A 9168 001E                  		sub.w	d0,_objYVel(a0)
00005F2E 4468 001E                  		neg.w	_objYVel(a0)
00005F32                            
00005F32                            .ChkCol:
00005F32 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00005F36 3478 E876                  		movea.w	playerPtrP1.w,a2		; Player object
00005F3A 4EB8 1D62                  		jsr	CheckObjInRange.w		; Is the player in range?
00005F3E 4A40                       		tst.w	d0				; ''
00005F40 6700                       		beq.s	.ChkDel				; If not, branch
00005F42 0C2A 0069 0042             		cmpi.b	#105,_objInvulTime(a2)
00005F48 6400                       		bhs.s	.ChkDel
00005F4A 6000                       		bra.s	ObjLostRing_Collect
00005F4C                            
00005F4C                            .ChkDel:
00005F4C 4A38 E864                  		tst.b	ringLossAnimT.w
00005F50 6700 0000                  		beq.w	ObjLostRing_Delete
00005F54 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get max camera Y position
00005F58 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
00005F5C B068 0018                  		cmp.w	_objYPos(a0),d0			; Have we touched the bottom boundary?
00005F60 6D00                       		blt.s	ObjLostRing_Delete		; If so, branch
00005F62                            	nextObject
00005F62 3068 0004                M 	movea.w	_objnext(a0),a0
00005F66 2250                     M 	move.l	_objaddress(a0),a1
00005F68 4ED1                     M 	jmp	(a1)
00005F6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F6A                            .RangeData:
00005F6A FFF0 0020                  		dc.w	-$10, $20
00005F6E FFF0 0020                  		dc.w	-$10, $20
00005F72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F72                            ObjLostRing_Collect:
00005F72                            	removeSprite	a0,a1,0
00005F72 3268 000A                M 	move.w	_objdrawprev(a0),a1
00005F76 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00005F7C 3268 0008                M 	move.w	_objdrawnext(a0),a1
00005F80 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
00005F86                          M .no_235
00005F86 42A8 0008                M 	clr.l	_objdrawnext(a0)
00005F8A                          M .yes_235
00005F8A                            	displaySprite	1,a0,a1,0
00005F8A 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
00005F90 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
00005F94 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005F98 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005F9C 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
00005FA0                          M .no_236
00005FA0 4EB8 3FC0                  		jsr	CollectRing
00005FA4 20BC 0000 0000             		move.l	#ObjLostRing_Sparkle,(a0)
00005FAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005FAA                            ObjLostRing_Sparkle:
00005FAA 43F9 0000 0000             		lea	Ani_ObjRing,a1
00005FB0 4EB8 1C42                  		jsr	AnimateObject.w
00005FB4 4A28 0025                  		tst.b	_objRoutine(a0)
00005FB8 6600                       		bne.s	ObjLostRing_Delete
00005FBA                            	nextObject
00005FBA 3068 0004                M 	movea.w	_objnext(a0),a0
00005FBE 2250                     M 	move.l	_objaddress(a0),a1
00005FC0 4ED1                     M 	jmp	(a1)
00005FC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005FC2                            ObjLostRing_Delete:
00005FC2 4EB8 1A4C                  		jsr	DeleteObject.w
00005FC6                            	nextObject
00005FC6 3068 0004                M 	movea.w	_objnext(a0),a0
00005FCA 2250                     M 	move.l	_objaddress(a0),a1
00005FCC 4ED1                     M 	jmp	(a1)
00005FCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005FCE                            ; Ring Spawn Array
00005FCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005FCE                            ObjLostRing_Speeds:
00005FCE FF3C FC14 00C4 FC14 FDC8+  		dc.w	$FF3C,$FC14,$00C4,$FC14,$FDC8,$FCB0,$0238,$FCB0
00005FDE FCB0 FDC8 0350 FDC8 FC14+  		dc.w	$FCB0,$FDC8,$0350,$FDC8,$FC14,$FF3C,$03EC,$FF3C
00005FEE FC14 00C4 03EC 00C4 FCB0+  		dc.w	$FC14,$00C4,$03EC,$00C4,$FCB0,$0238,$0350,$0238
00005FFE FDC8 0350 0238 0350 FF3C+  		dc.w	$FDC8,$0350,$0238,$0350,$FF3C,$03EC,$00C4,$03EC
0000600E FF9E FE0A 0062 FE0A FEE4+  		dc.w	$FF9E,$FE0A,$0062,$FE0A,$FEE4,$FE58,$011C,$FE58
0000601E FE58 FEE4 01A8 FEE4 FE0A+  		dc.w	$FE58,$FEE4,$01A8,$FEE4,$FE0A,$FF9E,$01F6,$FF9E
0000602E FE0A 0062 01F6 0062 FE58+  		dc.w	$FE0A,$0062,$01F6,$0062,$FE58,$011C,$01A8,$011C
0000603E FEE4 01A8 011C 01A8 FF9E+  		dc.w	$FEE4,$01A8,$011C,$01A8,$FF9E,$01F6,$0062,$01F6
0000604E                            		even
0000604E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000604E                            ; Data
0000604E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000604E                            Map_ObjLostRing:
0000604E                            		include	"Objects/Ring/Mappings.asm"
0000604E                            ; --------------------------------------------------------------------------------
0000604E                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0000604E                            ; --------------------------------------------------------------------------------
0000604E                            
0000604E                            SME_k4ulR:	
0000604E 0000 0000                  		dc.w SME_k4ulrA-SME_k4ulR, SME_k4ulrC-SME_k4ulR	
00006052 0000 0000                  		dc.w SME_k4ulr14-SME_k4ulR, SME_k4ulr1C-SME_k4ulR	
00006056 0000                       		dc.w SME_k4ulr24-SME_k4ulR	
00006058 0001                       SME_k4ulrA:	dc.b 0, 1	
0000605A F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8
00006060 0001                       SME_k4ulrC:	dc.b 0, 1	
00006062 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00006068 0001                       SME_k4ulr14:	dc.b 0, 1	
0000606A F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00006070 0001                       SME_k4ulr1C:	dc.b 0, 1	
00006072 F805 0804 FFF8             		dc.b $F8, 5, 8, 4, $FF, $F8	
00006078 0001                       SME_k4ulr24:	dc.b 0, 1	
0000607A F805 1004 FFF8             		dc.b $F8, 5, $10, 4, $FF, $F8	
00006080                            		even
00006080                            		even
00006080                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006080                            Ani_ObjRing:
00006080 0000                       		dc.w	.Ani0-Ani_ObjRing
00006082 0501 0203 04FC             .Ani0:		dc.b	5, 1, 2, 3, 4, $FC
00006088                            		even
00006088                            ; =========================================================================================================================================================
00006088                            		include	"Objects/Explosion/Code.asm"	; Explosion object
00006088                            ; =========================================================================================================================================================
00006088                            ; Explosion object
00006088                            ; =========================================================================================================================================================
00006088 =00000003                  EXPLODE_ANI	EQU	3
00006088                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006088                            ObjBossExplode:
00006088                            		playSnd	#sBomb, 2			; Play explosion sound
00006088 11FC 0099 C4BD           M 	move.b	#sbomb,(mqueue+((2)-1)).w
0000608E 6000                       		bra.s	ObjExplosion_Init		; Continue
00006090                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006090                            ObjExplosion:
00006090                            		playSnd	#sBreakItem, 2			; Play explosion sound
00006090 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
00006096                            
00006096                            ObjExplosion_Init:
00006096 20BC 0000 0000             		move.l	#ObjExplosion_Main,_objAddress(a0)	; Next routine
0000609C 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
000060A2 317C 86C0 000E             		move.w	#$86C0,_objVRAM(a0)		; Tile properties
000060A8 217C 0000 0000 0010        		move.l	#Map_ObjExplosion,_objMapping(a0)	; Mappings
000060B0                            	displaySprite	1,a0,a1,0			; Priority
000060B0 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
000060B6 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
000060BA 3149 000A                M 	move.w	a1,_objdrawprev(a0)
000060BE 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000060C2 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
000060C6                          M .no_241
000060C6 117C 000C 0017             		move.b	#$C,_objDrawW(a0)			; Sprite width
000060CC 117C 000C 001B             		move.b	#$C,_objDrawH(a0)			; Sprite height
000060D2 117C 0003 0023             		move.b	#EXPLODE_ANI,_objAnimTimer(a0)	; Animation timer
000060D8 4228 0010                  		clr.b	_objFrame(a0)			; Mapping frame
000060DC                            		
000060DC                            ObjExplosion_Main:
000060DC 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
000060E0 6A00                       		bpl.s	.Display			; If it hasn't run out, branch
000060E2 117C 0003 0023             		move.b	#EXPLODE_ANI,_objAnimTimer(a0)	; Reset animation timer
000060E8 5228 0010                  		addq.b	#1,_objFrame(a0)			; Next frame
000060EC 0C28 0005 0010             		cmpi.b	#5,_objFrame(a0)			; Has it reached the last frame?
000060F2 6600                       		bne.s	.Display			; If not, branch
000060F4 4EB8 1A4C                  		jsr	DeleteObject.w
000060F8                            		
000060F8                            .Display:
000060F8                            	nextObject
000060F8 3068 0004                M 	movea.w	_objnext(a0),a0
000060FC 2250                     M 	move.l	_objaddress(a0),a1
000060FE 4ED1                     M 	jmp	(a1)
00006100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006100                            ; Data
00006100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006100                            Map_ObjExplosion:
00006100                            		include	"Objects/Explosion/Mappings.asm"
00006100                            ; --------------------------------------------------------------------------------
00006100                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006100                            ; --------------------------------------------------------------------------------
00006100                            
00006100                            SME_PS_OI:	
00006100 0000 0000                  		dc.w SME_PS_OI_A-SME_PS_OI, SME_PS_OI_12-SME_PS_OI	
00006104 0000 0000                  		dc.w SME_PS_OI_1A-SME_PS_OI, SME_PS_OI_22-SME_PS_OI	
00006108 0000                       		dc.w SME_PS_OI_3C-SME_PS_OI	
0000610A 0001                       SME_PS_OI_A:	dc.b 0, 1	
0000610C F809 0000 FFF4             		dc.b $F8, 9, 0, 0, $FF, $F4	
00006112 0001                       SME_PS_OI_12:	dc.b 0, 1	
00006114 F00F 0020 FFF0             		dc.b $F0, $F, 0, $20, $FF, $F0	
0000611A 0001                       SME_PS_OI_1A:	dc.b 0, 1	
0000611C F00F 0030 FFF0             		dc.b $F0, $F, 0, $30, $FF, $F0	
00006122 0004                       SME_PS_OI_22:	dc.b 0, 4	
00006124 EC0A 0006 FFEC             		dc.b $EC, $A, 0, 6, $FF, $EC	
0000612A EC05 000F 0004             		dc.b $EC, 5, 0, $F, 0, 4	
00006130 0405 180F FFEC             		dc.b 4, 5, $18, $F, $FF, $EC	
00006136 FC0A 1806 FFFC             		dc.b $FC, $A, $18, 6, $FF, $FC	
0000613C 0004                       SME_PS_OI_3C:	dc.b 0, 4	
0000613E EC0A 0013 FFEC             		dc.b $EC, $A, 0, $13, $FF, $EC	
00006144 EC05 001C 0004             		dc.b $EC, 5, 0, $1C, 0, 4	
0000614A 0405 181C FFEC             		dc.b 4, 5, $18, $1C, $FF, $EC	
00006150 FC0A 1813 FFFC             		dc.b $FC, $A, $18, $13, $FF, $FC	
00006156                            		even
00006156                            		even
00006156                            ; =========================================================================================================================================================
00006156                            		include	"Objects/Water Surface/Code.asm"	; Water surface object
00006156                            ; =========================================================================================================================================================
00006156                            ; Water surface object
00006156                            ; =========================================================================================================================================================
00006156                            		rsset	_objLvlSSTs
00006156 =00000030                  _objSurfPause	rs.b	1			; Animation stop flag
00006156                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006156                            ObjWaterSurface:
00006156 20BC 0000 0000             		move.l	#ObjWaterSurface_Main,_objAddress(a0)	; Next routine
0000615C 217C 0000 0000 0010        		move.l	#Map_ObjWaterSurface,_objMapping(a0)	; Mappings
00006164 317C 8690 000E             		move.w	#$8690,_objVRAM(a0)		; Tile properties
0000616A 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00006170                            	displaySprite	0,a0,a1,0			; Priority
00006170 317C C15A 0008           M 	move.w	#objdisplay+(0*dsize),_objdrawnext(a0)
00006176 3278 C164                M 	move.w	objdisplay+dprev+(0*dsize).w,a1
0000617A 3149 000A                M 	move.w	a1,_objdrawprev(a0)
0000617E 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006182 31C8 C164                M 	move.w	a0,objdisplay+dprev+(0*dsize).w
00006186                          M .no_243
00006186 117C 0080 0017             		move.b	#$80,_objDrawW(a0)			; Sprite width
0000618C 117C 0020 001B             		move.b	#$20,_objDrawH(a0)			; Sprite height
00006192                            
00006192                            ObjWaterSurface_Main:
00006192 3238 E900                  		move.w	waterYPos.w,d1		; Get water height
00006196 5D41                       		subq.w	#6,d1				; Shift it
00006198 3141 0018                  		move.w	d1,_objYPos(a0)			; Set Y position
0000619C                            
0000619C 4A28 0030                  		tst.b	_objSurfPause(a0)			; Is the animation paused?
000061A0 6600                       		bne.s	.ChkUnpause			; If so, branch
000061A2 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
000061A8 6700                       		beq.s	.Animate			; If not, branch
000061AA 5628 0010                  		addq.b	#3,_objFrame(a0)			; Use different frames
000061AE 50E8 0030                  		st	_objSurfPause(a0)			; Pause the animation
000061B2 6000                       		bra.s	.Animate			; Continue
000061B4                            
000061B4                            .ChkUnpause:
000061B4 4A38 C75E                  		tst.b	pauseFlag.w			; Is the game paused?
000061B8 6600                       		bne.s	.Animate			; If so, branch
000061BA 4228 0030                  		clr.b	_objSurfPause(a0)			; Resume animation
000061BE 5728 0010                  		subq.b	#3,_objFrame(a0)			; Use normal frames
000061C2                            
000061C2                            .Animate:
000061C2 43FA 0000                  		lea	.AniScript(pc),a1		; Get animation script
000061C6 7200                       		moveq	#0,d1
000061C8 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get animation script frame
000061CC 1171 1000 0010             		move.b	(a1,d1.w),_objFrame(a0)		; Set mapping frame
000061D2 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Next frame in animation script
000061D6 0228 003F 0022             		andi.b	#$3F,_objAnimFrame(a0)		; Loop in necessary
000061DC                            	nextObject
000061DC 3068 0004                M 	movea.w	_objnext(a0),a0
000061E0 2250                     M 	move.l	_objaddress(a0),a1
000061E2 4ED1                     M 	jmp	(a1)
000061E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000061E4                            .AniScript:
000061E4 0001 0001 0001 0001 0001+  		dc.b	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
000061F4 0102 0102 0102 0102 0102+  		dc.b	1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2
00006204 0201 0201 0201 0201 0201+  		dc.b	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1
00006214 0100 0100 0100 0100 0100+  		dc.b	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
00006224 00                         		even
00006224                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006224                            ; Data
00006224                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006224                            Map_ObjWaterSurface:
00006224                            		include	"Objects/Water Surface/Mappings.asm"
00006224                            MapConv_obj1B:
00006224 0000                       	dc.w	byte_11178-MapConv_obj1B
00006226 0000                       	dc.w	byte_11188-MapConv_obj1B
00006228 0000                       	dc.w	byte_11198-MapConv_obj1B
0000622A 0000                       	dc.w	byte_111A8-MapConv_obj1B
0000622C 0000                       	dc.w	byte_111C7-MapConv_obj1B
0000622E 0000                       	dc.w	byte_111E6-MapConv_obj1B
00006230                            
00006230 0003                       byte_11178:	dc.w 3
00006232 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
00006238 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
0000623E FD0D 0000 0020             	dc.w $FD0D, 0, $20
00006244                            
00006244 0003                       byte_11188:	dc.w 3
00006246 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
0000624C FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
00006252 FD0D 0008 0020             	dc.w $FD0D, 8, $20
00006258                            
00006258 0003                       byte_11198:	dc.w 3
0000625A FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
00006260 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
00006266 FD0D 0800 0020             	dc.w $FD0D, $800, $20
0000626C                            
0000626C 0006                       byte_111A8:	dc.w 6
0000626E FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
00006274 FD0D 0000 FFC0             	dc.w $FD0D, 0, $FFC0
0000627A FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00006280 FD0D 0000 0000             	dc.w $FD0D, 0, 0
00006286 FD0D 0000 0020             	dc.w $FD0D, 0, $20
0000628C FD0D 0000 0040             	dc.w $FD0D, 0, $40
00006292                            
00006292 0006                       byte_111C7:	dc.w 6
00006294 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
0000629A FD0D 0008 FFC0             	dc.w $FD0D, 8, $FFC0
000062A0 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
000062A6 FD0D 0008 0000             	dc.w $FD0D, 8, 0
000062AC FD0D 0008 0020             	dc.w $FD0D, 8, $20
000062B2 FD0D 0008 0040             	dc.w $FD0D, 8, $40
000062B8                            
000062B8 0006                       byte_111E6:	dc.w 6
000062BA FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
000062C0 FD0D 0800 FFC0             	dc.w $FD0D, $800, $FFC0
000062C6 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
000062CC FD0D 0800 0000             	dc.w $FD0D, $800, 0
000062D2 FD0D 0800 0020             	dc.w $FD0D, $800, $20
000062D8 FD0D 0800 0040             	dc.w $FD0D, $800, $40
000062DE                            
000062DE                            	even
000062DE                            		even
000062DE                            ; =========================================================================================================================================================
000062DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000062DE                            		include	"Objects/Monitor/Code.asm"	; Monitor object
000062DE                            ; =========================================================================================================================================================
000062DE                            ; Monitor object
000062DE                            ; =========================================================================================================================================================
000062DE                            		rsset	_objLvlSSTs
000062DE =00000030                  _objMonFall	rs.b	1				; Fall flag
000062DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000062DE                            ObjEnemy:
000062DE 7000                               moveq   #0, d0
000062E0 1028 0025                          move.b  _objRoutine(a0),d0
000062E4 303B 0000                          move.w  .Index(pc,d0.w),d0
000062E8 4EFB 0000                          jmp     .Index(pc,d0.w)
000062EC                            
000062EC                            .Index:
000062EC 0000                               dc.w    ObjEnemy_Init-.Index
000062EE 0000                               dc.w    ObjEnemy_Down-.Index
000062F0 0000                               dc.w    ObjEnemy_Up-.Index
000062F2                            
000062F2                            ObjEnemy_Init:
000062F2 5428 0025                          addq.b  #2, _objRoutine(a0)
000062F6 217C 0000 0000 0010                move.l  #Map_ObjMonitor,_objMapping(a0)
000062FE 317C 0588 000E                     move.w	#$588,_objVRAM(a0)
00006304 117C 0004 000D             		move.b	#4,_objRender(a0)
0000630A                                    displaySprite	3,a0,a1,0			; Priority
0000630A 317C C172 0008           M 	move.w	#objdisplay+(3*dsize),_objdrawnext(a0)
00006310 3278 C17C                M 	move.w	objdisplay+dprev+(3*dsize).w,a1
00006314 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006318 3348 0008                M 	move.w	a0,_objdrawnext(a1)
0000631C 31C8 C17C                M 	move.w	a0,objdisplay+dprev+(3*dsize).w
00006320                          M .no_245
00006320                            
00006320                            ObjEnemy_Down:
00006320 0C68 00C8 0018                     cmpi.w  #200,   _objYPos(a0)
00006326 6500                               blo.s   .cont
00006328 5428 0025                          addq.b  #2, _ObjRoutine(a0)
0000632C                                .cont:
0000632C 5268 0018                          add.w   #1, _objYPos(a0)
00006330                                    nextObject
00006330 3068 0004                M 	movea.w	_objnext(a0),a0
00006334 2250                     M 	move.l	_objaddress(a0),a1
00006336 4ED1                     M 	jmp	(a1)
00006338                            
00006338                            ObjEnemy_Up:
00006338 0C68 0018 0018                     cmpi.w  #24,   _objYPos(a0)
0000633E 6200                               bhi.s   .cont
00006340 5528 0025                          subq.b  #2, _ObjRoutine(a0)
00006344                                .cont:
00006344 5368 0018                          sub.w   #1, _objYPos(a0)
00006348                                    nextObject
00006348 3068 0004                M 	movea.w	_objnext(a0),a0
0000634C 2250                     M 	move.l	_objaddress(a0),a1
0000634E 4ED1                     M 	jmp	(a1)
00006350                            
00006350                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006350                            ; Data
00006350                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006350                            Map_ObjMonitor:
00006350                            		include	"Objects/Monitor/Mappings.asm"
00006350                            ; --------------------------------------------------------------------------------
00006350                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006350                            ; --------------------------------------------------------------------------------
00006350                            
00006350                            SME_7TKK1:	
00006350 0000 0000                  		dc.w SME_7TKK1_10-SME_7TKK1, SME_7TKK1_18-SME_7TKK1	
00006354 0000 0000                  		dc.w SME_7TKK1_26-SME_7TKK1, SME_7TKK1_34-SME_7TKK1	
00006358 0000 0000                  		dc.w SME_7TKK1_42-SME_7TKK1, SME_7TKK1_50-SME_7TKK1	
0000635C 0000 0000                  		dc.w SME_7TKK1_5E-SME_7TKK1, SME_7TKK1_6C-SME_7TKK1	
00006360 0001                       SME_7TKK1_10:	dc.b 0, 1	
00006362 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006368 0002                       SME_7TKK1_18:	dc.b 0, 2	
0000636A F505 0018 FFF8             		dc.b $F5, 5, 0, $18, $FF, $F8	
00006370 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006376 0002                       SME_7TKK1_26:	dc.b 0, 2	
00006378 F505 001C FFF8             		dc.b $F5, 5, 0, $1C, $FF, $F8	
0000637E EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006384 0002                       SME_7TKK1_34:	dc.b 0, 2	
00006386 F505 2020 FFF8             		dc.b $F5, 5, $20, $20, $FF, $F8	
0000638C EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006392 0002                       SME_7TKK1_42:	dc.b 0, 2	
00006394 F505 0024 FFF8             		dc.b $F5, 5, 0, $24, $FF, $F8	
0000639A EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000063A0 0002                       SME_7TKK1_50:	dc.b 0, 2	
000063A2 F505 0028 FFF8             		dc.b $F5, 5, 0, $28, $FF, $F8	
000063A8 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000063AE 0002                       SME_7TKK1_5E:	dc.b 0, 2	
000063B0 F505 002C FFF8             		dc.b $F5, 5, 0, $2C, $FF, $F8	
000063B6 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000063BC 0001                       SME_7TKK1_6C:	dc.b 0, 1	
000063BE FF0D 0010 FFF0             		dc.b $FF, $D, 0, $10, $FF, $F0	
000063C4                            		even
000063C4                            Ani_ObjMonitor:
000063C4                            		include	"Objects/Monitor/Animations.asm"
000063C4                            ; ---------------------------------------------------------------------------
000063C4                            ; Animation script - monitors
000063C4                            ; ---------------------------------------------------------------------------
000063C4 0000                       		dc.w .Static-Ani_ObjMonitor
000063C6 0000                       		dc.w .Eggman-Ani_ObjMonitor
000063C8 0000                       		dc.w .Rings-Ani_ObjMonitor
000063CA 0000                       		dc.w .Shoes-Ani_ObjMonitor
000063CC 0000                       		dc.w .Shield-Ani_ObjMonitor
000063CE 0000                       		dc.w .Stars-Ani_ObjMonitor
000063D0 0000                       		dc.w .Destroyed-Ani_ObjMonitor
000063D2 0100 01FF 00               .Static:	dc.b 1, 0, 1, $FF, 0
000063D7 0100 0202 0102 02FF 00     .Eggman:	dc.b 1, 0, 2, 2, 1, 2, 2, $FF, 0
000063E0 0100 0303 0103 03FF 00     .Rings:		dc.b 1, 0, 3, 3, 1, 3, 3, $FF, 0
000063E9 0100 0404 0104 04FF 00     .Shoes:		dc.b 1, 0, 4, 4, 1, 4, 4, $FF, 0
000063F2 0100 0505 0105 05FF 00     .Shield:	dc.b 1, 0, 5, 5, 1, 5, 5, $FF, 0
000063FB 0100 0606 0106 06FF 00     .Stars:		dc.b 1, 0, 6, 6, 1, 6, 6, $FF, 0
00006404 0100 0107 FE01 00          .Destroyed:	dc.b 1, 0, 1, 7, $FE, 1, 0
0000640C 00                         		even
0000640C                            ; =========================================================================================================================================================
0000640C                            		include	"Objects/Spikes/Code.asm"		; Spike object
0000640C                            ; ===========================================================================
0000640C                            ; Spike object
0000640C                            ; ===========================================================================
0000640C                            		rsset	_objLvlSSTs
0000640C =00000030                  _objSpikeX	rs.w	1
0000640C =00000032                  _objSpikeY	rs.w	1
0000640C =00000034                  _objSpkMvOff	rs.w	1
0000640C =00000036                  _objSpkMvState	rs.w	1
0000640C =00000038                  _objSpkMvTime	rs.w	1
0000640C                            ; ===========================================================================
0000640C                            ObjSpike:
0000640C 7000                       		moveq	#0,d0
0000640E 1028 0025                  		move.b	_objRoutine(a0),d0
00006412 4EBB 0000                  		jsr	ObjSpike_Index(pc,d0.w)
00006416                            	nextObject
00006416 3068 0004                M 	movea.w	_objnext(a0),a0
0000641A 2250                     M 	move.l	_objaddress(a0),a1
0000641C 4ED1                     M 	jmp	(a1)
0000641E                            ; ===========================================================================
0000641E                            ObjSpike_Index:
0000641E 6000 0000                  		bra.w ObjSpike_Init
00006422 6000 0000                  		bra.w ObjSpike_Upright
00006426 6000 0000                  		bra.w ObjSpike_Sideways
0000642A 6000 0000                  		bra.w ObjSpike_UpsideDown
0000642E                            ; ===========================================================================
0000642E                            ;ObjSpike_InitData:
0000642E                            ;		dc.b $10,$10	; 0	- Upright or ceiling spikes
0000642E                            ;		dc.b $10,$10	; 2	- Sideways spikes
0000642E                            ; ===========================================================================
0000642E                            ObjSpike_Init:
0000642E 5828 0025                  		addq.b	#4,_objRoutine(a0)
00006432 217C 0000 0000 0010        		move.l	#Map_ObjSpike,_objMapping(a0)
0000643A 317C 06A8 000E             		move.w	#$6A8,_objVRAM(a0)
00006440 0028 0004 000D             		ori.b	#4,_objRender(a0)
00006446                            	displaySprite	4,a0,a1,0			; Priority
00006446 317C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a0)
0000644C 3278 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a1
00006450 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006454 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006458 31C8 C184                M 	move.w	a0,objdisplay+dprev+(4*dsize).w
0000645C                          M .no_249
0000645C 1028 0024                  		move.b	_objSubtype(a0),d0
00006460 0228 000F 0024             		andi.b	#$F,_objSubtype(a0)
00006466 0240 00F0                  		andi.w	#$F0,d0
0000646A 7210                       		moveq	#$10,d1
0000646C 1141 0017                  		move.b	d1,_objDrawW(a0)
00006470 1141 002C                  		move.b	d1,_objColW(a0)
00006474 1141 001B                  		move.b	d1,_objDrawH(a0)
00006478 1141 002D                  		move.b	d1,_objColH(a0)
0000647C E848                       		lsr.w	#4,d0
0000647E 1140 0010                  		move.b	d0,_objFrame(a0)
00006482 0C00 0001                  		cmpi.b	#1,d0
00006486 6600                       		bne.s	.ChkUpsideDown
00006488 5828 0025                  		addq.b	#4,_objRoutine(a0)
0000648C 317C 06AC 000E             		move.w	#$6AC,_objVRAM(a0)
00006492                            
00006492                            .ChkUpsideDown:
00006492 0828 0001 0028             		btst	#1,_objStatus(a0)
00006498 6700                       		beq.s	.SavePos
0000649A 117C 000C 0025             		move.b	#$C,_objRoutine(a0)
000064A0                            
000064A0                            .SavePos:
000064A0 3168 0014 0030             		move.w	_objXPos(a0),_objSpikeX(a0)
000064A6 3168 0018 0032             		move.w	_objYPos(a0),_objSpikeY(a0)
000064AC                            
000064AC 6100 0000                  		bsr.w	MoveSpikes		; make the object move
000064B0 0C28 0001 0010             		cmpi.b	#1,_objFrame(a0)		; is object type $1x ?
000064B6 6700                       		beq.s	ObjSpike_SideWays	; if yes, branch
000064B8                            ; ===========================================================================
000064B8                            ; Upright spikes
000064B8                            ; ===========================================================================
000064B8                            ObjSpike_Upright:
000064B8 6100 0000                  		bsr.w	MoveSpikes
000064BC 7200                       		moveq	#0,d1
000064BE 1228 0017                  		move.b	_objDrawW(a0),d1
000064C2 0641 000B                  		addi.w	#$B,d1
000064C6 7400                       		moveq	#0,d2
000064C8 1428 001B                  		move.b	_objDrawH(a0),d2
000064CC 3602                       		move.w	d2,d3
000064CE 5243                       		addq.w	#1,d3
000064D0 3828 0014                  		move.w	_objXPos(a0),d4
000064D4 4EB8 41F4                  		jsr	SolidObject
000064D8 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)
000064DE 6700                       		beq.s	ObjSpike_UprightEnd
000064E0 3278 E876                  		movea.w	playerPtrP1.w,a1
000064E4 6100 0000                  		bsr.w	Touch_ChkHurt2
000064E8                            
000064E8                            ObjSpike_UprightEnd:
000064E8 3028 0030                  		move.w	_objSpikeX(a0),d0
000064EC 4EF8 2000                  		jmp	CheckObjActive.w
000064F0                            ; ===========================================================================
000064F0                            ; Sideways spikes
000064F0                            ; ===========================================================================
000064F0                            ObjSpike_Sideways:
000064F0 3F28 0014                  		move.w	_objXPos(a0),-(sp)	
000064F4 6100 0000                  		bsr.w	MoveSpikes
000064F8 7200                       		moveq	#0,d1
000064FA 1228 0017                  		move.b	_objDrawW(a0),d1
000064FE 0641 000B                  		addi.w	#$B,d1
00006502 7400                       		moveq	#0,d2
00006504 1428 001B                  		move.b	_objDrawH(a0),d2
00006508 3602                       		move.w	d2,d3
0000650A 5243                       		addq.w	#1,d3
0000650C 381F                       		move.w	(sp)+,d4
0000650E 4EB8 41F4                  		jsr	SolidObject
00006512 0806 0000                  		btst	#cTouchSideBit,d6
00006516 6700                       		beq.s	ObjSpike_SidewaysEnd
00006518 3278 E876                  		movea.w	playerPtrP1.w,a1
0000651C 6100 0000                  		bsr.w	Touch_ChkHurt2
00006520                            
00006520                            ObjSpike_SidewaysEnd:
00006520 3028 0030                  		move.w	_objSpikeX(a0),d0
00006524 4EF8 2000                  		jmp	CheckObjActive.w
00006528                            ; ===========================================================================
00006528                            ; Upside down spikes
00006528                            ; ===========================================================================
00006528                            ObjSpike_UpsideDown:
00006528 6100 0000                  		bsr.w	MoveSpikes
0000652C 7200                       		moveq	#0,d1
0000652E 1228 0017                  		move.b	_objDrawW(a0),d1
00006532 0641 000B                  		addi.w	#$B,d1
00006536 7400                       		moveq	#0,d2
00006538 1428 001B                  		move.b	_objDrawH(a0),d2
0000653C 3602                       		move.w	d2,d3
0000653E 5243                       		addq.w	#1,d3
00006540 3828 0014                  		move.w	_objXPos(a0),d4
00006544 4EB8 41F4                  		jsr	SolidObject
00006548 0806 0002                  		btst	#cTouchBtmBit,d6
0000654C 6700                       		beq.s	ObjSpike_UpsideDownEnd
0000654E 3278 E876                  		movea.w	playerPtrP1.w,a1
00006552 6100 0000                  		bsr.w	Touch_ChkHurt2
00006556                            
00006556                            ObjSpike_UpsideDownEnd:
00006556 3028 0030                  		move.w	_objSpikeX(a0),d0
0000655A 4EF8 2000                  		jmp	CheckObjActive.w
0000655E                            ; ===========================================================================
0000655E                            Touch_ChkHurt2:
0000655E 4A29 0042                  		tst.b	_objInvulTime(a1)			; is Sonic invincible?
00006562 6600                       		bne.s	.End				; if yes, branch
00006564 0C29 0008 0025             		cmpi.b	#8,_objRoutine(a1)
0000656A 6700                       		beq.s	.End
0000656C 2629 0018                  		move.l	_objYPos(a1),d3
00006570 3029 001E                  		move.w	_objYVel(a1),d0
00006574 48C0                       		ext.l	d0
00006576 E180                       		asl.l	#8,d0
00006578 9680                       		sub.l	d0,d3
0000657A 2343 0018                  		move.l	d3,_objYPos(a1)
0000657E 2448                       		movea.l	a0,a2
00006580 2049                       		movea.l	a1,a0
00006582 4EB8 5876                  		jsr	ObjPlayer_GetHurt
00006586 204A                       		movea.l	a2,a0
00006588                            
00006588                            .End:
00006588 4E75                       		rts
0000658A                            ; ===========================================================================
0000658A                            MoveSpikes:	
0000658A 7000                       		moveq	#0,d0
0000658C 1028 0024                  		move.b	_objSubtype(a0),d0
00006590 D040                       		add.w	d0,d0
00006592 4EFB 0000                  		jmp	MoveSpikes_Behaviors(pc,d0.w)
00006596                            ; ===========================================================================
00006596                            MoveSpikes_Behaviors:
00006596 6000                       		bra.s MoveSpikes_Still
00006598 6000                       		bra.s MoveSpikes_Vertical
0000659A 6000                       		bra.s MoveSpikes_Horizontal
0000659C                            ; ===========================================================================
0000659C                            MoveSpikes_Still:
0000659C 4E75                       		rts			; don't move the object
0000659E                            ; ===========================================================================
0000659E                            MoveSpikes_Vertical:
0000659E 6100 0000                  		bsr.w	MoveSpikes_Delay
000065A2 7000                       		moveq	#0,d0
000065A4 1028 0034                  		move.b	_objSpkMvOff(a0),d0
000065A8 D068 0032                  		add.w	_objSpikeY(a0),d0
000065AC 3140 0018                  		move.w	d0,_objYPos(a0)	; move the object vertically
000065B0 4E75                       		rts
000065B2                            ; ===========================================================================
000065B2                            MoveSpikes_Horizontal:
000065B2 6100 0000                  		bsr.w	MoveSpikes_Delay
000065B6 7000                       		moveq	#0,d0
000065B8 1028 0034                  		move.b	_objSpkMvOff(a0),d0
000065BC D068 0030                  		add.w	_objSpikeX(a0),d0
000065C0 3140 0014                  		move.w	d0,_objXPos(a0)	; move the object horizontally
000065C4 4E75                       		rts
000065C6                            ; ===========================================================================
000065C6                            MoveSpikes_Delay:
000065C6 4A68 0038                  		tst.w	_objSpkMvTime(a0)		; is time delay	= zero?
000065CA 6700                       		beq.s	MoveSpikes_ChkDir		; if yes, branch
000065CC 5368 0038                  		subq.w	#1,_objSpkMvTime(a0)	; subtract 1 from time delay
000065D0 6600                       		bne.s	locret_CFE6
000065D2 4A28 000D                  		tst.b	_objRender(a0)
000065D6 6A00                       		bpl.s	locret_CFE6
000065D8                            		playSnd	#sSpikeMove, 2		; Play spike move sound
000065D8 11FC 008B C4BD           M 	move.b	#sspikemove,(mqueue+((2)-1)).w
000065DE 6000                       		bra.s	locret_CFE6
000065E0                            ; ===========================================================================
000065E0                            MoveSpikes_ChkDir:
000065E0 4A68 0036                  		tst.w	_objSpkMvState(a0)
000065E4 6700                       		beq.s	MoveSpikes_Retract
000065E6 0468 0800 0034             		subi.w	#$800,_objSpkMvOff(a0)
000065EC 6400                       		bcc.s	locret_CFE6
000065EE 317C 0000 0034             		move.w	#0,_objSpkMvOff(a0)
000065F4 317C 0000 0036             		move.w	#0,_objSpkMvState(a0)
000065FA 317C 003C 0038             		move.w	#60,_objSpkMvTime(a0)	; set time delay to 1 second
00006600 6000                       		bra.s	locret_CFE6
00006602                            ; ===========================================================================
00006602                            MoveSpikes_Retract:
00006602 0668 0800 0034             		addi.w	#$800,_objSpkMvOff(a0)
00006608 0C68 2000 0034             		cmpi.w	#$2000,_objSpkMvOff(a0)
0000660E 6500                       		bcs.s	locret_CFE6
00006610 317C 2000 0034             		move.w	#$2000,_objSpkMvOff(a0)
00006616 317C 0001 0036             		move.w	#1,_objSpkMvState(a0)
0000661C 317C 003C 0038             		move.w	#60,_objSpkMvTime(a0)	; set time delay to 1 second
00006622                            
00006622                            locret_CFE6:
00006622 4E75                       		rts
00006624                            ; ===========================================================================
00006624                            ; Spike object mappings
00006624                            ; ===========================================================================
00006624                            Map_ObjSpike:
00006624                            	include "Objects/Spikes/Mappings.asm"
00006624                            ; --------------------------------------------------------------------------------
00006624                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006624                            ; --------------------------------------------------------------------------------
00006624                            
00006624                            SME_5AG23:	
00006624 0000 0000                  		dc.w SME_5AG23_4-SME_5AG23, SME_5AG23_1E-SME_5AG23	
00006628 0004                       SME_5AG23_4:	dc.b 0, 4	
0000662A F003 0000 FFF0             		dc.b $F0, 3, 0, 0, $FF, $F0	
00006630 F003 0000 FFF8             		dc.b $F0, 3, 0, 0, $FF, $F8	
00006636 F003 0000 0000             		dc.b $F0, 3, 0, 0, 0, 0	
0000663C F003 0000 0008             		dc.b $F0, 3, 0, 0, 0, 8	
00006642 0004                       SME_5AG23_1E:	dc.b 0, 4	
00006644 F00C 0000 FFF0             		dc.b $F0, $C, 0, 0, $FF, $F0	
0000664A F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00006650 000C 0000 FFF0             		dc.b 0, $C, 0, 0, $FF, $F0	
00006656 080C 0000 FFF0             		dc.b 8, $C, 0, 0, $FF, $F0	
0000665C                            		even
0000665C                            ; ===========================================================================
0000665C                            		include	"Objects/Spring/Code.asm"		; Spring object
0000665C                            ; =========================================================================================================================================================
0000665C                            ; Spring object
0000665C                            ; =========================================================================================================================================================
0000665C                            		rsset	_objLvlSSTs
0000665C =00000030                  _objSprSpd		rs.w	1				; Spring strength
0000665C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000665C                            ObjSpring:
0000665C 217C 0000 0000 0010        		move.l	#Map_ObjSpring,_objMapping(a0)		; Mappings
00006664 317C 05BA 000E             		move.w	#$5BA,_objVRAM(a0)			; Tile properties
0000666A 0028 0004 000D             		ori.b	#4,_objRender(a0)			; Render flags
00006670 117C 0010 0017             		move.b	#$10,_objDrawW(a0)			; Sprite width
00006676 117C 0008 001B             		move.b	#8,_objDrawH(a0)			; Sprite height
0000667C 117C 000E 002C             		move.b	#$1C/2,_objColW(a0)		; Collision width
00006682                            	displaySprite	4,a0,a1,0			; Priority
00006682 317C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a0)
00006688 3278 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a1
0000668C 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006690 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006694 31C8 C184                M 	move.w	a0,objdisplay+dprev+(4*dsize).w
00006698                          M .no_251
00006698                            		
00006698 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
0000669C E648                       		lsr.w	#3,d0				; Turn into offset
0000669E 0240 000E                  		andi.w	#$E,d0				; ''
000066A2 4EFB 0000                  		jmp	.Subtypes(pc,d0.w)		; Jump to it
000066A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000066A6                            .Subtypes:
000066A6 6000                       		bra.s .Init_Up				; Up
000066A8 6000                       		bra.s .Init_Horizontal			; Horizontal
000066AA 6000                       		bra.s .Init_Down			; Down
000066AC 6000                       		bra.s .Init_DiagonallyUp		; Diagonally up
000066AE 6000                       		bra.s .Init_DiagonallyDown		; Diagonally down
000066B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000066B0                            .Init_Horizontal:
000066B0 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Animation
000066B6 117C 0002 0010             		move.b	#2,_objFrame(a0)			; Mapping frame
000066BC 317C 05CA 000E             		move.w	#$5CA,_objVRAM(a0)			; Tile properties
000066C2 117C 0008 0017             		move.b	#8,_objDrawW(a0)			; Sprite width
000066C8 117C 0010 001B             		move.b	#$10,_objDrawH(a0)			; Sprite height
000066CE 117C 000E 002C             		move.b	#$1C/2,_objColW(a0)		; Collision width
000066D4 20BC 0000 0000             		move.l	#ObjSpring_Horizontal,_objAddress(a0)	; Next routine
000066DA 6000                       		bra.s	.Init_Common			; Continue
000066DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000066DC                            .Init_Down:
000066DC 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Flip vertically
000066E2 20BC 0000 0000             		move.l	#ObjSpring_Down,_objAddress(a0)	; Next routine
000066E8 6000                       		bra.s	.Init_Common			; Continue
000066EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000066EA                            .Init_DiagonallyUp:
000066EA 117C 0004 0020             		move.b	#4,_objAnim(a0)			; Animation
000066F0 117C 0004 0010             		move.b	#4,_objFrame(a0)			; Map frame
000066F6 317C 05D9 000E             		move.w	#$5D9,_objVRAM(a0)			; Tile properties
000066FC 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyUp,_objAddress(a0); Next routine
00006702 6000                       		bra.s	.Init_Common			; Continue
00006704                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006704                            .Init_DiagonallyDown:
00006704 117C 0004 0020             		move.b	#4,_objAnim(a0)			; Animation
0000670A 117C 0006 0010             		move.b	#6,_objFrame(a0)			; Map frame
00006710 317C 05D9 000E             		move.w	#$5D9,_objVRAM(a0)			; Tile properties
00006716 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Flip vertically
0000671C 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyDown,_objAddress(a0); Next routine
00006722 6000                       		bra.s	.Init_Common			; Continue
00006724                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006724                            .Init_Up:
00006724 20BC 0000 0000             		move.l	#ObjSpring_Up,_objAddress(a0)		; Next routine
0000672A                            
0000672A                            .Init_Common:
0000672A 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
0000672E 0240 0002                  		andi.w	#2,d0				; Turn into offset
00006732 317B 0000 0030             		move.w	.Strengths(pc,d0.w),_objSprSpd(a0)	; Get spring strength
00006738 0800 0001                  		btst	#1,d0				; Is the spring supposed to be yellow?
0000673C 6700                       		beq.s	.NotYellow			; If not, branch
0000673E 08E8 0005 000E             		bset	#5,_objVRAM(a0)			; Make the spring yellow
00006744                            
00006744                            .NotYellow:
00006744                            	nextObject
00006744 3068 0004                M 	movea.w	_objnext(a0),a0
00006748 2250                     M 	move.l	_objaddress(a0),a1
0000674A 4ED1                     M 	jmp	(a1)
0000674C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000674C                            .Strengths:
0000674C F000                       		dc.w	-$1000				; Strength of red spring
0000674E F600                       		dc.w	-$A00				; Strength of yellow spring
00006750                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006750                            ObjSpring_Up:
00006750 323C 001A                  		move.w	#27-1,d1			; Width
00006754 343C 0008                  		move.w	#16/2,d2			; Height
00006758 3602                       		move.w	d2,d3				; ''
0000675A 3828 0014                  		move.w	_objXPos(a0),d4			; X position
0000675E 4EB8 4244                  		jsr	SolidObject_Always		; Set object as solid
00006762 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Has the player touched the top of the of spring?
00006768 6700                       		beq.s	.Display			; If not, branch
0000676A 6100                       		bsr.s	.Bounce				; Bounce the player up
0000676C                            
0000676C                            .Display:
0000676C 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006770 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006774 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006778                            	nextObject
00006778 3068 0004                M 	movea.w	_objnext(a0),a0
0000677C 2250                     M 	move.l	_objaddress(a0),a1
0000677E 4ED1                     M 	jmp	(a1)
00006780                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006780                            .Bounce:
00006780 317C 0100 0020             		move.w	#$100,_objAnim(a0)			; Reset animation
00006786 5069 0018                  		addq.w	#8,_objYPos(a1)			; Align player to spring
0000678A 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)		; Set the player's Y velocity
00006790 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set the player's "in air" flag
00006796 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Make the player no longer be on the spring
0000679C 4229 0040                  		clr.b	_objJumping(a1)			; Clear the player's jump flag
000067A0 137C 0010 0020             		move.b	#$10,_objAnim(a1)			; Set the player's animation to the spring animation
000067A6 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Reset the player's routine
000067AC                            		
000067AC 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
000067B0 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
000067B2 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's X movement
000067B6                            
000067B6                            .ChkPath1:
000067B6 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
000067BA 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
000067BE 6600                       		bne.s	.ChkPath2			; If not, branch
000067C0 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
000067C6 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
000067CC                            
000067CC                            .ChkPath2:
000067CC 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
000067D0 6600                       		bne.s	.PlaySound			; If not, branch
000067D2 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
000067D8 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
000067DE                            
000067DE                            .PlaySound:
000067DE                            		playSnd	#sSpring, 2			; Play spring sound
000067DE 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
000067E4 4E75                       		rts
000067E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000067E6                            ObjSpring_Horizontal:
000067E6 323C 0013                  		move.w	#20-1,d1			; Width
000067EA 343C 000E                  		move.w	#28/2,d2			; Height
000067EE 3602                       		move.w	d2,d3				; ''
000067F0 3828 0014                  		move.w	_objXPos(a0),d4			; X position
000067F4 4EB8 4244                  		jsr	SolidObject_Always		; Set object as solid
000067F8 0806 0000                  		btst	#cTouchSideBit,d6		; Has the player touched the side of the spring?
000067FC 6700                       		beq.s	.Display			; If not, branch
000067FE 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00006802 3028 0014                  		move.w	_objXPos(a0),d0			; Get which side of the spring the player is facing
00006806 9069 0014                  		sub.w	_objXPos(a1),d0			; ''
0000680A 6500                       		bcs.s	.NoFlip				; If the player is on the left side of the spring, branch
0000680C 0A01 0001                  		eori.b	#1,d1				; Flip so that we check for the other side of the spring
00006810                            
00006810                            .NoFlip:
00006810 0201 0001                  		andi.b	#1,d1				; Is the player touching the bouncy side of the spring?
00006814 6600                       		bne.s	.Display			; If not, branch
00006816 6100                       		bsr.s	.Bounce				; Bounce the player
00006818                            
00006818                            .Display:
00006818 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0000681C 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006820 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006824                            	nextObject
00006824 3068 0004                M 	movea.w	_objnext(a0),a0
00006828 2250                     M 	move.l	_objaddress(a0),a1
0000682A 4ED1                     M 	jmp	(a1)
0000682C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000682C                            .Bounce:	
0000682C 317C 0300 0020             		move.w	#$300,_objAnim(a0)			; Reset animation
00006832 5069 0014                  		addq.w	#8,_objXPos(a1)			; Align player to spring
00006836 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)		; Set the player's X velocity
0000683C 08E9 0000 0028             		bset	#0,_objStatus(a1)			; Make the player face the left
00006842 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is this spring facing the left?
00006848 6600                       		bne.s	.SetMoveLock			; If so, branch
0000684A 08A9 0000 0028             		bclr	#0,_objStatus(a1)			; Make the player face the right
00006850 0469 0010 0014             		subi.w	#$10,_objXPos(a1)			; Align player to spring
00006856 4469 001C                  		neg.w	_objXVel(a1)			; Move the player to the right
0000685A                            
0000685A                            .SetMoveLock:
0000685A 137C 000F 003F             		move.b	#$F,_objMoveLock(a1)		; Lock the player's movement for a bit
00006860 3369 001C 003A             		move.w	_objXVel(a1),_objGVel(a1)		; Set the player's ground velocity
00006866                            		
00006866 0829 0002 0028             		btst	#2,_objStatus(a1)			; Is the player jumping?
0000686C 6600                       		bne.s	.ChkYStop			; If so, branch
0000686E 4229 0020                  		clr.b	_objAnim(a1)			; Set the animation to the walking animation
00006872                            		
00006872                            .ChkYStop:
00006872 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006876 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move vertically
00006878 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's Y movement
0000687C                            
0000687C                            .ChkPath1:
0000687C 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006880 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006884 6600                       		bne.s	.ChkPath2			; If not, branch
00006886 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
0000688C 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006892                            
00006892                            .ChkPath2:
00006892 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006896 6600                       		bne.s	.PlaySound			; If not, branch
00006898 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
0000689E 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
000068A4                            
000068A4                            .PlaySound:
000068A4 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Clear "push" flags
000068AA 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; ''
000068B0                            		playSnd	#sSpring, 2			; Play spring sound
000068B0 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
000068B6 4E75                       		rts
000068B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000068B8                            ObjSpring_Down:
000068B8 323C 0012                  		move.w	#19-1,d1			; Width
000068BC 343C 0008                  		move.w	#16/2,d2			; Height
000068C0 3602                       		move.w	d2,d3				; ''
000068C2 3828 0014                  		move.w	_objXPos(a0),d4			; X position
000068C6 4EB8 4244                  		jsr	SolidObject_Always		; Set object as solid
000068CA 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the bottom of the spring?
000068CE 6600                       		bne.s	.Display			; If not, branch
000068D0 6100                       		bsr.s	.Bounce				; Bounce the player
000068D2                            
000068D2                            .Display:
000068D2 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
000068D6 4EB8 1C42                  		jsr	AnimateObject.w			; ''
000068DA 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
000068DE                            	nextObject
000068DE 3068 0004                M 	movea.w	_objnext(a0),a0
000068E2 2250                     M 	move.l	_objaddress(a0),a1
000068E4 4ED1                     M 	jmp	(a1)
000068E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000068E6                            .Bounce:
000068E6 317C 0100 0020             		move.w	#$100,_objAnim(a0)			; Reset animation
000068EC 5169 0018                  		subq.w	#8,_objYPos(a1)			; Align player with the spring
000068F0 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)		; Set the player's Y velocity
000068F6 4469 001E                  		neg.w	_objYVel(a1)			; Move the player down
000068FA                            		
000068FA 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
000068FE 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
00006900 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's X movement
00006904                            
00006904                            .ChkPath1:
00006904 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006908 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0000690C 6600                       		bne.s	.ChkPath2			; If not, branch
0000690E 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006914 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
0000691A                            
0000691A                            .ChkPath2:
0000691A 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0000691E 6600                       		bne.s	.PlaySound			; If not, branch
00006920 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006926 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
0000692C                            
0000692C                            .PlaySound:
0000692C 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set the player's "in air" flag
00006932 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Make the player no longer be on the spring
00006938 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Reset the player's routine
0000693E                            		playSnd	#sSpring, 2			; Play spring sound
0000693E 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006944 4E75                       		rts
00006946                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006946                            ObjSpring_DiagonallyUp:
00006946 323C 0019                  		move.w	#26-1,d1			; Width
0000694A 343C 0010                  		move.w	#32/2,d2			; Height
0000694E 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006952 45FA 0000                  		lea	.SlopeData(pc),a2		; Slope Data
00006956 4EB8 4294                  		jsr	SlopedSolid			; Set object as a solid slope
0000695A                            		
0000695A 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Has the player touched the spring?
00006960 6700                       		beq.s	.End				; If not, branch
00006962 6100                       		bsr.s	.Bounce				; Bounce the player
00006964                            
00006964                            .End:
00006964 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006968 4EB8 1C42                  		jsr	AnimateObject.w			; ''
0000696C 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006970                            	nextObject
00006970 3068 0004                M 	movea.w	_objnext(a0),a0
00006974 2250                     M 	move.l	_objaddress(a0),a1
00006976 4ED1                     M 	jmp	(a1)
00006978                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006978                            .Bounce:
00006978 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is the spring facing left?
0000697E 6600                       		bne.s	.FaceLeft			; If so, branch
00006980 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00006984 5940                       		subq.w	#4,d0				; Subtract 4
00006986 B069 0014                  		cmp.w	_objXPos(a1),d0			; Is the player
0000698A 6500                       		blo.s	.DoBounce
0000698C 4E75                       		rts
0000698E                            
0000698E                            .FaceLeft:
0000698E 3028 0014                  		move.w	_objXPos(a0),d0
00006992 5840                       		addq.w	#4,d0
00006994 B069 0014                  		cmp.w	_objXPos(a1),d0
00006998 6400                       		bhs.s	.DoBounce
0000699A 4E75                       		rts
0000699C                            
0000699C                            .DoBounce:
0000699C 317C 0500 0020             		move.w	#$500,_objAnim(a0)
000069A2 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)
000069A8 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)
000069AE 5C69 0018                  		addq.w	#6,_objYPos(a1)
000069B2 5C69 0014                  		addq.w	#6,_objXPos(a1)
000069B6 08E9 0000 0028             		bset	#0,_objStatus(a1)
000069BC 0828 0000 0028             		btst	#0,_objStatus(a0)
000069C2 6600                       		bne.s	.SetAni
000069C4 08A9 0000 0028             		bclr	#0,_objStatus(a1)
000069CA 0469 000C 0014             		subi.w	#$C,_objXPos(a1)
000069D0 4469 001C                  		neg.w	_objXVel(a1)
000069D4                            
000069D4                            .SetAni:
000069D4 08E9 0001 0028             		bset	#1,_objStatus(a1)
000069DA 08A9 0003 0028             		bclr	#3,_objStatus(a1)
000069E0 137C 0010 0020             		move.b	#$10,_objAnim(a1)
000069E6 137C 0004 0025             		move.b	#4,_objRoutine(a1)
000069EC                            
000069EC 1028 0024                  		move.b	_objSubtype(a0),d0
000069F0 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
000069F4 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
000069F8 6600                       		bne.s	.ChkPath2			; If not, branch
000069FA 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006A00 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006A06                            
00006A06                            .ChkPath2:
00006A06 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006A0A 6600                       		bne.s	.PlaySound			; If not, branch
00006A0C 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006A12 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006A18                            
00006A18                            .PlaySound:
00006A18                            		playSnd	#sSpring, 2			; Play spring sound
00006A18 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006A1E 4E75                       		rts
00006A20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A20                            .SlopeData:
00006A20 1010 1010 1010 10          		dc.b	$10, $10, $10, $10, $10, $10, $10
00006A27 1010 1010 100E 0C          		dc.b	$10, $10, $10, $10, $10, $0E, $0C
00006A2E 0A08 0604 0200 FE          		dc.b	$0A, $08, $06, $04, $02, $00, $FE
00006A35 FCFC FCFC FCFC FC          		dc.b	$FC, $FC, $FC, $FC, $FC, $FC, $FC
00006A3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A3C                            ObjSpring_DiagonallyDown:
00006A3C 323C 0019                  		move.w	#26-1,d1			; Width
00006A40 343C 0010                  		move.w	#32/2,d2
00006A44 3828 0014                  		move.w	_objXPos(a0),d4
00006A48 45FA 0000                  		lea	.SlopeData(pc),a2
00006A4C 4EB8 4294                  		jsr	SlopedSolid			; Set object as a solid slope
00006A50 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the spring?
00006A54 6600                       		bne.s	.End				; If not, branch
00006A56 6100                       		bsr.s	.Bounce				; Bounce the player
00006A58                            
00006A58                            .End:
00006A58 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006A5C 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006A60 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006A64                            	nextObject
00006A64 3068 0004                M 	movea.w	_objnext(a0),a0
00006A68 2250                     M 	move.l	_objaddress(a0),a1
00006A6A 4ED1                     M 	jmp	(a1)
00006A6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A6C                            .Bounce:
00006A6C 317C 0500 0020             		move.w	#$500,_objAnim(a0)
00006A72 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)
00006A78 4469 001E                  		neg.w	_objYVel(a1)
00006A7C 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)
00006A82 5C69 0018                  		addq.w	#6,_objYPos(a1)
00006A86 5C69 0014                  		addq.w	#6,_objXPos(a1)
00006A8A 08E9 0000 0028             		bset	#0,_objStatus(a1)
00006A90 0828 0000 0028             		btst	#0,_objStatus(a0)
00006A96 6600                       		bne.s	.SetAni
00006A98 08A9 0000 0028             		bclr	#0,_objStatus(a1)
00006A9E 0469 000C 0014             		subi.w	#$C,_objXPos(a1)
00006AA4 4469 001C                  		neg.w	_objXVel(a1)
00006AA8                            
00006AA8                            .SetAni:
00006AA8 08E9 0001 0028             		bset	#1,_objStatus(a1)
00006AAE 08A9 0003 0028             		bclr	#3,_objStatus(a1)
00006AB4 137C 0004 0025             		move.b	#4,_objRoutine(a1)
00006ABA                            
00006ABA 1028 0024                  		move.b	_objSubtype(a0),d0
00006ABE 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006AC2 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006AC6 6600                       		bne.s	.ChkPath2			; If not, branch
00006AC8 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006ACE 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006AD4                            
00006AD4                            .ChkPath2:
00006AD4 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006AD8 6600                       		bne.s	.PlaySound			; If not, branch
00006ADA 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006AE0 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006AE6                            
00006AE6                            .PlaySound:
00006AE6                            		playSnd	#sSpring, 2			; Play spring sound
00006AE6 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006AEC 4E75                       		rts
00006AEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006AEE                            .SlopeData:
00006AEE F4F0 F0F0 F0F0 F0          		dc.b	$F4, $F0, $F0, $F0, $F0, $F0, $F0
00006AF5 F0F0 F0F0 F0F2 F4          		dc.b	$F0, $F0, $F0, $F0, $F0, $F2, $F4
00006AFC F6F8 FAFC FE00 02          		dc.b	$F6, $F8, $FA, $FC, $FE, $00, $02
00006B03 0404 0404 0404 04          		dc.b	$04, $04, $04, $04, $04, $04, $04
00006B0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B0A                            ; Data
00006B0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B0A                            Ani_ObjSpring:
00006B0A                            		include	"Objects/Spring/Animations.asm"
00006B0A                            ; ---------------------------------------------------------------------------
00006B0A                            ; Animation script - springs
00006B0A                            ; ---------------------------------------------------------------------------
00006B0A 0000                       		dc.w byte_18FEE-Ani_ObjSpring
00006B0C 0000                       		dc.w byte_18FF1-Ani_ObjSpring
00006B0E 0000                       		dc.w byte_18FFD-Ani_ObjSpring
00006B10 0000                       		dc.w byte_19000-Ani_ObjSpring
00006B12 0000                       		dc.w byte_1900C-Ani_ObjSpring
00006B14 0000                       		dc.w byte_1900F-Ani_ObjSpring
00006B16                            byte_18FEE:
00006B16 0F00 FF                    		dc.b  $F, 0, $FF
00006B1A 00                         		even
00006B1A                            byte_18FF1:
00006B1A 0001 0101 0101 01FD 00     		dc.b 0, 1, 1, 1, 1, 1, 1, $FD, 0
00006B24 00                         		even
00006B24                            byte_18FFD:
00006B24 0F02 FF                    		dc.b $F, 2, $FF
00006B28 00                         		even
00006B28                            byte_19000:
00006B28 0003 0303 0303 03FD 02     		dc.b 0, 3, 3, 3, 3, 3, 3, $FD, 2
00006B32 00                         		even
00006B32                            byte_1900C:
00006B32 0F04 FF                    		dc.b $F, 4, $FF
00006B36 00                         		even
00006B36                            byte_1900F:
00006B36 0005 0505 0505 05FD 04     		dc.b 0, 5, 5, 5, 5, 5, 5, $FD, 4
00006B40 00                         		even
00006B40                            Map_ObjSpring:
00006B40                            		include	"Objects/Spring/Mappings.asm"
00006B40                            ; --------------------------------------------------------------------------------
00006B40                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006B40                            ; --------------------------------------------------------------------------------
00006B40                            
00006B40                            SME_q_6K9:	
00006B40 0000 0000                  		dc.w SME_q_6K9_E-SME_q_6K9, SME_q_6K9_1C-SME_q_6K9	
00006B44 0000 0000                  		dc.w SME_q_6K9_3C-SME_q_6K9, SME_q_6K9_44-SME_q_6K9	
00006B48 0000 0000                  		dc.w SME_q_6K9_70-SME_q_6K9, SME_q_6K9_7E-SME_q_6K9	
00006B4C 0000                       		dc.w SME_q_6K9_9E-SME_q_6K9	
00006B4E 0002                       SME_q_6K9_E:	dc.b 0, 2	
00006B50 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00006B56 000C 0004 FFF0             		dc.b 0, $C, 0, 4, $FF, $F0	
00006B5C 0005                       SME_q_6K9_1C:	dc.b 0, 5	
00006B5E E00C 0000 FFF0             		dc.b $E0, $C, 0, 0, $FF, $F0	
00006B64 E804 0008 FFF8             		dc.b $E8, 4, 0, 8, $FF, $F8	
00006B6A F004 000A FFF8             		dc.b $F0, 4, 0, $A, $FF, $F8	
00006B70 F804 000A FFF8             		dc.b $F8, 4, 0, $A, $FF, $F8	
00006B76 000C 000C FFF0             		dc.b 0, $C, 0, $C, $FF, $F0	
00006B7C 0001                       SME_q_6K9_3C:	dc.b 0, 1	
00006B7E E807 0000 FFF7             		dc.b $E8, 7, 0, 0, $FF, $F7	
00006B84 0007                       SME_q_6K9_44:	dc.b 0, 7	
00006B86 E803 0004 0017             		dc.b $E8, 3, 0, 4, 0, $17	
00006B8C F001 0008 000F             		dc.b $F0, 1, 0, 8, 0, $F	
00006B92 F001 000A 0007             		dc.b $F0, 1, 0, $A, 0, 7	
00006B98 F001 000A FFFF             		dc.b $F0, 1, 0, $A, $FF, $FF	
00006B9E F001 000C FFF7             		dc.b $F0, 1, 0, $C, $FF, $F7	
00006BA4 E800 000E FFF7             		dc.b $E8, 0, 0, $E, $FF, $F7	
00006BAA 0000 100E FFF7             		dc.b 0, 0, $10, $E, $FF, $F7	
00006BB0 0002                       SME_q_6K9_70:	dc.b 0, 2	
00006BB2 F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
00006BB8 FA02 000C 0008             		dc.b $FA, 2, 0, $C, 0, 8	
00006BBE 0005                       SME_q_6K9_7E:	dc.b 0, 5	
00006BC0 E20B 000F 0000             		dc.b $E2, $B, 0, $F, 0, 0	
00006BC6 EA02 001B 0018             		dc.b $EA, 2, 0, $1B, 0, $18	
00006BCC F201 201E FFF8             		dc.b $F2, 1, $20, $1E, $FF, $F8	
00006BD2 FA00 0020 FFF0             		dc.b $FA, 0, 0, $20, $FF, $F0	
00006BD8 0209 0021 FFF0             		dc.b 2, 9, 0, $21, $FF, $F0	
00006BDE 0002                       SME_q_6K9_9E:	dc.b 0, 2	
00006BE0 020B 1000 FFF0             		dc.b 2, $B, $10, 0, $FF, $F0	
00006BE6 0202 100C 0008             		dc.b 2, 2, $10, $C, 0, 8	
00006BEC                            		even
00006BEC                            ; =========================================================================================================================================================
00006BEC                            		include	"Objects/Checkpoint/Code.asm"	; Checkpoint object
00006BEC                            ; =========================================================================================================================================================
00006BEC                            ; Checkpoint object
00006BEC                            ; =========================================================================================================================================================
00006BEC                            		rsset	_objLvlSSTs
00006BEC =00000030                  _objDongleX	rs.w	1				; Ball dongle X
00006BEC =00000032                  _objDongleY	rs.w	1				; Ball dongle Y
00006BEC =00000034                  _objDongleTime	rs.w	1				; Ball dongle timer
00006BEC =00000036                  _objDonglePar	rs.w	1				; Ball dongle parent
00006BEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006BEC                            ObjCheckpoint:
00006BEC 7000                       		moveq	#0,d0
00006BEE 1028 0025                  		move.b	_objRoutine(a0),d0			; Get routine ID
00006BF2 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00006BF6                            	nextObject
00006BF6 3068 0004                M 	movea.w	_objnext(a0),a0
00006BFA 2250                     M 	move.l	_objaddress(a0),a1
00006BFC 4ED1                     M 	jmp	(a1)
00006BFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006BFE                            .Index:
00006BFE 6000 0000                  		bra.w	ObjChkpoint_Init
00006C02 6000 0000                  		bra.w	ObjChkpoint_Main
00006C06 6000 0000                  		bra.w	ObjChkpoint_Animate
00006C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C0A                            ObjChkpoint_Init:
00006C0A 5828 0025                  		addq.b	#4,_objRoutine(a0)			; Next routine
00006C0E                            		
00006C0E 217C 0000 0000 0010        		move.l	#Map_ObjChkpoint,_objMapping(a0)	; Mappings
00006C16 317C 057E 000E             		move.w	#$57E,_objVRAM(a0)			; Tile properties
00006C1C 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00006C22 117C 0008 0017             		move.b	#8,_objDrawW(a0)			; Sprite width
00006C28 117C 0020 001B             		move.b	#$20,_objDrawH(a0)			; Sprite height
00006C2E                            	displaySprite	5,a0,a1,0			; Priority
00006C2E 317C C182 0008           M 	move.w	#objdisplay+(5*dsize),_objdrawnext(a0)
00006C34 3278 C18C                M 	move.w	objdisplay+dprev+(5*dsize).w,a1
00006C38 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006C3C 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006C40 31C8 C18C                M 	move.w	a0,objdisplay+dprev+(5*dsize).w
00006C44                          M .no_264
00006C44                            		
00006C44 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table address
00006C48 3440                       		movea.w	d0,a2				; ''
00006C4A 0812 0000                  		btst	#0,(a2)				; Is it already set?
00006C4E 6600                       		bne.s	.AlreadySet			; If so, branch
00006C50                            
00006C50 1228 0024                  		move.b	_objSubtype(a0),d1			; Get checkpoint ID
00006C54 B238 C7B0                  		cmp.b	chkIDLast.w,d1		; Has a later checkpoint already been hit?
00006C58 6E00                       		bgt.s	ObjChkpoint_Main		; If not, branch
00006C5A                            
00006C5A                            .AlreadySet:
00006C5A 08D2 0000                  		bset	#0,(a2)				; Mark as set
00006C5E 117C 0002 0020             		move.b	#2,_objAnim(a0)			; ''
00006C64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C64                            ObjChkpoint_Main:
00006C64 4A38 E8DD                  		tst.b	debugMode.w			; Are we in debug placement mode?
00006C68 6600 0000                  		bne.w	ObjChkpoint_Animate		; If so, branch
00006C6C                            		
00006C6C 3278 E876                  		movea.w	playerPtrP1.w,a1		; Player object
00006C70 1238 C7B0                  		move.b	chkIDLast.w,d1		; Get last checkpoint hit
00006C74 B228 0024                  		cmp.b	_objSubtype(a0),d1			; Has a later checkpoint already been hit?
00006C78 6400 0000                  		bhs.w	.ChkSetAnim			; If so, branch
00006C7C                            
00006C7C 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
00006C80 9068 0014                  		sub.w	_objXPos(a0),d0			; Get delta X from current position
00006C84 5040                       		addq.w	#8,d0				; Add 8
00006C86 0C40 0010                  		cmpi.w	#$10,d0				; Is the player within horizontal boundaries?
00006C8A 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
00006C8E 3029 0018                  		move.w	_objYPos(a1),d0			; Get player's Y position
00006C92 9068 0018                  		sub.w	_objYPos(a0),d0			; Get delta Y from current position
00006C96 0640 0040                  		addi.w	#$40,d0				; Add $40
00006C9A 0C40 0068                  		cmpi.w	#$68,d0				; Is the player within vertical boundaries?
00006C9E 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
00006CA2                            		
00006CA2                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
00006CA2 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
00006CA8                            
00006CA8 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00006CAC 6700                       		beq.s	.SetPoint			; If there is none, branch
00006CAE 22BC 0000 0000             		move.l	#ObjChkPoint_Dongle,_objAddress(a1)	; Load the checkpoint ball dongle object
00006CB4 3368 0014 0030             		move.w	_objXPos(a0),_objDongleX(a1)		; Dongle X
00006CBA 3368 0018 0032             		move.w	_objYPos(a0),_objDongleY(a1)		; Dongle Y
00006CC0 0469 0014 0032             		subi.w	#$14,_objDongleY(a1)		; ''
00006CC6 2368 0010 0010             		move.l	_objMapping(a0),_objMapping(a1)		; Mappings
00006CCC 3368 000E 000E             		move.w	_objVRAM(a0),_objVRAM(a1)		; Tile properties
00006CD2 137C 0004 000D             		move.b	#4,_objRender(a1)			; Render flags
00006CD8 137C 0008 0017             		move.b	#8,_objDrawW(a1)			; Sprite width
00006CDE 137C 0008 001B             		move.b	#8,_objDrawH(a1)			; Sprite height
00006CE4                            	displaySprite	4,a1,a2,0			; Priority
00006CE4 337C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a1)
00006CEA 3478 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a2
00006CEE 334A 000A                M 	move.w	a2,_objdrawprev(a1)
00006CF2 3549 0008                M 	move.w	a1,_objdrawnext(a2)
00006CF6 31C9 C184                M 	move.w	a1,objdisplay+dprev+(4*dsize).w
00006CFA                          M .no_266
00006CFA 137C 0002 0010             		move.b	#2,_objFrame(a1)			; Map frame
00006D00 337C 0020 0034             		move.w	#$20,_objDongleTime(a1)		; Dongle timer
00006D06 3348 0036                  		move.w	a0,_objDonglePar(a1)		; Dongle parent
00006D0A                            
00006D0A                            .SetPoint:
00006D0A 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table address
00006D0E 3440                       		movea.w	d0,a2				; ''
00006D10 08D2 0000                  		bset	#0,(a2)				; Mark as set
00006D14                            		
00006D14 117C 0001 0020             		move.b	#1,_objAnim(a0)			; Use dongling animation
00006D1A 11E8 0024 C7B0             		move.b	_objSubtype(a0),chkIDLast.w	; Set checkpoint ID
00006D20                            
00006D20 5828 0025                  		addq.b	#4,_objRoutine(a0)
00006D24 4879 0000 0000             		pea	ObjChkpoint_Animate		; Animate
00006D2A 4EF8 47E8                  		jmp	Level_SaveInfo			; Save data
00006D2E                            		
00006D2E                            .ChkSetAnim:
00006D2E 5828 0025                  		addq.b	#4,_objRoutine(a0)
00006D32 4A28 0020                  		tst.b	_objAnim(a0)			; Are we still unset?
00006D36 6600                       		bne.s	ObjChkpoint_Animate		; If not, branch
00006D38 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use the set animation
00006D3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00006D3E                            ObjChkpoint_Animate:
00006D3E 43F9 0000 0000             		lea	Ani_ObjChkpoint,a1		; Animate
00006D44 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006D48 4EF8 2000                  		jmp	CheckObjActive.w		; Display
00006D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00006D4C                            ; Ball dongle object
00006D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00006D4C                            ObjChkPoint_Dongle:
00006D4C 5368 0034                  		subq.w	#1,_objDongleTime(a0)		; Decrement timer
00006D50 6A00                       		bpl.s	.MoveDongle			; If it hasn't run out, branch
00006D52 3268 0036                  		movea.w	_objDonglePar(a0),a1		; Get parent
00006D56 137C 0002 0020             		move.b	#2,_objAnim(a1)			; Set set animation for parent
00006D5C 4229 0010                  		clr.b	_objFrame(a1)			; Reset map frame for parent
00006D60 4EB8 1A4C                  		jsr	DeleteObject.w			; Delete ourselves
00006D64                            	nextObject
00006D64 3068 0004                M 	movea.w	_objnext(a0),a0
00006D68 2250                     M 	move.l	_objaddress(a0),a1
00006D6A 4ED1                     M 	jmp	(a1)
00006D6C                            
00006D6C                            .MoveDongle:
00006D6C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00006D70 0428 0010 0041             		subi.b	#$10,_objAngle(a0)			; Decrement angle
00006D76 0400 0040                  		subi.b	#$40,d0				; Subtract $40
00006D7A 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
00006D7E C3FC 0C00                  		muls.w	#$C00,d1			; Multiply cosine with $C00
00006D82 4841                       		swap	d1				; Get high word
00006D84 D268 0030                  		add.w	_objDongleX(a0),d1			; Add dongle X
00006D88 3141 0014                  		move.w	d1,_objXPos(a0)			; Set actual X
00006D8C C1FC 0C00                  		muls.w	#$C00,d0			; Multiply sine with $C00
00006D90 4840                       		swap	d0				; Get high word
00006D92 D068 0032                  		add.w	_objDongleY(a0),d0			; Add dongle X
00006D96 3140 0018                  		move.w	d0,_objYPos(a0)			; Set actual X
00006D9A 4EB8 2000                  		jsr	CheckObjActive.w		; Display
00006D9E                            	nextObject
00006D9E 3068 0004                M 	movea.w	_objnext(a0),a0
00006DA2 2250                     M 	move.l	_objaddress(a0),a1
00006DA4 4ED1                     M 	jmp	(a1)
00006DA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DA6                            ; Data
00006DA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DA6                            Ani_ObjChkpoint:
00006DA6 0000                       		dc.w	.Ani0-Ani_ObjChkpoint
00006DA8 0000                       		dc.w	.Ani1-Ani_ObjChkpoint
00006DAA 0000                       		dc.w	.Ani2-Ani_ObjChkpoint
00006DAC 0F00 FF                    .Ani0:		dc.b	$F, 0, $FF
00006DB0 00                         		even
00006DB0 0F01 FF                    .Ani1:		dc.b	$F, 1, $FF
00006DB4 00                         		even
00006DB4 0300 04FF                  .Ani2:		dc.b	3, 0, 4, $FF
00006DB8                            		even
00006DB8                            Map_ObjChkpoint:
00006DB8                            		include	"Objects/Checkpoint/Mappings.asm"
00006DB8                            ; --------------------------------------------------------------------------------
00006DB8                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006DB8                            ; --------------------------------------------------------------------------------
00006DB8                            
00006DB8                            SME_JjCUP:	
00006DB8 0000 0000                  		dc.w SME_JjCUP_A-SME_JjCUP, SME_JjCUP_24-SME_JjCUP	
00006DBC 0000 0000                  		dc.w SME_JjCUP_38-SME_JjCUP, SME_JjCUP_40-SME_JjCUP	
00006DC0 0000                       		dc.w SME_JjCUP_48-SME_JjCUP	
00006DC2 0004                       SME_JjCUP_A:	dc.b 0, 4	
00006DC4 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00006DCA F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00006DD0 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
00006DD6 D805 0000 FFF8             		dc.b $D8, 5, 0, 0, $FF, $F8	
00006DDC 0003                       SME_JjCUP_24:	dc.b 0, 3	
00006DDE E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00006DE4 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00006DEA F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
00006DF0 0001                       SME_JjCUP_38:	dc.b 0, 1	
00006DF2 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8	
00006DF8 0001                       SME_JjCUP_40:	dc.b 0, 1	
00006DFA F805 2000 FFF8             		dc.b $F8, 5, $20, 0, $FF, $F8	
00006E00 0004                       SME_JjCUP_48:	dc.b 0, 4	
00006E02 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00006E08 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00006E0E F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
00006E14 D805 2000 FFF8             		dc.b $D8, 5, $20, 0, $FF, $F8	
00006E1A                            		even
00006E1A                            ; =========================================================================================================================================================
00006E1A                            		include	"Objects/Wall Spring/Code.asm"	; Wall spring object
00006E1A                            ; =========================================================================================================================================================
00006E1A                            ; Wall spring object
00006E1A                            ; =========================================================================================================================================================
00006E1A                            ObjWallSpring:
00006E1A 20BC 0000 0000             		move.l	#ObjWallSpring_Main,_objAddress(a0)	; Next routine
00006E20                            	;	move.l	#Map_ObjWallSpring,_objMapping(a0)	; Mappings
00006E20                            	;	clr.w	_objVRAM(a0)			; Tile properties
00006E20                            	;	ori.b	#4,_objRender(a0)			; Render flags
00006E20                            	;	move.w	#rSprInput+$200,oPrio(a0)	; Priority
00006E20                            	;	move.b	#8,_objDrawW(a0)			; Sprite width
00006E20                            	;	move.b	#$40,_objDrawH(a0)			; Sprite height
00006E20 117C 0008 002C             		move.b	#8,_objColW(a0)			; Collision width
00006E26 117C 0040 002D             		move.b	#$40,_objColH(a0)			; Collision height
00006E2C                            
00006E2C 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006E30 E808                       		lsr.b	#4,d0				; Get map frame
00006E32 0200 0007                  		andi.b	#7,d0				; ''
00006E36 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00006E3A 6700                       		beq.s	ObjWallSpring_Main		; If it was 0, branch
00006E3C                            	;	move.b	#$80,_objDrawH(a0)			; Larger sprite height
00006E3C 117C 0080 002D             		move.b	#$80,_objColH(a0)			; Larger collision height
00006E42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E42                            ObjWallSpring_Main:
00006E42 7208                       		moveq	#8,d1				; Width
00006E44 7400                       		moveq	#0,d2
00006E46 1428 002D                  		move.b	_objColH(a0),d2			; Height
00006E4A 3602                       		move.w	d2,d3				; ''
00006E4C 5243                       		addq.w	#1,d3				; ''
00006E4E 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006E52 4EB8 4244                  		jsr	SolidObject_Always		; Make us solid
00006E56                            
00006E56 0806 0000                  		btst	#cTouchSideBit,d6		; Has Sonic touched the side of the spring?
00006E5A 6700                       		beq.s	.Display			; If not, branch
00006E5C 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set in air
00006E62 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00006E66 3028 0014                  		move.w	_objXPos(a0),d0			; Get distance between us and Sonic
00006E6A 9069 0014                  		sub.w	_objXPos(a1),d0			; ''
00006E6E 6500                       		bcs.s	.ChkXStat			; If Sonic is towards the right of the spring, branch
00006E70 0A01 0001                  		eori.b	#1,d1				; Go the other way
00006E74                            
00006E74                            .ChkXStat:
00006E74 0201 0001                  		andi.b	#1,d1				; Has Sonic touched the front of spring?
00006E78 6600                       		bne.s	.Display			; If not, branch
00006E7A 6100                       		bsr.s	.Bounce
00006E7C                            
00006E7C                            .Display:
00006E7C 4EB8 2000                  		jsr	CheckObjActive.w		; Delete if inactive
00006E80                            	nextObject
00006E80 3068 0004                M 	movea.w	_objnext(a0),a0
00006E84 2250                     M 	move.l	_objaddress(a0),a1
00006E86 4ED1                     M 	jmp	(a1)
00006E88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E88                            .Bounce:
00006E88 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is Sonic dead?
00006E8E 6500                       		blo.s	.DoBounce			; If not, branch
00006E90 4E75                       		rts
00006E92                            
00006E92                            .DoBounce:
00006E92 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Make Sonic not hurt if he is
00006E98 337C F800 001C             		move.w	#-$800,_objXVel(a1)		; Bounce left
00006E9E 337C F800 001E             		move.w	#-$800,_objYVel(a1)		; Bounce up
00006EA4 08E9 0000 0028             		bset	#0,_objStatus(a1)			; Face left
00006EAA 0828 0000 0028             		btst	#0,_objStatus(a0)			; Are we facing left?
00006EB0 6600                       		bne.s	.MoveLock			; If so, branch
00006EB2 08A9 0000 0028             		bclr	#0,_objStatus(a1)			; Face right
00006EB8 4469 001C                  		neg.w	_objXVel(a1)			; Go right
00006EBC                            
00006EBC                            .MoveLock:
00006EBC 137C 000F 003F             		move.b	#$F,_objMoveLock(a1)		; Set move lock timer
00006EC2 0829 0002 0028             		btst	#2,_objStatus(a1)			; Was Sonic jumping?
00006EC8 6600                       		bne.s	.ChkN_objYVel			; If so, branch
00006ECA 4229 0020                  		clr.b	_objAnim(a1)			; Reset animation
00006ECE                            
00006ECE                            .ChkN_objYVel:
00006ECE 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006ED2 6A00                       		bpl.s	.ChkFlip			; If Sonic should still bounce up, branch
00006ED4 4229 001E                  		clr.b	_objYVel(a1)			; Stop Y velocity
00006ED8                            
00006ED8                            .ChkFlip:
00006ED8 0800 0000                  		btst	#0,d0				; Should Sonic tumble?
00006EDC 6700                       		beq.s	.PlaySnd			; If not, branch
00006EDE 337C 0001 003A             		move.w	#1,_objFlipDir(a1)			; Set flip direction
00006EE4 137C 0001 0047             		move.b	#1,_objFlipAngle(a1)		; Set flip angle
00006EEA 4229 0020                  		clr.b	_objAnim(a1)			; Reset animation
00006EEE 137C 0001 0049             		move.b	#1,_objFlipRemain(a1)		; Set flips remaining
00006EF4 137C 0008 004A             		move.b	#8,_objFlipSpeed(a1)		; Set flip speed
00006EFA 0800 0001                  		btst	#1,d0				; Should Sonic do 3 flips?
00006EFE 6600                       		bne.s	.ChkDir				; If not, branch
00006F00 137C 0003 0049             		move.b	#3,_objFlipRemain(a1)		; Do 3 flips isntead
00006F06                            
00006F06                            .ChkDir:
00006F06 0829 0000 0028             		btst	#0,_objStatus(a1)			; Was Sonic facing left?
00006F0C 6700                       		beq.s	.PlaySnd			; If not, branch
00006F0E 4429 0047                  		neg.b	_objFlipAngle(a1)			; Flip the other way
00006F12 4469 003A                  		neg.w	_objFlipDir(a1)			; ''
00006F16                            
00006F16                            .PlaySnd:
00006F16 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Stop pushing
00006F1C 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; ''
00006F22                            		playSnd	#sSpring, 2			; Play spring sound
00006F22 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006F28 4E75                       		rts
00006F2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F2A                            ; Data
00006F2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F2A                            Map_ObjWallSpring:
00006F2A                            		include	"Objects/Wall Spring/Mappings.asm"
00006F2A                            ; --------------------------------------------------------------------------------
00006F2A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006F2A                            ; --------------------------------------------------------------------------------
00006F2A                            
00006F2A                            SME_ReVf5:	
00006F2A 0000 0000                  		dc.w SME_ReVf5_4-SME_ReVf5, SME_ReVf5_12-SME_ReVf5	
00006F2E 0002                       SME_ReVf5_4:	dc.b 0, 2	
00006F30 C005 0034 FFF8             		dc.b $C0, 5, 0, $34, $FF, $F8	
00006F36 3005 0034 FFF8             		dc.b $30, 5, 0, $34, $FF, $F8	
00006F3C 0002                       SME_ReVf5_12:	dc.b 0, 2	
00006F3E 8005 0034 FFF8             		dc.b $80, 5, 0, $34, $FF, $F8	
00006F44 7005 0034 FFF8             		dc.b $70, 5, 0, $34, $FF, $F8	
00006F4A                            		even
00006F4A                            		even
00006F4A                            ; =========================================================================================================================================================
00006F4A                            		include	"Objects/Ball Mode/Code.asm"	; Ball mode switch object
00006F4A                            ; =========================================================================================================================================================
00006F4A                            ; Ball mode enable/disable object
00006F4A                            ; =========================================================================================================================================================
00006F4A                            		rsset	_objLvlSSTs
00006F4A =00000030                  _objBModeTouch	rs.b	1				; Touched flag
00006F4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F4A                            ObjBallMode:
00006F4A                            	;	move.l	#ObjBallMode_Main,_objAddress(a0)	; Next routine
00006F4A                            	;	move.l	#Map_ObjMonitor,_objMapping(a0)	; Mappings
00006F4A                            	;	clr.w	_objVRAM(a0)			; Tile properties
00006F4A                            	;	ori.b	#4,_objRender(a0)			; Render flags
00006F4A                            	;	move.w	#rSprInput+$280,oPrio(a0)	; Priority
00006F4A                            	;	move.b	#$10,_objDrawW(a0)			; Sprite width
00006F4A                            	;	move.b	#$10,_objDrawH(a0)			; Sprite height
00006F4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F4A                            ObjBallMode_Main:
00006F4A 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00006F4E 3478 E876                  		movea.w	playerPtrP1.w,a2		; Player object
00006F52 4EB8 1D62                  		jsr	CheckObjInRange.w		; Is the player in range?
00006F56 4A40                       		tst.w	d0				; ''
00006F58 6700                       		beq.s	.NotTouched			; If not, branch
00006F5A                            
00006F5A 08AA 0002 000C             		bclr	#2,_objFlags(a2)
00006F60                            		
00006F60 4A28 0024                  		tst.b	_objSubtype(a0)			; Should we force Sonic out of ball mode?
00006F64 6B00                       		bmi.s	.NoBallMode			; If so, branch
00006F66 6600                       		bne.s	.BallMode			; Branch if we should force Sonic in to ball mode
00006F68                            
00006F68 4A28 0030                  		tst.b	_objBModeTouch(a0)		; Have we already been touched?
00006F6C 6600                       		bne.s	.End				; If so, branch
00006F6E 50E8 0030                  		st	_objBModeTouch(a0)		; Touched
00006F72                            
00006F72 462A 004B                  		not.b	_objBallMode(a2)		; Switch ball mode for Sonic
00006F76 6700                       		beq.s	.End				; If it's not set, branch
00006F78                            
00006F78                            .MakeSonicRoll:
00006F78 2248                       		movea.l	a0,a1				; Save a0
00006F7A 204A                       		movea.l	a2,a0				; Make Sonic roll
00006F7C 4EB8 553E                  		jsr	ObjPlayer_DoRoll		; ''
00006F80 2049                       		movea.l	a1,a0				; Restore a0
00006F82                            	nextObject
00006F82 3068 0004                M 	movea.w	_objnext(a0),a0
00006F86 2250                     M 	move.l	_objaddress(a0),a1
00006F88 4ED1                     M 	jmp	(a1)
00006F8A                            
00006F8A                            .NotTouched:
00006F8A 4228 0030                  		clr.b	_objBModeTouch(a0)		; Not touched
00006F8E                            	nextObject
00006F8E 3068 0004                M 	movea.w	_objnext(a0),a0
00006F92 2250                     M 	move.l	_objaddress(a0),a1
00006F94 4ED1                     M 	jmp	(a1)
00006F96                            
00006F96                            .BallMode:
00006F96 50EA 004B                  		st	_objBallMode(a2)		; Get in to ball mode
00006F9A 60DC                       		bra.s	.MakeSonicRoll			; ''
00006F9C                            
00006F9C                            .NoBallMode:
00006F9C 422A 004B                  		clr.b	_objBallMode(a2)		; Get out of ball mode
00006FA0                            
00006FA0                            .End:
00006FA0                            	nextObject
00006FA0 3068 0004                M 	movea.w	_objnext(a0),a0
00006FA4 2250                     M 	move.l	_objaddress(a0),a1
00006FA6 4ED1                     M 	jmp	(a1)
00006FA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006FA8                            .RangeData:
00006FA8 FFF0 0020                  		dc.w	-$10, $20
00006FAC FFF0 0020                  		dc.w	-$10, $20
00006FB0                            ; =========================================================================================================================================================
00006FB0                            		include	"Objects/Bumper/Code.asm"		; Bumper object
00006FB0                            ; =========================================================================================================================================================
00006FB0                            ; Water surface object
00006FB0                            ; =========================================================================================================================================================
00006FB0                            		rsset	_objLvlSSTs
00006FB0                            
00006FB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006FB0                            ObjAttack:
00006FB0 20BC 0000 0000             		move.l	#ObjBumperMain,_objAddress(a0)	; Next routine
00006FB6 217C 0000 0000 0010        		move.l	#Map_ObjBumper,_objMapping(a0)		; Mappings
00006FBE 317C 035B 000E             		move.w	#$35B,_objVRAM(a0)			; Tile properties
00006FC4 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00006FCA                            		displaySprite	1,a0,a1,0			; Priority
00006FCA 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
00006FD0 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
00006FD4 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006FD8 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006FDC 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
00006FE0                          M .no_274
00006FE0 7210                       		moveq	#$10,d1
00006FE2                            	;	move.b	d1,_objDrawW(a0)
00006FE2                            	;	move.b	d1,_objColW(a0)
00006FE2                            	;	move.b	d1,_objDrawH(a0)
00006FE2                            	;	move.b	d1,_objColH(a0)
00006FE2                            		
00006FE2                            
00006FE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006FE2                            ObjBumperMain:
00006FE2 0C68 0000 0024             		cmpi.w	#0,	_objSubtype(a0)
00006FE8 6700                       		beq.s	.AttackX
00006FEA                            		
00006FEA 0668 FFF6 0014             		add.w	#-10,_objXPos(a0)
00006FF0 6000                       		bra.s	.cont
00006FF2                            		
00006FF2                            	.AttackX:
00006FF2 0668 000A 0014             		add.w	#10,_objXPos(a0)
00006FF8                            	.cont:
00006FF8 5328 0017                  		subq.b	#1,	_objDrawW(a0)
00006FFC 4A28 0017                  		tst.b	_objDrawW(a0)
00007000 6700 0000                  		beq.w	ObjAttack_Delete
00007004                            		
00007004                            	nextObject
00007004 3068 0004                M 	movea.w	_objnext(a0),a0
00007008 2250                     M 	move.l	_objaddress(a0),a1
0000700A 4ED1                     M 	jmp	(a1)
0000700C                            
0000700C                            ObjAttack_Delete:
0000700C                            	;	playSnd	#sCheckpoint, 2			; Play checkpoint sound
0000700C 4EB8 1A4C                  		jsr	DeleteObject.w
00007010                            	nextObject
00007010 3068 0004                M 	movea.w	_objnext(a0),a0
00007014 2250                     M 	move.l	_objaddress(a0),a1
00007016 4ED1                     M 	jmp	(a1)
00007018                            
00007018                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007018                            ; Data
00007018                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007018                            Map_ObjBumper:
00007018                            		include	"Objects/Bumper/Mappings.asm"
00007018                            Map_eb08:
00007018 0000                       Map_eb08_0: 	dc.w Map_eb08_2-Map_eb08
0000701A 0001                       Map_eb08_2: 	dc.b $0, $1
0000701C FC04 0000 FFF8             	dc.b $FC, $4, $0, $0, $FF, $F8
00007022                            	even
00007022                            		even
00007022                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007022                            Ani_ObjBumper:
00007022 0000                       		dc.w	.Ani0-Ani_ObjBumper
00007024 0000                       		dc.w	.Ani1-Ani_ObjBumper
00007026 0500 FF00                  .Ani0:		dc.b	5, 0, $FF, 0
0000702A 0501 0201 02FD 00          .Ani1:		dc.b	5, 1, 2, 1, 2, $FD, 0
00007032 00                         		even
00007032                            ; =========================================================================================================================================================
00007032                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007032                            ; Unused/Temporary
00007032                            ;		include	"Objects/Slicer/Code.asm"		; Slicer object
00007032                            ;		include	"Objects/Shellcracker/Code.asm"	; Shellcracker object
00007032                            ;		include	"Objects/Asteron/Code.asm"	; Asteron object
00007032                            ;		include	"Objects/Boss - WFZ/Code.asm"	; WFZ boss object
00007032                            ;		include	"Objects/Harpoon/Code.asm"	; Harpoon object
00007032                            ;		include	"Objects/CNZ Barrel/Code.asm"	; CNZ barrel object
00007032                            ;		include	"Objects/Diamond/Code.asm"	; Diamond object
00007032                            ;		include	"Objects/Orbinaut/Code.asm"	; Orbinaut object
00007032                            
00007032                            ; =========================================================================================================================================================
00007032                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007032                            ; Object Art
00007032                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007032                            ArtUnc_Sonic:
00007032                            		incbin	"Graphics/Sprites/Sonic/Art.unc"
000071B2                            		even
000071B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000071B2                            ArtKosM_Bumper:
000071B2                            		incbin	"Graphics/Sprites/Bumper/Art.kosm"
000071D0                            		even
000071D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000071D0                            ArtKosM_Chkpoint:
000071D0                            		incbin	"Graphics/Sprites/Checkpoint/Art.kosm"
000072D0 00                         		even
000072D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072D0                            ArtKosM_DrownCnt:
000072D0                            		incbin	"Graphics/Sprites/Drown Countdown/Art.kosm"
000078A2 00                         		even
000078A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000078A2                            ArtKosM_Explosion:
000078A2                            		incbin	"Graphics/Sprites/Explosion/Art.kosm"
00007D34                            		even
00007D34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007D34                            ArtKosM_Monitor:
00007D34                            		incbin	"Graphics/Sprites/Monitor/Art.kosm"
00008056 00                         		even
00008056                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008056                            ArtUnc_Ring:
00008056                            		incbin	"Graphics/Sprites/Ring/Art - Ring.unc"
00008456                            		even
00008456                            
00008456                            ArtKosM_RingSparkle:
00008456                            		incbin	"Graphics/Sprites/Ring/Art - Sparkle.kosm"
000084A2 00                         		even
000084A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000084A2                            ArtKosM_SpikesN:
000084A2                            		incbin	"Graphics/Sprites/Spikes/Art - Normal.kosm"
000084E2                            		even
000084E2                            
000084E2                            ArtKosM_SpikesS:
000084E2                            		incbin	"Graphics/Sprites/Spikes/Art - Sideways.kosm"
00008524 00                         		even
00008524                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008524                            ArtKosM_SpringH:
00008524                            		incbin	"Graphics/Sprites/Spring/Art - Horizontal.kosm"
00008600 00                         		even
00008600                            
00008600                            ArtKosM_SpringV:
00008600                            		incbin	"Graphics/Sprites/Spring/Art - Vertical.kosm"
000086E6 00                         		even
000086E6                            
000086E6                            ArtKosM_SpringD:
000086E6                            		incbin	"Graphics/Sprites/Spring/Art - Diagonal.kosm"
00008900 00                         		even
00008900                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008900                            ArtKosM_WaterSplash:
00008900                            		incbin	"Graphics/Sprites/Water Splash/Art.kosm"
00009114                            		even
00009114                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00009114                            ArtKosM_WaterSurface:
00009114                            		incbin	"Graphics/Sprites/Water Surface/Art.kosm"
0000926E                            		even
0000926E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000926E                            ArtKosM_HUD:
0000926E                            		incbin	"Graphics/Sprites/HUD/Art - HUD Base.kosm"
000092E4                            		even
000092E4                            
000092E4                            ArtUnc_HUDNumbers:
000092E4                            		incbin	"Graphics/Sprites/HUD/Art - HUD Numbers.unc"
00009564 0000 0000 0000 0000 0000+  		dcb.l	16, 0
000095A4                            		even
000095A4                            
000095A4                            ; =========================================================================================================================================================
000095A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000095A4                            ; Level data
000095A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000095A4                            ; Wacky Workbench Zone
000095A4                            
000095A4                            WWZ_FGLayout:
000095A4                            		incbin	"Zones/Wacky Workbench/Foreground.lvl"
00009DC6                            		even
00009DC6                            WWZ_BGLayout:
00009DC6                            		incbin	"Zones/Wacky Workbench/Background.lvl"
00009DEC                            		even
00009DEC                            
00009DEC FFFF 0000 0000             		dc.w	$FFFF, 0, 0				; Null object list entry
00009DF2                            WWZ_Objects:
00009DF2                            		incbin	"Zones/Wacky Workbench/Objects.bin"
00009DFE                            		even
00009DFE                            WWZ_Rings:
00009DFE                            		incbin	"Zones/Wacky Workbench/Rings.bin"
00009E02                            		even
00009E02                            WWZ_Collision:
00009E02 0000 0000 0000 0000 0000+  		dc.l	.ColData, .Angles, .Heights, .HeightsR
00009E12                            .ColData:
00009E12                            		incbin	"Zones/Wacky Workbench/Collision.bin"
0000A412                            		even
0000A412                            .Angles:
0000A412                            		incbin	"Zones/Wacky Workbench/Angle Values.bin"
0000A512                            		even
0000A512                            .Heights:
0000A512                            		incbin	"Zones/Wacky Workbench/Height Values.bin"
0000B512                            		even
0000B512                            .HeightsR:
0000B512                            		incbin	"Zones/Wacky Workbench/Height Values (Rotated).bin"
0000C512                            		even
0000C512                            WWZ_Chunks:
0000C512                            		incbin	"Zones/Wacky Workbench/Chunks.bin"
0000C57C                            		even
0000C57C                            WWZ_Blocks:
0000C57C                            		incbin	"Zones/Wacky Workbench/Blocks.bin"
0000C5A6                            		even
0000C5A6                            WWZ_Pal:
0000C5A6 007F                       		dc.w	$100>>1-1
0000C5A8                            		incbin	"Graphics/Palettes/Wacky Workbench/Normal.pal"
0000C628                                    WWZ_Pal_End:
0000C628                            		incbin	"Graphics/Palettes/Wacky Workbench/Water.pal"
0000C6A8                            		even
0000C6A8                            WWZ_Tiles:
0000C6A8                            		incbin	"Graphics/Tilesets/Wacky Workbench/Tiles.kosm"
0000C732                            		even
0000C732                            ArtUnc_Electricity:
0000C732                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electricity.unc"
0000CB32                            		even
0000CB32                            ArtUnc_ElectricOrbs:
0000CB32                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electric Orbs.unc"
0000CD32                            		even
0000CD32                            ArtUnc_Sirens:
0000CD32                            		incbin	"Graphics/Tilesets/Wacky Workbench/Sirens.unc"
0000CF32                            		even
0000CF32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000CF32                            
0000CF32                            ; =========================================================================================================================================================
0000CF32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000CF32                            ; Sound driver
0000CF32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000CF32                            		include	"Sound/amps/code/68k.asm"
0000CF32                            	opt oz+					; enable zero-offset optimization
0000CF32                            	opt l.					; local lables are dots
0000CF32                            	opt ae+					; enable automatic even's
0000CF32                            
0000CF32                            	include "Sound/amps/code/routines.asm"	; include macro'd routines
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Note timout handler macro
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dNoteToutHandler	macro
0000CF32                            		tst.b	cNoteTimeCur(a5)	; check if timer is 0
0000CF32                            		beq.s	.endt			; if is, do not timeout
0000CF32                            		subq.b	#1,cNoteTimeCur(a5)	; decrease delay by 1
0000CF32                            		bne.s	.endt			; if still not 0, branch
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Note timout handler macro for DAC
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dNoteToutDAC	macro
0000CF32                            	dNoteToutHandler			; include timeout handler
0000CF32                            		moveq	#0,d0			; play stop sample
0000CF32                            		bra.w	dNoteOnDAC2		; ''
0000CF32                            .endt
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Note timout handler macro for FM
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dNoteToutFM	macro
0000CF32                            	dNoteToutHandler			; include timeout handler
0000CF32                            		bset	#cfbRest,(a5)		; set track to resting
0000CF32                            		bsr.w	dKeyOffFM		; key off FM
0000CF32                            		bra.\0	.next			; jump to next track
0000CF32                            .endt
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Note timout handler macro for PSG
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dNoteToutPSG	macro
0000CF32                            	dNoteToutHandler			; include timeout handler
0000CF32                            		bset	#cfbRest,(a5)		; set track to resting
0000CF32                            		bsr.w	dMutePSGmus		; mute PSG channel
0000CF32                            		bra.s	.next			; jump to next track
0000CF32                            .endt
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Macro for calculating the current frequency (without modulation) into d6.
0000CF32                            ; Used if user wants to add extra pitch effects such as pitch slides.
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dCalcFreq	macro
0000CF32                            		move.b	cDetune(a5),d6		; get detune value to d6
0000CF32                            		ext.w	d6			; extend to word
0000CF32                            		add.w	cFreq(a5),d6		; add channel base frequency to it
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Macro for generating frequency modulation code
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dModulate	macro jump,loop,type
0000CF32                            		btst	#cfbMod,(a5)		; check if modulation is active
0000CF32                            		beq.s	.noret			; if not, update volume and return
0000CF32                            		tst.b	cModDelay(a5)		; check if there is delay left
0000CF32                            		beq.s	.started		; if not, modulate!
0000CF32                            		subq.b	#1,cModDelay(a5)	; decrease delay
0000CF32                            .noret
0000CF32                            	if narg>0
0000CF32                            		if narg=3
0000CF32                            			if type<2
0000CF32                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000CF32                            				beq.s	.noupdatevol		; if not, skip
0000CF32                            				jsr	dUpdateVolFM(pc)	; update FM volume
0000CF32                            			.noupdatevol:
0000CF32                            			endif
0000CF32                            			if type>=4
0000CF32                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000CF32                            				beq.s	.noupdatevol		; if not, skip
0000CF32                            				jsr	dUpdateVolDAC(pc)	; update DAC volume
0000CF32                            			.noupdatevol:
0000CF32                            			endif
0000CF32                            			if \type<>5
0000CF32                            				dbf	d7,\loop		; loop for all channels
0000CF32                            			endif
0000CF32                            		endif
0000CF32                            		bra.w	\jump			; jump to next routine
0000CF32                            	else
0000CF32                            		bra.s	.endm			; jump to the next .endm routine
0000CF32                            	endif
0000CF32                            .started
0000CF32                            		subq.b	#1,cModSpeed(a5)	; decrease modulation speed counter
0000CF32                            		bne.s	.noret			; if there's still delay left, update vol and return
0000CF32                            		movea.l	cMod(a5),a1		; get modulation data offset to a1
0000CF32                            		move.b	1(a1),cModSpeed(a5)	; reset modulation speed counter
0000CF32                            		tst.b	cModCount(a5)		; check if this was the last step
0000CF32                            		bne.s	.norev			; if was not, do not reverse
0000CF32                            		move.b	3(a1),cModCount(a5)	; reset steps counter
0000CF32                            		neg.b	cModStep(a5)		; negate step amount
0000CF32                            .norev
0000CF32                            		subq.b	#1,cModCount(a5)	; decrease step counter
0000CF32                            		move.b	cModStep(a5),d5		; get step offset into d5
0000CF32                            		ext.w	d5			; extend to word
0000CF32                            		add.w	cModFreq(a5),d5		; add modulation frequency to it
0000CF32                            		move.w	d5,cModFreq(a5)		; save as the modulation frequency
0000CF32                            		add.w	d5,d6			; add to channel base frequency
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Macro for processing the tracker
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dDoTracker	macro
0000CF32                            		movea.l	cData(a5),a4		; grab tracker address
0000CF32                            	if safe=1
0000CF32                            		AMPS_Debug_TrackUpd		; check if this address is valid
0000CF32                            	endif
0000CF32                            .data
0000CF32                            		moveq	#0,d5
0000CF32                            		move.b	(a4)+,d5		; get a byte from tracker
0000CF32                            		cmpi.b	#$E0,d5			; is this a command?
0000CF32                            		blo.s	.notcomm		; if not, continue
0000CF32                            		jsr	dCommands(pc)		; run the condition flag
0000CF32                            		bra.s	.data			; for most commands, use this branch to loop
0000CF32                            		bra.s	.next			; however, for example sStop will make us return here.
0000CF32                            .notcomm
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Macro for playing a note, and setting up for it (software updates only)
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dProcNote	macro sfx, psg
0000CF32                            		move.l	a4,cData(a5)		; save tracker address
0000CF32                            		move.b	cLastDur(a5),cDuration(a5); copy stored duration
0000CF32                            		btst	#cfbHold,(a5)		; check if we are holding
0000CF32                            		bne.s	.endpn			; if we are, branch
0000CF32                            	if sfx=0
0000CF32                            		move.b	cNoteTimeMain(a5),cNoteTimeCur(a5); copy note timeout value
0000CF32                            	endif
0000CF32                            	if psg<>0
0000CF32                            		clr.b	cEnvPos(a5)		; clear envelope position if PSG channel
0000CF32                            	endif
0000CF32                            		btst	#cfbMod,(a5)		; check if modulation is enabled
0000CF32                            		beq.s	.endpn			; if not, branch
0000CF32                            		movea.l	cMod(a5),a1		; get modulation data address
0000CF32                            		move.b	(a1)+,cModDelay(a5)	; copy delay
0000CF32                            		move.b	(a1)+,cModSpeed(a5)	; copy speed
0000CF32                            		move.b	(a1)+,cModStep(a5)	; copy step offset
0000CF32                            		move.b	(a1),d0			; get number of steps
0000CF32                            		lsr.b	#1,d0			; halve it
0000CF32                            		move.b	d0,cModCount(a5)	; save as the current number of steps
0000CF32                            		clr.w	cModFreq(a5)		; clear frequency offset
0000CF32                            .endpn
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Macro for processing a note in DAC channel
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dTrackNoteDAC	macro
0000CF32                            		btst	#cfbMode,(a5)		; check if we are on pitch mode
0000CF32                            		bne.s	.pitch			; if so, load pitch
0000CF32                            		move.b	d5,cSample(a5)		; else, save as a sample
0000CF32                            		bra.s	.cont
0000CF32                            .pitch
0000CF32                            		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0000CF32                            		bne.s	.noprest		; branch if note wasnt $80 (rest)
0000CF32                            		moveq	#0,d0			; play stop sample
0000CF32                            		bsr.w	dNoteOnDAC2		; ''
0000CF32                            		moveq	#-$80,d6		; tell the code we are resting
0000CF32                            		bra.s	.cont
0000CF32                            .noprest
0000CF32                            		add.b	cPitch(a5),d5		; add pitch offset to note
0000CF32                            		add.w	d5,d5			; double offset (each entry is a word)
0000CF32                            		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0000CF32                            		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0000CF32                            .cont
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Macro for doing keying-on FM channel
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dKeyOnFM	macro
0000CF32                            		btst	#cfbHold,(a5)		; check if note is held
0000CF32                            		bne.s	.k			; if so, do not note on
0000CF32                            		btst	#cfbRest,(a5)		; check if channel is resting
0000CF32                            		bne.s	.k			; if so, do not note on
0000CF32                            	if narg=0
0000CF32                            		btst	#cfbInt,(a5)		; check if overridden by sfx
0000CF32                            		bne.s	.k			; if so, do not note on
0000CF32                            	endif
0000CF32                            		moveq	#$28,d0			; YM command: Key on
0000CF32                            		move.b	cType(a5),d1		; get channel type bits
0000CF32                            		ori.b	#$F0,d1			; turn all FM operators on
0000CF32                            		bsr.w	WriteYM_Pt1		; send note-on event
0000CF32                            .k
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Macro for processing a note in PSG channel
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            dGetFreqPSG	macro
0000CF32                            		subi.b	#$81,d5			; sub $81 from the note (notes start at $80)
0000CF32                            		bhs.s	.norest			; branch if note wasnt $80 (rest)
0000CF32                            		bset	#cfbRest,(a5)		; set channel to resting
0000CF32                            		move.w	#-1,cFreq(a5)		; set invalid PSG frequency
0000CF32                            		jsr	dMutePSGmus(pc)		; mute this PSG channel
0000CF32                            		bra.s	.freqgot
0000CF32                            .norest
0000CF32                            		add.b	cPitch(a5),d5		; add pitch offset to note
0000CF32                            		andi.w	#$7F,d5			; keep within $80 notes
0000CF32                            		add.w	d5,d5			; double offset (each entry is a word)
0000CF32                            		move.w	(a6,d5.w),cFreq(a5)	; load and save the requested frequency
0000CF32                            	if safe=1
0000CF32                            		AMPS_Debug_NotePSG		; check if the note was valid
0000CF32                            	endif
0000CF32                            .freqgot
0000CF32                                endm
0000CF32                            ; ===========================================================================
0000CF32                            	include "Sound/amps/code/debug.asm"	; debug data blob
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; write channel string to console
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            AMPS_Debug_GetChannel	macro
0000CF32                            	cmp.w	#mPSG1,a5
0000CF32                            	bne.s	AMPS_Debug_Writepsg2
0000CF32                            	Console.Write "PSG1"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writepsg2
0000CF32                            	cmp.w	#mPSG2,a5
0000CF32                            	bne.s	AMPS_Debug_Writepsg3
0000CF32                            	Console.Write "PSG2"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writepsg3
0000CF32                            	cmp.w	#mPSG3,a5
0000CF32                            	bne.s	AMPS_Debug_Writepsgs1
0000CF32                            	Console.Write "PSG3"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writepsgs1
0000CF32                            	cmp.w	#mSFXPSG1,a5
0000CF32                            	bne.s	AMPS_Debug_Writepsgs2
0000CF32                            	Console.Write "SFX PSG1"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writepsgs2
0000CF32                            	cmp.w	#mSFXPSG2,a5
0000CF32                            	bne.s	AMPS_Debug_Writepsgs3
0000CF32                            	Console.Write "SFX PSG2"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writepsgs3
0000CF32                            	cmp.w	#mSFXPSG3,a5
0000CF32                            	bne.s	AMPS_Debug_Writedacs1
0000CF32                            	Console.Write "SFX PSG3"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writedacs1
0000CF32                            	cmp.w	#mSFXDAC1,a5
0000CF32                            	bne.s	AMPS_Debug_Writedac1
0000CF32                            	Console.Write "SFX DAC1"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writedac1
0000CF32                            	cmp.w	#mDAC1,a5
0000CF32                            	bne.s	AMPS_Debug_Writedac2
0000CF32                            	Console.Write "DAC1"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writedac2
0000CF32                            	cmp.w	#mDAC2,a5
0000CF32                            	bne.s	AMPS_Debug_Writefm1
0000CF32                            	Console.Write "DAC2"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writefm1
0000CF32                            	cmp.w	#mFM1,a5
0000CF32                            	bne.s	AMPS_Debug_Writefm2
0000CF32                            	Console.Write "FM1"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writefm2
0000CF32                            	cmp.w	#mFM2,a5
0000CF32                            	bne.s	AMPS_Debug_Writefm3
0000CF32                            	Console.Write "FM2"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writefm3
0000CF32                            	cmp.w	#mFM3,a5
0000CF32                            	bne.s	AMPS_Debug_Writefm4
0000CF32                            	Console.Write "FM3"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writefm4
0000CF32                            	cmp.w	#mFM4,a5
0000CF32                            	bne.s	AMPS_Debug_Writefm5
0000CF32                            	Console.Write "FM4"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writefm5
0000CF32                            	cmp.w	#mFM5,a5
0000CF32                            	bne.s	AMPS_Debug_Writefms3
0000CF32                            	Console.Write "FM5"
0000CF32                            	bra.w	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writefms3
0000CF32                            	cmp.w	#mSFXFM3,a5
0000CF32                            	bne.s	AMPS_Debug_Writefms4
0000CF32                            	Console.Write "SFX FM3"
0000CF32                            	rts
0000CF32                            AMPS_Debug_Writefms4
0000CF32                            	cmp.w	#mSFXFM4,a5
0000CF32                            	bne.s	AMPS_Debug_Writefms5
0000CF32                            	Console.Write "SFX FM4"
0000CF32                            	bra.s	AMPS_Debug_Writeend
0000CF32                            AMPS_Debug_Writefms5
0000CF32                            	cmp.w	#mSFXFM5,a5
0000CF32                            	beq.s	AMPS_Debug_Writefms5_
0000CF32                            AMPS_Debug_Writeaddr
0000CF32                            	Console.Write "%<fpal2>%<.l a5>"
0000CF32                            	rts
0000CF32                            AMPS_Debug_Writefms5_
0000CF32                            	Console.Write "SFX FM5"
0000CF32                            AMPS_Debug_Writeend
0000CF32                            	endm
0000CF32                            ; ===========================================================================
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            ; Channel console code
0000CF32                            ; ---------------------------------------------------------------------------
0000CF32                            
0000CF32                            AMPS_Debug_Console_Channel:
0000CF32                            	Console.WriteLine "  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF32 40E7                     M 	move.w	sr,-(sp)
0000CF34                          M 	__fstring_generateargumentscode	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF34 =00000000                M 	__stack:set	0
0000CF34 =00000000                M 	__sp:	set 0
0000CF34                          M 	while	(__pos)
0000CF34 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF34 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF34 =0000000A                M 	__midpos:	= __endpos
0000CF34                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF34 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF34 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF34 =00000016                M 	__midpos:	= __endpos
0000CF34                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF34 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF34 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF34 =0000001E                M 	__midpos:	= __endpos
0000CF34                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	pushp	"move.l d0,-(sp)"
0000CF34 =00000001                M 	__stack:	= __stack+1
0000CF34 =00000004                M 	__sp:	= __sp+4
0000CF34 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF34 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF34 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF34 =00000028                M 	__midpos:	= __endpos
0000CF34                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF34 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF34 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF34 =00000034                M 	__midpos:	= __endpos
0000CF34                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF34 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF34 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF34 =0000003C                M 	__midpos:	= __endpos
0000CF34                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF34                          M 	pushp	"move.l a0,-(sp)"
0000CF34 =00000002                M 	__stack:	= __stack+1
0000CF34 =00000008                M 	__sp:	= __sp+4
0000CF34 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF34                          M 	rept	__stack
0000CF34                          M 	popp	__command
0000CF34 2F08                     M 	move.l	a0,-(sp)
0000CF36                          M 	popp	__command
0000CF36 2F00                     M 	move.l	d0,-(sp)
0000CF38 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000CF3C 45EF 0010                M 	lea	4*4(sp),a2
0000CF40 43FA 0000                M 	lea	.str_277(pc),a1
0000CF44 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000CF4A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000CF4E 504F                     M 	addq.w	#__sp,sp
0000CF50 46DF                     M 	move.w	(sp)+,sr
0000CF52 6000 0000                M 	bra.w	.instr_end_277
0000CF56                          M 	.str_277:
0000CF56                          M 	__fstring_generatedecodedstring	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF56 =00000001                M 	__lpos:	set 1
0000CF56 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF56                          M 	while	(__pos)
0000CF56                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF56 2020                     M 	dc.b	"  "
0000CF58 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF58 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF58 =0000000A                M 	__midpos:	= __endpos
0000CF58                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF58                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF58 E8                       M 	dc.b	fpal0
0000CF59 =0000000B                M 	__lpos:	set __endpos+1
0000CF59 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF59                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF59 6430 3A20                M 	dc.b	"d0: "
0000CF5D =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF5D =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF5D =00000016                M 	__midpos:	= __endpos
0000CF5D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF5D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF5D EC                       M 	dc.b	fpal2
0000CF5E =00000017                M 	__lpos:	set __endpos+1
0000CF5E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF5E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF5E                          M 	dc.b	""
0000CF5E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF5E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF5E =0000001E                M 	__midpos:	= __endpos
0000CF5E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF5E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF5E                          M 	__param:	substr ,,"hex"
0000CF5E 83                       M 	dc.b	hex|3
0000CF5F =0000001F                M 	__lpos:	set __endpos+1
0000CF5F =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF5F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF5F 2020                     M 	dc.b	"  "
0000CF61 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF61 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF61 =00000028                M 	__midpos:	= __endpos
0000CF61                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF61                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF61 E8                       M 	dc.b	fpal0
0000CF62 =00000029                M 	__lpos:	set __endpos+1
0000CF62 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF62                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF62 6130 3A20                M 	dc.b	"a0: "
0000CF66 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF66 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF66 =00000034                M 	__midpos:	= __endpos
0000CF66                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF66                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF66 EC                       M 	dc.b	fpal2
0000CF67 =00000035                M 	__lpos:	set __endpos+1
0000CF67 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF67                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF67                          M 	dc.b	""
0000CF67 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000CF67 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000CF67 =0000003C                M 	__midpos:	= __endpos
0000CF67                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF67                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF67                          M 	__param:	substr ,,"hex"
0000CF67 83                       M 	dc.b	hex|3
0000CF68 =0000003D                M 	__lpos:	set __endpos+1
0000CF68 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000CF68                          M 	__substr:	substr __lpos,,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000CF68                          M 	dc.b	""
0000CF68 00                       M 	dc.b	0
0000CF6A 00                       M 	even
0000CF6A                          M 	.instr_end_277:
0000CF6A                            	Console.WriteLine "  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6A 40E7                     M 	move.w	sr,-(sp)
0000CF6C                          M 	__fstring_generateargumentscode	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF6C =00000000                M 	__stack:set	0
0000CF6C =00000000                M 	__sp:	set 0
0000CF6C                          M 	while	(__pos)
0000CF6C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF6C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF6C =0000000A                M 	__midpos:	= __endpos
0000CF6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF6C =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF6C =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF6C =00000016                M 	__midpos:	= __endpos
0000CF6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF6C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF6C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF6C =0000001E                M 	__midpos:	= __endpos
0000CF6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	pushp	"move.l d1,-(sp)"
0000CF6C =00000001                M 	__stack:	= __stack+1
0000CF6C =00000004                M 	__sp:	= __sp+4
0000CF6C =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF6C =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF6C =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF6C =00000028                M 	__midpos:	= __endpos
0000CF6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF6C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF6C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF6C =00000034                M 	__midpos:	= __endpos
0000CF6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF6C =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF6C =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF6C =0000003C                M 	__midpos:	= __endpos
0000CF6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF6C                          M 	pushp	"move.l a1,-(sp)"
0000CF6C =00000002                M 	__stack:	= __stack+1
0000CF6C =00000008                M 	__sp:	= __sp+4
0000CF6C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF6C                          M 	rept	__stack
0000CF6C                          M 	popp	__command
0000CF6C 2F09                     M 	move.l	a1,-(sp)
0000CF6E                          M 	popp	__command
0000CF6E 2F01                     M 	move.l	d1,-(sp)
0000CF70 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000CF74 45EF 0010                M 	lea	4*4(sp),a2
0000CF78 43FA 0000                M 	lea	.str_280(pc),a1
0000CF7C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000CF82 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000CF86 504F                     M 	addq.w	#__sp,sp
0000CF88 46DF                     M 	move.w	(sp)+,sr
0000CF8A 6000 0000                M 	bra.w	.instr_end_280
0000CF8E                          M 	.str_280:
0000CF8E                          M 	__fstring_generatedecodedstring	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF8E =00000001                M 	__lpos:	set 1
0000CF8E =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF8E                          M 	while	(__pos)
0000CF8E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF8E 2020                     M 	dc.b	"  "
0000CF90 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF90 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF90 =0000000A                M 	__midpos:	= __endpos
0000CF90                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF90                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF90 E8                       M 	dc.b	fpal0
0000CF91 =0000000B                M 	__lpos:	set __endpos+1
0000CF91 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF91                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF91 6431 3A20                M 	dc.b	"d1: "
0000CF95 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF95 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF95 =00000016                M 	__midpos:	= __endpos
0000CF95                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF95                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF95 EC                       M 	dc.b	fpal2
0000CF96 =00000017                M 	__lpos:	set __endpos+1
0000CF96 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF96                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF96                          M 	dc.b	""
0000CF96 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF96 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF96 =0000001E                M 	__midpos:	= __endpos
0000CF96                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF96                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF96                          M 	__param:	substr ,,"hex"
0000CF96 83                       M 	dc.b	hex|3
0000CF97 =0000001F                M 	__lpos:	set __endpos+1
0000CF97 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF97                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF97 2020                     M 	dc.b	"  "
0000CF99 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF99 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF99 =00000028                M 	__midpos:	= __endpos
0000CF99                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF99                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF99 E8                       M 	dc.b	fpal0
0000CF9A =00000029                M 	__lpos:	set __endpos+1
0000CF9A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF9A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF9A 6131 3A20                M 	dc.b	"a1: "
0000CF9E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF9E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF9E =00000034                M 	__midpos:	= __endpos
0000CF9E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF9E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF9E EC                       M 	dc.b	fpal2
0000CF9F =00000035                M 	__lpos:	set __endpos+1
0000CF9F =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CF9F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF9F                          M 	dc.b	""
0000CF9F =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000CF9F =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000CF9F =0000003C                M 	__midpos:	= __endpos
0000CF9F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF9F                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CF9F                          M 	__param:	substr ,,"hex"
0000CF9F 83                       M 	dc.b	hex|3
0000CFA0 =0000003D                M 	__lpos:	set __endpos+1
0000CFA0 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000CFA0                          M 	__substr:	substr __lpos,,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000CFA0                          M 	dc.b	""
0000CFA0 00                       M 	dc.b	0
0000CFA2 00                       M 	even
0000CFA2                          M 	.instr_end_280:
0000CFA2                            	Console.WriteLine "  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA2 40E7                     M 	move.w	sr,-(sp)
0000CFA4                          M 	__fstring_generateargumentscode	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFA4 =00000000                M 	__stack:set	0
0000CFA4 =00000000                M 	__sp:	set 0
0000CFA4                          M 	while	(__pos)
0000CFA4 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFA4 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFA4 =0000000A                M 	__midpos:	= __endpos
0000CFA4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFA4 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFA4 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFA4 =00000016                M 	__midpos:	= __endpos
0000CFA4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFA4 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFA4 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFA4 =0000001E                M 	__midpos:	= __endpos
0000CFA4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	pushp	"move.l d2,-(sp)"
0000CFA4 =00000001                M 	__stack:	= __stack+1
0000CFA4 =00000004                M 	__sp:	= __sp+4
0000CFA4 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFA4 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFA4 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFA4 =00000028                M 	__midpos:	= __endpos
0000CFA4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFA4 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFA4 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFA4 =00000034                M 	__midpos:	= __endpos
0000CFA4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFA4 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFA4 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFA4 =0000003C                M 	__midpos:	= __endpos
0000CFA4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFA4                          M 	pushp	"move.l a2,-(sp)"
0000CFA4 =00000002                M 	__stack:	= __stack+1
0000CFA4 =00000008                M 	__sp:	= __sp+4
0000CFA4 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFA4                          M 	rept	__stack
0000CFA4                          M 	popp	__command
0000CFA4 2F0A                     M 	move.l	a2,-(sp)
0000CFA6                          M 	popp	__command
0000CFA6 2F02                     M 	move.l	d2,-(sp)
0000CFA8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000CFAC 45EF 0010                M 	lea	4*4(sp),a2
0000CFB0 43FA 0000                M 	lea	.str_283(pc),a1
0000CFB4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000CFBA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000CFBE 504F                     M 	addq.w	#__sp,sp
0000CFC0 46DF                     M 	move.w	(sp)+,sr
0000CFC2 6000 0000                M 	bra.w	.instr_end_283
0000CFC6                          M 	.str_283:
0000CFC6                          M 	__fstring_generatedecodedstring	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFC6 =00000001                M 	__lpos:	set 1
0000CFC6 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFC6                          M 	while	(__pos)
0000CFC6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFC6 2020                     M 	dc.b	"  "
0000CFC8 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFC8 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFC8 =0000000A                M 	__midpos:	= __endpos
0000CFC8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFC8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFC8 E8                       M 	dc.b	fpal0
0000CFC9 =0000000B                M 	__lpos:	set __endpos+1
0000CFC9 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFC9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFC9 6432 3A20                M 	dc.b	"d2: "
0000CFCD =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFCD =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFCD =00000016                M 	__midpos:	= __endpos
0000CFCD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFCD                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFCD EC                       M 	dc.b	fpal2
0000CFCE =00000017                M 	__lpos:	set __endpos+1
0000CFCE =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFCE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFCE                          M 	dc.b	""
0000CFCE =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFCE =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFCE =0000001E                M 	__midpos:	= __endpos
0000CFCE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFCE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFCE                          M 	__param:	substr ,,"hex"
0000CFCE 83                       M 	dc.b	hex|3
0000CFCF =0000001F                M 	__lpos:	set __endpos+1
0000CFCF =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFCF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFCF 2020                     M 	dc.b	"  "
0000CFD1 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFD1 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFD1 =00000028                M 	__midpos:	= __endpos
0000CFD1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFD1                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFD1 E8                       M 	dc.b	fpal0
0000CFD2 =00000029                M 	__lpos:	set __endpos+1
0000CFD2 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFD2                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFD2 6132 3A20                M 	dc.b	"a2: "
0000CFD6 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFD6 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFD6 =00000034                M 	__midpos:	= __endpos
0000CFD6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFD6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFD6 EC                       M 	dc.b	fpal2
0000CFD7 =00000035                M 	__lpos:	set __endpos+1
0000CFD7 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFD7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFD7                          M 	dc.b	""
0000CFD7 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000CFD7 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000CFD7 =0000003C                M 	__midpos:	= __endpos
0000CFD7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFD7                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFD7                          M 	__param:	substr ,,"hex"
0000CFD7 83                       M 	dc.b	hex|3
0000CFD8 =0000003D                M 	__lpos:	set __endpos+1
0000CFD8 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000CFD8                          M 	__substr:	substr __lpos,,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000CFD8                          M 	dc.b	""
0000CFD8 00                       M 	dc.b	0
0000CFDA 00                       M 	even
0000CFDA                          M 	.instr_end_283:
0000CFDA                            	Console.WriteLine "  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDA 40E7                     M 	move.w	sr,-(sp)
0000CFDC                          M 	__fstring_generateargumentscode	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000CFDC =00000000                M 	__stack:set	0
0000CFDC =00000000                M 	__sp:	set 0
0000CFDC                          M 	while	(__pos)
0000CFDC =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000CFDC =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000CFDC =0000000A                M 	__midpos:	= __endpos
0000CFDC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000CFDC =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000CFDC =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000CFDC =00000016                M 	__midpos:	= __endpos
0000CFDC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000CFDC =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000CFDC =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000CFDC =0000001E                M 	__midpos:	= __endpos
0000CFDC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	pushp	"move.l d3,-(sp)"
0000CFDC =00000001                M 	__stack:	= __stack+1
0000CFDC =00000004                M 	__sp:	= __sp+4
0000CFDC =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000CFDC =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000CFDC =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000CFDC =00000028                M 	__midpos:	= __endpos
0000CFDC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000CFDC =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000CFDC =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000CFDC =00000034                M 	__midpos:	= __endpos
0000CFDC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000CFDC =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000CFDC =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000CFDC =0000003C                M 	__midpos:	= __endpos
0000CFDC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFDC                          M 	pushp	"move.l a3,-(sp)"
0000CFDC =00000002                M 	__stack:	= __stack+1
0000CFDC =00000008                M 	__sp:	= __sp+4
0000CFDC =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000CFDC                          M 	rept	__stack
0000CFDC                          M 	popp	__command
0000CFDC 2F0B                     M 	move.l	a3,-(sp)
0000CFDE                          M 	popp	__command
0000CFDE 2F03                     M 	move.l	d3,-(sp)
0000CFE0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000CFE4 45EF 0010                M 	lea	4*4(sp),a2
0000CFE8 43FA 0000                M 	lea	.str_286(pc),a1
0000CFEC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000CFF2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000CFF6 504F                     M 	addq.w	#__sp,sp
0000CFF8 46DF                     M 	move.w	(sp)+,sr
0000CFFA 6000 0000                M 	bra.w	.instr_end_286
0000CFFE                          M 	.str_286:
0000CFFE                          M 	__fstring_generatedecodedstring	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFFE =00000001                M 	__lpos:	set 1
0000CFFE =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000CFFE                          M 	while	(__pos)
0000CFFE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000CFFE 2020                     M 	dc.b	"  "
0000D000 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D000 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D000 =0000000A                M 	__midpos:	= __endpos
0000D000                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D000                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D000 E8                       M 	dc.b	fpal0
0000D001 =0000000B                M 	__lpos:	set __endpos+1
0000D001 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D001                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D001 6433 3A20                M 	dc.b	"d3: "
0000D005 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D005 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D005 =00000016                M 	__midpos:	= __endpos
0000D005                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D005                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D005 EC                       M 	dc.b	fpal2
0000D006 =00000017                M 	__lpos:	set __endpos+1
0000D006 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D006                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D006                          M 	dc.b	""
0000D006 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D006 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D006 =0000001E                M 	__midpos:	= __endpos
0000D006                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D006                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D006                          M 	__param:	substr ,,"hex"
0000D006 83                       M 	dc.b	hex|3
0000D007 =0000001F                M 	__lpos:	set __endpos+1
0000D007 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D007                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D007 2020                     M 	dc.b	"  "
0000D009 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D009 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D009 =00000028                M 	__midpos:	= __endpos
0000D009                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D009                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D009 E8                       M 	dc.b	fpal0
0000D00A =00000029                M 	__lpos:	set __endpos+1
0000D00A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D00A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D00A 6133 3A20                M 	dc.b	"a3: "
0000D00E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D00E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D00E =00000034                M 	__midpos:	= __endpos
0000D00E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D00E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D00E EC                       M 	dc.b	fpal2
0000D00F =00000035                M 	__lpos:	set __endpos+1
0000D00F =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D00F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D00F                          M 	dc.b	""
0000D00F =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D00F =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D00F =0000003C                M 	__midpos:	= __endpos
0000D00F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D00F                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D00F                          M 	__param:	substr ,,"hex"
0000D00F 83                       M 	dc.b	hex|3
0000D010 =0000003D                M 	__lpos:	set __endpos+1
0000D010 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D010                          M 	__substr:	substr __lpos,,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D010                          M 	dc.b	""
0000D010 00                       M 	dc.b	0
0000D012 00                       M 	even
0000D012                          M 	.instr_end_286:
0000D012                            	Console.WriteLine "  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D012 40E7                     M 	move.w	sr,-(sp)
0000D014                          M 	__fstring_generateargumentscode	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D014 =00000000                M 	__stack:set	0
0000D014 =00000000                M 	__sp:	set 0
0000D014                          M 	while	(__pos)
0000D014 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D014 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D014 =0000000A                M 	__midpos:	= __endpos
0000D014                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D014 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D014 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D014 =00000016                M 	__midpos:	= __endpos
0000D014                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D014 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D014 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D014 =0000001E                M 	__midpos:	= __endpos
0000D014                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	pushp	"move.l d4,-(sp)"
0000D014 =00000001                M 	__stack:	= __stack+1
0000D014 =00000004                M 	__sp:	= __sp+4
0000D014 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D014 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D014 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D014 =00000028                M 	__midpos:	= __endpos
0000D014                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D014 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D014 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D014 =00000034                M 	__midpos:	= __endpos
0000D014                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D014 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D014 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D014 =0000003C                M 	__midpos:	= __endpos
0000D014                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D014                          M 	pushp	"move.l a4,-(sp)"
0000D014 =00000002                M 	__stack:	= __stack+1
0000D014 =00000008                M 	__sp:	= __sp+4
0000D014 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D014                          M 	rept	__stack
0000D014                          M 	popp	__command
0000D014 2F0C                     M 	move.l	a4,-(sp)
0000D016                          M 	popp	__command
0000D016 2F04                     M 	move.l	d4,-(sp)
0000D018 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D01C 45EF 0010                M 	lea	4*4(sp),a2
0000D020 43FA 0000                M 	lea	.str_289(pc),a1
0000D024 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D02A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D02E 504F                     M 	addq.w	#__sp,sp
0000D030 46DF                     M 	move.w	(sp)+,sr
0000D032 6000 0000                M 	bra.w	.instr_end_289
0000D036                          M 	.str_289:
0000D036                          M 	__fstring_generatedecodedstring	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D036 =00000001                M 	__lpos:	set 1
0000D036 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D036                          M 	while	(__pos)
0000D036                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D036 2020                     M 	dc.b	"  "
0000D038 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D038 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D038 =0000000A                M 	__midpos:	= __endpos
0000D038                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D038                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D038 E8                       M 	dc.b	fpal0
0000D039 =0000000B                M 	__lpos:	set __endpos+1
0000D039 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D039                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D039 6434 3A20                M 	dc.b	"d4: "
0000D03D =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D03D =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D03D =00000016                M 	__midpos:	= __endpos
0000D03D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D03D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D03D EC                       M 	dc.b	fpal2
0000D03E =00000017                M 	__lpos:	set __endpos+1
0000D03E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D03E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D03E                          M 	dc.b	""
0000D03E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D03E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D03E =0000001E                M 	__midpos:	= __endpos
0000D03E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D03E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D03E                          M 	__param:	substr ,,"hex"
0000D03E 83                       M 	dc.b	hex|3
0000D03F =0000001F                M 	__lpos:	set __endpos+1
0000D03F =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D03F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D03F 2020                     M 	dc.b	"  "
0000D041 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D041 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D041 =00000028                M 	__midpos:	= __endpos
0000D041                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D041                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D041 E8                       M 	dc.b	fpal0
0000D042 =00000029                M 	__lpos:	set __endpos+1
0000D042 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D042                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D042 6134 3A20                M 	dc.b	"a4: "
0000D046 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D046 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D046 =00000034                M 	__midpos:	= __endpos
0000D046                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D046                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D046 EC                       M 	dc.b	fpal2
0000D047 =00000035                M 	__lpos:	set __endpos+1
0000D047 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D047                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D047                          M 	dc.b	""
0000D047 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D047 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D047 =0000003C                M 	__midpos:	= __endpos
0000D047                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D047                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D047                          M 	__param:	substr ,,"hex"
0000D047 83                       M 	dc.b	hex|3
0000D048 =0000003D                M 	__lpos:	set __endpos+1
0000D048 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D048                          M 	__substr:	substr __lpos,,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D048                          M 	dc.b	""
0000D048 00                       M 	dc.b	0
0000D04A 00                       M 	even
0000D04A                          M 	.instr_end_289:
0000D04A                            	Console.WriteLine "  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04A 40E7                     M 	move.w	sr,-(sp)
0000D04C                          M 	__fstring_generateargumentscode	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D04C =00000000                M 	__stack:set	0
0000D04C =00000000                M 	__sp:	set 0
0000D04C                          M 	while	(__pos)
0000D04C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D04C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D04C =0000000A                M 	__midpos:	= __endpos
0000D04C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D04C =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D04C =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D04C =00000016                M 	__midpos:	= __endpos
0000D04C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D04C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D04C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D04C =0000001E                M 	__midpos:	= __endpos
0000D04C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	pushp	"move.l d5,-(sp)"
0000D04C =00000001                M 	__stack:	= __stack+1
0000D04C =00000004                M 	__sp:	= __sp+4
0000D04C =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D04C =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D04C =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D04C =00000028                M 	__midpos:	= __endpos
0000D04C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D04C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D04C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D04C =00000034                M 	__midpos:	= __endpos
0000D04C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D04C =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D04C =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D04C =0000003C                M 	__midpos:	= __endpos
0000D04C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D04C                          M 	pushp	"move.l a5,-(sp)"
0000D04C =00000002                M 	__stack:	= __stack+1
0000D04C =00000008                M 	__sp:	= __sp+4
0000D04C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D04C                          M 	rept	__stack
0000D04C                          M 	popp	__command
0000D04C 2F0D                     M 	move.l	a5,-(sp)
0000D04E                          M 	popp	__command
0000D04E 2F05                     M 	move.l	d5,-(sp)
0000D050 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D054 45EF 0010                M 	lea	4*4(sp),a2
0000D058 43FA 0000                M 	lea	.str_292(pc),a1
0000D05C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D062 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D066 504F                     M 	addq.w	#__sp,sp
0000D068 46DF                     M 	move.w	(sp)+,sr
0000D06A 6000 0000                M 	bra.w	.instr_end_292
0000D06E                          M 	.str_292:
0000D06E                          M 	__fstring_generatedecodedstring	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D06E =00000001                M 	__lpos:	set 1
0000D06E =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D06E                          M 	while	(__pos)
0000D06E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D06E 2020                     M 	dc.b	"  "
0000D070 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D070 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D070 =0000000A                M 	__midpos:	= __endpos
0000D070                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D070                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D070 E8                       M 	dc.b	fpal0
0000D071 =0000000B                M 	__lpos:	set __endpos+1
0000D071 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D071                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D071 6435 3A20                M 	dc.b	"d5: "
0000D075 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D075 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D075 =00000016                M 	__midpos:	= __endpos
0000D075                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D075                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D075 EC                       M 	dc.b	fpal2
0000D076 =00000017                M 	__lpos:	set __endpos+1
0000D076 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D076                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D076                          M 	dc.b	""
0000D076 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D076 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D076 =0000001E                M 	__midpos:	= __endpos
0000D076                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D076                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D076                          M 	__param:	substr ,,"hex"
0000D076 83                       M 	dc.b	hex|3
0000D077 =0000001F                M 	__lpos:	set __endpos+1
0000D077 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D077                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D077 2020                     M 	dc.b	"  "
0000D079 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D079 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D079 =00000028                M 	__midpos:	= __endpos
0000D079                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D079                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D079 E8                       M 	dc.b	fpal0
0000D07A =00000029                M 	__lpos:	set __endpos+1
0000D07A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D07A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D07A 6135 3A20                M 	dc.b	"a5: "
0000D07E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D07E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D07E =00000034                M 	__midpos:	= __endpos
0000D07E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D07E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D07E EC                       M 	dc.b	fpal2
0000D07F =00000035                M 	__lpos:	set __endpos+1
0000D07F =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D07F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D07F                          M 	dc.b	""
0000D07F =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D07F =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D07F =0000003C                M 	__midpos:	= __endpos
0000D07F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D07F                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D07F                          M 	__param:	substr ,,"hex"
0000D07F 83                       M 	dc.b	hex|3
0000D080 =0000003D                M 	__lpos:	set __endpos+1
0000D080 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D080                          M 	__substr:	substr __lpos,,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D080                          M 	dc.b	""
0000D080 00                       M 	dc.b	0
0000D082 00                       M 	even
0000D082                          M 	.instr_end_292:
0000D082                            	Console.WriteLine "  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D082 40E7                     M 	move.w	sr,-(sp)
0000D084                          M 	__fstring_generateargumentscode	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D084 =00000000                M 	__stack:set	0
0000D084 =00000000                M 	__sp:	set 0
0000D084                          M 	while	(__pos)
0000D084 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D084 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D084 =0000000A                M 	__midpos:	= __endpos
0000D084                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D084 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D084 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D084 =00000016                M 	__midpos:	= __endpos
0000D084                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D084 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D084 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D084 =0000001E                M 	__midpos:	= __endpos
0000D084                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	pushp	"move.l d6,-(sp)"
0000D084 =00000001                M 	__stack:	= __stack+1
0000D084 =00000004                M 	__sp:	= __sp+4
0000D084 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D084 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D084 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D084 =00000028                M 	__midpos:	= __endpos
0000D084                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D084 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D084 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D084 =00000034                M 	__midpos:	= __endpos
0000D084                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D084 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D084 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D084 =0000003C                M 	__midpos:	= __endpos
0000D084                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D084                          M 	pushp	"move.l a6,-(sp)"
0000D084 =00000002                M 	__stack:	= __stack+1
0000D084 =00000008                M 	__sp:	= __sp+4
0000D084 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D084                          M 	rept	__stack
0000D084                          M 	popp	__command
0000D084 2F0E                     M 	move.l	a6,-(sp)
0000D086                          M 	popp	__command
0000D086 2F06                     M 	move.l	d6,-(sp)
0000D088 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D08C 45EF 0010                M 	lea	4*4(sp),a2
0000D090 43FA 0000                M 	lea	.str_295(pc),a1
0000D094 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D09A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D09E 504F                     M 	addq.w	#__sp,sp
0000D0A0 46DF                     M 	move.w	(sp)+,sr
0000D0A2 6000 0000                M 	bra.w	.instr_end_295
0000D0A6                          M 	.str_295:
0000D0A6                          M 	__fstring_generatedecodedstring	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0A6 =00000001                M 	__lpos:	set 1
0000D0A6 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D0A6                          M 	while	(__pos)
0000D0A6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0A6 2020                     M 	dc.b	"  "
0000D0A8 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D0A8 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D0A8 =0000000A                M 	__midpos:	= __endpos
0000D0A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0A8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0A8 E8                       M 	dc.b	fpal0
0000D0A9 =0000000B                M 	__lpos:	set __endpos+1
0000D0A9 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D0A9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0A9 6436 3A20                M 	dc.b	"d6: "
0000D0AD =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D0AD =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D0AD =00000016                M 	__midpos:	= __endpos
0000D0AD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0AD                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0AD EC                       M 	dc.b	fpal2
0000D0AE =00000017                M 	__lpos:	set __endpos+1
0000D0AE =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D0AE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0AE                          M 	dc.b	""
0000D0AE =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D0AE =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D0AE =0000001E                M 	__midpos:	= __endpos
0000D0AE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0AE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0AE                          M 	__param:	substr ,,"hex"
0000D0AE 83                       M 	dc.b	hex|3
0000D0AF =0000001F                M 	__lpos:	set __endpos+1
0000D0AF =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D0AF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0AF 2020                     M 	dc.b	"  "
0000D0B1 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D0B1 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D0B1 =00000028                M 	__midpos:	= __endpos
0000D0B1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0B1                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0B1 E8                       M 	dc.b	fpal0
0000D0B2 =00000029                M 	__lpos:	set __endpos+1
0000D0B2 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D0B2                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0B2 6136 3A20                M 	dc.b	"a6: "
0000D0B6 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D0B6 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D0B6 =00000034                M 	__midpos:	= __endpos
0000D0B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0B6 EC                       M 	dc.b	fpal2
0000D0B7 =00000035                M 	__lpos:	set __endpos+1
0000D0B7 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D0B7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0B7                          M 	dc.b	""
0000D0B7 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D0B7 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D0B7 =0000003C                M 	__midpos:	= __endpos
0000D0B7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0B7                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0B7                          M 	__param:	substr ,,"hex"
0000D0B7 83                       M 	dc.b	hex|3
0000D0B8 =0000003D                M 	__lpos:	set __endpos+1
0000D0B8 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D0B8                          M 	__substr:	substr __lpos,,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D0B8                          M 	dc.b	""
0000D0B8 00                       M 	dc.b	0
0000D0BA 00                       M 	even
0000D0BA                          M 	.instr_end_295:
0000D0BA                            	Console.WriteLine "  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BA 40E7                     M 	move.w	sr,-(sp)
0000D0BC                          M 	__fstring_generateargumentscode	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0BC =00000000                M 	__stack:set	0
0000D0BC =00000000                M 	__sp:	set 0
0000D0BC                          M 	while	(__pos)
0000D0BC =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0BC =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0BC =0000000A                M 	__midpos:	= __endpos
0000D0BC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0BC =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0BC =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0BC =00000016                M 	__midpos:	= __endpos
0000D0BC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0BC =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0BC =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0BC =0000001E                M 	__midpos:	= __endpos
0000D0BC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	pushp	"move.l d7,-(sp)"
0000D0BC =00000001                M 	__stack:	= __stack+1
0000D0BC =00000004                M 	__sp:	= __sp+4
0000D0BC =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0BC =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0BC =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0BC =00000028                M 	__midpos:	= __endpos
0000D0BC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0BC =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0BC =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0BC =00000034                M 	__midpos:	= __endpos
0000D0BC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0BC =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0BC =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0BC =0000003C                M 	__midpos:	= __endpos
0000D0BC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0BC                          M 	pushp	"move.l a7,-(sp)"
0000D0BC =00000002                M 	__stack:	= __stack+1
0000D0BC =00000008                M 	__sp:	= __sp+4
0000D0BC =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0BC                          M 	rept	__stack
0000D0BC                          M 	popp	__command
0000D0BC 2F0F                     M 	move.l	a7,-(sp)
0000D0BE                          M 	popp	__command
0000D0BE 2F07                     M 	move.l	d7,-(sp)
0000D0C0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D0C4 45EF 0010                M 	lea	4*4(sp),a2
0000D0C8 43FA 0000                M 	lea	.str_298(pc),a1
0000D0CC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D0D2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D0D6 504F                     M 	addq.w	#__sp,sp
0000D0D8 46DF                     M 	move.w	(sp)+,sr
0000D0DA 6000 0000                M 	bra.w	.instr_end_298
0000D0DE                          M 	.str_298:
0000D0DE                          M 	__fstring_generatedecodedstring	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0DE =00000001                M 	__lpos:	set 1
0000D0DE =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0DE                          M 	while	(__pos)
0000D0DE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0DE 2020                     M 	dc.b	"  "
0000D0E0 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0E0 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0E0 =0000000A                M 	__midpos:	= __endpos
0000D0E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E0 E8                       M 	dc.b	fpal0
0000D0E1 =0000000B                M 	__lpos:	set __endpos+1
0000D0E1 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0E1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E1 6437 3A20                M 	dc.b	"d7: "
0000D0E5 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0E5 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0E5 =00000016                M 	__midpos:	= __endpos
0000D0E5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E5                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E5 EC                       M 	dc.b	fpal2
0000D0E6 =00000017                M 	__lpos:	set __endpos+1
0000D0E6 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0E6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E6                          M 	dc.b	""
0000D0E6 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0E6 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0E6 =0000001E                M 	__midpos:	= __endpos
0000D0E6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E6                          M 	__param:	substr ,,"hex"
0000D0E6 83                       M 	dc.b	hex|3
0000D0E7 =0000001F                M 	__lpos:	set __endpos+1
0000D0E7 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0E7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E7 2020                     M 	dc.b	"  "
0000D0E9 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0E9 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0E9 =00000028                M 	__midpos:	= __endpos
0000D0E9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E9                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0E9 E8                       M 	dc.b	fpal0
0000D0EA =00000029                M 	__lpos:	set __endpos+1
0000D0EA =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0EA                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0EA 7370 3A20                M 	dc.b	"sp: "
0000D0EE =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0EE =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0EE =00000034                M 	__midpos:	= __endpos
0000D0EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0EE EC                       M 	dc.b	fpal2
0000D0EF =00000035                M 	__lpos:	set __endpos+1
0000D0EF =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0EF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0EF                          M 	dc.b	""
0000D0EF =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D0EF =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D0EF =0000003C                M 	__midpos:	= __endpos
0000D0EF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0EF                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0EF                          M 	__param:	substr ,,"hex"
0000D0EF 83                       M 	dc.b	hex|3
0000D0F0 =0000003D                M 	__lpos:	set __endpos+1
0000D0F0 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D0F0                          M 	__substr:	substr __lpos,,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D0F0                          M 	dc.b	""
0000D0F0 00                       M 	dc.b	0
0000D0F2 00                       M 	even
0000D0F2                          M 	.instr_end_298:
0000D0F2                            	Console.BreakLine
0000D0F2 40E7                     M 	move.w	sr,-(sp)
0000D0F4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D0FA 46DF                     M 	move.w	(sp)+,sr
0000D0FC                            
0000D0FC                            	Console.Write "%<fpal1>Channel: %<fpal0>"
0000D0FC 40E7                     M 	move.w	sr,-(sp)
0000D0FE                          M 	__fstring_generateargumentscode	"%<fpal1>Channel: %<fpal0>"
0000D0FE =00000001                M 	__pos:	set instr("%<fpal1>Channel: %<fpal0>",'%<')
0000D0FE =00000000                M 	__stack:set	0
0000D0FE =00000000                M 	__sp:	set 0
0000D0FE                          M 	while	(__pos)
0000D0FE =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D0FE =00000011                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D0FE =00000008                M 	__midpos:	= __endpos
0000D0FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D0FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D0FE =00000012                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D0FE =00000019                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D0FE =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D0FE =00000019                M 	__midpos:	= __endpos
0000D0FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D0FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D0FE =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D0FE                          M 	rept	__stack
0000D0FE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D102 43FA 0000                M 	lea	.str_302(pc),a1
0000D106 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D10C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D110 46DF                     M 	move.w	(sp)+,sr
0000D112 6000 0000                M 	bra.w	.instr_end_302
0000D116                          M 	.str_302:
0000D116                          M 	__fstring_generatedecodedstring	"%<fpal1>Channel: %<fpal0>"
0000D116 =00000001                M 	__lpos:	set 1
0000D116 =00000001                M 	__pos:	set instr("%<fpal1>Channel: %<fpal0>",'%<')
0000D116                          M 	while	(__pos)
0000D116                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Channel: %<fpal0>"
0000D116                          M 	dc.b	""
0000D116 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D116 =00000011                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D116 =00000008                M 	__midpos:	= __endpos
0000D116                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D116                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D116 EA                       M 	dc.b	fpal1
0000D117 =00000009                M 	__lpos:	set __endpos+1
0000D117 =00000012                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D117                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Channel: %<fpal0>"
0000D117 4368 616E 6E65 6C3A 20   M 	dc.b	"Channel: "
0000D120 =00000019                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D120 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D120 =00000019                M 	__midpos:	= __endpos
0000D120                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D120                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D120 E8                       M 	dc.b	fpal0
0000D121 =0000001A                M 	__lpos:	set __endpos+1
0000D121 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D121                          M 	__substr:	substr __lpos,,"%<fpal1>Channel: %<fpal0>"
0000D121                          M 	dc.b	""
0000D121 00                       M 	dc.b	0
0000D122                          M 	even
0000D122                          M 	.instr_end_302:
0000D122                            	AMPS_Debug_GetChannel
0000D122 BAFC C5F8                M 	cmp.w	#mpsg1,a5
0000D126 6600                     M 	bne.s	amps_debug_writepsg2
0000D128                          M 	console.write	"PSG1"
0000D128 40E7                     M 	move.w	sr,-(sp)
0000D12A                          M 	__fstring_generateargumentscode	"PSG1"
0000D12A =00000000                M 	__pos:	set instr("PSG1",'%<')
0000D12A =00000000                M 	__stack:set	0
0000D12A =00000000                M 	__sp:	set 0
0000D12A                          M 	while	(__pos)
0000D12A                          M 	rept	__stack
0000D12A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D12E 43FA 0000                M 	lea	.str_306(pc),a1
0000D132 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D138 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D13C 46DF                     M 	move.w	(sp)+,sr
0000D13E 6000 0000                M 	bra.w	.instr_end_306
0000D142                          M 	.str_306:
0000D142                          M 	__fstring_generatedecodedstring	"PSG1"
0000D142 =00000001                M 	__lpos:	set 1
0000D142 =00000000                M 	__pos:	set instr("PSG1",'%<')
0000D142                          M 	while	(__pos)
0000D142                          M 	__substr:	substr __lpos,,"PSG1"
0000D142 5053 4731                M 	dc.b	"PSG1"
0000D146 00                       M 	dc.b	0
0000D148 00                       M 	even
0000D148                          M 	.instr_end_306:
0000D148 6000 0000                M 	bra.w	amps_debug_writeend
0000D14C                          M amps_debug_writepsg2
0000D14C BAFC C624                M 	cmp.w	#mpsg2,a5
0000D150 6600                     M 	bne.s	amps_debug_writepsg3
0000D152                          M 	console.write	"PSG2"
0000D152 40E7                     M 	move.w	sr,-(sp)
0000D154                          M 	__fstring_generateargumentscode	"PSG2"
0000D154 =00000000                M 	__pos:	set instr("PSG2",'%<')
0000D154 =00000000                M 	__stack:set	0
0000D154 =00000000                M 	__sp:	set 0
0000D154                          M 	while	(__pos)
0000D154                          M 	rept	__stack
0000D154 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D158 43FA 0000                M 	lea	.str_309(pc),a1
0000D15C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D162 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D166 46DF                     M 	move.w	(sp)+,sr
0000D168 6000 0000                M 	bra.w	.instr_end_309
0000D16C                          M 	.str_309:
0000D16C                          M 	__fstring_generatedecodedstring	"PSG2"
0000D16C =00000001                M 	__lpos:	set 1
0000D16C =00000000                M 	__pos:	set instr("PSG2",'%<')
0000D16C                          M 	while	(__pos)
0000D16C                          M 	__substr:	substr __lpos,,"PSG2"
0000D16C 5053 4732                M 	dc.b	"PSG2"
0000D170 00                       M 	dc.b	0
0000D172 00                       M 	even
0000D172                          M 	.instr_end_309:
0000D172 6000 0000                M 	bra.w	amps_debug_writeend
0000D176                          M amps_debug_writepsg3
0000D176 BAFC C650                M 	cmp.w	#mpsg3,a5
0000D17A 6600                     M 	bne.s	amps_debug_writepsgs1
0000D17C                          M 	console.write	"PSG3"
0000D17C 40E7                     M 	move.w	sr,-(sp)
0000D17E                          M 	__fstring_generateargumentscode	"PSG3"
0000D17E =00000000                M 	__pos:	set instr("PSG3",'%<')
0000D17E =00000000                M 	__stack:set	0
0000D17E =00000000                M 	__sp:	set 0
0000D17E                          M 	while	(__pos)
0000D17E                          M 	rept	__stack
0000D17E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D182 43FA 0000                M 	lea	.str_312(pc),a1
0000D186 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D18C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D190 46DF                     M 	move.w	(sp)+,sr
0000D192 6000 0000                M 	bra.w	.instr_end_312
0000D196                          M 	.str_312:
0000D196                          M 	__fstring_generatedecodedstring	"PSG3"
0000D196 =00000001                M 	__lpos:	set 1
0000D196 =00000000                M 	__pos:	set instr("PSG3",'%<')
0000D196                          M 	while	(__pos)
0000D196                          M 	__substr:	substr __lpos,,"PSG3"
0000D196 5053 4733                M 	dc.b	"PSG3"
0000D19A 00                       M 	dc.b	0
0000D19C 00                       M 	even
0000D19C                          M 	.instr_end_312:
0000D19C 6000 0000                M 	bra.w	amps_debug_writeend
0000D1A0                          M amps_debug_writepsgs1
0000D1A0 BAFC C6EC                M 	cmp.w	#msfxpsg1,a5
0000D1A4 6600                     M 	bne.s	amps_debug_writepsgs2
0000D1A6                          M 	console.write	"SFX PSG1"
0000D1A6 40E7                     M 	move.w	sr,-(sp)
0000D1A8                          M 	__fstring_generateargumentscode	"SFX PSG1"
0000D1A8 =00000000                M 	__pos:	set instr("SFX PSG1",'%<')
0000D1A8 =00000000                M 	__stack:set	0
0000D1A8 =00000000                M 	__sp:	set 0
0000D1A8                          M 	while	(__pos)
0000D1A8                          M 	rept	__stack
0000D1A8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D1AC 43FA 0000                M 	lea	.str_315(pc),a1
0000D1B0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D1B6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D1BA 46DF                     M 	move.w	(sp)+,sr
0000D1BC 6000 0000                M 	bra.w	.instr_end_315
0000D1C0                          M 	.str_315:
0000D1C0                          M 	__fstring_generatedecodedstring	"SFX PSG1"
0000D1C0 =00000001                M 	__lpos:	set 1
0000D1C0 =00000000                M 	__pos:	set instr("SFX PSG1",'%<')
0000D1C0                          M 	while	(__pos)
0000D1C0                          M 	__substr:	substr __lpos,,"SFX PSG1"
0000D1C0 5346 5820 5053 4731      M 	dc.b	"SFX PSG1"
0000D1C8 00                       M 	dc.b	0
0000D1CA 00                       M 	even
0000D1CA                          M 	.instr_end_315:
0000D1CA 6000 0000                M 	bra.w	amps_debug_writeend
0000D1CE                          M amps_debug_writepsgs2
0000D1CE BAFC C708                M 	cmp.w	#msfxpsg2,a5
0000D1D2 6600                     M 	bne.s	amps_debug_writepsgs3
0000D1D4                          M 	console.write	"SFX PSG2"
0000D1D4 40E7                     M 	move.w	sr,-(sp)
0000D1D6                          M 	__fstring_generateargumentscode	"SFX PSG2"
0000D1D6 =00000000                M 	__pos:	set instr("SFX PSG2",'%<')
0000D1D6 =00000000                M 	__stack:set	0
0000D1D6 =00000000                M 	__sp:	set 0
0000D1D6                          M 	while	(__pos)
0000D1D6                          M 	rept	__stack
0000D1D6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D1DA 43FA 0000                M 	lea	.str_318(pc),a1
0000D1DE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D1E4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D1E8 46DF                     M 	move.w	(sp)+,sr
0000D1EA 6000 0000                M 	bra.w	.instr_end_318
0000D1EE                          M 	.str_318:
0000D1EE                          M 	__fstring_generatedecodedstring	"SFX PSG2"
0000D1EE =00000001                M 	__lpos:	set 1
0000D1EE =00000000                M 	__pos:	set instr("SFX PSG2",'%<')
0000D1EE                          M 	while	(__pos)
0000D1EE                          M 	__substr:	substr __lpos,,"SFX PSG2"
0000D1EE 5346 5820 5053 4732      M 	dc.b	"SFX PSG2"
0000D1F6 00                       M 	dc.b	0
0000D1F8 00                       M 	even
0000D1F8                          M 	.instr_end_318:
0000D1F8 6000 0000                M 	bra.w	amps_debug_writeend
0000D1FC                          M amps_debug_writepsgs3
0000D1FC BAFC C724                M 	cmp.w	#msfxpsg3,a5
0000D200 6600                     M 	bne.s	amps_debug_writedacs1
0000D202                          M 	console.write	"SFX PSG3"
0000D202 40E7                     M 	move.w	sr,-(sp)
0000D204                          M 	__fstring_generateargumentscode	"SFX PSG3"
0000D204 =00000000                M 	__pos:	set instr("SFX PSG3",'%<')
0000D204 =00000000                M 	__stack:set	0
0000D204 =00000000                M 	__sp:	set 0
0000D204                          M 	while	(__pos)
0000D204                          M 	rept	__stack
0000D204 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D208 43FA 0000                M 	lea	.str_321(pc),a1
0000D20C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D212 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D216 46DF                     M 	move.w	(sp)+,sr
0000D218 6000 0000                M 	bra.w	.instr_end_321
0000D21C                          M 	.str_321:
0000D21C                          M 	__fstring_generatedecodedstring	"SFX PSG3"
0000D21C =00000001                M 	__lpos:	set 1
0000D21C =00000000                M 	__pos:	set instr("SFX PSG3",'%<')
0000D21C                          M 	while	(__pos)
0000D21C                          M 	__substr:	substr __lpos,,"SFX PSG3"
0000D21C 5346 5820 5053 4733      M 	dc.b	"SFX PSG3"
0000D224 00                       M 	dc.b	0
0000D226 00                       M 	even
0000D226                          M 	.instr_end_321:
0000D226 6000 0000                M 	bra.w	amps_debug_writeend
0000D22A                          M amps_debug_writedacs1
0000D22A BAFC C67C                M 	cmp.w	#msfxdac1,a5
0000D22E 6600                     M 	bne.s	amps_debug_writedac1
0000D230                          M 	console.write	"SFX DAC1"
0000D230 40E7                     M 	move.w	sr,-(sp)
0000D232                          M 	__fstring_generateargumentscode	"SFX DAC1"
0000D232 =00000000                M 	__pos:	set instr("SFX DAC1",'%<')
0000D232 =00000000                M 	__stack:set	0
0000D232 =00000000                M 	__sp:	set 0
0000D232                          M 	while	(__pos)
0000D232                          M 	rept	__stack
0000D232 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D236 43FA 0000                M 	lea	.str_324(pc),a1
0000D23A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D240 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D244 46DF                     M 	move.w	(sp)+,sr
0000D246 6000 0000                M 	bra.w	.instr_end_324
0000D24A                          M 	.str_324:
0000D24A                          M 	__fstring_generatedecodedstring	"SFX DAC1"
0000D24A =00000001                M 	__lpos:	set 1
0000D24A =00000000                M 	__pos:	set instr("SFX DAC1",'%<')
0000D24A                          M 	while	(__pos)
0000D24A                          M 	__substr:	substr __lpos,,"SFX DAC1"
0000D24A 5346 5820 4441 4331      M 	dc.b	"SFX DAC1"
0000D252 00                       M 	dc.b	0
0000D254 00                       M 	even
0000D254                          M 	.instr_end_324:
0000D254 6000 0000                M 	bra.w	amps_debug_writeend
0000D258                          M amps_debug_writedac1
0000D258 BAFC C4C4                M 	cmp.w	#mdac1,a5
0000D25C 6600                     M 	bne.s	amps_debug_writedac2
0000D25E                          M 	console.write	"DAC1"
0000D25E 40E7                     M 	move.w	sr,-(sp)
0000D260                          M 	__fstring_generateargumentscode	"DAC1"
0000D260 =00000000                M 	__pos:	set instr("DAC1",'%<')
0000D260 =00000000                M 	__stack:set	0
0000D260 =00000000                M 	__sp:	set 0
0000D260                          M 	while	(__pos)
0000D260                          M 	rept	__stack
0000D260 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D264 43FA 0000                M 	lea	.str_327(pc),a1
0000D268 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D26E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D272 46DF                     M 	move.w	(sp)+,sr
0000D274 6000 0000                M 	bra.w	.instr_end_327
0000D278                          M 	.str_327:
0000D278                          M 	__fstring_generatedecodedstring	"DAC1"
0000D278 =00000001                M 	__lpos:	set 1
0000D278 =00000000                M 	__pos:	set instr("DAC1",'%<')
0000D278                          M 	while	(__pos)
0000D278                          M 	__substr:	substr __lpos,,"DAC1"
0000D278 4441 4331                M 	dc.b	"DAC1"
0000D27C 00                       M 	dc.b	0
0000D27E 00                       M 	even
0000D27E                          M 	.instr_end_327:
0000D27E 6000 0000                M 	bra.w	amps_debug_writeend
0000D282                          M amps_debug_writedac2
0000D282 BAFC C4F0                M 	cmp.w	#mdac2,a5
0000D286 6600                     M 	bne.s	amps_debug_writefm1
0000D288                          M 	console.write	"DAC2"
0000D288 40E7                     M 	move.w	sr,-(sp)
0000D28A                          M 	__fstring_generateargumentscode	"DAC2"
0000D28A =00000000                M 	__pos:	set instr("DAC2",'%<')
0000D28A =00000000                M 	__stack:set	0
0000D28A =00000000                M 	__sp:	set 0
0000D28A                          M 	while	(__pos)
0000D28A                          M 	rept	__stack
0000D28A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D28E 43FA 0000                M 	lea	.str_330(pc),a1
0000D292 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D298 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D29C 46DF                     M 	move.w	(sp)+,sr
0000D29E 6000 0000                M 	bra.w	.instr_end_330
0000D2A2                          M 	.str_330:
0000D2A2                          M 	__fstring_generatedecodedstring	"DAC2"
0000D2A2 =00000001                M 	__lpos:	set 1
0000D2A2 =00000000                M 	__pos:	set instr("DAC2",'%<')
0000D2A2                          M 	while	(__pos)
0000D2A2                          M 	__substr:	substr __lpos,,"DAC2"
0000D2A2 4441 4332                M 	dc.b	"DAC2"
0000D2A6 00                       M 	dc.b	0
0000D2A8 00                       M 	even
0000D2A8                          M 	.instr_end_330:
0000D2A8 6000 0000                M 	bra.w	amps_debug_writeend
0000D2AC                          M amps_debug_writefm1
0000D2AC BAFC C51C                M 	cmp.w	#mfm1,a5
0000D2B0 6600                     M 	bne.s	amps_debug_writefm2
0000D2B2                          M 	console.write	"FM1"
0000D2B2 40E7                     M 	move.w	sr,-(sp)
0000D2B4                          M 	__fstring_generateargumentscode	"FM1"
0000D2B4 =00000000                M 	__pos:	set instr("FM1",'%<')
0000D2B4 =00000000                M 	__stack:set	0
0000D2B4 =00000000                M 	__sp:	set 0
0000D2B4                          M 	while	(__pos)
0000D2B4                          M 	rept	__stack
0000D2B4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D2B8 43FA 0000                M 	lea	.str_333(pc),a1
0000D2BC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D2C2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D2C6 46DF                     M 	move.w	(sp)+,sr
0000D2C8 6000 0000                M 	bra.w	.instr_end_333
0000D2CC                          M 	.str_333:
0000D2CC                          M 	__fstring_generatedecodedstring	"FM1"
0000D2CC =00000001                M 	__lpos:	set 1
0000D2CC =00000000                M 	__pos:	set instr("FM1",'%<')
0000D2CC                          M 	while	(__pos)
0000D2CC                          M 	__substr:	substr __lpos,,"FM1"
0000D2CC 464D 31                  M 	dc.b	"FM1"
0000D2CF 00                       M 	dc.b	0
0000D2D0                          M 	even
0000D2D0                          M 	.instr_end_333:
0000D2D0 6000 0000                M 	bra.w	amps_debug_writeend
0000D2D4                          M amps_debug_writefm2
0000D2D4 BAFC C548                M 	cmp.w	#mfm2,a5
0000D2D8 6600                     M 	bne.s	amps_debug_writefm3
0000D2DA                          M 	console.write	"FM2"
0000D2DA 40E7                     M 	move.w	sr,-(sp)
0000D2DC                          M 	__fstring_generateargumentscode	"FM2"
0000D2DC =00000000                M 	__pos:	set instr("FM2",'%<')
0000D2DC =00000000                M 	__stack:set	0
0000D2DC =00000000                M 	__sp:	set 0
0000D2DC                          M 	while	(__pos)
0000D2DC                          M 	rept	__stack
0000D2DC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D2E0 43FA 0000                M 	lea	.str_336(pc),a1
0000D2E4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D2EA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D2EE 46DF                     M 	move.w	(sp)+,sr
0000D2F0 6000 0000                M 	bra.w	.instr_end_336
0000D2F4                          M 	.str_336:
0000D2F4                          M 	__fstring_generatedecodedstring	"FM2"
0000D2F4 =00000001                M 	__lpos:	set 1
0000D2F4 =00000000                M 	__pos:	set instr("FM2",'%<')
0000D2F4                          M 	while	(__pos)
0000D2F4                          M 	__substr:	substr __lpos,,"FM2"
0000D2F4 464D 32                  M 	dc.b	"FM2"
0000D2F7 00                       M 	dc.b	0
0000D2F8                          M 	even
0000D2F8                          M 	.instr_end_336:
0000D2F8 6000 0000                M 	bra.w	amps_debug_writeend
0000D2FC                          M amps_debug_writefm3
0000D2FC BAFC C574                M 	cmp.w	#mfm3,a5
0000D300 6600                     M 	bne.s	amps_debug_writefm4
0000D302                          M 	console.write	"FM3"
0000D302 40E7                     M 	move.w	sr,-(sp)
0000D304                          M 	__fstring_generateargumentscode	"FM3"
0000D304 =00000000                M 	__pos:	set instr("FM3",'%<')
0000D304 =00000000                M 	__stack:set	0
0000D304 =00000000                M 	__sp:	set 0
0000D304                          M 	while	(__pos)
0000D304                          M 	rept	__stack
0000D304 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D308 43FA 0000                M 	lea	.str_339(pc),a1
0000D30C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D312 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D316 46DF                     M 	move.w	(sp)+,sr
0000D318 6000 0000                M 	bra.w	.instr_end_339
0000D31C                          M 	.str_339:
0000D31C                          M 	__fstring_generatedecodedstring	"FM3"
0000D31C =00000001                M 	__lpos:	set 1
0000D31C =00000000                M 	__pos:	set instr("FM3",'%<')
0000D31C                          M 	while	(__pos)
0000D31C                          M 	__substr:	substr __lpos,,"FM3"
0000D31C 464D 33                  M 	dc.b	"FM3"
0000D31F 00                       M 	dc.b	0
0000D320                          M 	even
0000D320                          M 	.instr_end_339:
0000D320 6000 0000                M 	bra.w	amps_debug_writeend
0000D324                          M amps_debug_writefm4
0000D324 BAFC C5A0                M 	cmp.w	#mfm4,a5
0000D328 6600                     M 	bne.s	amps_debug_writefm5
0000D32A                          M 	console.write	"FM4"
0000D32A 40E7                     M 	move.w	sr,-(sp)
0000D32C                          M 	__fstring_generateargumentscode	"FM4"
0000D32C =00000000                M 	__pos:	set instr("FM4",'%<')
0000D32C =00000000                M 	__stack:set	0
0000D32C =00000000                M 	__sp:	set 0
0000D32C                          M 	while	(__pos)
0000D32C                          M 	rept	__stack
0000D32C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D330 43FA 0000                M 	lea	.str_342(pc),a1
0000D334 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D33A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D33E 46DF                     M 	move.w	(sp)+,sr
0000D340 6000 0000                M 	bra.w	.instr_end_342
0000D344                          M 	.str_342:
0000D344                          M 	__fstring_generatedecodedstring	"FM4"
0000D344 =00000001                M 	__lpos:	set 1
0000D344 =00000000                M 	__pos:	set instr("FM4",'%<')
0000D344                          M 	while	(__pos)
0000D344                          M 	__substr:	substr __lpos,,"FM4"
0000D344 464D 34                  M 	dc.b	"FM4"
0000D347 00                       M 	dc.b	0
0000D348                          M 	even
0000D348                          M 	.instr_end_342:
0000D348 6000 0000                M 	bra.w	amps_debug_writeend
0000D34C                          M amps_debug_writefm5
0000D34C BAFC C5CC                M 	cmp.w	#mfm5,a5
0000D350 6600                     M 	bne.s	amps_debug_writefms3
0000D352                          M 	console.write	"FM5"
0000D352 40E7                     M 	move.w	sr,-(sp)
0000D354                          M 	__fstring_generateargumentscode	"FM5"
0000D354 =00000000                M 	__pos:	set instr("FM5",'%<')
0000D354 =00000000                M 	__stack:set	0
0000D354 =00000000                M 	__sp:	set 0
0000D354                          M 	while	(__pos)
0000D354                          M 	rept	__stack
0000D354 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D358 43FA 0000                M 	lea	.str_345(pc),a1
0000D35C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D362 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D366 46DF                     M 	move.w	(sp)+,sr
0000D368 6000 0000                M 	bra.w	.instr_end_345
0000D36C                          M 	.str_345:
0000D36C                          M 	__fstring_generatedecodedstring	"FM5"
0000D36C =00000001                M 	__lpos:	set 1
0000D36C =00000000                M 	__pos:	set instr("FM5",'%<')
0000D36C                          M 	while	(__pos)
0000D36C                          M 	__substr:	substr __lpos,,"FM5"
0000D36C 464D 35                  M 	dc.b	"FM5"
0000D36F 00                       M 	dc.b	0
0000D370                          M 	even
0000D370                          M 	.instr_end_345:
0000D370 6000 0000                M 	bra.w	amps_debug_writeend
0000D374                          M amps_debug_writefms3
0000D374 BAFC C698                M 	cmp.w	#msfxfm3,a5
0000D378 6600                     M 	bne.s	amps_debug_writefms4
0000D37A                          M 	console.write	"SFX FM3"
0000D37A 40E7                     M 	move.w	sr,-(sp)
0000D37C                          M 	__fstring_generateargumentscode	"SFX FM3"
0000D37C =00000000                M 	__pos:	set instr("SFX FM3",'%<')
0000D37C =00000000                M 	__stack:set	0
0000D37C =00000000                M 	__sp:	set 0
0000D37C                          M 	while	(__pos)
0000D37C                          M 	rept	__stack
0000D37C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D380 43FA 0000                M 	lea	.str_348(pc),a1
0000D384 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D38A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D38E 46DF                     M 	move.w	(sp)+,sr
0000D390 6000 0000                M 	bra.w	.instr_end_348
0000D394                          M 	.str_348:
0000D394                          M 	__fstring_generatedecodedstring	"SFX FM3"
0000D394 =00000001                M 	__lpos:	set 1
0000D394 =00000000                M 	__pos:	set instr("SFX FM3",'%<')
0000D394                          M 	while	(__pos)
0000D394                          M 	__substr:	substr __lpos,,"SFX FM3"
0000D394 5346 5820 464D 33        M 	dc.b	"SFX FM3"
0000D39B 00                       M 	dc.b	0
0000D39C                          M 	even
0000D39C                          M 	.instr_end_348:
0000D39C 4E75                     M 	rts
0000D39E                          M amps_debug_writefms4
0000D39E BAFC C6B4                M 	cmp.w	#msfxfm4,a5
0000D3A2 6600                     M 	bne.s	amps_debug_writefms5
0000D3A4                          M 	console.write	"SFX FM4"
0000D3A4 40E7                     M 	move.w	sr,-(sp)
0000D3A6                          M 	__fstring_generateargumentscode	"SFX FM4"
0000D3A6 =00000000                M 	__pos:	set instr("SFX FM4",'%<')
0000D3A6 =00000000                M 	__stack:set	0
0000D3A6 =00000000                M 	__sp:	set 0
0000D3A6                          M 	while	(__pos)
0000D3A6                          M 	rept	__stack
0000D3A6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D3AA 43FA 0000                M 	lea	.str_351(pc),a1
0000D3AE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D3B4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D3B8 46DF                     M 	move.w	(sp)+,sr
0000D3BA 6000 0000                M 	bra.w	.instr_end_351
0000D3BE                          M 	.str_351:
0000D3BE                          M 	__fstring_generatedecodedstring	"SFX FM4"
0000D3BE =00000001                M 	__lpos:	set 1
0000D3BE =00000000                M 	__pos:	set instr("SFX FM4",'%<')
0000D3BE                          M 	while	(__pos)
0000D3BE                          M 	__substr:	substr __lpos,,"SFX FM4"
0000D3BE 5346 5820 464D 34        M 	dc.b	"SFX FM4"
0000D3C5 00                       M 	dc.b	0
0000D3C6                          M 	even
0000D3C6                          M 	.instr_end_351:
0000D3C6 6000                     M 	bra.s	amps_debug_writeend
0000D3C8                          M amps_debug_writefms5
0000D3C8 BAFC C6D0                M 	cmp.w	#msfxfm5,a5
0000D3CC 6700                     M 	beq.s	amps_debug_writefms5_
0000D3CE                          M amps_debug_writeaddr
0000D3CE                          M 	console.write	"%<fpal2>%<.l a5>"
0000D3CE 40E7                     M 	move.w	sr,-(sp)
0000D3D0                          M 	__fstring_generateargumentscode	"%<fpal2>%<.l a5>"
0000D3D0 =00000001                M 	__pos:	set instr("%<fpal2>%<.l a5>",'%<')
0000D3D0 =00000000                M 	__stack:set	0
0000D3D0 =00000000                M 	__sp:	set 0
0000D3D0                          M 	while	(__pos)
0000D3D0 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D3D0 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D3D0 =00000008                M 	__midpos:	= __endpos
0000D3D0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D3D0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D3D0 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D3D0 =00000010                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D3D0 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D3D0 =00000010                M 	__midpos:	= __endpos
0000D3D0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D3D0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D3D0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal2>%<.l a5>"
0000D3D0                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D3D0                          M 	pushp	"move.l a5,-(sp)"
0000D3D0 =00000001                M 	__stack:	= __stack+1
0000D3D0 =00000004                M 	__sp:	= __sp+4
0000D3D0 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D3D0                          M 	rept	__stack
0000D3D0                          M 	popp	__command
0000D3D0 2F0D                     M 	move.l	a5,-(sp)
0000D3D2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D3D6 45EF 0010                M 	lea	4*4(sp),a2
0000D3DA 43FA 0000                M 	lea	.str_354(pc),a1
0000D3DE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D3E4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D3E8 584F                     M 	addq.w	#__sp,sp
0000D3EA 46DF                     M 	move.w	(sp)+,sr
0000D3EC 6000 0000                M 	bra.w	.instr_end_354
0000D3F0                          M 	.str_354:
0000D3F0                          M 	__fstring_generatedecodedstring	"%<fpal2>%<.l a5>"
0000D3F0 =00000001                M 	__lpos:	set 1
0000D3F0 =00000001                M 	__pos:	set instr("%<fpal2>%<.l a5>",'%<')
0000D3F0                          M 	while	(__pos)
0000D3F0                          M 	__substr:	substr __lpos,__pos-1,"%<fpal2>%<.l a5>"
0000D3F0                          M 	dc.b	""
0000D3F0 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D3F0 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D3F0 =00000008                M 	__midpos:	= __endpos
0000D3F0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D3F0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D3F0 EC                       M 	dc.b	fpal2
0000D3F1 =00000009                M 	__lpos:	set __endpos+1
0000D3F1 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D3F1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal2>%<.l a5>"
0000D3F1                          M 	dc.b	""
0000D3F1 =00000010                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D3F1 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D3F1 =00000010                M 	__midpos:	= __endpos
0000D3F1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D3F1                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D3F1                          M 	__param:	substr ,,"hex"
0000D3F1 83                       M 	dc.b	hex|3
0000D3F2 =00000011                M 	__lpos:	set __endpos+1
0000D3F2 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D3F2                          M 	__substr:	substr __lpos,,"%<fpal2>%<.l a5>"
0000D3F2                          M 	dc.b	""
0000D3F2 00                       M 	dc.b	0
0000D3F4 00                       M 	even
0000D3F4                          M 	.instr_end_354:
0000D3F4 4E75                     M 	rts
0000D3F6                          M amps_debug_writefms5_
0000D3F6                          M 	console.write	"SFX FM5"
0000D3F6 40E7                     M 	move.w	sr,-(sp)
0000D3F8                          M 	__fstring_generateargumentscode	"SFX FM5"
0000D3F8 =00000000                M 	__pos:	set instr("SFX FM5",'%<')
0000D3F8 =00000000                M 	__stack:set	0
0000D3F8 =00000000                M 	__sp:	set 0
0000D3F8                          M 	while	(__pos)
0000D3F8                          M 	rept	__stack
0000D3F8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D3FC 43FA 0000                M 	lea	.str_357(pc),a1
0000D400 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D406 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D40A 46DF                     M 	move.w	(sp)+,sr
0000D40C 6000 0000                M 	bra.w	.instr_end_357
0000D410                          M 	.str_357:
0000D410                          M 	__fstring_generatedecodedstring	"SFX FM5"
0000D410 =00000001                M 	__lpos:	set 1
0000D410 =00000000                M 	__pos:	set instr("SFX FM5",'%<')
0000D410                          M 	while	(__pos)
0000D410                          M 	__substr:	substr __lpos,,"SFX FM5"
0000D410 5346 5820 464D 35        M 	dc.b	"SFX FM5"
0000D417 00                       M 	dc.b	0
0000D418                          M 	even
0000D418                          M 	.instr_end_357:
0000D418                          M amps_debug_writeend
0000D418                            	Console.BreakLine
0000D418 40E7                     M 	move.w	sr,-(sp)
0000D41A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D420 46DF                     M 	move.w	(sp)+,sr
0000D422                            
0000D422                            	Console.WriteLine "%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D422 40E7                     M 	move.w	sr,-(sp)
0000D424                          M 	__fstring_generateargumentscode	"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424 =00000001                M 	__pos:	set instr("%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D424 =00000000                M 	__stack:set	0
0000D424 =00000000                M 	__sp:	set 0
0000D424                          M 	while	(__pos)
0000D424 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D424 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D424 =00000008                M 	__midpos:	= __endpos
0000D424                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424 =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D424 =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D424 =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D424 =00000016                M 	__midpos:	= __endpos
0000D424                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424 =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D424 =00000029                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D424 =0000001E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D424                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424                          M 	pushp	"move.l a4,-(sp)"
0000D424 =00000001                M 	__stack:	= __stack+1
0000D424 =00000004                M 	__sp:	= __sp+4
0000D424 =0000002A                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D424 =0000003A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D424 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D424 =0000003A                M 	__midpos:	= __endpos
0000D424                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D424 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D424                          M 	rept	__stack
0000D424                          M 	popp	__command
0000D424 2F0C                     M 	move.l	a4,-(sp)
0000D426 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D42A 45EF 0010                M 	lea	4*4(sp),a2
0000D42E 43FA 0000                M 	lea	.str_361(pc),a1
0000D432 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D438 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D43C 584F                     M 	addq.w	#__sp,sp
0000D43E 46DF                     M 	move.w	(sp)+,sr
0000D440 6000 0000                M 	bra.w	.instr_end_361
0000D444                          M 	.str_361:
0000D444                          M 	__fstring_generatedecodedstring	"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D444 =00000001                M 	__lpos:	set 1
0000D444 =00000001                M 	__pos:	set instr("%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D444                          M 	while	(__pos)
0000D444                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D444                          M 	dc.b	""
0000D444 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D444 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D444 =00000008                M 	__midpos:	= __endpos
0000D444                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D444                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D444 EA                       M 	dc.b	fpal1
0000D445 =00000009                M 	__lpos:	set __endpos+1
0000D445 =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D445                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D445 4164 6472 3A20           M 	dc.b	"Addr: "
0000D44B =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D44B =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D44B =00000016                M 	__midpos:	= __endpos
0000D44B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D44B                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D44B E8                       M 	dc.b	fpal0
0000D44C =00000017                M 	__lpos:	set __endpos+1
0000D44C =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D44C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D44C                          M 	dc.b	""
0000D44C =00000029                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D44C =0000001E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D44C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D44C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D44C BB                       M 	dc.b	sym|fsplit|3
0000D44D =0000002A                M 	__lpos:	set __endpos+1
0000D44D =0000002A                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D44D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D44D                          M 	dc.b	""
0000D44D =0000003A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D44D =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D44D =0000003A                M 	__midpos:	= __endpos
0000D44D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D44D                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D44D ECC0                     M 	dc.b	fpal2,fsymdisp
0000D44F =0000003B                M 	__lpos:	set __endpos+1
0000D44F =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D44F                          M 	__substr:	substr __lpos,,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D44F                          M 	dc.b	""
0000D44F 00                       M 	dc.b	0
0000D450                          M 	even
0000D450                          M 	.instr_end_361:
0000D450                            ; fmt: flag, type, pan, det, pitch, vol, tick, sample/voice, dur, lastdur, freq
0000D450                            	Console.Write	  "%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D450 40E7                     M 	move.w	sr,-(sp)
0000D452                          M 	__fstring_generateargumentscode	"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452 =00000001                M 	__pos:	set instr("%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D452 =00000000                M 	__stack:set	0
0000D452 =00000000                M 	__sp:	set 0
0000D452                          M 	while	(__pos)
0000D452 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D452 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D452 =00000008                M 	__midpos:	= __endpos
0000D452                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452 =0000000D                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D452 =00000014                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D452 =00000019                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D452 =00000014                M 	__midpos:	= __endpos
0000D452                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452 =00000015                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D452 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D452 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D452 =0000001E                M 	__midpos:	= __endpos
0000D452                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	pushp	"move.b (a5),1(sp)"
0000D452                          M 	pushp	"subq.w	#2, sp"
0000D452 =00000002                M 	__stack:	= __stack+2
0000D452 =00000002                M 	__sp:	= __sp+2
0000D452 =00000020                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D452 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D452 =0000002F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D452 =0000002E                M 	__midpos:	= __endpos
0000D452                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	pushp	"move.b cType(a5),1(sp)"
0000D452                          M 	pushp	"subq.w	#2, sp"
0000D452 =00000004                M 	__stack:	= __stack+2
0000D452 =00000004                M 	__sp:	= __sp+2
0000D452 =00000030                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D452 =00000041                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D452 =00000042                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D452 =00000041                M 	__midpos:	= __endpos
0000D452                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D452                          M 	pushp	"move.b cPanning(a5),1(sp)"
0000D452                          M 	pushp	"subq.w	#2, sp"
0000D452 =00000006                M 	__stack:	= __stack+2
0000D452 =00000006                M 	__sp:	= __sp+2
0000D452 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D452                          M 	rept	__stack
0000D452                          M 	popp	__command
0000D452 554F                     M 	subq.w	#2,sp
0000D454                          M 	popp	__command
0000D454 1F6D 0006 0001           M 	move.b	cpanning(a5),1(sp)
0000D45A                          M 	popp	__command
0000D45A 554F                     M 	subq.w	#2,sp
0000D45C                          M 	popp	__command
0000D45C 1F6D 0001 0001           M 	move.b	ctype(a5),1(sp)
0000D462                          M 	popp	__command
0000D462 554F                     M 	subq.w	#2,sp
0000D464                          M 	popp	__command
0000D464 1F55 0001                M 	move.b	(a5),1(sp)
0000D468 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D46C 45EF 0010                M 	lea	4*4(sp),a2
0000D470 43FA 0000                M 	lea	.str_364(pc),a1
0000D474 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D47A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D47E 5C4F                     M 	addq.w	#__sp,sp
0000D480 46DF                     M 	move.w	(sp)+,sr
0000D482 6000 0000                M 	bra.w	.instr_end_364
0000D486                          M 	.str_364:
0000D486                          M 	__fstring_generatedecodedstring	"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D486 =00000001                M 	__lpos:	set 1
0000D486 =00000001                M 	__pos:	set instr("%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D486                          M 	while	(__pos)
0000D486                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D486                          M 	dc.b	""
0000D486 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D486 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D486 =00000008                M 	__midpos:	= __endpos
0000D486                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D486                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D486 EA                       M 	dc.b	fpal1
0000D487 =00000009                M 	__lpos:	set __endpos+1
0000D487 =0000000D                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D487                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D487 4348 3A20                M 	dc.b	"CH: "
0000D48B =00000014                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D48B =00000019                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D48B =00000014                M 	__midpos:	= __endpos
0000D48B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D48B                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D48B EC                       M 	dc.b	fpal2
0000D48C =00000015                M 	__lpos:	set __endpos+1
0000D48C =00000015                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D48C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D48C                          M 	dc.b	""
0000D48C =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D48C =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D48C =0000001E                M 	__midpos:	= __endpos
0000D48C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D48C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D48C                          M 	__param:	substr ,,"hex"
0000D48C 80                       M 	dc.b	hex
0000D48D =0000001F                M 	__lpos:	set __endpos+1
0000D48D =00000020                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D48D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D48D 20                       M 	dc.b	" "
0000D48E =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D48E =0000002F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D48E =0000002E                M 	__midpos:	= __endpos
0000D48E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D48E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D48E                          M 	__param:	substr ,,"hex"
0000D48E 80                       M 	dc.b	hex
0000D48F =0000002F                M 	__lpos:	set __endpos+1
0000D48F =00000030                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D48F                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D48F 20                       M 	dc.b	" "
0000D490 =00000041                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D490 =00000042                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D490 =00000041                M 	__midpos:	= __endpos
0000D490                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D490                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D490                          M 	__param:	substr ,,"hex"
0000D490 80                       M 	dc.b	hex
0000D491 =00000042                M 	__lpos:	set __endpos+1
0000D491 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D491                          M 	__substr:	substr __lpos,,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D491 20                       M 	dc.b	" "
0000D492 00                       M 	dc.b	0
0000D494 00                       M 	even
0000D494                          M 	.instr_end_364:
0000D494                            	Console.Write	  "%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D494 40E7                     M 	move.w	sr,-(sp)
0000D496                          M 	__fstring_generateargumentscode	"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496 =00000001                M 	__pos:	set instr("%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D496 =00000000                M 	__stack:set	0
0000D496 =00000000                M 	__sp:	set 0
0000D496                          M 	while	(__pos)
0000D496 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D496 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D496 =00000011                M 	__midpos:	= __endpos
0000D496                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	pushp	"move.b cDetune(a5),1(sp)"
0000D496                          M 	pushp	"subq.w	#2, sp"
0000D496 =00000002                M 	__stack:	= __stack+2
0000D496 =00000002                M 	__sp:	= __sp+2
0000D496 =00000013                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D496 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D496 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D496 =00000022                M 	__midpos:	= __endpos
0000D496                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	pushp	"move.b cPitch(a5),1(sp)"
0000D496                          M 	pushp	"subq.w	#2, sp"
0000D496 =00000004                M 	__stack:	= __stack+2
0000D496 =00000004                M 	__sp:	= __sp+2
0000D496 =00000024                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D496 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D496 =00000035                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D496 =00000034                M 	__midpos:	= __endpos
0000D496                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	pushp	"move.b cVolume(a5),1(sp)"
0000D496                          M 	pushp	"subq.w	#2, sp"
0000D496 =00000006                M 	__stack:	= __stack+2
0000D496 =00000006                M 	__sp:	= __sp+2
0000D496 =00000036                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D496 =00000044                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D496 =00000045                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D496 =00000044                M 	__midpos:	= __endpos
0000D496                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D496                          M 	pushp	"move.b cTick(a5),1(sp)"
0000D496                          M 	pushp	"subq.w	#2, sp"
0000D496 =00000008                M 	__stack:	= __stack+2
0000D496 =00000008                M 	__sp:	= __sp+2
0000D496 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D496                          M 	rept	__stack
0000D496                          M 	popp	__command
0000D496 554F                     M 	subq.w	#2,sp
0000D498                          M 	popp	__command
0000D498 1F6D 000A 0001           M 	move.b	ctick(a5),1(sp)
0000D49E                          M 	popp	__command
0000D49E 554F                     M 	subq.w	#2,sp
0000D4A0                          M 	popp	__command
0000D4A0 1F6D 0009 0001           M 	move.b	cvolume(a5),1(sp)
0000D4A6                          M 	popp	__command
0000D4A6 554F                     M 	subq.w	#2,sp
0000D4A8                          M 	popp	__command
0000D4A8 1F6D 0008 0001           M 	move.b	cpitch(a5),1(sp)
0000D4AE                          M 	popp	__command
0000D4AE 554F                     M 	subq.w	#2,sp
0000D4B0                          M 	popp	__command
0000D4B0 1F6D 0007 0001           M 	move.b	cdetune(a5),1(sp)
0000D4B6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D4BA 45EF 0010                M 	lea	4*4(sp),a2
0000D4BE 43FA 0000                M 	lea	.str_367(pc),a1
0000D4C2 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D4C8 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D4CC 504F                     M 	addq.w	#__sp,sp
0000D4CE 46DF                     M 	move.w	(sp)+,sr
0000D4D0 6000 0000                M 	bra.w	.instr_end_367
0000D4D4                          M 	.str_367:
0000D4D4                          M 	__fstring_generatedecodedstring	"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D4 =00000001                M 	__lpos:	set 1
0000D4D4 =00000001                M 	__pos:	set instr("%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D4D4                          M 	while	(__pos)
0000D4D4                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D4                          M 	dc.b	""
0000D4D4 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D4D4 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D4D4 =00000011                M 	__midpos:	= __endpos
0000D4D4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D4                          M 	__param:	substr ,,"hex"
0000D4D4 80                       M 	dc.b	hex
0000D4D5 =00000012                M 	__lpos:	set __endpos+1
0000D4D5 =00000013                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D4D5                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D5 20                       M 	dc.b	" "
0000D4D6 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D4D6 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D4D6 =00000022                M 	__midpos:	= __endpos
0000D4D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D6                          M 	__param:	substr ,,"hex"
0000D4D6 80                       M 	dc.b	hex
0000D4D7 =00000023                M 	__lpos:	set __endpos+1
0000D4D7 =00000024                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D4D7                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D7 20                       M 	dc.b	" "
0000D4D8 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D4D8 =00000035                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D4D8 =00000034                M 	__midpos:	= __endpos
0000D4D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D8                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D8                          M 	__param:	substr ,,"hex"
0000D4D8 80                       M 	dc.b	hex
0000D4D9 =00000035                M 	__lpos:	set __endpos+1
0000D4D9 =00000036                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D4D9                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4D9 20                       M 	dc.b	" "
0000D4DA =00000044                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D4DA =00000045                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D4DA =00000044                M 	__midpos:	= __endpos
0000D4DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4DA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4DA                          M 	__param:	substr ,,"hex"
0000D4DA 80                       M 	dc.b	hex
0000D4DB =00000045                M 	__lpos:	set __endpos+1
0000D4DB =00000000                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D4DB                          M 	__substr:	substr __lpos,,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D4DB 20                       M 	dc.b	" "
0000D4DC 00                       M 	dc.b	0
0000D4DE 00                       M 	even
0000D4DE                          M 	.instr_end_367:
0000D4DE                            	Console.WriteLine "%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4DE 40E7                     M 	move.w	sr,-(sp)
0000D4E0                          M 	__fstring_generateargumentscode	"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0 =00000001                M 	__pos:	set instr("%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D4E0 =00000000                M 	__stack:set	0
0000D4E0 =00000000                M 	__sp:	set 0
0000D4E0                          M 	while	(__pos)
0000D4E0 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D4E0 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D4E0 =00000011                M 	__midpos:	= __endpos
0000D4E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	pushp	"move.b cSample(a5),1(sp)"
0000D4E0                          M 	pushp	"subq.w	#2, sp"
0000D4E0 =00000002                M 	__stack:	= __stack+2
0000D4E0 =00000002                M 	__sp:	= __sp+2
0000D4E0 =00000013                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D4E0 =00000025                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D4E0 =00000026                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D4E0 =00000025                M 	__midpos:	= __endpos
0000D4E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	pushp	"move.b cDuration(a5),1(sp)"
0000D4E0                          M 	pushp	"subq.w	#2, sp"
0000D4E0 =00000004                M 	__stack:	= __stack+2
0000D4E0 =00000004                M 	__sp:	= __sp+2
0000D4E0 =00000027                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D4E0 =00000038                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D4E0 =00000039                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D4E0 =00000038                M 	__midpos:	= __endpos
0000D4E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	pushp	"move.b cLastDur(a5),1(sp)"
0000D4E0                          M 	pushp	"subq.w	#2, sp"
0000D4E0 =00000006                M 	__stack:	= __stack+2
0000D4E0 =00000006                M 	__sp:	= __sp+2
0000D4E0 =0000003A                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D4E0 =00000048                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D4E0 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D4E0 =00000048                M 	__midpos:	= __endpos
0000D4E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D4E0                          M 	pushp	"move.w cFreq(a5),-(sp)"
0000D4E0 =00000007                M 	__stack:	= __stack+1
0000D4E0 =00000008                M 	__sp:	= __sp+2
0000D4E0 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D4E0                          M 	rept	__stack
0000D4E0                          M 	popp	__command
0000D4E0 3F2D 000E                M 	move.w	cfreq(a5),-(sp)
0000D4E4                          M 	popp	__command
0000D4E4 554F                     M 	subq.w	#2,sp
0000D4E6                          M 	popp	__command
0000D4E6 1F6D 000D 0001           M 	move.b	clastdur(a5),1(sp)
0000D4EC                          M 	popp	__command
0000D4EC 554F                     M 	subq.w	#2,sp
0000D4EE                          M 	popp	__command
0000D4EE 1F6D 000C 0001           M 	move.b	cduration(a5),1(sp)
0000D4F4                          M 	popp	__command
0000D4F4 554F                     M 	subq.w	#2,sp
0000D4F6                          M 	popp	__command
0000D4F6 1F6D 000B 0001           M 	move.b	csample(a5),1(sp)
0000D4FC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D500 45EF 0010                M 	lea	4*4(sp),a2
0000D504 43FA 0000                M 	lea	.str_370(pc),a1
0000D508 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D50E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D512 504F                     M 	addq.w	#__sp,sp
0000D514 46DF                     M 	move.w	(sp)+,sr
0000D516 6000 0000                M 	bra.w	.instr_end_370
0000D51A                          M 	.str_370:
0000D51A                          M 	__fstring_generatedecodedstring	"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51A =00000001                M 	__lpos:	set 1
0000D51A =00000001                M 	__pos:	set instr("%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D51A                          M 	while	(__pos)
0000D51A                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51A                          M 	dc.b	""
0000D51A =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D51A =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D51A =00000011                M 	__midpos:	= __endpos
0000D51A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51A                          M 	__param:	substr ,,"hex"
0000D51A 80                       M 	dc.b	hex
0000D51B =00000012                M 	__lpos:	set __endpos+1
0000D51B =00000013                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D51B                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51B 20                       M 	dc.b	" "
0000D51C =00000025                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D51C =00000026                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D51C =00000025                M 	__midpos:	= __endpos
0000D51C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51C                          M 	__param:	substr ,,"hex"
0000D51C 80                       M 	dc.b	hex
0000D51D =00000026                M 	__lpos:	set __endpos+1
0000D51D =00000027                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D51D                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51D 20                       M 	dc.b	" "
0000D51E =00000038                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D51E =00000039                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D51E =00000038                M 	__midpos:	= __endpos
0000D51E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51E                          M 	__param:	substr ,,"hex"
0000D51E 80                       M 	dc.b	hex
0000D51F =00000039                M 	__lpos:	set __endpos+1
0000D51F =0000003A                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D51F                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D51F 20                       M 	dc.b	" "
0000D520 =00000048                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D520 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D520 =00000048                M 	__midpos:	= __endpos
0000D520                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D520                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D520                          M 	__param:	substr ,,"hex"
0000D520 81                       M 	dc.b	hex|1
0000D521 =00000049                M 	__lpos:	set __endpos+1
0000D521 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D521                          M 	__substr:	substr __lpos,,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D521                          M 	dc.b	""
0000D521 00                       M 	dc.b	0
0000D522                          M 	even
0000D522                          M 	.instr_end_370:
0000D522                            	Console.BreakLine
0000D522 40E7                     M 	move.w	sr,-(sp)
0000D524 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D52A 46DF                     M 	move.w	(sp)+,sr
0000D52C                            
0000D52C                            	Console.WriteLine "%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52C 40E7                     M 	move.w	sr,-(sp)
0000D52E                          M 	__fstring_generateargumentscode	"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E =00000001                M 	__pos:	set instr("%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D52E =00000000                M 	__stack:set	0
0000D52E =00000000                M 	__sp:	set 0
0000D52E                          M 	while	(__pos)
0000D52E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D52E =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D52E =00000008                M 	__midpos:	= __endpos
0000D52E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E =0000000E                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D52E =00000015                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D52E =0000001A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D52E =00000015                M 	__midpos:	= __endpos
0000D52E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E =00000016                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D52E =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D52E =00000023                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D52E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E                          M 	pushp	"move.l cMod(a5),-(sp)"
0000D52E =00000001                M 	__stack:	= __stack+1
0000D52E =00000004                M 	__sp:	= __sp+4
0000D52E =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D52E =0000003F                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D52E =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D52E =0000003F                M 	__midpos:	= __endpos
0000D52E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D52E =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D52E                          M 	rept	__stack
0000D52E                          M 	popp	__command
0000D52E 2F2D 0010                M 	move.l	cmod(a5),-(sp)
0000D532 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D536 45EF 0010                M 	lea	4*4(sp),a2
0000D53A 43FA 0000                M 	lea	.str_374(pc),a1
0000D53E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D544 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D548 584F                     M 	addq.w	#__sp,sp
0000D54A 46DF                     M 	move.w	(sp)+,sr
0000D54C 6000 0000                M 	bra.w	.instr_end_374
0000D550                          M 	.str_374:
0000D550                          M 	__fstring_generatedecodedstring	"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D550 =00000001                M 	__lpos:	set 1
0000D550 =00000001                M 	__pos:	set instr("%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D550                          M 	while	(__pos)
0000D550                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D550                          M 	dc.b	""
0000D550 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D550 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D550 =00000008                M 	__midpos:	= __endpos
0000D550                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D550                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D550 EA                       M 	dc.b	fpal1
0000D551 =00000009                M 	__lpos:	set __endpos+1
0000D551 =0000000E                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D551                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D551 4D6F 643A 20             M 	dc.b	"Mod: "
0000D556 =00000015                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D556 =0000001A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D556 =00000015                M 	__midpos:	= __endpos
0000D556                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D556                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D556 E8                       M 	dc.b	fpal0
0000D557 =00000016                M 	__lpos:	set __endpos+1
0000D557 =00000016                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D557                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D557                          M 	dc.b	""
0000D557 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D557 =00000023                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D557                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D557                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D557 BB                       M 	dc.b	sym|fsplit|3
0000D558 =0000002F                M 	__lpos:	set __endpos+1
0000D558 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D558                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D558                          M 	dc.b	""
0000D558 =0000003F                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D558 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D558 =0000003F                M 	__midpos:	= __endpos
0000D558                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D558                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D558 ECC0                     M 	dc.b	fpal2,fsymdisp
0000D55A =00000040                M 	__lpos:	set __endpos+1
0000D55A =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D55A                          M 	__substr:	substr __lpos,,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D55A                          M 	dc.b	""
0000D55A 00                       M 	dc.b	0
0000D55C 00                       M 	even
0000D55C                          M 	.instr_end_374:
0000D55C                            	Console.Write	  "%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55C 40E7                     M 	move.w	sr,-(sp)
0000D55E                          M 	__fstring_generateargumentscode	"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E =00000001                M 	__pos:	set instr("%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D55E =00000000                M 	__stack:set	0
0000D55E =00000000                M 	__sp:	set 0
0000D55E                          M 	while	(__pos)
0000D55E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D55E =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D55E =00000008                M 	__midpos:	= __endpos
0000D55E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E =00000013                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D55E =0000001A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D55E =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D55E =0000001A                M 	__midpos:	= __endpos
0000D55E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E =0000001B                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D55E =0000002D                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D55E =0000002E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D55E =0000002D                M 	__midpos:	= __endpos
0000D55E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	pushp	"move.b cModDelay(a5),1(sp)"
0000D55E                          M 	pushp	"subq.w	#2, sp"
0000D55E =00000002                M 	__stack:	= __stack+2
0000D55E =00000002                M 	__sp:	= __sp+2
0000D55E =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D55E =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D55E =0000003B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D55E =00000036                M 	__midpos:	= __endpos
0000D55E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D55E =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D55E =00000049                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D55E =00000048                M 	__midpos:	= __endpos
0000D55E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D55E                          M 	pushp	"move.w cModFreq(a5),-(sp)"
0000D55E =00000003                M 	__stack:	= __stack+1
0000D55E =00000004                M 	__sp:	= __sp+2
0000D55E =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D55E                          M 	rept	__stack
0000D55E                          M 	popp	__command
0000D55E 3F2D 0014                M 	move.w	cmodfreq(a5),-(sp)
0000D562                          M 	popp	__command
0000D562 554F                     M 	subq.w	#2,sp
0000D564                          M 	popp	__command
0000D564 1F6D 0010 0001           M 	move.b	cmoddelay(a5),1(sp)
0000D56A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D56E 45EF 0010                M 	lea	4*4(sp),a2
0000D572 43FA 0000                M 	lea	.str_377(pc),a1
0000D576 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D57C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D580 584F                     M 	addq.w	#__sp,sp
0000D582 46DF                     M 	move.w	(sp)+,sr
0000D584 6000 0000                M 	bra.w	.instr_end_377
0000D588                          M 	.str_377:
0000D588                          M 	__fstring_generatedecodedstring	"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D588 =00000001                M 	__lpos:	set 1
0000D588 =00000001                M 	__pos:	set instr("%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D588                          M 	while	(__pos)
0000D588                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D588                          M 	dc.b	""
0000D588 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D588 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D588 =00000008                M 	__midpos:	= __endpos
0000D588                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D588                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D588 EA                       M 	dc.b	fpal1
0000D589 =00000009                M 	__lpos:	set __endpos+1
0000D589 =00000013                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D589                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D589 4D6F 6420 4461 7461 3A20 M 	dc.b	"Mod Data: "
0000D593 =0000001A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D593 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D593 =0000001A                M 	__midpos:	= __endpos
0000D593                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D593                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D593 EC                       M 	dc.b	fpal2
0000D594 =0000001B                M 	__lpos:	set __endpos+1
0000D594 =0000001B                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D594                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D594                          M 	dc.b	""
0000D594 =0000002D                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D594 =0000002E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D594 =0000002D                M 	__midpos:	= __endpos
0000D594                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D594                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D594                          M 	__param:	substr ,,"hex"
0000D594 80                       M 	dc.b	hex
0000D595 =0000002E                M 	__lpos:	set __endpos+1
0000D595 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D595                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D595 20                       M 	dc.b	" "
0000D596 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D596 =0000003B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D596 =00000036                M 	__midpos:	= __endpos
0000D596                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D596                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D596 EC                       M 	dc.b	fpal2
0000D597 =00000037                M 	__lpos:	set __endpos+1
0000D597 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D597                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D597                          M 	dc.b	""
0000D597 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D597 =00000049                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D597 =00000048                M 	__midpos:	= __endpos
0000D597                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D597                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D597                          M 	__param:	substr ,,"hex"
0000D597 81                       M 	dc.b	hex|1
0000D598 =00000049                M 	__lpos:	set __endpos+1
0000D598 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D598                          M 	__substr:	substr __lpos,,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D598 20                       M 	dc.b	" "
0000D599 00                       M 	dc.b	0
0000D59A                          M 	even
0000D59A                          M 	.instr_end_377:
0000D59A                            	Console.WriteLine "%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59A 40E7                     M 	move.w	sr,-(sp)
0000D59C                          M 	__fstring_generateargumentscode	"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C =00000001                M 	__pos:	set instr("%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D59C =00000000                M 	__stack:set	0
0000D59C =00000000                M 	__sp:	set 0
0000D59C                          M 	while	(__pos)
0000D59C =00000013                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D59C =00000014                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D59C =00000013                M 	__midpos:	= __endpos
0000D59C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	pushp	"move.b cModSpeed(a5),1(sp)"
0000D59C                          M 	pushp	"subq.w	#2, sp"
0000D59C =00000002                M 	__stack:	= __stack+2
0000D59C =00000002                M 	__sp:	= __sp+2
0000D59C =00000015                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D59C =00000026                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D59C =00000027                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D59C =00000026                M 	__midpos:	= __endpos
0000D59C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	pushp	"move.b cModStep(a5),1(sp)"
0000D59C                          M 	pushp	"subq.w	#2, sp"
0000D59C =00000004                M 	__stack:	= __stack+2
0000D59C =00000004                M 	__sp:	= __sp+2
0000D59C =00000028                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D59C =0000003A                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D59C =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D59C =0000003A                M 	__midpos:	= __endpos
0000D59C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D59C                          M 	pushp	"move.b cModCount(a5),1(sp)"
0000D59C                          M 	pushp	"subq.w	#2, sp"
0000D59C =00000006                M 	__stack:	= __stack+2
0000D59C =00000006                M 	__sp:	= __sp+2
0000D59C =00000000                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D59C                          M 	rept	__stack
0000D59C                          M 	popp	__command
0000D59C 554F                     M 	subq.w	#2,sp
0000D59E                          M 	popp	__command
0000D59E 1F6D 0018 0001           M 	move.b	cmodcount(a5),1(sp)
0000D5A4                          M 	popp	__command
0000D5A4 554F                     M 	subq.w	#2,sp
0000D5A6                          M 	popp	__command
0000D5A6 1F6D 0017 0001           M 	move.b	cmodstep(a5),1(sp)
0000D5AC                          M 	popp	__command
0000D5AC 554F                     M 	subq.w	#2,sp
0000D5AE                          M 	popp	__command
0000D5AE 1F6D 0016 0001           M 	move.b	cmodspeed(a5),1(sp)
0000D5B4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D5B8 45EF 0010                M 	lea	4*4(sp),a2
0000D5BC 43FA 0000                M 	lea	.str_380(pc),a1
0000D5C0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D5C6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D5CA 5C4F                     M 	addq.w	#__sp,sp
0000D5CC 46DF                     M 	move.w	(sp)+,sr
0000D5CE 6000 0000                M 	bra.w	.instr_end_380
0000D5D2                          M 	.str_380:
0000D5D2                          M 	__fstring_generatedecodedstring	"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D2 =00000001                M 	__lpos:	set 1
0000D5D2 =00000001                M 	__pos:	set instr("%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D5D2                          M 	while	(__pos)
0000D5D2                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D2                          M 	dc.b	""
0000D5D2 =00000013                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D5D2 =00000014                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D5D2 =00000013                M 	__midpos:	= __endpos
0000D5D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D2                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D2                          M 	__param:	substr ,,"hex"
0000D5D2 80                       M 	dc.b	hex
0000D5D3 =00000014                M 	__lpos:	set __endpos+1
0000D5D3 =00000015                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D5D3                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D3 20                       M 	dc.b	" "
0000D5D4 =00000026                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D5D4 =00000027                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D5D4 =00000026                M 	__midpos:	= __endpos
0000D5D4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D4                          M 	__param:	substr ,,"hex"
0000D5D4 80                       M 	dc.b	hex
0000D5D5 =00000027                M 	__lpos:	set __endpos+1
0000D5D5 =00000028                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D5D5                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D5 20                       M 	dc.b	" "
0000D5D6 =0000003A                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D5D6 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D5D6 =0000003A                M 	__midpos:	= __endpos
0000D5D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D6                          M 	__param:	substr ,,"hex"
0000D5D6 80                       M 	dc.b	hex
0000D5D7 =0000003B                M 	__lpos:	set __endpos+1
0000D5D7 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D5D7                          M 	__substr:	substr __lpos,,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D5D7                          M 	dc.b	""
0000D5D7 00                       M 	dc.b	0
0000D5D8                          M 	even
0000D5D8                          M 	.instr_end_380:
0000D5D8                            	Console.BreakLine
0000D5D8 40E7                     M 	move.w	sr,-(sp)
0000D5DA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D5E0 46DF                     M 	move.w	(sp)+,sr
0000D5E2                            
0000D5E2                            	Console.Write "%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E2 40E7                     M 	move.w	sr,-(sp)
0000D5E4                          M 	__fstring_generateargumentscode	"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4 =00000001                M 	__pos:	set instr("%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D5E4 =00000000                M 	__stack:set	0
0000D5E4 =00000000                M 	__sp:	set 0
0000D5E4                          M 	while	(__pos)
0000D5E4 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D5E4 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D5E4 =00000008                M 	__midpos:	= __endpos
0000D5E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4 =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D5E4 =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D5E4 =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D5E4 =00000016                M 	__midpos:	= __endpos
0000D5E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4 =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D5E4 =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D5E4 =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D5E4 =00000025                M 	__midpos:	= __endpos
0000D5E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	pushp	"move.b cLoop(a5),1(sp)"
0000D5E4                          M 	pushp	"subq.w	#2, sp"
0000D5E4 =00000002                M 	__stack:	= __stack+2
0000D5E4 =00000002                M 	__sp:	= __sp+2
0000D5E4 =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D5E4 =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D5E4 =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D5E4 =00000037                M 	__midpos:	= __endpos
0000D5E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	pushp	"move.b cLoop+1(a5),1(sp)"
0000D5E4                          M 	pushp	"subq.w	#2, sp"
0000D5E4 =00000004                M 	__stack:	= __stack+2
0000D5E4 =00000004                M 	__sp:	= __sp+2
0000D5E4 =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D5E4 =00000049                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D5E4 =0000004A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D5E4 =00000049                M 	__midpos:	= __endpos
0000D5E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D5E4                          M 	pushp	"move.b cLoop+2(a5),1(sp)"
0000D5E4                          M 	pushp	"subq.w	#2, sp"
0000D5E4 =00000006                M 	__stack:	= __stack+2
0000D5E4 =00000006                M 	__sp:	= __sp+2
0000D5E4 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D5E4                          M 	rept	__stack
0000D5E4                          M 	popp	__command
0000D5E4 554F                     M 	subq.w	#2,sp
0000D5E6                          M 	popp	__command
0000D5E6 1F6D 001B 0001           M 	move.b	cloop+2(a5),1(sp)
0000D5EC                          M 	popp	__command
0000D5EC 554F                     M 	subq.w	#2,sp
0000D5EE                          M 	popp	__command
0000D5EE 1F6D 001A 0001           M 	move.b	cloop+1(a5),1(sp)
0000D5F4                          M 	popp	__command
0000D5F4 554F                     M 	subq.w	#2,sp
0000D5F6                          M 	popp	__command
0000D5F6 1F6D 0019 0001           M 	move.b	cloop(a5),1(sp)
0000D5FC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D600 45EF 0010                M 	lea	4*4(sp),a2
0000D604 43FA 0000                M 	lea	.str_384(pc),a1
0000D608 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D60E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D612 5C4F                     M 	addq.w	#__sp,sp
0000D614 46DF                     M 	move.w	(sp)+,sr
0000D616 6000 0000                M 	bra.w	.instr_end_384
0000D61A                          M 	.str_384:
0000D61A                          M 	__fstring_generatedecodedstring	"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D61A =00000001                M 	__lpos:	set 1
0000D61A =00000001                M 	__pos:	set instr("%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D61A                          M 	while	(__pos)
0000D61A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D61A                          M 	dc.b	""
0000D61A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D61A =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D61A =00000008                M 	__midpos:	= __endpos
0000D61A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D61A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D61A EA                       M 	dc.b	fpal1
0000D61B =00000009                M 	__lpos:	set __endpos+1
0000D61B =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D61B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D61B 4C6F 6F70 3A20           M 	dc.b	"Loop: "
0000D621 =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D621 =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D621 =00000016                M 	__midpos:	= __endpos
0000D621                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D621                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D621 EC                       M 	dc.b	fpal2
0000D622 =00000017                M 	__lpos:	set __endpos+1
0000D622 =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D622                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D622                          M 	dc.b	""
0000D622 =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D622 =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D622 =00000025                M 	__midpos:	= __endpos
0000D622                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D622                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D622                          M 	__param:	substr ,,"hex"
0000D622 80                       M 	dc.b	hex
0000D623 =00000026                M 	__lpos:	set __endpos+1
0000D623 =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D623                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D623 20                       M 	dc.b	" "
0000D624 =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D624 =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D624 =00000037                M 	__midpos:	= __endpos
0000D624                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D624                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D624                          M 	__param:	substr ,,"hex"
0000D624 80                       M 	dc.b	hex
0000D625 =00000038                M 	__lpos:	set __endpos+1
0000D625 =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D625                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D625 20                       M 	dc.b	" "
0000D626 =00000049                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D626 =0000004A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D626 =00000049                M 	__midpos:	= __endpos
0000D626                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D626                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D626                          M 	__param:	substr ,,"hex"
0000D626 80                       M 	dc.b	hex
0000D627 =0000004A                M 	__lpos:	set __endpos+1
0000D627 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D627                          M 	__substr:	substr __lpos,,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D627 20                       M 	dc.b	" "
0000D628 00                       M 	dc.b	0
0000D62A 00                       M 	even
0000D62A                          M 	.instr_end_384:
0000D62A BAFC C67C                  	cmp.w	#mSFXDAC1,a5
0000D62E 6400 0000                  	bhs.w	AMPS_Debug_Console_Channel_Writerts
0000D632                            	Console.WriteLine "%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D632 40E7                     M 	move.w	sr,-(sp)
0000D634                          M 	__fstring_generateargumentscode	"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D634 =00000001                M 	__pos:	set instr("%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D634 =00000000                M 	__stack:set	0
0000D634 =00000000                M 	__sp:	set 0
0000D634                          M 	while	(__pos)
0000D634 =00000016                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D634 =00000017                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D634 =00000016                M 	__midpos:	= __endpos
0000D634                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D634                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D634                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D634                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D634                          M 	pushp	"move.b cNoteTimeCur(a5),1(sp)"
0000D634                          M 	pushp	"subq.w	#2, sp"
0000D634 =00000002                M 	__stack:	= __stack+2
0000D634 =00000002                M 	__sp:	= __sp+2
0000D634 =00000018                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D634 =0000002E                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D634 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D634 =0000002E                M 	__midpos:	= __endpos
0000D634                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D634                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D634                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D634                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D634                          M 	pushp	"move.b cNoteTimeMain(a5),1(sp)"
0000D634                          M 	pushp	"subq.w	#2, sp"
0000D634 =00000004                M 	__stack:	= __stack+2
0000D634 =00000004                M 	__sp:	= __sp+2
0000D634 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D634                          M 	rept	__stack
0000D634                          M 	popp	__command
0000D634 554F                     M 	subq.w	#2,sp
0000D636                          M 	popp	__command
0000D636 1F6D 001D 0001           M 	move.b	cnotetimemain(a5),1(sp)
0000D63C                          M 	popp	__command
0000D63C 554F                     M 	subq.w	#2,sp
0000D63E                          M 	popp	__command
0000D63E 1F6D 001C 0001           M 	move.b	cnotetimecur(a5),1(sp)
0000D644 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D648 45EF 0010                M 	lea	4*4(sp),a2
0000D64C 43FA 0000                M 	lea	.str_387(pc),a1
0000D650 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D656 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D65A 584F                     M 	addq.w	#__sp,sp
0000D65C 46DF                     M 	move.w	(sp)+,sr
0000D65E 6000 0000                M 	bra.w	.instr_end_387
0000D662                          M 	.str_387:
0000D662                          M 	__fstring_generatedecodedstring	"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D662 =00000001                M 	__lpos:	set 1
0000D662 =00000001                M 	__pos:	set instr("%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D662                          M 	while	(__pos)
0000D662                          M 	__substr:	substr __lpos,__pos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D662                          M 	dc.b	""
0000D662 =00000016                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D662 =00000017                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D662 =00000016                M 	__midpos:	= __endpos
0000D662                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D662                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D662                          M 	__param:	substr ,,"hex"
0000D662 80                       M 	dc.b	hex
0000D663 =00000017                M 	__lpos:	set __endpos+1
0000D663 =00000018                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D663                          M 	__substr:	substr __lpos,__pos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D663 20                       M 	dc.b	" "
0000D664 =0000002E                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D664 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D664 =0000002E                M 	__midpos:	= __endpos
0000D664                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D664                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D664                          M 	__param:	substr ,,"hex"
0000D664 80                       M 	dc.b	hex
0000D665 =0000002F                M 	__lpos:	set __endpos+1
0000D665 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D665                          M 	__substr:	substr __lpos,,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D665                          M 	dc.b	""
0000D665 00                       M 	dc.b	0
0000D666                          M 	even
0000D666                          M 	.instr_end_387:
0000D666                            	Console.WriteLine "%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D666 40E7                     M 	move.w	sr,-(sp)
0000D668                          M 	__fstring_generateargumentscode	"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D668 =00000001                M 	__pos:	set instr("%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D668 =00000000                M 	__stack:set	0
0000D668 =00000000                M 	__sp:	set 0
0000D668                          M 	while	(__pos)
0000D668 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D668 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D668 =00000008                M 	__midpos:	= __endpos
0000D668                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D668                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D668 =00000010                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D668 =00000017                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D668 =0000001C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D668 =00000017                M 	__midpos:	= __endpos
0000D668                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D668                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D668 =00000018                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D668 =00000027                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D668 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D668 =00000027                M 	__midpos:	= __endpos
0000D668                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D668                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D668                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D668                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D668                          M 	pushp	"move.b cStack(a5),1(sp)"
0000D668                          M 	pushp	"subq.w	#2, sp"
0000D668 =00000002                M 	__stack:	= __stack+2
0000D668 =00000002                M 	__sp:	= __sp+2
0000D668 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D668                          M 	rept	__stack
0000D668                          M 	popp	__command
0000D668 554F                     M 	subq.w	#2,sp
0000D66A                          M 	popp	__command
0000D66A 1F6D 001E 0001           M 	move.b	cstack(a5),1(sp)
0000D670 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D674 45EF 0010                M 	lea	4*4(sp),a2
0000D678 43FA 0000                M 	lea	.str_390(pc),a1
0000D67C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D682 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D686 544F                     M 	addq.w	#__sp,sp
0000D688 46DF                     M 	move.w	(sp)+,sr
0000D68A 6000 0000                M 	bra.w	.instr_end_390
0000D68E                          M 	.str_390:
0000D68E                          M 	__fstring_generatedecodedstring	"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D68E =00000001                M 	__lpos:	set 1
0000D68E =00000001                M 	__pos:	set instr("%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D68E                          M 	while	(__pos)
0000D68E                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D68E                          M 	dc.b	""
0000D68E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D68E =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D68E =00000008                M 	__midpos:	= __endpos
0000D68E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D68E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D68E EA                       M 	dc.b	fpal1
0000D68F =00000009                M 	__lpos:	set __endpos+1
0000D68F =00000010                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D68F                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D68F 5374 6163 6B3A 20        M 	dc.b	"Stack: "
0000D696 =00000017                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D696 =0000001C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D696 =00000017                M 	__midpos:	= __endpos
0000D696                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D696                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D696 EC                       M 	dc.b	fpal2
0000D697 =00000018                M 	__lpos:	set __endpos+1
0000D697 =00000018                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D697                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D697                          M 	dc.b	""
0000D697 =00000027                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D697 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D697 =00000027                M 	__midpos:	= __endpos
0000D697                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D697                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D697                          M 	__param:	substr ,,"hex"
0000D697 80                       M 	dc.b	hex
0000D698 =00000028                M 	__lpos:	set __endpos+1
0000D698 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D698                          M 	__substr:	substr __lpos,,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D698                          M 	dc.b	""
0000D698 00                       M 	dc.b	0
0000D69A 00                       M 	even
0000D69A                          M 	.instr_end_390:
0000D69A                            
0000D69A 320D                       	move.w	a5,d1
0000D69C 0641 002C                  	add.w	#cSize,d1
0000D6A0                            
0000D6A0 7000                       	moveq	#0,d0
0000D6A2 102D 001E                  	move.b	cStack(a5),d0
0000D6A6 DAC0                       	add.w	d0,a5
0000D6A8                            
0000D6A8                            AMPS_Debug_Console_Channel_Writeloop
0000D6A8 B24D                       	cmp.w	a5,d1
0000D6AA 6300                       	bls.s	AMPS_Debug_Console_Channel_Writerts
0000D6AC                            	Console.WriteLine "%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AC 40E7                     M 	move.w	sr,-(sp)
0000D6AE                          M 	__fstring_generateargumentscode	"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AE =00000001                M 	__pos:	set instr("%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D6AE =00000000                M 	__stack:set	0
0000D6AE =00000000                M 	__sp:	set 0
0000D6AE                          M 	while	(__pos)
0000D6AE =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D6AE =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D6AE =00000008                M 	__midpos:	= __endpos
0000D6AE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AE =00000009                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D6AE =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D6AE =00000013                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D6AE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AE                          M 	pushp	"move.l (a5)+,-(sp)"
0000D6AE =00000001                M 	__stack:	= __stack+1
0000D6AE =00000004                M 	__sp:	= __sp+4
0000D6AE =0000001F                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D6AE =0000002F                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D6AE =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D6AE =0000002F                M 	__midpos:	= __endpos
0000D6AE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6AE =00000000                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D6AE                          M 	rept	__stack
0000D6AE                          M 	popp	__command
0000D6AE 2F1D                     M 	move.l	(a5)+,-(sp)
0000D6B0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6B4 45EF 0010                M 	lea	4*4(sp),a2
0000D6B8 43FA 0000                M 	lea	.str_393(pc),a1
0000D6BC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D6C2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D6C6 584F                     M 	addq.w	#__sp,sp
0000D6C8 46DF                     M 	move.w	(sp)+,sr
0000D6CA 6000 0000                M 	bra.w	.instr_end_393
0000D6CE                          M 	.str_393:
0000D6CE                          M 	__fstring_generatedecodedstring	"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6CE =00000001                M 	__lpos:	set 1
0000D6CE =00000001                M 	__pos:	set instr("%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D6CE                          M 	while	(__pos)
0000D6CE                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6CE                          M 	dc.b	""
0000D6CE =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D6CE =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D6CE =00000008                M 	__midpos:	= __endpos
0000D6CE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6CE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6CE E8                       M 	dc.b	fpal0
0000D6CF =00000009                M 	__lpos:	set __endpos+1
0000D6CF =00000009                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D6CF                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6CF                          M 	dc.b	""
0000D6CF =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D6CF =00000013                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D6CF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6CF                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6CF BB                       M 	dc.b	sym|fsplit|3
0000D6D0 =0000001F                M 	__lpos:	set __endpos+1
0000D6D0 =0000001F                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D6D0                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6D0                          M 	dc.b	""
0000D6D0 =0000002F                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D6D0 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D6D0 =0000002F                M 	__midpos:	= __endpos
0000D6D0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6D0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6D0 ECC0                     M 	dc.b	fpal2,fsymdisp
0000D6D2 =00000030                M 	__lpos:	set __endpos+1
0000D6D2 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D6D2                          M 	__substr:	substr __lpos,,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D6D2                          M 	dc.b	""
0000D6D2 00                       M 	dc.b	0
0000D6D4 00                       M 	even
0000D6D4                          M 	.instr_end_393:
0000D6D4 60D2                       	bra.s	AMPS_Debug_Console_Channel_Writeloop
0000D6D6                            
0000D6D6                            AMPS_Debug_Console_Channel_Writerts
0000D6D6 4E75                       	rts
0000D6D8                            ; ===========================================================================
0000D6D8                            ; ---------------------------------------------------------------------------
0000D6D8                            ; Generic console code
0000D6D8                            ; ---------------------------------------------------------------------------
0000D6D8                            
0000D6D8                            AMPS_Debug_Console_Main:
0000D6D8                            	Console.WriteLine "  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6D8 40E7                     M 	move.w	sr,-(sp)
0000D6DA                          M 	__fstring_generateargumentscode	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D6DA =00000000                M 	__stack:set	0
0000D6DA =00000000                M 	__sp:	set 0
0000D6DA                          M 	while	(__pos)
0000D6DA =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D6DA =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D6DA =0000000A                M 	__midpos:	= __endpos
0000D6DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D6DA =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D6DA =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D6DA =00000016                M 	__midpos:	= __endpos
0000D6DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D6DA =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D6DA =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D6DA =0000001E                M 	__midpos:	= __endpos
0000D6DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	pushp	"move.l d0,-(sp)"
0000D6DA =00000001                M 	__stack:	= __stack+1
0000D6DA =00000004                M 	__sp:	= __sp+4
0000D6DA =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D6DA =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D6DA =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D6DA =00000028                M 	__midpos:	= __endpos
0000D6DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D6DA =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D6DA =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D6DA =00000034                M 	__midpos:	= __endpos
0000D6DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D6DA =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D6DA =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D6DA =0000003C                M 	__midpos:	= __endpos
0000D6DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6DA                          M 	pushp	"move.l a0,-(sp)"
0000D6DA =00000002                M 	__stack:	= __stack+1
0000D6DA =00000008                M 	__sp:	= __sp+4
0000D6DA =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D6DA                          M 	rept	__stack
0000D6DA                          M 	popp	__command
0000D6DA 2F08                     M 	move.l	a0,-(sp)
0000D6DC                          M 	popp	__command
0000D6DC 2F00                     M 	move.l	d0,-(sp)
0000D6DE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6E2 45EF 0010                M 	lea	4*4(sp),a2
0000D6E6 43FA 0000                M 	lea	.str_396(pc),a1
0000D6EA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D6F0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D6F4 504F                     M 	addq.w	#__sp,sp
0000D6F6 46DF                     M 	move.w	(sp)+,sr
0000D6F8 6000 0000                M 	bra.w	.instr_end_396
0000D6FC                          M 	.str_396:
0000D6FC                          M 	__fstring_generatedecodedstring	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6FC =00000001                M 	__lpos:	set 1
0000D6FC =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D6FC                          M 	while	(__pos)
0000D6FC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6FC 2020                     M 	dc.b	"  "
0000D6FE =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D6FE =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D6FE =0000000A                M 	__midpos:	= __endpos
0000D6FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6FE E8                       M 	dc.b	fpal0
0000D6FF =0000000B                M 	__lpos:	set __endpos+1
0000D6FF =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D6FF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D6FF 6430 3A20                M 	dc.b	"d0: "
0000D703 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D703 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D703 =00000016                M 	__midpos:	= __endpos
0000D703                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D703                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D703 EC                       M 	dc.b	fpal2
0000D704 =00000017                M 	__lpos:	set __endpos+1
0000D704 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D704                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D704                          M 	dc.b	""
0000D704 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D704 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D704 =0000001E                M 	__midpos:	= __endpos
0000D704                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D704                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D704                          M 	__param:	substr ,,"hex"
0000D704 83                       M 	dc.b	hex|3
0000D705 =0000001F                M 	__lpos:	set __endpos+1
0000D705 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D705                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D705 2020                     M 	dc.b	"  "
0000D707 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D707 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D707 =00000028                M 	__midpos:	= __endpos
0000D707                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D707                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D707 E8                       M 	dc.b	fpal0
0000D708 =00000029                M 	__lpos:	set __endpos+1
0000D708 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D708                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D708 6130 3A20                M 	dc.b	"a0: "
0000D70C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D70C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D70C =00000034                M 	__midpos:	= __endpos
0000D70C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D70C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D70C EC                       M 	dc.b	fpal2
0000D70D =00000035                M 	__lpos:	set __endpos+1
0000D70D =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D70D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D70D                          M 	dc.b	""
0000D70D =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D70D =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D70D =0000003C                M 	__midpos:	= __endpos
0000D70D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D70D                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D70D                          M 	__param:	substr ,,"hex"
0000D70D 83                       M 	dc.b	hex|3
0000D70E =0000003D                M 	__lpos:	set __endpos+1
0000D70E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D70E                          M 	__substr:	substr __lpos,,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D70E                          M 	dc.b	""
0000D70E 00                       M 	dc.b	0
0000D710 00                       M 	even
0000D710                          M 	.instr_end_396:
0000D710                            	Console.WriteLine "  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D710 40E7                     M 	move.w	sr,-(sp)
0000D712                          M 	__fstring_generateargumentscode	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712 =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D712 =00000000                M 	__stack:set	0
0000D712 =00000000                M 	__sp:	set 0
0000D712                          M 	while	(__pos)
0000D712 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D712 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D712 =0000000A                M 	__midpos:	= __endpos
0000D712                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D712 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D712 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D712 =00000016                M 	__midpos:	= __endpos
0000D712                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D712 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D712 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D712 =0000001E                M 	__midpos:	= __endpos
0000D712                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	pushp	"move.l d1,-(sp)"
0000D712 =00000001                M 	__stack:	= __stack+1
0000D712 =00000004                M 	__sp:	= __sp+4
0000D712 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D712 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D712 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D712 =00000028                M 	__midpos:	= __endpos
0000D712                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D712 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D712 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D712 =00000034                M 	__midpos:	= __endpos
0000D712                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D712 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D712 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D712 =0000003C                M 	__midpos:	= __endpos
0000D712                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D712                          M 	pushp	"move.l a1,-(sp)"
0000D712 =00000002                M 	__stack:	= __stack+1
0000D712 =00000008                M 	__sp:	= __sp+4
0000D712 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D712                          M 	rept	__stack
0000D712                          M 	popp	__command
0000D712 2F09                     M 	move.l	a1,-(sp)
0000D714                          M 	popp	__command
0000D714 2F01                     M 	move.l	d1,-(sp)
0000D716 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D71A 45EF 0010                M 	lea	4*4(sp),a2
0000D71E 43FA 0000                M 	lea	.str_399(pc),a1
0000D722 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D728 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D72C 504F                     M 	addq.w	#__sp,sp
0000D72E 46DF                     M 	move.w	(sp)+,sr
0000D730 6000 0000                M 	bra.w	.instr_end_399
0000D734                          M 	.str_399:
0000D734                          M 	__fstring_generatedecodedstring	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D734 =00000001                M 	__lpos:	set 1
0000D734 =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D734                          M 	while	(__pos)
0000D734                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D734 2020                     M 	dc.b	"  "
0000D736 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D736 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D736 =0000000A                M 	__midpos:	= __endpos
0000D736                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D736                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D736 E8                       M 	dc.b	fpal0
0000D737 =0000000B                M 	__lpos:	set __endpos+1
0000D737 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D737                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D737 6431 3A20                M 	dc.b	"d1: "
0000D73B =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D73B =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D73B =00000016                M 	__midpos:	= __endpos
0000D73B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D73B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D73B EC                       M 	dc.b	fpal2
0000D73C =00000017                M 	__lpos:	set __endpos+1
0000D73C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D73C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D73C                          M 	dc.b	""
0000D73C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D73C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D73C =0000001E                M 	__midpos:	= __endpos
0000D73C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D73C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D73C                          M 	__param:	substr ,,"hex"
0000D73C 83                       M 	dc.b	hex|3
0000D73D =0000001F                M 	__lpos:	set __endpos+1
0000D73D =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D73D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D73D 2020                     M 	dc.b	"  "
0000D73F =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D73F =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D73F =00000028                M 	__midpos:	= __endpos
0000D73F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D73F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D73F E8                       M 	dc.b	fpal0
0000D740 =00000029                M 	__lpos:	set __endpos+1
0000D740 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D740                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D740 6131 3A20                M 	dc.b	"a1: "
0000D744 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D744 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D744 =00000034                M 	__midpos:	= __endpos
0000D744                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D744                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D744 EC                       M 	dc.b	fpal2
0000D745 =00000035                M 	__lpos:	set __endpos+1
0000D745 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D745                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D745                          M 	dc.b	""
0000D745 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D745 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D745 =0000003C                M 	__midpos:	= __endpos
0000D745                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D745                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D745                          M 	__param:	substr ,,"hex"
0000D745 83                       M 	dc.b	hex|3
0000D746 =0000003D                M 	__lpos:	set __endpos+1
0000D746 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D746                          M 	__substr:	substr __lpos,,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D746                          M 	dc.b	""
0000D746 00                       M 	dc.b	0
0000D748 00                       M 	even
0000D748                          M 	.instr_end_399:
0000D748                            	Console.WriteLine "  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D748 40E7                     M 	move.w	sr,-(sp)
0000D74A                          M 	__fstring_generateargumentscode	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D74A =00000000                M 	__stack:set	0
0000D74A =00000000                M 	__sp:	set 0
0000D74A                          M 	while	(__pos)
0000D74A =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D74A =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D74A =0000000A                M 	__midpos:	= __endpos
0000D74A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D74A =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D74A =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D74A =00000016                M 	__midpos:	= __endpos
0000D74A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D74A =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D74A =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D74A =0000001E                M 	__midpos:	= __endpos
0000D74A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	pushp	"move.l d2,-(sp)"
0000D74A =00000001                M 	__stack:	= __stack+1
0000D74A =00000004                M 	__sp:	= __sp+4
0000D74A =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D74A =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D74A =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D74A =00000028                M 	__midpos:	= __endpos
0000D74A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D74A =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D74A =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D74A =00000034                M 	__midpos:	= __endpos
0000D74A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D74A =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D74A =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D74A =0000003C                M 	__midpos:	= __endpos
0000D74A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D74A                          M 	pushp	"move.l a2,-(sp)"
0000D74A =00000002                M 	__stack:	= __stack+1
0000D74A =00000008                M 	__sp:	= __sp+4
0000D74A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D74A                          M 	rept	__stack
0000D74A                          M 	popp	__command
0000D74A 2F0A                     M 	move.l	a2,-(sp)
0000D74C                          M 	popp	__command
0000D74C 2F02                     M 	move.l	d2,-(sp)
0000D74E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D752 45EF 0010                M 	lea	4*4(sp),a2
0000D756 43FA 0000                M 	lea	.str_402(pc),a1
0000D75A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D760 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D764 504F                     M 	addq.w	#__sp,sp
0000D766 46DF                     M 	move.w	(sp)+,sr
0000D768 6000 0000                M 	bra.w	.instr_end_402
0000D76C                          M 	.str_402:
0000D76C                          M 	__fstring_generatedecodedstring	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D76C =00000001                M 	__lpos:	set 1
0000D76C =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D76C                          M 	while	(__pos)
0000D76C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D76C 2020                     M 	dc.b	"  "
0000D76E =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D76E =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D76E =0000000A                M 	__midpos:	= __endpos
0000D76E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D76E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D76E E8                       M 	dc.b	fpal0
0000D76F =0000000B                M 	__lpos:	set __endpos+1
0000D76F =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D76F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D76F 6432 3A20                M 	dc.b	"d2: "
0000D773 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D773 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D773 =00000016                M 	__midpos:	= __endpos
0000D773                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D773                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D773 EC                       M 	dc.b	fpal2
0000D774 =00000017                M 	__lpos:	set __endpos+1
0000D774 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D774                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D774                          M 	dc.b	""
0000D774 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D774 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D774 =0000001E                M 	__midpos:	= __endpos
0000D774                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D774                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D774                          M 	__param:	substr ,,"hex"
0000D774 83                       M 	dc.b	hex|3
0000D775 =0000001F                M 	__lpos:	set __endpos+1
0000D775 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D775                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D775 2020                     M 	dc.b	"  "
0000D777 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D777 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D777 =00000028                M 	__midpos:	= __endpos
0000D777                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D777                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D777 E8                       M 	dc.b	fpal0
0000D778 =00000029                M 	__lpos:	set __endpos+1
0000D778 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D778                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D778 6132 3A20                M 	dc.b	"a2: "
0000D77C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D77C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D77C =00000034                M 	__midpos:	= __endpos
0000D77C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D77C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D77C EC                       M 	dc.b	fpal2
0000D77D =00000035                M 	__lpos:	set __endpos+1
0000D77D =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D77D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D77D                          M 	dc.b	""
0000D77D =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D77D =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D77D =0000003C                M 	__midpos:	= __endpos
0000D77D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D77D                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D77D                          M 	__param:	substr ,,"hex"
0000D77D 83                       M 	dc.b	hex|3
0000D77E =0000003D                M 	__lpos:	set __endpos+1
0000D77E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D77E                          M 	__substr:	substr __lpos,,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D77E                          M 	dc.b	""
0000D77E 00                       M 	dc.b	0
0000D780 00                       M 	even
0000D780                          M 	.instr_end_402:
0000D780                            	Console.WriteLine "  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D780 40E7                     M 	move.w	sr,-(sp)
0000D782                          M 	__fstring_generateargumentscode	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782 =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D782 =00000000                M 	__stack:set	0
0000D782 =00000000                M 	__sp:	set 0
0000D782                          M 	while	(__pos)
0000D782 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D782 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D782 =0000000A                M 	__midpos:	= __endpos
0000D782                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D782 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D782 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D782 =00000016                M 	__midpos:	= __endpos
0000D782                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D782 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D782 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D782 =0000001E                M 	__midpos:	= __endpos
0000D782                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	pushp	"move.l d3,-(sp)"
0000D782 =00000001                M 	__stack:	= __stack+1
0000D782 =00000004                M 	__sp:	= __sp+4
0000D782 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D782 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D782 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D782 =00000028                M 	__midpos:	= __endpos
0000D782                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D782 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D782 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D782 =00000034                M 	__midpos:	= __endpos
0000D782                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D782 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D782 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D782 =0000003C                M 	__midpos:	= __endpos
0000D782                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D782                          M 	pushp	"move.l a3,-(sp)"
0000D782 =00000002                M 	__stack:	= __stack+1
0000D782 =00000008                M 	__sp:	= __sp+4
0000D782 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D782                          M 	rept	__stack
0000D782                          M 	popp	__command
0000D782 2F0B                     M 	move.l	a3,-(sp)
0000D784                          M 	popp	__command
0000D784 2F03                     M 	move.l	d3,-(sp)
0000D786 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D78A 45EF 0010                M 	lea	4*4(sp),a2
0000D78E 43FA 0000                M 	lea	.str_405(pc),a1
0000D792 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D798 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D79C 504F                     M 	addq.w	#__sp,sp
0000D79E 46DF                     M 	move.w	(sp)+,sr
0000D7A0 6000 0000                M 	bra.w	.instr_end_405
0000D7A4                          M 	.str_405:
0000D7A4                          M 	__fstring_generatedecodedstring	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7A4 =00000001                M 	__lpos:	set 1
0000D7A4 =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D7A4                          M 	while	(__pos)
0000D7A4                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7A4 2020                     M 	dc.b	"  "
0000D7A6 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D7A6 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D7A6 =0000000A                M 	__midpos:	= __endpos
0000D7A6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7A6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7A6 E8                       M 	dc.b	fpal0
0000D7A7 =0000000B                M 	__lpos:	set __endpos+1
0000D7A7 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D7A7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7A7 6433 3A20                M 	dc.b	"d3: "
0000D7AB =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D7AB =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D7AB =00000016                M 	__midpos:	= __endpos
0000D7AB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7AB                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7AB EC                       M 	dc.b	fpal2
0000D7AC =00000017                M 	__lpos:	set __endpos+1
0000D7AC =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D7AC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7AC                          M 	dc.b	""
0000D7AC =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D7AC =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D7AC =0000001E                M 	__midpos:	= __endpos
0000D7AC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7AC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7AC                          M 	__param:	substr ,,"hex"
0000D7AC 83                       M 	dc.b	hex|3
0000D7AD =0000001F                M 	__lpos:	set __endpos+1
0000D7AD =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D7AD                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7AD 2020                     M 	dc.b	"  "
0000D7AF =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D7AF =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D7AF =00000028                M 	__midpos:	= __endpos
0000D7AF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7AF                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7AF E8                       M 	dc.b	fpal0
0000D7B0 =00000029                M 	__lpos:	set __endpos+1
0000D7B0 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D7B0                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7B0 6133 3A20                M 	dc.b	"a3: "
0000D7B4 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D7B4 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D7B4 =00000034                M 	__midpos:	= __endpos
0000D7B4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7B4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7B4 EC                       M 	dc.b	fpal2
0000D7B5 =00000035                M 	__lpos:	set __endpos+1
0000D7B5 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D7B5                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7B5                          M 	dc.b	""
0000D7B5 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D7B5 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D7B5 =0000003C                M 	__midpos:	= __endpos
0000D7B5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7B5                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7B5                          M 	__param:	substr ,,"hex"
0000D7B5 83                       M 	dc.b	hex|3
0000D7B6 =0000003D                M 	__lpos:	set __endpos+1
0000D7B6 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D7B6                          M 	__substr:	substr __lpos,,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D7B6                          M 	dc.b	""
0000D7B6 00                       M 	dc.b	0
0000D7B8 00                       M 	even
0000D7B8                          M 	.instr_end_405:
0000D7B8                            	Console.WriteLine "  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7B8 40E7                     M 	move.w	sr,-(sp)
0000D7BA                          M 	__fstring_generateargumentscode	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7BA =00000000                M 	__stack:set	0
0000D7BA =00000000                M 	__sp:	set 0
0000D7BA                          M 	while	(__pos)
0000D7BA =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7BA =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7BA =0000000A                M 	__midpos:	= __endpos
0000D7BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7BA =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7BA =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7BA =00000016                M 	__midpos:	= __endpos
0000D7BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7BA =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7BA =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7BA =0000001E                M 	__midpos:	= __endpos
0000D7BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	pushp	"move.l d4,-(sp)"
0000D7BA =00000001                M 	__stack:	= __stack+1
0000D7BA =00000004                M 	__sp:	= __sp+4
0000D7BA =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7BA =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7BA =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7BA =00000028                M 	__midpos:	= __endpos
0000D7BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7BA =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7BA =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7BA =00000034                M 	__midpos:	= __endpos
0000D7BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7BA =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7BA =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7BA =0000003C                M 	__midpos:	= __endpos
0000D7BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7BA                          M 	pushp	"move.l a4,-(sp)"
0000D7BA =00000002                M 	__stack:	= __stack+1
0000D7BA =00000008                M 	__sp:	= __sp+4
0000D7BA =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7BA                          M 	rept	__stack
0000D7BA                          M 	popp	__command
0000D7BA 2F0C                     M 	move.l	a4,-(sp)
0000D7BC                          M 	popp	__command
0000D7BC 2F04                     M 	move.l	d4,-(sp)
0000D7BE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D7C2 45EF 0010                M 	lea	4*4(sp),a2
0000D7C6 43FA 0000                M 	lea	.str_408(pc),a1
0000D7CA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D7D0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D7D4 504F                     M 	addq.w	#__sp,sp
0000D7D6 46DF                     M 	move.w	(sp)+,sr
0000D7D8 6000 0000                M 	bra.w	.instr_end_408
0000D7DC                          M 	.str_408:
0000D7DC                          M 	__fstring_generatedecodedstring	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7DC =00000001                M 	__lpos:	set 1
0000D7DC =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7DC                          M 	while	(__pos)
0000D7DC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7DC 2020                     M 	dc.b	"  "
0000D7DE =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7DE =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7DE =0000000A                M 	__midpos:	= __endpos
0000D7DE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7DE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7DE E8                       M 	dc.b	fpal0
0000D7DF =0000000B                M 	__lpos:	set __endpos+1
0000D7DF =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7DF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7DF 6434 3A20                M 	dc.b	"d4: "
0000D7E3 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7E3 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7E3 =00000016                M 	__midpos:	= __endpos
0000D7E3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7E3                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7E3 EC                       M 	dc.b	fpal2
0000D7E4 =00000017                M 	__lpos:	set __endpos+1
0000D7E4 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7E4                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7E4                          M 	dc.b	""
0000D7E4 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7E4 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7E4 =0000001E                M 	__midpos:	= __endpos
0000D7E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7E4                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7E4                          M 	__param:	substr ,,"hex"
0000D7E4 83                       M 	dc.b	hex|3
0000D7E5 =0000001F                M 	__lpos:	set __endpos+1
0000D7E5 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7E5                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7E5 2020                     M 	dc.b	"  "
0000D7E7 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7E7 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7E7 =00000028                M 	__midpos:	= __endpos
0000D7E7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7E7                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7E7 E8                       M 	dc.b	fpal0
0000D7E8 =00000029                M 	__lpos:	set __endpos+1
0000D7E8 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7E8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7E8 6134 3A20                M 	dc.b	"a4: "
0000D7EC =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7EC =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7EC =00000034                M 	__midpos:	= __endpos
0000D7EC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7EC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7EC EC                       M 	dc.b	fpal2
0000D7ED =00000035                M 	__lpos:	set __endpos+1
0000D7ED =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7ED                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7ED                          M 	dc.b	""
0000D7ED =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D7ED =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D7ED =0000003C                M 	__midpos:	= __endpos
0000D7ED                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7ED                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7ED                          M 	__param:	substr ,,"hex"
0000D7ED 83                       M 	dc.b	hex|3
0000D7EE =0000003D                M 	__lpos:	set __endpos+1
0000D7EE =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D7EE                          M 	__substr:	substr __lpos,,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D7EE                          M 	dc.b	""
0000D7EE 00                       M 	dc.b	0
0000D7F0 00                       M 	even
0000D7F0                          M 	.instr_end_408:
0000D7F0                            	Console.WriteLine "  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F0 40E7                     M 	move.w	sr,-(sp)
0000D7F2                          M 	__fstring_generateargumentscode	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2 =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D7F2 =00000000                M 	__stack:set	0
0000D7F2 =00000000                M 	__sp:	set 0
0000D7F2                          M 	while	(__pos)
0000D7F2 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D7F2 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D7F2 =0000000A                M 	__midpos:	= __endpos
0000D7F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D7F2 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D7F2 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D7F2 =00000016                M 	__midpos:	= __endpos
0000D7F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D7F2 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D7F2 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D7F2 =0000001E                M 	__midpos:	= __endpos
0000D7F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	pushp	"move.l d5,-(sp)"
0000D7F2 =00000001                M 	__stack:	= __stack+1
0000D7F2 =00000004                M 	__sp:	= __sp+4
0000D7F2 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D7F2 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D7F2 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D7F2 =00000028                M 	__midpos:	= __endpos
0000D7F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D7F2 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D7F2 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D7F2 =00000034                M 	__midpos:	= __endpos
0000D7F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D7F2 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D7F2 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D7F2 =0000003C                M 	__midpos:	= __endpos
0000D7F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D7F2                          M 	pushp	"move.l a5,-(sp)"
0000D7F2 =00000002                M 	__stack:	= __stack+1
0000D7F2 =00000008                M 	__sp:	= __sp+4
0000D7F2 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D7F2                          M 	rept	__stack
0000D7F2                          M 	popp	__command
0000D7F2 2F0D                     M 	move.l	a5,-(sp)
0000D7F4                          M 	popp	__command
0000D7F4 2F05                     M 	move.l	d5,-(sp)
0000D7F6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D7FA 45EF 0010                M 	lea	4*4(sp),a2
0000D7FE 43FA 0000                M 	lea	.str_411(pc),a1
0000D802 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D808 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D80C 504F                     M 	addq.w	#__sp,sp
0000D80E 46DF                     M 	move.w	(sp)+,sr
0000D810 6000 0000                M 	bra.w	.instr_end_411
0000D814                          M 	.str_411:
0000D814                          M 	__fstring_generatedecodedstring	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D814 =00000001                M 	__lpos:	set 1
0000D814 =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D814                          M 	while	(__pos)
0000D814                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D814 2020                     M 	dc.b	"  "
0000D816 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D816 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D816 =0000000A                M 	__midpos:	= __endpos
0000D816                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D816                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D816 E8                       M 	dc.b	fpal0
0000D817 =0000000B                M 	__lpos:	set __endpos+1
0000D817 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D817                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D817 6435 3A20                M 	dc.b	"d5: "
0000D81B =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D81B =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D81B =00000016                M 	__midpos:	= __endpos
0000D81B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D81B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D81B EC                       M 	dc.b	fpal2
0000D81C =00000017                M 	__lpos:	set __endpos+1
0000D81C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D81C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D81C                          M 	dc.b	""
0000D81C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D81C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D81C =0000001E                M 	__midpos:	= __endpos
0000D81C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D81C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D81C                          M 	__param:	substr ,,"hex"
0000D81C 83                       M 	dc.b	hex|3
0000D81D =0000001F                M 	__lpos:	set __endpos+1
0000D81D =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D81D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D81D 2020                     M 	dc.b	"  "
0000D81F =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D81F =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D81F =00000028                M 	__midpos:	= __endpos
0000D81F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D81F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D81F E8                       M 	dc.b	fpal0
0000D820 =00000029                M 	__lpos:	set __endpos+1
0000D820 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D820                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D820 6135 3A20                M 	dc.b	"a5: "
0000D824 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D824 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D824 =00000034                M 	__midpos:	= __endpos
0000D824                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D824                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D824 EC                       M 	dc.b	fpal2
0000D825 =00000035                M 	__lpos:	set __endpos+1
0000D825 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D825                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D825                          M 	dc.b	""
0000D825 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D825 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D825 =0000003C                M 	__midpos:	= __endpos
0000D825                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D825                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D825                          M 	__param:	substr ,,"hex"
0000D825 83                       M 	dc.b	hex|3
0000D826 =0000003D                M 	__lpos:	set __endpos+1
0000D826 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D826                          M 	__substr:	substr __lpos,,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D826                          M 	dc.b	""
0000D826 00                       M 	dc.b	0
0000D828 00                       M 	even
0000D828                          M 	.instr_end_411:
0000D828                            	Console.WriteLine "  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D828 40E7                     M 	move.w	sr,-(sp)
0000D82A                          M 	__fstring_generateargumentscode	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D82A =00000000                M 	__stack:set	0
0000D82A =00000000                M 	__sp:	set 0
0000D82A                          M 	while	(__pos)
0000D82A =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D82A =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D82A =0000000A                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D82A =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D82A =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D82A =00000016                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D82A =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D82A =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D82A =0000001E                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	pushp	"move.l d6,-(sp)"
0000D82A =00000001                M 	__stack:	= __stack+1
0000D82A =00000004                M 	__sp:	= __sp+4
0000D82A =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D82A =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D82A =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D82A =00000028                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D82A =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D82A =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D82A =00000034                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D82A =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D82A =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D82A =0000003C                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D82A                          M 	pushp	"move.l a6,-(sp)"
0000D82A =00000002                M 	__stack:	= __stack+1
0000D82A =00000008                M 	__sp:	= __sp+4
0000D82A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D82A                          M 	rept	__stack
0000D82A                          M 	popp	__command
0000D82A 2F0E                     M 	move.l	a6,-(sp)
0000D82C                          M 	popp	__command
0000D82C 2F06                     M 	move.l	d6,-(sp)
0000D82E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D832 45EF 0010                M 	lea	4*4(sp),a2
0000D836 43FA 0000                M 	lea	.str_414(pc),a1
0000D83A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D840 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D844 504F                     M 	addq.w	#__sp,sp
0000D846 46DF                     M 	move.w	(sp)+,sr
0000D848 6000 0000                M 	bra.w	.instr_end_414
0000D84C                          M 	.str_414:
0000D84C                          M 	__fstring_generatedecodedstring	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D84C =00000001                M 	__lpos:	set 1
0000D84C =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D84C                          M 	while	(__pos)
0000D84C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D84C 2020                     M 	dc.b	"  "
0000D84E =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D84E =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D84E =0000000A                M 	__midpos:	= __endpos
0000D84E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D84E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D84E E8                       M 	dc.b	fpal0
0000D84F =0000000B                M 	__lpos:	set __endpos+1
0000D84F =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D84F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D84F 6436 3A20                M 	dc.b	"d6: "
0000D853 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D853 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D853 =00000016                M 	__midpos:	= __endpos
0000D853                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D853                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D853 EC                       M 	dc.b	fpal2
0000D854 =00000017                M 	__lpos:	set __endpos+1
0000D854 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D854                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D854                          M 	dc.b	""
0000D854 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D854 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D854 =0000001E                M 	__midpos:	= __endpos
0000D854                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D854                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D854                          M 	__param:	substr ,,"hex"
0000D854 83                       M 	dc.b	hex|3
0000D855 =0000001F                M 	__lpos:	set __endpos+1
0000D855 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D855                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D855 2020                     M 	dc.b	"  "
0000D857 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D857 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D857 =00000028                M 	__midpos:	= __endpos
0000D857                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D857                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D857 E8                       M 	dc.b	fpal0
0000D858 =00000029                M 	__lpos:	set __endpos+1
0000D858 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D858                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D858 6136 3A20                M 	dc.b	"a6: "
0000D85C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D85C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D85C =00000034                M 	__midpos:	= __endpos
0000D85C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D85C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D85C EC                       M 	dc.b	fpal2
0000D85D =00000035                M 	__lpos:	set __endpos+1
0000D85D =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D85D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D85D                          M 	dc.b	""
0000D85D =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D85D =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D85D =0000003C                M 	__midpos:	= __endpos
0000D85D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D85D                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D85D                          M 	__param:	substr ,,"hex"
0000D85D 83                       M 	dc.b	hex|3
0000D85E =0000003D                M 	__lpos:	set __endpos+1
0000D85E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D85E                          M 	__substr:	substr __lpos,,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D85E                          M 	dc.b	""
0000D85E 00                       M 	dc.b	0
0000D860 00                       M 	even
0000D860                          M 	.instr_end_414:
0000D860                            	Console.WriteLine "  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D860 40E7                     M 	move.w	sr,-(sp)
0000D862                          M 	__fstring_generateargumentscode	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862 =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D862 =00000000                M 	__stack:set	0
0000D862 =00000000                M 	__sp:	set 0
0000D862                          M 	while	(__pos)
0000D862 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D862 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D862 =0000000A                M 	__midpos:	= __endpos
0000D862                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D862 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D862 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D862 =00000016                M 	__midpos:	= __endpos
0000D862                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D862 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D862 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D862 =0000001E                M 	__midpos:	= __endpos
0000D862                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	pushp	"move.l d7,-(sp)"
0000D862 =00000001                M 	__stack:	= __stack+1
0000D862 =00000004                M 	__sp:	= __sp+4
0000D862 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D862 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D862 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D862 =00000028                M 	__midpos:	= __endpos
0000D862                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D862 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D862 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D862 =00000034                M 	__midpos:	= __endpos
0000D862                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D862 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D862 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D862 =0000003C                M 	__midpos:	= __endpos
0000D862                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D862                          M 	pushp	"move.l a7,-(sp)"
0000D862 =00000002                M 	__stack:	= __stack+1
0000D862 =00000008                M 	__sp:	= __sp+4
0000D862 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D862                          M 	rept	__stack
0000D862                          M 	popp	__command
0000D862 2F0F                     M 	move.l	a7,-(sp)
0000D864                          M 	popp	__command
0000D864 2F07                     M 	move.l	d7,-(sp)
0000D866 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D86A 45EF 0010                M 	lea	4*4(sp),a2
0000D86E 43FA 0000                M 	lea	.str_417(pc),a1
0000D872 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D878 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D87C 504F                     M 	addq.w	#__sp,sp
0000D87E 46DF                     M 	move.w	(sp)+,sr
0000D880 6000 0000                M 	bra.w	.instr_end_417
0000D884                          M 	.str_417:
0000D884                          M 	__fstring_generatedecodedstring	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D884 =00000001                M 	__lpos:	set 1
0000D884 =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D884                          M 	while	(__pos)
0000D884                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D884 2020                     M 	dc.b	"  "
0000D886 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D886 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D886 =0000000A                M 	__midpos:	= __endpos
0000D886                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D886                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D886 E8                       M 	dc.b	fpal0
0000D887 =0000000B                M 	__lpos:	set __endpos+1
0000D887 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D887                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D887 6437 3A20                M 	dc.b	"d7: "
0000D88B =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D88B =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D88B =00000016                M 	__midpos:	= __endpos
0000D88B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D88B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D88B EC                       M 	dc.b	fpal2
0000D88C =00000017                M 	__lpos:	set __endpos+1
0000D88C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D88C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D88C                          M 	dc.b	""
0000D88C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D88C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D88C =0000001E                M 	__midpos:	= __endpos
0000D88C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D88C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D88C                          M 	__param:	substr ,,"hex"
0000D88C 83                       M 	dc.b	hex|3
0000D88D =0000001F                M 	__lpos:	set __endpos+1
0000D88D =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D88D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D88D 2020                     M 	dc.b	"  "
0000D88F =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D88F =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D88F =00000028                M 	__midpos:	= __endpos
0000D88F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D88F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D88F E8                       M 	dc.b	fpal0
0000D890 =00000029                M 	__lpos:	set __endpos+1
0000D890 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D890                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D890 7370 3A20                M 	dc.b	"sp: "
0000D894 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D894 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D894 =00000034                M 	__midpos:	= __endpos
0000D894                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D894                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D894 EC                       M 	dc.b	fpal2
0000D895 =00000035                M 	__lpos:	set __endpos+1
0000D895 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D895                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D895                          M 	dc.b	""
0000D895 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D895 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D895 =0000003C                M 	__midpos:	= __endpos
0000D895                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D895                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D895                          M 	__param:	substr ,,"hex"
0000D895 83                       M 	dc.b	hex|3
0000D896 =0000003D                M 	__lpos:	set __endpos+1
0000D896 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D896                          M 	__substr:	substr __lpos,,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D896                          M 	dc.b	""
0000D896 00                       M 	dc.b	0
0000D898 00                       M 	even
0000D898                          M 	.instr_end_417:
0000D898                            	Console.BreakLine
0000D898 40E7                     M 	move.w	sr,-(sp)
0000D89A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D8A0 46DF                     M 	move.w	(sp)+,sr
0000D8A2                            
0000D8A2                            	Console.Write	  "%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A2 40E7                     M 	move.w	sr,-(sp)
0000D8A4                          M 	__fstring_generateargumentscode	"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4 =00000001                M 	__pos:	set instr("%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8A4 =00000000                M 	__stack:set	0
0000D8A4 =00000000                M 	__sp:	set 0
0000D8A4                          M 	while	(__pos)
0000D8A4 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000D8A4 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000D8A4 =00000008                M 	__midpos:	= __endpos
0000D8A4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8A4 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000D8A4 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000D8A4 =00000018                M 	__midpos:	= __endpos
0000D8A4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8A4 =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000D8A4 =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000D8A4 =00000026                M 	__midpos:	= __endpos
0000D8A4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	pushp	"move.b mFlags.w,1(sp)"
0000D8A4                          M 	pushp	"subq.w	#2, sp"
0000D8A4 =00000002                M 	__stack:	= __stack+2
0000D8A4 =00000002                M 	__sp:	= __sp+2
0000D8A4 =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8A4 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000D8A4 =00000037                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000D8A4 =00000036                M 	__midpos:	= __endpos
0000D8A4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8A4                          M 	pushp	"move.b mCtrPal.w,1(sp)"
0000D8A4                          M 	pushp	"subq.w	#2, sp"
0000D8A4 =00000004                M 	__stack:	= __stack+2
0000D8A4 =00000004                M 	__sp:	= __sp+2
0000D8A4 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8A4                          M 	rept	__stack
0000D8A4                          M 	popp	__command
0000D8A4 554F                     M 	subq.w	#2,sp
0000D8A6                          M 	popp	__command
0000D8A6 1F78 C4A7 0001           M 	move.b	mctrpal.w,1(sp)
0000D8AC                          M 	popp	__command
0000D8AC 554F                     M 	subq.w	#2,sp
0000D8AE                          M 	popp	__command
0000D8AE 1F78 C4A6 0001           M 	move.b	mflags.w,1(sp)
0000D8B4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D8B8 45EF 0010                M 	lea	4*4(sp),a2
0000D8BC 43FA 0000                M 	lea	.str_421(pc),a1
0000D8C0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D8C6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D8CA 584F                     M 	addq.w	#__sp,sp
0000D8CC 46DF                     M 	move.w	(sp)+,sr
0000D8CE 6000 0000                M 	bra.w	.instr_end_421
0000D8D2                          M 	.str_421:
0000D8D2                          M 	__fstring_generatedecodedstring	"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8D2 =00000001                M 	__lpos:	set 1
0000D8D2 =00000001                M 	__pos:	set instr("%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8D2                          M 	while	(__pos)
0000D8D2                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8D2                          M 	dc.b	""
0000D8D2 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000D8D2 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000D8D2 =00000008                M 	__midpos:	= __endpos
0000D8D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8D2                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8D2 EA                       M 	dc.b	fpal1
0000D8D3 =00000009                M 	__lpos:	set __endpos+1
0000D8D3 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8D3                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8D3 4D69 7363 3A20 2020      M 	dc.b	"Misc:   "
0000D8DB =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000D8DB =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000D8DB =00000018                M 	__midpos:	= __endpos
0000D8DB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8DB                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8DB EC                       M 	dc.b	fpal2
0000D8DC =00000019                M 	__lpos:	set __endpos+1
0000D8DC =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8DC                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8DC                          M 	dc.b	""
0000D8DC =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000D8DC =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000D8DC =00000026                M 	__midpos:	= __endpos
0000D8DC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8DC                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8DC                          M 	__param:	substr ,,"hex"
0000D8DC 80                       M 	dc.b	hex
0000D8DD =00000027                M 	__lpos:	set __endpos+1
0000D8DD =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8DD                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8DD 20                       M 	dc.b	" "
0000D8DE =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000D8DE =00000037                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000D8DE =00000036                M 	__midpos:	= __endpos
0000D8DE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8DE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8DE                          M 	__param:	substr ,,"hex"
0000D8DE 80                       M 	dc.b	hex
0000D8DF =00000037                M 	__lpos:	set __endpos+1
0000D8DF =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000D8DF                          M 	__substr:	substr __lpos,,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000D8DF 20                       M 	dc.b	" "
0000D8E0 00                       M 	dc.b	0
0000D8E2 00                       M 	even
0000D8E2                          M 	.instr_end_421:
0000D8E2                            	Console.WriteLine "%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E2 40E7                     M 	move.w	sr,-(sp)
0000D8E4                          M 	__fstring_generateargumentscode	"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4 =00000001                M 	__pos:	set instr("%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000D8E4 =00000000                M 	__stack:set	0
0000D8E4 =00000000                M 	__sp:	set 0
0000D8E4                          M 	while	(__pos)
0000D8E4 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000D8E4 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000D8E4 =00000011                M 	__midpos:	= __endpos
0000D8E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	pushp	"move.b mSpindash.w,1(sp)"
0000D8E4                          M 	pushp	"subq.w	#2, sp"
0000D8E4 =00000002                M 	__stack:	= __stack+2
0000D8E4 =00000002                M 	__sp:	= __sp+2
0000D8E4 =00000013                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000D8E4 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000D8E4 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000D8E4 =00000022                M 	__midpos:	= __endpos
0000D8E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	pushp	"move.b mContCtr.w,1(sp)"
0000D8E4                          M 	pushp	"subq.w	#2, sp"
0000D8E4 =00000004                M 	__stack:	= __stack+2
0000D8E4 =00000004                M 	__sp:	= __sp+2
0000D8E4 =00000024                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000D8E4 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000D8E4 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000D8E4 =00000034                M 	__midpos:	= __endpos
0000D8E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D8E4                          M 	pushp	"move.b mContLast.w,1(sp)"
0000D8E4                          M 	pushp	"subq.w	#2, sp"
0000D8E4 =00000006                M 	__stack:	= __stack+2
0000D8E4 =00000006                M 	__sp:	= __sp+2
0000D8E4 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000D8E4                          M 	rept	__stack
0000D8E4                          M 	popp	__command
0000D8E4 554F                     M 	subq.w	#2,sp
0000D8E6                          M 	popp	__command
0000D8E6 1F78 C4C3 0001           M 	move.b	mcontlast.w,1(sp)
0000D8EC                          M 	popp	__command
0000D8EC 554F                     M 	subq.w	#2,sp
0000D8EE                          M 	popp	__command
0000D8EE 1F78 C4C2 0001           M 	move.b	mcontctr.w,1(sp)
0000D8F4                          M 	popp	__command
0000D8F4 554F                     M 	subq.w	#2,sp
0000D8F6                          M 	popp	__command
0000D8F6 1F78 C4C1 0001           M 	move.b	mspindash.w,1(sp)
0000D8FC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D900 45EF 0010                M 	lea	4*4(sp),a2
0000D904 43FA 0000                M 	lea	.str_424(pc),a1
0000D908 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D90E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D912 5C4F                     M 	addq.w	#__sp,sp
0000D914 46DF                     M 	move.w	(sp)+,sr
0000D916 6000 0000                M 	bra.w	.instr_end_424
0000D91A                          M 	.str_424:
0000D91A                          M 	__fstring_generatedecodedstring	"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91A =00000001                M 	__lpos:	set 1
0000D91A =00000001                M 	__pos:	set instr("%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000D91A                          M 	while	(__pos)
0000D91A                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91A                          M 	dc.b	""
0000D91A =00000011                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000D91A =00000012                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000D91A =00000011                M 	__midpos:	= __endpos
0000D91A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91A                          M 	__param:	substr ,,"hex"
0000D91A 80                       M 	dc.b	hex
0000D91B =00000012                M 	__lpos:	set __endpos+1
0000D91B =00000013                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000D91B                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91B 20                       M 	dc.b	" "
0000D91C =00000022                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000D91C =00000023                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000D91C =00000022                M 	__midpos:	= __endpos
0000D91C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91C                          M 	__param:	substr ,,"hex"
0000D91C 80                       M 	dc.b	hex
0000D91D =00000023                M 	__lpos:	set __endpos+1
0000D91D =00000024                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000D91D                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91D 20                       M 	dc.b	" "
0000D91E =00000034                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000D91E =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000D91E =00000034                M 	__midpos:	= __endpos
0000D91E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91E                          M 	__param:	substr ,,"hex"
0000D91E 80                       M 	dc.b	hex
0000D91F =00000035                M 	__lpos:	set __endpos+1
0000D91F =00000000                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000D91F                          M 	__substr:	substr __lpos,,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000D91F                          M 	dc.b	""
0000D91F 00                       M 	dc.b	0
0000D920                          M 	even
0000D920                          M 	.instr_end_424:
0000D920                            	Console.Write	  "%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D920 40E7                     M 	move.w	sr,-(sp)
0000D922                          M 	__fstring_generateargumentscode	"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922 =00000001                M 	__pos:	set instr("%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D922 =00000000                M 	__stack:set	0
0000D922 =00000000                M 	__sp:	set 0
0000D922                          M 	while	(__pos)
0000D922 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000D922 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000D922 =00000008                M 	__midpos:	= __endpos
0000D922                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D922 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000D922 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000D922 =00000018                M 	__midpos:	= __endpos
0000D922                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D922 =0000002A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000D922 =0000002B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000D922 =0000002A                M 	__midpos:	= __endpos
0000D922                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	pushp	"move.b mTempoMain.w,1(sp)"
0000D922                          M 	pushp	"subq.w	#2, sp"
0000D922 =00000002                M 	__stack:	= __stack+2
0000D922 =00000002                M 	__sp:	= __sp+2
0000D922 =0000002C                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D922 =0000003E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000D922 =0000003F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000D922 =0000003E                M 	__midpos:	= __endpos
0000D922                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D922                          M 	pushp	"move.b mTempoSpeed.w,1(sp)"
0000D922                          M 	pushp	"subq.w	#2, sp"
0000D922 =00000004                M 	__stack:	= __stack+2
0000D922 =00000004                M 	__sp:	= __sp+2
0000D922 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D922                          M 	rept	__stack
0000D922                          M 	popp	__command
0000D922 554F                     M 	subq.w	#2,sp
0000D924                          M 	popp	__command
0000D924 1F78 C4B9 0001           M 	move.b	mtempospeed.w,1(sp)
0000D92A                          M 	popp	__command
0000D92A 554F                     M 	subq.w	#2,sp
0000D92C                          M 	popp	__command
0000D92C 1F78 C4B8 0001           M 	move.b	mtempomain.w,1(sp)
0000D932 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D936 45EF 0010                M 	lea	4*4(sp),a2
0000D93A 43FA 0000                M 	lea	.str_427(pc),a1
0000D93E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D944 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D948 584F                     M 	addq.w	#__sp,sp
0000D94A 46DF                     M 	move.w	(sp)+,sr
0000D94C 6000 0000                M 	bra.w	.instr_end_427
0000D950                          M 	.str_427:
0000D950                          M 	__fstring_generatedecodedstring	"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D950 =00000001                M 	__lpos:	set 1
0000D950 =00000001                M 	__pos:	set instr("%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D950                          M 	while	(__pos)
0000D950                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D950                          M 	dc.b	""
0000D950 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000D950 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000D950 =00000008                M 	__midpos:	= __endpos
0000D950                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D950                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D950 EA                       M 	dc.b	fpal1
0000D951 =00000009                M 	__lpos:	set __endpos+1
0000D951 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D951                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D951 5465 6D70 6F3A 2020      M 	dc.b	"Tempo:  "
0000D959 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000D959 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000D959 =00000018                M 	__midpos:	= __endpos
0000D959                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D959                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D959 EC                       M 	dc.b	fpal2
0000D95A =00000019                M 	__lpos:	set __endpos+1
0000D95A =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D95A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D95A                          M 	dc.b	""
0000D95A =0000002A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000D95A =0000002B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000D95A =0000002A                M 	__midpos:	= __endpos
0000D95A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D95A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D95A                          M 	__param:	substr ,,"hex"
0000D95A 80                       M 	dc.b	hex
0000D95B =0000002B                M 	__lpos:	set __endpos+1
0000D95B =0000002C                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D95B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D95B 20                       M 	dc.b	" "
0000D95C =0000003E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000D95C =0000003F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000D95C =0000003E                M 	__midpos:	= __endpos
0000D95C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D95C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D95C                          M 	__param:	substr ,,"hex"
0000D95C 80                       M 	dc.b	hex
0000D95D =0000003F                M 	__lpos:	set __endpos+1
0000D95D =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000D95D                          M 	__substr:	substr __lpos,,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000D95D 20                       M 	dc.b	" "
0000D95E 00                       M 	dc.b	0
0000D960 00                       M 	even
0000D960                          M 	.instr_end_427:
0000D960                            	Console.WriteLine "%<.b mTempo.w> %<.b mTempoCur.w>"
0000D960 40E7                     M 	move.w	sr,-(sp)
0000D962                          M 	__fstring_generateargumentscode	"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D962 =00000001                M 	__pos:	set instr("%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000D962 =00000000                M 	__stack:set	0
0000D962 =00000000                M 	__sp:	set 0
0000D962                          M 	while	(__pos)
0000D962 =0000000E                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000D962 =0000000F                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000D962 =0000000E                M 	__midpos:	= __endpos
0000D962                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D962                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D962                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D962                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D962                          M 	pushp	"move.b mTempo.w,1(sp)"
0000D962                          M 	pushp	"subq.w	#2, sp"
0000D962 =00000002                M 	__stack:	= __stack+2
0000D962 =00000002                M 	__sp:	= __sp+2
0000D962 =00000010                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000D962 =00000020                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000D962 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000D962 =00000020                M 	__midpos:	= __endpos
0000D962                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D962                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D962                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D962                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D962                          M 	pushp	"move.b mTempoCur.w,1(sp)"
0000D962                          M 	pushp	"subq.w	#2, sp"
0000D962 =00000004                M 	__stack:	= __stack+2
0000D962 =00000004                M 	__sp:	= __sp+2
0000D962 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000D962                          M 	rept	__stack
0000D962                          M 	popp	__command
0000D962 554F                     M 	subq.w	#2,sp
0000D964                          M 	popp	__command
0000D964 1F78 C4BB 0001           M 	move.b	mtempocur.w,1(sp)
0000D96A                          M 	popp	__command
0000D96A 554F                     M 	subq.w	#2,sp
0000D96C                          M 	popp	__command
0000D96C 1F78 C4BA 0001           M 	move.b	mtempo.w,1(sp)
0000D972 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D976 45EF 0010                M 	lea	4*4(sp),a2
0000D97A 43FA 0000                M 	lea	.str_430(pc),a1
0000D97E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D984 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D988 584F                     M 	addq.w	#__sp,sp
0000D98A 46DF                     M 	move.w	(sp)+,sr
0000D98C 6000 0000                M 	bra.w	.instr_end_430
0000D990                          M 	.str_430:
0000D990                          M 	__fstring_generatedecodedstring	"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D990 =00000001                M 	__lpos:	set 1
0000D990 =00000001                M 	__pos:	set instr("%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000D990                          M 	while	(__pos)
0000D990                          M 	__substr:	substr __lpos,__pos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D990                          M 	dc.b	""
0000D990 =0000000E                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000D990 =0000000F                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000D990 =0000000E                M 	__midpos:	= __endpos
0000D990                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D990                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D990                          M 	__param:	substr ,,"hex"
0000D990 80                       M 	dc.b	hex
0000D991 =0000000F                M 	__lpos:	set __endpos+1
0000D991 =00000010                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000D991                          M 	__substr:	substr __lpos,__pos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D991 20                       M 	dc.b	" "
0000D992 =00000020                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000D992 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000D992 =00000020                M 	__midpos:	= __endpos
0000D992                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D992                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D992                          M 	__param:	substr ,,"hex"
0000D992 80                       M 	dc.b	hex
0000D993 =00000021                M 	__lpos:	set __endpos+1
0000D993 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000D993                          M 	__substr:	substr __lpos,,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000D993                          M 	dc.b	""
0000D993 00                       M 	dc.b	0
0000D994                          M 	even
0000D994                          M 	.instr_end_430:
0000D994                            	Console.Write	  "%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D994 40E7                     M 	move.w	sr,-(sp)
0000D996                          M 	__fstring_generateargumentscode	"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996 =00000001                M 	__pos:	set instr("%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D996 =00000000                M 	__stack:set	0
0000D996 =00000000                M 	__sp:	set 0
0000D996                          M 	while	(__pos)
0000D996 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000D996 =00000010                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000D996 =00000008                M 	__midpos:	= __endpos
0000D996                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D996 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000D996 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000D996 =00000018                M 	__midpos:	= __endpos
0000D996                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D996 =0000002C                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000D996 =0000002D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000D996 =0000002C                M 	__midpos:	= __endpos
0000D996                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	pushp	"move.b mMasterVolFM.w,1(sp)"
0000D996                          M 	pushp	"subq.w	#2, sp"
0000D996 =00000002                M 	__stack:	= __stack+2
0000D996 =00000002                M 	__sp:	= __sp+2
0000D996 =0000002E                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D996 =00000042                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000D996 =00000043                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000D996 =00000042                M 	__midpos:	= __endpos
0000D996                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D996                          M 	pushp	"move.b mMasterVolDAC.w,1(sp)"
0000D996                          M 	pushp	"subq.w	#2, sp"
0000D996 =00000004                M 	__stack:	= __stack+2
0000D996 =00000004                M 	__sp:	= __sp+2
0000D996 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D996                          M 	rept	__stack
0000D996                          M 	popp	__command
0000D996 554F                     M 	subq.w	#2,sp
0000D998                          M 	popp	__command
0000D998 1F78 C4C0 0001           M 	move.b	mmastervoldac.w,1(sp)
0000D99E                          M 	popp	__command
0000D99E 554F                     M 	subq.w	#2,sp
0000D9A0                          M 	popp	__command
0000D9A0 1F78 C4B4 0001           M 	move.b	mmastervolfm.w,1(sp)
0000D9A6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D9AA 45EF 0010                M 	lea	4*4(sp),a2
0000D9AE 43FA 0000                M 	lea	.str_433(pc),a1
0000D9B2 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D9B8 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D9BC 584F                     M 	addq.w	#__sp,sp
0000D9BE 46DF                     M 	move.w	(sp)+,sr
0000D9C0 6000 0000                M 	bra.w	.instr_end_433
0000D9C4                          M 	.str_433:
0000D9C4                          M 	__fstring_generatedecodedstring	"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9C4 =00000001                M 	__lpos:	set 1
0000D9C4 =00000001                M 	__pos:	set instr("%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D9C4                          M 	while	(__pos)
0000D9C4                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9C4                          M 	dc.b	""
0000D9C4 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000D9C4 =00000010                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000D9C4 =00000008                M 	__midpos:	= __endpos
0000D9C4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9C4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9C4 EA                       M 	dc.b	fpal1
0000D9C5 =00000009                M 	__lpos:	set __endpos+1
0000D9C5 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D9C5                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9C5 566F 6C75 6D65 3A20      M 	dc.b	"Volume: "
0000D9CD =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000D9CD =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000D9CD =00000018                M 	__midpos:	= __endpos
0000D9CD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9CD                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9CD EC                       M 	dc.b	fpal2
0000D9CE =00000019                M 	__lpos:	set __endpos+1
0000D9CE =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D9CE                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9CE                          M 	dc.b	""
0000D9CE =0000002C                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000D9CE =0000002D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000D9CE =0000002C                M 	__midpos:	= __endpos
0000D9CE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9CE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9CE                          M 	__param:	substr ,,"hex"
0000D9CE 80                       M 	dc.b	hex
0000D9CF =0000002D                M 	__lpos:	set __endpos+1
0000D9CF =0000002E                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D9CF                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9CF 20                       M 	dc.b	" "
0000D9D0 =00000042                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000D9D0 =00000043                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000D9D0 =00000042                M 	__midpos:	= __endpos
0000D9D0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9D0                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9D0                          M 	__param:	substr ,,"hex"
0000D9D0 80                       M 	dc.b	hex
0000D9D1 =00000043                M 	__lpos:	set __endpos+1
0000D9D1 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000D9D1                          M 	__substr:	substr __lpos,,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000D9D1 20                       M 	dc.b	" "
0000D9D2 00                       M 	dc.b	0
0000D9D4 00                       M 	even
0000D9D4                          M 	.instr_end_433:
0000D9D4                            	Console.WriteLine "%<.b mMasterVolPSG.w>"
0000D9D4 40E7                     M 	move.w	sr,-(sp)
0000D9D6                          M 	__fstring_generateargumentscode	"%<.b mMasterVolPSG.w>"
0000D9D6 =00000001                M 	__pos:	set instr("%<.b mMasterVolPSG.w>",'%<')
0000D9D6 =00000000                M 	__stack:set	0
0000D9D6 =00000000                M 	__sp:	set 0
0000D9D6                          M 	while	(__pos)
0000D9D6 =00000015                M 	__endpos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'>')
0000D9D6 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mMasterVolPSG.w>",' ')
0000D9D6 =00000015                M 	__midpos:	= __endpos
0000D9D6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000D9D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mMasterVolPSG.w>"
0000D9D6                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mMasterVolPSG.w>"
0000D9D6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000D9D6                          M 	pushp	"move.b mMasterVolPSG.w,1(sp)"
0000D9D6                          M 	pushp	"subq.w	#2, sp"
0000D9D6 =00000002                M 	__stack:	= __stack+2
0000D9D6 =00000002                M 	__sp:	= __sp+2
0000D9D6 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'%<')
0000D9D6                          M 	rept	__stack
0000D9D6                          M 	popp	__command
0000D9D6 554F                     M 	subq.w	#2,sp
0000D9D8                          M 	popp	__command
0000D9D8 1F78 C4BF 0001           M 	move.b	mmastervolpsg.w,1(sp)
0000D9DE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D9E2 45EF 0010                M 	lea	4*4(sp),a2
0000D9E6 43FA 0000                M 	lea	.str_436(pc),a1
0000D9EA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D9F0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D9F4 544F                     M 	addq.w	#__sp,sp
0000D9F6 46DF                     M 	move.w	(sp)+,sr
0000D9F8 6000 0000                M 	bra.w	.instr_end_436
0000D9FC                          M 	.str_436:
0000D9FC                          M 	__fstring_generatedecodedstring	"%<.b mMasterVolPSG.w>"
0000D9FC =00000001                M 	__lpos:	set 1
0000D9FC =00000001                M 	__pos:	set instr("%<.b mMasterVolPSG.w>",'%<')
0000D9FC                          M 	while	(__pos)
0000D9FC                          M 	__substr:	substr __lpos,__pos-1,"%<.b mMasterVolPSG.w>"
0000D9FC                          M 	dc.b	""
0000D9FC =00000015                M 	__endpos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'>')
0000D9FC =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mMasterVolPSG.w>",' ')
0000D9FC =00000015                M 	__midpos:	= __endpos
0000D9FC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mMasterVolPSG.w>"
0000D9FC                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000D9FC                          M 	__param:	substr ,,"hex"
0000D9FC 80                       M 	dc.b	hex
0000D9FD =00000016                M 	__lpos:	set __endpos+1
0000D9FD =00000000                M 	__pos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'%<')
0000D9FD                          M 	__substr:	substr __lpos,,"%<.b mMasterVolPSG.w>"
0000D9FD                          M 	dc.b	""
0000D9FD 00                       M 	dc.b	0
0000D9FE                          M 	even
0000D9FE                          M 	.instr_end_436:
0000D9FE                            	Console.WriteLine "%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000D9FE 40E7                     M 	move.w	sr,-(sp)
0000DA00                          M 	__fstring_generateargumentscode	"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00 =00000001                M 	__pos:	set instr("%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA00 =00000000                M 	__stack:set	0
0000DA00 =00000000                M 	__sp:	set 0
0000DA00                          M 	while	(__pos)
0000DA00 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA00 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA00 =00000008                M 	__midpos:	= __endpos
0000DA00                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA00 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA00 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA00 =00000018                M 	__midpos:	= __endpos
0000DA00                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA00 =00000034                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA00 =00000029                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA00                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00                          M 	pushp	"move.l mFadeAddr.w,-(sp)"
0000DA00 =00000001                M 	__stack:	= __stack+1
0000DA00 =00000004                M 	__sp:	= __sp+4
0000DA00 =00000035                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA00 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA00 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA00 =00000045                M 	__midpos:	= __endpos
0000DA00                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA00 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA00                          M 	rept	__stack
0000DA00                          M 	popp	__command
0000DA00 2F38 C4B4                M 	move.l	mfadeaddr.w,-(sp)
0000DA04 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA08 45EF 0010                M 	lea	4*4(sp),a2
0000DA0C 43FA 0000                M 	lea	.str_439(pc),a1
0000DA10 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA16 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA1A 584F                     M 	addq.w	#__sp,sp
0000DA1C 46DF                     M 	move.w	(sp)+,sr
0000DA1E 6000 0000                M 	bra.w	.instr_end_439
0000DA22                          M 	.str_439:
0000DA22                          M 	__fstring_generatedecodedstring	"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA22 =00000001                M 	__lpos:	set 1
0000DA22 =00000001                M 	__pos:	set instr("%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA22                          M 	while	(__pos)
0000DA22                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA22                          M 	dc.b	""
0000DA22 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA22 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA22 =00000008                M 	__midpos:	= __endpos
0000DA22                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA22                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA22 EA                       M 	dc.b	fpal1
0000DA23 =00000009                M 	__lpos:	set __endpos+1
0000DA23 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA23                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA23 4661 6465 3A20 2020      M 	dc.b	"Fade:   "
0000DA2B =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA2B =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA2B =00000018                M 	__midpos:	= __endpos
0000DA2B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA2B                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA2B E8                       M 	dc.b	fpal0
0000DA2C =00000019                M 	__lpos:	set __endpos+1
0000DA2C =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA2C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA2C                          M 	dc.b	""
0000DA2C =00000034                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA2C =00000029                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA2C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA2C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA2C BB                       M 	dc.b	sym|fsplit|3
0000DA2D =00000035                M 	__lpos:	set __endpos+1
0000DA2D =00000035                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA2D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA2D                          M 	dc.b	""
0000DA2D =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA2D =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA2D =00000045                M 	__midpos:	= __endpos
0000DA2D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA2D                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA2D ECC0                     M 	dc.b	fpal2,fsymdisp
0000DA2F =00000046                M 	__lpos:	set __endpos+1
0000DA2F =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA2F                          M 	__substr:	substr __lpos,,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DA2F                          M 	dc.b	""
0000DA2F 00                       M 	dc.b	0
0000DA30                          M 	even
0000DA30                          M 	.instr_end_439:
0000DA30                            	Console.WriteLine "%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA30 40E7                     M 	move.w	sr,-(sp)
0000DA32                          M 	__fstring_generateargumentscode	"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32 =00000001                M 	__pos:	set instr("%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA32 =00000000                M 	__stack:set	0
0000DA32 =00000000                M 	__sp:	set 0
0000DA32                          M 	while	(__pos)
0000DA32 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA32 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA32 =00000008                M 	__midpos:	= __endpos
0000DA32                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA32 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA32 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA32 =00000018                M 	__midpos:	= __endpos
0000DA32                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA32 =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA32 =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA32 =00000026                M 	__midpos:	= __endpos
0000DA32                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	pushp	"move.b mQueue.w,1(sp)"
0000DA32                          M 	pushp	"subq.w	#2, sp"
0000DA32 =00000002                M 	__stack:	= __stack+2
0000DA32 =00000002                M 	__sp:	= __sp+2
0000DA32 =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA32 =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA32 =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA32 =00000037                M 	__midpos:	= __endpos
0000DA32                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	pushp	"move.b mQueue+1.w,1(sp)"
0000DA32                          M 	pushp	"subq.w	#2, sp"
0000DA32 =00000004                M 	__stack:	= __stack+2
0000DA32 =00000004                M 	__sp:	= __sp+2
0000DA32 =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA32 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA32 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA32 =00000048                M 	__midpos:	= __endpos
0000DA32                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA32                          M 	pushp	"move.b mQueue+2.w,1(sp)"
0000DA32                          M 	pushp	"subq.w	#2, sp"
0000DA32 =00000006                M 	__stack:	= __stack+2
0000DA32 =00000006                M 	__sp:	= __sp+2
0000DA32 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA32                          M 	rept	__stack
0000DA32                          M 	popp	__command
0000DA32 554F                     M 	subq.w	#2,sp
0000DA34                          M 	popp	__command
0000DA34 1F78 C4BE 0001           M 	move.b	mqueue+2.w,1(sp)
0000DA3A                          M 	popp	__command
0000DA3A 554F                     M 	subq.w	#2,sp
0000DA3C                          M 	popp	__command
0000DA3C 1F78 C4BD 0001           M 	move.b	mqueue+1.w,1(sp)
0000DA42                          M 	popp	__command
0000DA42 554F                     M 	subq.w	#2,sp
0000DA44                          M 	popp	__command
0000DA44 1F78 C4BC 0001           M 	move.b	mqueue.w,1(sp)
0000DA4A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA4E 45EF 0010                M 	lea	4*4(sp),a2
0000DA52 43FA 0000                M 	lea	.str_442(pc),a1
0000DA56 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA5C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA60 5C4F                     M 	addq.w	#__sp,sp
0000DA62 46DF                     M 	move.w	(sp)+,sr
0000DA64 6000 0000                M 	bra.w	.instr_end_442
0000DA68                          M 	.str_442:
0000DA68                          M 	__fstring_generatedecodedstring	"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA68 =00000001                M 	__lpos:	set 1
0000DA68 =00000001                M 	__pos:	set instr("%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA68                          M 	while	(__pos)
0000DA68                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA68                          M 	dc.b	""
0000DA68 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA68 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA68 =00000008                M 	__midpos:	= __endpos
0000DA68                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA68                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA68 EA                       M 	dc.b	fpal1
0000DA69 =00000009                M 	__lpos:	set __endpos+1
0000DA69 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA69                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA69 5175 6575 653A 2020      M 	dc.b	"Queue:  "
0000DA71 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA71 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA71 =00000018                M 	__midpos:	= __endpos
0000DA71                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA71                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA71 EC                       M 	dc.b	fpal2
0000DA72 =00000019                M 	__lpos:	set __endpos+1
0000DA72 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA72                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA72                          M 	dc.b	""
0000DA72 =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA72 =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA72 =00000026                M 	__midpos:	= __endpos
0000DA72                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA72                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA72                          M 	__param:	substr ,,"hex"
0000DA72 80                       M 	dc.b	hex
0000DA73 =00000027                M 	__lpos:	set __endpos+1
0000DA73 =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA73                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA73 20                       M 	dc.b	" "
0000DA74 =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA74 =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA74 =00000037                M 	__midpos:	= __endpos
0000DA74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA74                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA74                          M 	__param:	substr ,,"hex"
0000DA74 80                       M 	dc.b	hex
0000DA75 =00000038                M 	__lpos:	set __endpos+1
0000DA75 =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA75                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA75 20                       M 	dc.b	" "
0000DA76 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DA76 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DA76 =00000048                M 	__midpos:	= __endpos
0000DA76                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA76                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA76                          M 	__param:	substr ,,"hex"
0000DA76 80                       M 	dc.b	hex
0000DA77 =00000049                M 	__lpos:	set __endpos+1
0000DA77 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DA77                          M 	__substr:	substr __lpos,,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DA77                          M 	dc.b	""
0000DA77 00                       M 	dc.b	0
0000DA78                          M 	even
0000DA78                          M 	.instr_end_442:
0000DA78                            	Console.Write	  "%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA78 40E7                     M 	move.w	sr,-(sp)
0000DA7A                          M 	__fstring_generateargumentscode	"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A =00000001                M 	__pos:	set instr("%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DA7A =00000000                M 	__stack:set	0
0000DA7A =00000000                M 	__sp:	set 0
0000DA7A                          M 	while	(__pos)
0000DA7A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DA7A =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DA7A =00000008                M 	__midpos:	= __endpos
0000DA7A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DA7A =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DA7A =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DA7A =00000018                M 	__midpos:	= __endpos
0000DA7A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DA7A =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DA7A =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DA7A =00000025                M 	__midpos:	= __endpos
0000DA7A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	pushp	"move.b mComm.w,1(sp)"
0000DA7A                          M 	pushp	"subq.w	#2, sp"
0000DA7A =00000002                M 	__stack:	= __stack+2
0000DA7A =00000002                M 	__sp:	= __sp+2
0000DA7A =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DA7A =00000035                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DA7A =00000036                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DA7A =00000035                M 	__midpos:	= __endpos
0000DA7A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	pushp	"move.b mComm+1.w,1(sp)"
0000DA7A                          M 	pushp	"subq.w	#2, sp"
0000DA7A =00000004                M 	__stack:	= __stack+2
0000DA7A =00000004                M 	__sp:	= __sp+2
0000DA7A =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DA7A =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DA7A =00000046                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DA7A =00000045                M 	__midpos:	= __endpos
0000DA7A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DA7A                          M 	pushp	"move.b mComm+2.w,1(sp)"
0000DA7A                          M 	pushp	"subq.w	#2, sp"
0000DA7A =00000006                M 	__stack:	= __stack+2
0000DA7A =00000006                M 	__sp:	= __sp+2
0000DA7A =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DA7A                          M 	rept	__stack
0000DA7A                          M 	popp	__command
0000DA7A 554F                     M 	subq.w	#2,sp
0000DA7C                          M 	popp	__command
0000DA7C 1F78 C4AE 0001           M 	move.b	mcomm+2.w,1(sp)
0000DA82                          M 	popp	__command
0000DA82 554F                     M 	subq.w	#2,sp
0000DA84                          M 	popp	__command
0000DA84 1F78 C4AD 0001           M 	move.b	mcomm+1.w,1(sp)
0000DA8A                          M 	popp	__command
0000DA8A 554F                     M 	subq.w	#2,sp
0000DA8C                          M 	popp	__command
0000DA8C 1F78 C4AC 0001           M 	move.b	mcomm.w,1(sp)
0000DA92 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA96 45EF 0010                M 	lea	4*4(sp),a2
0000DA9A 43FA 0000                M 	lea	.str_445(pc),a1
0000DA9E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DAA4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DAA8 5C4F                     M 	addq.w	#__sp,sp
0000DAAA 46DF                     M 	move.w	(sp)+,sr
0000DAAC 6000 0000                M 	bra.w	.instr_end_445
0000DAB0                          M 	.str_445:
0000DAB0                          M 	__fstring_generatedecodedstring	"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DAB0 =00000001                M 	__lpos:	set 1
0000DAB0 =00000001                M 	__pos:	set instr("%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DAB0                          M 	while	(__pos)
0000DAB0                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DAB0                          M 	dc.b	""
0000DAB0 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DAB0 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DAB0 =00000008                M 	__midpos:	= __endpos
0000DAB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DAB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DAB0 EA                       M 	dc.b	fpal1
0000DAB1 =00000009                M 	__lpos:	set __endpos+1
0000DAB1 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DAB1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DAB1 436F 6D6D 3A20 2020      M 	dc.b	"Comm:   "
0000DAB9 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DAB9 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DAB9 =00000018                M 	__midpos:	= __endpos
0000DAB9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DAB9                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DAB9 EC                       M 	dc.b	fpal2
0000DABA =00000019                M 	__lpos:	set __endpos+1
0000DABA =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DABA                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABA                          M 	dc.b	""
0000DABA =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DABA =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DABA =00000025                M 	__midpos:	= __endpos
0000DABA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABA                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABA                          M 	__param:	substr ,,"hex"
0000DABA 80                       M 	dc.b	hex
0000DABB =00000026                M 	__lpos:	set __endpos+1
0000DABB =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DABB                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABB 20                       M 	dc.b	" "
0000DABC =00000035                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DABC =00000036                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DABC =00000035                M 	__midpos:	= __endpos
0000DABC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABC                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABC                          M 	__param:	substr ,,"hex"
0000DABC 80                       M 	dc.b	hex
0000DABD =00000036                M 	__lpos:	set __endpos+1
0000DABD =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DABD                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABD 20                       M 	dc.b	" "
0000DABE =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DABE =00000046                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DABE =00000045                M 	__midpos:	= __endpos
0000DABE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABE                          M 	__param:	substr ,,"hex"
0000DABE 80                       M 	dc.b	hex
0000DABF =00000046                M 	__lpos:	set __endpos+1
0000DABF =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DABF                          M 	__substr:	substr __lpos,,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DABF 20                       M 	dc.b	" "
0000DAC0 00                       M 	dc.b	0
0000DAC2 00                       M 	even
0000DAC2                          M 	.instr_end_445:
0000DAC2                            	Console.Write	  "%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC2 40E7                     M 	move.w	sr,-(sp)
0000DAC4                          M 	__fstring_generateargumentscode	"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4 =00000001                M 	__pos:	set instr("%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DAC4 =00000000                M 	__stack:set	0
0000DAC4 =00000000                M 	__sp:	set 0
0000DAC4                          M 	while	(__pos)
0000DAC4 =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DAC4 =00000010                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DAC4 =0000000F                M 	__midpos:	= __endpos
0000DAC4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	pushp	"move.b mComm+3.w,1(sp)"
0000DAC4                          M 	pushp	"subq.w	#2, sp"
0000DAC4 =00000002                M 	__stack:	= __stack+2
0000DAC4 =00000002                M 	__sp:	= __sp+2
0000DAC4 =00000011                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DAC4 =0000001F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DAC4 =00000020                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DAC4 =0000001F                M 	__midpos:	= __endpos
0000DAC4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	pushp	"move.b mComm+4.w,1(sp)"
0000DAC4                          M 	pushp	"subq.w	#2, sp"
0000DAC4 =00000004                M 	__stack:	= __stack+2
0000DAC4 =00000004                M 	__sp:	= __sp+2
0000DAC4 =00000021                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DAC4 =0000002F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DAC4 =00000030                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DAC4 =0000002F                M 	__midpos:	= __endpos
0000DAC4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	pushp	"move.b mComm+5.w,1(sp)"
0000DAC4                          M 	pushp	"subq.w	#2, sp"
0000DAC4 =00000006                M 	__stack:	= __stack+2
0000DAC4 =00000006                M 	__sp:	= __sp+2
0000DAC4 =00000031                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DAC4 =0000003F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DAC4 =00000040                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DAC4 =0000003F                M 	__midpos:	= __endpos
0000DAC4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DAC4                          M 	pushp	"move.b mComm+6.w,1(sp)"
0000DAC4                          M 	pushp	"subq.w	#2, sp"
0000DAC4 =00000008                M 	__stack:	= __stack+2
0000DAC4 =00000008                M 	__sp:	= __sp+2
0000DAC4 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DAC4                          M 	rept	__stack
0000DAC4                          M 	popp	__command
0000DAC4 554F                     M 	subq.w	#2,sp
0000DAC6                          M 	popp	__command
0000DAC6 1F78 C4B2 0001           M 	move.b	mcomm+6.w,1(sp)
0000DACC                          M 	popp	__command
0000DACC 554F                     M 	subq.w	#2,sp
0000DACE                          M 	popp	__command
0000DACE 1F78 C4B1 0001           M 	move.b	mcomm+5.w,1(sp)
0000DAD4                          M 	popp	__command
0000DAD4 554F                     M 	subq.w	#2,sp
0000DAD6                          M 	popp	__command
0000DAD6 1F78 C4B0 0001           M 	move.b	mcomm+4.w,1(sp)
0000DADC                          M 	popp	__command
0000DADC 554F                     M 	subq.w	#2,sp
0000DADE                          M 	popp	__command
0000DADE 1F78 C4AF 0001           M 	move.b	mcomm+3.w,1(sp)
0000DAE4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DAE8 45EF 0010                M 	lea	4*4(sp),a2
0000DAEC 43FA 0000                M 	lea	.str_448(pc),a1
0000DAF0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DAF6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DAFA 504F                     M 	addq.w	#__sp,sp
0000DAFC 46DF                     M 	move.w	(sp)+,sr
0000DAFE 6000 0000                M 	bra.w	.instr_end_448
0000DB02                          M 	.str_448:
0000DB02                          M 	__fstring_generatedecodedstring	"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB02 =00000001                M 	__lpos:	set 1
0000DB02 =00000001                M 	__pos:	set instr("%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DB02                          M 	while	(__pos)
0000DB02                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB02                          M 	dc.b	""
0000DB02 =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DB02 =00000010                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DB02 =0000000F                M 	__midpos:	= __endpos
0000DB02                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB02                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB02                          M 	__param:	substr ,,"hex"
0000DB02 80                       M 	dc.b	hex
0000DB03 =00000010                M 	__lpos:	set __endpos+1
0000DB03 =00000011                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DB03                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB03 20                       M 	dc.b	" "
0000DB04 =0000001F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DB04 =00000020                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DB04 =0000001F                M 	__midpos:	= __endpos
0000DB04                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB04                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB04                          M 	__param:	substr ,,"hex"
0000DB04 80                       M 	dc.b	hex
0000DB05 =00000020                M 	__lpos:	set __endpos+1
0000DB05 =00000021                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DB05                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB05 20                       M 	dc.b	" "
0000DB06 =0000002F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DB06 =00000030                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DB06 =0000002F                M 	__midpos:	= __endpos
0000DB06                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB06                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB06                          M 	__param:	substr ,,"hex"
0000DB06 80                       M 	dc.b	hex
0000DB07 =00000030                M 	__lpos:	set __endpos+1
0000DB07 =00000031                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DB07                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB07 20                       M 	dc.b	" "
0000DB08 =0000003F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DB08 =00000040                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DB08 =0000003F                M 	__midpos:	= __endpos
0000DB08                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB08                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB08                          M 	__param:	substr ,,"hex"
0000DB08 80                       M 	dc.b	hex
0000DB09 =00000040                M 	__lpos:	set __endpos+1
0000DB09 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DB09                          M 	__substr:	substr __lpos,,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DB09 20                       M 	dc.b	" "
0000DB0A 00                       M 	dc.b	0
0000DB0C 00                       M 	even
0000DB0C                          M 	.instr_end_448:
0000DB0C                            	Console.WriteLine "%<.b mComm+7.w>"
0000DB0C 40E7                     M 	move.w	sr,-(sp)
0000DB0E                          M 	__fstring_generateargumentscode	"%<.b mComm+7.w>"
0000DB0E =00000001                M 	__pos:	set instr("%<.b mComm+7.w>",'%<')
0000DB0E =00000000                M 	__stack:set	0
0000DB0E =00000000                M 	__sp:	set 0
0000DB0E                          M 	while	(__pos)
0000DB0E =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+7.w>",'>')
0000DB0E =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mComm+7.w>",' ')
0000DB0E =0000000F                M 	__midpos:	= __endpos
0000DB0E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+7.w>"
0000DB0E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+7.w>"
0000DB0E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+7.w>"
0000DB0E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+7.w>"
0000DB0E                          M 	pushp	"move.b mComm+7.w,1(sp)"
0000DB0E                          M 	pushp	"subq.w	#2, sp"
0000DB0E =00000002                M 	__stack:	= __stack+2
0000DB0E =00000002                M 	__sp:	= __sp+2
0000DB0E =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+7.w>",'%<')
0000DB0E                          M 	rept	__stack
0000DB0E                          M 	popp	__command
0000DB0E 554F                     M 	subq.w	#2,sp
0000DB10                          M 	popp	__command
0000DB10 1F78 C4B3 0001           M 	move.b	mcomm+7.w,1(sp)
0000DB16 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DB1A 45EF 0010                M 	lea	4*4(sp),a2
0000DB1E 43FA 0000                M 	lea	.str_451(pc),a1
0000DB22 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB28 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB2C 544F                     M 	addq.w	#__sp,sp
0000DB2E 46DF                     M 	move.w	(sp)+,sr
0000DB30 6000 0000                M 	bra.w	.instr_end_451
0000DB34                          M 	.str_451:
0000DB34                          M 	__fstring_generatedecodedstring	"%<.b mComm+7.w>"
0000DB34 =00000001                M 	__lpos:	set 1
0000DB34 =00000001                M 	__pos:	set instr("%<.b mComm+7.w>",'%<')
0000DB34                          M 	while	(__pos)
0000DB34                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+7.w>"
0000DB34                          M 	dc.b	""
0000DB34 =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+7.w>",'>')
0000DB34 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mComm+7.w>",' ')
0000DB34 =0000000F                M 	__midpos:	= __endpos
0000DB34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+7.w>"
0000DB34                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+7.w>"
0000DB34                          M 	__param:	substr ,,"hex"
0000DB34 80                       M 	dc.b	hex
0000DB35 =00000010                M 	__lpos:	set __endpos+1
0000DB35 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+7.w>",'%<')
0000DB35                          M 	__substr:	substr __lpos,,"%<.b mComm+7.w>"
0000DB35                          M 	dc.b	""
0000DB35 00                       M 	dc.b	0
0000DB36                          M 	even
0000DB36                          M 	.instr_end_451:
0000DB36                            
0000DB36                            .rts
0000DB36 4E75                       	rts
0000DB38                            ; ===========================================================================
0000DB38                            ; ---------------------------------------------------------------------------
0000DB38                            ; Invalid fade command handler
0000DB38                            ; ---------------------------------------------------------------------------
0000DB38                            
0000DB38                            AMPS_Debug_FadeCmd	macro
0000DB38                            	cmp.b	#fLast,d0	; check against max
0000DB38                            	bhs.s	.fail		; if in range, branch
0000DB38                            	cmp.b	#$80,d0		; check against min
0000DB38                            	blo.s	.fail		; if too little, bra
0000DB38                            	btst	#1,d0		; check if bit1 set
0000DB38                            	bne.s	.fail		; if is, branch
0000DB38                            	btst	#0,d0		; check if even
0000DB38                            	beq.s	.ok		; if is, branch
0000DB38                            .fail
0000DB38                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DB38                            		jsr	AMPS_DebugR_FadeCmd
0000DB38                            	else
0000DB38                            		bra.w	*
0000DB38                            	endif
0000DB38                            .ok
0000DB38                                endm
0000DB38                            
0000DB38                            AMPS_DebugR_FadeCmd:
0000DB38                            		RaiseError2 "Invalid Fade command: %<.b d0>", AMPS_Debug_Console_Main
0000DB38 40E7                     M 	move.w	sr,-(sp)
0000DB3A                          M 	__fstring_generateargumentscode	"Invalid Fade command: %<.b d0>"
0000DB3A =00000017                M 	__pos:	set instr("Invalid Fade command: %<.b d0>",'%<')
0000DB3A =00000000                M 	__stack:set	0
0000DB3A =00000000                M 	__sp:	set 0
0000DB3A                          M 	while	(__pos)
0000DB3A =0000001E                M 	__endpos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'>')
0000DB3A =00000000                M 	__midpos:	set instr(__pos+5,"Invalid Fade command: %<.b d0>",' ')
0000DB3A =0000001E                M 	__midpos:	= __endpos
0000DB3A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DB3A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid Fade command: %<.b d0>"
0000DB3A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid Fade command: %<.b d0>"
0000DB3A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DB3A                          M 	pushp	"move.b d0,1(sp)"
0000DB3A                          M 	pushp	"subq.w	#2, sp"
0000DB3A =00000002                M 	__stack:	= __stack+2
0000DB3A =00000002                M 	__sp:	= __sp+2
0000DB3A =00000000                M 	__pos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'%<')
0000DB3A                          M 	rept	__stack
0000DB3A                          M 	popp	__command
0000DB3A 554F                     M 	subq.w	#2,sp
0000DB3C                          M 	popp	__command
0000DB3C 1F40 0001                M 	move.b	d0,1(sp)
0000DB40 4EB9 0000 0000           M 	jsr	errorhandler
0000DB46                          M 	__fstring_generatedecodedstring	"Invalid Fade command: %<.b d0>"
0000DB46 =00000001                M 	__lpos:	set 1
0000DB46 =00000017                M 	__pos:	set instr("Invalid Fade command: %<.b d0>",'%<')
0000DB46                          M 	while	(__pos)
0000DB46                          M 	__substr:	substr __lpos,__pos-1,"Invalid Fade command: %<.b d0>"
0000DB46 496E 7661 6C69 6420 4661+M 	dc.b	"Invalid Fade command: "
0000DB5C =0000001E                M 	__endpos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'>')
0000DB5C =00000000                M 	__midpos:	set instr(__pos+5,"Invalid Fade command: %<.b d0>",' ')
0000DB5C =0000001E                M 	__midpos:	= __endpos
0000DB5C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid Fade command: %<.b d0>"
0000DB5C                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DB5C                          M 	__param:	substr ,,"hex"
0000DB5C 80                       M 	dc.b	hex
0000DB5D =0000001F                M 	__lpos:	set __endpos+1
0000DB5D =00000000                M 	__pos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'%<')
0000DB5D                          M 	__substr:	substr __lpos,,"Invalid Fade command: %<.b d0>"
0000DB5D                          M 	dc.b	""
0000DB5D 00                       M 	dc.b	0
0000DB5E 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DB60 00                       M 	even
0000DB60 4EFA FB76                M 	jmp	amps_debug_console_main
0000DB64                          M 	even
0000DB64                            ; ===========================================================================
0000DB64                            ; ---------------------------------------------------------------------------
0000DB64                            ; Invalid volume envelope handler
0000DB64                            ; ---------------------------------------------------------------------------
0000DB64                            
0000DB64                            AMPS_Debug_VolEnvID	macro
0000DB64                            	cmp.b	#(VolEnvs_End-VolEnvs)/4,d4	; check against max
0000DB64                            	bls.s	.ok			; if in range, branch
0000DB64                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DB64                            		jsr	AMPS_DebugR_VolEnvID
0000DB64                            	else
0000DB64                            		bra.w	*
0000DB64                            	endif
0000DB64                            .ok
0000DB64                                endm
0000DB64                            
0000DB64                            AMPS_DebugR_VolEnvID:
0000DB64                            		RaiseError2 "Volume envelope ID out of range: %<.b d4>", AMPS_Debug_Console_Channel
0000DB64 40E7                     M 	move.w	sr,-(sp)
0000DB66                          M 	__fstring_generateargumentscode	"Volume envelope ID out of range: %<.b d4>"
0000DB66 =00000022                M 	__pos:	set instr("Volume envelope ID out of range: %<.b d4>",'%<')
0000DB66 =00000000                M 	__stack:set	0
0000DB66 =00000000                M 	__sp:	set 0
0000DB66                          M 	while	(__pos)
0000DB66 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'>')
0000DB66 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope ID out of range: %<.b d4>",' ')
0000DB66 =00000029                M 	__midpos:	= __endpos
0000DB66                          M 	__substr:	substr __pos+1+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DB66                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope ID out of range: %<.b d4>"
0000DB66                          M 	__operand:	substr __pos+1+1,__midpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DB66                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DB66                          M 	pushp	"move.b d4,1(sp)"
0000DB66                          M 	pushp	"subq.w	#2, sp"
0000DB66 =00000002                M 	__stack:	= __stack+2
0000DB66 =00000002                M 	__sp:	= __sp+2
0000DB66 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'%<')
0000DB66                          M 	rept	__stack
0000DB66                          M 	popp	__command
0000DB66 554F                     M 	subq.w	#2,sp
0000DB68                          M 	popp	__command
0000DB68 1F44 0001                M 	move.b	d4,1(sp)
0000DB6C 4EB9 0000 0000           M 	jsr	errorhandler
0000DB72                          M 	__fstring_generatedecodedstring	"Volume envelope ID out of range: %<.b d4>"
0000DB72 =00000001                M 	__lpos:	set 1
0000DB72 =00000022                M 	__pos:	set instr("Volume envelope ID out of range: %<.b d4>",'%<')
0000DB72                          M 	while	(__pos)
0000DB72                          M 	__substr:	substr __lpos,__pos-1,"Volume envelope ID out of range: %<.b d4>"
0000DB72 566F 6C75 6D65 2065 6E76+M 	dc.b	"Volume envelope ID out of range: "
0000DB93 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'>')
0000DB93 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope ID out of range: %<.b d4>",' ')
0000DB93 =00000029                M 	__midpos:	= __endpos
0000DB93                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope ID out of range: %<.b d4>"
0000DB93                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DB93                          M 	__param:	substr ,,"hex"
0000DB93 80                       M 	dc.b	hex
0000DB94 =0000002A                M 	__lpos:	set __endpos+1
0000DB94 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'%<')
0000DB94                          M 	__substr:	substr __lpos,,"Volume envelope ID out of range: %<.b d4>"
0000DB94                          M 	dc.b	""
0000DB94 00                       M 	dc.b	0
0000DB95 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DB96                          M 	even
0000DB96 4EFA F39A                M 	jmp	amps_debug_console_channel
0000DB9A                          M 	even
0000DB9A                            ; ===========================================================================
0000DB9A                            ; ---------------------------------------------------------------------------
0000DB9A                            ; Invalid volume envelope command handler
0000DB9A                            ; ---------------------------------------------------------------------------
0000DB9A                            
0000DB9A                            AMPS_Debug_VolEnvCmd	macro
0000DB9A                            	cmp.b	#eLast,d0	; check against max
0000DB9A                            	bhs.s	.fail		; if too much, bra
0000DB9A                            	cmp.b	#$80,d0		; check against min
0000DB9A                            	blo.s	.fail		; if too little, bra
0000DB9A                            	btst	#0,d0		; check if even
0000DB9A                            	beq.s	.ok		; if is, branch
0000DB9A                            .fail
0000DB9A                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DB9A                            		RaiseError2 "Volume envelope command invalid: %<.b d0>", AMPS_Debug_Console_Channel
0000DB9A                            	else
0000DB9A                            		bra.w	*
0000DB9A                            	endif
0000DB9A                            .ok
0000DB9A                                endm
0000DB9A                            ; ===========================================================================
0000DB9A                            ; ---------------------------------------------------------------------------
0000DB9A                            ; PSG note check
0000DB9A                            ; ---------------------------------------------------------------------------
0000DB9A                            
0000DB9A                            AMPS_Debug_NotePSG	macro
0000DB9A                            	cmp.b	#dFreqPSG_-dFreqPSG,d5; check against max
0000DB9A                            	blo.s	.ok		; if too little, bra
0000DB9A                            .fail
0000DB9A                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DB9A                            		jsr	AMPS_DebugR_NotePSG
0000DB9A                            	else
0000DB9A                            		bra.w	*
0000DB9A                            	endif
0000DB9A                            .ok
0000DB9A                                endm
0000DB9A                            
0000DB9A                            AMPS_DebugR_NotePSG:
0000DB9A E24D                       		lsr.w	#1,d5	; get real note
0000DB9C                            		RaiseError2 "Invalid PSG note: %<.b d5>", AMPS_Debug_Console_Channel
0000DB9C 40E7                     M 	move.w	sr,-(sp)
0000DB9E                          M 	__fstring_generateargumentscode	"Invalid PSG note: %<.b d5>"
0000DB9E =00000013                M 	__pos:	set instr("Invalid PSG note: %<.b d5>",'%<')
0000DB9E =00000000                M 	__stack:set	0
0000DB9E =00000000                M 	__sp:	set 0
0000DB9E                          M 	while	(__pos)
0000DB9E =0000001A                M 	__endpos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'>')
0000DB9E =00000000                M 	__midpos:	set instr(__pos+5,"Invalid PSG note: %<.b d5>",' ')
0000DB9E =0000001A                M 	__midpos:	= __endpos
0000DB9E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DB9E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid PSG note: %<.b d5>"
0000DB9E                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid PSG note: %<.b d5>"
0000DB9E                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DB9E                          M 	pushp	"move.b d5,1(sp)"
0000DB9E                          M 	pushp	"subq.w	#2, sp"
0000DB9E =00000002                M 	__stack:	= __stack+2
0000DB9E =00000002                M 	__sp:	= __sp+2
0000DB9E =00000000                M 	__pos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'%<')
0000DB9E                          M 	rept	__stack
0000DB9E                          M 	popp	__command
0000DB9E 554F                     M 	subq.w	#2,sp
0000DBA0                          M 	popp	__command
0000DBA0 1F45 0001                M 	move.b	d5,1(sp)
0000DBA4 4EB9 0000 0000           M 	jsr	errorhandler
0000DBAA                          M 	__fstring_generatedecodedstring	"Invalid PSG note: %<.b d5>"
0000DBAA =00000001                M 	__lpos:	set 1
0000DBAA =00000013                M 	__pos:	set instr("Invalid PSG note: %<.b d5>",'%<')
0000DBAA                          M 	while	(__pos)
0000DBAA                          M 	__substr:	substr __lpos,__pos-1,"Invalid PSG note: %<.b d5>"
0000DBAA 496E 7661 6C69 6420 5053+M 	dc.b	"Invalid PSG note: "
0000DBBC =0000001A                M 	__endpos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'>')
0000DBBC =00000000                M 	__midpos:	set instr(__pos+5,"Invalid PSG note: %<.b d5>",' ')
0000DBBC =0000001A                M 	__midpos:	= __endpos
0000DBBC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid PSG note: %<.b d5>"
0000DBBC                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DBBC                          M 	__param:	substr ,,"hex"
0000DBBC 80                       M 	dc.b	hex
0000DBBD =0000001B                M 	__lpos:	set __endpos+1
0000DBBD =00000000                M 	__pos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'%<')
0000DBBD                          M 	__substr:	substr __lpos,,"Invalid PSG note: %<.b d5>"
0000DBBD                          M 	dc.b	""
0000DBBD 00                       M 	dc.b	0
0000DBBE 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DBC0 00                       M 	even
0000DBC0 4EFA F370                M 	jmp	amps_debug_console_channel
0000DBC4                          M 	even
0000DBC4                            ; ===========================================================================
0000DBC4                            ; ---------------------------------------------------------------------------
0000DBC4                            ; FM note check
0000DBC4                            ; ---------------------------------------------------------------------------
0000DBC4                            
0000DBC4                            AMPS_Debug_NoteFM	macro
0000DBC4                            	cmp.b	#dFreqFM_-dFreqFM,d5; check against max
0000DBC4                            	blo.s	.ok		; if too little, bra
0000DBC4                            .fail
0000DBC4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DBC4                            		jsr	AMPS_DebugR_NoteFM
0000DBC4                            	else
0000DBC4                            		bra.w	*
0000DBC4                            	endif
0000DBC4                            .ok
0000DBC4                                endm
0000DBC4                            
0000DBC4                            AMPS_DebugR_NoteFM:
0000DBC4 E24D                       		lsr.w	#1,d5	; get real note
0000DBC6                            		RaiseError2 "Invalid FM note: %<.b d5>", AMPS_Debug_Console_Channel
0000DBC6 40E7                     M 	move.w	sr,-(sp)
0000DBC8                          M 	__fstring_generateargumentscode	"Invalid FM note: %<.b d5>"
0000DBC8 =00000012                M 	__pos:	set instr("Invalid FM note: %<.b d5>",'%<')
0000DBC8 =00000000                M 	__stack:set	0
0000DBC8 =00000000                M 	__sp:	set 0
0000DBC8                          M 	while	(__pos)
0000DBC8 =00000019                M 	__endpos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'>')
0000DBC8 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid FM note: %<.b d5>",' ')
0000DBC8 =00000019                M 	__midpos:	= __endpos
0000DBC8                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DBC8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid FM note: %<.b d5>"
0000DBC8                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid FM note: %<.b d5>"
0000DBC8                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DBC8                          M 	pushp	"move.b d5,1(sp)"
0000DBC8                          M 	pushp	"subq.w	#2, sp"
0000DBC8 =00000002                M 	__stack:	= __stack+2
0000DBC8 =00000002                M 	__sp:	= __sp+2
0000DBC8 =00000000                M 	__pos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'%<')
0000DBC8                          M 	rept	__stack
0000DBC8                          M 	popp	__command
0000DBC8 554F                     M 	subq.w	#2,sp
0000DBCA                          M 	popp	__command
0000DBCA 1F45 0001                M 	move.b	d5,1(sp)
0000DBCE 4EB9 0000 0000           M 	jsr	errorhandler
0000DBD4                          M 	__fstring_generatedecodedstring	"Invalid FM note: %<.b d5>"
0000DBD4 =00000001                M 	__lpos:	set 1
0000DBD4 =00000012                M 	__pos:	set instr("Invalid FM note: %<.b d5>",'%<')
0000DBD4                          M 	while	(__pos)
0000DBD4                          M 	__substr:	substr __lpos,__pos-1,"Invalid FM note: %<.b d5>"
0000DBD4 496E 7661 6C69 6420 464D+M 	dc.b	"Invalid FM note: "
0000DBE5 =00000019                M 	__endpos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'>')
0000DBE5 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid FM note: %<.b d5>",' ')
0000DBE5 =00000019                M 	__midpos:	= __endpos
0000DBE5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid FM note: %<.b d5>"
0000DBE5                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DBE5                          M 	__param:	substr ,,"hex"
0000DBE5 80                       M 	dc.b	hex
0000DBE6 =0000001A                M 	__lpos:	set __endpos+1
0000DBE6 =00000000                M 	__pos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'%<')
0000DBE6                          M 	__substr:	substr __lpos,,"Invalid FM note: %<.b d5>"
0000DBE6                          M 	dc.b	""
0000DBE6 00                       M 	dc.b	0
0000DBE7 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DBE8                          M 	even
0000DBE8 4EFA F348                M 	jmp	amps_debug_console_channel
0000DBEC                          M 	even
0000DBEC                            ; ===========================================================================
0000DBEC                            ; ---------------------------------------------------------------------------
0000DBEC                            ; DAC frequency check
0000DBEC                            ; ---------------------------------------------------------------------------
0000DBEC                            
0000DBEC                            AMPS_Debug_FreqDAC	macro
0000DBEC                            	cmp.w	#MaxPitch,d6	; check if frequency is too large
0000DBEC                            	bgt.s	.fail		; if so, branch
0000DBEC                            	cmp.w	#-MaxPitch,d6	; check if frequency is too small
0000DBEC                            	bge.s	.ok		; if not, branch
0000DBEC                            .fail
0000DBEC                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DBEC                            		jsr	AMPS_DebugR_FreqDAC
0000DBEC                            	else
0000DBEC                            		bra.w	*
0000DBEC                            	endif
0000DBEC                            .ok
0000DBEC                                endm
0000DBEC                            
0000DBEC                            AMPS_DebugR_FreqDAC:
0000DBEC                            		RaiseError "Out of range DAC frequency: %<.w d6>", AMPS_Debug_Console_Channel
0000DBEC 487A FFFE                M 	pea	*(pc)
0000DBF0                          M 	raiseerror2	"Out of range DAC frequency: %<.w d6>",amps_debug_console_channel
0000DBF0 40E7                     M 	move.w	sr,-(sp)
0000DBF2                          M 	__fstring_generateargumentscode	"Out of range DAC frequency: %<.w d6>"
0000DBF2 =0000001D                M 	__pos:	set instr("Out of range DAC frequency: %<.w d6>",'%<')
0000DBF2 =00000000                M 	__stack:set	0
0000DBF2 =00000000                M 	__sp:	set 0
0000DBF2                          M 	while	(__pos)
0000DBF2 =00000024                M 	__endpos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'>')
0000DBF2 =00000000                M 	__midpos:	set instr(__pos+5,"Out of range DAC frequency: %<.w d6>",' ')
0000DBF2 =00000024                M 	__midpos:	= __endpos
0000DBF2                          M 	__substr:	substr __pos+1+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000DBF2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Out of range DAC frequency: %<.w d6>"
0000DBF2                          M 	__operand:	substr __pos+1+1,__midpos-1,"Out of range DAC frequency: %<.w d6>"
0000DBF2                          M 	__param:	substr __midpos+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000DBF2                          M 	pushp	"move.w d6,-(sp)"
0000DBF2 =00000001                M 	__stack:	= __stack+1
0000DBF2 =00000002                M 	__sp:	= __sp+2
0000DBF2 =00000000                M 	__pos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'%<')
0000DBF2                          M 	rept	__stack
0000DBF2                          M 	popp	__command
0000DBF2 3F06                     M 	move.w	d6,-(sp)
0000DBF4 4EB9 0000 0000           M 	jsr	errorhandler
0000DBFA                          M 	__fstring_generatedecodedstring	"Out of range DAC frequency: %<.w d6>"
0000DBFA =00000001                M 	__lpos:	set 1
0000DBFA =0000001D                M 	__pos:	set instr("Out of range DAC frequency: %<.w d6>",'%<')
0000DBFA                          M 	while	(__pos)
0000DBFA                          M 	__substr:	substr __lpos,__pos-1,"Out of range DAC frequency: %<.w d6>"
0000DBFA 4F75 7420 6F66 2072 616E+M 	dc.b	"Out of range DAC frequency: "
0000DC16 =00000024                M 	__endpos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'>')
0000DC16 =00000000                M 	__midpos:	set instr(__pos+5,"Out of range DAC frequency: %<.w d6>",' ')
0000DC16 =00000024                M 	__midpos:	= __endpos
0000DC16                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Out of range DAC frequency: %<.w d6>"
0000DC16                          M 	__param:	substr __midpos+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000DC16                          M 	__param:	substr ,,"hex"
0000DC16 81                       M 	dc.b	hex|1
0000DC17 =00000025                M 	__lpos:	set __endpos+1
0000DC17 =00000000                M 	__pos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'%<')
0000DC17                          M 	__substr:	substr __lpos,,"Out of range DAC frequency: %<.w d6>"
0000DC17                          M 	dc.b	""
0000DC17 00                       M 	dc.b	0
0000DC18 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DC1A 00                       M 	even
0000DC1A 4EFA F316                M 	jmp	amps_debug_console_channel
0000DC1E                          M 	even
0000DC1E                            ; ===========================================================================
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            ; Invalid tracker command handlers
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            
0000DC1E                            AMPS_Debug_dcInvalid	macro
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		RaiseError "Invalid command detected!", AMPS_Debug_Console_Channel
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                                endm
0000DC1E                            ; ===========================================================================
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            ; PSG on sPan handler
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            
0000DC1E                            AMPS_Debug_dcPan	macro
0000DC1E                            	tst.b	cType(a5)	; check for PSG channel
0000DC1E                            	bpl.s	.ok		; if no, branch
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		RaiseError "sPan on a PSG channel!", AMPS_Debug_Console_Channel
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                            .ok
0000DC1E                                endm
0000DC1E                            ; ===========================================================================
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            ; Timeout command on SFX channel handler
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            
0000DC1E                            AMPS_Debug_dcTimeout	macro
0000DC1E                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DC1E                            	blo.s	.ok		; if no, branch
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		RaiseError "sNoteTimeOut on a SFX channel!", AMPS_Debug_Console_Channel
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                            .ok
0000DC1E                                endm
0000DC1E                            ; ===========================================================================
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            ; Call command handlers
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            
0000DC1E                            AMPS_Debug_dcCall1	macro
0000DC1E                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DC1E                            	blo.s	.ok1		; if no, branch
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		RaiseError "sCall on a SFX channel!", AMPS_Debug_Console_Channel
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                            .ok1
0000DC1E                                endm
0000DC1E                            
0000DC1E                            AMPS_Debug_dcCall2	macro
0000DC1E                            	cmp.b	#cNoteTimeCur,d0; check for invalid stack address
0000DC1E                            	bhi.s	.ok2		; if no, branch
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		RaiseError "sCall stack too deep!", AMPS_Debug_Console_Channel
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                            .ok2
0000DC1E                                endm
0000DC1E                            ; ===========================================================================
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            ; Loop command handler
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            
0000DC1E                            AMPS_Debug_dcLoop	macro
0000DC1E                            	cmp.b	#3,d0		; check for invalid call number
0000DC1E                            	bhi.s	.fail		; if is, branch
0000DC1E                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DC1E                            	blo.s	.nosfx		; if no, branch
0000DC1E                            	cmp.b	#1,d0		; check if cPrio
0000DC1E                            	beq.s	.fail		; if so, branch
0000DC1E                            .nosfx
0000DC1E                            	cmp.b	#$C0,cType(a5)	; check if PSG3 or PSG4
0000DC1E                            	blo.s	AMPS_Debug_dcLoop_ok; if no, branch
0000DC1E                            	cmp.b	#2,d0		; check if cStatPSG4
0000DC1E                            	bne.s	AMPS_Debug_dcLoop_ok; if no, branch
0000DC1E                            .fail
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		RaiseError "sLoop ID is invalid!", AMPS_Debug_Console_Channel
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                            AMPS_Debug_dcLoop_ok
0000DC1E                                endm
0000DC1E                            ; ===========================================================================
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            ; Return command handlers
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            
0000DC1E                            AMPS_Debug_dcReturn1	macro
0000DC1E                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DC1E                            	blo.s	.ok1		; if no, branch
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		RaiseError "sRet on a SFX channel!", AMPS_Debug_Console_Channel
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                            .ok1
0000DC1E                                endm
0000DC1E                            
0000DC1E                            AMPS_Debug_dcReturn2	macro
0000DC1E                            	cmp.b	#cSize,d0	; check for invalid stack address
0000DC1E                            	bls.s	.ok2		; if no, branch
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		RaiseError "sRet stack too shallow!", AMPS_Debug_Console_Channel
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                            .ok2
0000DC1E                                endm
0000DC1E                            ; ===========================================================================
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            ; Update FM voice handler
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            
0000DC1E                            AMPS_Debug_UpdVoiceFM	macro
0000DC1E                            	cmp.b	#'N',(a1)+	; check if this is valid voice
0000DC1E                            	bne.s	.fail		; if not, branch
0000DC1E                            	cmp.w	#'AT',(a1)+	; check if this is valid voice
0000DC1E                            	beq.s	.ok		; if is, branch
0000DC1E                            .fail
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		RaiseError "FM voice Update invalid voice: %<.b cVoice(a5)>", AMPS_Debug_Console_Channel
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                            .ok
0000DC1E                                endm
0000DC1E                            ; ===========================================================================
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            ; Update FM Volume handler
0000DC1E                            ; ---------------------------------------------------------------------------
0000DC1E                            
0000DC1E                            AMPS_Debug_UpdVolFM	macro
0000DC1E                            	cmp.b	#'N',(a1)+	; check if this is valid voice
0000DC1E                            	bne.s	.fail		; if not, branch
0000DC1E                            	cmp.w	#'AT',(a1)+	; check if this is valid voice
0000DC1E                            	beq.s	.ok		; if is, branch
0000DC1E                            .fail
0000DC1E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC1E                            		jsr	AMPS_DebugR_UpdVolFM
0000DC1E                            	else
0000DC1E                            		bra.w	*
0000DC1E                            	endif
0000DC1E                            .ok
0000DC1E                                endm
0000DC1E                            
0000DC1E                            AMPS_DebugR_UpdVolFM:
0000DC1E                            	RaiseError2 "FM Volume Update invalid voice: %<.b cVoice(a5)>", AMPS_Debug_Console_Channel
0000DC1E 40E7                     M 	move.w	sr,-(sp)
0000DC20                          M 	__fstring_generateargumentscode	"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC20 =00000021                M 	__pos:	set instr("FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DC20 =00000000                M 	__stack:set	0
0000DC20 =00000000                M 	__sp:	set 0
0000DC20                          M 	while	(__pos)
0000DC20 =00000030                M 	__endpos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'>')
0000DC20 =00000000                M 	__midpos:	set instr(__pos+5,"FM Volume Update invalid voice: %<.b cVoice(a5)>",' ')
0000DC20 =00000030                M 	__midpos:	= __endpos
0000DC20                          M 	__substr:	substr __pos+1+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC20                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC20                          M 	__operand:	substr __pos+1+1,__midpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC20                          M 	__param:	substr __midpos+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC20                          M 	pushp	"move.b cVoice(a5),1(sp)"
0000DC20                          M 	pushp	"subq.w	#2, sp"
0000DC20 =00000002                M 	__stack:	= __stack+2
0000DC20 =00000002                M 	__sp:	= __sp+2
0000DC20 =00000000                M 	__pos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DC20                          M 	rept	__stack
0000DC20                          M 	popp	__command
0000DC20 554F                     M 	subq.w	#2,sp
0000DC22                          M 	popp	__command
0000DC22 1F6D 000B 0001           M 	move.b	cvoice(a5),1(sp)
0000DC28 4EB9 0000 0000           M 	jsr	errorhandler
0000DC2E                          M 	__fstring_generatedecodedstring	"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC2E =00000001                M 	__lpos:	set 1
0000DC2E =00000021                M 	__pos:	set instr("FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DC2E                          M 	while	(__pos)
0000DC2E                          M 	__substr:	substr __lpos,__pos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC2E 464D 2056 6F6C 756D 6520+M 	dc.b	"FM Volume Update invalid voice: "
0000DC4E =00000030                M 	__endpos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'>')
0000DC4E =00000000                M 	__midpos:	set instr(__pos+5,"FM Volume Update invalid voice: %<.b cVoice(a5)>",' ')
0000DC4E =00000030                M 	__midpos:	= __endpos
0000DC4E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC4E                          M 	__param:	substr __midpos+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC4E                          M 	__param:	substr ,,"hex"
0000DC4E 80                       M 	dc.b	hex
0000DC4F =00000031                M 	__lpos:	set __endpos+1
0000DC4F =00000000                M 	__pos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DC4F                          M 	__substr:	substr __lpos,,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DC4F                          M 	dc.b	""
0000DC4F 00                       M 	dc.b	0
0000DC50 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DC52 00                       M 	even
0000DC52 4EFA F2DE                M 	jmp	amps_debug_console_channel
0000DC56                          M 	even
0000DC56                            ; ===========================================================================
0000DC56                            ; ---------------------------------------------------------------------------
0000DC56                            ; Invalid cue handler
0000DC56                            ; ---------------------------------------------------------------------------
0000DC56                            
0000DC56                            AMPS_Debug_CuePtr	macro id
0000DC56                            	cmp.l	#$A00000+YM_Buffer1,a0	; check against min
0000DC56                            	blo.s	.fail\@			; if not in range, branch
0000DC56                            	cmp.l	#$A00000+YM_Buffer2+$400,a0; check against max
0000DC56                            	blo.s	.ok\@			; if in range, branch
0000DC56                            .fail\@
0000DC56                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DC56                            		jsr	AMPS_Debug_CuePtr\id
0000DC56                            	else
0000DC56                            		bra.w	*
0000DC56                            	endif
0000DC56                            .ok\@
0000DC56                                endm
0000DC56                            
0000DC56                            AMPS_Debug_CuePtr1:
0000DC56                            		RaiseError2 "CUE invalid at WriteYM_Pt1: %<.l a0>", AMPS_Debug_Console_Channel
0000DC56 40E7                     M 	move.w	sr,-(sp)
0000DC58                          M 	__fstring_generateargumentscode	"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC58 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DC58 =00000000                M 	__stack:set	0
0000DC58 =00000000                M 	__sp:	set 0
0000DC58                          M 	while	(__pos)
0000DC58 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'>')
0000DC58 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt1: %<.l a0>",' ')
0000DC58 =00000024                M 	__midpos:	= __endpos
0000DC58                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC58                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC58                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC58                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC58                          M 	pushp	"move.l a0,-(sp)"
0000DC58 =00000001                M 	__stack:	= __stack+1
0000DC58 =00000004                M 	__sp:	= __sp+4
0000DC58 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DC58                          M 	rept	__stack
0000DC58                          M 	popp	__command
0000DC58 2F08                     M 	move.l	a0,-(sp)
0000DC5A 4EB9 0000 0000           M 	jsr	errorhandler
0000DC60                          M 	__fstring_generatedecodedstring	"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC60 =00000001                M 	__lpos:	set 1
0000DC60 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DC60                          M 	while	(__pos)
0000DC60                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC60 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at WriteYM_Pt1: "
0000DC7C =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'>')
0000DC7C =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt1: %<.l a0>",' ')
0000DC7C =00000024                M 	__midpos:	= __endpos
0000DC7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC7C                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC7C                          M 	__param:	substr ,,"hex"
0000DC7C 83                       M 	dc.b	hex|3
0000DC7D =00000025                M 	__lpos:	set __endpos+1
0000DC7D =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DC7D                          M 	__substr:	substr __lpos,,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DC7D                          M 	dc.b	""
0000DC7D 00                       M 	dc.b	0
0000DC7E 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DC80 00                       M 	even
0000DC80 4EFA F2B0                M 	jmp	amps_debug_console_channel
0000DC84                          M 	even
0000DC84                            AMPS_Debug_CuePtr2:
0000DC84                            		RaiseError2 "CUE invalid at WriteYM_Pt2: %<.l a0>", AMPS_Debug_Console_Channel
0000DC84 40E7                     M 	move.w	sr,-(sp)
0000DC86                          M 	__fstring_generateargumentscode	"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DC86 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000DC86 =00000000                M 	__stack:set	0
0000DC86 =00000000                M 	__sp:	set 0
0000DC86                          M 	while	(__pos)
0000DC86 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'>')
0000DC86 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt2: %<.l a0>",' ')
0000DC86 =00000024                M 	__midpos:	= __endpos
0000DC86                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DC86                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DC86                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DC86                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DC86                          M 	pushp	"move.l a0,-(sp)"
0000DC86 =00000001                M 	__stack:	= __stack+1
0000DC86 =00000004                M 	__sp:	= __sp+4
0000DC86 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000DC86                          M 	rept	__stack
0000DC86                          M 	popp	__command
0000DC86 2F08                     M 	move.l	a0,-(sp)
0000DC88 4EB9 0000 0000           M 	jsr	errorhandler
0000DC8E                          M 	__fstring_generatedecodedstring	"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DC8E =00000001                M 	__lpos:	set 1
0000DC8E =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000DC8E                          M 	while	(__pos)
0000DC8E                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DC8E 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at WriteYM_Pt2: "
0000DCAA =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'>')
0000DCAA =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt2: %<.l a0>",' ')
0000DCAA =00000024                M 	__midpos:	= __endpos
0000DCAA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DCAA                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DCAA                          M 	__param:	substr ,,"hex"
0000DCAA 83                       M 	dc.b	hex|3
0000DCAB =00000025                M 	__lpos:	set __endpos+1
0000DCAB =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000DCAB                          M 	__substr:	substr __lpos,,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DCAB                          M 	dc.b	""
0000DCAB 00                       M 	dc.b	0
0000DCAC 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DCAE 00                       M 	even
0000DCAE 4EFA F282                M 	jmp	amps_debug_console_channel
0000DCB2                          M 	even
0000DCB2                            AMPS_Debug_CuePtr0:
0000DCB2                            		RaiseError2 "CUE invalid at dUpdateVoiceFM: %<.l a0>", AMPS_Debug_Console_Channel
0000DCB2 40E7                     M 	move.w	sr,-(sp)
0000DCB4                          M 	__fstring_generateargumentscode	"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCB4 =00000020                M 	__pos:	set instr("CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000DCB4 =00000000                M 	__stack:set	0
0000DCB4 =00000000                M 	__sp:	set 0
0000DCB4                          M 	while	(__pos)
0000DCB4 =00000027                M 	__endpos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'>')
0000DCB4 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dUpdateVoiceFM: %<.l a0>",' ')
0000DCB4 =00000027                M 	__midpos:	= __endpos
0000DCB4                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCB4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCB4                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCB4                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCB4                          M 	pushp	"move.l a0,-(sp)"
0000DCB4 =00000001                M 	__stack:	= __stack+1
0000DCB4 =00000004                M 	__sp:	= __sp+4
0000DCB4 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000DCB4                          M 	rept	__stack
0000DCB4                          M 	popp	__command
0000DCB4 2F08                     M 	move.l	a0,-(sp)
0000DCB6 4EB9 0000 0000           M 	jsr	errorhandler
0000DCBC                          M 	__fstring_generatedecodedstring	"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCBC =00000001                M 	__lpos:	set 1
0000DCBC =00000020                M 	__pos:	set instr("CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000DCBC                          M 	while	(__pos)
0000DCBC                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCBC 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at dUpdateVoiceFM: "
0000DCDB =00000027                M 	__endpos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'>')
0000DCDB =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dUpdateVoiceFM: %<.l a0>",' ')
0000DCDB =00000027                M 	__midpos:	= __endpos
0000DCDB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCDB                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCDB                          M 	__param:	substr ,,"hex"
0000DCDB 83                       M 	dc.b	hex|3
0000DCDC =00000028                M 	__lpos:	set __endpos+1
0000DCDC =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000DCDC                          M 	__substr:	substr __lpos,,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DCDC                          M 	dc.b	""
0000DCDC 00                       M 	dc.b	0
0000DCDD 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DCDE                          M 	even
0000DCDE 4EFA F252                M 	jmp	amps_debug_console_channel
0000DCE2                          M 	even
0000DCE2                            AMPS_Debug_CuePtr3:
0000DCE2                            		RaiseError2 "CUE invalid at dAMPSend: %<.l a0>", AMPS_Debug_Console_Channel
0000DCE2 40E7                     M 	move.w	sr,-(sp)
0000DCE4                          M 	__fstring_generateargumentscode	"CUE invalid at dAMPSend: %<.l a0>"
0000DCE4 =0000001A                M 	__pos:	set instr("CUE invalid at dAMPSend: %<.l a0>",'%<')
0000DCE4 =00000000                M 	__stack:set	0
0000DCE4 =00000000                M 	__sp:	set 0
0000DCE4                          M 	while	(__pos)
0000DCE4 =00000021                M 	__endpos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'>')
0000DCE4 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dAMPSend: %<.l a0>",' ')
0000DCE4 =00000021                M 	__midpos:	= __endpos
0000DCE4                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000DCE4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dAMPSend: %<.l a0>"
0000DCE4                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000DCE4                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000DCE4                          M 	pushp	"move.l a0,-(sp)"
0000DCE4 =00000001                M 	__stack:	= __stack+1
0000DCE4 =00000004                M 	__sp:	= __sp+4
0000DCE4 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'%<')
0000DCE4                          M 	rept	__stack
0000DCE4                          M 	popp	__command
0000DCE4 2F08                     M 	move.l	a0,-(sp)
0000DCE6 4EB9 0000 0000           M 	jsr	errorhandler
0000DCEC                          M 	__fstring_generatedecodedstring	"CUE invalid at dAMPSend: %<.l a0>"
0000DCEC =00000001                M 	__lpos:	set 1
0000DCEC =0000001A                M 	__pos:	set instr("CUE invalid at dAMPSend: %<.l a0>",'%<')
0000DCEC                          M 	while	(__pos)
0000DCEC                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000DCEC 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at dAMPSend: "
0000DD05 =00000021                M 	__endpos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'>')
0000DD05 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dAMPSend: %<.l a0>",' ')
0000DD05 =00000021                M 	__midpos:	= __endpos
0000DD05                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dAMPSend: %<.l a0>"
0000DD05                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000DD05                          M 	__param:	substr ,,"hex"
0000DD05 83                       M 	dc.b	hex|3
0000DD06 =00000022                M 	__lpos:	set __endpos+1
0000DD06 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'%<')
0000DD06                          M 	__substr:	substr __lpos,,"CUE invalid at dAMPSend: %<.l a0>"
0000DD06                          M 	dc.b	""
0000DD06 00                       M 	dc.b	0
0000DD07 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DD08                          M 	even
0000DD08 4EFA F228                M 	jmp	amps_debug_console_channel
0000DD0C                          M 	even
0000DD0C                            ; ===========================================================================
0000DD0C                            ; ---------------------------------------------------------------------------
0000DD0C                            ; Play Command handler
0000DD0C                            ; ---------------------------------------------------------------------------
0000DD0C                            
0000DD0C                            AMPS_Debug_PlayCmd	macro
0000DD0C                            	cmp.b	#(dSoundCommands_End-dSoundCommands)/4,d7; check if this is valid command
0000DD0C                            	bls.s	.ok		; if is, branch
0000DD0C                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DD0C                            		RaiseError "Invalid command in queue: %<.b d7>", AMPS_Debug_Console_Channel
0000DD0C                            	else
0000DD0C                            		bra.w	*
0000DD0C                            	endif
0000DD0C                            .ok
0000DD0C                                endm
0000DD0C                            ; ===========================================================================
0000DD0C                            ; ---------------------------------------------------------------------------
0000DD0C                            ; Tracker address handlers
0000DD0C                            ; ---------------------------------------------------------------------------
0000DD0C                            
0000DD0C                            AMPS_Debug_PlayTrackMus	macro
0000DD0C                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000DD0C                            	blo.s	.fail\@		; if no, branch
0000DD0C                            	cmp.l	#musend,d0	; check if this is valid tracker
0000DD0C                            	blo.s	.ok\@		; if is, branch
0000DD0C                            .fail\@
0000DD0C                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DD0C                            		lsr.w	#2,d7	; get actual ID
0000DD0C                            		RaiseError "Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Main
0000DD0C                            	else
0000DD0C                            		bra.w	*
0000DD0C                            	endif
0000DD0C                            .ok\@
0000DD0C                                endm
0000DD0C                            
0000DD0C                            AMPS_Debug_PlayTrackMus2	macro ch
0000DD0C                            	and.l	#$FFFFFF,d0	; remove high byte
0000DD0C                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000DD0C                            	blo.s	.fail\@		; if no, branch
0000DD0C                            	cmp.l	#dacaddr,d0	; check if this is valid tracker
0000DD0C                            	blo.s	.ok\@		; if is, branch
0000DD0C                            .fail\@
0000DD0C                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DD0C                            		RaiseError "Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>", AMPS_Debug_Console_Main
0000DD0C                            	else
0000DD0C                            		bra.w	*
0000DD0C                            	endif
0000DD0C                            .ok\@
0000DD0C                                endm
0000DD0C                            
0000DD0C                            AMPS_Debug_PlayTrackSFX	macro
0000DD0C                            	cmp.l	#sfxaddr,d0	; check if this is valid tracker
0000DD0C                            	blo.s	.fail\@		; if no, branch
0000DD0C                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000DD0C                            	blo.s	.ok\@		; if is, branch
0000DD0C                            .fail\@
0000DD0C                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DD0C                            		RaiseError "Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Main
0000DD0C                            	else
0000DD0C                            		bra.w	*
0000DD0C                            	endif
0000DD0C                            .ok\@
0000DD0C                                endm
0000DD0C                            
0000DD0C                            AMPS_Debug_PlayTrackSFX2	macro
0000DD0C                            	cmp.l	#sfxaddr,d0	; check if this is valid tracker
0000DD0C                            	blo.s	.fail\@		; if no, branch
0000DD0C                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000DD0C                            	blo.s	.ok\@		; if is, branch
0000DD0C                            .fail\@
0000DD0C                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DD0C                            		RaiseError "Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>", AMPS_Debug_Console_Main
0000DD0C                            	else
0000DD0C                            		bra.w	*
0000DD0C                            	endif
0000DD0C                            .ok\@
0000DD0C                                endm
0000DD0C                            
0000DD0C                            AMPS_Debug_TrackUpd	macro
0000DD0C                            	move.l	a4,d1		; copy to d1
0000DD0C                            	and.l	#$FFFFFF,d1	; remove high byte
0000DD0C                            	cmp.l	#sfxaddr,d1	; check if this is valid tracker
0000DD0C                            	blo.s	.fail2		; if no, branch
0000DD0C                            	cmp.l	#dacaddr,d1	; check if this is valid tracker
0000DD0C                            	blo.s	.data		; if is, branch
0000DD0C                            .fail2
0000DD0C                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DD0C                            		RaiseError "Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Channel
0000DD0C                            	else
0000DD0C                            		bra.w	*
0000DD0C                            	endif
0000DD0C                                endm
0000DD0C                            ; ===========================================================================
0000DD0C                            ; ---------------------------------------------------------------------------
0000DD0C                            ; Tracker debugger handler and console code
0000DD0C                            ; ---------------------------------------------------------------------------
0000DD0C                            
0000DD0C                            AMPS_Debug_ChkTracker	macro
0000DD0C                            .fail
0000DD0C                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DD0C                            		jsr	AMPS_DebugR_ChkTracker
0000DD0C                            	else
0000DD0C                            		bra.w	*
0000DD0C                            	endif
0000DD0C                                endm
0000DD0C                            
0000DD0C                            AMPS_DebugR_ChkTracker:
0000DD0C 4EBA 0000                  		jsr	AMPS_Debug_CalcMax(pc)
0000DD10 4847                       		swap	d7			; swap d7 words
0000DD12                            
0000DD12                            AMPS_DebugR_ChkTracker_loop
0000DD12 23C7 00FF 0000             		move.l	d7,$FF0000		; save stuff in RAM
0000DD18                            		Console.Run AMPS_DebugR_ChkTracker2, "NAT"
0000DD18 4EB9 0000 0000           M 	jsr	errorhandler.__extern__console_only
0000DD1E 4EB9 0000 0000           M 	jsr	amps_debugr_chktracker2
0000DD24 2E39 00FF 0000             		move.l	$FF0000,d7		; get stuff back
0000DD2A                            
0000DD2A                            AMPS_DebugR_ChkTracker_nodraw
0000DD2A 7CFF                       		moveq	#-1,d6
0000DD2C 51CE FFFE                  		dbf	d6,*			; delay a lot
0000DD30                            
0000DD30                            	; implement reading control data
0000DD30 43F9 00A1 0003             		lea	$A10003,a1
0000DD36 12BC 0000                  		move.b	#0,(a1)			; set TH low
0000DD3A 8080                       		or.l	d0,d0			; delay
0000DD3C 12BC 0040                  		move.b	#$40,(a1)		; set TH high
0000DD40 8080                       		or.l	d0,d0			; delay
0000DD42 1011                       		move.b	(a1),d0			; get dpad stat
0000DD44                            
0000DD44 3A07                       		move.w	d7,d5			; copy to d5
0000DD46 0800 0000                  		btst	#0,d0			; check if up held
0000DD4A 6600                       		bne.s	AMPS_Debug_Writekd			; if not ,branch
0000DD4C                            
0000DD4C 5347                       		subq.w	#1,d7			; move up
0000DD4E 6A00                       		bpl.s	AMPS_Debug_Writekd			; if positive, branch
0000DD50 4247                       		clr.w	d7			; else force to 0
0000DD52                            
0000DD52                            AMPS_Debug_Writekd
0000DD52 0800 0001                  		btst	#1,d0			; check if down held
0000DD56 6600                       		bne.s	AMPS_Debug_Writekdraw			; if not ,branch
0000DD58                            
0000DD58 4847                       		swap	d7
0000DD5A 3C07                       		move.w	d7,d6			; copy high word to d6
0000DD5C 4847                       		swap	d7
0000DD5E                            
0000DD5E BE46                       		cmp.w	d6,d7			; check if we can move up
0000DD60 6C00                       		bge.s	AMPS_Debug_Writekdraw			; if not, branch
0000DD62 5247                       		addq.w	#1,d7			; move down
0000DD64                            
0000DD64                            AMPS_Debug_Writekdraw
0000DD64 BA47                       		cmp.w	d7,d5			; check if we need to redraw
0000DD66 67C2                       		beq.s	AMPS_DebugR_ChkTracker_nodraw; if not, branch
0000DD68 6000 FFA8                  		bra.w	AMPS_DebugR_ChkTracker_loop
0000DD6C                            
0000DD6C                            AMPS_Debug_CalcMax:
0000DD6C 7C1C                       		moveq	#28,d6	; max lines count
0000DD6E 7E09                       		moveq	#10-1,d7	; run for 10 chs
0000DD70 7A2C                       		moveq	#cSize,d5	; prepare size
0000DD72 4BF8 C650                  		lea	mPSG3.w,a5	; start at PSG3
0000DD76                            
0000DD76                            AMPS_Debug_Writehkloop
0000DD76 4A46                       		tst.w	d6		; check if we have no lines left
0000DD78                            	;	ble.s	.rts		; if so, we found it
0000DD78 5746                       		subq.w	#3,d6		; we need at least 3 lines
0000DD7A 6B00                       		bmi.s	.add		; if not enough lines, branch
0000DD7C                            
0000DD7C 320D                       		move.w	a5,d1		; copy ch to d1
0000DD7E 0641 002C                  		add.w	#cSize,d1	; go to end of it
0000DD82                            
0000DD82 7000                       		moveq	#0,d0
0000DD84 102D 001E                  		move.b	cStack(a5),d0	; get stack to d0
0000DD88 4DF5 0000                  		lea	(a5,d0.w),a6	; and get first element to a6
0000DD8C                            
0000DD8C                            .stack
0000DD8C B24E                       		cmp.w	a6,d1		; check if stack is dry now
0000DD8E 6200                       		bhi.s	.inc		; if not, branch
0000DD90                            
0000DD90 9AC5                       		sub.w	d5,a5		; sub ch size
0000DD92 51CF FFE2                  		dbf	d7,AMPS_Debug_Writehkloop	; loop for all chans
0000DD96 6000                       		bra.s	.add
0000DD98                            
0000DD98                            .inc
0000DD98 584E                       		addq.w	#4,a6		; go to next long
0000DD9A 5346                       		subq.w	#1,d6		; sub 1 line
0000DD9C 6AEE                       		bpl.s	.stack		; if lines left, branch
0000DD9E                            
0000DD9E                            .add
0000DD9E 5247                       		addq.w	#1,d7		; increase ch by 1
0000DDA0                            .rts
0000DDA0 4E75                       		rts
0000DDA2                            
0000DDA2                            AMPS_DebugR_ChkTracker_Ch:
0000DDA2 5347                       		subq.w	#1,d7		; sub 1 from offset
0000DDA4 6A00 0000                  		bpl.w	AMPS_Debug_Write_n; branch if positive
0000DDA8 4A46                       		tst.w	d6		; check if we need to render anymore
0000DDAA 6B00 0000                  		bmi.w	AMPS_Debug_Write_n; if not, branch
0000DDAE                            
0000DDAE                            ; fmt: <addr> lstdur, dur, freq, sample, loop0, loop1, loop2
0000DDAE 4E90                       		jsr	(a0)
0000DDB0                            	Console.Write	  ": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB0 40E7                     M 	move.w	sr,-(sp)
0000DDB2                          M 	__fstring_generateargumentscode	": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2 =00000003                M 	__pos:	set instr(": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDB2 =00000000                M 	__stack:set	0
0000DDB2 =00000000                M 	__sp:	set 0
0000DDB2                          M 	while	(__pos)
0000DDB2 =0000000A                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDB2 =0000000F                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDB2 =0000000A                M 	__midpos:	= __endpos
0000DDB2                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2 =0000000B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDB2 =00000012                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDB2 =00000013                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDB2 =00000012                M 	__midpos:	= __endpos
0000DDB2                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	pushp	"move.w a5,-(sp)"
0000DDB2 =00000001                M 	__stack:	= __stack+1
0000DDB2 =00000002                M 	__sp:	= __sp+2
0000DDB2 =00000014                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDB2 =00000025                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDB2 =00000026                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDB2 =00000025                M 	__midpos:	= __endpos
0000DDB2                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	pushp	"move.b cLastDur(a5),1(sp)"
0000DDB2                          M 	pushp	"subq.w	#2, sp"
0000DDB2 =00000003                M 	__stack:	= __stack+2
0000DDB2 =00000004                M 	__sp:	= __sp+2
0000DDB2 =00000027                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDB2 =00000039                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDB2 =0000003A                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDB2 =00000039                M 	__midpos:	= __endpos
0000DDB2                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	pushp	"move.b cDuration(a5),1(sp)"
0000DDB2                          M 	pushp	"subq.w	#2, sp"
0000DDB2 =00000005                M 	__stack:	= __stack+2
0000DDB2 =00000006                M 	__sp:	= __sp+2
0000DDB2 =0000003B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDB2 =00000049                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDB2 =00000000                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDB2 =00000049                M 	__midpos:	= __endpos
0000DDB2                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDB2                          M 	pushp	"move.w cFreq(a5),-(sp)"
0000DDB2 =00000006                M 	__stack:	= __stack+1
0000DDB2 =00000008                M 	__sp:	= __sp+2
0000DDB2 =00000000                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDB2                          M 	rept	__stack
0000DDB2                          M 	popp	__command
0000DDB2 3F2D 000E                M 	move.w	cfreq(a5),-(sp)
0000DDB6                          M 	popp	__command
0000DDB6 554F                     M 	subq.w	#2,sp
0000DDB8                          M 	popp	__command
0000DDB8 1F6D 000C 0001           M 	move.b	cduration(a5),1(sp)
0000DDBE                          M 	popp	__command
0000DDBE 554F                     M 	subq.w	#2,sp
0000DDC0                          M 	popp	__command
0000DDC0 1F6D 000D 0001           M 	move.b	clastdur(a5),1(sp)
0000DDC6                          M 	popp	__command
0000DDC6 3F0D                     M 	move.w	a5,-(sp)
0000DDC8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DDCC 45EF 0010                M 	lea	4*4(sp),a2
0000DDD0 43FA 0000                M 	lea	.str_486(pc),a1
0000DDD4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DDDA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DDDE 504F                     M 	addq.w	#__sp,sp
0000DDE0 46DF                     M 	move.w	(sp)+,sr
0000DDE2 6000 0000                M 	bra.w	.instr_end_486
0000DDE6                          M 	.str_486:
0000DDE6                          M 	__fstring_generatedecodedstring	": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDE6 =00000001                M 	__lpos:	set 1
0000DDE6 =00000003                M 	__pos:	set instr(": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDE6                          M 	while	(__pos)
0000DDE6                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDE6 3A20                     M 	dc.b	": "
0000DDE8 =0000000A                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDE8 =0000000F                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDE8 =0000000A                M 	__midpos:	= __endpos
0000DDE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDE8                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDE8 EC                       M 	dc.b	fpal2
0000DDE9 =0000000B                M 	__lpos:	set __endpos+1
0000DDE9 =0000000B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDE9                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDE9                          M 	dc.b	""
0000DDE9 =00000012                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDE9 =00000013                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDE9 =00000012                M 	__midpos:	= __endpos
0000DDE9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDE9                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDE9                          M 	__param:	substr ,,"hex"
0000DDE9 81                       M 	dc.b	hex|1
0000DDEA =00000013                M 	__lpos:	set __endpos+1
0000DDEA =00000014                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDEA                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDEA 20                       M 	dc.b	" "
0000DDEB =00000025                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDEB =00000026                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDEB =00000025                M 	__midpos:	= __endpos
0000DDEB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDEB                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDEB                          M 	__param:	substr ,,"hex"
0000DDEB 80                       M 	dc.b	hex
0000DDEC =00000026                M 	__lpos:	set __endpos+1
0000DDEC =00000027                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDEC                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDEC 20                       M 	dc.b	" "
0000DDED =00000039                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDED =0000003A                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDED =00000039                M 	__midpos:	= __endpos
0000DDED                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDED                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDED                          M 	__param:	substr ,,"hex"
0000DDED 80                       M 	dc.b	hex
0000DDEE =0000003A                M 	__lpos:	set __endpos+1
0000DDEE =0000003B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDEE                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDEE 20                       M 	dc.b	" "
0000DDEF =00000049                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000DDEF =00000000                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000DDEF =00000049                M 	__midpos:	= __endpos
0000DDEF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDEF                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDEF                          M 	__param:	substr ,,"hex"
0000DDEF 81                       M 	dc.b	hex|1
0000DDF0 =0000004A                M 	__lpos:	set __endpos+1
0000DDF0 =00000000                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000DDF0                          M 	__substr:	substr __lpos,,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000DDF0                          M 	dc.b	""
0000DDF0 00                       M 	dc.b	0
0000DDF2 00                       M 	even
0000DDF2                          M 	.instr_end_486:
0000DDF2                            	Console.WriteLine " %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF2 40E7                     M 	move.w	sr,-(sp)
0000DDF4                          M 	__fstring_generateargumentscode	" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4 =00000002                M 	__pos:	set instr(" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DDF4 =00000000                M 	__stack:set	0
0000DDF4 =00000000                M 	__sp:	set 0
0000DDF4                          M 	while	(__pos)
0000DDF4 =00000012                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000DDF4 =00000013                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000DDF4 =00000012                M 	__midpos:	= __endpos
0000DDF4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	pushp	"move.b cSample(a5),1(sp)"
0000DDF4                          M 	pushp	"subq.w	#2, sp"
0000DDF4 =00000002                M 	__stack:	= __stack+2
0000DDF4 =00000002                M 	__sp:	= __sp+2
0000DDF4 =00000014                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DDF4 =00000022                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000DDF4 =00000023                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000DDF4 =00000022                M 	__midpos:	= __endpos
0000DDF4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	pushp	"move.b cLoop(a5),1(sp)"
0000DDF4                          M 	pushp	"subq.w	#2, sp"
0000DDF4 =00000004                M 	__stack:	= __stack+2
0000DDF4 =00000004                M 	__sp:	= __sp+2
0000DDF4 =00000024                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DDF4 =00000034                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000DDF4 =00000035                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000DDF4 =00000034                M 	__midpos:	= __endpos
0000DDF4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	pushp	"move.b cLoop+1(a5),1(sp)"
0000DDF4                          M 	pushp	"subq.w	#2, sp"
0000DDF4 =00000006                M 	__stack:	= __stack+2
0000DDF4 =00000006                M 	__sp:	= __sp+2
0000DDF4 =00000036                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DDF4 =00000046                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000DDF4 =00000000                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000DDF4 =00000046                M 	__midpos:	= __endpos
0000DDF4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DDF4                          M 	pushp	"move.b cLoop+2(a5),1(sp)"
0000DDF4                          M 	pushp	"subq.w	#2, sp"
0000DDF4 =00000008                M 	__stack:	= __stack+2
0000DDF4 =00000008                M 	__sp:	= __sp+2
0000DDF4 =00000000                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DDF4                          M 	rept	__stack
0000DDF4                          M 	popp	__command
0000DDF4 554F                     M 	subq.w	#2,sp
0000DDF6                          M 	popp	__command
0000DDF6 1F6D 001B 0001           M 	move.b	cloop+2(a5),1(sp)
0000DDFC                          M 	popp	__command
0000DDFC 554F                     M 	subq.w	#2,sp
0000DDFE                          M 	popp	__command
0000DDFE 1F6D 001A 0001           M 	move.b	cloop+1(a5),1(sp)
0000DE04                          M 	popp	__command
0000DE04 554F                     M 	subq.w	#2,sp
0000DE06                          M 	popp	__command
0000DE06 1F6D 0019 0001           M 	move.b	cloop(a5),1(sp)
0000DE0C                          M 	popp	__command
0000DE0C 554F                     M 	subq.w	#2,sp
0000DE0E                          M 	popp	__command
0000DE0E 1F6D 000B 0001           M 	move.b	csample(a5),1(sp)
0000DE14 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DE18 45EF 0010                M 	lea	4*4(sp),a2
0000DE1C 43FA 0000                M 	lea	.str_489(pc),a1
0000DE20 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DE26 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DE2A 504F                     M 	addq.w	#__sp,sp
0000DE2C 46DF                     M 	move.w	(sp)+,sr
0000DE2E 6000 0000                M 	bra.w	.instr_end_489
0000DE32                          M 	.str_489:
0000DE32                          M 	__fstring_generatedecodedstring	" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE32 =00000001                M 	__lpos:	set 1
0000DE32 =00000002                M 	__pos:	set instr(" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DE32                          M 	while	(__pos)
0000DE32                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE32 20                       M 	dc.b	" "
0000DE33 =00000012                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000DE33 =00000013                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000DE33 =00000012                M 	__midpos:	= __endpos
0000DE33                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE33                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE33                          M 	__param:	substr ,,"hex"
0000DE33 80                       M 	dc.b	hex
0000DE34 =00000013                M 	__lpos:	set __endpos+1
0000DE34 =00000014                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DE34                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE34 20                       M 	dc.b	" "
0000DE35 =00000022                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000DE35 =00000023                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000DE35 =00000022                M 	__midpos:	= __endpos
0000DE35                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE35                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE35                          M 	__param:	substr ,,"hex"
0000DE35 80                       M 	dc.b	hex
0000DE36 =00000023                M 	__lpos:	set __endpos+1
0000DE36 =00000024                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DE36                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE36 20                       M 	dc.b	" "
0000DE37 =00000034                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000DE37 =00000035                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000DE37 =00000034                M 	__midpos:	= __endpos
0000DE37                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE37                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE37                          M 	__param:	substr ,,"hex"
0000DE37 80                       M 	dc.b	hex
0000DE38 =00000035                M 	__lpos:	set __endpos+1
0000DE38 =00000036                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DE38                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE38 20                       M 	dc.b	" "
0000DE39 =00000046                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000DE39 =00000000                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000DE39 =00000046                M 	__midpos:	= __endpos
0000DE39                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE39                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE39                          M 	__param:	substr ,,"hex"
0000DE39 80                       M 	dc.b	hex
0000DE3A =00000047                M 	__lpos:	set __endpos+1
0000DE3A =00000000                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000DE3A                          M 	__substr:	substr __lpos,," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000DE3A                          M 	dc.b	""
0000DE3A 00                       M 	dc.b	0
0000DE3C 00                       M 	even
0000DE3C                          M 	.instr_end_489:
0000DE3C                            	Console.WriteLine " %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3C 40E7                     M 	move.w	sr,-(sp)
0000DE3E                          M 	__fstring_generateargumentscode	" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E =00000002                M 	__pos:	set instr(" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE3E =00000000                M 	__stack:set	0
0000DE3E =00000000                M 	__sp:	set 0
0000DE3E                          M 	while	(__pos)
0000DE3E =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE3E =0000000F                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE3E =00000009                M 	__midpos:	= __endpos
0000DE3E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE3E =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE3E =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE3E =00000017                M 	__midpos:	= __endpos
0000DE3E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE3E =00000031                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE3E =00000026                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE3E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E                          M 	pushp	"move.l cData(a5),-(sp)"
0000DE3E =00000001                M 	__stack:	= __stack+1
0000DE3E =00000004                M 	__sp:	= __sp+4
0000DE3E =00000032                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE3E =00000042                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE3E =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE3E =00000042                M 	__midpos:	= __endpos
0000DE3E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE3E =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE3E                          M 	rept	__stack
0000DE3E                          M 	popp	__command
0000DE3E 2F2D 0002                M 	move.l	cdata(a5),-(sp)
0000DE42 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DE46 45EF 0010                M 	lea	4*4(sp),a2
0000DE4A 43FA 0000                M 	lea	.str_492(pc),a1
0000DE4E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DE54 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DE58 584F                     M 	addq.w	#__sp,sp
0000DE5A 46DF                     M 	move.w	(sp)+,sr
0000DE5C 6000 0000                M 	bra.w	.instr_end_492
0000DE60                          M 	.str_492:
0000DE60                          M 	__fstring_generatedecodedstring	" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE60 =00000001                M 	__lpos:	set 1
0000DE60 =00000002                M 	__pos:	set instr(" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE60                          M 	while	(__pos)
0000DE60                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE60 20                       M 	dc.b	" "
0000DE61 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE61 =0000000F                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE61 =00000009                M 	__midpos:	= __endpos
0000DE61                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE61                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE61 EA                       M 	dc.b	fpal1
0000DE62 =0000000A                M 	__lpos:	set __endpos+1
0000DE62 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE62                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE62 4164 6472 3A20           M 	dc.b	"Addr: "
0000DE68 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE68 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE68 =00000017                M 	__midpos:	= __endpos
0000DE68                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE68                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE68 E8                       M 	dc.b	fpal0
0000DE69 =00000018                M 	__lpos:	set __endpos+1
0000DE69 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE69                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE69                          M 	dc.b	""
0000DE69 =00000031                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE69 =00000026                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE69                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE69                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE69 BB                       M 	dc.b	sym|fsplit|3
0000DE6A =00000032                M 	__lpos:	set __endpos+1
0000DE6A =00000032                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE6A                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE6A                          M 	dc.b	""
0000DE6A =00000042                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE6A =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE6A =00000042                M 	__midpos:	= __endpos
0000DE6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE6A                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE6A ECC0                     M 	dc.b	fpal2,fsymdisp
0000DE6C =00000043                M 	__lpos:	set __endpos+1
0000DE6C =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE6C                          M 	__substr:	substr __lpos,," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000DE6C                          M 	dc.b	""
0000DE6C 00                       M 	dc.b	0
0000DE6E 00                       M 	even
0000DE6E                          M 	.instr_end_492:
0000DE6E                            
0000DE6E 5546                       		subq.w	#2,d6		; sub those 2 lines from stuff
0000DE70 6B00 0000                  		bmi.w	AMPS_Debug_Write_n; if drawn all, branch
0000DE74 320D                       		move.w	a5,d1		; copy ch to d1
0000DE76 D245                       		add.w	d5,d1		; go to end of it
0000DE78                            
0000DE78 7000                       		moveq	#0,d0
0000DE7A 102D 001E                  		move.b	cStack(a5),d0	; get stack to d0
0000DE7E 4DF5 0000                  		lea	(a5,d0.w),a6	; and get first element to a6
0000DE82                            
0000DE82 B24E                       		cmp.w	a6,d1		; check if stack is dry
0000DE84 6300                       		bls.s	AMPS_Debug_Write		; if is, branch
0000DE86                            	Console.WriteLine " %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE86 40E7                     M 	move.w	sr,-(sp)
0000DE88                          M 	__fstring_generateargumentscode	" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88 =00000002                M 	__pos:	set instr(" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE88 =00000000                M 	__stack:set	0
0000DE88 =00000000                M 	__sp:	set 0
0000DE88                          M 	while	(__pos)
0000DE88 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE88 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE88 =00000009                M 	__midpos:	= __endpos
0000DE88                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE88 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE88 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE88 =00000017                M 	__midpos:	= __endpos
0000DE88                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE88 =0000002D                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE88 =00000022                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE88                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88                          M 	__operand:	substr __pos+1+1,__midpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88                          M 	pushp	"move.l (a6)+,-(sp)"
0000DE88 =00000001                M 	__stack:	= __stack+1
0000DE88 =00000004                M 	__sp:	= __sp+4
0000DE88 =0000002E                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE88 =0000003E                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DE88 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DE88 =0000003E                M 	__midpos:	= __endpos
0000DE88                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DE88 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DE88                          M 	rept	__stack
0000DE88                          M 	popp	__command
0000DE88 2F1E                     M 	move.l	(a6)+,-(sp)
0000DE8A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DE8E 45EF 0010                M 	lea	4*4(sp),a2
0000DE92 43FA 0000                M 	lea	.str_495(pc),a1
0000DE96 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DE9C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DEA0 584F                     M 	addq.w	#__sp,sp
0000DEA2 46DF                     M 	move.w	(sp)+,sr
0000DEA4 6000 0000                M 	bra.w	.instr_end_495
0000DEA8                          M 	.str_495:
0000DEA8                          M 	__fstring_generatedecodedstring	" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEA8 =00000001                M 	__lpos:	set 1
0000DEA8 =00000002                M 	__pos:	set instr(" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEA8                          M 	while	(__pos)
0000DEA8                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEA8 20                       M 	dc.b	" "
0000DEA9 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEA9 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEA9 =00000009                M 	__midpos:	= __endpos
0000DEA9                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEA9                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEA9 EA                       M 	dc.b	fpal1
0000DEAA =0000000A                M 	__lpos:	set __endpos+1
0000DEAA =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEAA                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEAA 5374 6163 6B3A           M 	dc.b	"Stack:"
0000DEB0 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEB0 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEB0 =00000017                M 	__midpos:	= __endpos
0000DEB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEB0                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEB0 E8                       M 	dc.b	fpal0
0000DEB1 =00000018                M 	__lpos:	set __endpos+1
0000DEB1 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEB1                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEB1                          M 	dc.b	""
0000DEB1 =0000002D                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEB1 =00000022                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEB1                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEB1                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEB1 BB                       M 	dc.b	sym|fsplit|3
0000DEB2 =0000002E                M 	__lpos:	set __endpos+1
0000DEB2 =0000002E                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEB2                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEB2                          M 	dc.b	""
0000DEB2 =0000003E                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEB2 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEB2 =0000003E                M 	__midpos:	= __endpos
0000DEB2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEB2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEB2 ECC0                     M 	dc.b	fpal2,fsymdisp
0000DEB4 =0000003F                M 	__lpos:	set __endpos+1
0000DEB4 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEB4                          M 	__substr:	substr __lpos,," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEB4                          M 	dc.b	""
0000DEB4 00                       M 	dc.b	0
0000DEB6 00                       M 	even
0000DEB6                          M 	.instr_end_495:
0000DEB6 5346                       		subq.w	#1,d6		; sub a line
0000DEB8 6B00                       		bmi.s	AMPS_Debug_Write_n; if drawn all, branch
0000DEBA                            
0000DEBA                            AMPS_DebugR_ChkTracker_Ch_loop
0000DEBA B24E                       		cmp.w	a6,d1		; check if we printed full stack
0000DEBC 6300                       		bls.s	AMPS_Debug_Write		; if not though, branch
0000DEBE                            	Console.WriteLine "   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEBE 40E7                     M 	move.w	sr,-(sp)
0000DEC0                          M 	__fstring_generateargumentscode	"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEC0 =00000004                M 	__pos:	set instr("   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEC0 =00000000                M 	__stack:set	0
0000DEC0 =00000000                M 	__sp:	set 0
0000DEC0                          M 	while	(__pos)
0000DEC0 =0000000B                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEC0 =00000010                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEC0 =0000000B                M 	__midpos:	= __endpos
0000DEC0                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEC0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEC0 =0000000C                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEC0 =00000021                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEC0 =00000016                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEC0                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEC0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEC0                          M 	__operand:	substr __pos+1+1,__midpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEC0                          M 	__param:	substr __midpos+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEC0                          M 	pushp	"move.l (a6)+,-(sp)"
0000DEC0 =00000001                M 	__stack:	= __stack+1
0000DEC0 =00000004                M 	__sp:	= __sp+4
0000DEC0 =00000022                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEC0 =00000032                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEC0 =00000000                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEC0 =00000032                M 	__midpos:	= __endpos
0000DEC0                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEC0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEC0 =00000000                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEC0                          M 	rept	__stack
0000DEC0                          M 	popp	__command
0000DEC0 2F1E                     M 	move.l	(a6)+,-(sp)
0000DEC2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DEC6 45EF 0010                M 	lea	4*4(sp),a2
0000DECA 43FA 0000                M 	lea	.str_498(pc),a1
0000DECE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DED4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DED8 584F                     M 	addq.w	#__sp,sp
0000DEDA 46DF                     M 	move.w	(sp)+,sr
0000DEDC 6000 0000                M 	bra.w	.instr_end_498
0000DEE0                          M 	.str_498:
0000DEE0                          M 	__fstring_generatedecodedstring	"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE0 =00000001                M 	__lpos:	set 1
0000DEE0 =00000004                M 	__pos:	set instr("   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEE0                          M 	while	(__pos)
0000DEE0                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE0 2020 20                  M 	dc.b	"   "
0000DEE3 =0000000B                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEE3 =00000010                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEE3 =0000000B                M 	__midpos:	= __endpos
0000DEE3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE3                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE3 E8                       M 	dc.b	fpal0
0000DEE4 =0000000C                M 	__lpos:	set __endpos+1
0000DEE4 =0000000C                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEE4                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE4                          M 	dc.b	""
0000DEE4 =00000021                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEE4 =00000016                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEE4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE4                          M 	__param:	substr __midpos+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE4 BB                       M 	dc.b	sym|fsplit|3
0000DEE5 =00000022                M 	__lpos:	set __endpos+1
0000DEE5 =00000022                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEE5                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE5                          M 	dc.b	""
0000DEE5 =00000032                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DEE5 =00000000                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DEE5 =00000032                M 	__midpos:	= __endpos
0000DEE5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE5                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE5 ECC0                     M 	dc.b	fpal2,fsymdisp
0000DEE7 =00000033                M 	__lpos:	set __endpos+1
0000DEE7 =00000000                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DEE7                          M 	__substr:	substr __lpos,,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DEE7                          M 	dc.b	""
0000DEE7 00                       M 	dc.b	0
0000DEE8                          M 	even
0000DEE8                          M 	.instr_end_498:
0000DEE8 5346                       		subq.w	#1,d6		; sub a line
0000DEEA 6ACE                       		bpl.s	AMPS_DebugR_ChkTracker_Ch_loop; if we havent drawn all, branch
0000DEEC                            
0000DEEC                            AMPS_Debug_Write
0000DEEC                            	Console.BreakLine
0000DEEC 40E7                     M 	move.w	sr,-(sp)
0000DEEE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000DEF4 46DF                     M 	move.w	(sp)+,sr
0000DEF6 5346                       		subq.w	#1,d6		; sub a line
0000DEF8                            AMPS_Debug_Write_n
0000DEF8 DAC5                       		add.w	d5,a5		; go to next ch
0000DEFA 4E75                       		rts
0000DEFC                            
0000DEFC                            AMPS_DebugR_ChkTracker2:
0000DEFC 7C27                       		moveq	#40-1,d6
0000DEFE 7A2C                       		moveq	#cSize,d5
0000DF00 4BF8 C4C4                  		lea	mDAC1.w,a5
0000DF04                            
0000DF04                            
0000DF04 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_dac1(pc),a0
0000DF08 4EBA FE98                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF0C 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_dac2(pc),a0
0000DF10 4EBA FE90                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF14                            
0000DF14 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm1(pc),a0
0000DF18 4EBA FE88                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF1C 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm2(pc),a0
0000DF20 4EBA FE80                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF24 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm3(pc),a0
0000DF28 4EBA FE78                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF2C 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm4(pc),a0
0000DF30 4EBA FE70                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF34 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm5(pc),a0
0000DF38 4EBA FE68                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF3C                            
0000DF3C 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg1(pc),a0
0000DF40 4EBA FE60                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF44 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg2(pc),a0
0000DF48 4EBA FE58                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF4C 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg3(pc),a0
0000DF50 4EFA FE50                  		jmp	AMPS_DebugR_ChkTracker_Ch(pc)
0000DF54                            
0000DF54                            AMPS_DebugR_ChkTracker2_dac1
0000DF54                            	Console.Write " %<fpal0>DAC1"
0000DF54 40E7                     M 	move.w	sr,-(sp)
0000DF56                          M 	__fstring_generateargumentscode	" %<fpal0>DAC1"
0000DF56 =00000002                M 	__pos:	set instr(" %<fpal0>DAC1",'%<')
0000DF56 =00000000                M 	__stack:set	0
0000DF56 =00000000                M 	__sp:	set 0
0000DF56                          M 	while	(__pos)
0000DF56 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC1",'>')
0000DF56 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC1",' ')
0000DF56 =00000009                M 	__midpos:	= __endpos
0000DF56                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC1"
0000DF56                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC1"
0000DF56 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC1",'%<')
0000DF56                          M 	rept	__stack
0000DF56 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DF5A 43FA 0000                M 	lea	.str_502(pc),a1
0000DF5E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DF64 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DF68 46DF                     M 	move.w	(sp)+,sr
0000DF6A 6000 0000                M 	bra.w	.instr_end_502
0000DF6E                          M 	.str_502:
0000DF6E                          M 	__fstring_generatedecodedstring	" %<fpal0>DAC1"
0000DF6E =00000001                M 	__lpos:	set 1
0000DF6E =00000002                M 	__pos:	set instr(" %<fpal0>DAC1",'%<')
0000DF6E                          M 	while	(__pos)
0000DF6E                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>DAC1"
0000DF6E 20                       M 	dc.b	" "
0000DF6F =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC1",'>')
0000DF6F =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC1",' ')
0000DF6F =00000009                M 	__midpos:	= __endpos
0000DF6F                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC1"
0000DF6F                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC1"
0000DF6F E8                       M 	dc.b	fpal0
0000DF70 =0000000A                M 	__lpos:	set __endpos+1
0000DF70 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC1",'%<')
0000DF70                          M 	__substr:	substr __lpos,," %<fpal0>DAC1"
0000DF70 4441 4331                M 	dc.b	"DAC1"
0000DF74 00                       M 	dc.b	0
0000DF76 00                       M 	even
0000DF76                          M 	.instr_end_502:
0000DF76 4E75                       		rts
0000DF78                            
0000DF78                            AMPS_DebugR_ChkTracker2_dac2
0000DF78                            	Console.Write " %<fpal0>DAC2"
0000DF78 40E7                     M 	move.w	sr,-(sp)
0000DF7A                          M 	__fstring_generateargumentscode	" %<fpal0>DAC2"
0000DF7A =00000002                M 	__pos:	set instr(" %<fpal0>DAC2",'%<')
0000DF7A =00000000                M 	__stack:set	0
0000DF7A =00000000                M 	__sp:	set 0
0000DF7A                          M 	while	(__pos)
0000DF7A =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC2",'>')
0000DF7A =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC2",' ')
0000DF7A =00000009                M 	__midpos:	= __endpos
0000DF7A                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC2"
0000DF7A                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC2"
0000DF7A =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC2",'%<')
0000DF7A                          M 	rept	__stack
0000DF7A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DF7E 43FA 0000                M 	lea	.str_505(pc),a1
0000DF82 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DF88 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DF8C 46DF                     M 	move.w	(sp)+,sr
0000DF8E 6000 0000                M 	bra.w	.instr_end_505
0000DF92                          M 	.str_505:
0000DF92                          M 	__fstring_generatedecodedstring	" %<fpal0>DAC2"
0000DF92 =00000001                M 	__lpos:	set 1
0000DF92 =00000002                M 	__pos:	set instr(" %<fpal0>DAC2",'%<')
0000DF92                          M 	while	(__pos)
0000DF92                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>DAC2"
0000DF92 20                       M 	dc.b	" "
0000DF93 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC2",'>')
0000DF93 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC2",' ')
0000DF93 =00000009                M 	__midpos:	= __endpos
0000DF93                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC2"
0000DF93                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC2"
0000DF93 E8                       M 	dc.b	fpal0
0000DF94 =0000000A                M 	__lpos:	set __endpos+1
0000DF94 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC2",'%<')
0000DF94                          M 	__substr:	substr __lpos,," %<fpal0>DAC2"
0000DF94 4441 4332                M 	dc.b	"DAC2"
0000DF98 00                       M 	dc.b	0
0000DF9A 00                       M 	even
0000DF9A                          M 	.instr_end_505:
0000DF9A 4E75                       		rts
0000DF9C                            
0000DF9C                            AMPS_DebugR_ChkTracker2_fm1
0000DF9C                            	Console.Write " %<fpal0> FM1"
0000DF9C 40E7                     M 	move.w	sr,-(sp)
0000DF9E                          M 	__fstring_generateargumentscode	" %<fpal0> FM1"
0000DF9E =00000002                M 	__pos:	set instr(" %<fpal0> FM1",'%<')
0000DF9E =00000000                M 	__stack:set	0
0000DF9E =00000000                M 	__sp:	set 0
0000DF9E                          M 	while	(__pos)
0000DF9E =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM1",'>')
0000DF9E =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM1",' ')
0000DF9E =00000009                M 	__midpos:	= __endpos
0000DF9E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM1"
0000DF9E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM1"
0000DF9E =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM1",'%<')
0000DF9E                          M 	rept	__stack
0000DF9E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DFA2 43FA 0000                M 	lea	.str_508(pc),a1
0000DFA6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DFAC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DFB0 46DF                     M 	move.w	(sp)+,sr
0000DFB2 6000 0000                M 	bra.w	.instr_end_508
0000DFB6                          M 	.str_508:
0000DFB6                          M 	__fstring_generatedecodedstring	" %<fpal0> FM1"
0000DFB6 =00000001                M 	__lpos:	set 1
0000DFB6 =00000002                M 	__pos:	set instr(" %<fpal0> FM1",'%<')
0000DFB6                          M 	while	(__pos)
0000DFB6                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM1"
0000DFB6 20                       M 	dc.b	" "
0000DFB7 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM1",'>')
0000DFB7 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM1",' ')
0000DFB7 =00000009                M 	__midpos:	= __endpos
0000DFB7                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM1"
0000DFB7                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM1"
0000DFB7 E8                       M 	dc.b	fpal0
0000DFB8 =0000000A                M 	__lpos:	set __endpos+1
0000DFB8 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM1",'%<')
0000DFB8                          M 	__substr:	substr __lpos,," %<fpal0> FM1"
0000DFB8 2046 4D31                M 	dc.b	" FM1"
0000DFBC 00                       M 	dc.b	0
0000DFBE 00                       M 	even
0000DFBE                          M 	.instr_end_508:
0000DFBE 4E75                       		rts
0000DFC0                            
0000DFC0                            AMPS_DebugR_ChkTracker2_fm2
0000DFC0                            	Console.Write " %<fpal0> FM2"
0000DFC0 40E7                     M 	move.w	sr,-(sp)
0000DFC2                          M 	__fstring_generateargumentscode	" %<fpal0> FM2"
0000DFC2 =00000002                M 	__pos:	set instr(" %<fpal0> FM2",'%<')
0000DFC2 =00000000                M 	__stack:set	0
0000DFC2 =00000000                M 	__sp:	set 0
0000DFC2                          M 	while	(__pos)
0000DFC2 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM2",'>')
0000DFC2 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM2",' ')
0000DFC2 =00000009                M 	__midpos:	= __endpos
0000DFC2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM2"
0000DFC2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM2"
0000DFC2 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM2",'%<')
0000DFC2                          M 	rept	__stack
0000DFC2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DFC6 43FA 0000                M 	lea	.str_511(pc),a1
0000DFCA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DFD0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DFD4 46DF                     M 	move.w	(sp)+,sr
0000DFD6 6000 0000                M 	bra.w	.instr_end_511
0000DFDA                          M 	.str_511:
0000DFDA                          M 	__fstring_generatedecodedstring	" %<fpal0> FM2"
0000DFDA =00000001                M 	__lpos:	set 1
0000DFDA =00000002                M 	__pos:	set instr(" %<fpal0> FM2",'%<')
0000DFDA                          M 	while	(__pos)
0000DFDA                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM2"
0000DFDA 20                       M 	dc.b	" "
0000DFDB =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM2",'>')
0000DFDB =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM2",' ')
0000DFDB =00000009                M 	__midpos:	= __endpos
0000DFDB                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM2"
0000DFDB                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM2"
0000DFDB E8                       M 	dc.b	fpal0
0000DFDC =0000000A                M 	__lpos:	set __endpos+1
0000DFDC =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM2",'%<')
0000DFDC                          M 	__substr:	substr __lpos,," %<fpal0> FM2"
0000DFDC 2046 4D32                M 	dc.b	" FM2"
0000DFE0 00                       M 	dc.b	0
0000DFE2 00                       M 	even
0000DFE2                          M 	.instr_end_511:
0000DFE2 4E75                       		rts
0000DFE4                            
0000DFE4                            AMPS_DebugR_ChkTracker2_fm3
0000DFE4                            	Console.Write " %<fpal0> FM3"
0000DFE4 40E7                     M 	move.w	sr,-(sp)
0000DFE6                          M 	__fstring_generateargumentscode	" %<fpal0> FM3"
0000DFE6 =00000002                M 	__pos:	set instr(" %<fpal0> FM3",'%<')
0000DFE6 =00000000                M 	__stack:set	0
0000DFE6 =00000000                M 	__sp:	set 0
0000DFE6                          M 	while	(__pos)
0000DFE6 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM3",'>')
0000DFE6 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM3",' ')
0000DFE6 =00000009                M 	__midpos:	= __endpos
0000DFE6                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM3"
0000DFE6                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM3"
0000DFE6 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM3",'%<')
0000DFE6                          M 	rept	__stack
0000DFE6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DFEA 43FA 0000                M 	lea	.str_514(pc),a1
0000DFEE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DFF4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DFF8 46DF                     M 	move.w	(sp)+,sr
0000DFFA 6000 0000                M 	bra.w	.instr_end_514
0000DFFE                          M 	.str_514:
0000DFFE                          M 	__fstring_generatedecodedstring	" %<fpal0> FM3"
0000DFFE =00000001                M 	__lpos:	set 1
0000DFFE =00000002                M 	__pos:	set instr(" %<fpal0> FM3",'%<')
0000DFFE                          M 	while	(__pos)
0000DFFE                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM3"
0000DFFE 20                       M 	dc.b	" "
0000DFFF =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM3",'>')
0000DFFF =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM3",' ')
0000DFFF =00000009                M 	__midpos:	= __endpos
0000DFFF                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM3"
0000DFFF                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM3"
0000DFFF E8                       M 	dc.b	fpal0
0000E000 =0000000A                M 	__lpos:	set __endpos+1
0000E000 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM3",'%<')
0000E000                          M 	__substr:	substr __lpos,," %<fpal0> FM3"
0000E000 2046 4D33                M 	dc.b	" FM3"
0000E004 00                       M 	dc.b	0
0000E006 00                       M 	even
0000E006                          M 	.instr_end_514:
0000E006 4E75                       		rts
0000E008                            
0000E008                            AMPS_DebugR_ChkTracker2_fm4
0000E008                            	Console.Write " %<fpal0> FM4"
0000E008 40E7                     M 	move.w	sr,-(sp)
0000E00A                          M 	__fstring_generateargumentscode	" %<fpal0> FM4"
0000E00A =00000002                M 	__pos:	set instr(" %<fpal0> FM4",'%<')
0000E00A =00000000                M 	__stack:set	0
0000E00A =00000000                M 	__sp:	set 0
0000E00A                          M 	while	(__pos)
0000E00A =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM4",'>')
0000E00A =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM4",' ')
0000E00A =00000009                M 	__midpos:	= __endpos
0000E00A                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM4"
0000E00A                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM4"
0000E00A =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM4",'%<')
0000E00A                          M 	rept	__stack
0000E00A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E00E 43FA 0000                M 	lea	.str_517(pc),a1
0000E012 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E018 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E01C 46DF                     M 	move.w	(sp)+,sr
0000E01E 6000 0000                M 	bra.w	.instr_end_517
0000E022                          M 	.str_517:
0000E022                          M 	__fstring_generatedecodedstring	" %<fpal0> FM4"
0000E022 =00000001                M 	__lpos:	set 1
0000E022 =00000002                M 	__pos:	set instr(" %<fpal0> FM4",'%<')
0000E022                          M 	while	(__pos)
0000E022                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM4"
0000E022 20                       M 	dc.b	" "
0000E023 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM4",'>')
0000E023 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM4",' ')
0000E023 =00000009                M 	__midpos:	= __endpos
0000E023                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM4"
0000E023                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM4"
0000E023 E8                       M 	dc.b	fpal0
0000E024 =0000000A                M 	__lpos:	set __endpos+1
0000E024 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM4",'%<')
0000E024                          M 	__substr:	substr __lpos,," %<fpal0> FM4"
0000E024 2046 4D34                M 	dc.b	" FM4"
0000E028 00                       M 	dc.b	0
0000E02A 00                       M 	even
0000E02A                          M 	.instr_end_517:
0000E02A 4E75                       		rts
0000E02C                            
0000E02C                            AMPS_DebugR_ChkTracker2_fm5
0000E02C                            	Console.Write " %<fpal0> FM5"
0000E02C 40E7                     M 	move.w	sr,-(sp)
0000E02E                          M 	__fstring_generateargumentscode	" %<fpal0> FM5"
0000E02E =00000002                M 	__pos:	set instr(" %<fpal0> FM5",'%<')
0000E02E =00000000                M 	__stack:set	0
0000E02E =00000000                M 	__sp:	set 0
0000E02E                          M 	while	(__pos)
0000E02E =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM5",'>')
0000E02E =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM5",' ')
0000E02E =00000009                M 	__midpos:	= __endpos
0000E02E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM5"
0000E02E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM5"
0000E02E =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM5",'%<')
0000E02E                          M 	rept	__stack
0000E02E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E032 43FA 0000                M 	lea	.str_520(pc),a1
0000E036 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E03C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E040 46DF                     M 	move.w	(sp)+,sr
0000E042 6000 0000                M 	bra.w	.instr_end_520
0000E046                          M 	.str_520:
0000E046                          M 	__fstring_generatedecodedstring	" %<fpal0> FM5"
0000E046 =00000001                M 	__lpos:	set 1
0000E046 =00000002                M 	__pos:	set instr(" %<fpal0> FM5",'%<')
0000E046                          M 	while	(__pos)
0000E046                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM5"
0000E046 20                       M 	dc.b	" "
0000E047 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM5",'>')
0000E047 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM5",' ')
0000E047 =00000009                M 	__midpos:	= __endpos
0000E047                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM5"
0000E047                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM5"
0000E047 E8                       M 	dc.b	fpal0
0000E048 =0000000A                M 	__lpos:	set __endpos+1
0000E048 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM5",'%<')
0000E048                          M 	__substr:	substr __lpos,," %<fpal0> FM5"
0000E048 2046 4D35                M 	dc.b	" FM5"
0000E04C 00                       M 	dc.b	0
0000E04E 00                       M 	even
0000E04E                          M 	.instr_end_520:
0000E04E 4E75                       		rts
0000E050                            
0000E050                            AMPS_DebugR_ChkTracker2_psg1
0000E050                            	Console.Write " %<fpal0>PSG1"
0000E050 40E7                     M 	move.w	sr,-(sp)
0000E052                          M 	__fstring_generateargumentscode	" %<fpal0>PSG1"
0000E052 =00000002                M 	__pos:	set instr(" %<fpal0>PSG1",'%<')
0000E052 =00000000                M 	__stack:set	0
0000E052 =00000000                M 	__sp:	set 0
0000E052                          M 	while	(__pos)
0000E052 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG1",'>')
0000E052 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG1",' ')
0000E052 =00000009                M 	__midpos:	= __endpos
0000E052                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG1"
0000E052                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG1"
0000E052 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG1",'%<')
0000E052                          M 	rept	__stack
0000E052 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E056 43FA 0000                M 	lea	.str_523(pc),a1
0000E05A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E060 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E064 46DF                     M 	move.w	(sp)+,sr
0000E066 6000 0000                M 	bra.w	.instr_end_523
0000E06A                          M 	.str_523:
0000E06A                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG1"
0000E06A =00000001                M 	__lpos:	set 1
0000E06A =00000002                M 	__pos:	set instr(" %<fpal0>PSG1",'%<')
0000E06A                          M 	while	(__pos)
0000E06A                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG1"
0000E06A 20                       M 	dc.b	" "
0000E06B =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG1",'>')
0000E06B =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG1",' ')
0000E06B =00000009                M 	__midpos:	= __endpos
0000E06B                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG1"
0000E06B                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG1"
0000E06B E8                       M 	dc.b	fpal0
0000E06C =0000000A                M 	__lpos:	set __endpos+1
0000E06C =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG1",'%<')
0000E06C                          M 	__substr:	substr __lpos,," %<fpal0>PSG1"
0000E06C 5053 4731                M 	dc.b	"PSG1"
0000E070 00                       M 	dc.b	0
0000E072 00                       M 	even
0000E072                          M 	.instr_end_523:
0000E072 4E75                       		rts
0000E074                            
0000E074                            AMPS_DebugR_ChkTracker2_psg2
0000E074                            	Console.Write " %<fpal0>PSG2"
0000E074 40E7                     M 	move.w	sr,-(sp)
0000E076                          M 	__fstring_generateargumentscode	" %<fpal0>PSG2"
0000E076 =00000002                M 	__pos:	set instr(" %<fpal0>PSG2",'%<')
0000E076 =00000000                M 	__stack:set	0
0000E076 =00000000                M 	__sp:	set 0
0000E076                          M 	while	(__pos)
0000E076 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG2",'>')
0000E076 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG2",' ')
0000E076 =00000009                M 	__midpos:	= __endpos
0000E076                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG2"
0000E076                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG2"
0000E076 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG2",'%<')
0000E076                          M 	rept	__stack
0000E076 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E07A 43FA 0000                M 	lea	.str_526(pc),a1
0000E07E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E084 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E088 46DF                     M 	move.w	(sp)+,sr
0000E08A 6000 0000                M 	bra.w	.instr_end_526
0000E08E                          M 	.str_526:
0000E08E                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG2"
0000E08E =00000001                M 	__lpos:	set 1
0000E08E =00000002                M 	__pos:	set instr(" %<fpal0>PSG2",'%<')
0000E08E                          M 	while	(__pos)
0000E08E                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG2"
0000E08E 20                       M 	dc.b	" "
0000E08F =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG2",'>')
0000E08F =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG2",' ')
0000E08F =00000009                M 	__midpos:	= __endpos
0000E08F                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG2"
0000E08F                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG2"
0000E08F E8                       M 	dc.b	fpal0
0000E090 =0000000A                M 	__lpos:	set __endpos+1
0000E090 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG2",'%<')
0000E090                          M 	__substr:	substr __lpos,," %<fpal0>PSG2"
0000E090 5053 4732                M 	dc.b	"PSG2"
0000E094 00                       M 	dc.b	0
0000E096 00                       M 	even
0000E096                          M 	.instr_end_526:
0000E096 4E75                       		rts
0000E098                            
0000E098                            AMPS_DebugR_ChkTracker2_psg3
0000E098                            	Console.Write " %<fpal0>PSG3"
0000E098 40E7                     M 	move.w	sr,-(sp)
0000E09A                          M 	__fstring_generateargumentscode	" %<fpal0>PSG3"
0000E09A =00000002                M 	__pos:	set instr(" %<fpal0>PSG3",'%<')
0000E09A =00000000                M 	__stack:set	0
0000E09A =00000000                M 	__sp:	set 0
0000E09A                          M 	while	(__pos)
0000E09A =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG3",'>')
0000E09A =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG3",' ')
0000E09A =00000009                M 	__midpos:	= __endpos
0000E09A                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG3"
0000E09A                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG3"
0000E09A =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG3",'%<')
0000E09A                          M 	rept	__stack
0000E09A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E09E 43FA 0000                M 	lea	.str_529(pc),a1
0000E0A2 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E0A8 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E0AC 46DF                     M 	move.w	(sp)+,sr
0000E0AE 6000 0000                M 	bra.w	.instr_end_529
0000E0B2                          M 	.str_529:
0000E0B2                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG3"
0000E0B2 =00000001                M 	__lpos:	set 1
0000E0B2 =00000002                M 	__pos:	set instr(" %<fpal0>PSG3",'%<')
0000E0B2                          M 	while	(__pos)
0000E0B2                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG3"
0000E0B2 20                       M 	dc.b	" "
0000E0B3 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG3",'>')
0000E0B3 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG3",' ')
0000E0B3 =00000009                M 	__midpos:	= __endpos
0000E0B3                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG3"
0000E0B3                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG3"
0000E0B3 E8                       M 	dc.b	fpal0
0000E0B4 =0000000A                M 	__lpos:	set __endpos+1
0000E0B4 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG3",'%<')
0000E0B4                          M 	__substr:	substr __lpos,," %<fpal0>PSG3"
0000E0B4 5053 4733                M 	dc.b	"PSG3"
0000E0B8 00                       M 	dc.b	0
0000E0BA 00                       M 	even
0000E0BA                          M 	.instr_end_529:
0000E0BA 4E75                       		rts
0000E0BC                            ; ===========================================================================
0000E0BC                            ; ---------------------------------------------------------------------------
0000E0BC                            ; Routine for loading the Dual PCM driver into Z80 RAM
0000E0BC                            ; ---------------------------------------------------------------------------
0000E0BC                            
0000E0BC                            LoadDualPCM:
0000E0BC 33FC 0100 00A1 1100        		move.w	#$0100,$A11100		; request Z80 stop
0000E0C4 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0000E0CC                            
0000E0CC 41F9 0000 0000             		lea	DualPCM,a0		; load Dual PCM address into a0
0000E0D2 43F9 00A0 0000             		lea	dZ80,a1			; load Z80 RAM address into a1
0000E0D8 323C 0000                  		move.w	#DualPCM_sz-1,d1	; get lenght counter for dbf into d1
0000E0DC                            
0000E0DC                            .z80
0000E0DC 0839 0000 00A1 1100        		btst	#$00,$A11100		; check if Z80 has stopped
0000E0E4 66F6                       		bne.s	.z80			; if not, wait more
0000E0E6                            
0000E0E6                            .load
0000E0E6 12D8                       		move.b	(a0)+,(a1)+		; copy the Dual PCM driver into Z80 RAM
0000E0E8 51C9 FFFC                  		dbf	d1,.load		; write every single byte
0000E0EC                            
0000E0EC 41FA 0000                  		lea	SampleList(pc),a0	; load address for the stop sample data into a0
0000E0F0 43F9 0000 0000             		lea	dZ80+MuteSample,a1	; load address in Dual PCM to write into a1
0000E0F6                            
0000E0F6                            	rept 6
0000E0F6                            		move.b	(a0)+,(a1)+		; copy all required data
0000E0F6                            	endr
0000E0F6 12D8                     M 	move.b	(a0)+,(a1)+
0000E0F8 12D8                     M 	move.b	(a0)+,(a1)+
0000E0FA 12D8                     M 	move.b	(a0)+,(a1)+
0000E0FC 12D8                     M 	move.b	(a0)+,(a1)+
0000E0FE 12D8                     M 	move.b	(a0)+,(a1)+
0000E100 12D8                     M 	move.b	(a0)+,(a1)+
0000E102                            
0000E102 7002                       		moveq	#2,d0			; set flush timer for 60hz systems
0000E104 0838 0006 C746             		btst	#6,hwVersion.w	; is this a PAL Mega Drive?
0000E10A 6700                       		beq.s	.ntsc			; if not, branch
0000E10C 7003                       		moveq	#3,d0			; set flush timer for 50hz systems
0000E10E                            .ntsc
0000E10E 13C0 0000 0000             		move.b	d0,dZ80+YM_FlushTimer+2	; save flush timer
0000E114                            
0000E114 33FC 0000 00A1 1200        		move.w	#$0000,$A11200		; request Z80 reset
0000E11C 727F                       		moveq	#$7F,d1			; wait for a little bit
0000E11E 51C9 FFFE                  		dbf	d1,*			; we can't check for reset, so we need to delay
0000E122                            
0000E122 33FC 0000 00A1 1100        		move.w	#$0000,$A11100		; enable Z80
0000E12A 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0000E132 4E75                       		rts
0000E134                            ; ---------------------------------------------------------------------------
0000E134                            ; Play DAC
0000E134                            ; ---------------------------------------------------------------------------
0000E134                            
0000E134                            PlayDAC2:
0000E134 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0000E13A                            	StopZ80					; wait for Z80 to stop
0000E13A 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E142                          M 	waitz80stop
0000E142 0839 0000 00A1 1100      M .wait_533:	btst	#0,z80_bus_req
0000E14A 66F6                     M 	bne.s	.wait_533
0000E14C                            	rept 12
0000E14C                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E14C                            	endr
0000E14C 12DB                     M 	move.b	(a3)+,(a1)+
0000E14E 12DB                     M 	move.b	(a3)+,(a1)+
0000E150 12DB                     M 	move.b	(a3)+,(a1)+
0000E152 12DB                     M 	move.b	(a3)+,(a1)+
0000E154 12DB                     M 	move.b	(a3)+,(a1)+
0000E156 12DB                     M 	move.b	(a3)+,(a1)+
0000E158 12DB                     M 	move.b	(a3)+,(a1)+
0000E15A 12DB                     M 	move.b	(a3)+,(a1)+
0000E15C 12DB                     M 	move.b	(a3)+,(a1)+
0000E15E 12DB                     M 	move.b	(a3)+,(a1)+
0000E160 12DB                     M 	move.b	(a3)+,(a1)+
0000E162 12DB                     M 	move.b	(a3)+,(a1)+
0000E164 101B                       		move.b	(a3)+,d0
0000E166 5200                       		addq.b	#1,d0
0000E168 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchHigh+1
0000E16E 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM2_PitchLow+1
0000E174 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0000E17C                            
0000E17C 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0000E184                            	StartZ80				; enable Z80 execution
0000E184 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E18C 4E75                       		rts
0000E18E                            
0000E18E                            ; ---------------------------------------------------------------------------
0000E18E                            
0000E18E                            PlayDAC1:
0000E18E 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1
0000E194                            	StopZ80					; wait for Z80 to stop
0000E194 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E19C                          M 	waitz80stop
0000E19C 0839 0000 00A1 1100      M .wait_536:	btst	#0,z80_bus_req
0000E1A4 66F6                     M 	bne.s	.wait_536
0000E1A6                            	rept 12
0000E1A6                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E1A6                            	endr
0000E1A6 12DB                     M 	move.b	(a3)+,(a1)+
0000E1A8 12DB                     M 	move.b	(a3)+,(a1)+
0000E1AA 12DB                     M 	move.b	(a3)+,(a1)+
0000E1AC 12DB                     M 	move.b	(a3)+,(a1)+
0000E1AE 12DB                     M 	move.b	(a3)+,(a1)+
0000E1B0 12DB                     M 	move.b	(a3)+,(a1)+
0000E1B2 12DB                     M 	move.b	(a3)+,(a1)+
0000E1B4 12DB                     M 	move.b	(a3)+,(a1)+
0000E1B6 12DB                     M 	move.b	(a3)+,(a1)+
0000E1B8 12DB                     M 	move.b	(a3)+,(a1)+
0000E1BA 12DB                     M 	move.b	(a3)+,(a1)+
0000E1BC 12DB                     M 	move.b	(a3)+,(a1)+
0000E1BE 101B                       		move.b	(a3)+,d0
0000E1C0 5200                       		addq.b	#1,d0
0000E1C2 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchHigh+1
0000E1C8 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM1_PitchLow+1
0000E1CE 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0000E1D6                            
0000E1D6 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0000E1DE                            	StartZ80				; enable Z80 execution
0000E1DE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E1E6 4E75                       		rts
0000E1E8                            ; ===========================================================================
0000E1E8                            ; ---------------------------------------------------------------------------
0000E1E8                            ; Handle Dual PCM YM Cue correctly
0000E1E8                            ; ---------------------------------------------------------------------------
0000E1E8                            
0000E1E8                            UpdateAMPS:
0000E1E8                            	StopZ80					; wait for Z80 to stop
0000E1E8 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E1F0                          M 	waitz80stop
0000E1F0 0839 0000 00A1 1100      M .wait_539:	btst	#0,z80_bus_req
0000E1F8 66F6                     M 	bne.s	.wait_539
0000E1FA 1039 0000 0000             		move.b	dZ80+YM_Buffer,d0	; load current cue buffer in use
0000E200                            	StartZ80				; enable Z80 execution
0000E200 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E208                            
0000E208 207C 0000 0000             		move.l	#dZ80+YM_Buffer1,a0	; set the cue address to buffer 1
0000E20E 4A00                       		tst.b	d0			; check buffer to use
0000E210 6600                       		bne.s	.gotbuffer		; if Z80 is reading buffer 2, branch
0000E212 D0FC 0000                  		add.w	#YM_Buffer2-YM_Buffer1,a0; set the cue address to buffer 2
0000E216                            
0000E216                            .gotbuffer
0000E216 6100                       		bsr.s	dUpdateAllAMPS		; process the driver
0000E218                            		AMPS_Debug_CuePtr 3		; check if the cue is still valid
0000E218 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000E21E 6500                     M 	blo.s	.fail_541
0000E220 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000E226 6500                     M 	blo.s	.ok_541
0000E228                          M .fail_541
0000E228 4EBA FAB8                M 	jsr	amps_debug_cueptr3
0000E22C                          M .ok_541
0000E22C                            
0000E22C                            	StopZ80					; wait for Z80 to stop
0000E22C 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E234                          M 	waitz80stop
0000E234 0839 0000 00A1 1100      M .wait_543:	btst	#0,z80_bus_req
0000E23C 66F6                     M 	bne.s	.wait_543
0000E23E 50D0                       		st	(a0)			; make sure cue is marked as completed
0000E240                            	StartZ80				; enable Z80 execution
0000E240 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E248                            
0000E248                            dPaused:
0000E248 4E75                       		rts
0000E24A                            ; ===========================================================================
0000E24A                            ; ---------------------------------------------------------------------------
0000E24A                            ; Main routine for updating the AMPS driver
0000E24A                            ; ---------------------------------------------------------------------------
0000E24A                            
0000E24A                            dUpdateAllAMPS:
0000E24A 4EBA 0000                  		jsr	dPlaySnd(pc)		; check if any music needs playing
0000E24E 4A38 C4A6                  		tst.b	mFlags.w		; is music paused?
0000E252 6BF4                       		bmi.s	dPaused			; if yes, branch
0000E254                            ; ---------------------------------------------------------------------------
0000E254                            ; This is the new fading feature I created, to make custom fading
0000E254                            ; types easier to program. You can define series of 3 bytes, each
0000E254                            ; representing FM, PSG and DAC volumes. Each group of 3 is executed
0000E254                            ; once per frame. If the first value in a frame is a command flag,
0000E254                            ; instead its code is executed. Additionally, no fade program may
0000E254                            ; appear before ROM offset $10000, or else it will never be executed.
0000E254                            ; ---------------------------------------------------------------------------
0000E254                            
0000E254 4A38 C4B5                  .notempo	tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0000E258 6700 0000                  		beq.w	.chkregion		; branch if not
0000E25C                            
0000E25C 2278 C4B4                  		move.l	mFadeAddr.w,a1		; get the fade porogram address to a1
0000E260 56B8 C4B4                  		addq.l	#3,mFadeAddr.w		; set the fade address to next group
0000E264                            
0000E264 7220                       		moveq	#(1<<cfbVol),d1		; prepare volume update to d1
0000E266 7000                       		moveq	#0,d0
0000E268 1019                       		move.b	(a1)+,d0		; get FM/command byte from fade data
0000E26A 6A00                       		bpl.s	.nofadeend		; branch if this is not a command
0000E26C                            
0000E26C                            		AMPS_Debug_FadeCmd		; check if this command is valid
0000E26C 0C00 0090                M 	cmp.b	#flast,d0
0000E270 6400                     M 	bhs.s	.fail
0000E272 0C00 0080                M 	cmp.b	#$80,d0
0000E276 6500                     M 	blo.s	.fail
0000E278 0800 0001                M 	btst	#1,d0
0000E27C 6600                     M 	bne.s	.fail
0000E27E 0800 0000                M 	btst	#0,d0
0000E282 6700                     M 	beq.s	.ok
0000E284                          M .fail
0000E284 4EBA F8B2                M 	jsr	amps_debugr_fadecmd
0000E288                          M .ok
0000E288 45FA 0000                  		lea	dFadeCommands-$80(pc),a2; load fade commands pointer table to a2
0000E28C 4EB2 0000                  		jsr	(a2,d0.w)		; run the fade command code
0000E290 4238 C4B5                  		clr.b	mFadeAddr+1.w		; mark the fade program as completed
0000E294 6000                       		bra.s	.chkregion		; go check the region
0000E296                            
0000E296                            .nofadeend
0000E296 B038 C4B4                  		cmp.b	mMasterVolFM.w,d0	; check if volume did not change
0000E29A 6700                       		beq.s	.fadedac		; if did not, branch
0000E29C 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save the new volume
0000E2A0 4EBA 0000                  		jsr	dReqVolUpFM(pc)		; go request volume update for FM
0000E2A4                            
0000E2A4                            .fadedac
0000E2A4 1019                       		move.b	(a1)+,d0		; get DAC volume byte from fade data
0000E2A6 B038 C4C0                  		cmp.b	mMasterVolDAC.w,d0	; check if volume did not change
0000E2AA 6700                       		beq.s	.fadepsg		; if did not, branch
0000E2AC 11C0 C4C0                  		move.b	d0,mMasterVolDAC.w	; save new volume
0000E2B0                            
0000E2B0 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0000E2B0                            	rept Mus_DAC				; do for all music DAC channels
0000E2B0                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E2B0                            .ch =		.ch+cSize			; go to next channel
0000E2B0                            	endr
0000E2B0 8338 C4C4                M 	or.b	d1,.ch.w
0000E2B4 =FFFFC4F0                M .ch	=	.ch+csize
0000E2B4 8338 C4F0                M 	or.b	d1,.ch.w
0000E2B8 =FFFFC51C                M .ch	=	.ch+csize
0000E2B8 8338 C67C                  		or.b	d1,mSFXDAC1.w		; tell SFX DAC1 to update its volume
0000E2BC                            
0000E2BC                            .fadepsg
0000E2BC 1019                       		move.b	(a1)+,d0		; get PSG volume byte from fade data
0000E2BE B038 C4BF                  		cmp.b	mMasterVolPSG.w,d0	; check if volume did not change
0000E2C2 6700                       		beq.s	.chkregion		; if did not, branch
0000E2C4 11C0 C4BF                  		move.b	d0,mMasterVolPSG.w	; save new volume
0000E2C8                            
0000E2C8 =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0000E2C8                            	rept Mus_PSG				; do for all music PSG channels
0000E2C8                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E2C8                            .ch =		.ch+cSize			; go to next channel
0000E2C8                            	endr
0000E2C8 8338 C5F8                M 	or.b	d1,.ch.w
0000E2CC =FFFFC624                M .ch	=	.ch+csize
0000E2CC 8338 C624                M 	or.b	d1,.ch.w
0000E2D0 =FFFFC650                M .ch	=	.ch+csize
0000E2D0 8338 C650                M 	or.b	d1,.ch.w
0000E2D4 =FFFFC67C                M .ch	=	.ch+csize
0000E2D4                            
0000E2D4 =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0000E2D4                            	rept SFX_PSG				; do for all SFX PSG channels
0000E2D4                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E2D4                            .ch =		.ch+cSizeSFX			; go to next channel
0000E2D4                            	endr
0000E2D4 8338 C6EC                M 	or.b	d1,.ch.w
0000E2D8 =FFFFC708                M .ch	=	.ch+csizesfx
0000E2D8 8338 C708                M 	or.b	d1,.ch.w
0000E2DC =FFFFC724                M .ch	=	.ch+csizesfx
0000E2DC 8338 C724                M 	or.b	d1,.ch.w
0000E2E0 =FFFFC740                M .ch	=	.ch+csizesfx
0000E2E0                            ; ---------------------------------------------------------------------------
0000E2E0                            ; Since PAL Mega Drive's run slower than NTSC, if we want the music to
0000E2E0                            ; sound consistent, we need to run the sound driver 1.2 times as fast
0000E2E0                            ; on PAL systems. This will cause issues with some songs that rely on
0000E2E0                            ; game engine to seem "in sync". Because of that, I added a flag to
0000E2E0                            ; disable the PAL fix (much like in Sonic 2's driver). Unlike the fix
0000E2E0                            ; in SMPS drivers (and Sonic 3 and above), this fix will make the music
0000E2E0                            ; play at the exact right speed, instead of slightly too slow.
0000E2E0                            ; ---------------------------------------------------------------------------
0000E2E0                            
0000E2E0 0838 0006 C746             .chkregion	btst	#6,hwVersion.w	; is this PAL system?
0000E2E6 6700                       		beq.s	.driver			; if not, branch
0000E2E8 5338 C4A7                  		subq.b	#1,mCtrPal.w		; decrease PAL frame counter
0000E2EC 6E00                       		bgt.s	.driver			; if hasn't become 0 (or lower!), branch
0000E2EE                            
0000E2EE 0838 0003 C4A6             		btst	#mfbNoPAL,mFlags.w	; check if we have disabled the PAL fix
0000E2F4 6600                       		bne.s	.nofix			; if yes, run music and SFX
0000E2F6 6100                       		bsr.s	.nosfx			; run the sound driver
0000E2F8                            
0000E2F8                            .nofix
0000E2F8 11FC 0005 C4A7             		move.b	#6-1,mCtrPal.w		; reset counter
0000E2FE                            .driver
0000E2FE 6100 0000                  		bsr.w	dAMPSdoSFX		; run SFX this time
0000E302                            
0000E302                            .nosfx		; continue to run sound driver again
0000E302                            ; ---------------------------------------------------------------------------
0000E302                            ; There are 2 methods of handling tempo adjustments in SMPS,
0000E302                            ; overflow (where a value is added to the accumulator, and when it
0000E302                            ; range overflows, tick of delay is added), and counter (where a
0000E302                            ; counter is copied to the tempo, which is then decreased each frame,
0000E302                            ; until it becomes 0, after which a tick of delay is added). AMPS
0000E302                            ; supports these both too, because there is no single right answer,
0000E302                            ; and users may prefer one over the other. The overflow method is
0000E302                            ; really good for low values, as it provides very fine control over
0000E302                            ; the tempo, but at high ranges it gets worse. Meanwhile the counter
0000E302                            ; method isn't as good for small values, but for large value it works
0000E302                            ; better. You may choose this setting in the macro.asm file,
0000E302                            ; ---------------------------------------------------------------------------
0000E302                            
0000E302 1038 C4BA                  		move.b	mTempo.w,d0		; get tempo to d0
0000E306 D138 C4BB                  		add.b	d0,mTempoCur.w		; add to accumulator
0000E30A 6400                       		bcc.s	dAMPSdoAll		; if carry clear, branch
0000E30C                            
0000E30C                            
0000E30C =FFFFC4D0                  .ch =	mDAC1+cDuration				; start at DAC1 duration
0000E30C                            	rept Mus_Ch				; loop through all music channels
0000E30C                            		addq.b	#1,.ch.w		; add 1 to duration
0000E30C                            .ch =		.ch+cSize			; go to next channel
0000E30C                            	endr
0000E30C 5238 C4D0                M 	addq.b	#1,.ch.w
0000E310 =FFFFC4FC                M .ch	=	.ch+csize
0000E310 5238 C4FC                M 	addq.b	#1,.ch.w
0000E314 =FFFFC528                M .ch	=	.ch+csize
0000E314 5238 C528                M 	addq.b	#1,.ch.w
0000E318 =FFFFC554                M .ch	=	.ch+csize
0000E318 5238 C554                M 	addq.b	#1,.ch.w
0000E31C =FFFFC580                M .ch	=	.ch+csize
0000E31C 5238 C580                M 	addq.b	#1,.ch.w
0000E320 =FFFFC5AC                M .ch	=	.ch+csize
0000E320 5238 C5AC                M 	addq.b	#1,.ch.w
0000E324 =FFFFC5D8                M .ch	=	.ch+csize
0000E324 5238 C5D8                M 	addq.b	#1,.ch.w
0000E328 =FFFFC604                M .ch	=	.ch+csize
0000E328 5238 C604                M 	addq.b	#1,.ch.w
0000E32C =FFFFC630                M .ch	=	.ch+csize
0000E32C 5238 C630                M 	addq.b	#1,.ch.w
0000E330 =FFFFC65C                M .ch	=	.ch+csize
0000E330 5238 C65C                M 	addq.b	#1,.ch.w
0000E334 =FFFFC688                M .ch	=	.ch+csize
0000E334                            ; ===========================================================================
0000E334                            ; ---------------------------------------------------------------------------
0000E334                            ; Process music DAC channels
0000E334                            ; ---------------------------------------------------------------------------
0000E334                            
0000E334                            dAMPSdoAll:
0000E334 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0000E338 4BF8 C498                  		lea	mDAC1-cSize.w,a5	; get DAC1 channel RAM address into a5
0000E33C 7E01                       		moveq	#Mus_DAC-1,d7		; get total number of DAC channels to d7
0000E33E                            
0000E33E                            dAMPSdoDAC:
0000E33E DAFC 002C                  		add.w	#cSize,a5		; go to the next channel (first time its mDAC1!)
0000E342 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000E344 6A00 0000                  		bpl.w	.next			; if not, branch
0000E348 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000E34C 6700 0000                  		beq.w	.update			; if timed out, update channel
0000E350                            	dNoteToutDAC	 			; handle DAC-specific note timeout behavior
0000E350                          M 	dnotetouthandler
0000E350 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000E354 6700                     M 	beq.s	.endt
0000E356 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000E35A 6600                     M 	bne.s	.endt
0000E35C 7000                     M 	moveq	#0,d0
0000E35E 6000 0000                M 	bra.w	dnoteondac2
0000E362                          M .endt
0000E362                            
0000E362                            	dCalcFreq				; calculate channel base frequency
0000E362 1C2D 0007                M 	move.b	cdetune(a5),d6
0000E366 4886                     M 	ext.w	d6
0000E368 DC6D 000E                M 	add.w	cfreq(a5),d6
0000E36C                            	dModulate dAMPSdoFM, dAMPSdoDAC, 4	; run modulation code
0000E36C 0815 0003                M 	btst	#cfbmod,(a5)
0000E370 6700                     M 	beq.s	.noret
0000E372 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000E376 6700                     M 	beq.s	.started
0000E378 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000E37C                          M .noret
0000E37C 0895 0005                M 	bclr	#cfbvol,(a5)
0000E380 6700                     M 	beq.s	.noupdatevol
0000E382 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0000E386                          M 	.noupdatevol:
0000E386 51CF FFB6                M 	dbf	d7,dampsdodac
0000E38A 6000 0000                M 	bra.w	dampsdofm
0000E38E                          M .started
0000E38E 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000E392 66E8                     M 	bne.s	.noret
0000E394 226D 0010                M 	movea.l	cmod(a5),a1
0000E398 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000E39E 4A2D 0018                M 	tst.b	cmodcount(a5)
0000E3A2 6600                     M 	bne.s	.norev
0000E3A4 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000E3AA 442D 0017                M 	neg.b	cmodstep(a5)
0000E3AE                          M .norev
0000E3AE 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000E3B2 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000E3B6 4885                     M 	ext.w	d5
0000E3B8 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000E3BC 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000E3C0 DC45                     M 	add.w	d5,d6
0000E3C2 6100 0000                  		bsr.w	dUpdateFreqDAC		; if frequency needs changing, do it
0000E3C6                            
0000E3C6 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000E3CA 6700                       		beq.s	.next			; if not, skip
0000E3CC 6100 0000                  		bsr.w	dUpdateVolDAC		; update DAC volume
0000E3D0                            
0000E3D0                            .next
0000E3D0 51CF FF6C                  		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0000E3D4 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process music FM channels
0000E3D8                            
0000E3D8                            .update
0000E3D8 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0000E3DC                            	dDoTracker				; process tracker
0000E3DC 286D 0002                M 	movea.l	cdata(a5),a4
0000E3E0                          M 	amps_debug_trackupd
0000E3E0 220C                     M 	move.l	a4,d1
0000E3E2 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000E3E8 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000E3EE 6500                     M 	blo.s	.fail2
0000E3F0 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000E3F6 6500                     M 	blo.s	.data
0000E3F8                          M .fail2
0000E3F8                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E3F8 487A FFFE                M 	pea	*(pc)
0000E3FC                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E3FC 40E7                     M 	move.w	sr,-(sp)
0000E3FE                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E3FE =00000000                M 	__stack:set	0
0000E3FE =00000000                M 	__sp:	set 0
0000E3FE                          M 	while	(__pos)
0000E3FE =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E3FE =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E3FE =00000021                M 	__midpos:	= __endpos
0000E3FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE                          M 	pushp	"move.l a4,-(sp)"
0000E3FE =00000001                M 	__stack:	= __stack+1
0000E3FE =00000004                M 	__sp:	= __sp+4
0000E3FE =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E3FE =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E3FE =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E3FE =00000029                M 	__midpos:	= __endpos
0000E3FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E3FE =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E3FE =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E3FE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E3FE                          M 	pushp	"move.l a4,-(sp)"
0000E3FE =00000002                M 	__stack:	= __stack+1
0000E3FE =00000008                M 	__sp:	= __sp+4
0000E3FE =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E3FE                          M 	rept	__stack
0000E3FE                          M 	popp	__command
0000E3FE 2F0C                     M 	move.l	a4,-(sp)
0000E400                          M 	popp	__command
0000E400 2F0C                     M 	move.l	a4,-(sp)
0000E402 4EB9 0000 0000           M 	jsr	errorhandler
0000E408                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E408 =00000001                M 	__lpos:	set 1
0000E408 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E408                          M 	while	(__pos)
0000E408                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E408 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000E421 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E421 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E421 =00000021                M 	__midpos:	= __endpos
0000E421                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E421                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E421                          M 	__param:	substr ,,"hex"
0000E421 83                       M 	dc.b	hex|3
0000E422 =00000022                M 	__lpos:	set __endpos+1
0000E422 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E422                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E422                          M 	dc.b	""
0000E422 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E422 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E422 =00000029                M 	__midpos:	= __endpos
0000E422                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E422                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E422 E0                       M 	dc.b	fendl
0000E423 =0000002A                M 	__lpos:	set __endpos+1
0000E423 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E423                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E423                          M 	dc.b	""
0000E423 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E423 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E423                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E423                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E423 B3                       M 	dc.b	sym|3
0000E424 =00000036                M 	__lpos:	set __endpos+1
0000E424 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E424                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E424                          M 	dc.b	""
0000E424 00                       M 	dc.b	0
0000E425 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E426                          M 	even
0000E426 4EFA EB0A                M 	jmp	amps_debug_console_channel
0000E42A                          M 	even
0000E42A                          M .data
0000E42A 7A00                     M 	moveq	#0,d5
0000E42C 1A1C                     M 	move.b	(a4)+,d5
0000E42E 0C05 00E0                M 	cmpi.b	#$e0,d5
0000E432 6500                     M 	blo.s	.notcomm
0000E434 4EBA 0000                M 	jsr	dcommands(pc)
0000E438 60F0                     M 	bra.s	.data
0000E43A 6094                     M 	bra.s	.next
0000E43C                          M .notcomm
0000E43C 7C00                       		moveq	#0,d6			; clear rest flag
0000E43E 4A05                       		tst.b	d5			; check if note is being played
0000E440 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000E442                            
0000E442                            	dTrackNoteDAC				; calculate frequency or update sample
0000E442 0815 0000                M 	btst	#cfbmode,(a5)
0000E446 6600                     M 	bne.s	.pitch
0000E448 1B45 000B                M 	move.b	d5,csample(a5)
0000E44C 6000                     M 	bra.s	.cont
0000E44E                          M .pitch
0000E44E 0405 0080                M 	subi.b	#$80,d5
0000E452 6600                     M 	bne.s	.noprest
0000E454 7000                     M 	moveq	#0,d0
0000E456 6100 0000                M 	bsr.w	dnoteondac2
0000E45A 7C80                     M 	moveq	#-$80,d6
0000E45C 6000                     M 	bra.s	.cont
0000E45E                          M .noprest
0000E45E DA2D 0008                M 	add.b	cpitch(a5),d5
0000E462 DA45                     M 	add.w	d5,d5
0000E464 43FA 0000                M 	lea	dfreqdac(pc),a1
0000E468 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0000E46E                          M .cont
0000E46E 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000E470 6A00                       		bpl.s	.timer			; if yes, handle timer
0000E472 534C                       		subq.w	#1,a4			; else, undo the increment
0000E474 6000                       		bra.s	.pcnote			; do not calculate duration
0000E476                            
0000E476                            .timer
0000E476 4EBA 0000                  		jsr	dCalcDuration(pc)	; calculate duration
0000E47A                            .pcnote
0000E47A                            	dProcNote 0, 0				; reset necessary channel memory
0000E47A 2B4C 0002                M 	move.l	a4,cdata(a5)
0000E47E 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000E484 0815 0002                M 	btst	#cfbhold,(a5)
0000E488 6600                     M 	bne.s	.endpn
0000E48A 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000E490 0815 0003                M 	btst	#cfbmod,(a5)
0000E494 6700                     M 	beq.s	.endpn
0000E496 226D 0010                M 	movea.l	cmod(a5),a1
0000E49A 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000E49E 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000E4A2 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000E4A6 1011                     M 	move.b	(a1),d0
0000E4A8 E208                     M 	lsr.b	#1,d0
0000E4AA 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000E4AE 426D 0014                M 	clr.w	cmodfreq(a5)
0000E4B2                          M .endpn
0000E4B2                            
0000E4B2 4A06                       		tst.b	d6			; check if channel was resting
0000E4B4 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0000E4B6 6100                       		bsr.s	dNoteOnDAC		; do hardware note-on behavior
0000E4B8                            
0000E4B8 51CF FE84                  .noplay		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0000E4BC 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process FM channels
0000E4C0                            ; ===========================================================================
0000E4C0                            ; ---------------------------------------------------------------------------
0000E4C0                            ; Write DAC sample information to Dual PCM
0000E4C0                            ; ---------------------------------------------------------------------------
0000E4C0                            
0000E4C0                            dNoteOnDAC2:
0000E4C0 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E4C4 6700                       		beq.s	dNoteOnDAC3		; if not, process note
0000E4C6 4E75                       		rts
0000E4C8                            
0000E4C8                            dNoteOnDAC:
0000E4C8 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E4CC 6600                       		bne.s	locret_dNoteOnDAC4	; if so, do not note on or update frequency
0000E4CE                            
0000E4CE 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0000E4D0 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0000E4D4 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0000E4D8 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0000E4DC 6600 0000                  		bne.w	dUpdateFreqOffDAC2	; if so, only update frequency
0000E4E0                            
0000E4E0                            dNoteOnDAC3:
0000E4E0 E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0000E4E2 47F6 0000                  		lea	(a6,d0.w),a3		; get sample data to a3
0000E4E6                            
0000E4E6 487A 0000                  		pea	dUpdateFreqOffDAC(pc)	; update frequency after loading sample
0000E4EA 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0000E4F0 6700                       		beq.s	dNoteWriteDAC1		; if is, branch
0000E4F2                            ; ---------------------------------------------------------------------------
0000E4F2                            ; This code is for updating the note to Dual PCM. We have tracker commands
0000E4F2                            ; for also playing notes on DAC channels, which is why the code seems a
0000E4F2                            ; little weird.
0000E4F2                            ; ---------------------------------------------------------------------------
0000E4F2                            
0000E4F2                            dNoteWriteDAC2:
0000E4F2 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0000E4F8 45F9 0000 0000             		lea	dZ80+PCM2_NewRET,a2	; ''
0000E4FE 6000                       		bra.s	dNoteOnDAC4
0000E500                            
0000E500                            dNoteWriteDAC1:
0000E500                            
0000E500 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 2
0000E506 45F9 0000 0000             		lea	dZ80+PCM1_NewRET,a2	; ''
0000E50C                            
0000E50C                            dNoteOnDAC4:
0000E50C                            	StopZ80					; wait for Z80 to stop
0000E50C 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E514                          M 	waitz80stop
0000E514 0839 0000 00A1 1100      M .wait_559:	btst	#0,z80_bus_req
0000E51C 66F6                     M 	bne.s	.wait_559
0000E51E                            	rept 12
0000E51E                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E51E                            	endr
0000E51E 12DB                     M 	move.b	(a3)+,(a1)+
0000E520 12DB                     M 	move.b	(a3)+,(a1)+
0000E522 12DB                     M 	move.b	(a3)+,(a1)+
0000E524 12DB                     M 	move.b	(a3)+,(a1)+
0000E526 12DB                     M 	move.b	(a3)+,(a1)+
0000E528 12DB                     M 	move.b	(a3)+,(a1)+
0000E52A 12DB                     M 	move.b	(a3)+,(a1)+
0000E52C 12DB                     M 	move.b	(a3)+,(a1)+
0000E52E 12DB                     M 	move.b	(a3)+,(a1)+
0000E530 12DB                     M 	move.b	(a3)+,(a1)+
0000E532 12DB                     M 	move.b	(a3)+,(a1)+
0000E534 12DB                     M 	move.b	(a3)+,(a1)+
0000E536                            
0000E536 14BC 00DA                  		move.b	#$DA,(a2)		; activate sample switch (change instruction)
0000E53A                            	StartZ80				; enable Z80 execution
0000E53A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E542                            
0000E542                            locret_dNoteOnDAC4:
0000E542 4E75                       		rts
0000E544                            ; ===========================================================================
0000E544                            ; ---------------------------------------------------------------------------
0000E544                            ; Write DAC frequency to Dual PCM
0000E544                            ; ---------------------------------------------------------------------------
0000E544                            
0000E544                            dUpdateFreqOffDAC2:
0000E544 E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0000E546 47F6 000C                  		lea	$0C(a6,d0.w),a3		; get sample pitch to a3
0000E54A                            
0000E54A                            dUpdateFreqOffDAC:
0000E54A 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0000E54E DC5B                       		add.w	(a3)+,d6		; add sample frequency offset to d6
0000E550                            
0000E550 102D 0007                  		move.b	cDetune(a5),d0		; get detune value
0000E554 4880                       		ext.w	d0			; extend to word
0000E556 DC40                       		add.w	d0,d6			; add it to d6
0000E558                            
0000E558 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0000E55C 6700                       		beq.s	dUpdateFreqDAC3		; if not, branch
0000E55E DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0000E562 6000                       		bra.s	dUpdateFreqDAC3
0000E564                            
0000E564                            dUpdateFreqDAC:
0000E564 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E568 6600                       		bne.s	locret_UpdFreqDAC	; if so, branch
0000E56A                            
0000E56A                            dUpdateFreqDAC2:
0000E56A 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0000E56C 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0000E570 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0000E574 E948                       		lsl.w	#4,d0			; multiply ID by $10 (size of each entry)
0000E576 DC76 000C                  		add.w	$0C(a6,d0.w),d6		; add sample frequency offset to d6
0000E57A                            
0000E57A                            dUpdateFreqDAC3:
0000E57A                            		AMPS_Debug_FreqDAC		; check if DAC frequency is in bounds
0000E57A 0C46 1000                M 	cmp.w	#maxpitch,d6
0000E57E 6E00                     M 	bgt.s	.fail
0000E580 0C46 F000                M 	cmp.w	#-maxpitch,d6
0000E584 6C00                     M 	bge.s	.ok
0000E586                          M .fail
0000E586 4EBA F664                M 	jsr	amps_debugr_freqdac
0000E58A                          M .ok
0000E58A                            
0000E58A 1006                       		move.b	d6,d0			; copy the frequency to d0
0000E58C E04E                       		lsr.w	#8,d6			; get the upper byte to the lower byte
0000E58E 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if DAC1
0000E594 6700                       		beq.s	dFreqDAC1		; if is, branch
0000E596                            
0000E596                            	StopZ80					; wait for Z80 to stop
0000E596 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E59E                          M 	waitz80stop
0000E59E 0839 0000 00A1 1100      M .wait_563:	btst	#0,z80_bus_req
0000E5A6 66F6                     M 	bne.s	.wait_563
0000E5A8 13C6 0000 0000             		move.b	d6,dZ80+PCM2_PitchHigh+1
0000E5AE 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchLow+1
0000E5B4 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0000E5BC                            	StartZ80				; enable Z80 execution
0000E5BC 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E5C4                            
0000E5C4                            locret_UpdFreqDAC;
0000E5C4 4E75                       		rts
0000E5C6                            
0000E5C6                            dFreqDAC1:
0000E5C6                            	StopZ80					; wait for Z80 to stop
0000E5C6 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E5CE                          M 	waitz80stop
0000E5CE 0839 0000 00A1 1100      M .wait_566:	btst	#0,z80_bus_req
0000E5D6 66F6                     M 	bne.s	.wait_566
0000E5D8 13C6 0000 0000             		move.b	d6,dZ80+PCM1_PitchHigh+1
0000E5DE 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchLow+1
0000E5E4 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0000E5EC                            	StartZ80				; enable Z80 execution
0000E5EC 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E5F4 4E75                       		rts
0000E5F6                            ; ===========================================================================
0000E5F6                            ; ---------------------------------------------------------------------------
0000E5F6                            ; Routine to multiply duration by tick rate
0000E5F6                            ; We actually use a dbf loop instead of mulu, because 2 rounds
0000E5F6                            ; around the loop will be faster than a single mulu instruction
0000E5F6                            ; ---------------------------------------------------------------------------
0000E5F6                            
0000E5F6                            dCalcDuration:
0000E5F6 7000                       		moveq	#0,d0			; clear duration
0000E5F8 7200                       		moveq	#0,d1			; clear upper bytes (for dbf)
0000E5FA 122D 000A                  		move.b	cTick(a5),d1		; get tick multiplier to d1
0000E5FE                            
0000E5FE D005                       .multiply	add.b	d5,d0			; add duration value to d0
0000E600 51C9 FFFC                  		dbf	d1,.multiply		; multiply by tick rate
0000E604                            
0000E604 1B40 000D                  		move.b	d0,cLastDur(a5)		; save as the new duration
0000E608 4E75                       		rts				; get copied to duration by later code
0000E60A                            ; ===========================================================================
0000E60A                            ; ---------------------------------------------------------------------------
0000E60A                            ; Process SFX DAC channels
0000E60A                            ; ---------------------------------------------------------------------------
0000E60A                            
0000E60A                            dAMPSdoSFX:
0000E60A 4BF8 C660                  		lea	mSFXDAC1-cSizeSFX.w,a5	; get SFX DAC1 channel RAM address into a5
0000E60E                            
0000E60E                            dAMPSdoDACSFX:
0000E60E DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000E612 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000E614 6A00                       		bpl.s	.next			; if not, branch
0000E616                            
0000E616 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0000E61A 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000E61E 6700 0000                  		beq.w	.update			; if timed out, update channel
0000E622                            
0000E622                            	dCalcFreq				; calculate channel base frequency
0000E622 1C2D 0007                M 	move.b	cdetune(a5),d6
0000E626 4886                     M 	ext.w	d6
0000E628 DC6D 000E                M 	add.w	cfreq(a5),d6
0000E62C                            	dModulate dAMPSdoFMSFX, dAMPSdoDAC, 5	; run modulation code
0000E62C 0815 0003                M 	btst	#cfbmod,(a5)
0000E630 6700                     M 	beq.s	.noret
0000E632 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000E636 6700                     M 	beq.s	.started
0000E638 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000E63C                          M .noret
0000E63C 0895 0005                M 	bclr	#cfbvol,(a5)
0000E640 6700                     M 	beq.s	.noupdatevol
0000E642 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0000E646                          M 	.noupdatevol:
0000E646 6000 0000                M 	bra.w	dampsdofmsfx
0000E64A                          M .started
0000E64A 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000E64E 66EC                     M 	bne.s	.noret
0000E650 226D 0010                M 	movea.l	cmod(a5),a1
0000E654 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000E65A 4A2D 0018                M 	tst.b	cmodcount(a5)
0000E65E 6600                     M 	bne.s	.norev
0000E660 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000E666 442D 0017                M 	neg.b	cmodstep(a5)
0000E66A                          M .norev
0000E66A 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000E66E 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000E672 4885                     M 	ext.w	d5
0000E674 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000E678 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000E67C DC45                     M 	add.w	d5,d6
0000E67E 6100 FEEA                  		bsr.w	dUpdateFreqDAC2		; if frequency needs changing, do it
0000E682                            
0000E682 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000E686 6700                       		beq.s	.next			; if not, skip
0000E688 6100 0000                  		bsr.w	dUpdateVolDAC2		; update DAC volume
0000E68C                            
0000E68C                            .next
0000E68C 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0000E690                            
0000E690                            .update
0000E690 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0000E694                            	dDoTracker				; process tracker
0000E694 286D 0002                M 	movea.l	cdata(a5),a4
0000E698                          M 	amps_debug_trackupd
0000E698 220C                     M 	move.l	a4,d1
0000E69A 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000E6A0 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000E6A6 6500                     M 	blo.s	.fail2
0000E6A8 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000E6AE 6500                     M 	blo.s	.data
0000E6B0                          M .fail2
0000E6B0                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E6B0 487A FFFE                M 	pea	*(pc)
0000E6B4                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E6B4 40E7                     M 	move.w	sr,-(sp)
0000E6B6                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E6B6 =00000000                M 	__stack:set	0
0000E6B6 =00000000                M 	__sp:	set 0
0000E6B6                          M 	while	(__pos)
0000E6B6 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E6B6 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E6B6 =00000021                M 	__midpos:	= __endpos
0000E6B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6                          M 	pushp	"move.l a4,-(sp)"
0000E6B6 =00000001                M 	__stack:	= __stack+1
0000E6B6 =00000004                M 	__sp:	= __sp+4
0000E6B6 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E6B6 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E6B6 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E6B6 =00000029                M 	__midpos:	= __endpos
0000E6B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E6B6 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E6B6 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E6B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6B6                          M 	pushp	"move.l a4,-(sp)"
0000E6B6 =00000002                M 	__stack:	= __stack+1
0000E6B6 =00000008                M 	__sp:	= __sp+4
0000E6B6 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E6B6                          M 	rept	__stack
0000E6B6                          M 	popp	__command
0000E6B6 2F0C                     M 	move.l	a4,-(sp)
0000E6B8                          M 	popp	__command
0000E6B8 2F0C                     M 	move.l	a4,-(sp)
0000E6BA 4EB9 0000 0000           M 	jsr	errorhandler
0000E6C0                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6C0 =00000001                M 	__lpos:	set 1
0000E6C0 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E6C0                          M 	while	(__pos)
0000E6C0                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6C0 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000E6D9 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E6D9 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E6D9 =00000021                M 	__midpos:	= __endpos
0000E6D9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6D9                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6D9                          M 	__param:	substr ,,"hex"
0000E6D9 83                       M 	dc.b	hex|3
0000E6DA =00000022                M 	__lpos:	set __endpos+1
0000E6DA =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E6DA                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6DA                          M 	dc.b	""
0000E6DA =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E6DA =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E6DA =00000029                M 	__midpos:	= __endpos
0000E6DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6DA E0                       M 	dc.b	fendl
0000E6DB =0000002A                M 	__lpos:	set __endpos+1
0000E6DB =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E6DB                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6DB                          M 	dc.b	""
0000E6DB =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E6DB =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E6DB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6DB                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6DB B3                       M 	dc.b	sym|3
0000E6DC =00000036                M 	__lpos:	set __endpos+1
0000E6DC =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E6DC                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E6DC                          M 	dc.b	""
0000E6DC 00                       M 	dc.b	0
0000E6DD 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E6DE                          M 	even
0000E6DE 4EFA E852                M 	jmp	amps_debug_console_channel
0000E6E2                          M 	even
0000E6E2                          M .data
0000E6E2 7A00                     M 	moveq	#0,d5
0000E6E4 1A1C                     M 	move.b	(a4)+,d5
0000E6E6 0C05 00E0                M 	cmpi.b	#$e0,d5
0000E6EA 6500                     M 	blo.s	.notcomm
0000E6EC 4EBA 0000                M 	jsr	dcommands(pc)
0000E6F0 60F0                     M 	bra.s	.data
0000E6F2 6098                     M 	bra.s	.next
0000E6F4                          M .notcomm
0000E6F4 7C00                       		moveq	#0,d6			; clear rest flag
0000E6F6 4A05                       		tst.b	d5			; check if note is being played
0000E6F8 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000E6FA                            
0000E6FA                            	dTrackNoteDAC				; calculate frequency or update sample
0000E6FA 0815 0000                M 	btst	#cfbmode,(a5)
0000E6FE 6600                     M 	bne.s	.pitch
0000E700 1B45 000B                M 	move.b	d5,csample(a5)
0000E704 6000                     M 	bra.s	.cont
0000E706                          M .pitch
0000E706 0405 0080                M 	subi.b	#$80,d5
0000E70A 6600                     M 	bne.s	.noprest
0000E70C 7000                     M 	moveq	#0,d0
0000E70E 6100 FDB0                M 	bsr.w	dnoteondac2
0000E712 7C80                     M 	moveq	#-$80,d6
0000E714 6000                     M 	bra.s	.cont
0000E716                          M .noprest
0000E716 DA2D 0008                M 	add.b	cpitch(a5),d5
0000E71A DA45                     M 	add.w	d5,d5
0000E71C 43FA 0000                M 	lea	dfreqdac(pc),a1
0000E720 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0000E726                          M .cont
0000E726 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000E728 6A00                       		bpl.s	.timer			; if yes, handle timer
0000E72A 534C                       		subq.w	#1,a4			; else, undo the increment
0000E72C 6000                       		bra.s	.pcnote			; do not calculate duration
0000E72E                            
0000E72E                            .timer
0000E72E 4EBA FEC6                  		jsr	dCalcDuration(pc)	; calculate duration
0000E732                            .pcnote
0000E732                            	dProcNote 1, 0				; reset necessary channel memory
0000E732 2B4C 0002                M 	move.l	a4,cdata(a5)
0000E736 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000E73C 0815 0002                M 	btst	#cfbhold,(a5)
0000E740 6600                     M 	bne.s	.endpn
0000E742 0815 0003                M 	btst	#cfbmod,(a5)
0000E746 6700                     M 	beq.s	.endpn
0000E748 226D 0010                M 	movea.l	cmod(a5),a1
0000E74C 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000E750 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000E754 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000E758 1011                     M 	move.b	(a1),d0
0000E75A E208                     M 	lsr.b	#1,d0
0000E75C 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000E760 426D 0014                M 	clr.w	cmodfreq(a5)
0000E764                          M .endpn
0000E764 4A06                       		tst.b	d6			; check if channel was resting
0000E766 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0000E768 6100 FD5E                  		bsr.w	dNoteOnDAC		; do hardware note-on behavior
0000E76C                            
0000E76C                            .noplay
0000E76C 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0000E770                            ; ===========================================================================
0000E770                            ; ---------------------------------------------------------------------------
0000E770                            ; Write DAC volume to Dual PCM
0000E770                            ; ---------------------------------------------------------------------------
0000E770                            
0000E770                            dUpdateVolDAC:
0000E770 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E774 6600                       		bne.s	locret_VolDAC		; if yes, do not update
0000E776                            
0000E776                            dUpdateVolDAC2:
0000E776 162D 0009                  		move.b	cVolume(a5),d3		; get channel volume to d3
0000E77A D638 C4C0                  		add.b	mMasterVolDAC.w,d3	; add master volume to it
0000E77E 6A00                       		bpl.s	.gotvol			; if positive (in range), branch
0000E780 7680                       		moveq	#$FFFFFF80,d3		; force volume to mute ($80 is the last valid volume)
0000E782                            
0000E782                            .gotvol
0000E782                            	StopZ80					; wait for Z80 to stop
0000E782 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E78A                          M 	waitz80stop
0000E78A 0839 0000 00A1 1100      M .wait_579:	btst	#0,z80_bus_req
0000E792 66F6                     M 	bne.s	.wait_579
0000E794 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM_ChangeVolume; set volume change flag
0000E79C                            
0000E79C 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0000E7A2 6700                       		beq.s	.dac1			; if is, branch
0000E7A4 13C3 0000 0000             		move.b	d3,dZ80+PCM2_Volume+1	; save volume for PCM 1
0000E7AA                            	StartZ80				; enable Z80 execution
0000E7AA 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E7B2 4E75                       		rts
0000E7B4                            
0000E7B4                            .dac1
0000E7B4 13C3 0000 0000             		move.b	d3,dZ80+PCM1_Volume+1	; save volume for PCM 2
0000E7BA                            	StartZ80				; enable Z80 execution
0000E7BA 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E7C2                            
0000E7C2                            locret_VolDAC:
0000E7C2 4E75                       		rts
0000E7C4                            ; ===========================================================================
0000E7C4                            ; ---------------------------------------------------------------------------
0000E7C4                            ; Routine for unpausing the sound driver
0000E7C4                            ; ---------------------------------------------------------------------------
0000E7C4                            
0000E7C4                            dPlaySnd_Unpause:
0000E7C4 08B8 0007 C4A6             		bclr	#mfbPaused,mFlags.w	; unpause music
0000E7CA 67F6                       		beq.s	locret_VolDAC		; if was already unpaused, skip
0000E7CC                            ; ---------------------------------------------------------------------------
0000E7CC                            ; The following code will reset the panning values for each running
0000E7CC                            ; channel. It also makes sure that the channel is not interrupted
0000E7CC                            ; by sound effects, and that each running sound effect channel gets
0000E7CC                            ; updated. We do not handle key on's, since that could potentially
0000E7CC                            ; cause issues if notes are half-done. The next time tracker plays
0000E7CC                            ; notes, they start being audible again.
0000E7CC                            ; ---------------------------------------------------------------------------
0000E7CC                            
0000E7CC 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0000E7D0 7804                       		moveq	#Mus_FM-1,d4		; load the number of music FM channels to d4
0000E7D2 762C                       		moveq	#cSize,d3		; get the size of each music channel to d3
0000E7D4                            
0000E7D4                            .musloop
0000E7D4 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0000E7D6 6A00                       		bpl.s	.skipmus		; if not, do not update
0000E7D8 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E7DC 6600                       		bne.s	.skipmus		; if is, do not update
0000E7DE                            
0000E7DE 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000E7E0 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0000E7E4 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0000E7E8                            
0000E7E8                            .skipmus
0000E7E8 DAC3                       		adda.w	d3,a5			; go to next channel
0000E7EA 51CC FFE8                  		dbf	d4,.musloop		; repeat for all music FM channels
0000E7EE                            
0000E7EE 4BF8 C698                  		lea	mSFXFM3.w,a5		; start from SFX FM1 channel
0000E7F2 7802                       		moveq	#SFX_FM-1,d4		; load the number of SFX FM channels to d4
0000E7F4 761C                       		moveq	#cSizeSFX,d3		; get the size of each SFX channel to d3
0000E7F6                            
0000E7F6                            .sfxloop
0000E7F6 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0000E7F8 6A00                       		bpl.s	.skipsfx		; if not, do not update
0000E7FA                            
0000E7FA 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000E7FC 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0000E800 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0000E804                            
0000E804                            .skipsfx
0000E804 DAC3                       		adda.w  d3,a5			; go to next channel
0000E806 51CC FFEE                  		dbf     d4,.sfxloop		; repeat for all SFX FM channels
0000E80A                            ; ---------------------------------------------------------------------------
0000E80A                            ; Since the DAC channels have or based panning behavior, we need this
0000E80A                            ; piece of code to update its panning
0000E80A                            ; ---------------------------------------------------------------------------
0000E80A                            
0000E80A 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0000E80E 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0000E814 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0000E816 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0000E81A                            
0000E81A                            .nodacsfx
0000E81A 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0000E81E 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0000E820 4EFA 0000                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0000E824                            ; ===========================================================================
0000E824                            ; ---------------------------------------------------------------------------
0000E824                            ; Routine for pausing the sound driver
0000E824                            ; ---------------------------------------------------------------------------
0000E824                            
0000E824                            dPlaySnd_Pause:
0000E824 08F8 0007 C4A6             		bset	#mfbPaused,mFlags.w	; pause music
0000E82A 6696                       		bne.s	locret_VolDAC		; if was already paused, skip
0000E82C                            ; ---------------------------------------------------------------------------
0000E82C                            ; The following code will set channel panning to none for all FM channels.
0000E82C                            ; This will ensure they are muted while we are pausing.
0000E82C                            ; ---------------------------------------------------------------------------
0000E82C                            
0000E82C 7602                       		moveq	#3-1,d3			; 3 channels per YM2616 "part"
0000E82E 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000E830 7200                       		moveq	#0,d1			; pan to neither speaker and remove LFO
0000E832                            
0000E832                            .muteFM
0000E832 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000E836 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000E83A 5200                       		addq.b	#1,d0			; go to next FM channel
0000E83C 51CB FFF4                  		dbf	d3,.muteFM		; write each 3 channels per part
0000E840                            ; ---------------------------------------------------------------------------
0000E840                            ; The following code will key off all FM channels. There is a special
0000E840                            ; behavior in that, we must write all channels into part 1, and we
0000E840                            ; control the channel we are writing in the data portion.
0000E840                            ; 4 bits are reserved for which operators are active (in this case,
0000E840                            ; none), and 3 bits are reserved for the channel we want to affect.
0000E840                            ; ---------------------------------------------------------------------------
0000E840                            
0000E840 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000E842 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0000E844                            
0000E844                            .note
0000E844 1203                       		move.b	d3,d1			; copy value into d1
0000E846 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000E84A 5801                       		addq.b	#4,d1			; set this to part 2 channel
0000E84C 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000E850 51CB FFF2                  		dbf	d3,.note		; loop for all 3 channel groups
0000E854                            
0000E854 4EBA 0000                  		jsr	dMutePSG(pc)		; mute all PSG channels
0000E858                            	; continue to mute all DAC channels
0000E858                            ; ===========================================================================
0000E858                            ; ---------------------------------------------------------------------------
0000E858                            ; Routine for muting all DAC channels
0000E858                            ; ---------------------------------------------------------------------------
0000E858                            
0000E858                            dMuteDAC:
0000E858                            	StopZ80					; wait for Z80 to stop
0000E858 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E860                          M 	waitz80stop
0000E860 0839 0000 00A1 1100      M .wait_583:	btst	#0,z80_bus_req
0000E868 66F6                     M 	bne.s	.wait_583
0000E86A 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0000E86E 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1 sample to a1
0000E874                            
0000E874                            	rept 12
0000E874                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0000E874                            	endr
0000E874 12DA                     M 	move.b	(a2)+,(a1)+
0000E876 12DA                     M 	move.b	(a2)+,(a1)+
0000E878 12DA                     M 	move.b	(a2)+,(a1)+
0000E87A 12DA                     M 	move.b	(a2)+,(a1)+
0000E87C 12DA                     M 	move.b	(a2)+,(a1)+
0000E87E 12DA                     M 	move.b	(a2)+,(a1)+
0000E880 12DA                     M 	move.b	(a2)+,(a1)+
0000E882 12DA                     M 	move.b	(a2)+,(a1)+
0000E884 12DA                     M 	move.b	(a2)+,(a1)+
0000E886 12DA                     M 	move.b	(a2)+,(a1)+
0000E888 12DA                     M 	move.b	(a2)+,(a1)+
0000E88A 12DA                     M 	move.b	(a2)+,(a1)+
0000E88C                            
0000E88C 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0000E894                            
0000E894 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0000E898 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 2 sample to a1
0000E89E                            
0000E89E                            	rept 12
0000E89E                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0000E89E                            	endr
0000E89E 12DA                     M 	move.b	(a2)+,(a1)+
0000E8A0 12DA                     M 	move.b	(a2)+,(a1)+
0000E8A2 12DA                     M 	move.b	(a2)+,(a1)+
0000E8A4 12DA                     M 	move.b	(a2)+,(a1)+
0000E8A6 12DA                     M 	move.b	(a2)+,(a1)+
0000E8A8 12DA                     M 	move.b	(a2)+,(a1)+
0000E8AA 12DA                     M 	move.b	(a2)+,(a1)+
0000E8AC 12DA                     M 	move.b	(a2)+,(a1)+
0000E8AE 12DA                     M 	move.b	(a2)+,(a1)+
0000E8B0 12DA                     M 	move.b	(a2)+,(a1)+
0000E8B2 12DA                     M 	move.b	(a2)+,(a1)+
0000E8B4 12DA                     M 	move.b	(a2)+,(a1)+
0000E8B6                            
0000E8B6 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0000E8BE                            	StartZ80				; enable Z80 execution
0000E8BE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E8C6                            
0000E8C6                            locret_MuteDAC:
0000E8C6 4E75                       		rts
0000E8C8                            ; ===========================================================================
0000E8C8                            ; ---------------------------------------------------------------------------
0000E8C8                            ; Subroutine to play any queued music tracks, sound effects or commands
0000E8C8                            ; ---------------------------------------------------------------------------
0000E8C8                            
0000E8C8                            dPlaySnd:
0000E8C8 4DF8 C4BC                  		lea	mQueue.w,a6		; get address to the sound queue
0000E8CC 7E00                       		moveq	#0,d7
0000E8CE 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000E8D0 6600                       		bne.s	.found			; if nonzero, a sound is queued
0000E8D2 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000E8D4 6600                       		bne.s	.found			; if nonzero, a sound is queued
0000E8D6 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000E8D8 67EC                       		beq.s	locret_MuteDAC		; if 0, no sounds were queued, return
0000E8DA                            
0000E8DA                            .found
0000E8DA 422E FFFF                  		clr.b	-1(a6)			; clear the slot we are processing
0000E8DE 0C07 0082                  		cmpi.b	#SFXoff,d7		; check if this sound was a sound effect
0000E8E2 6400 0000                  		bhs.w	dPlaySnd_SFX		; if so, handle it
0000E8E6 0C07 000A                  		cmpi.b	#MusOff,d7		; check if this sound was a command
0000E8EA 6500 0000                  		blo.w	dPlaySnd_Comm		; if so, handle it
0000E8EE                            	; it was music, handle it below
0000E8EE                            ; ===========================================================================
0000E8EE                            ; ---------------------------------------------------------------------------
0000E8EE                            ; Subroutine to play a queued music track
0000E8EE                            ; ---------------------------------------------------------------------------
0000E8EE                            
0000E8EE                            dPlaySnd_Music:
0000E8EE 4EBA 0000                  		jsr	dStopMusic(pc)		; mute hardware and reset all driver memory
0000E8F2 4EBA 0000                  		jsr	dResetVolume(pc)	; reset volumes and end any fades
0000E8F6                            ; ---------------------------------------------------------------------------
0000E8F6                            ; To save few cycles, we don't directly substract the music offset from
0000E8F6                            ; the ID, and instead offset the table position. In practice this will
0000E8F6                            ; have the same effect, but saves us 8 cycles overall.
0000E8F6                            ; ---------------------------------------------------------------------------
0000E8F6                            
0000E8F6 49FA 0000                  		lea	MusicIndex-(MusOff*4)(pc),a4; get music pointer table with an offset
0000E8FA DE47                       		add.w	d7,d7			; quadruple music ID
0000E8FC DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0000E8FE 11F4 7000 C4B9             		move.b	(a4,d7.w),mTempoSpeed.w	; load speed shoes tempo from the unused 8 bits
0000E904 2874 7000                  		movea.l	(a4,d7.w),a4		; get music header pointer from the table
0000E908                            
0000E908 200C                       		move.l	a4,d0			; copy pointer to d0
0000E90A 0280 00FF FFFF             		and.l	#$FFFFFF,d0		; clearing the upper 8 bits allows the debugger
0000E910 2840                       		move.l	d0,a4			; to show the address correctly. Move ptr back to a4
0000E912                            		AMPS_Debug_PlayTrackMus		; check if this was valid music
0000E912 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000E918 6500                     M 	blo.s	.fail_585
0000E91A 0C80 0000 0000           M 	cmp.l	#musend,d0
0000E920 6500                     M 	blo.s	.ok_585
0000E922                          M .fail_585
0000E922 E44F                     M 	lsr.w	#2,d7
0000E924                          M 	raiseerror	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000E924 487A FFFE                M 	pea	*(pc)
0000E928                          M 	raiseerror2	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000E928 40E7                     M 	move.w	sr,-(sp)
0000E92A                          M 	__fstring_generateargumentscode	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A =0000001A                M 	__pos:	set instr("Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E92A =00000000                M 	__stack:set	0
0000E92A =00000000                M 	__sp:	set 0
0000E92A                          M 	while	(__pos)
0000E92A =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E92A =00000023                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E92A =00000021                M 	__midpos:	= __endpos
0000E92A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	pushp	"move.b d7,1(sp)"
0000E92A                          M 	pushp	"subq.w	#2, sp"
0000E92A =00000002                M 	__stack:	= __stack+2
0000E92A =00000002                M 	__sp:	= __sp+2
0000E92A =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E92A =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E92A =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E92A =0000002B                M 	__midpos:	= __endpos
0000E92A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	pushp	"move.l a4,-(sp)"
0000E92A =00000003                M 	__stack:	= __stack+1
0000E92A =00000006                M 	__sp:	= __sp+4
0000E92A =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E92A =00000033                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E92A =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E92A =00000033                M 	__midpos:	= __endpos
0000E92A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A =00000034                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E92A =0000003F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E92A =0000003B                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E92A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E92A                          M 	pushp	"move.l a4,-(sp)"
0000E92A =00000004                M 	__stack:	= __stack+1
0000E92A =0000000A                M 	__sp:	= __sp+4
0000E92A =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E92A                          M 	rept	__stack
0000E92A                          M 	popp	__command
0000E92A 2F0C                     M 	move.l	a4,-(sp)
0000E92C                          M 	popp	__command
0000E92C 2F0C                     M 	move.l	a4,-(sp)
0000E92E                          M 	popp	__command
0000E92E 554F                     M 	subq.w	#2,sp
0000E930                          M 	popp	__command
0000E930 1F47 0001                M 	move.b	d7,1(sp)
0000E934 4EB9 0000 0000           M 	jsr	errorhandler
0000E93A                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E93A =00000001                M 	__lpos:	set 1
0000E93A =0000001A                M 	__pos:	set instr("Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E93A                          M 	while	(__pos)
0000E93A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E93A 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music "
0000E953 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E953 =00000023                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E953 =00000021                M 	__midpos:	= __endpos
0000E953                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E953                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E953                          M 	__param:	substr ,,"hex"
0000E953 80                       M 	dc.b	hex
0000E954 =00000022                M 	__lpos:	set __endpos+1
0000E954 =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E954                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E954 3A20                     M 	dc.b	": "
0000E956 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E956 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E956 =0000002B                M 	__midpos:	= __endpos
0000E956                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E956                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E956                          M 	__param:	substr ,,"hex"
0000E956 83                       M 	dc.b	hex|3
0000E957 =0000002C                M 	__lpos:	set __endpos+1
0000E957 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E957                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E957                          M 	dc.b	""
0000E957 =00000033                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E957 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E957 =00000033                M 	__midpos:	= __endpos
0000E957                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E957                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E957 E0                       M 	dc.b	fendl
0000E958 =00000034                M 	__lpos:	set __endpos+1
0000E958 =00000034                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E958                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E958                          M 	dc.b	""
0000E958 =0000003F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E958 =0000003B                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E958                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E958                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E958 B3                       M 	dc.b	sym|3
0000E959 =00000040                M 	__lpos:	set __endpos+1
0000E959 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E959                          M 	__substr:	substr __lpos,,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000E959                          M 	dc.b	""
0000E959 00                       M 	dc.b	0
0000E95A 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E95C 00                       M 	even
0000E95C 4EFA ED7A                M 	jmp	amps_debug_console_main
0000E960                          M 	even
0000E960                          M .ok_585
0000E960                            
0000E960 264C                       		move.l	a4,a3			; copy pointer to a3
0000E962 584C                       		addq.w	#4,a4			; go to DAC1 data section
0000E964                            
0000E964 7000                       		moveq	#0,d0
0000E966 102B 0001                  		move.b	1(a3),d0		; load song tempo to d0
0000E96A 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as regular tempo
0000E96E 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes flag was set
0000E974 6700                       		beq.s	.tempogot		; if not, use main tempo
0000E976 1038 C4B9                  		move.b	mTempoSpeed.w,d0	; load speed shoes tempo to d0 instead
0000E97A                            
0000E97A                            .tempogot
0000E97A 11C0 C4BA                  		move.b	d0,mTempo.w		; save as the current tempo
0000E97E 11C0 C4BB                  		move.b	d0,mTempoCur.w		; copy into the accumulator/counter
0000E982 0238 00F7 C4A6             		and.b	#$FF-(1<<mfbNoPAL),mFlags.w; enable PAL fix
0000E988                            ; ---------------------------------------------------------------------------
0000E988                            ; If the 7th bit (msb) of tick multiplier is set, PAL fix gets
0000E988                            ; disabled. I know, very weird place to put it, but we dont have
0000E988                            ; much free room in the song header
0000E988                            ; ---------------------------------------------------------------------------
0000E988                            
0000E988 1813                       		move.b	(a3),d4			; load the tick multiplier to d4
0000E98A 6A00                       		bpl.s	.noPAL			; branch if the loaded value was positive
0000E98C 0244 007F                  		and.w	#$7F,d4			; keep value in range
0000E990 0038 0008 C4A6             		or.b	#1<<mfbNoPAL,mFlags.w	; disable PAL fix
0000E996                            
0000E996                            .noPAL
0000E996 74A0                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbVol),d2; prepare running tracker and volume flags into d2
0000E998 72C0                       		moveq	#$FFFFFFC0,d1		; prepare panning value of centre to d1
0000E99A 7C2C                       		moveq	#cSize,d6		; prepare channel size to d6
0000E99C 7A01                       		moveq	#1,d5			; prepare duration of 0 frames to d5
0000E99E                            
0000E99E 43F8 C4C4                  		lea	mDAC1.w,a1		; start from DAC1 channel
0000E9A2 45FA 0000                  		lea	dDACtypeVals(pc),a2	; prepare DAC (and FM) type value list into a2
0000E9A6 7E01                       		moveq	#2-1,d7			; always run for 2 DAC channels
0000E9A8 363C 0100                  		move.w	#$100,d3		; prepare default DAC frequency
0000E9AC                            
0000E9AC                            .loopDAC
0000E9AC 1282                       		move.b	d2,(a1)			; save channel flags
0000E9AE 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000E9B2 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000E9B6 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000E9BA 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0000E9BE 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000E9C2 3343 000E                  		move.w	d3,cFreq(a1)		; reset channel base frequency
0000E9C6                            
0000E9C6 7000                       		moveq	#0,d0
0000E9C8 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000E9CA D08B                       		add.l	a3,d0			; add music header offset to d0
0000E9CC 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000E9D0                            		AMPS_Debug_PlayTrackMus2 DAC	; make sure the tracker address is valid
0000E9D0 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000E9D6 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000E9DC 6500                     M 	blo.s	.fail_590
0000E9DE 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000E9E4 6500                     M 	blo.s	.ok_590
0000E9E6                          M .fail_590
0000E9E6                          M 	raiseerror	"Invalid tracker at Music dac: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000E9E6 487A FFFE                M 	pea	*(pc)
0000E9EA                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000E9EA 40E7                     M 	move.w	sr,-(sp)
0000E9EC                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000E9EC =00000000                M 	__stack:set	0
0000E9EC =00000000                M 	__sp:	set 0
0000E9EC                          M 	while	(__pos)
0000E9EC =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000E9EC =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000E9EC =00000027                M 	__midpos:	= __endpos
0000E9EC                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC                          M 	pushp	"move.l d0,-(sp)"
0000E9EC =00000001                M 	__stack:	= __stack+1
0000E9EC =00000004                M 	__sp:	= __sp+4
0000E9EC =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000E9EC =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000E9EC =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000E9EC =0000002F                M 	__midpos:	= __endpos
0000E9EC                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000E9EC =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000E9EC =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000E9EC                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9EC                          M 	pushp	"move.l d0,-(sp)"
0000E9EC =00000002                M 	__stack:	= __stack+1
0000E9EC =00000008                M 	__sp:	= __sp+4
0000E9EC =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000E9EC                          M 	rept	__stack
0000E9EC                          M 	popp	__command
0000E9EC 2F00                     M 	move.l	d0,-(sp)
0000E9EE                          M 	popp	__command
0000E9EE 2F00                     M 	move.l	d0,-(sp)
0000E9F0 4EB9 0000 0000           M 	jsr	errorhandler
0000E9F6                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9F6 =00000001                M 	__lpos:	set 1
0000E9F6 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000E9F6                          M 	while	(__pos)
0000E9F6                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000E9F6 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EA15 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EA15 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EA15 =00000027                M 	__midpos:	= __endpos
0000EA15                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA15                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA15                          M 	__param:	substr ,,"hex"
0000EA15 83                       M 	dc.b	hex|3
0000EA16 =00000028                M 	__lpos:	set __endpos+1
0000EA16 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EA16                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA16                          M 	dc.b	""
0000EA16 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EA16 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EA16 =0000002F                M 	__midpos:	= __endpos
0000EA16                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA16                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA16 E0                       M 	dc.b	fendl
0000EA17 =00000030                M 	__lpos:	set __endpos+1
0000EA17 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EA17                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA17                          M 	dc.b	""
0000EA17 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EA17 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EA17                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA17                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA17 B3                       M 	dc.b	sym|3
0000EA18 =0000003C                M 	__lpos:	set __endpos+1
0000EA18 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EA18                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA18                          M 	dc.b	""
0000EA18 00                       M 	dc.b	0
0000EA19 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EA1A                          M 	even
0000EA1A 4EFA ECBC                M 	jmp	amps_debug_console_main
0000EA1E                          M 	even
0000EA1E                          M .ok_590
0000EA1E                            
0000EA1E 135C 0009                  		move.b	(a4)+,cVolume(a1)	; load channel volume
0000EA22 135C 000B                  		move.b	(a4)+,cSample(a1)	; load channel sample ID
0000EA26 6700                       		beq.s	.sampmode		; if 0, we are in sample mode
0000EA28 08D1 0000                  		bset	#cfbMode,(a1)		; if not 0, enable pitch mode
0000EA2C                            
0000EA2C                            .sampmode
0000EA2C D2C6                       		add.w	d6,a1			; go to the next channel
0000EA2E 51CF FF7C                  		dbf	d7,.loopDAC		; repeat for all DAC channels
0000EA32                            
0000EA32 7E00                       		moveq	#0,d7
0000EA34 7481                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbRest),d2; prepare running tracker and channel rest flags
0000EA36 1E2B 0002                  		move.b	2(a3),d7		; load the FM channel count to d7
0000EA3A 6B00                       		bmi.s	.doPSG			; if no FM channels are loaded, branch
0000EA3C                            
0000EA3C                            .loopFM
0000EA3C 1282                       		move.b	d2,(a1)			; save channel flags
0000EA3E 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000EA42 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000EA46 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000EA4A 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0000EA4E 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000EA52                            
0000EA52 7000                       		moveq	#0,d0
0000EA54 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000EA56 D08B                       		add.l	a3,d0			; add music header offset to d0
0000EA58 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000EA5C                            		AMPS_Debug_PlayTrackMus2 FM	; make sure the tracker address is valid
0000EA5C 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000EA62 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EA68 6500                     M 	blo.s	.fail_595
0000EA6A 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000EA70 6500                     M 	blo.s	.ok_595
0000EA72                          M .fail_595
0000EA72                          M 	raiseerror	"Invalid tracker at Music fm: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EA72 487A FFFE                M 	pea	*(pc)
0000EA76                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EA76 40E7                     M 	move.w	sr,-(sp)
0000EA78                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EA78 =00000000                M 	__stack:set	0
0000EA78 =00000000                M 	__sp:	set 0
0000EA78                          M 	while	(__pos)
0000EA78 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EA78 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EA78 =00000027                M 	__midpos:	= __endpos
0000EA78                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78                          M 	pushp	"move.l d0,-(sp)"
0000EA78 =00000001                M 	__stack:	= __stack+1
0000EA78 =00000004                M 	__sp:	= __sp+4
0000EA78 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EA78 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EA78 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EA78 =0000002F                M 	__midpos:	= __endpos
0000EA78                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EA78 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EA78 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EA78                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA78                          M 	pushp	"move.l d0,-(sp)"
0000EA78 =00000002                M 	__stack:	= __stack+1
0000EA78 =00000008                M 	__sp:	= __sp+4
0000EA78 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EA78                          M 	rept	__stack
0000EA78                          M 	popp	__command
0000EA78 2F00                     M 	move.l	d0,-(sp)
0000EA7A                          M 	popp	__command
0000EA7A 2F00                     M 	move.l	d0,-(sp)
0000EA7C 4EB9 0000 0000           M 	jsr	errorhandler
0000EA82                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA82 =00000001                M 	__lpos:	set 1
0000EA82 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EA82                          M 	while	(__pos)
0000EA82                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EA82 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EAA1 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EAA1 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EAA1 =00000027                M 	__midpos:	= __endpos
0000EAA1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EAA1                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EAA1                          M 	__param:	substr ,,"hex"
0000EAA1 83                       M 	dc.b	hex|3
0000EAA2 =00000028                M 	__lpos:	set __endpos+1
0000EAA2 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EAA2                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EAA2                          M 	dc.b	""
0000EAA2 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EAA2 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EAA2 =0000002F                M 	__midpos:	= __endpos
0000EAA2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EAA2                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EAA2 E0                       M 	dc.b	fendl
0000EAA3 =00000030                M 	__lpos:	set __endpos+1
0000EAA3 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EAA3                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EAA3                          M 	dc.b	""
0000EAA3 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EAA3 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EAA3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EAA3                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EAA3 B3                       M 	dc.b	sym|3
0000EAA4 =0000003C                M 	__lpos:	set __endpos+1
0000EAA4 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EAA4                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EAA4                          M 	dc.b	""
0000EAA4 00                       M 	dc.b	0
0000EAA5 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EAA6                          M 	even
0000EAA6 4EFA EC30                M 	jmp	amps_debug_console_main
0000EAAA                          M 	even
0000EAAA                          M .ok_595
0000EAAA                            
0000EAAA 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0000EAAE D2C6                       		adda.w	d6,a1			; go to the next channel
0000EAB0 51CF FF8A                  		dbf	d7,.loopFM		; repeat for all FM channels
0000EAB4                            
0000EAB4                            .doPSG
0000EAB4 7E00                       		moveq	#0,d7
0000EAB6 1E2B 0003                  		move.b	3(a3),d7		; load the FM channel count to d7
0000EABA 6B00 0000                  		bmi.w	.intSFX			; if no PSG channels are loaded, branch
0000EABE                            ; ---------------------------------------------------------------------------
0000EABE                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0000EABE                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0000EABE                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0000EABE                            ; is controlled by the 68000, we would be off by a single frame without
0000EABE                            ; this fix.
0000EABE                            ; ---------------------------------------------------------------------------
0000EABE                            
0000EABE 7A02                       		moveq	#2,d5			; prepare duration of 1 frames to d5
0000EAC0 45FA 0000                  		lea	dPSGtypeVals(pc),a2	; prepare PSG type value list into a2
0000EAC4 43F8 C5F8                  		lea	mPSG1.w,a1		; start from PSG1 channel
0000EAC8                            
0000EAC8                            .loopPSG
0000EAC8 1282                       		move.b	d2,(a1)			; save channel flags
0000EACA 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000EACE 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000EAD2 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000EAD6 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000EADA                            
0000EADA 7000                       		moveq	#0,d0
0000EADC 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000EADE D08B                       		add.l	a3,d0			; add music header offset to d0
0000EAE0 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000EAE4                            		AMPS_Debug_PlayTrackMus2 PSG	; make sure the tracker address is valid
0000EAE4 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000EAEA 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EAF0 6500                     M 	blo.s	.fail_600
0000EAF2 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000EAF8 6500                     M 	blo.s	.ok_600
0000EAFA                          M .fail_600
0000EAFA                          M 	raiseerror	"Invalid tracker at Music psg: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EAFA 487A FFFE                M 	pea	*(pc)
0000EAFE                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EAFE 40E7                     M 	move.w	sr,-(sp)
0000EB00                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EB00 =00000000                M 	__stack:set	0
0000EB00 =00000000                M 	__sp:	set 0
0000EB00                          M 	while	(__pos)
0000EB00 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EB00 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EB00 =00000027                M 	__midpos:	= __endpos
0000EB00                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00                          M 	pushp	"move.l d0,-(sp)"
0000EB00 =00000001                M 	__stack:	= __stack+1
0000EB00 =00000004                M 	__sp:	= __sp+4
0000EB00 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EB00 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EB00 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EB00 =0000002F                M 	__midpos:	= __endpos
0000EB00                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EB00 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EB00 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EB00                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB00                          M 	pushp	"move.l d0,-(sp)"
0000EB00 =00000002                M 	__stack:	= __stack+1
0000EB00 =00000008                M 	__sp:	= __sp+4
0000EB00 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EB00                          M 	rept	__stack
0000EB00                          M 	popp	__command
0000EB00 2F00                     M 	move.l	d0,-(sp)
0000EB02                          M 	popp	__command
0000EB02 2F00                     M 	move.l	d0,-(sp)
0000EB04 4EB9 0000 0000           M 	jsr	errorhandler
0000EB0A                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB0A =00000001                M 	__lpos:	set 1
0000EB0A =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EB0A                          M 	while	(__pos)
0000EB0A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB0A 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EB29 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EB29 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EB29 =00000027                M 	__midpos:	= __endpos
0000EB29                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB29                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB29                          M 	__param:	substr ,,"hex"
0000EB29 83                       M 	dc.b	hex|3
0000EB2A =00000028                M 	__lpos:	set __endpos+1
0000EB2A =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EB2A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB2A                          M 	dc.b	""
0000EB2A =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EB2A =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EB2A =0000002F                M 	__midpos:	= __endpos
0000EB2A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB2A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB2A E0                       M 	dc.b	fendl
0000EB2B =00000030                M 	__lpos:	set __endpos+1
0000EB2B =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EB2B                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB2B                          M 	dc.b	""
0000EB2B =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EB2B =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EB2B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB2B                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB2B B3                       M 	dc.b	sym|3
0000EB2C =0000003C                M 	__lpos:	set __endpos+1
0000EB2C =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EB2C                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EB2C                          M 	dc.b	""
0000EB2C 00                       M 	dc.b	0
0000EB2D 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EB2E                          M 	even
0000EB2E 4EFA EBA8                M 	jmp	amps_debug_console_main
0000EB32                          M 	even
0000EB32                          M .ok_600
0000EB32                            
0000EB32 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0000EB36 135C 0007                  		move.b	(a4)+,cDetune(a1)	; load detune offset
0000EB3A 135C 000B                  		move.b	(a4)+,cVolEnv(a1)	; load volume envelope ID
0000EB3E D2C6                       		adda.w	d6,a1			; go to the next channel
0000EB40 51CF FF86                  		dbf	d7,.loopPSG		; repeat for all FM channels
0000EB44                            
0000EB44                            .intSFX
0000EB44                            ; ---------------------------------------------------------------------------
0000EB44                            ; Now follows initializing FM6 to be ready for PCM streaming,
0000EB44                            ; and resetting the PCM filter for Dual PCM. Simply, this just
0000EB44                            ; clears some YM registers.
0000EB44                            ; ---------------------------------------------------------------------------
0000EB44                            
0000EB44 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000EB46 7206                       		moveq	#6,d1			; FM6, all operators off
0000EB48 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000EB4C                            
0000EB4C 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0000EB4E 7042                       		moveq	#$42,d0			; YM address: Total Level Operator 1 (FM3/6)
0000EB50 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EB54 704A                       		moveq	#$4A,d0			; YM address: Total Level Operator 2 (FM3/6)
0000EB56 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EB5A 7046                       		moveq	#$46,d0			; YM address: Total Level Operator 3 (FM3/6)
0000EB5C 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EB60 704E                       		moveq	#$4E,d0			; YM address: Total Level Operator 4 (FM3/6)
0000EB62 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EB66                            
0000EB66 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0000EB68 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0000EB6A 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EB6E                            
0000EB6E 303C 0000                  		move.w	#fLog>>$0F,d0		; use linear filter
0000EB72 4EBA 0000                  		jsr	dSetFilter(pc)		; set filter
0000EB76                            ; ---------------------------------------------------------------------------
0000EB76                            ; This piece of code here handles SFX overriding our newly loaded
0000EB76                            ; music channels. Since we did not do this at the initialization
0000EB76                            ; step, we will handle it here instead.
0000EB76                            ; ---------------------------------------------------------------------------
0000EB76                            
0000EB76 45FA 0000                  		lea	dSFXoverList(pc),a2	; load quick reference to the SFX override list
0000EB7A 43F8 C67C                  		lea	mSFXDAC1.w,a1		; start from SFX DAC1 channel
0000EB7E 7E06                       		moveq	#SFX_Ch-1,d7		; prepare total number of SFX channels into d7
0000EB80 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0000EB82                            
0000EB82                            .loopSFX
0000EB82 4A11                       		tst.b	(a1)			; check if SFX channel is running a tracker
0000EB84 6A00                       		bpl.s	.nextSFX		; if not, skip this channel
0000EB86                            
0000EB86 7000                       		moveq	#0,d0
0000EB88 1029 0001                  		move.b	cType(a1),d0		; load SFX channel type to d0
0000EB8C 6B00                       		bmi.s	.SFXPSG			; if negative, it is a PSG channel
0000EB8E                            
0000EB8E 0240 0007                  		and.w	#$07,d0			; get only the necessary bits to d3
0000EB92 5540                       		subq.w	#2,d0			; since FM 1 and 2 are not used, skip over them
0000EB94 D040                       		add.w	d0,d0			; double offset (each entry is 1 word in size)
0000EB96 6000                       		bra.s	.override
0000EB98                            ; ---------------------------------------------------------------------------
0000EB98                            
0000EB98                            .SFXPSG
0000EB98 E808                       		lsr.b	#4,d0			; make it easier to reference the right offset in the table
0000EB9A                            .override
0000EB9A 3672 0000                  		move.w	(a2,d0.w),a3		; get music channel RAM address to a3
0000EB9E 08D3 0001                  		bset	#cfbInt,(a3)		; set as interrupted
0000EBA2                            
0000EBA2                            .nextSFX
0000EBA2 D2C6                       		adda.w	d6,a1			; go to the next channel
0000EBA4 51CF FFDC                  		dbf	d7,.loopSFX		; repeat for all SFX channels
0000EBA8                            ; ---------------------------------------------------------------------------
0000EBA8                            ; Here we mute all non-interrupted FM and PSG channels
0000EBA8                            ; ---------------------------------------------------------------------------
0000EBA8                            
0000EBA8 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0000EBAC 7804                       		moveq	#Mus_FM-1,d4		; prepare total number of FM channels into d7
0000EBAE                            .stopFM
0000EBAE 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key off even if not interrupted
0000EBB2 DAC6                       		adda.w	d6,a5			; go to the next channel
0000EBB4 51CC FFF8                  		dbf	d4,.stopFM		; repeat for all FM channels
0000EBB8                            
0000EBB8 7802                       		moveq	#Mus_PSG-1,d4		; start from PSG1 channel
0000EBBA                            .mutePSG
0000EBBA 4EBA 0000                  		jsr	dMutePSGmus(pc)		; mute PSG channel if not interrupted
0000EBBE DAC6                       		adda.w	d6,a5			; go to the next channel
0000EBC0 51CC FFF8                  		dbf	d4,.mutePSG		; repeat for all FM channels
0000EBC4 4E75                       		rts
0000EBC6                            
0000EBC6                            ; ===========================================================================
0000EBC6                            ; ---------------------------------------------------------------------------
0000EBC6                            ; Type values for different channels. Used for playing music
0000EBC6                            ; ---------------------------------------------------------------------------
0000EBC6 0B0E                       dDACtypeVals:	dc.b ctDAC1, ctDAC2
0000EBC8 0001 0204 05               dFMtypeVals:	dc.b ctFM1, ctFM2, ctFM3, ctFM4, ctFM5
0000EBCD 80A0 C0                    dPSGtypeVals:	dc.b ctPSG1, ctPSG2, ctPSG3
0000EBD0                            		even
0000EBD0                            ; ===========================================================================
0000EBD0                            ; ---------------------------------------------------------------------------
0000EBD0                            ; Subroutine to play a queued sound effect
0000EBD0                            ; ---------------------------------------------------------------------------
0000EBD0                            
0000EBD0                            dPlaySnd_SFX:
0000EBD0                            ; ---------------------------------------------------------------------------
0000EBD0                            ; This is a little special case with Sonic 1 - 3K, where the ring
0000EBD0                            ; sound effect would change panning each time it is played. AMPS
0000EBD0                            ; emulates this behavior like the original drivers did, by
0000EBD0                            ; playing a different sound effect ID.
0000EBD0                            ; ---------------------------------------------------------------------------
0000EBD0                            
0000EBD0                            		;cmpi.b	#sfx_RingRight,d7	; check if the sound effect was the ring sound effect
0000EBD0                            		;bne.s	.noring			; if not, skip
0000EBD0                            		;bchg	#mfbRing,mFlags.w	; swap flag and check if it was set
0000EBD0                            		;beq.s	.noring			; if was not, do not change sound effect
0000EBD0                            		;move.w	#sfx_RingLeft,d7	; switch to left panned sound effect instead
0000EBD0                            ; ---------------------------------------------------------------------------
0000EBD0                            ; To save few cycles, we don't directly substract the SFX offset from
0000EBD0                            ; the ID, and instead offset the table position. In practice this will
0000EBD0                            ; have the same effect, but saves us 8 cycles overall.
0000EBD0                            ; ---------------------------------------------------------------------------
0000EBD0                            
0000EBD0                            .noring
0000EBD0 43FA 0000                  		lea	SoundIndex-(SFXoff*4)(pc),a1; get sfx pointer table with an offset to a4
0000EBD4 1207                       		move.b	d7,d1			; copy sfx ID to d1 (used later)
0000EBD6 DE47                       		add.w	d7,d7			; quadruple sfx ID
0000EBD8 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0000EBDA 2871 7000                  		movea.l	(a1,d7.w),a4		; get SFX header pointer from the table
0000EBDE                            
0000EBDE 200C                       		move.l	a4,d0			; copy pointer to d0
0000EBE0 0280 00FF FFFF             		and.l	#$FFFFFF,d0		; clearing the upper 8 bits allows the debugger
0000EBE6 2840                       		move.l	d0,a4			; to show the address correctly. Move ptr back to a4
0000EBE8                            		AMPS_Debug_PlayTrackSFX		; check if this was valid sound effect
0000EBE8 0C80 0000 0000           M 	cmp.l	#sfxaddr,d0
0000EBEE 6500                     M 	blo.s	.fail_605
0000EBF0 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EBF6 6500                     M 	blo.s	.ok_605
0000EBF8                          M .fail_605
0000EBF8                          M 	raiseerror	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000EBF8 487A FFFE                M 	pea	*(pc)
0000EBFC                          M 	raiseerror2	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000EBFC 40E7                     M 	move.w	sr,-(sp)
0000EBFE                          M 	__fstring_generateargumentscode	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE =00000018                M 	__pos:	set instr("Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EBFE =00000000                M 	__stack:set	0
0000EBFE =00000000                M 	__sp:	set 0
0000EBFE                          M 	while	(__pos)
0000EBFE =0000001F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EBFE =00000021                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EBFE =0000001F                M 	__midpos:	= __endpos
0000EBFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	pushp	"move.b d0,1(sp)"
0000EBFE                          M 	pushp	"subq.w	#2, sp"
0000EBFE =00000002                M 	__stack:	= __stack+2
0000EBFE =00000002                M 	__sp:	= __sp+2
0000EBFE =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EBFE =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EBFE =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EBFE =00000029                M 	__midpos:	= __endpos
0000EBFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	pushp	"move.l a4,-(sp)"
0000EBFE =00000003                M 	__stack:	= __stack+1
0000EBFE =00000006                M 	__sp:	= __sp+4
0000EBFE =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EBFE =00000031                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EBFE =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EBFE =00000031                M 	__midpos:	= __endpos
0000EBFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE =00000032                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EBFE =0000003D                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EBFE =00000039                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EBFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EBFE                          M 	pushp	"move.l a4,-(sp)"
0000EBFE =00000004                M 	__stack:	= __stack+1
0000EBFE =0000000A                M 	__sp:	= __sp+4
0000EBFE =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EBFE                          M 	rept	__stack
0000EBFE                          M 	popp	__command
0000EBFE 2F0C                     M 	move.l	a4,-(sp)
0000EC00                          M 	popp	__command
0000EC00 2F0C                     M 	move.l	a4,-(sp)
0000EC02                          M 	popp	__command
0000EC02 554F                     M 	subq.w	#2,sp
0000EC04                          M 	popp	__command
0000EC04 1F40 0001                M 	move.b	d0,1(sp)
0000EC08 4EB9 0000 0000           M 	jsr	errorhandler
0000EC0E                          M 	__fstring_generatedecodedstring	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC0E =00000001                M 	__lpos:	set 1
0000EC0E =00000018                M 	__pos:	set instr("Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC0E                          M 	while	(__pos)
0000EC0E                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC0E 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at SFX "
0000EC25 =0000001F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EC25 =00000021                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EC25 =0000001F                M 	__midpos:	= __endpos
0000EC25                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC25                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC25                          M 	__param:	substr ,,"hex"
0000EC25 80                       M 	dc.b	hex
0000EC26 =00000020                M 	__lpos:	set __endpos+1
0000EC26 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC26                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC26 3A20                     M 	dc.b	": "
0000EC28 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EC28 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EC28 =00000029                M 	__midpos:	= __endpos
0000EC28                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC28                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC28                          M 	__param:	substr ,,"hex"
0000EC28 83                       M 	dc.b	hex|3
0000EC29 =0000002A                M 	__lpos:	set __endpos+1
0000EC29 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC29                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC29                          M 	dc.b	""
0000EC29 =00000031                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EC29 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EC29 =00000031                M 	__midpos:	= __endpos
0000EC29                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC29                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC29 E0                       M 	dc.b	fendl
0000EC2A =00000032                M 	__lpos:	set __endpos+1
0000EC2A =00000032                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC2A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC2A                          M 	dc.b	""
0000EC2A =0000003D                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EC2A =00000039                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EC2A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC2A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC2A B3                       M 	dc.b	sym|3
0000EC2B =0000003E                M 	__lpos:	set __endpos+1
0000EC2B =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC2B                          M 	__substr:	substr __lpos,,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC2B                          M 	dc.b	""
0000EC2B 00                       M 	dc.b	0
0000EC2C 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EC2E 00                       M 	even
0000EC2E 4EFA EAA8                M 	jmp	amps_debug_console_main
0000EC32                          M 	even
0000EC32                          M .ok_605
0000EC32                            ; ---------------------------------------------------------------------------
0000EC32                            ; Continous SFX is a very special type of sound effect. Unlike other
0000EC32                            ; sound effects, when a continous SFX is played, it will run a loop
0000EC32                            ; again, until it is no longer queued. This is very useful for sound
0000EC32                            ; effects that need to be queued very often, but that really do not
0000EC32                            ; sound good when restarted (plus, it requires more CPU time, anyway).
0000EC32                            ; Even the Marble Zone block pushing sound effect had similar behavior,
0000EC32                            ; but the code was not quite as matured as this here. Only one continous
0000EC32                            ; SFX may be running at once, when other type is loaded, the earlier one
0000EC32                            ; is stopped and replaced.
0000EC32                            ; ---------------------------------------------------------------------------
0000EC32                            
0000EC32 4A31 7000                  		tst.b	(a1,d7.w)		; check if this sound effect is continously looping
0000EC36 6A00                       		bpl.s	.nocont			; if not, skip
0000EC38 11EC 0001 C4C2             		move.b	1(a4),mContCtr.w	; copy the number of channels as the new continous loop counter
0000EC3E B238 C4C3                  		cmp.b	mContLast.w,d1		; check if the last continous SFX had the same ID
0000EC42 6600                       		bne.s	.setcont		; if not, play as a new sound effect anyway
0000EC44 4E75                       		rts
0000EC46                            
0000EC46                            .setcont
0000EC46 11C1 C4C3                  		move.b	d1,mContLast.w		; save new continous SFX ID
0000EC4A                            .nocont
0000EC4A 224C                       		movea.l	a4,a1			; copy tracker header pointer to a1
0000EC4C                            
0000EC4C 7E00                       		moveq	#0,d7
0000EC4E 47FA 0000                  		lea	dSFXoverList(pc),a3	; load quick reference to the SFX override list to a3
0000EC52 45FA 0000                  		lea	dSFXoffList(pc),a2	; load quick reference to the SFX channel list to a2
0000EC56 1A19                       		move.b	(a1)+,d5		; load sound effect priority to d5
0000EC58 1E19                       		move.b	(a1)+,d7		; load number of SFX channels to d7
0000EC5A 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0000EC5C                            ; ---------------------------------------------------------------------------
0000EC5C                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0000EC5C                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0000EC5C                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0000EC5C                            ; is controlled by the 68000, we would be off by a single frame without
0000EC5C                            ; this fix.
0000EC5C                            ; ---------------------------------------------------------------------------
0000EC5C                            
0000EC5C                            .loopSFX
0000EC5C 7600                       		moveq	#0,d3
0000EC5E 7402                       		moveq	#2,d2			; prepare duration of 1 frames to d5
0000EC60 1629 0001                  		move.b	1(a1),d3		; load sound effect channel type to d3
0000EC64 1803                       		move.b	d3,d4			; copy type to d4
0000EC66 6B00                       		bmi.s	.chPSG			; if channel is a PSG channel, branch
0000EC68                            
0000EC68 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0000EC6C 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0000EC6E D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0000EC70                            
0000EC70 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0000EC74 BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0000EC78 6500                       		blo.s	.skip			; if not, we can not override it
0000EC7A                            
0000EC7A 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0000EC7E 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0000EC82 7401                       		moveq	#1,d2			; prepare duration of 0 frames to d5
0000EC84 6000                       		bra.s	.clearCh
0000EC86                            ; ---------------------------------------------------------------------------
0000EC86                            
0000EC86                            .skip
0000EC86 5C89                       		addq.l	#6,a1			; skip this sound effect channel
0000EC88 51CF FFD2                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000EC8C 4E75                       		rts
0000EC8E                            ; ---------------------------------------------------------------------------
0000EC8E                            
0000EC8E                            .chPSG
0000EC8E E84B                       		lsr.w	#4,d3			; make it easier to reference the right offset in the table
0000EC90 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0000EC94 BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0000EC98 65EC                       		blo.s	.skip			; if not, we can not override it
0000EC9A                            
0000EC9A 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0000EC9E 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0000ECA2 0004 001F                  		ori.b	#$1F,d4			; add volume update and max volume to channel type
0000ECA6 13C4 00C0 0011             		move.b	d4,dPSG			; send volume mute command to PSG
0000ECAC                            
0000ECAC 0C04 00DF                  		cmpi.b	#ctPSG3|$1F,d4		; check if we sent command about PSG3
0000ECB0 6600                       		bne.s	.clearCh		; if not, skip
0000ECB2 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send volume mute command for PSG4 to PSG
0000ECBA                            
0000ECBA                            .clearCh
0000ECBA 3C4D                       		move.w	a5,a6			; copy sound effect channel RAM pointer to a6
0000ECBC 7006                       		moveq	#cSizeSFX/4-1,d0	; prepare SFX channel size / 4 to d0
0000ECBE                            .clear
0000ECBE 429E                       		clr.l	(a6)+			; clear 4 bytes of channel data
0000ECC0 51C8 FFFC                  		dbf	d0,.clear		; clear the entire channel
0000ECC4                            
0000ECC4                            
0000ECC4 3A99                       		move.w	(a1)+,(a5)		; load channel flags and type
0000ECC6 1B45 001A                  		move.b	d5,cPrio(a5)		; set channel priority
0000ECCA 1B42 000C                  		move.b	d2,cDuration(a5)	; reset channel duration
0000ECCE                            
0000ECCE 7000                       		moveq	#0,d0
0000ECD0 3019                       		move.w	(a1)+,d0		; load tracker offset to d0
0000ECD2 D08C                       		add.l	a4,d0			; add music header offset to d0
0000ECD4 2B40 0002                  		move.l	d0,cData(a5)		; save as the tracker address of the channel
0000ECD8                            		AMPS_Debug_PlayTrackSFX2	; make sure the tracker address is valid
0000ECD8 0C80 0000 0000           M 	cmp.l	#sfxaddr,d0
0000ECDE 6500                     M 	blo.s	.fail_610
0000ECE0 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000ECE6 6500                     M 	blo.s	.ok_610
0000ECE8                          M .fail_610
0000ECE8                          M 	raiseerror	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000ECE8 487A FFFE                M 	pea	*(pc)
0000ECEC                          M 	raiseerror2	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000ECEC 40E7                     M 	move.w	sr,-(sp)
0000ECEE                          M 	__fstring_generateargumentscode	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE =0000001C                M 	__pos:	set instr("Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ECEE =00000000                M 	__stack:set	0
0000ECEE =00000000                M 	__sp:	set 0
0000ECEE                          M 	while	(__pos)
0000ECEE =00000023                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ECEE =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ECEE =00000023                M 	__midpos:	= __endpos
0000ECEE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE                          M 	pushp	"move.l d0,-(sp)"
0000ECEE =00000001                M 	__stack:	= __stack+1
0000ECEE =00000004                M 	__sp:	= __sp+4
0000ECEE =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ECEE =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ECEE =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ECEE =0000002B                M 	__midpos:	= __endpos
0000ECEE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ECEE =00000037                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ECEE =00000033                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ECEE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECEE                          M 	pushp	"move.l d0,-(sp)"
0000ECEE =00000002                M 	__stack:	= __stack+1
0000ECEE =00000008                M 	__sp:	= __sp+4
0000ECEE =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ECEE                          M 	rept	__stack
0000ECEE                          M 	popp	__command
0000ECEE 2F00                     M 	move.l	d0,-(sp)
0000ECF0                          M 	popp	__command
0000ECF0 2F00                     M 	move.l	d0,-(sp)
0000ECF2 4EB9 0000 0000           M 	jsr	errorhandler
0000ECF8                          M 	__fstring_generatedecodedstring	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECF8 =00000001                M 	__lpos:	set 1
0000ECF8 =0000001C                M 	__pos:	set instr("Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ECF8                          M 	while	(__pos)
0000ECF8                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ECF8 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at SFX ch: "
0000ED13 =00000023                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED13 =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED13 =00000023                M 	__midpos:	= __endpos
0000ED13                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED13                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED13                          M 	__param:	substr ,,"hex"
0000ED13 83                       M 	dc.b	hex|3
0000ED14 =00000024                M 	__lpos:	set __endpos+1
0000ED14 =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED14                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED14                          M 	dc.b	""
0000ED14 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED14 =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED14 =0000002B                M 	__midpos:	= __endpos
0000ED14                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED14                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED14 E0                       M 	dc.b	fendl
0000ED15 =0000002C                M 	__lpos:	set __endpos+1
0000ED15 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED15                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED15                          M 	dc.b	""
0000ED15 =00000037                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED15 =00000033                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED15                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED15                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED15 B3                       M 	dc.b	sym|3
0000ED16 =00000038                M 	__lpos:	set __endpos+1
0000ED16 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED16                          M 	__substr:	substr __lpos,,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED16                          M 	dc.b	""
0000ED16 00                       M 	dc.b	0
0000ED17 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000ED18                          M 	even
0000ED18 4EFA E9BE                M 	jmp	amps_debug_console_main
0000ED1C                          M 	even
0000ED1C                          M .ok_610
0000ED1C                            
0000ED1C 3B59 0008                  		move.w	(a1)+,cPitch(a5)	; load pitch offset and channel volume
0000ED20 4A04                       		tst.b	d4			; check if this channel is a PSG channel
0000ED22 6B00                       		bmi.s	.loop			; if is, skip over this
0000ED24                            
0000ED24 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0000ED26 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel memory too
0000ED2A 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000ED2C 4EBA 0000                  		jsr	WriteChYM(pc)		; write to part 2 channel
0000ED30                            
0000ED30 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this channel is a DAC channel
0000ED34 6600                       		bne.s	.fm			; if not, branch
0000ED36 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; DAC default frequency is $100, NOT $000
0000ED3C                            
0000ED3C                            .loop
0000ED3C 51CF FF1E                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000ED40 4E75                       		rts
0000ED42                            ; ---------------------------------------------------------------------------
0000ED42                            ; The instant release for FM channels behavior was not in the Sonic 1
0000ED42                            ; SMPS driver by default, but it has been added since it fixes an
0000ED42                            ; issue with YM2612, where sometimes subsequent sound effect activations
0000ED42                            ; would sound different over time. This fix will help to mitigate that.
0000ED42                            ; ---------------------------------------------------------------------------
0000ED42                            
0000ED42                            .fm
0000ED42 720F                       		moveq	#$F,d1			; set to release note instantly
0000ED44 7080                       		moveq	#$FFFFFF80,d0		; YM address: Release Rate Operator 1
0000ED46 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000ED4A 7088                       		moveq	#$FFFFFF88,d0		; YM address: Release Rate Operator 3
0000ED4C 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000ED50 7084                       		moveq	#$FFFFFF84,d0		; YM address: Release Rate Operator 2
0000ED52 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000ED56 708C                       		moveq	#$FFFFFF8C,d0		; YM address: Release Rate Operator 4
0000ED58 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000ED5C                            
0000ED5C 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000ED5E 122D 0001                  		move.b	cType(a5),d1		; FM channel, all operators off
0000ED62 6100 0000                  		bsr.w	WriteYM_Pt1		; write to part 1 or 2 channel
0000ED66                            
0000ED66 51CF FEF4                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000ED6A 4E75                       		rts
0000ED6C                            ; ===========================================================================
0000ED6C                            ; ---------------------------------------------------------------------------
0000ED6C                            ; pointers for music channels SFX can override and addresses of SFX channels
0000ED6C                            ; ---------------------------------------------------------------------------
0000ED6C                            
0000ED6C C698                       dSFXoffList:	dc.w mSFXFM3			; FM3
0000ED6E C67C                       		dc.w mSFXDAC1			; DAC1
0000ED70 C6B4                       		dc.w mSFXFM4			; FM4
0000ED72 C6D0                       		dc.w mSFXFM5			; FM5
0000ED74 C6EC                       		dc.w mSFXPSG1			; PSG1
0000ED76 C708                       		dc.w mSFXPSG2			; PSG2
0000ED78 C724                       		dc.w mSFXPSG3			; PSG3
0000ED7A C724                       		dc.w mSFXPSG3			; PSG4
0000ED7C                            
0000ED7C C574                       dSFXoverList:	dc.w mFM3			; SFX FM3
0000ED7E C4C4                       		dc.w mDAC1			; SFX DAC1
0000ED80 C5A0                       		dc.w mFM4			; SFX FM4
0000ED82 C5CC                       		dc.w mFM5			; SFX FM5
0000ED84 C5F8                       		dc.w mPSG1			; SFX PSG1
0000ED86 C624                       		dc.w mPSG2			; SFX PSG2
0000ED88 C650                       		dc.w mPSG3			; SFX PSG3
0000ED8A C650                       		dc.w mPSG3			; SFX PSG4
0000ED8C                            ; ===========================================================================
0000ED8C                            ; ---------------------------------------------------------------------------
0000ED8C                            ; Play queued command
0000ED8C                            ; ---------------------------------------------------------------------------
0000ED8C                            
0000ED8C                            dPlaySnd_Comm:
0000ED8C                            		AMPS_Debug_PlayCmd		; check if the command is valid
0000ED8C 0C07 0000                M 	cmp.b	#(dsoundcommands_end-dsoundcommands)/4,d7
0000ED90 6300                     M 	bls.s	.ok
0000ED92                          M 	raiseerror	"Invalid command in queue: %<.b d7>",amps_debug_console_channel
0000ED92 487A FFFE                M 	pea	*(pc)
0000ED96                          M 	raiseerror2	"Invalid command in queue: %<.b d7>",amps_debug_console_channel
0000ED96 40E7                     M 	move.w	sr,-(sp)
0000ED98                          M 	__fstring_generateargumentscode	"Invalid command in queue: %<.b d7>"
0000ED98 =0000001B                M 	__pos:	set instr("Invalid command in queue: %<.b d7>",'%<')
0000ED98 =00000000                M 	__stack:set	0
0000ED98 =00000000                M 	__sp:	set 0
0000ED98                          M 	while	(__pos)
0000ED98 =00000022                M 	__endpos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'>')
0000ED98 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid command in queue: %<.b d7>",' ')
0000ED98 =00000022                M 	__midpos:	= __endpos
0000ED98                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000ED98                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid command in queue: %<.b d7>"
0000ED98                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid command in queue: %<.b d7>"
0000ED98                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000ED98                          M 	pushp	"move.b d7,1(sp)"
0000ED98                          M 	pushp	"subq.w	#2, sp"
0000ED98 =00000002                M 	__stack:	= __stack+2
0000ED98 =00000002                M 	__sp:	= __sp+2
0000ED98 =00000000                M 	__pos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'%<')
0000ED98                          M 	rept	__stack
0000ED98                          M 	popp	__command
0000ED98 554F                     M 	subq.w	#2,sp
0000ED9A                          M 	popp	__command
0000ED9A 1F47 0001                M 	move.b	d7,1(sp)
0000ED9E 4EB9 0000 0000           M 	jsr	errorhandler
0000EDA4                          M 	__fstring_generatedecodedstring	"Invalid command in queue: %<.b d7>"
0000EDA4 =00000001                M 	__lpos:	set 1
0000EDA4 =0000001B                M 	__pos:	set instr("Invalid command in queue: %<.b d7>",'%<')
0000EDA4                          M 	while	(__pos)
0000EDA4                          M 	__substr:	substr __lpos,__pos-1,"Invalid command in queue: %<.b d7>"
0000EDA4 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command in queue: "
0000EDBE =00000022                M 	__endpos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'>')
0000EDBE =00000000                M 	__midpos:	set instr(__pos+5,"Invalid command in queue: %<.b d7>",' ')
0000EDBE =00000022                M 	__midpos:	= __endpos
0000EDBE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid command in queue: %<.b d7>"
0000EDBE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000EDBE                          M 	__param:	substr ,,"hex"
0000EDBE 80                       M 	dc.b	hex
0000EDBF =00000023                M 	__lpos:	set __endpos+1
0000EDBF =00000000                M 	__pos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'%<')
0000EDBF                          M 	__substr:	substr __lpos,,"Invalid command in queue: %<.b d7>"
0000EDBF                          M 	dc.b	""
0000EDBF 00                       M 	dc.b	0
0000EDC0 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EDC2 00                       M 	even
0000EDC2 4EFA E16E                M 	jmp	amps_debug_console_channel
0000EDC6                          M 	even
0000EDC6                          M .ok
0000EDC6                            
0000EDC6 DE47                       		add.w	d7,d7			; quadruple ID
0000EDC8 DE47                       		add.w	d7,d7			; because each entry is 1 long word
0000EDCA 4EFB 7000                  		jmp	dSoundCommands-4(pc,d7.w); jump to appropriate command handler
0000EDCE                            
0000EDCE                            ; ---------------------------------------------------------------------------
0000EDCE                            dSoundCommands:
0000EDCE 6000 0000                  		bra.w	dPlaySnd_Reset		; 01 - Reset underwater and speed shoes flags, update volume
0000EDD2 6000 0000                  		bra.w	dPlaySnd_FadeOut	; 02 - Initialize a music fade out
0000EDD6 6000 0000                  		bra.w	dPlaySnd_Stop		; 03 - Stop all music
0000EDDA 6000 0000                  		bra.w	dPlaySnd_ShoesOn	; 04 - Enable speed shoes mode
0000EDDE 6000 0000                  		bra.w	dPlaySnd_ShoesOff	; 05 - Disable speed shoes mode
0000EDE2 6000 0000                  		bra.w	dPlaySnd_ToWater	; 06 - Enable underwater mode
0000EDE6 6000 0000                  		bra.w	dPlaySnd_OutWater	; 07 - Disable underwater mode
0000EDEA 6000 FA38                  		bra.w	dPlaySnd_Pause		; 08 - Pause the sound driver
0000EDEE 6000 F9D4                  		bra.w	dPlaySnd_Unpause	; 09 - Unpause the sound driver
0000EDF2                            dSoundCommands_End:
0000EDF2                            ; ===========================================================================
0000EDF2                            ; ---------------------------------------------------------------------------
0000EDF2                            ; Commands for what to do after a volume fade
0000EDF2                            ; ---------------------------------------------------------------------------
0000EDF2                            
0000EDF2                            dFadeCommands:
0000EDF2 4E75                       		rts				; 80 - Do nothing
0000EDF4 4E75                       		rts
0000EDF6 6000                       .stop		bra.s	dPlaySnd_Stop		; 84 - Stop all music
0000EDF8 4E75                       		rts
0000EDFA 6000 0000                  .resv		bra.w	dResetVolume		; 88 - Reset volume and update
0000EDFE 61FA                       		bsr.s	.resv			; 8C - Stop music playing and reset volume
0000EE00 60F4                       		bra.s	.stop
0000EE02                            ; ===========================================================================
0000EE02                            ; ---------------------------------------------------------------------------
0000EE02                            ; Stop music and SFX from playing (This code clears SFX RAM also)
0000EE02                            ; ---------------------------------------------------------------------------
0000EE02                            
0000EE02                            dPlaySnd_Stop:
0000EE02                            ; Not needed,	moveq	#$2B,d0			; YM command: DAC Enable
0000EE02                            ; Dual PCM does	moveq	#$FFFFFF80,d1		; FM6 acts as DAC
0000EE02                            ; this for us	jsr	WriteYM_Pt1(pc)		; write to YM global register
0000EE02                            
0000EE02 7027                       		moveq	#$27,d0			; YM command: Channel 3 Mode & Timer Control
0000EE04 7200                       		moveq	#0,d1			; disable timers and channel 3 special mode
0000EE06 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to YM global register
0000EE0A                            
0000EE0A 43F8 C67C                  		lea	mSFXDAC1.w,a1		; prepare SFX DAC 1 to start clearing fromn
0000EE0E                            
0000EE0E                            	rept (mSize-mSFXDAC1)/4
0000EE0E                            		clr.l	(a1)+			; clear entire SFX RAM (others done below)
0000EE0E                            	endr
0000EE0E 4299                     M 	clr.l	(a1)+
0000EE10 4299                     M 	clr.l	(a1)+
0000EE12 4299                     M 	clr.l	(a1)+
0000EE14 4299                     M 	clr.l	(a1)+
0000EE16 4299                     M 	clr.l	(a1)+
0000EE18 4299                     M 	clr.l	(a1)+
0000EE1A 4299                     M 	clr.l	(a1)+
0000EE1C 4299                     M 	clr.l	(a1)+
0000EE1E 4299                     M 	clr.l	(a1)+
0000EE20 4299                     M 	clr.l	(a1)+
0000EE22 4299                     M 	clr.l	(a1)+
0000EE24 4299                     M 	clr.l	(a1)+
0000EE26 4299                     M 	clr.l	(a1)+
0000EE28 4299                     M 	clr.l	(a1)+
0000EE2A 4299                     M 	clr.l	(a1)+
0000EE2C 4299                     M 	clr.l	(a1)+
0000EE2E 4299                     M 	clr.l	(a1)+
0000EE30 4299                     M 	clr.l	(a1)+
0000EE32 4299                     M 	clr.l	(a1)+
0000EE34 4299                     M 	clr.l	(a1)+
0000EE36 4299                     M 	clr.l	(a1)+
0000EE38 4299                     M 	clr.l	(a1)+
0000EE3A 4299                     M 	clr.l	(a1)+
0000EE3C 4299                     M 	clr.l	(a1)+
0000EE3E 4299                     M 	clr.l	(a1)+
0000EE40 4299                     M 	clr.l	(a1)+
0000EE42 4299                     M 	clr.l	(a1)+
0000EE44 4299                     M 	clr.l	(a1)+
0000EE46 4299                     M 	clr.l	(a1)+
0000EE48 4299                     M 	clr.l	(a1)+
0000EE4A 4299                     M 	clr.l	(a1)+
0000EE4C 4299                     M 	clr.l	(a1)+
0000EE4E 4299                     M 	clr.l	(a1)+
0000EE50 4299                     M 	clr.l	(a1)+
0000EE52 4299                     M 	clr.l	(a1)+
0000EE54 4299                     M 	clr.l	(a1)+
0000EE56 4299                     M 	clr.l	(a1)+
0000EE58 4299                     M 	clr.l	(a1)+
0000EE5A 4299                     M 	clr.l	(a1)+
0000EE5C 4299                     M 	clr.l	(a1)+
0000EE5E 4299                     M 	clr.l	(a1)+
0000EE60 4299                     M 	clr.l	(a1)+
0000EE62 4299                     M 	clr.l	(a1)+
0000EE64 4299                     M 	clr.l	(a1)+
0000EE66 4299                     M 	clr.l	(a1)+
0000EE68 4299                     M 	clr.l	(a1)+
0000EE6A 4299                     M 	clr.l	(a1)+
0000EE6C 4299                     M 	clr.l	(a1)+
0000EE6E 4299                     M 	clr.l	(a1)+
0000EE70                            
0000EE70 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0000EE72                            	; continue straight to stopping music
0000EE72                            ; ===========================================================================
0000EE72                            ; ---------------------------------------------------------------------------
0000EE72                            ; Stop music from playing, reset driver memory and mute hardware
0000EE72                            ; ---------------------------------------------------------------------------
0000EE72                            
0000EE72                            dStopMusic:
0000EE72 43F8 C4A6                  		lea	mFlags.w,a1		; load driver RAM start to a1
0000EE76 3611                       		move.w	(a1),d3			; load driver flags and PAL counter to d3
0000EE78 1838 C4C0                  		move.b	mMasterVolDAC.w,d4	; load DAC master volume to d4
0000EE7C 2A38 C4BC                  		move.l	mQueue.w,d5		; load sound queue and PSG master volume to d5
0000EE80 4CF8 0007 C4AC             		movem.l	mComm.w,d0-d2		; load communications bytes, FM master volume and fade address to d0-d2
0000EE86                            
0000EE86                            	rept (mSFXDAC1-mFlags)/4
0000EE86                            		clr.l	(a1)+			; clear driver and music channel memory
0000EE86                            	endr
0000EE86 4299                     M 	clr.l	(a1)+
0000EE88 4299                     M 	clr.l	(a1)+
0000EE8A 4299                     M 	clr.l	(a1)+
0000EE8C 4299                     M 	clr.l	(a1)+
0000EE8E 4299                     M 	clr.l	(a1)+
0000EE90 4299                     M 	clr.l	(a1)+
0000EE92 4299                     M 	clr.l	(a1)+
0000EE94 4299                     M 	clr.l	(a1)+
0000EE96 4299                     M 	clr.l	(a1)+
0000EE98 4299                     M 	clr.l	(a1)+
0000EE9A 4299                     M 	clr.l	(a1)+
0000EE9C 4299                     M 	clr.l	(a1)+
0000EE9E 4299                     M 	clr.l	(a1)+
0000EEA0 4299                     M 	clr.l	(a1)+
0000EEA2 4299                     M 	clr.l	(a1)+
0000EEA4 4299                     M 	clr.l	(a1)+
0000EEA6 4299                     M 	clr.l	(a1)+
0000EEA8 4299                     M 	clr.l	(a1)+
0000EEAA 4299                     M 	clr.l	(a1)+
0000EEAC 4299                     M 	clr.l	(a1)+
0000EEAE 4299                     M 	clr.l	(a1)+
0000EEB0 4299                     M 	clr.l	(a1)+
0000EEB2 4299                     M 	clr.l	(a1)+
0000EEB4 4299                     M 	clr.l	(a1)+
0000EEB6 4299                     M 	clr.l	(a1)+
0000EEB8 4299                     M 	clr.l	(a1)+
0000EEBA 4299                     M 	clr.l	(a1)+
0000EEBC 4299                     M 	clr.l	(a1)+
0000EEBE 4299                     M 	clr.l	(a1)+
0000EEC0 4299                     M 	clr.l	(a1)+
0000EEC2 4299                     M 	clr.l	(a1)+
0000EEC4 4299                     M 	clr.l	(a1)+
0000EEC6 4299                     M 	clr.l	(a1)+
0000EEC8 4299                     M 	clr.l	(a1)+
0000EECA 4299                     M 	clr.l	(a1)+
0000EECC 4299                     M 	clr.l	(a1)+
0000EECE 4299                     M 	clr.l	(a1)+
0000EED0 4299                     M 	clr.l	(a1)+
0000EED2 4299                     M 	clr.l	(a1)+
0000EED4 4299                     M 	clr.l	(a1)+
0000EED6 4299                     M 	clr.l	(a1)+
0000EED8 4299                     M 	clr.l	(a1)+
0000EEDA 4299                     M 	clr.l	(a1)+
0000EEDC 4299                     M 	clr.l	(a1)+
0000EEDE 4299                     M 	clr.l	(a1)+
0000EEE0 4299                     M 	clr.l	(a1)+
0000EEE2 4299                     M 	clr.l	(a1)+
0000EEE4 4299                     M 	clr.l	(a1)+
0000EEE6 4299                     M 	clr.l	(a1)+
0000EEE8 4299                     M 	clr.l	(a1)+
0000EEEA 4299                     M 	clr.l	(a1)+
0000EEEC 4299                     M 	clr.l	(a1)+
0000EEEE 4299                     M 	clr.l	(a1)+
0000EEF0 4299                     M 	clr.l	(a1)+
0000EEF2 4299                     M 	clr.l	(a1)+
0000EEF4 4299                     M 	clr.l	(a1)+
0000EEF6 4299                     M 	clr.l	(a1)+
0000EEF8 4299                     M 	clr.l	(a1)+
0000EEFA 4299                     M 	clr.l	(a1)+
0000EEFC 4299                     M 	clr.l	(a1)+
0000EEFE 4299                     M 	clr.l	(a1)+
0000EF00 4299                     M 	clr.l	(a1)+
0000EF02 4299                     M 	clr.l	(a1)+
0000EF04 4299                     M 	clr.l	(a1)+
0000EF06 4299                     M 	clr.l	(a1)+
0000EF08 4299                     M 	clr.l	(a1)+
0000EF0A 4299                     M 	clr.l	(a1)+
0000EF0C 4299                     M 	clr.l	(a1)+
0000EF0E 4299                     M 	clr.l	(a1)+
0000EF10 4299                     M 	clr.l	(a1)+
0000EF12 4299                     M 	clr.l	(a1)+
0000EF14 4299                     M 	clr.l	(a1)+
0000EF16 4299                     M 	clr.l	(a1)+
0000EF18 4299                     M 	clr.l	(a1)+
0000EF1A 4299                     M 	clr.l	(a1)+
0000EF1C 4299                     M 	clr.l	(a1)+
0000EF1E 4299                     M 	clr.l	(a1)+
0000EF20 4299                     M 	clr.l	(a1)+
0000EF22 4299                     M 	clr.l	(a1)+
0000EF24 4299                     M 	clr.l	(a1)+
0000EF26 4299                     M 	clr.l	(a1)+
0000EF28 4299                     M 	clr.l	(a1)+
0000EF2A 4299                     M 	clr.l	(a1)+
0000EF2C 4299                     M 	clr.l	(a1)+
0000EF2E 4299                     M 	clr.l	(a1)+
0000EF30 4299                     M 	clr.l	(a1)+
0000EF32 4299                     M 	clr.l	(a1)+
0000EF34 4299                     M 	clr.l	(a1)+
0000EF36 4299                     M 	clr.l	(a1)+
0000EF38 4299                     M 	clr.l	(a1)+
0000EF3A 4299                     M 	clr.l	(a1)+
0000EF3C 4299                     M 	clr.l	(a1)+
0000EF3E 4299                     M 	clr.l	(a1)+
0000EF40 4299                     M 	clr.l	(a1)+
0000EF42 4299                     M 	clr.l	(a1)+
0000EF44 4299                     M 	clr.l	(a1)+
0000EF46 4299                     M 	clr.l	(a1)+
0000EF48 4299                     M 	clr.l	(a1)+
0000EF4A 4299                     M 	clr.l	(a1)+
0000EF4C 4299                     M 	clr.l	(a1)+
0000EF4E 4299                     M 	clr.l	(a1)+
0000EF50 4299                     M 	clr.l	(a1)+
0000EF52 4299                     M 	clr.l	(a1)+
0000EF54 4299                     M 	clr.l	(a1)+
0000EF56 4299                     M 	clr.l	(a1)+
0000EF58 4299                     M 	clr.l	(a1)+
0000EF5A 4299                     M 	clr.l	(a1)+
0000EF5C 4299                     M 	clr.l	(a1)+
0000EF5E 4299                     M 	clr.l	(a1)+
0000EF60 4299                     M 	clr.l	(a1)+
0000EF62 4299                     M 	clr.l	(a1)+
0000EF64 4299                     M 	clr.l	(a1)+
0000EF66 4299                     M 	clr.l	(a1)+
0000EF68 4299                     M 	clr.l	(a1)+
0000EF6A 4299                     M 	clr.l	(a1)+
0000EF6C 4299                     M 	clr.l	(a1)+
0000EF6E 4299                     M 	clr.l	(a1)+
0000EF70                            
0000EF70 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0000EF72                            
0000EF72 31C3 C4A6                  		move.w	d3,mFlags.w		; save driver flags and PAL counter
0000EF76 11C4 C4C0                  		move.b	d4,mMasterVolDAC.w	; save DAC master volume
0000EF7A 21C5 C4BC                  		move.l	d5,mQueue.w		; save sound queue and PSG master volume
0000EF7E 48F8 0007 C4AC             		movem.l	d0-d2,mComm.w		; save communications bytes, FM master volume and fade address
0000EF84                            
0000EF84 6100                       		bsr.s	dMutePSG		; hardware mute PSG
0000EF86 4EBA F8D0                  		jsr	dMuteDAC(pc)		; hardware mute DAC
0000EF8A                            	; continue straight to hardware muting FM
0000EF8A                            ; ===========================================================================
0000EF8A                            ; ---------------------------------------------------------------------------
0000EF8A                            ; Mute all FM channels
0000EF8A                            ; ---------------------------------------------------------------------------
0000EF8A                            
0000EF8A                            dMuteFM:
0000EF8A 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000EF8C 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0000EF8E                            
0000EF8E                            .noteoff
0000EF8E 1203                       		move.b	d3,d1			; copy value into d1
0000EF90 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000EF94 5801                       		addq.b	#4,d1			; set this to part 2 channel
0000EF96 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000EF9A 51CB FFF2                  		dbf	d3,.noteoff		; loop for all 3 channel groups
0000EF9E                            
0000EF9E 7040                       		moveq	#$40,d0			; YM command: Total Level Operator 1
0000EFA0 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0000EFA2 7802                       		moveq	#3-1,d4			; prepare 3 groups of channels to d4
0000EFA4                            
0000EFA4                            .chloop
0000EFA4 7603                       		moveq	#4-1,d3			; prepare 4 operator writes per channel to d3
0000EFA6 7A0F                       		moveq	#$10-1,d5		; prepare the value for going to next channel to d5
0000EFA8                            
0000EFA8                            .oploop
0000EFA8 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000EFAC 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EFB0 5840                       		addq.w	#4,d0			; go to next operator (1 2 3 4)
0000EFB2 51CB FFF4                  		dbf	d3,.oploop		; repeat for each operator
0000EFB6                            
0000EFB6 9005                       		sub.b	d5,d0			; go to next FM channel
0000EFB8 51CC FFEA                  		dbf	d4,.chloop		; repeat for each channel
0000EFBC 4E75                       		rts
0000EFBE                            ; ===========================================================================
0000EFBE                            ; ---------------------------------------------------------------------------
0000EFBE                            ; Routine for muting all PSG channels
0000EFBE                            ; ---------------------------------------------------------------------------
0000EFBE                            
0000EFBE                            dMutePSG:
0000EFBE 43F9 00C0 0011             		lea	dPSG,a1			; load PSG data port address to a1
0000EFC4 12BC 009F                  		move.b	#ctPSG1|$1F,(a1)	; send volume mute command for PSG1 to PSG
0000EFC8 12BC 00BF                  		move.b	#ctPSG2|$1F,(a1)	; send volume mute command for PSG2 to PSG
0000EFCC 12BC 00DF                  		move.b	#ctPSG3|$1F,(a1)	; send volume mute command for PSG3 to PSG
0000EFD0 12BC 00FF                  		move.b	#ctPSG4|$1F,(a1)	; send volume mute command for PSG4 to PSG
0000EFD4 4E75                       		rts
0000EFD6                            ; ===========================================================================
0000EFD6                            ; ---------------------------------------------------------------------------
0000EFD6                            ; Normal fade out data
0000EFD6                            ; ---------------------------------------------------------------------------
0000EFD6                            
0000EFD6                            dFadeOutDataLog:
0000EFD6 0101 0002 0200 0204 0103+  	dc.b $01, $01, $00,  $02, $02, $00,  $02, $04, $01,  $03, $05, $01
0000EFE2 0405 0104 0602 0507 0206+  	dc.b $04, $05, $01,  $04, $06, $02,  $05, $07, $02,  $06, $08, $02
0000EFEE 0709 0309 0B03 0A0C 030C+  	dc.b $07, $09, $03,  $09, $0B, $03,  $0A, $0C, $03,  $0C, $0E, $03
0000EFFA 0E10 0410 1104 1113 0414+  	dc.b $0E, $10, $04,  $10, $11, $04,  $11, $13, $04,  $14, $15, $05
0000F006 1618 051A 1C05 1C1F 0620+  	dc.b $16, $18, $05,  $1A, $1C, $05,  $1C, $1F, $06,  $20, $24, $06
0000F012 2228 0726 2E07 2C34 0830+  	dc.b $22, $28, $07,  $26, $2E, $07,  $2C, $34, $08,  $30, $39, $08
0000F01E 343E 093C 440A 404C 0A46+  	dc.b $34, $3E, $09,  $3C, $44, $0A,  $40, $4C, $0A,  $46, $54, $0B
0000F02A 4C5A 0C54 620D 5C6B 0D60+  	dc.b $4C, $5A, $0C,  $54, $62, $0D,  $5C, $6B, $0D,  $60, $76, $0E
0000F036 6C7C 0E74 7F0F 7F7F 0F8C   	dc.b $6C, $7C, $0E,  $74, $7F, $0F,  $7F, $7F, $0F,  fReset
0000F040                            
0000F040                            ;dFadeOutDataLinear:
0000F040                            ;	dc.b $01, $00, $00,  $02, $01, $00,  $02, $01, $01,  $03, $02, $01
0000F040                            ;	dc.b $04, $02, $01,  $04, $03, $02,  $05, $03, $02,  $06, $04, $02
0000F040                            ;	dc.b $07, $05, $03,  $09, $06, $03,  $0A, $08, $03,  $0C, $0A, $03
0000F040                            ;	dc.b $0E, $0D, $04,  $10, $0F, $04,  $11, $10, $04,  $14, $13, $05
0000F040                            ;	dc.b $16, $16, $05,  $1A, $1A, $05,  $1C, $1E, $06,  $20, $22, $06
0000F040                            ;	dc.b $22, $27, $07,  $26, $2A, $07,  $2C, $2E, $08,  $30, $34, $08
0000F040                            ;	dc.b $34, $39, $09,  $3C, $3E, $0A,  $40, $3F, $0A,  $46, $40, $0B
0000F040                            ;	dc.b $4C, $40, $0C,  $54, $40, $0D,  $5C, $40, $0D,  $60, $40, $0E
0000F040                            ;	dc.b $6C, $40, $0E,  $74, $40, $0F,  $7F, $40, $0F,  fReset
0000F040                            	even
0000F040                            ; ===========================================================================
0000F040                            ; ---------------------------------------------------------------------------
0000F040                            ; Subroutine for initializing a fade effect.
0000F040                            ; Since the driver allows for such an extensive and customizable
0000F040                            ; fading code, we may hit a snag if we use fades too fast. It is
0000F040                            ; possible, for example, to fade out, then in the middle of that,
0000F040                            ; start fading in. This would normally cause a quick jump in the
0000F040                            ; volume level from maybe half to completely mute. This routine
0000F040                            ; aims to combat this by actually searching for the closest FM
0000F040                            ; volume level in the fade program, and to start the new fade from
0000F040                            ; where that byte appears. This can alter how long a volume fade
0000F040                            ; lasts however, and if PSG and DAC volume are not correct faded,
0000F040                            ; it may still cause a jump in their volume (especially if only,
0000F040                            ; say, DAC fades volume). In the future, there might be a fix for
0000F040                            ; that.
0000F040                            ; ---------------------------------------------------------------------------
0000F040                            
0000F040                            dPlaySnd_FadeOut:
0000F040 43FA FF94                  		lea	dFadeOutDataLog(pc),a1	; prepare stock fade out program to a1
0000F044                            
0000F044                            dLoadFade:
0000F044 1038 C4B4                  		move.b	mMasterVolFM.w,d0	; load FM master volume to d0
0000F048 4A38 C4B5                  		tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0000F04C 6700                       		beq.s	.nofade			; if not, load fade as is
0000F04E                            
0000F04E 2449                       		move.l	a1,a2			; copy fade program address to a2
0000F050 74FF                       		moveq	#-1,d2			; prepare max byter difference
0000F052                            
0000F052                            .find
0000F052 1212                       		move.b	(a2),d1			; load the next FM volume from fade program
0000F054 6A00                       		bpl.s	.search			; branch if this is not a command
0000F056                            
0000F056                            .nofade
0000F056 21C9 C4B4                  		move.l	a1,mFadeAddr.w		; save new fade program address to memory
0000F05A 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save new FM master volume
0000F05E 4E75                       		rts
0000F060                            
0000F060                            .search
0000F060 568A                       		addq.l	#3,a2			; skip over the current volume group
0000F062 9200                       		sub.b	d0,d1			; sub current FM volume from read volume
0000F064 6A00                       		bpl.s	.abs			; if positive, do not negate
0000F066 4401                       		neg.b	d1			; negative to positive
0000F068                            
0000F068                            .abs
0000F068 B202                       		cmp.b	d2,d1			; check if volume difference was smaller than before
0000F06A 64E6                       		bhs.s	.find			; if not, read next group
0000F06C                            
0000F06C 1401                       		move.b	d1,d2			; else save the new difference
0000F06E 224A                       		move.l	a2,a1			; also save the fade program address where we found it
0000F070 60E0                       		bra.s	.find			; loop through each group in the program
0000F072                            ; ===========================================================================
0000F072                            ; ---------------------------------------------------------------------------
0000F072                            ; Routine for loading a volume filter into Dual PCM ROM.
0000F072                            ; This routine will actually write the bank number the volume filter
0000F072                            ; is in. This requires volume filters are aligned to Z80 banks, and
0000F072                            ; just because we can, we write 9 bits (yeah its not necessary, but
0000F072                            ; what the hell, you have to have fun sometimes!)
0000F072                            ; ---------------------------------------------------------------------------
0000F072                            
0000F072                            dSetFilter:
0000F072 43F9 0000 0000             		lea	dZ80+SV_VolumeBank,a1	; load volume bank instructions address to a1
0000F078 7274                       		moveq	#$74,d1			; prepare the "ld  (hl),h" instruction to d1
0000F07A 7408                       		moveq	#9-1,d2			; prepare number of instructions to write to d2
0000F07C                            	StopZ80					; wait for Z80 to stop
0000F07C 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F084                          M 	waitz80stop
0000F084 0839 0000 00A1 1100      M .wait_621:	btst	#0,z80_bus_req
0000F08C 66F6                     M 	bne.s	.wait_621
0000F08E                            ; ---------------------------------------------------------------------------
0000F08E                            ; addx in Motorola 68000 is much like adc in Z80. It allows us to add
0000F08E                            ; a register AND the carry to another register. What this means, is if
0000F08E                            ; we push 1 into carry (so, carry set), we will be loading $75 instead
0000F08E                            ; of $74 into the carry, making us able to switch between the Z80
0000F08E                            ; instructions  "ld  (hl),h" and "ld  (hl),l", which in turn allows
0000F08E                            ; Dual PCM to bank switch into the appropriate bank.
0000F08E                            ; ---------------------------------------------------------------------------
0000F08E                            
0000F08E                            .loop
0000F08E 7600                       		moveq	#0,d3			; prepare 0 into d3 (because of addx)
0000F090 E248                       		lsr.w	#1,d0			; shift lsb into carry
0000F092 D701                       		addx.b	d1,d3			; add instruction and carry into d3
0000F094                            
0000F094 12C3                       		move.b	d3,(a1)+		; save instruction into Z80 memory
0000F096 51CA FFF6                  		dbf	d2,.loop		; repeat for each bit/instruction
0000F09A                            	StartZ80				; enable Z80 execution
0000F09A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F0A2 4E75                       		rts
0000F0A4                            
0000F0A4                            ; ===========================================================================
0000F0A4                            ; ---------------------------------------------------------------------------
0000F0A4                            ; Routine for resetting master volumes, filters and disabling fading
0000F0A4                            ; ---------------------------------------------------------------------------
0000F0A4                            
0000F0A4                            dResetVolume:
0000F0A4 42B8 C4B4                  		clr.l	mFadeAddr.w		; stop fading program and reset FM master volume
0000F0A8 4238 C4BF                  		clr.b	mMasterVolPSG.w		; reset PSG master volume
0000F0AC 4238 C4C0                  		clr.b	mMasterVolDAC.w		; reset DAC master volume
0000F0B0 303C 0000                  		move.w	#fLog>>$0F,d0		; load value for linear filter
0000F0B4 61BC                       		bsr.s	dSetFilter		; load filter instructions
0000F0B6                            
0000F0B6                            dUpdateVolumeAll:
0000F0B6 6100                       		bsr.s	dReqVolUpFM		; request FM volume update
0000F0B8 8138 C67C                  		or.b	d0,mSFXDAC1.w		; request update for SFX DAC1 channel
0000F0BC                            
0000F0BC =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0000F0BC                            	rept Mus_DAC				; loop through all music DAC channels
0000F0BC                            		or.b	d0,.ch.w		; request channel volume update
0000F0BC                            .ch =		.ch+cSize			; go to next channel
0000F0BC                            	endr
0000F0BC 8138 C4C4                M 	or.b	d0,.ch.w
0000F0C0 =FFFFC4F0                M .ch	=	.ch+csize
0000F0C0 8138 C4F0                M 	or.b	d0,.ch.w
0000F0C4 =FFFFC51C                M .ch	=	.ch+csize
0000F0C4                            
0000F0C4 =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0000F0C4                            	rept Mus_PSG				; loop through all music PSG channels
0000F0C4                            		or.b	d0,.ch.w		; request channel volume update
0000F0C4                            .ch =		.ch+cSize			; go to next channel
0000F0C4                            	endr
0000F0C4 8138 C5F8                M 	or.b	d0,.ch.w
0000F0C8 =FFFFC624                M .ch	=	.ch+csize
0000F0C8 8138 C624                M 	or.b	d0,.ch.w
0000F0CC =FFFFC650                M .ch	=	.ch+csize
0000F0CC 8138 C650                M 	or.b	d0,.ch.w
0000F0D0 =FFFFC67C                M .ch	=	.ch+csize
0000F0D0                            
0000F0D0 =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0000F0D0                            	rept SFX_PSG				; loop through all SFX PSG channels
0000F0D0                            		or.b	d0,.ch.w		; request channel volume update
0000F0D0                            .ch =		.ch+cSizeSFX			; go to next channel
0000F0D0                            	endr
0000F0D0 8138 C6EC                M 	or.b	d0,.ch.w
0000F0D4 =FFFFC708                M .ch	=	.ch+csizesfx
0000F0D4 8138 C708                M 	or.b	d0,.ch.w
0000F0D8 =FFFFC724                M .ch	=	.ch+csizesfx
0000F0D8 8138 C724                M 	or.b	d0,.ch.w
0000F0DC =FFFFC740                M .ch	=	.ch+csizesfx
0000F0DC 4E75                       		rts
0000F0DE                            ; ===========================================================================
0000F0DE                            ; ---------------------------------------------------------------------------
0000F0DE                            ; Enable speed shoes mode
0000F0DE                            ; ---------------------------------------------------------------------------
0000F0DE                            
0000F0DE                            dPlaySnd_ShoesOn:
0000F0DE 11F8 C4B9 C4BB             		move.b	mTempoSpeed.w,mTempoCur.w; set tempo accumulator/counter to speed shoes one
0000F0E4 11F8 C4B9 C4BA             		move.b	mTempoSpeed.w,mTempo.w	; set main tempor to speed shoes one
0000F0EA 08F8 0001 C4A6             		bset	#mfbSpeed,mFlags.w	; enable speed shoes flag
0000F0F0 4E75                       		rts
0000F0F2                            ; ===========================================================================
0000F0F2                            ; ---------------------------------------------------------------------------
0000F0F2                            ; Reset music flags (underwater mode and tempo mode)
0000F0F2                            ; ---------------------------------------------------------------------------
0000F0F2                            
0000F0F2                            dPlaySnd_Reset:
0000F0F2 6100                       		bsr.s	dPlaySnd_OutWater	; gp reset underwater flag and request volume update
0000F0F4                            ; ===========================================================================
0000F0F4                            ; ---------------------------------------------------------------------------
0000F0F4                            ; Disable speed shoes mode
0000F0F4                            ; ---------------------------------------------------------------------------
0000F0F4                            
0000F0F4                            dPlaySnd_ShoesOff:
0000F0F4 11F8 C4B8 C4BB             		move.b	mTempoMain.w,mTempoCur.w; set tempo accumulator/counter to normal one
0000F0FA 11F8 C4B8 C4BA             		move.b	mTempoMain.w,mTempo.w	; set main tempor to normal one
0000F100 08B8 0001 C4A6             		bclr	#mfbSpeed,mFlags.w	; disable speed shoes flag
0000F106 4E75                       		rts
0000F108                            ; ===========================================================================
0000F108                            ; ---------------------------------------------------------------------------
0000F108                            ; Enable Underwater mode
0000F108                            ; ---------------------------------------------------------------------------
0000F108                            
0000F108                            dPlaySnd_ToWater:
0000F108 08F8 0002 C4A6             		bset	#mfbWater,mFlags.w	; enable underwater mode
0000F10E 6000                       		bra.s	dReqVolUpFM		; request FM volume update
0000F110                            ; ===========================================================================
0000F110                            ; ---------------------------------------------------------------------------
0000F110                            ; Disable Underwater mode
0000F110                            ; ---------------------------------------------------------------------------
0000F110                            
0000F110                            dPlaySnd_OutWater:
0000F110 08B8 0002 C4A6             		bclr	#mfbWater,mFlags.w	; disable underwater mode
0000F116                            ; ===========================================================================
0000F116                            ; ---------------------------------------------------------------------------
0000F116                            ; force volume update on all FM channels
0000F116                            ; ---------------------------------------------------------------------------
0000F116                            
0000F116                            dReqVolUpFM;
0000F116 7020                       		moveq	#1<<cfbVol,d0		; prepare volume update flag to d0
0000F118 =FFFFC51C                  .ch =	mFM1					; start at FM1
0000F118                            	rept Mus_FM				; loop through all music FM channels
0000F118                            		or.b	d0,.ch.w		; request channel volume update
0000F118                            .ch =		.ch+cSize			; go to next channel
0000F118                            	endr
0000F118 8138 C51C                M 	or.b	d0,.ch.w
0000F11C =FFFFC548                M .ch	=	.ch+csize
0000F11C 8138 C548                M 	or.b	d0,.ch.w
0000F120 =FFFFC574                M .ch	=	.ch+csize
0000F120 8138 C574                M 	or.b	d0,.ch.w
0000F124 =FFFFC5A0                M .ch	=	.ch+csize
0000F124 8138 C5A0                M 	or.b	d0,.ch.w
0000F128 =FFFFC5CC                M .ch	=	.ch+csize
0000F128 8138 C5CC                M 	or.b	d0,.ch.w
0000F12C =FFFFC5F8                M .ch	=	.ch+csize
0000F12C                            
0000F12C =FFFFC698                  .ch =	mSFXFM3					; start at SFX FM3
0000F12C                            	rept SFX_FM				; loop through all SFX FM channels
0000F12C                            		or.b	d0,.ch.w		; request channel volume update
0000F12C                            .ch =		.ch+cSizeSFX			; go to next channel
0000F12C                            	endr
0000F12C 8138 C698                M 	or.b	d0,.ch.w
0000F130 =FFFFC6B4                M .ch	=	.ch+csizesfx
0000F130 8138 C6B4                M 	or.b	d0,.ch.w
0000F134 =FFFFC6D0                M .ch	=	.ch+csizesfx
0000F134 8138 C6D0                M 	or.b	d0,.ch.w
0000F138 =FFFFC6EC                M .ch	=	.ch+csizesfx
0000F138 4E75                       		rts
0000F13A                            ; ===========================================================================
0000F13A                            ; ---------------------------------------------------------------------------
0000F13A                            ; Subroutine for updating Total Levels for FM channel
0000F13A                            ; ---------------------------------------------------------------------------
0000F13A                            
0000F13A                            dUpdateVolFM:
0000F13A 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000F13E 6600                       		bne.s	locret_VolFM		; if yes, do not update
0000F140                            
0000F140 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0000F144 D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0000F148 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0000F14A 767F                       		moveq	#$7F,d3			; force FM volume to silence
0000F14C                            
0000F14C                            .noover
0000F14C 7000                       		moveq	#0,d0
0000F14E 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0000F152 224E                       		move.l	a6,a1			; copy music voice table address to a1
0000F154                            
0000F154                            	dCALC_VOICE				; get address of the specific voice to a1
0000F154 EB48                     M 	lsl.w	#5,d0
0000F156 D2C0                     M 	add.w	d0,a1
0000F158 1011                       		move.b	(a1),d0			; load algorithm and feedback to d0
0000F15A 7C00                       		moveq	#0,d6			; reset the modulator offset
0000F15C                            
0000F15C 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0000F162 6700                       		beq.s	.uwdone			; if not, skip
0000F164 1C00                       		move.b	d0,d6			; copy algorithm and feedback to d6
0000F166 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0000F16A D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0000F16C 1C00                       		move.b	d0,d6			; set algorithm and feedback to modulator offset
0000F16E                            
0000F16E                            .uwdone
0000F16E 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0000F170 D2FC 0019                  		add.w	#VoiceTL,a1		; go to the Total Level offset of the voice
0000F174 45FA 0000                  		lea	dOpTLFM(pc),a2		; load Total Level address table to a3
0000F178                            
0000F178                            .tlloop
0000F178 101A                       		move.b	(a2)+,d0		; load YM address to write to
0000F17A 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0000F17C 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0000F17E                            
0000F17E D203                       		add.b	d3,d1			; add carrier offset to loaded value
0000F180 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0000F182 727F                       		moveq	#$7F,d1			; cap to silent volume
0000F184 6000                       		bra.s	.slot
0000F186                            
0000F186                            .noslot
0000F186 D206                       		add.b	d6,d1			; add modulator offset to loaded value
0000F188                            .slot
0000F188 4EBA 0000                  		jsr	WriteChYM(pc)		; write Total Level to YM according to channel
0000F18C                            .ignore
0000F18C 51CD FFEA                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0000F190                            
0000F190                            		AMPS_Debug_UpdVolFM		; check if the voice was valid
0000F190 0C19 004E                M 	cmp.b	#'N',(a1)+
0000F194 6600                     M 	bne.s	.fail
0000F196 0C59 4154                M 	cmp.w	#'AT',(a1)+
0000F19A 6700                     M 	beq.s	.ok
0000F19C                          M .fail
0000F19C 4EBA EA80                M 	jsr	amps_debugr_updvolfm
0000F1A0                          M .ok
0000F1A0                            
0000F1A0                            locret_VolFM:
0000F1A0 4E75                       		rts
0000F1A2                            ; ===========================================================================
0000F1A2                            ; ---------------------------------------------------------------------------
0000F1A2                            ; YM2612 register update list
0000F1A2                            ; ---------------------------------------------------------------------------
0000F1A2                            
0000F1A2 3038 343C                  dOpListYM:	dc.b $30, $38, $34, $3C		; Detune, Multiple
0000F1A6 5058 545C                  		dc.b $50, $58, $54, $5C		; Rate Scale, Attack Rate
0000F1AA 6068 646C                  dAMSEn_Ops:	dc.b $60, $68, $64, $6C		; Decay 1 Rate
0000F1AE 7078 747C                  		dc.b $70, $78, $74, $7C		; Decay 2 Rate
0000F1B2 8088 848C                  		dc.b $80, $88, $84, $8C		; Decay 1 level, Release Rate
0000F1B6 9098 949C                  		dc.b $90, $98, $94, $9C		; SSG-EG
0000F1BA 4048 444C                  dOpTLFM:	dc.b $40, $48, $44, $4C		; Total Level
0000F1BE                            ; ===========================================================================
0000F1BE                            ; ---------------------------------------------------------------------------
0000F1BE                            ; Process SFX FM channels
0000F1BE                            ; ---------------------------------------------------------------------------
0000F1BE                            
0000F1BE                            dAMPSdoFMSFX:
0000F1BE 4DFA 0000                  		lea	VoiceBankSFX(pc),a6	; load sound effects voice table into a6
0000F1C2 7E02                       		moveq	#SFX_FM-1,d7		; get total number of SFX FM channels to d7
0000F1C4                            
0000F1C4                            dAMPSnextFMSFX:
0000F1C4 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000F1C8 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000F1CA 6A00 0000                  		bpl.w	.next			; if not, branch
0000F1CE 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000F1D2 6700 0000                  		beq.w	.update			; if timed out, update channel
0000F1D6                            
0000F1D6                            	dCalcFreq				; calculate channel base frequency
0000F1D6 1C2D 0007                M 	move.b	cdetune(a5),d6
0000F1DA 4886                     M 	ext.w	d6
0000F1DC DC6D 000E                M 	add.w	cfreq(a5),d6
0000F1E0                            	dModulate dAMPSdoPSGSFX, dAMPSnextFMSFX, 1; run modulation code
0000F1E0 0815 0003                M 	btst	#cfbmod,(a5)
0000F1E4 6700                     M 	beq.s	.noret
0000F1E6 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000F1EA 6700                     M 	beq.s	.started
0000F1EC 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000F1F0                          M .noret
0000F1F0 0895 0005                M 	bclr	#cfbvol,(a5)
0000F1F4 6700                     M 	beq.s	.noupdatevol
0000F1F6 4EBA FF42                M 	jsr	dupdatevolfm(pc)
0000F1FA                          M 	.noupdatevol:
0000F1FA 51CF FFC8                M 	dbf	d7,dampsnextfmsfx
0000F1FE 6000 0000                M 	bra.w	dampsdopsgsfx
0000F202                          M .started
0000F202 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000F206 66E8                     M 	bne.s	.noret
0000F208 226D 0010                M 	movea.l	cmod(a5),a1
0000F20C 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000F212 4A2D 0018                M 	tst.b	cmodcount(a5)
0000F216 6600                     M 	bne.s	.norev
0000F218 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000F21E 442D 0017                M 	neg.b	cmodstep(a5)
0000F222                          M .norev
0000F222 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000F226 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000F22A 4885                     M 	ext.w	d5
0000F22C DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000F230 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000F234 DC45                     M 	add.w	d5,d6
0000F236 6100 0000                  		bsr.w	dUpdateFreqFM3		; send FM frequency to hardware
0000F23A                            
0000F23A 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F23E 6700                       		beq.s	.next			; if not, skip
0000F240 4EBA FEF8                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F244                            
0000F244                            .next
0000F244 51CF FF7E                  		dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0000F248 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0000F24C                            
0000F24C                            .update
0000F24C 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000F250                            	dDoTracker				; process tracker
0000F250 286D 0002                M 	movea.l	cdata(a5),a4
0000F254                          M 	amps_debug_trackupd
0000F254 220C                     M 	move.l	a4,d1
0000F256 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000F25C 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000F262 6500                     M 	blo.s	.fail2
0000F264 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000F26A 6500                     M 	blo.s	.data
0000F26C                          M .fail2
0000F26C                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F26C 487A FFFE                M 	pea	*(pc)
0000F270                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F270 40E7                     M 	move.w	sr,-(sp)
0000F272                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F272 =00000000                M 	__stack:set	0
0000F272 =00000000                M 	__sp:	set 0
0000F272                          M 	while	(__pos)
0000F272 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F272 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F272 =00000021                M 	__midpos:	= __endpos
0000F272                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272                          M 	pushp	"move.l a4,-(sp)"
0000F272 =00000001                M 	__stack:	= __stack+1
0000F272 =00000004                M 	__sp:	= __sp+4
0000F272 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F272 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F272 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F272 =00000029                M 	__midpos:	= __endpos
0000F272                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F272 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F272 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F272                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F272                          M 	pushp	"move.l a4,-(sp)"
0000F272 =00000002                M 	__stack:	= __stack+1
0000F272 =00000008                M 	__sp:	= __sp+4
0000F272 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F272                          M 	rept	__stack
0000F272                          M 	popp	__command
0000F272 2F0C                     M 	move.l	a4,-(sp)
0000F274                          M 	popp	__command
0000F274 2F0C                     M 	move.l	a4,-(sp)
0000F276 4EB9 0000 0000           M 	jsr	errorhandler
0000F27C                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F27C =00000001                M 	__lpos:	set 1
0000F27C =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F27C                          M 	while	(__pos)
0000F27C                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F27C 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000F295 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F295 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F295 =00000021                M 	__midpos:	= __endpos
0000F295                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F295                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F295                          M 	__param:	substr ,,"hex"
0000F295 83                       M 	dc.b	hex|3
0000F296 =00000022                M 	__lpos:	set __endpos+1
0000F296 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F296                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F296                          M 	dc.b	""
0000F296 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F296 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F296 =00000029                M 	__midpos:	= __endpos
0000F296                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F296                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F296 E0                       M 	dc.b	fendl
0000F297 =0000002A                M 	__lpos:	set __endpos+1
0000F297 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F297                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F297                          M 	dc.b	""
0000F297 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F297 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F297                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F297                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F297 B3                       M 	dc.b	sym|3
0000F298 =00000036                M 	__lpos:	set __endpos+1
0000F298 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F298                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F298                          M 	dc.b	""
0000F298 00                       M 	dc.b	0
0000F299 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F29A                          M 	even
0000F29A 4EFA DC96                M 	jmp	amps_debug_console_channel
0000F29E                          M 	even
0000F29E                          M .data
0000F29E 7A00                     M 	moveq	#0,d5
0000F2A0 1A1C                     M 	move.b	(a4)+,d5
0000F2A2 0C05 00E0                M 	cmpi.b	#$e0,d5
0000F2A6 6500                     M 	blo.s	.notcomm
0000F2A8 4EBA 0000                M 	jsr	dcommands(pc)
0000F2AC 60F0                     M 	bra.s	.data
0000F2AE 6094                     M 	bra.s	.next
0000F2B0                          M .notcomm
0000F2B0 4EBA 0000                  		jsr	dKeyOffFM2(pc)		; send key-off command to YM
0000F2B4 4A05                       		tst.b	d5			; check if note is being played
0000F2B6 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000F2B8                            
0000F2B8 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0000F2BC 1A1C                       		move.b	(a4)+,d5		; check next byte
0000F2BE 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0000F2C0 534C                       		subq.w	#1,a4			; if not, then return back
0000F2C2 6000                       		bra.s	.pcnote			; do some extra clearing
0000F2C4                            
0000F2C4                            .timer
0000F2C4 4EBA F330                  		jsr	dCalcDuration(pc)	; calculate duration
0000F2C8                            .pcnote
0000F2C8                            	dProcNote 1, 0				; reset necessary channel memory
0000F2C8 2B4C 0002                M 	move.l	a4,cdata(a5)
0000F2CC 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000F2D2 0815 0002                M 	btst	#cfbhold,(a5)
0000F2D6 6600                     M 	bne.s	.endpn
0000F2D8 0815 0003                M 	btst	#cfbmod,(a5)
0000F2DC 6700                     M 	beq.s	.endpn
0000F2DE 226D 0010                M 	movea.l	cmod(a5),a1
0000F2E2 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000F2E6 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000F2EA 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000F2EE 1011                     M 	move.b	(a1),d0
0000F2F0 E208                     M 	lsr.b	#1,d0
0000F2F2 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000F2F6 426D 0014                M 	clr.w	cmodfreq(a5)
0000F2FA                          M .endpn
0000F2FA 6100 0000                  		bsr.w	dUpdateFreqFM		; send FM frequency to hardware
0000F2FE                            	dKeyOnFM 1				; send key-on command to YM
0000F2FE 0815 0002                M 	btst	#cfbhold,(a5)
0000F302 6600                     M 	bne.s	.k
0000F304 0815 0000                M 	btst	#cfbrest,(a5)
0000F308 6600                     M 	bne.s	.k
0000F30A 7028                     M 	moveq	#$28,d0
0000F30C 122D 0001                M 	move.b	ctype(a5),d1
0000F310 0001 00F0                M 	ori.b	#$f0,d1
0000F314 6100 0000                M 	bsr.w	writeym_pt1
0000F318                          M .k
0000F318                            
0000F318 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F31C 6700                       		beq.s	.noupdate		; if not, branch
0000F31E 4EBA FE1A                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F322                            
0000F322 51CF FEA0                  .noupdate	dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0000F326 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0000F32A                            ; ===========================================================================
0000F32A                            ; ---------------------------------------------------------------------------
0000F32A                            ; Process music FM channels
0000F32A                            ; ---------------------------------------------------------------------------
0000F32A                            
0000F32A                            dAMPSdoFM:
0000F32A 4DFA 0000                  		lea	VoiceBankMusic(pc),a6	; load music voice table into a6
0000F32E 7E04                       		moveq	#Mus_FM-1,d7		; get total number of music FM channels to d7
0000F330                            
0000F330                            dAMPSnextFM:
0000F330 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel
0000F334 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000F336 6A00 0000                  		bpl.w	.next			; if not, branch
0000F33A 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000F33E 6700 0000                  		beq.w	.update			; if timed out, update channel
0000F342                            
0000F342                            	dNoteToutFM.w				; handle FM-specific note timeout behavior
0000F342                          M 	dnotetouthandler
0000F342 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000F346 6700                     M 	beq.s	.endt
0000F348 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000F34C 6600                     M 	bne.s	.endt
0000F34E 08D5 0000                M 	bset	#cfbrest,(a5)
0000F352 6100 0000                M 	bsr.w	dkeyofffm
0000F356 6000 0000                M 	bra.w	.next
0000F35A                          M .endt
0000F35A                            	dCalcFreq				; calculate channel base frequency
0000F35A 1C2D 0007                M 	move.b	cdetune(a5),d6
0000F35E 4886                     M 	ext.w	d6
0000F360 DC6D 000E                M 	add.w	cfreq(a5),d6
0000F364                            	dModulate dAMPSdoPSG, dAMPSnextFM, 0	; run modulation code
0000F364 0815 0003                M 	btst	#cfbmod,(a5)
0000F368 6700                     M 	beq.s	.noret
0000F36A 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000F36E 6700                     M 	beq.s	.started
0000F370 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000F374                          M .noret
0000F374 0895 0005                M 	bclr	#cfbvol,(a5)
0000F378 6700                     M 	beq.s	.noupdatevol
0000F37A 4EBA FDBE                M 	jsr	dupdatevolfm(pc)
0000F37E                          M 	.noupdatevol:
0000F37E 51CF FFB0                M 	dbf	d7,dampsnextfm
0000F382 6000 0000                M 	bra.w	dampsdopsg
0000F386                          M .started
0000F386 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000F38A 66E8                     M 	bne.s	.noret
0000F38C 226D 0010                M 	movea.l	cmod(a5),a1
0000F390 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000F396 4A2D 0018                M 	tst.b	cmodcount(a5)
0000F39A 6600                     M 	bne.s	.norev
0000F39C 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000F3A2 442D 0017                M 	neg.b	cmodstep(a5)
0000F3A6                          M .norev
0000F3A6 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000F3AA 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000F3AE 4885                     M 	ext.w	d5
0000F3B0 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000F3B4 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000F3B8 DC45                     M 	add.w	d5,d6
0000F3BA 6100 0000                  		bsr.w	dUpdateFreqFM2		; send FM frequency to hardware
0000F3BE                            
0000F3BE 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F3C2 6700                       		beq.s	.next			; if not, skip
0000F3C4 4EBA FD74                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F3C8                            
0000F3C8                            .next
0000F3C8 51CF FF66                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0000F3CC 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0000F3D0                            
0000F3D0                            .update
0000F3D0 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000F3D4                            	dDoTracker				; process tracker
0000F3D4 286D 0002                M 	movea.l	cdata(a5),a4
0000F3D8                          M 	amps_debug_trackupd
0000F3D8 220C                     M 	move.l	a4,d1
0000F3DA 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000F3E0 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000F3E6 6500                     M 	blo.s	.fail2
0000F3E8 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000F3EE 6500                     M 	blo.s	.data
0000F3F0                          M .fail2
0000F3F0                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F3F0 487A FFFE                M 	pea	*(pc)
0000F3F4                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F3F4 40E7                     M 	move.w	sr,-(sp)
0000F3F6                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F3F6 =00000000                M 	__stack:set	0
0000F3F6 =00000000                M 	__sp:	set 0
0000F3F6                          M 	while	(__pos)
0000F3F6 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F3F6 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F3F6 =00000021                M 	__midpos:	= __endpos
0000F3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6                          M 	pushp	"move.l a4,-(sp)"
0000F3F6 =00000001                M 	__stack:	= __stack+1
0000F3F6 =00000004                M 	__sp:	= __sp+4
0000F3F6 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F3F6 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F3F6 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F3F6 =00000029                M 	__midpos:	= __endpos
0000F3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F3F6 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F3F6 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F3F6                          M 	pushp	"move.l a4,-(sp)"
0000F3F6 =00000002                M 	__stack:	= __stack+1
0000F3F6 =00000008                M 	__sp:	= __sp+4
0000F3F6 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F3F6                          M 	rept	__stack
0000F3F6                          M 	popp	__command
0000F3F6 2F0C                     M 	move.l	a4,-(sp)
0000F3F8                          M 	popp	__command
0000F3F8 2F0C                     M 	move.l	a4,-(sp)
0000F3FA 4EB9 0000 0000           M 	jsr	errorhandler
0000F400                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F400 =00000001                M 	__lpos:	set 1
0000F400 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F400                          M 	while	(__pos)
0000F400                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F400 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000F419 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F419 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F419 =00000021                M 	__midpos:	= __endpos
0000F419                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F419                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F419                          M 	__param:	substr ,,"hex"
0000F419 83                       M 	dc.b	hex|3
0000F41A =00000022                M 	__lpos:	set __endpos+1
0000F41A =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F41A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F41A                          M 	dc.b	""
0000F41A =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F41A =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F41A =00000029                M 	__midpos:	= __endpos
0000F41A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F41A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F41A E0                       M 	dc.b	fendl
0000F41B =0000002A                M 	__lpos:	set __endpos+1
0000F41B =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F41B                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F41B                          M 	dc.b	""
0000F41B =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F41B =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F41B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F41B                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F41B B3                       M 	dc.b	sym|3
0000F41C =00000036                M 	__lpos:	set __endpos+1
0000F41C =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F41C                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F41C                          M 	dc.b	""
0000F41C 00                       M 	dc.b	0
0000F41D 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F41E                          M 	even
0000F41E 4EFA DB12                M 	jmp	amps_debug_console_channel
0000F422                          M 	even
0000F422                          M .data
0000F422 7A00                     M 	moveq	#0,d5
0000F424 1A1C                     M 	move.b	(a4)+,d5
0000F426 0C05 00E0                M 	cmpi.b	#$e0,d5
0000F42A 6500                     M 	blo.s	.notcomm
0000F42C 4EBA 0000                M 	jsr	dcommands(pc)
0000F430 60F0                     M 	bra.s	.data
0000F432 6094                     M 	bra.s	.next
0000F434                          M .notcomm
0000F434 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0000F438 4A05                       		tst.b	d5			; check if note is being played
0000F43A 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000F43C                            
0000F43C 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0000F440 1A1C                       		move.b	(a4)+,d5		; check next byte
0000F442 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0000F444 534C                       		subq.w	#1,a4			; if not, then return back
0000F446 6000                       		bra.s	.pcnote			; do some extra clearing
0000F448                            
0000F448                            .timer
0000F448 4EBA F1AC                  		jsr	dCalcDuration(pc)	; calculate duration
0000F44C                            .pcnote
0000F44C                            	dProcNote 0, 0				; reset necessary channel memory
0000F44C 2B4C 0002                M 	move.l	a4,cdata(a5)
0000F450 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000F456 0815 0002                M 	btst	#cfbhold,(a5)
0000F45A 6600                     M 	bne.s	.endpn
0000F45C 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000F462 0815 0003                M 	btst	#cfbmod,(a5)
0000F466 6700                     M 	beq.s	.endpn
0000F468 226D 0010                M 	movea.l	cmod(a5),a1
0000F46C 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000F470 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000F474 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000F478 1011                     M 	move.b	(a1),d0
0000F47A E208                     M 	lsr.b	#1,d0
0000F47C 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000F480 426D 0014                M 	clr.w	cmodfreq(a5)
0000F484                          M .endpn
0000F484 6100                       		bsr.s	dUpdateFreqFM		; send FM frequency to hardware
0000F486                            	dKeyOnFM				; send key-on command to YM
0000F486 0815 0002                M 	btst	#cfbhold,(a5)
0000F48A 6600                     M 	bne.s	.k
0000F48C 0815 0000                M 	btst	#cfbrest,(a5)
0000F490 6600                     M 	bne.s	.k
0000F492 0815 0001                M 	btst	#cfbint,(a5)
0000F496 6600                     M 	bne.s	.k
0000F498 7028                     M 	moveq	#$28,d0
0000F49A 122D 0001                M 	move.b	ctype(a5),d1
0000F49E 0001 00F0                M 	ori.b	#$f0,d1
0000F4A2 6100 0000                M 	bsr.w	writeym_pt1
0000F4A6                          M .k
0000F4A6                            
0000F4A6 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F4AA 6700                       		beq.s	.noupdate		; if not, branch
0000F4AC 4EBA FC8C                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F4B0                            
0000F4B0                            .noupdate
0000F4B0 51CF FE7E                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0000F4B4 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0000F4B8                            ; ===========================================================================
0000F4B8                            ; ---------------------------------------------------------------------------
0000F4B8                            ; Write FM frequency to Dual PCM YMCue
0000F4B8                            ; ---------------------------------------------------------------------------
0000F4B8                            
0000F4B8                            dUpdateFreqFM:
0000F4B8 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0000F4BC 6600                       		bne.s	locret_UpdFreqFM	; if is, skip
0000F4BE 3C2D 000E                  		move.w	cFreq(a5),d6		; load channel base frequency to d6
0000F4C2 6700                       		beq.s	dUpdFreqFMrest		; if 0, this channel should be resting
0000F4C4                            
0000F4C4 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0000F4C8 4880                       		ext.w	d0			; extend to word
0000F4CA DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0000F4CC                            
0000F4CC 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0000F4D0 6700                       		beq.s	dUpdateFreqFM2		; if not, branch
0000F4D2 DC6D 0014                  		add.w	cModFreq(a5),d6		; add channel modulation frequency offset to d6
0000F4D6                            
0000F4D6                            dUpdateFreqFM2:
0000F4D6 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000F4DA 6600                       		bne.s	locret_UpdFreqFM	; if is, do not update frequency anyway
0000F4DC                            
0000F4DC                            dUpdateFreqFM3:
0000F4DC 3206                       		move.w	d6,d1			; copy frequency to d1
0000F4DE E049                       		lsr.w	#8,d1			; shift upper byte into lower byte
0000F4E0 70A4                       		moveq	#$FFFFFFA4,d0		; YM command: Frequency MSB & Octave
0000F4E2 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F4E6                            
0000F4E6 1206                       		move.b	d6,d1			; copy lower byte of frequency into d1 (value)
0000F4E8 103C 00A0                  		move.b	#$FFFFFFA0,d0		; YM command: Frequency LSB
0000F4EC 4EFA 0000                  		jmp	WriteChYM(pc)		; write to YM according to channel
0000F4F0                            
0000F4F0                            dUpdFreqFMrest:
0000F4F0 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0000F4F4                            
0000F4F4                            locret_UpdFreqFM:
0000F4F4 4E75                       		rts
0000F4F6                            ; ===========================================================================
0000F4F6                            ; ---------------------------------------------------------------------------
0000F4F6                            ; Process a note in FM channel (enable resting or get frequency)
0000F4F6                            ; ---------------------------------------------------------------------------
0000F4F6                            
0000F4F6                            dGetFreqFM:
0000F4F6 0405 0080                  		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0000F4FA 6600                       		bne.s	.norest			; branch if note wasnt $80 (rest)
0000F4FC 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0000F500 426D 000E                  		clr.w	cFreq(a5)		; set base frequency to 0
0000F504 4E75                       		rts
0000F506                            
0000F506                            .norest
0000F506 DA2D 0008                  		add.b	cPitch(a5),d5		; add pitch offset to note
0000F50A 0245 007F                  		andi.w	#$7F,d5			; keep within $80 notes
0000F50E DA45                       		add.w	d5,d5			; double offset (each entry is a word)
0000F510                            
0000F510 43FA 0000                  		lea	dFreqFM(pc),a1		; load FM frequency table to a1
0000F514 3B71 5000 000E             		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0000F51A                            
0000F51A                            		AMPS_Debug_NoteFM		; check if the note was valid
0000F51A 0C05 0000                M 	cmp.b	#dfreqfm_-dfreqfm,d5
0000F51E 6500                     M 	blo.s	.ok
0000F520                          M .fail
0000F520 4EBA E6A2                M 	jsr	amps_debugr_notefm
0000F524                          M .ok
0000F524 4E75                       		rts
0000F526                            ; ===========================================================================
0000F526                            ; ---------------------------------------------------------------------------
0000F526                            ; Subroutine for doing keying-off FM channel
0000F526                            ; ---------------------------------------------------------------------------
0000F526                            
0000F526                            dKeyOffFM:
0000F526 0815 0001                  		btst	#cfbInt,(a5)		; check if overridden by sfx
0000F52A 66C8                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0000F52C                            
0000F52C                            dKeyOffFM2:
0000F52C 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0000F530 66C2                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0000F532                            
0000F532 7028                       		moveq	#$28,d0			; YM command: Key on
0000F534 122D 0001                  		move.b	cType(a5),d1		; get channel type bits (and turn all operators off)
0000F538 6000                       		bra.s	WriteYM_Pt1		; write to part 1 channel
0000F53A                            ; ===========================================================================
0000F53A                            ; ---------------------------------------------------------------------------
0000F53A                            ; Write to YMCue according to channel and check if interrupted by sfx
0000F53A                            ; ---------------------------------------------------------------------------
0000F53A                            
0000F53A                            dWriteYMchnInt:
0000F53A 0815 0001                  		btst	#cfbInt,(a5)		; check if interrupted by sfx
0000F53E 6600                       		bne.s	WriteYM_Pt1_rts		; if was, do not note on
0000F540                            ; ===========================================================================
0000F540                            ; ---------------------------------------------------------------------------
0000F540                            ; Write to YMCue according to channel
0000F540                            ; ---------------------------------------------------------------------------
0000F540                            
0000F540                            WriteChYM:
0000F540 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this is a YM part 1 or 2 channel
0000F546 6600                       		bne.s	WriteChYM2		; if part 2, branch
0000F548 D02D 0001                  		add.b	cType(a5),d0		; add channel type to address
0000F54C                            ; ===========================================================================
0000F54C                            ; ---------------------------------------------------------------------------
0000F54C                            ; Write to YMCue using part 1
0000F54C                            ; ---------------------------------------------------------------------------
0000F54C                            
0000F54C                            WriteYM_Pt1:
0000F54C                            		AMPS_Debug_CuePtr 1		; check if cue pointer is valid
0000F54C B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000F552 6500                     M 	blo.s	.fail_648
0000F554 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000F55A 6500                     M 	blo.s	.ok_648
0000F55C                          M .fail_648
0000F55C 4EBA E6F8                M 	jsr	amps_debug_cueptr1
0000F560                          M .ok_648
0000F560                            	StopZ80					; wait for Z80 to stop
0000F560 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F568                          M 	waitz80stop
0000F568 0839 0000 00A1 1100      M .wait_650:	btst	#0,z80_bus_req
0000F570 66F6                     M 	bne.s	.wait_650
0000F572 51D8                       		sf	(a0)+			; set YM port address as 0
0000F574 10C1                       		move.b	d1,(a0)+		; write data value to cue
0000F576 10C0                       		move.b	d0,(a0)+		; write address to cue
0000F578                            	;	st	(a0)			; mark as the end of the cue data
0000F578                            	StartZ80				; enable Z80 execution
0000F578 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F580                            
0000F580                            WriteYM_Pt1_rts:
0000F580 4E75                       		rts
0000F582                            ; ===========================================================================
0000F582                            ; ---------------------------------------------------------------------------
0000F582                            ; Write to YMCue according to channel in part 2
0000F582                            ; ---------------------------------------------------------------------------
0000F582                            
0000F582                            WriteChYM2:
0000F582 142D 0001                  		move.b	cType(a5),d2		; get channel type to d2
0000F586 0882 0002                  		bclr	#ctbPt2,d2		; remove part 2 marker from it
0000F58A D002                       		add.b	d2,d0			; add to YM address
0000F58C                            ; ===========================================================================
0000F58C                            ; ---------------------------------------------------------------------------
0000F58C                            ; Write to YMCue using part 2
0000F58C                            ; ---------------------------------------------------------------------------
0000F58C                            
0000F58C                            WriteYM_Pt2:
0000F58C                            		AMPS_Debug_CuePtr 2		; check if cue pointer is valid
0000F58C B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000F592 6500                     M 	blo.s	.fail_652
0000F594 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000F59A 6500                     M 	blo.s	.ok_652
0000F59C                          M .fail_652
0000F59C 4EBA E6E6                M 	jsr	amps_debug_cueptr2
0000F5A0                          M .ok_652
0000F5A0                            	StopZ80					; wait for Z80 to stop
0000F5A0 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F5A8                          M 	waitz80stop
0000F5A8 0839 0000 00A1 1100      M .wait_654:	btst	#0,z80_bus_req
0000F5B0 66F6                     M 	bne.s	.wait_654
0000F5B2 10FC 0002                  		move.b	#$02,(a0)+		; set YM port address as 2
0000F5B6 10C1                       		move.b	d1,(a0)+		; write data value to cue
0000F5B8 10C0                       		move.b	d0,(a0)+		; write address to cue
0000F5BA                            	;	st	(a0)			; mark as the end of the cue data
0000F5BA                            	StartZ80				; enable Z80 execution
0000F5BA 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F5C2 4E75                       		rts
0000F5C4                            ; ===========================================================================
0000F5C4                            ; ---------------------------------------------------------------------------
0000F5C4                            ; Note to FM frequency conversion table
0000F5C4                            ; ---------------------------------------------------------------------------
0000F5C4                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000F5C4 025E                       dFreqFM:dc.w								       $025E; Octave-1 - (80)
0000F5C6 0284 02AB 02D3 02FE 032D+  	dc.w $0284,$02AB,$02D3,$02FE,$032D,$035C,$038F,$03C5,$03FF,$043C,$047C,$0A5E; Octave 0 - (81 - 8C)
0000F5DE 0A84 0AAB 0AD3 0AFE 0B2D+  	dc.w $0A84,$0AAB,$0AD3,$0AFE,$0B2D,$0B5C,$0B8F,$0BC5,$0BFF,$0C3C,$0C7C,$125E; Octave 1 - (8D - 98)
0000F5F6 1284 12AB 12D3 12FE 132D+  	dc.w $1284,$12AB,$12D3,$12FE,$132D,$135C,$138F,$13C5,$13FF,$143C,$147C,$1A5E; Octave 2 - (99 - A4)
0000F60E 1A84 1AAB 1AD3 1AFE 1B2D+  	dc.w $1A84,$1AAB,$1AD3,$1AFE,$1B2D,$1B5C,$1B8F,$1BC5,$1BFF,$1C3C,$1C7C,$225E; Octave 3 - (A5 - B0)
0000F626 2284 22AB 22D3 22FE 232D+  	dc.w $2284,$22AB,$22D3,$22FE,$232D,$235C,$238F,$23C5,$23FF,$243C,$247C,$2A5E; Octave 4 - (B1 - BC)
0000F63E 2A84 2AAB 2AD3 2AFE 2B2D+  	dc.w $2A84,$2AAB,$2AD3,$2AFE,$2B2D,$2B5C,$2B8F,$2BC5,$2BFF,$2C3C,$2C7C,$325E; Octave 5 - (BD - C8)
0000F656 3284 32AB 32D3 32FE 332D+  	dc.w $3284,$32AB,$32D3,$32FE,$332D,$335C,$338F,$33C5,$33FF,$343C,$347C,$3A5E; Octave 6 - (c9 - D4)
0000F66E 3A84 3AAB 3AD3 3AFE 3B2D+  	dc.w $3A84,$3AAB,$3AD3,$3AFE,$3B2D,$3B5C,$3B8F,$3BC5,$3BFF,$3C3C,$3C7C	    ; Octave 7 - (D5 - DF)
0000F684                            dFreqFM_:
0000F684 =00000160                  .x = $100|((dFreqFM_-dFreqFM)/2)		; to check if we played an invalid note
0000F684                            		rept $80-((dFreqFM_-dFreqFM)/2)	; and if so, tell us which note it was
0000F684                            			dc.w .x
0000F684                            .x =			.x+$101
0000F684                            		endr
0000F684 0160                     M 	dc.w	.x
0000F686 =00000261                M .x	=	.x+$101
0000F686 0261                     M 	dc.w	.x
0000F688 =00000362                M .x	=	.x+$101
0000F688 0362                     M 	dc.w	.x
0000F68A =00000463                M .x	=	.x+$101
0000F68A 0463                     M 	dc.w	.x
0000F68C =00000564                M .x	=	.x+$101
0000F68C 0564                     M 	dc.w	.x
0000F68E =00000665                M .x	=	.x+$101
0000F68E 0665                     M 	dc.w	.x
0000F690 =00000766                M .x	=	.x+$101
0000F690 0766                     M 	dc.w	.x
0000F692 =00000867                M .x	=	.x+$101
0000F692 0867                     M 	dc.w	.x
0000F694 =00000968                M .x	=	.x+$101
0000F694 0968                     M 	dc.w	.x
0000F696 =00000A69                M .x	=	.x+$101
0000F696 0A69                     M 	dc.w	.x
0000F698 =00000B6A                M .x	=	.x+$101
0000F698 0B6A                     M 	dc.w	.x
0000F69A =00000C6B                M .x	=	.x+$101
0000F69A 0C6B                     M 	dc.w	.x
0000F69C =00000D6C                M .x	=	.x+$101
0000F69C 0D6C                     M 	dc.w	.x
0000F69E =00000E6D                M .x	=	.x+$101
0000F69E 0E6D                     M 	dc.w	.x
0000F6A0 =00000F6E                M .x	=	.x+$101
0000F6A0 0F6E                     M 	dc.w	.x
0000F6A2 =0000106F                M .x	=	.x+$101
0000F6A2 106F                     M 	dc.w	.x
0000F6A4 =00001170                M .x	=	.x+$101
0000F6A4 1170                     M 	dc.w	.x
0000F6A6 =00001271                M .x	=	.x+$101
0000F6A6 1271                     M 	dc.w	.x
0000F6A8 =00001372                M .x	=	.x+$101
0000F6A8 1372                     M 	dc.w	.x
0000F6AA =00001473                M .x	=	.x+$101
0000F6AA 1473                     M 	dc.w	.x
0000F6AC =00001574                M .x	=	.x+$101
0000F6AC 1574                     M 	dc.w	.x
0000F6AE =00001675                M .x	=	.x+$101
0000F6AE 1675                     M 	dc.w	.x
0000F6B0 =00001776                M .x	=	.x+$101
0000F6B0 1776                     M 	dc.w	.x
0000F6B2 =00001877                M .x	=	.x+$101
0000F6B2 1877                     M 	dc.w	.x
0000F6B4 =00001978                M .x	=	.x+$101
0000F6B4 1978                     M 	dc.w	.x
0000F6B6 =00001A79                M .x	=	.x+$101
0000F6B6 1A79                     M 	dc.w	.x
0000F6B8 =00001B7A                M .x	=	.x+$101
0000F6B8 1B7A                     M 	dc.w	.x
0000F6BA =00001C7B                M .x	=	.x+$101
0000F6BA 1C7B                     M 	dc.w	.x
0000F6BC =00001D7C                M .x	=	.x+$101
0000F6BC 1D7C                     M 	dc.w	.x
0000F6BE =00001E7D                M .x	=	.x+$101
0000F6BE 1E7D                     M 	dc.w	.x
0000F6C0 =00001F7E                M .x	=	.x+$101
0000F6C0 1F7E                     M 	dc.w	.x
0000F6C2 =0000207F                M .x	=	.x+$101
0000F6C2 207F                     M 	dc.w	.x
0000F6C4 =00002180                M .x	=	.x+$101
0000F6C4                            ; ===========================================================================
0000F6C4                            ; ---------------------------------------------------------------------------
0000F6C4                            ; Note to Dual PCM frequency conversion table
0000F6C4                            ; ---------------------------------------------------------------------------
0000F6C4                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000F6C4 0000                       dFreqDAC:dc.w $0000								    ; Octave NOPE - (80)
0000F6C6 0010 0011 0012 0013 0014+  	dc.w $0010,$0011,$0012,$0013,$0014,$0015,$0017,$0018,$0019,$001B,$001D,$001E; Octave 0 - (81 - 8C)
0000F6DE 0020 0022 0024 0026 0028+  	dc.w $0020,$0022,$0024,$0026,$0028,$002B,$002D,$0030,$0033,$0036,$0039,$003C; Octave 1 - (8D - 98)
0000F6F6 0040 0044 0048 004C 0051+  	dc.w $0040,$0044,$0048,$004C,$0051,$0055,$005B,$0060,$0066,$006C,$0072,$0079; Octave 2 - (99 - A4)
0000F70E 0080 0088 0090 0098 00A1+  	dc.w $0080,$0088,$0090,$0098,$00A1,$00AB,$00B5,$00C0,$00CB,$00D7,$00E4,$00F2; Octave 3 - (A5 - B0)
0000F726 0100 010F 011F 0130 0143+  	dc.w $0100,$010F,$011F,$0130,$0143,$0156,$016A,$0180,$0196,$01AF,$01C8,$01E3; Octave 4 - (B1 - BC)
0000F73E 0200 021E 023F 0261 0285+  	dc.w $0200,$021E,$023F,$0261,$0285,$02AB,$02D4,$02FF,$032D,$035D,$0390,$03C7; Octave 5 - (BD - C8)
0000F756 0400 043D 047D 04C2 050A+  	dc.w $0400,$043D,$047D,$04C2,$050A,$0557,$05A8,$05FE,$0659,$06BA,$0721,$078D; Octave 6 - (C9 - D4)
0000F76E 0800 087A 08FB 0983 0A14+  	dc.w $0800,$087A,$08FB,$0983,$0A14,$0AAE,$0B50,$0BFD,$0CB3,$0D74,$0E41,$0F1A; Octave 7 - (D5 - E0)
0000F786 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 8 - (E1 - EC)
0000F79E 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 9 - (ED - F8)
0000F7B6 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF				    ; Octave 10 -(F9 - FF)
0000F7C4                            
0000F7C4 F001 F001 F001 F001 F001+  	dc.w			     -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -10 -(00 - 07)
0000F7D4 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -9 - (08 - 13)
0000F7EC F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -8 - (14 - 1F)
0000F804 F0E6 F1BF F28C F34D F403+  	dc.w -$F1A,-$E41,-$D74,-$CB3,-$BFD,-$B50,-$AAE,-$A14,-$983,-$8FB,-$87A,-$800; Octave -7 - (20 - 2B)
0000F81C F873 F8DF F946 F9A7 FA02+  	dc.w -$78D,-$721,-$6BA,-$659,-$5FE,-$5A8,-$557,-$50A,-$4C2,-$47D,-$43D,-$400; Octave -6 - (2C - 37)
0000F834 FC39 FC70 FCA3 FCD3 FD01+  	dc.w -$3C7,-$390,-$35D,-$32D,-$2FF,-$2D4,-$2AB,-$285,-$261,-$23F,-$21E,-$200; Octave -5 - (38 - 43)
0000F84C FE1D FE38 FE51 FE6A FE80+  	dc.w -$1E3,-$1C8,-$1AF,-$196,-$180,-$16A,-$156,-$143,-$130,-$11F,-$10F,-$100; Octave -4 - (44 - 4F)
0000F864 FF0E FF1C FF29 FF35 FF40+  	dc.w -$0F2,-$0E4,-$0D7,-$0CB,-$0C0,-$0B5,-$0AB,-$0A1,-$098,-$090,-$088,-$080; Octave -3 - (50 - 5B)
0000F87C FF87 FF8E FF94 FF9A FFA0+  	dc.w -$079,-$072,-$06C,-$066,-$060,-$05B,-$055,-$051,-$04C,-$048,-$044,-$040; Octave -2 - (5C - 67)
0000F894 FFC4 FFC7 FFCA FFCD FFD0+  	dc.w -$03C,-$039,-$036,-$033,-$030,-$02D,-$02B,-$028,-$026,-$024,-$022,-$020; Octave -1 - (68 - 73)
0000F8AC FFE2 FFE3 FFE5 FFE7 FFE8+  	dc.w -$01E,-$01D,-$01B,-$019,-$018,-$017,-$015,-$014,-$013,-$012,-$011,-$010; Octave -0 - (74 - 7F)
0000F8C4                            ; ===========================================================================
0000F8C4                            ; ---------------------------------------------------------------------------
0000F8C4                            ; Note to PSG frequency conversion table
0000F8C4                            ; ---------------------------------------------------------------------------
0000F8C4                            ;	dc.w	C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000F8C4 0356 0326 02F9 02CE 02A5+  dFreqPSG:dc.w $0356,$0326,$02F9,$02CE,$02A5,$0280,$025C,$023A,$021A,$01FB,$01DF,$01C4; Octave 3 - (81 - 8C)
0000F8DC 01AB 0193 017D 0167 0153+  	dc.w  $01AB,$0193,$017D,$0167,$0153,$0140,$012E,$011D,$010D,$00FE,$00EF,$00E2; Octave 4 - (8D - 98)
0000F8F4 00D6 00C9 00BE 00B4 00A9+  	dc.w  $00D6,$00C9,$00BE,$00B4,$00A9,$00A0,$0097,$008F,$0087,$007F,$0078,$0071; Octave 5 - (99 - A4)
0000F90C 006B 0065 005F 005A 0055+  	dc.w  $006B,$0065,$005F,$005A,$0055,$0050,$004B,$0047,$0043,$0040,$003C,$0039; Octave 6 - (A5 - B0)
0000F924 0036 0033 0030 002D 002B+  	dc.w  $0036,$0033,$0030,$002D,$002B,$0028,$0026,$0024,$0022,$0020,$001F,$001D; Octave 7 - (B1 - BC)
0000F93C 001B 001A 0018 0017 0016+  	dc.w  $001B,$001A,$0018,$0017,$0016,$0015,$0013,$0012,$0011		     ; Notes (BD - C5)
0000F94E 0000                       	dc.w  $0000								     ; Note (C6)
0000F950                            dFreqPSG_:
0000F950 =00000146                  .x = $100|((dFreqPSG_-dFreqPSG)/2)		; to check if we played an invalid note
0000F950                            		rept $80-((dFreqPSG_-dFreqPSG)/2); and if so, tell us which note it was
0000F950                            			dc.w .x
0000F950                            .x =			.x+$101
0000F950                            		endr
0000F950 0146                     M 	dc.w	.x
0000F952 =00000247                M .x	=	.x+$101
0000F952 0247                     M 	dc.w	.x
0000F954 =00000348                M .x	=	.x+$101
0000F954 0348                     M 	dc.w	.x
0000F956 =00000449                M .x	=	.x+$101
0000F956 0449                     M 	dc.w	.x
0000F958 =0000054A                M .x	=	.x+$101
0000F958 054A                     M 	dc.w	.x
0000F95A =0000064B                M .x	=	.x+$101
0000F95A 064B                     M 	dc.w	.x
0000F95C =0000074C                M .x	=	.x+$101
0000F95C 074C                     M 	dc.w	.x
0000F95E =0000084D                M .x	=	.x+$101
0000F95E 084D                     M 	dc.w	.x
0000F960 =0000094E                M .x	=	.x+$101
0000F960 094E                     M 	dc.w	.x
0000F962 =00000A4F                M .x	=	.x+$101
0000F962 0A4F                     M 	dc.w	.x
0000F964 =00000B50                M .x	=	.x+$101
0000F964 0B50                     M 	dc.w	.x
0000F966 =00000C51                M .x	=	.x+$101
0000F966 0C51                     M 	dc.w	.x
0000F968 =00000D52                M .x	=	.x+$101
0000F968 0D52                     M 	dc.w	.x
0000F96A =00000E53                M .x	=	.x+$101
0000F96A 0E53                     M 	dc.w	.x
0000F96C =00000F54                M .x	=	.x+$101
0000F96C 0F54                     M 	dc.w	.x
0000F96E =00001055                M .x	=	.x+$101
0000F96E 1055                     M 	dc.w	.x
0000F970 =00001156                M .x	=	.x+$101
0000F970 1156                     M 	dc.w	.x
0000F972 =00001257                M .x	=	.x+$101
0000F972 1257                     M 	dc.w	.x
0000F974 =00001358                M .x	=	.x+$101
0000F974 1358                     M 	dc.w	.x
0000F976 =00001459                M .x	=	.x+$101
0000F976 1459                     M 	dc.w	.x
0000F978 =0000155A                M .x	=	.x+$101
0000F978 155A                     M 	dc.w	.x
0000F97A =0000165B                M .x	=	.x+$101
0000F97A 165B                     M 	dc.w	.x
0000F97C =0000175C                M .x	=	.x+$101
0000F97C 175C                     M 	dc.w	.x
0000F97E =0000185D                M .x	=	.x+$101
0000F97E 185D                     M 	dc.w	.x
0000F980 =0000195E                M .x	=	.x+$101
0000F980 195E                     M 	dc.w	.x
0000F982 =00001A5F                M .x	=	.x+$101
0000F982 1A5F                     M 	dc.w	.x
0000F984 =00001B60                M .x	=	.x+$101
0000F984 1B60                     M 	dc.w	.x
0000F986 =00001C61                M .x	=	.x+$101
0000F986 1C61                     M 	dc.w	.x
0000F988 =00001D62                M .x	=	.x+$101
0000F988 1D62                     M 	dc.w	.x
0000F98A =00001E63                M .x	=	.x+$101
0000F98A 1E63                     M 	dc.w	.x
0000F98C =00001F64                M .x	=	.x+$101
0000F98C 1F64                     M 	dc.w	.x
0000F98E =00002065                M .x	=	.x+$101
0000F98E 2065                     M 	dc.w	.x
0000F990 =00002166                M .x	=	.x+$101
0000F990 2166                     M 	dc.w	.x
0000F992 =00002267                M .x	=	.x+$101
0000F992 2267                     M 	dc.w	.x
0000F994 =00002368                M .x	=	.x+$101
0000F994 2368                     M 	dc.w	.x
0000F996 =00002469                M .x	=	.x+$101
0000F996 2469                     M 	dc.w	.x
0000F998 =0000256A                M .x	=	.x+$101
0000F998 256A                     M 	dc.w	.x
0000F99A =0000266B                M .x	=	.x+$101
0000F99A 266B                     M 	dc.w	.x
0000F99C =0000276C                M .x	=	.x+$101
0000F99C 276C                     M 	dc.w	.x
0000F99E =0000286D                M .x	=	.x+$101
0000F99E 286D                     M 	dc.w	.x
0000F9A0 =0000296E                M .x	=	.x+$101
0000F9A0 296E                     M 	dc.w	.x
0000F9A2 =00002A6F                M .x	=	.x+$101
0000F9A2 2A6F                     M 	dc.w	.x
0000F9A4 =00002B70                M .x	=	.x+$101
0000F9A4 2B70                     M 	dc.w	.x
0000F9A6 =00002C71                M .x	=	.x+$101
0000F9A6 2C71                     M 	dc.w	.x
0000F9A8 =00002D72                M .x	=	.x+$101
0000F9A8 2D72                     M 	dc.w	.x
0000F9AA =00002E73                M .x	=	.x+$101
0000F9AA 2E73                     M 	dc.w	.x
0000F9AC =00002F74                M .x	=	.x+$101
0000F9AC 2F74                     M 	dc.w	.x
0000F9AE =00003075                M .x	=	.x+$101
0000F9AE 3075                     M 	dc.w	.x
0000F9B0 =00003176                M .x	=	.x+$101
0000F9B0 3176                     M 	dc.w	.x
0000F9B2 =00003277                M .x	=	.x+$101
0000F9B2 3277                     M 	dc.w	.x
0000F9B4 =00003378                M .x	=	.x+$101
0000F9B4 3378                     M 	dc.w	.x
0000F9B6 =00003479                M .x	=	.x+$101
0000F9B6 3479                     M 	dc.w	.x
0000F9B8 =0000357A                M .x	=	.x+$101
0000F9B8 357A                     M 	dc.w	.x
0000F9BA =0000367B                M .x	=	.x+$101
0000F9BA 367B                     M 	dc.w	.x
0000F9BC =0000377C                M .x	=	.x+$101
0000F9BC 377C                     M 	dc.w	.x
0000F9BE =0000387D                M .x	=	.x+$101
0000F9BE 387D                     M 	dc.w	.x
0000F9C0 =0000397E                M .x	=	.x+$101
0000F9C0 397E                     M 	dc.w	.x
0000F9C2 =00003A7F                M .x	=	.x+$101
0000F9C2 3A7F                     M 	dc.w	.x
0000F9C4 =00003B80                M .x	=	.x+$101
0000F9C4                            ; ===========================================================================
0000F9C4                            ; ---------------------------------------------------------------------------
0000F9C4                            ; Process SFX PSG channels
0000F9C4                            ; ---------------------------------------------------------------------------
0000F9C4                            
0000F9C4                            dAMPSdoPSGSFX:
0000F9C4 7E02                       		moveq	#SFX_PSG-1,d7		; get total number of SFX PSG channels to d7
0000F9C6 4DFA FEFC                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0000F9CA                            
0000F9CA                            dAMPSnextPSGSFX:
0000F9CA DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000F9CE 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000F9D0 6A00                       		bpl.s	.next			; if not, branch
0000F9D2 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000F9D6 6700 0000                  		beq.w	.update			; if timed out, update channel
0000F9DA                            
0000F9DA                            	dCalcFreq				; calculate channel base frequency
0000F9DA 1C2D 0007                M 	move.b	cdetune(a5),d6
0000F9DE 4886                     M 	ext.w	d6
0000F9E0 DC6D 000E                M 	add.w	cfreq(a5),d6
0000F9E4                            	dModulate				; run modulation code
0000F9E4 0815 0003                M 	btst	#cfbmod,(a5)
0000F9E8 6700                     M 	beq.s	.noret
0000F9EA 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000F9EE 6700                     M 	beq.s	.started
0000F9F0 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000F9F4                          M .noret
0000F9F4 6000                     M 	bra.s	.endm
0000F9F6                          M .started
0000F9F6 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000F9FA 66F8                     M 	bne.s	.noret
0000F9FC 226D 0010                M 	movea.l	cmod(a5),a1
0000FA00 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000FA06 4A2D 0018                M 	tst.b	cmodcount(a5)
0000FA0A 6600                     M 	bne.s	.norev
0000FA0C 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000FA12 442D 0017                M 	neg.b	cmodstep(a5)
0000FA16                          M .norev
0000FA16 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000FA1A 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000FA1E 4885                     M 	ext.w	d5
0000FA20 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000FA24 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000FA28 DC45                     M 	add.w	d5,d6
0000FA2A 6100 0000                  		bsr.w	dUpdateFreqPSG3		; if frequency needs changing, do it
0000FA2E                            
0000FA2E                            .endm
0000FA2E 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0000FA32                            .next
0000FA32 51CF FF96                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0000FA36 4EFA 0000                  		jmp	dCheckTracker(pc)	; after that, check tracker and end loop
0000FA3A                            
0000FA3A                            .update
0000FA3A 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000FA3E                            	dDoTracker				; process tracker
0000FA3E 286D 0002                M 	movea.l	cdata(a5),a4
0000FA42                          M 	amps_debug_trackupd
0000FA42 220C                     M 	move.l	a4,d1
0000FA44 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000FA4A 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000FA50 6500                     M 	blo.s	.fail2
0000FA52 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000FA58 6500                     M 	blo.s	.data
0000FA5A                          M .fail2
0000FA5A                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FA5A 487A FFFE                M 	pea	*(pc)
0000FA5E                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FA5E 40E7                     M 	move.w	sr,-(sp)
0000FA60                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FA60 =00000000                M 	__stack:set	0
0000FA60 =00000000                M 	__sp:	set 0
0000FA60                          M 	while	(__pos)
0000FA60 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FA60 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FA60 =00000021                M 	__midpos:	= __endpos
0000FA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60                          M 	pushp	"move.l a4,-(sp)"
0000FA60 =00000001                M 	__stack:	= __stack+1
0000FA60 =00000004                M 	__sp:	= __sp+4
0000FA60 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FA60 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FA60 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FA60 =00000029                M 	__midpos:	= __endpos
0000FA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FA60 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FA60 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA60                          M 	pushp	"move.l a4,-(sp)"
0000FA60 =00000002                M 	__stack:	= __stack+1
0000FA60 =00000008                M 	__sp:	= __sp+4
0000FA60 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FA60                          M 	rept	__stack
0000FA60                          M 	popp	__command
0000FA60 2F0C                     M 	move.l	a4,-(sp)
0000FA62                          M 	popp	__command
0000FA62 2F0C                     M 	move.l	a4,-(sp)
0000FA64 4EB9 0000 0000           M 	jsr	errorhandler
0000FA6A                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA6A =00000001                M 	__lpos:	set 1
0000FA6A =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FA6A                          M 	while	(__pos)
0000FA6A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA6A 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000FA83 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FA83 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FA83 =00000021                M 	__midpos:	= __endpos
0000FA83                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA83                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA83                          M 	__param:	substr ,,"hex"
0000FA83 83                       M 	dc.b	hex|3
0000FA84 =00000022                M 	__lpos:	set __endpos+1
0000FA84 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FA84                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA84                          M 	dc.b	""
0000FA84 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FA84 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FA84 =00000029                M 	__midpos:	= __endpos
0000FA84                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA84                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA84 E0                       M 	dc.b	fendl
0000FA85 =0000002A                M 	__lpos:	set __endpos+1
0000FA85 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FA85                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA85                          M 	dc.b	""
0000FA85 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FA85 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FA85                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA85                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA85 B3                       M 	dc.b	sym|3
0000FA86 =00000036                M 	__lpos:	set __endpos+1
0000FA86 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FA86                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FA86                          M 	dc.b	""
0000FA86 00                       M 	dc.b	0
0000FA87 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000FA88                          M 	even
0000FA88 4EFA D4A8                M 	jmp	amps_debug_console_channel
0000FA8C                          M 	even
0000FA8C                          M .data
0000FA8C 7A00                     M 	moveq	#0,d5
0000FA8E 1A1C                     M 	move.b	(a4)+,d5
0000FA90 0C05 00E0                M 	cmpi.b	#$e0,d5
0000FA94 6500                     M 	blo.s	.notcomm
0000FA96 4EBA 0000                M 	jsr	dcommands(pc)
0000FA9A 60F0                     M 	bra.s	.data
0000FA9C 6094                     M 	bra.s	.next
0000FA9E                          M .notcomm
0000FA9E 4A05                       		tst.b	d5			; check if note is being played
0000FAA0 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000FAA2                            
0000FAA2                            	dGetFreqPSG				; get PSG frequency
0000FAA2 0405 0081                M 	subi.b	#$81,d5
0000FAA6 6400                     M 	bhs.s	.norest
0000FAA8 08D5 0000                M 	bset	#cfbrest,(a5)
0000FAAC 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0000FAB2 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0000FAB6 6000                     M 	bra.s	.freqgot
0000FAB8                          M .norest
0000FAB8 DA2D 0008                M 	add.b	cpitch(a5),d5
0000FABC 0245 007F                M 	andi.w	#$7f,d5
0000FAC0 DA45                     M 	add.w	d5,d5
0000FAC2 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0000FAC8                          M 	amps_debug_notepsg
0000FAC8 0C05 008C                M 	cmp.b	#dfreqpsg_-dfreqpsg,d5
0000FACC 6500                     M 	blo.s	.ok
0000FACE                          M .fail
0000FACE 4EBA E0CA                M 	jsr	amps_debugr_notepsg
0000FAD2                          M .ok
0000FAD2                          M .freqgot
0000FAD2 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000FAD4 6A00                       		bpl.s	.timer			; if yes, handle timer
0000FAD6 534C                       		subq.w	#1,a4			; else, undo the increment
0000FAD8 6000                       		bra.s	.pcnote			; do not calculate duration
0000FADA                            
0000FADA                            .timer
0000FADA 4EBA EB1A                  		jsr	dCalcDuration(pc)	; calculate duration
0000FADE                            .pcnote
0000FADE                            	dProcNote 1, 1				; reset necessary channel memory
0000FADE 2B4C 0002                M 	move.l	a4,cdata(a5)
0000FAE2 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000FAE8 0815 0002                M 	btst	#cfbhold,(a5)
0000FAEC 6600                     M 	bne.s	.endpn
0000FAEE 422D 0006                M 	clr.b	cenvpos(a5)
0000FAF2 0815 0003                M 	btst	#cfbmod,(a5)
0000FAF6 6700                     M 	beq.s	.endpn
0000FAF8 226D 0010                M 	movea.l	cmod(a5),a1
0000FAFC 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000FB00 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000FB04 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000FB08 1011                     M 	move.b	(a1),d0
0000FB0A E208                     M 	lsr.b	#1,d0
0000FB0C 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000FB10 426D 0014                M 	clr.w	cmodfreq(a5)
0000FB14                          M .endpn
0000FB14                            
0000FB14 6100 0000                  		bsr.w	dUpdateFreqPSG		; update hardware frequency
0000FB18 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0000FB1C 51CF FEAC                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0000FB20                            	; continue to check tracker and end loop
0000FB20                            ; ===========================================================================
0000FB20                            ; ---------------------------------------------------------------------------
0000FB20                            ; End channel loop and check if tracker debugger should be opened
0000FB20                            ; ---------------------------------------------------------------------------
0000FB20                            
0000FB20                            dCheckTracker:
0000FB20 4A38 C740                  		tst.b	msChktracker.w		; check if tracker debugger flag was set
0000FB24 6700                       		beq.s	.rts			; if not, skip
0000FB26 4238 C740                  		clr.b	msChktracker.w		; clear that flag
0000FB2A                            		AMPS_Debug_ChkTracker		; run debugger
0000FB2A                          M .fail
0000FB2A 4EBA E1E0                M 	jsr	amps_debugr_chktracker
0000FB2E                            .rts
0000FB2E 4E75                       		rts
0000FB30                            ; ===========================================================================
0000FB30                            ; ---------------------------------------------------------------------------
0000FB30                            ; Music PSG channel loop
0000FB30                            ; ---------------------------------------------------------------------------
0000FB30                            
0000FB30                            dAMPSdoPSG:
0000FB30 7E02                       		moveq	#Mus_PSG-1,d7		; get total number of music PSG channels to d7
0000FB32 4DFA FD90                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0000FB36                            
0000FB36                            dAMPSnextPSG:
0000FB36 DAFC 002C                  		add.w	#cSize,a5		; go to the next channe
0000FB3A 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000FB3C 6A00 0000                  		bpl.w	.next			; if not, branch
0000FB40 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000FB44 6700 0000                  		beq.w	.update			; if timed out, update channel
0000FB48                            
0000FB48                            	dNoteToutPSG				; handle PSG-specific note timeout behavior
0000FB48                          M 	dnotetouthandler
0000FB48 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000FB4C 6700                     M 	beq.s	.endt
0000FB4E 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000FB52 6600                     M 	bne.s	.endt
0000FB54 08D5 0000                M 	bset	#cfbrest,(a5)
0000FB58 6100 0000                M 	bsr.w	dmutepsgmus
0000FB5C 6000                     M 	bra.s	.next
0000FB5E                          M .endt
0000FB5E                            	dCalcFreq				; calculate channel base frequency
0000FB5E 1C2D 0007                M 	move.b	cdetune(a5),d6
0000FB62 4886                     M 	ext.w	d6
0000FB64 DC6D 000E                M 	add.w	cfreq(a5),d6
0000FB68                            	dModulate				; run modulation code
0000FB68 0815 0003                M 	btst	#cfbmod,(a5)
0000FB6C 6700                     M 	beq.s	.noret
0000FB6E 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000FB72 6700                     M 	beq.s	.started
0000FB74 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000FB78                          M .noret
0000FB78 6000                     M 	bra.s	.endm
0000FB7A                          M .started
0000FB7A 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000FB7E 66F8                     M 	bne.s	.noret
0000FB80 226D 0010                M 	movea.l	cmod(a5),a1
0000FB84 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000FB8A 4A2D 0018                M 	tst.b	cmodcount(a5)
0000FB8E 6600                     M 	bne.s	.norev
0000FB90 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000FB96 442D 0017                M 	neg.b	cmodstep(a5)
0000FB9A                          M .norev
0000FB9A 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000FB9E 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000FBA2 4885                     M 	ext.w	d5
0000FBA4 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000FBA8 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000FBAC DC45                     M 	add.w	d5,d6
0000FBAE 6100 0000                  		bsr.w	dUpdateFreqPSG2		; if frequency needs changing, do it
0000FBB2                            
0000FBB2                            .endm
0000FBB2 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0000FBB6                            .next
0000FBB6 51CF FF7E                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0000FBBA 4EFA EA52                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0000FBBE                            
0000FBBE                            .update
0000FBBE 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000FBC2                            	dDoTracker				; process tracker
0000FBC2 286D 0002                M 	movea.l	cdata(a5),a4
0000FBC6                          M 	amps_debug_trackupd
0000FBC6 220C                     M 	move.l	a4,d1
0000FBC8 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000FBCE 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000FBD4 6500                     M 	blo.s	.fail2
0000FBD6 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000FBDC 6500                     M 	blo.s	.data
0000FBDE                          M .fail2
0000FBDE                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FBDE 487A FFFE                M 	pea	*(pc)
0000FBE2                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FBE2 40E7                     M 	move.w	sr,-(sp)
0000FBE4                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FBE4 =00000000                M 	__stack:set	0
0000FBE4 =00000000                M 	__sp:	set 0
0000FBE4                          M 	while	(__pos)
0000FBE4 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FBE4 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FBE4 =00000021                M 	__midpos:	= __endpos
0000FBE4                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4                          M 	pushp	"move.l a4,-(sp)"
0000FBE4 =00000001                M 	__stack:	= __stack+1
0000FBE4 =00000004                M 	__sp:	= __sp+4
0000FBE4 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FBE4 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FBE4 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FBE4 =00000029                M 	__midpos:	= __endpos
0000FBE4                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FBE4 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FBE4 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FBE4                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBE4                          M 	pushp	"move.l a4,-(sp)"
0000FBE4 =00000002                M 	__stack:	= __stack+1
0000FBE4 =00000008                M 	__sp:	= __sp+4
0000FBE4 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FBE4                          M 	rept	__stack
0000FBE4                          M 	popp	__command
0000FBE4 2F0C                     M 	move.l	a4,-(sp)
0000FBE6                          M 	popp	__command
0000FBE6 2F0C                     M 	move.l	a4,-(sp)
0000FBE8 4EB9 0000 0000           M 	jsr	errorhandler
0000FBEE                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBEE =00000001                M 	__lpos:	set 1
0000FBEE =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FBEE                          M 	while	(__pos)
0000FBEE                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FBEE 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000FC07 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FC07 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FC07 =00000021                M 	__midpos:	= __endpos
0000FC07                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FC07                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FC07                          M 	__param:	substr ,,"hex"
0000FC07 83                       M 	dc.b	hex|3
0000FC08 =00000022                M 	__lpos:	set __endpos+1
0000FC08 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FC08                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FC08                          M 	dc.b	""
0000FC08 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FC08 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FC08 =00000029                M 	__midpos:	= __endpos
0000FC08                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FC08                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FC08 E0                       M 	dc.b	fendl
0000FC09 =0000002A                M 	__lpos:	set __endpos+1
0000FC09 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FC09                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FC09                          M 	dc.b	""
0000FC09 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FC09 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FC09                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FC09                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FC09 B3                       M 	dc.b	sym|3
0000FC0A =00000036                M 	__lpos:	set __endpos+1
0000FC0A =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FC0A                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FC0A                          M 	dc.b	""
0000FC0A 00                       M 	dc.b	0
0000FC0B 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000FC0C                          M 	even
0000FC0C 4EFA D324                M 	jmp	amps_debug_console_channel
0000FC10                          M 	even
0000FC10                          M .data
0000FC10 7A00                     M 	moveq	#0,d5
0000FC12 1A1C                     M 	move.b	(a4)+,d5
0000FC14 0C05 00E0                M 	cmpi.b	#$e0,d5
0000FC18 6500                     M 	blo.s	.notcomm
0000FC1A 4EBA 0000                M 	jsr	dcommands(pc)
0000FC1E 60F0                     M 	bra.s	.data
0000FC20 6094                     M 	bra.s	.next
0000FC22                          M .notcomm
0000FC22 4A05                       		tst.b	d5			; check if note is being played
0000FC24 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000FC26                            
0000FC26                            	dGetFreqPSG				; get PSG frequency
0000FC26 0405 0081                M 	subi.b	#$81,d5
0000FC2A 6400                     M 	bhs.s	.norest
0000FC2C 08D5 0000                M 	bset	#cfbrest,(a5)
0000FC30 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0000FC36 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0000FC3A 6000                     M 	bra.s	.freqgot
0000FC3C                          M .norest
0000FC3C DA2D 0008                M 	add.b	cpitch(a5),d5
0000FC40 0245 007F                M 	andi.w	#$7f,d5
0000FC44 DA45                     M 	add.w	d5,d5
0000FC46 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0000FC4C                          M 	amps_debug_notepsg
0000FC4C 0C05 008C                M 	cmp.b	#dfreqpsg_-dfreqpsg,d5
0000FC50 6500                     M 	blo.s	.ok
0000FC52                          M .fail
0000FC52 4EBA DF46                M 	jsr	amps_debugr_notepsg
0000FC56                          M .ok
0000FC56                          M .freqgot
0000FC56 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000FC58 6A00                       		bpl.s	.timer			; if yes, handle timer
0000FC5A 534C                       		subq.w	#1,a4			; else, undo the increment
0000FC5C 6000                       		bra.s	.pcnote			; do not calculate duration
0000FC5E                            
0000FC5E                            .timer
0000FC5E 4EBA E996                  		jsr	dCalcDuration(pc)	; calculate duration
0000FC62                            .pcnote
0000FC62                            	dProcNote 0, 1				; reset necessary channel memory
0000FC62 2B4C 0002                M 	move.l	a4,cdata(a5)
0000FC66 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000FC6C 0815 0002                M 	btst	#cfbhold,(a5)
0000FC70 6600                     M 	bne.s	.endpn
0000FC72 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000FC78 422D 0006                M 	clr.b	cenvpos(a5)
0000FC7C 0815 0003                M 	btst	#cfbmod,(a5)
0000FC80 6700                     M 	beq.s	.endpn
0000FC82 226D 0010                M 	movea.l	cmod(a5),a1
0000FC86 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000FC8A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000FC8E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000FC92 1011                     M 	move.b	(a1),d0
0000FC94 E208                     M 	lsr.b	#1,d0
0000FC96 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000FC9A 426D 0014                M 	clr.w	cmodfreq(a5)
0000FC9E                          M .endpn
0000FC9E                            
0000FC9E 6100                       		bsr.s	dUpdateFreqPSG		; update hardware frequency
0000FCA0 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0000FCA4 51CF FE90                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0000FCA8 4EFA E964                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0000FCAC                            ; ===========================================================================
0000FCAC                            ; ---------------------------------------------------------------------------
0000FCAC                            ; Write PSG frequency to hardware
0000FCAC                            ; ---------------------------------------------------------------------------
0000FCAC                            
0000FCAC                            dUpdateFreqPSG:
0000FCAC 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0000FCB0 6A00                       		bpl.s	.detune			; if it was not rest frequency, branch
0000FCB2 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0000FCB6 4E75                       		rts
0000FCB8                            
0000FCB8                            .detune
0000FCB8 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0000FCBC 4880                       		ext.w	d0			; extend to word
0000FCBE DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0000FCC0                            
0000FCC0 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0000FCC4 6700                       		beq.s	dUpdateFreqPSG2		; if not, branch
0000FCC6 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0000FCCA                            
0000FCCA                            dUpdateFreqPSG2:
0000FCCA 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0000FCCE 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0000FCD0                            
0000FCD0                            dUpdateFreqPSG3:
0000FCD0 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0000FCD4 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0000FCD6                            
0000FCD6 102D 0001                  		move.b	cType(a5),d0		; load channel type value to d0
0000FCDA 0C00 00E0                  		cmpi.b	#ctPSG4,d0		; check if this channel is in PSG4 mode
0000FCDE 6600                       		bne.s	.notPSG4		; if not, branch
0000FCE0 70C0                       		moveq	#$FFFFFF00|ctPSG3,d0	; load PSG3 type value instead
0000FCE2                            
0000FCE2                            .notPSG4
0000FCE2 3206                       		move.w	d6,d1			; copy frequency to d1
0000FCE4 0201 000F                  		andi.b	#$F,d1			; get the low nibble of it
0000FCE8 8001                       		or.b	d1,d0			; combine with channel type
0000FCEA                            ; ---------------------------------------------------------------------------
0000FCEA                            ; Note about the and instruction below: If this instruction is
0000FCEA                            ; not commented out, the instashield SFX will not sound correct.
0000FCEA                            ; This instruction was removed in Sonic 3K because of this, but
0000FCEA                            ; this can cause issues when values overflow the valid range of
0000FCEA                            ; PSG frequency. This may cause erroneous behavior if not anded,
0000FCEA                            ; but will also make the instashield SFX not sound correctly.
0000FCEA                            ; Comment out the instruction with caution, if you are planning
0000FCEA                            ; to port said sound effect to this driver. This has not caused
0000FCEA                            ; any issues for me, and if you are careful you can avoid any
0000FCEA                            ; such case, but beware of this issue!
0000FCEA                            ; ---------------------------------------------------------------------------
0000FCEA                            
0000FCEA E84E                       		lsr.w	#4,d6			; get the 2 higher nibbles of frequency
0000FCEC 0206 003F                  		andi.b	#$3F,d6			; clear any extra bits that aren't valid
0000FCF0 13C0 00C0 0011             		move.b	d0,dPSG			; write frequency low nibble and latch channel
0000FCF6 13C6 00C0 0011             		move.b	d6,dPSG			; write frequency high nibbles to PSG
0000FCFC                            
0000FCFC                            locret_dUpdateFreqPSG:
0000FCFC 4E75                       		rts
0000FCFE                            ; ===========================================================================
0000FCFE                            ; ---------------------------------------------------------------------------
0000FCFE                            ; Routine for running envelope programs
0000FCFE                            ; ---------------------------------------------------------------------------
0000FCFE                            
0000FCFE                            dEnvProgPSG:
0000FCFE 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0000FD02 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0000FD06                            
0000FD06 7800                       		moveq	#0,d4
0000FD08 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0000FD0C 6700                       		beq.s	dUpdateVolPSG2		; if 0, update volume only
0000FD0E 6000                       		bra.s	dEnvProgPSG2		; continue to run code below
0000FD10                            
0000FD10                            dEnvelopePSG:
0000FD10 7800                       		moveq	#0,d4
0000FD12 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0000FD16 6700                       		beq.s	locret_UpdVolPSG	; if 0, return
0000FD18                            
0000FD18 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0000FD1C DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0000FD20                            
0000FD20                            dEnvProgPSG2:
0000FD20                            		AMPS_Debug_VolEnvID		; check if volume envelope ID is valid
0000FD20 0C04 0000                M 	cmp.b	#(volenvs_end-volenvs)/4,d4
0000FD24 6300                     M 	bls.s	.ok
0000FD26 4EBA DE3C                M 	jsr	amps_debugr_volenvid
0000FD2A                          M .ok
0000FD2A                            
0000FD2A 43FA 0000                  		lea	VolEnvs-4(pc),a1	; load volume envelope data array
0000FD2E D844                       		add.w	d4,d4			; quadruple volume envelope ID
0000FD30 D844                       		add.w	d4,d4			; (each entry is 4 bytes in size)
0000FD32 2271 4000                  		move.l	(a1,d4.w),a1		; get pointer to volume envelope data
0000FD36                            
0000FD36 7200                       		moveq	#0,d1
0000FD38 7000                       		moveq	#0,d0
0000FD3A                            
0000FD3A                            dEnvProgPSG3:
0000FD3A 122D 0006                  		move.b	cEnvPos(a5),d1		; get envelope position to d1
0000FD3E 1031 1000                  		move.b	(a1,d1.w),d0		; get the date in that position
0000FD42 6B00                       		bmi.s	dEnvCommand		; if it is a command, handle it
0000FD44                            
0000FD44 522D 0006                  		addq.b	#1,cEnvPos(a5)		; increment envelope position
0000FD48 DA00                       		add.b	d0,d5			; add envelope volume to d5
0000FD4A                            	; continue to update PSG volume
0000FD4A                            ; ===========================================================================
0000FD4A                            ; ---------------------------------------------------------------------------
0000FD4A                            ; Routine for updating PSG volume to hardware
0000FD4A                            ; ---------------------------------------------------------------------------
0000FD4A                            
0000FD4A                            dUpdateVolPSG2:
0000FD4A 0C05 000F                  		cmpi.b	#$F,d5			; check if volume is out of range
0000FD4E 6300                       		bls.s	dUpdateVolPSG		; if not, branch
0000FD50 7A0F                       		moveq	#$F,d5			; cap volume to silent
0000FD52                            
0000FD52                            dUpdateVolPSG:
0000FD52 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0000FD56 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0000FD58 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0000FD5C 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0000FD5E                            
0000FD5E 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0000FD62 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0000FD64 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this is a SFX channel
0000FD68 6400                       		bhs.s	dUpdVolPSGset		; if so, update volume
0000FD6A                            
0000FD6A 4A2D 001D                  		tst.b	cNoteTimeMain(a5)	; check if note timeout is active
0000FD6E 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0000FD70 4A2D 001C                  		tst.b	cNoteTimeCur(a5)	; is note stopped already?
0000FD74 6700                       		beq.s	locret_UpdVolPSG	; if is, do not update
0000FD76                            
0000FD76                            dUpdVolPSGset:
0000FD76 8A2D 0001                  		or.b	cType(a5),d5		; combine channel type value with volume
0000FD7A 0605 0010                  		addi.b	#$10,d5			; set volume update bit
0000FD7E 13C5 00C0 0011             		move.b	d5,dPSG			; write volume command to PSG port
0000FD84                            
0000FD84                            locret_UpdVolPSG:
0000FD84 4E75                       		rts
0000FD86                            ; ===========================================================================
0000FD86                            ; ---------------------------------------------------------------------------
0000FD86                            ; Subroutine for handling volume envelope commands
0000FD86                            ; ---------------------------------------------------------------------------
0000FD86                            
0000FD86                            dEnvCommand:
0000FD86                            		AMPS_Debug_VolEnvCmd		; check if command is valid
0000FD86 0C00 0088                M 	cmp.b	#elast,d0
0000FD8A 6400                     M 	bhs.s	.fail
0000FD8C 0C00 0080                M 	cmp.b	#$80,d0
0000FD90 6500                     M 	blo.s	.fail
0000FD92 0800 0000                M 	btst	#0,d0
0000FD96 6700                     M 	beq.s	.ok
0000FD98                          M .fail
0000FD98                          M 	raiseerror2	"Volume envelope command invalid: %<.b d0>",amps_debug_console_channel
0000FD98 40E7                     M 	move.w	sr,-(sp)
0000FD9A                          M 	__fstring_generateargumentscode	"Volume envelope command invalid: %<.b d0>"
0000FD9A =00000022                M 	__pos:	set instr("Volume envelope command invalid: %<.b d0>",'%<')
0000FD9A =00000000                M 	__stack:set	0
0000FD9A =00000000                M 	__sp:	set 0
0000FD9A                          M 	while	(__pos)
0000FD9A =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'>')
0000FD9A =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope command invalid: %<.b d0>",' ')
0000FD9A =00000029                M 	__midpos:	= __endpos
0000FD9A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
0000FD9A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope command invalid: %<.b d0>"
0000FD9A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Volume envelope command invalid: %<.b d0>"
0000FD9A                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
0000FD9A                          M 	pushp	"move.b d0,1(sp)"
0000FD9A                          M 	pushp	"subq.w	#2, sp"
0000FD9A =00000002                M 	__stack:	= __stack+2
0000FD9A =00000002                M 	__sp:	= __sp+2
0000FD9A =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'%<')
0000FD9A                          M 	rept	__stack
0000FD9A                          M 	popp	__command
0000FD9A 554F                     M 	subq.w	#2,sp
0000FD9C                          M 	popp	__command
0000FD9C 1F40 0001                M 	move.b	d0,1(sp)
0000FDA0 4EB9 0000 0000           M 	jsr	errorhandler
0000FDA6                          M 	__fstring_generatedecodedstring	"Volume envelope command invalid: %<.b d0>"
0000FDA6 =00000001                M 	__lpos:	set 1
0000FDA6 =00000022                M 	__pos:	set instr("Volume envelope command invalid: %<.b d0>",'%<')
0000FDA6                          M 	while	(__pos)
0000FDA6                          M 	__substr:	substr __lpos,__pos-1,"Volume envelope command invalid: %<.b d0>"
0000FDA6 566F 6C75 6D65 2065 6E76+M 	dc.b	"Volume envelope command invalid: "
0000FDC7 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'>')
0000FDC7 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope command invalid: %<.b d0>",' ')
0000FDC7 =00000029                M 	__midpos:	= __endpos
0000FDC7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope command invalid: %<.b d0>"
0000FDC7                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
0000FDC7                          M 	__param:	substr ,,"hex"
0000FDC7 80                       M 	dc.b	hex
0000FDC8 =0000002A                M 	__lpos:	set __endpos+1
0000FDC8 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'%<')
0000FDC8                          M 	__substr:	substr __lpos,,"Volume envelope command invalid: %<.b d0>"
0000FDC8                          M 	dc.b	""
0000FDC8 00                       M 	dc.b	0
0000FDC9 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000FDCA                          M 	even
0000FDCA 4EFA D166                M 	jmp	amps_debug_console_channel
0000FDCE                          M 	even
0000FDCE                          M .ok
0000FDCE                            
0000FDCE 4EFB 0000                  		jmp	.comm-$80(pc,d0.w)	; jump to command handler
0000FDD2                            
0000FDD2                            .comm
0000FDD2 6000                       		bra.s	.reset			; 80 - Loop back to beginning
0000FDD4 6000                       		bra.s	.hold			; 82 - Hold the envelope at current level
0000FDD6 6000                       		bra.s	.loop			; 84 - Go to position defined by the next byte
0000FDD8                            	;	bra.s	.stop			; 86 - Stop current note and envelope
0000FDD8                            ; ---------------------------------------------------------------------------
0000FDD8                            
0000FDD8                            .stop
0000FDD8 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting bit
0000FDDC 6000                       		bra.s	dMutePSGmus		; nute the channel
0000FDDE                            ; ---------------------------------------------------------------------------
0000FDDE                            
0000FDDE                            .hold
0000FDDE 532D 0006                  		subq.b	#1,cEnvPos(a5)		; decrease envelope position
0000FDE2 4EFA FF56                  		jmp	dEnvProgPSG3(pc)	; run the program again (make sure volume fades work)
0000FDE6                            ; ---------------------------------------------------------------------------
0000FDE6                            
0000FDE6                            .reset
0000FDE6 422D 0006                  		clr.b	cEnvPos(a5)		; set envelope position to 0
0000FDEA 4EFA FF4E                  		jmp	dEnvProgPSG3(pc)	; run the program again
0000FDEE                            ; ---------------------------------------------------------------------------
0000FDEE                            
0000FDEE                            .loop
0000FDEE 1B71 1001 0006             		move.b	1(a1,d1.w),cEnvPos(a5)	; set envelope position to the next byte
0000FDF4 4EFA FF44                  		jmp	dEnvProgPSG3(pc)	; run the program again
0000FDF8                            ; ===========================================================================
0000FDF8                            ; ---------------------------------------------------------------------------
0000FDF8                            ; Routine for hardware muting a PSG channel
0000FDF8                            ; ---------------------------------------------------------------------------
0000FDF8                            
0000FDF8                            dMutePSGmus:
0000FDF8 0815 0001                  		btst	#cfbInt,(a5)		; check if this is a SFX channel
0000FDFC 6600                       		bne.s	locret_MutePSG		; if yes, do not update
0000FDFE                            
0000FDFE                            dMutePSGsfx:
0000FDFE 701F                       		moveq	#$1F,d0			; prepare volume update to mute value to d0
0000FE00 802D 0001                  		or.b	cType(a5),d0		; combine channel type value with d0
0000FE04 13C0 00C0 0011             		move.b	d0,dPSG			; write volume command to PSG port
0000FE0A                            
0000FE0A                            locret_MutePSG:
0000FE0A 4E75                       		rts
0000FE0C                            
0000FE0C 414D 5053 2031 2E30        	dc.b "AMPS 1.0"				; not required, just here to make my life easier
0000FE14                            ; ===========================================================================
0000FE14                            ; ---------------------------------------------------------------------------
0000FE14                            ; Routine to execute tracker commands
0000FE14                            ;
0000FE14                            ; The reason we use add.b instead of add.w, is to get rid of some bits that
0000FE14                            ; would make this kind of arbitary jumping way more complex than it needs to be.
0000FE14                            ; What do we win by doing this? Why, 8 cycles per command! Thats... Not a lot,
0000FE14                            ; but it may be helpful with speed anyway.
0000FE14                            ; ---------------------------------------------------------------------------
0000FE14                            
0000FE14                            dCommands:
0000FE14 DA05                       		add.b	d5,d5			; quadruple command ID
0000FE16 DA05                       		add.b	d5,d5			; since each entry is 4 bytes large
0000FE18                            
0000FE18 0815 0004                  		btst	#cfbCond,(a5)		; check if condition state
0000FE1C 6600 0000                  		bne.w	.falsecomm		; branch if false
0000FE20 4EFB 5000                  		jmp	.comm-$80(pc,d5.w)	; jump to appropriate handler
0000FE24                            ; ===========================================================================
0000FE24                            ; ---------------------------------------------------------------------------
0000FE24                            ; Command handlers for normal execution
0000FE24                            ; ---------------------------------------------------------------------------
0000FE24                            
0000FE24                            .comm
0000FE24 6000 0000                  	bra.w	dcPan		; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0000FE28 6000 0000                  	bra.w	dcsDetune	; E1 - Set channel frequency displacement to xx (DETUNE_SET)
0000FE2C 6000 0000                  	bra.w	dcaDetune	; E2 - Add xx to channel frequency displacement (DETUNE)
0000FE30 6000 0000                  	bra.w	dcsTransp	; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0000FE34 6000 0000                  	bra.w	dcaTransp	; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0000FE38 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0000FE3C 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0000FE40 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0000FE44 6000 0000                  	bra.w	dcVoice		; E8 - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0000FE48 6000 0000                  	bra.w	dcsTempoShoes	; E9 - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
0000FE4C 6000 0000                  	bra.w	dcsTempo	; EA - Set music tempo to xx (TEMPO - TEMPO_SET)
0000FE50 6000 0000                  	bra.w	dcModOn		; EB - Turn on Modulation (MOD_SET - MODS_ON)
0000FE54 6000 0000                  	bra.w	dcModOff	; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0000FE58 6000 0000                  	bra.w	dcaVolume	; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0000FE5C 6000 0000                  	bra.w	dcsVolume	; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0000FE60 6000 0000                  	bra.w	dcsLFO		; EF - Set LFO (SET_LFO - LFO_AMSEN)
0000FE64 6000 0000                  	bra.w	dcMod68K	; F0 - Modulation (MOD_SETUP)
0000FE68 6000 0000                  	bra.w	dcSampDAC	; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0000FE6C 6000 0000                  	bra.w	dcPitchDAC	; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0000FE70 6000 0000                  	bra.w	dcNoisePSG	; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_AMPS)
0000FE74 6000 0000                  	bra.w	dcCont		; F4 - Do a continuous SFX loop (CONT_SFX)
0000FE78 6000 0000                  	bra.w	dcStop		; F5 - End of channel (TRK_END - TEND_STD)
0000FE7C 6000 0000                  	bra.w	dcJump		; F6 - Jump to xxxx (GOTO)
0000FE80 6000 0000                  	bra.w	dcLoop		; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0000FE84 6000 0000                  	bra.w	dcCall		; F8 - Call pattern at xxxx, saving return point (GOSUB)
0000FE88 6000 0000                  	bra.w	dcReturn	; F9 - Return (RETURN)
0000FE8C 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0000FE90 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0000FE94 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COMM_RESET)
0000FE98 6000 0000                  	bra.w	dcTimeout	; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0000FE9C 6000 0000                  	bra.w	dcYM		; FE - YM command (YMCMD)
0000FEA0                            				; FF - META
0000FEA0                            ; ===========================================================================
0000FEA0                            ; ---------------------------------------------------------------------------
0000FEA0                            ; Routine to execute tracker meta and false condition commands
0000FEA0                            ; ---------------------------------------------------------------------------
0000FEA0                            
0000FEA0                            .metacall
0000FEA0 1A1C                       		move.b	(a4)+,d5		; get next command byte
0000FEA2 DA45                       		add.w	d5,d5			; quadruple ID
0000FEA4 DA45                       		add.w	d5,d5			; since each entry is again 4 bytes large
0000FEA6 4EFB 5000                  		jmp	.meta(pc,d5.w)		; jump to appropriate meta handler
0000FEAA                            
0000FEAA                            .falsecomm
0000FEAA 4EFB 5000                  		jmp	.false-$80(pc,d5.w)	; jump to appropriate handler (false command)
0000FEAE                            ; ===========================================================================
0000FEAE                            ; ---------------------------------------------------------------------------
0000FEAE                            ; Command handlers for meta commands
0000FEAE                            ; ---------------------------------------------------------------------------
0000FEAE                            
0000FEAE                            .meta
0000FEAE 6000 0000                  	bra.w	dcWriteDAC1	; FF 00 - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
0000FEB2 6000 0000                  	bra.w	dcWriteDAC2	; FF 01 - Play sample xx on DAC2 (PLAY_DAC - PLAY_DAC2)
0000FEB6 6000 0000                  	bra.w	dcsFreq		; FF 02 - Set channel frequency to xxxx (CHFREQ_SET)
0000FEBA 6000 0000                  	bra.w	dcsFreqNote	; FF 03 - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
0000FEBE 6000 0000                  	bra.w	dcSpRev		; FF 04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
0000FEC2 6000 0000                  	bra.w	dcSpReset	; FF 05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
0000FEC6 6000 0000                  	bra.w	dcaTempoShoes	; FF 06 - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
0000FECA 6000 0000                  	bra.w	dcaTempo	; FF 07 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0000FECE 6000 0000                  	bra.w	dcCondReg	; FF 08 - Get RAM table offset by y, and chk zz with cond x (COMM_CONDITION - COMM_SPEC)
0000FED2 6000 0000                  	bra.w	dcSound		; FF 09 - Play another music/sfx (SND_CMD)
0000FED6 6000 0000                  	bra.w	dcFreqOn	; FF 0A - Enable raw frequency mode (RAW_FREQ)
0000FEDA 6000 0000                  	bra.w	dcFreqOff	; FF 0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
0000FEDE 6000 0000                  	bra.w	dcSpecFM3	; FF 0C - Enable FM3 special mode (SPC_FM3)
0000FEE2 6000 0000                  	bra.w	dcFilter	; FF 0D - Set DAC filter bank. (DAC_FILTER)
0000FEE6                            
0000FEE6 6000 0000                  		bra.w	dcFreeze	; FF 0E - Freeze CPU. Debug flag (DEBUG_STOP_CPU)
0000FEEA 6000 0000                  		bra.w	dcTracker	; FF 0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
0000FEEE                            ; ===========================================================================
0000FEEE                            ; ---------------------------------------------------------------------------
0000FEEE                            ; Command handlers for false condition execution
0000FEEE                            ; ---------------------------------------------------------------------------
0000FEEE                            
0000FEEE                            .false
0000FEEE 524C                       	addq.w	#1,a4
0000FEF0 4E75                       	rts			; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0000FEF2 524C                       	addq.w	#1,a4
0000FEF4 4E75                       	rts			; E1 - Add xx to channel frequency displacement (DETUNE)
0000FEF6 524C                       	addq.w	#1,a4
0000FEF8 4E75                       	rts			; E2 - Add xx to channel frequency displacement (DETUNE)
0000FEFA 524C                       	addq.w	#1,a4
0000FEFC 4E75                       	rts			; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0000FEFE 524C                       	addq.w	#1,a4
0000FF00 4E75                       	rts			; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0000FF02 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0000FF06 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0000FF0A 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0000FF0E 524C                       	addq.w	#1,a4
0000FF10 4E75                       	rts			; E8 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0000FF12 524C                       	addq.w	#1,a4
0000FF14 4E75                       	rts			; E9 - Set music tempo to xx (TEMPO - TEMPO_SET)
0000FF16 524C                       	addq.w	#1,a4
0000FF18 4E75                       	rts			; EA - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0000FF1A 4E75                       	rts
0000FF1C 4E75                       	rts			; EB - Turn on Modulation (MOD_SET - MODS_ON)
0000FF1E 4E75                       	rts
0000FF20 4E75                       	rts			; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0000FF22 524C                       	addq.w	#1,a4
0000FF24 4E75                       	rts			; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0000FF26 524C                       	addq.w	#1,a4
0000FF28 4E75                       	rts			; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0000FF2A 524C                       	addq.w	#1,a4
0000FF2C 4E75                       	rts			; EF - Set LFO (SET_LFO - LFO_AMSEN)
0000FF2E 584C                       	addq.w	#4,a4
0000FF30 4E75                       	rts			; F0 - Modulation (MOD_SETUP)
0000FF32 4E75                       	rts
0000FF34 4E75                       	rts			; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0000FF36 4E75                       	rts
0000FF38 4E75                       	rts			; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0000FF3A 524C                       	addq.w	#1,a4
0000FF3C 4E75                       	rts			; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_SET)
0000FF3E 544C                       	addq.w	#2,a4
0000FF40 4E75                       	rts			; F4 - Do a continuous SFX loop (CONT_SFX)
0000FF42 4E75                       	rts
0000FF44 4E75                       	rts			; F5 - End of channel (TRK_END - TEND_STD)
0000FF46 544C                       	addq.w	#2,a4
0000FF48 4E75                       	rts			; F6 - Jump to xxxx (GOTO)
0000FF4A 584C                       	addq.w	#4,a4
0000FF4C 4E75                       	rts			; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0000FF4E 544C                       	addq.w	#2,a4
0000FF50 4E75                       	rts			; F8 - Call pattern at xxxx, saving return point (GOSUB)
0000FF52 4E75                       	rts
0000FF54 4E75                       	rts			; F9 - Return (RETURN)
0000FF56 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0000FF5A 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0000FF5E 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COND_RESET)
0000FF62 524C                       	addq.w	#1,a4
0000FF64 4E75                       	rts			; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0000FF66 524C                       	addq.w	#1,a4
0000FF68 4E75                       	rts			; FE - YM command (YMCMD)
0000FF6A 6000 FF34                  	bra.w	.metacall	; FF - META
0000FF6E                            ; ===========================================================================
0000FF6E                            ; ---------------------------------------------------------------------------
0000FF6E                            ; Tracker commands for writing direct DAC samples to Dual PCM.
0000FF6E                            ; Note that this will override any DAC already being played,
0000FF6E                            ; and in turn trackers may override these DAC samples at any
0000FF6E                            ; time. Use with caution!
0000FF6E                            ; ---------------------------------------------------------------------------
0000FF6E                            
0000FF6E                            dcWriteDAC1:
0000FF6E 7000                       		moveq	#0,d0
0000FF70 101C                       		move.b	(a4)+,d0		; get note to write
0000FF72 4EFA E58C                  		jmp	dNoteWriteDAC1(pc)	; note-on
0000FF76                            
0000FF76                            dcWriteDAC2:
0000FF76 7000                       		moveq	#0,d0
0000FF78 101C                       		move.b	(a4)+,d0		; get note to write
0000FF7A 4EFA E576                  		jmp	dNoteWriteDAC2(pc)	; note-on
0000FF7E                            ; ===========================================================================
0000FF7E                            ; ---------------------------------------------------------------------------
0000FF7E                            ; Tracker commands for handling spindash revving.
0000FF7E                            ; The way spindash revving works, is it actually just
0000FF7E                            ; increments a counter each time, and this counter is
0000FF7E                            ; added into the channel pitch offset.
0000FF7E                            ; ---------------------------------------------------------------------------
0000FF7E                            
0000FF7E                            dcSpRev:
0000FF7E 1038 C4C1                  		move.b	mSpindash.w,d0		; load spindash rev counter to d0
0000FF82 5238 C4C1                  		addq.b	#1,mSpindash.w		; increment spindash rev counter
0000FF86 D12D 0008                  		add.b	d0,cPitch(a5)		; add d0 to channel pitch offset
0000FF8A                            
0000FF8A 0C00 000B                  		cmp.b	#$C-1,d0		; check if this is the max pitch offset
0000FF8E 6500                       		blo.s	.rts			; if not, skip
0000FF90 5338 C4C1                  		subq.b	#1,mSpindash.w		; cap at pitch offset $C
0000FF94                            
0000FF94                            .rts
0000FF94 4E75                       		rts
0000FF96                            
0000FF96                            dcSpReset:
0000FF96 4238 C4C1                  		clr.b	mSpindash.w		; reset spindash rev counter
0000FF9A 4E75                       		rts
0000FF9C                            ; ===========================================================================
0000FF9C                            ; ---------------------------------------------------------------------------
0000FF9C                            ; Tracker command for changing channel panning
0000FF9C                            ; ---------------------------------------------------------------------------
0000FF9C                            
0000FF9C                            dcPan:
0000FF9C                            		AMPS_Debug_dcPan		; check if this channel can pan
0000FF9C 4A2D 0001                M 	tst.b	ctype(a5)
0000FFA0 6A00                     M 	bpl.s	.ok
0000FFA2                          M 	raiseerror	"sPan on a PSG channel!",amps_debug_console_channel
0000FFA2 487A FFFE                M 	pea	*(pc)
0000FFA6                          M 	raiseerror2	"sPan on a PSG channel!",amps_debug_console_channel
0000FFA6 40E7                     M 	move.w	sr,-(sp)
0000FFA8                          M 	__fstring_generateargumentscode	"sPan on a PSG channel!"
0000FFA8 =00000000                M 	__pos:	set instr("sPan on a PSG channel!",'%<')
0000FFA8 =00000000                M 	__stack:set	0
0000FFA8 =00000000                M 	__sp:	set 0
0000FFA8                          M 	while	(__pos)
0000FFA8                          M 	rept	__stack
0000FFA8 4EB9 0000 0000           M 	jsr	errorhandler
0000FFAE                          M 	__fstring_generatedecodedstring	"sPan on a PSG channel!"
0000FFAE =00000001                M 	__lpos:	set 1
0000FFAE =00000000                M 	__pos:	set instr("sPan on a PSG channel!",'%<')
0000FFAE                          M 	while	(__pos)
0000FFAE                          M 	__substr:	substr __lpos,,"sPan on a PSG channel!"
0000FFAE 7350 616E 206F 6E20 6120+M 	dc.b	"sPan on a PSG channel!"
0000FFC4 00                       M 	dc.b	0
0000FFC5 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000FFC6                          M 	even
0000FFC6 4EFA CF6A                M 	jmp	amps_debug_console_channel
0000FFCA                          M 	even
0000FFCA                          M .ok
0000FFCA                            
0000FFCA 7237                       		moveq	#$37,d1			; prepare bits to keep
0000FFCC C22D 0006                  		and.b	cPanning(a5),d1		; and with channel LFO settings
0000FFD0 821C                       		or.b	(a4)+,d1		; or panning value
0000FFD2 1B41 0006                  		move.b	d1,cPanning(a5)		; save as channel panning
0000FFD6                            
0000FFD6 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0000FFD8 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0000FFDE 6700 F55A                  		beq.w	dWriteYMchnInt		; if not, write channel-specific YM command
0000FFE2                            ; ---------------------------------------------------------------------------
0000FFE2                            ; Since the DAC channels have or based panning behavior, we need this
0000FFE2                            ; piece of code to update its panning
0000FFE2                            ; ---------------------------------------------------------------------------
0000FFE2                            
0000FFE2 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0000FFE6 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0000FFEC 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0000FFEE 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0000FFF2                            
0000FFF2                            .nodacsfx
0000FFF2 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0000FFF6 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0000FFF8 4EFA F592                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0000FFFC                            ; ===========================================================================
0000FFFC                            ; ---------------------------------------------------------------------------
0000FFFC                            ; Tracker commands for changing detune offset
0000FFFC                            ; ---------------------------------------------------------------------------
0000FFFC                            
0000FFFC                            dcaDetune:
0000FFFC 101C                       		move.b	(a4)+,d0		; load detune offset from tracker
0000FFFE D12D 0007                  		add.b	d0,cDetune(a5)		; Add to channel detune offset
00010002 4E75                       		rts
00010004                            
00010004                            dcsDetune:
00010004 1B5C 0007                  		move.b	(a4)+,cDetune(a5)	; load detune offset from tracker to channel
00010008 4E75                       		rts
0001000A                            ; ===========================================================================
0001000A                            ; ---------------------------------------------------------------------------
0001000A                            ; Tracker command for changing channel volume
0001000A                            ; ---------------------------------------------------------------------------
0001000A                            
0001000A                            dcsVolume:
0001000A 1B5C 0009                  		move.b	(a4)+,cVolume(a5)	; load volume from tracker to channel
0001000E 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
00010012 4E75                       		rts
00010014                            
00010014                            dcaVolume:
00010014 101C                       		move.b	(a4)+,d0		; load volume from tracker
00010016 D12D 0009                  		add.b	d0,cVolume(a5)		; add to channel volume
0001001A 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001001E 4E75                       		rts
00010020                            ; ===========================================================================
00010020                            ; ---------------------------------------------------------------------------
00010020                            ; Tracker command for setting DAC to sample mode and resetting frequency
00010020                            ; ---------------------------------------------------------------------------
00010020                            
00010020                            dcSampDAC:
00010020 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; reset to defualt base frequency
00010026 0895 0000                  		bclr	#cfbMode,(a5)		; enable sample mode
0001002A 4E75                       		rts
0001002C                            ; ===========================================================================
0001002C                            ; ---------------------------------------------------------------------------
0001002C                            ; Tracker command for setting DAC to pitch mode
0001002C                            ; ---------------------------------------------------------------------------
0001002C                            
0001002C                            dcPitchDAC:
0001002C 08D5 0000                  		bset	#cfbMode,(a5)		; enable pitch mode
00010030 4E75                       		rts
00010032                            ; ===========================================================================
00010032                            ; ---------------------------------------------------------------------------
00010032                            ; Tracker commands for changing channel tick multiplier
00010032                            ; ---------------------------------------------------------------------------
00010032                            
00010032                            dcsTmulCh:
00010032 1B5C 000A                  		move.b	(a4)+,cTick(a5)		; load tick multiplier from tracker to channel
00010036 4E75                       		rts
00010038                            
00010038                            dcsTmul:
00010038 101C                       		move.b	(a4)+,d0		; load tick multiplier from tracker to d0
0001003A =FFFFC4C4                  .x =	mDAC1					; start at DAC1
0001003A                            	rept Mus_Ch				; do for all music channels
0001003A                            		move.b	d0,cTick+.x.w		; set channel tick multiplier
0001003A                            .x =		.x+cSize			; go to next channel
0001003A                            	endr
0001003A 11C0 C4CE                M 	move.b	d0,ctick+.x.w
0001003E =FFFFC4F0                M .x	=	.x+csize
0001003E 11C0 C4FA                M 	move.b	d0,ctick+.x.w
00010042 =FFFFC51C                M .x	=	.x+csize
00010042 11C0 C526                M 	move.b	d0,ctick+.x.w
00010046 =FFFFC548                M .x	=	.x+csize
00010046 11C0 C552                M 	move.b	d0,ctick+.x.w
0001004A =FFFFC574                M .x	=	.x+csize
0001004A 11C0 C57E                M 	move.b	d0,ctick+.x.w
0001004E =FFFFC5A0                M .x	=	.x+csize
0001004E 11C0 C5AA                M 	move.b	d0,ctick+.x.w
00010052 =FFFFC5CC                M .x	=	.x+csize
00010052 11C0 C5D6                M 	move.b	d0,ctick+.x.w
00010056 =FFFFC5F8                M .x	=	.x+csize
00010056 11C0 C602                M 	move.b	d0,ctick+.x.w
0001005A =FFFFC624                M .x	=	.x+csize
0001005A 11C0 C62E                M 	move.b	d0,ctick+.x.w
0001005E =FFFFC650                M .x	=	.x+csize
0001005E 11C0 C65A                M 	move.b	d0,ctick+.x.w
00010062 =FFFFC67C                M .x	=	.x+csize
00010062 4E75                       		rts
00010064                            ; ===========================================================================
00010064                            ; ---------------------------------------------------------------------------
00010064                            ; Tracker command for enabling or disabling the hold flag
00010064                            ; ---------------------------------------------------------------------------
00010064                            
00010064                            dcHold:
00010064 0855 0002                  		bchg	#cfbHold,(a5)		; flip the channel hold flag
00010068 4E75                       		rts
0001006A                            ; ===========================================================================
0001006A                            ; ---------------------------------------------------------------------------
0001006A                            ; Tracker command for enabling or disabling note timeout
0001006A                            ; ---------------------------------------------------------------------------
0001006A                            
0001006A                            dcTimeout:
0001006A                            		AMPS_Debug_dcTimeout		; check if this channel has timeout support
0001006A BAFC C67C                M 	cmp.w	#msfxdac1,a5
0001006E 6500                     M 	blo.s	.ok
00010070                          M 	raiseerror	"sNoteTimeOut on a SFX channel!",amps_debug_console_channel
00010070 487A FFFE                M 	pea	*(pc)
00010074                          M 	raiseerror2	"sNoteTimeOut on a SFX channel!",amps_debug_console_channel
00010074 40E7                     M 	move.w	sr,-(sp)
00010076                          M 	__fstring_generateargumentscode	"sNoteTimeOut on a SFX channel!"
00010076 =00000000                M 	__pos:	set instr("sNoteTimeOut on a SFX channel!",'%<')
00010076 =00000000                M 	__stack:set	0
00010076 =00000000                M 	__sp:	set 0
00010076                          M 	while	(__pos)
00010076                          M 	rept	__stack
00010076 4EB9 0000 0000           M 	jsr	errorhandler
0001007C                          M 	__fstring_generatedecodedstring	"sNoteTimeOut on a SFX channel!"
0001007C =00000001                M 	__lpos:	set 1
0001007C =00000000                M 	__pos:	set instr("sNoteTimeOut on a SFX channel!",'%<')
0001007C                          M 	while	(__pos)
0001007C                          M 	__substr:	substr __lpos,,"sNoteTimeOut on a SFX channel!"
0001007C 734E 6F74 6554 696D 654F+M 	dc.b	"sNoteTimeOut on a SFX channel!"
0001009A 00                       M 	dc.b	0
0001009B 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001009C                          M 	even
0001009C 4EFA CE94                M 	jmp	amps_debug_console_channel
000100A0                          M 	even
000100A0                          M .ok
000100A0                            
000100A0 1B54 001D                  		move.b	(a4),cNoteTimeMain(a5)	; load note timeout from tracker to channel
000100A4 1B5C 001C                  		move.b	(a4)+,cNoteTimeCur(a5)	; ''
000100A8 4E75                       		rts
000100AA                            ; ===========================================================================
000100AA                            ; ---------------------------------------------------------------------------
000100AA                            ; Tracker commands for changing channel pitch
000100AA                            ; ---------------------------------------------------------------------------
000100AA                            
000100AA                            dcaTransp:
000100AA 101C                       		move.b	(a4)+,d0		; load pitch offset from tracker
000100AC D12D 0008                  		add.b	d0,cPitch(a5)		; add to channel pitch offset
000100B0 4E75                       		rts
000100B2                            
000100B2                            dcsTransp:
000100B2 1B5C 0008                  		move.b	(a4)+,cPitch(a5)	; load pitch offset from tracker to channel
000100B6 4E75                       		rts
000100B8                            ; ===========================================================================
000100B8                            ; ---------------------------------------------------------------------------
000100B8                            ; Tracker commands for tempo control
000100B8                            ; ---------------------------------------------------------------------------
000100B8                            
000100B8                            dcsTempoShoes:
000100B8 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
000100BA 11C0 C4B9                  		move.b	d0,mTempoSpeed.w	; save as the speed shoes tempo
000100BE 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
000100C4 6600                       		bne.s	dcsTempoCur		; if is, load as current tempo too
000100C6 4E75                       		rts
000100C8                            
000100C8                            dcsTempo:
000100C8 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
000100CA 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as the main tempo
000100CE 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
000100D4 6600                       		bne.s	locret_Tempo		; if not, load as current tempo too
000100D6                            
000100D6                            dcsTempoCur:
000100D6 11C0 C4BA                  		move.b	d0,mTempo.w		; save as current tempo
000100DA                            
000100DA                            locret_Tempo:
000100DA 4E75                       		rts
000100DC                            
000100DC                            dcaTempoShoes:
000100DC 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
000100DE D138 C4B9                  		add.b	d0,mTempoSpeed.w	; add to the speed shoes tempo
000100E2 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
000100E8 6600                       		bne.s	dcaTempoCur		; if is, add to current tempo too
000100EA 4E75                       		rts
000100EC                            
000100EC                            dcaTempo:
000100EC 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
000100EE D138 C4B8                  		add.b	d0,mTempoMain.w		; add to the main tempo
000100F2 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
000100F8 66E0                       		bne.s	locret_Tempo		; if not, add to current tempo too
000100FA                            
000100FA                            dcaTempoCur:
000100FA D138 C4BA                  		add.b	d0,mTempo.w		; add to current tempo
000100FE 4E75                       		rts
00010100                            ; ===========================================================================
00010100                            ; ---------------------------------------------------------------------------
00010100                            ; Tracker command for enabling or disabling PSG4 noise mode
00010100                            ; ---------------------------------------------------------------------------
00010100                            
00010100                            dcNoisePSG:
00010100 1B54 001B                  		move.b	(a4),cStatPSG4(a5)	; load PSG4 status command from tracker to channel
00010104 6700                       		beq.s	.psg3			; if disabling PSG4 mode, branch
00010106 1B7C 00E0 0001             		move.b	#ctPSG4,cType(a5)	; make PSG3 act on behalf of PSG4
0001010C 13DC 00C0 0011             		move.b	(a4)+,dPSG		; send command to PSG port
00010112 4E75                       		rts
00010114                            
00010114                            .psg3
00010114 1B7C 00C0 0001             		move.b	#ctPSG3,cType(a5)	; make PSG3 not act on behalf of PSG4
0001011A 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send PSG4 mute command to PSG
00010122 524C                       		addq.w	#1,a4			; skip param
00010124 4E75                       		rts
00010126                            ; ===========================================================================
00010126                            ; ---------------------------------------------------------------------------
00010126                            ; Tracker command for playing another music or SFX
00010126                            ; ---------------------------------------------------------------------------
00010126                            
00010126                            dcSound:
00010126 11DC C4BE                  		move.b	(a4)+,mQueue+2.w	; load sound ID from tracker to sound queue
0001012A                            
0001012A                            Return_dcSound:
0001012A 4E75                       		rts
0001012C                            ; ===========================================================================
0001012C                            ; ---------------------------------------------------------------------------
0001012C                            ; Tracker command for setting DAC filter bank
0001012C                            ; ---------------------------------------------------------------------------
0001012C                            
0001012C                            dcFilter:
0001012C 7000                       		moveq	#0,d0
0001012E 101C                       		move.b	(a4)+,d0		; load filter bank number from tracker
00010130 4EFA EF40                  		jmp	dSetFilter(pc)		; load filter bank instructions to Z80 RAM
00010134                            ; ===========================================================================
00010134                            ; ---------------------------------------------------------------------------
00010134                            ; Tracker command for writing a YM command to YMCue
00010134                            ; ---------------------------------------------------------------------------
00010134                            
00010134                            dcYM:
00010134 101C                       		move.b	(a4)+,d0		; load YM address from tracker to d0
00010136 121C                       		move.b	(a4)+,d1		; get command value from tracker to d1
00010138 0815 0001                  		btst	#cfbInt,(a5)		; is this channel overridden by SFX?
0001013C 66EC                       		bne.s	Return_dcSound		; if so, skip
0001013E                            
0001013E 0C00 0030                  		cmp.b	#$30,d0			; is this register 00-2F?
00010142 6500 F408                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
00010146                            
00010146 1400                       		move.b	d0,d2			; copy address to d2
00010148 0402 00A8                  		sub.b	#$A8,d2			; align $A8 with 0
0001014C 0C02 0008                  		cmp.b	#$08,d2			; is this egister A8-AF?
00010150 6500 F3FA                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
00010154 4EFA F3EA                  		jmp	WriteChYM(pc)		; write to YM according to channel
00010158                            ; ===========================================================================
00010158                            ; ---------------------------------------------------------------------------
00010158                            ; Tracker command for setting channel base frequency
00010158                            ; ---------------------------------------------------------------------------
00010158                            
00010158                            dcsFreq:
00010158 1B5C 000E                  		move.b	(a4)+,cFreq(a5)		; load base frequency from tracker to channel
0001015C 1B5C 000F                  		move.b	(a4)+,cFreq+1(a5)	; ''
00010160                            
00010160 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
00010166 6600                       		bne.s	.rts			; if so, brÃ¡nch
00010168                            		AMPS_Debug_dcInvalid		; this command should be only used with DAC channels
00010168                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
00010168 487A FFFE                M 	pea	*(pc)
0001016C                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
0001016C 40E7                     M 	move.w	sr,-(sp)
0001016E                          M 	__fstring_generateargumentscode	"Invalid command detected!"
0001016E =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
0001016E =00000000                M 	__stack:set	0
0001016E =00000000                M 	__sp:	set 0
0001016E                          M 	while	(__pos)
0001016E                          M 	rept	__stack
0001016E 4EB9 0000 0000           M 	jsr	errorhandler
00010174                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
00010174 =00000001                M 	__lpos:	set 1
00010174 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010174                          M 	while	(__pos)
00010174                          M 	__substr:	substr __lpos,,"Invalid command detected!"
00010174 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
0001018D 00                       M 	dc.b	0
0001018E 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010190 00                       M 	even
00010190 4EFA CDA0                M 	jmp	amps_debug_console_channel
00010194                          M 	even
00010194                            .rts
00010194 4E75                       		rts
00010196                            ; ===========================================================================
00010196                            ; ---------------------------------------------------------------------------
00010196                            ; Tracker command for setting channel base frequency from the note table
00010196                            ; ---------------------------------------------------------------------------
00010196                            
00010196                            dcsFreqNote:
00010196 7000                       		moveq	#0,d0
00010198 101C                       		move.b	(a4)+,d0		; load note from tracker to d0
0001019A D02D 0008                  		add.b	cPitch(a5),d0		; add pitch offset to note
0001019E D040                       		add.w	d0,d0			; double offset (each entry is a word)
000101A0                            
000101A0 43FA F522                  		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
000101A4 3B71 0000 000E             		move.w	(a1,d0.w),cFreq(a5)	; load and save the requested frequency
000101AA                            
000101AA 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
000101B0 6600                       		bne.s	.rts			; if so, brÃ¡nch
000101B2                            		AMPS_Debug_dcInvalid		; this command should be only used with DAC channels
000101B2                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000101B2 487A FFFE                M 	pea	*(pc)
000101B6                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000101B6 40E7                     M 	move.w	sr,-(sp)
000101B8                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000101B8 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000101B8 =00000000                M 	__stack:set	0
000101B8 =00000000                M 	__sp:	set 0
000101B8                          M 	while	(__pos)
000101B8                          M 	rept	__stack
000101B8 4EB9 0000 0000           M 	jsr	errorhandler
000101BE                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000101BE =00000001                M 	__lpos:	set 1
000101BE =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000101BE                          M 	while	(__pos)
000101BE                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000101BE 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000101D7 00                       M 	dc.b	0
000101D8 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000101DA 00                       M 	even
000101DA 4EFA CD56                M 	jmp	amps_debug_console_channel
000101DE                          M 	even
000101DE                            .rts
000101DE 4E75                       		rts
000101E0                            ; ===========================================================================
000101E0                            ; ---------------------------------------------------------------------------
000101E0                            ; Tracker command for doing a continous SFX loop
000101E0                            ; ---------------------------------------------------------------------------
000101E0                            
000101E0                            dcCont:
000101E0 5338 C4C2                  		subq.b	#1,mContCtr.w		; decrease continous sfx counter
000101E4 6A00                       		bpl.s	dcJump			; if positive, jump to routine
000101E6 4238 C4C3                  		clr.b	mContLast.w		; clear continous SFX ID
000101EA 544C                       		addq.w	#2,a4			; skip over jump offset
000101EC 4E75                       		rts
000101EE                            ; ===========================================================================
000101EE                            ; ---------------------------------------------------------------------------
000101EE                            ; Tracker command for calling a tracker subroutine
000101EE                            ; ---------------------------------------------------------------------------
000101EE                            
000101EE                            dcCall:
000101EE                            		AMPS_Debug_dcCall1		; check if this channel supports the stack
000101EE BAFC C67C                M 	cmp.w	#msfxdac1,a5
000101F2 6500                     M 	blo.s	.ok1
000101F4                          M 	raiseerror	"sCall on a SFX channel!",amps_debug_console_channel
000101F4 487A FFFE                M 	pea	*(pc)
000101F8                          M 	raiseerror2	"sCall on a SFX channel!",amps_debug_console_channel
000101F8 40E7                     M 	move.w	sr,-(sp)
000101FA                          M 	__fstring_generateargumentscode	"sCall on a SFX channel!"
000101FA =00000000                M 	__pos:	set instr("sCall on a SFX channel!",'%<')
000101FA =00000000                M 	__stack:set	0
000101FA =00000000                M 	__sp:	set 0
000101FA                          M 	while	(__pos)
000101FA                          M 	rept	__stack
000101FA 4EB9 0000 0000           M 	jsr	errorhandler
00010200                          M 	__fstring_generatedecodedstring	"sCall on a SFX channel!"
00010200 =00000001                M 	__lpos:	set 1
00010200 =00000000                M 	__pos:	set instr("sCall on a SFX channel!",'%<')
00010200                          M 	while	(__pos)
00010200                          M 	__substr:	substr __lpos,,"sCall on a SFX channel!"
00010200 7343 616C 6C20 6F6E 2061+M 	dc.b	"sCall on a SFX channel!"
00010217 00                       M 	dc.b	0
00010218 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001021A 00                       M 	even
0001021A 4EFA CD16                M 	jmp	amps_debug_console_channel
0001021E                          M 	even
0001021E                          M .ok1
0001021E                            
0001021E 7000                       		moveq	#0,d0
00010220 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
00010224 5900                       		subq.b	#4,d0			; allocate space for another routine
00010226                            
00010226                            		AMPS_Debug_dcCall2		; check if we overflowed the space
00010226 0C00 001C                M 	cmp.b	#cnotetimecur,d0
0001022A 6200                     M 	bhi.s	.ok2
0001022C                          M 	raiseerror	"sCall stack too deep!",amps_debug_console_channel
0001022C 487A FFFE                M 	pea	*(pc)
00010230                          M 	raiseerror2	"sCall stack too deep!",amps_debug_console_channel
00010230 40E7                     M 	move.w	sr,-(sp)
00010232                          M 	__fstring_generateargumentscode	"sCall stack too deep!"
00010232 =00000000                M 	__pos:	set instr("sCall stack too deep!",'%<')
00010232 =00000000                M 	__stack:set	0
00010232 =00000000                M 	__sp:	set 0
00010232                          M 	while	(__pos)
00010232                          M 	rept	__stack
00010232 4EB9 0000 0000           M 	jsr	errorhandler
00010238                          M 	__fstring_generatedecodedstring	"sCall stack too deep!"
00010238 =00000001                M 	__lpos:	set 1
00010238 =00000000                M 	__pos:	set instr("sCall stack too deep!",'%<')
00010238                          M 	while	(__pos)
00010238                          M 	__substr:	substr __lpos,,"sCall stack too deep!"
00010238 7343 616C 6C20 7374 6163+M 	dc.b	"sCall stack too deep!"
0001024D 00                       M 	dc.b	0
0001024E 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010250 00                       M 	even
00010250 4EFA CCE0                M 	jmp	amps_debug_console_channel
00010254                          M 	even
00010254                          M .ok2
00010254 2B8C 0000                  		move.l	a4,(a5,d0.w)		; save current address in stack
00010258 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001025C                            ; ===========================================================================
0001025C                            ; ---------------------------------------------------------------------------
0001025C                            ; Tracker command for jumping to another tracker location
0001025C                            ; ---------------------------------------------------------------------------
0001025C                            
0001025C                            dcJump:
0001025C                            	dREAD_WORD a4, d0			; read a word from tracker to d0
0001025C 1E9C                     M 	move.b	(a4)+,(sp)
0001025E 3017                     M 	move.w	(sp),d0
00010260 1014                     M 	move.b	(a4),d0
00010262 D8C0                       		adda.w	d0,a4			; offset tracker address by d0
00010264 4E75                       		rts
00010266                            ; ===========================================================================
00010266                            ; ---------------------------------------------------------------------------
00010266                            ; Tracker command for handling loops
00010266                            ; ---------------------------------------------------------------------------
00010266                            
00010266                            dcLoop:
00010266 7000                       		moveq	#0,d0
00010268 101C                       		move.b	(a4)+,d0		; load loop index from tracker to d0
0001026A                            		AMPS_Debug_dcLoop		; check if loop index is valid
0001026A 0C00 0003                M 	cmp.b	#3,d0
0001026E 6200                     M 	bhi.s	.fail
00010270 BAFC C67C                M 	cmp.w	#msfxdac1,a5
00010274 6500                     M 	blo.s	.nosfx
00010276 0C00 0001                M 	cmp.b	#1,d0
0001027A 6700                     M 	beq.s	.fail
0001027C                          M .nosfx
0001027C 0C2D 00C0 0001           M 	cmp.b	#$c0,ctype(a5)
00010282 6500                     M 	blo.s	amps_debug_dcloop_ok
00010284 0C00 0002                M 	cmp.b	#2,d0
00010288 6600                     M 	bne.s	amps_debug_dcloop_ok
0001028A                          M .fail
0001028A                          M 	raiseerror	"sLoop ID is invalid!",amps_debug_console_channel
0001028A 487A FFFE                M 	pea	*(pc)
0001028E                          M 	raiseerror2	"sLoop ID is invalid!",amps_debug_console_channel
0001028E 40E7                     M 	move.w	sr,-(sp)
00010290                          M 	__fstring_generateargumentscode	"sLoop ID is invalid!"
00010290 =00000000                M 	__pos:	set instr("sLoop ID is invalid!",'%<')
00010290 =00000000                M 	__stack:set	0
00010290 =00000000                M 	__sp:	set 0
00010290                          M 	while	(__pos)
00010290                          M 	rept	__stack
00010290 4EB9 0000 0000           M 	jsr	errorhandler
00010296                          M 	__fstring_generatedecodedstring	"sLoop ID is invalid!"
00010296 =00000001                M 	__lpos:	set 1
00010296 =00000000                M 	__pos:	set instr("sLoop ID is invalid!",'%<')
00010296                          M 	while	(__pos)
00010296                          M 	__substr:	substr __lpos,,"sLoop ID is invalid!"
00010296 734C 6F6F 7020 4944 2069+M 	dc.b	"sLoop ID is invalid!"
000102AA 00                       M 	dc.b	0
000102AB 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000102AC                          M 	even
000102AC 4EFA CC84                M 	jmp	amps_debug_console_channel
000102B0                          M 	even
000102B0                          M amps_debug_dcloop_ok
000102B0                            
000102B0 4A35 0019                  		tst.b	cLoop(a5,d0.w)		; check the loop counter
000102B4 6600                       		bne.s	.loopok			; if nonzero, branch
000102B6 1BAC 0002 0019             		move.b	2(a4),cLoop(a5,d0.w)	; reload loop counter
000102BC                            
000102BC                            .loopok
000102BC 5335 0019                  		subq.b	#1,cLoop(a5,d0.w)	; decrease loop counter
000102C0 669A                       		bne.s	dcJump			; if not 0, jump to routine
000102C2 564C                       		addq.w	#3,a4			; skip over jump offset
000102C4 4E75                       		rts
000102C6                            ; ===========================================================================
000102C6                            ; ---------------------------------------------------------------------------
000102C6                            ; Tracker command for initializing modulation
000102C6                            ; ---------------------------------------------------------------------------
000102C6                            
000102C6                            dcMod68K:
000102C6 2B4C 0010                  		move.l	a4,cMod(a5)		; set modulation data address
000102CA 1B5C 0010                  		move.b	(a4)+,cModDelay(a5)	; load modulation delay from tracker to channel
000102CE 1B5C 0016                  		move.b	(a4)+,cModSpeed(a5)	; load modulation speed from tracker to channel
000102D2 1B5C 0017                  		move.b	(a4)+,cModStep(a5)	; load modulation step offset from tracker to channel
000102D6                            
000102D6 101C                       		move.b	(a4)+,d0		; load modulation step count from tracker to d0
000102D8 E208                       		lsr.b	#1,d0			; halve it
000102DA 1B40 0018                  		move.b	d0,cModCount(a5)	; save as modulation step count to channel
000102DE 426D 0014                  		clr.w	cModFreq(a5)		; reset modulation frequency offset to 0
000102E2                            	; continue to enabling modulation
000102E2                            ; ===========================================================================
000102E2                            ; ---------------------------------------------------------------------------
000102E2                            ; Tracker commands for enabling and disabling modulation
000102E2                            ; ---------------------------------------------------------------------------
000102E2                            
000102E2                            dcModOn:
000102E2 08D5 0003                  		bset	#cfbMod,(a5)		; enable modulation
000102E6 4E75                       		rts
000102E8                            
000102E8                            dcModOff:
000102E8 0895 0003                  		bclr	#cfbMod,(a5)		; disable modulation
000102EC 4E75                       		rts
000102EE                            ; ===========================================================================
000102EE                            ; ---------------------------------------------------------------------------
000102EE                            ; Tracker command for returning from tracker subroutine
000102EE                            ; ---------------------------------------------------------------------------
000102EE                            
000102EE                            dcReturn:
000102EE                            		AMPS_Debug_dcReturn1		; check if this channel supports the stack
000102EE BAFC C67C                M 	cmp.w	#msfxdac1,a5
000102F2 6500                     M 	blo.s	.ok1
000102F4                          M 	raiseerror	"sRet on a SFX channel!",amps_debug_console_channel
000102F4 487A FFFE                M 	pea	*(pc)
000102F8                          M 	raiseerror2	"sRet on a SFX channel!",amps_debug_console_channel
000102F8 40E7                     M 	move.w	sr,-(sp)
000102FA                          M 	__fstring_generateargumentscode	"sRet on a SFX channel!"
000102FA =00000000                M 	__pos:	set instr("sRet on a SFX channel!",'%<')
000102FA =00000000                M 	__stack:set	0
000102FA =00000000                M 	__sp:	set 0
000102FA                          M 	while	(__pos)
000102FA                          M 	rept	__stack
000102FA 4EB9 0000 0000           M 	jsr	errorhandler
00010300                          M 	__fstring_generatedecodedstring	"sRet on a SFX channel!"
00010300 =00000001                M 	__lpos:	set 1
00010300 =00000000                M 	__pos:	set instr("sRet on a SFX channel!",'%<')
00010300                          M 	while	(__pos)
00010300                          M 	__substr:	substr __lpos,,"sRet on a SFX channel!"
00010300 7352 6574 206F 6E20 6120+M 	dc.b	"sRet on a SFX channel!"
00010316 00                       M 	dc.b	0
00010317 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010318                          M 	even
00010318 4EFA CC18                M 	jmp	amps_debug_console_channel
0001031C                          M 	even
0001031C                          M .ok1
0001031C 7000                       		moveq	#0,d0
0001031E 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
00010322 2875 0000                  		movea.l	(a5,d0.w),a4		; load the address to return to
00010326                            
00010326 544C                       		addq.w	#2,a4			; skip the call address parameter
00010328 5800                       		addq.b	#4,d0			; deallocate stack space
0001032A 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001032E                            
0001032E                            		AMPS_Debug_dcReturn2		; check if we underflowed the space
0001032E 0C00 002C                M 	cmp.b	#csize,d0
00010332 6300                     M 	bls.s	.ok2
00010334                          M 	raiseerror	"sRet stack too shallow!",amps_debug_console_channel
00010334 487A FFFE                M 	pea	*(pc)
00010338                          M 	raiseerror2	"sRet stack too shallow!",amps_debug_console_channel
00010338 40E7                     M 	move.w	sr,-(sp)
0001033A                          M 	__fstring_generateargumentscode	"sRet stack too shallow!"
0001033A =00000000                M 	__pos:	set instr("sRet stack too shallow!",'%<')
0001033A =00000000                M 	__stack:set	0
0001033A =00000000                M 	__sp:	set 0
0001033A                          M 	while	(__pos)
0001033A                          M 	rept	__stack
0001033A 4EB9 0000 0000           M 	jsr	errorhandler
00010340                          M 	__fstring_generatedecodedstring	"sRet stack too shallow!"
00010340 =00000001                M 	__lpos:	set 1
00010340 =00000000                M 	__pos:	set instr("sRet stack too shallow!",'%<')
00010340                          M 	while	(__pos)
00010340                          M 	__substr:	substr __lpos,,"sRet stack too shallow!"
00010340 7352 6574 2073 7461 636B+M 	dc.b	"sRet stack too shallow!"
00010357 00                       M 	dc.b	0
00010358 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001035A 00                       M 	even
0001035A 4EFA CBD6                M 	jmp	amps_debug_console_channel
0001035E                          M 	even
0001035E                          M .ok2
0001035E 4E75                       		rts
00010360                            ; ===========================================================================
00010360                            ; ---------------------------------------------------------------------------
00010360                            ; Tracker command for initializing special FM3 mode
00010360                            ; ---------------------------------------------------------------------------
00010360                            
00010360                            dcSpecFM3:
00010360                            		AMPS_Debug_dcInvalid		; this is an invalid command
00010360                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
00010360 487A FFFE                M 	pea	*(pc)
00010364                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
00010364 40E7                     M 	move.w	sr,-(sp)
00010366                          M 	__fstring_generateargumentscode	"Invalid command detected!"
00010366 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010366 =00000000                M 	__stack:set	0
00010366 =00000000                M 	__sp:	set 0
00010366                          M 	while	(__pos)
00010366                          M 	rept	__stack
00010366 4EB9 0000 0000           M 	jsr	errorhandler
0001036C                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
0001036C =00000001                M 	__lpos:	set 1
0001036C =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
0001036C                          M 	while	(__pos)
0001036C                          M 	__substr:	substr __lpos,,"Invalid command detected!"
0001036C 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
00010385 00                       M 	dc.b	0
00010386 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010388 00                       M 	even
00010388 4EFA CBA8                M 	jmp	amps_debug_console_channel
0001038C                          M 	even
0001038C 4E75                       		rts
0001038E                            ; ===========================================================================
0001038E                            ; ---------------------------------------------------------------------------
0001038E                            ; Tracker command for enabling raw frequency mode
0001038E                            ; ---------------------------------------------------------------------------
0001038E                            
0001038E                            dcFreqOn:
0001038E                            		AMPS_Debug_dcInvalid		; this is an invalid command
0001038E                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
0001038E 487A FFFE                M 	pea	*(pc)
00010392                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
00010392 40E7                     M 	move.w	sr,-(sp)
00010394                          M 	__fstring_generateargumentscode	"Invalid command detected!"
00010394 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010394 =00000000                M 	__stack:set	0
00010394 =00000000                M 	__sp:	set 0
00010394                          M 	while	(__pos)
00010394                          M 	rept	__stack
00010394 4EB9 0000 0000           M 	jsr	errorhandler
0001039A                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
0001039A =00000001                M 	__lpos:	set 1
0001039A =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
0001039A                          M 	while	(__pos)
0001039A                          M 	__substr:	substr __lpos,,"Invalid command detected!"
0001039A 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000103B3 00                       M 	dc.b	0
000103B4 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000103B6 00                       M 	even
000103B6 4EFA CB7A                M 	jmp	amps_debug_console_channel
000103BA                          M 	even
000103BA 4E75                       		rts
000103BC                            ; ===========================================================================
000103BC                            ; ---------------------------------------------------------------------------
000103BC                            ; Tracker command for disabling raw frequency mode
000103BC                            ; ---------------------------------------------------------------------------
000103BC                            
000103BC                            dcFreqOff:
000103BC                            		AMPS_Debug_dcInvalid		; this is an invalid command
000103BC                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000103BC 487A FFFE                M 	pea	*(pc)
000103C0                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000103C0 40E7                     M 	move.w	sr,-(sp)
000103C2                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000103C2 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000103C2 =00000000                M 	__stack:set	0
000103C2 =00000000                M 	__sp:	set 0
000103C2                          M 	while	(__pos)
000103C2                          M 	rept	__stack
000103C2 4EB9 0000 0000           M 	jsr	errorhandler
000103C8                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000103C8 =00000001                M 	__lpos:	set 1
000103C8 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000103C8                          M 	while	(__pos)
000103C8                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000103C8 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000103E1 00                       M 	dc.b	0
000103E2 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000103E4 00                       M 	even
000103E4 4EFA CB4C                M 	jmp	amps_debug_console_channel
000103E8                          M 	even
000103E8                            
000103E8                            locret_FreqOff:
000103E8 4E75                       		rts
000103EA                            ; ===========================================================================
000103EA                            ; ---------------------------------------------------------------------------
000103EA                            ; Tracker command for changing voice, volume envelope or sample
000103EA                            ; ---------------------------------------------------------------------------
000103EA                            
000103EA                            dcVoice:
000103EA 7000                       		moveq	#0,d0
000103EC 101C                       		move.b	(a4)+,d0		; load voice/sample/volume envelope from tracker to d0
000103EE 1B40 000B                  		move.b	d0,cVoice(a5)		; save to channel
000103F2                            
000103F2 4A2D 0001                  		tst.b	cType(a5)		; check if this is a PSG channel
000103F6 6BF0                       		bmi.s	locret_FreqOff		; if is, skip
000103F8 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
000103FE 66E8                       		bne.s	locret_FreqOff		; if is, skip
00010400                            
00010400 0815 0001                  		btst	#cfbInt,(a5)		; check if channel is interrupted by SFX
00010404 66E2                       		bne.s	locret_FreqOff		; if is, skip
00010406 224E                       		move.l	a6,a1			; load voice table to a1
00010408                            	; continue to send FM voice
00010408                            ; ===========================================================================
00010408                            ; ---------------------------------------------------------------------------
00010408                            ; Subroutine for sending the FM voice to YM2612
00010408                            ; This routine is speed optimized in a way that allows Dual PCM
00010408                            ; to only be stopped for as long as it must be. This will waste
00010408                            ; some cycles for 68000, but it will help improve DAC quality.
00010408                            ; ---------------------------------------------------------------------------
00010408                            
00010408                            dUpdateVoiceFM:
00010408                            	dCALC_VOICE				; get address of the specific voice to a1
00010408 EB48                     M 	lsl.w	#5,d0
0001040A D2C0                     M 	add.w	d0,a1
0001040C 9EFC 003C                  		sub.w	#(VoiceRegs+1)*2,sp	; prepapre space in the stack
00010410 264F                       		move.l	sp,a3			; copy pointer to the free space to a3
00010412                            
00010412 1819                       		move.b	(a1)+,d4		; load feedback and algorithm to d4
00010414 16C4                       		move.b	d4,(a3)+		; save it to free space
00010416 16FC 00B0                  		move.b	#$B0,(a3)+		; YM command: Algorithm & FeedBack
0001041A                            
0001041A 45FA ED86                  		lea	dOpListYM(pc),a2	; load YM2612 operator list into a2
0001041E                            	rept VoiceRegs-5
0001041E                            		move.b	(a1)+,(a3)+		; copy each value (except Total Level)
0001041E                            		move.b	(a2)+,(a3)+		; copy each command
0001041E                            	endr
0001041E 16D9                     M 	move.b	(a1)+,(a3)+
00010420 16DA                     M 	move.b	(a2)+,(a3)+
00010422 16D9                     M 	move.b	(a1)+,(a3)+
00010424 16DA                     M 	move.b	(a2)+,(a3)+
00010426 16D9                     M 	move.b	(a1)+,(a3)+
00010428 16DA                     M 	move.b	(a2)+,(a3)+
0001042A 16D9                     M 	move.b	(a1)+,(a3)+
0001042C 16DA                     M 	move.b	(a2)+,(a3)+
0001042E 16D9                     M 	move.b	(a1)+,(a3)+
00010430 16DA                     M 	move.b	(a2)+,(a3)+
00010432 16D9                     M 	move.b	(a1)+,(a3)+
00010434 16DA                     M 	move.b	(a2)+,(a3)+
00010436 16D9                     M 	move.b	(a1)+,(a3)+
00010438 16DA                     M 	move.b	(a2)+,(a3)+
0001043A 16D9                     M 	move.b	(a1)+,(a3)+
0001043C 16DA                     M 	move.b	(a2)+,(a3)+
0001043E 16D9                     M 	move.b	(a1)+,(a3)+
00010440 16DA                     M 	move.b	(a2)+,(a3)+
00010442 16D9                     M 	move.b	(a1)+,(a3)+
00010444 16DA                     M 	move.b	(a2)+,(a3)+
00010446 16D9                     M 	move.b	(a1)+,(a3)+
00010448 16DA                     M 	move.b	(a2)+,(a3)+
0001044A 16D9                     M 	move.b	(a1)+,(a3)+
0001044C 16DA                     M 	move.b	(a2)+,(a3)+
0001044E 16D9                     M 	move.b	(a1)+,(a3)+
00010450 16DA                     M 	move.b	(a2)+,(a3)+
00010452 16D9                     M 	move.b	(a1)+,(a3)+
00010454 16DA                     M 	move.b	(a2)+,(a3)+
00010456 16D9                     M 	move.b	(a1)+,(a3)+
00010458 16DA                     M 	move.b	(a2)+,(a3)+
0001045A 16D9                     M 	move.b	(a1)+,(a3)+
0001045C 16DA                     M 	move.b	(a2)+,(a3)+
0001045E 16D9                     M 	move.b	(a1)+,(a3)+
00010460 16DA                     M 	move.b	(a2)+,(a3)+
00010462 16D9                     M 	move.b	(a1)+,(a3)+
00010464 16DA                     M 	move.b	(a2)+,(a3)+
00010466 16D9                     M 	move.b	(a1)+,(a3)+
00010468 16DA                     M 	move.b	(a2)+,(a3)+
0001046A 16D9                     M 	move.b	(a1)+,(a3)+
0001046C 16DA                     M 	move.b	(a2)+,(a3)+
0001046E 16D9                     M 	move.b	(a1)+,(a3)+
00010470 16DA                     M 	move.b	(a2)+,(a3)+
00010472 16D9                     M 	move.b	(a1)+,(a3)+
00010474 16DA                     M 	move.b	(a2)+,(a3)+
00010476 16D9                     M 	move.b	(a1)+,(a3)+
00010478 16DA                     M 	move.b	(a2)+,(a3)+
0001047A 16D9                     M 	move.b	(a1)+,(a3)+
0001047C 16DA                     M 	move.b	(a2)+,(a3)+
0001047E                            
0001047E 7C00                       		moveq	#0,d6			; reset the modulator offset
00010480 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
00010484 D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
00010488 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001048A 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001048C                            
0001048C                            .noover
0001048C 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
00010492 6700                       		beq.s	.uwdone			; if not, skip
00010494 1C04                       		move.b	d4,d6			; copy algorithm and feedback to d6
00010496 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001049A D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001049C 1C04                       		move.b	d4,d6			; set algorithm and feedback to modulator offset
0001049E                            
0001049E                            .uwdone
0001049E 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
000104A0                            
000104A0                            .tlloop
000104A0 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
000104A2 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
000104A4                            
000104A4 D203                       		add.b	d3,d1			; add carrier offset to loaded value
000104A6 6B00                       		bmi.s	.slot			; if we did not overflow, branch
000104A8 727F                       		moveq	#$7F,d1			; cap to silent volume
000104AA 6000                       		bra.s	.slot
000104AC                            
000104AC                            .noslot
000104AC D206                       		add.b	d6,d1			; add modulator offset to loaded value
000104AE                            .slot
000104AE 16C1                       		move.b	d1,(a3)+		; save the Total Level value
000104B0 16DA                       		move.b	(a2)+,(a3)+		; copy total level command
000104B2 51CD FFEC                  		dbf	d5,.tlloop		; repeat for each Total Level operator
000104B6                            
000104B6                            		AMPS_Debug_UpdVoiceFM		; check if the voice was valid
000104B6 0C19 004E                M 	cmp.b	#'N',(a1)+
000104BA 6600                     M 	bne.s	.fail
000104BC 0C59 4154                M 	cmp.w	#'AT',(a1)+
000104C0 6700                     M 	beq.s	.ok
000104C2                          M .fail
000104C2                          M 	raiseerror	"FM voice Update invalid voice: %<.b cVoice(a5)>",amps_debug_console_channel
000104C2 487A FFFE                M 	pea	*(pc)
000104C6                          M 	raiseerror2	"FM voice Update invalid voice: %<.b cVoice(a5)>",amps_debug_console_channel
000104C6 40E7                     M 	move.w	sr,-(sp)
000104C8                          M 	__fstring_generateargumentscode	"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104C8 =00000020                M 	__pos:	set instr("FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
000104C8 =00000000                M 	__stack:set	0
000104C8 =00000000                M 	__sp:	set 0
000104C8                          M 	while	(__pos)
000104C8 =0000002F                M 	__endpos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'>')
000104C8 =00000000                M 	__midpos:	set instr(__pos+5,"FM voice Update invalid voice: %<.b cVoice(a5)>",' ')
000104C8 =0000002F                M 	__midpos:	= __endpos
000104C8                          M 	__substr:	substr __pos+1+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104C8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104C8                          M 	__operand:	substr __pos+1+1,__midpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104C8                          M 	__param:	substr __midpos+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104C8                          M 	pushp	"move.b cVoice(a5),1(sp)"
000104C8                          M 	pushp	"subq.w	#2, sp"
000104C8 =00000002                M 	__stack:	= __stack+2
000104C8 =00000002                M 	__sp:	= __sp+2
000104C8 =00000000                M 	__pos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
000104C8                          M 	rept	__stack
000104C8                          M 	popp	__command
000104C8 554F                     M 	subq.w	#2,sp
000104CA                          M 	popp	__command
000104CA 1F6D 000B 0001           M 	move.b	cvoice(a5),1(sp)
000104D0 4EB9 0000 0000           M 	jsr	errorhandler
000104D6                          M 	__fstring_generatedecodedstring	"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104D6 =00000001                M 	__lpos:	set 1
000104D6 =00000020                M 	__pos:	set instr("FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
000104D6                          M 	while	(__pos)
000104D6                          M 	__substr:	substr __lpos,__pos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104D6 464D 2076 6F69 6365 2055+M 	dc.b	"FM voice Update invalid voice: "
000104F5 =0000002F                M 	__endpos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'>')
000104F5 =00000000                M 	__midpos:	set instr(__pos+5,"FM voice Update invalid voice: %<.b cVoice(a5)>",' ')
000104F5 =0000002F                M 	__midpos:	= __endpos
000104F5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104F5                          M 	__param:	substr __midpos+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104F5                          M 	__param:	substr ,,"hex"
000104F5 80                       M 	dc.b	hex
000104F6 =00000030                M 	__lpos:	set __endpos+1
000104F6 =00000000                M 	__pos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
000104F6                          M 	__substr:	substr __lpos,,"FM voice Update invalid voice: %<.b cVoice(a5)>"
000104F6                          M 	dc.b	""
000104F6 00                       M 	dc.b	0
000104F7 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000104F8                          M 	even
000104F8 4EFA CA38                M 	jmp	amps_debug_console_channel
000104FC                          M 	even
000104FC                          M .ok
000104FC                            
000104FC 0895 0005                  		bclr	#cfbVol,(a5)		; reset volume update request flag
00010500 16ED 0006                  		move.b	cPanning(a5),(a3)+	; copy panning value to free space
00010504 16FC 00B4                  		move.b	#$B4,(a3)+		; YM command: Panning & LFO
00010508                            
00010508 7400                       		moveq	#0,d2			; prepare part 1 value
0001050A 162D 0001                  		move.b	cType(a5),d3		; load FM channel type to d3
0001050E 0803 0002                  		btst	#ctbPt2,d3		; check if its part 1
00010512 6700                       		beq.s	.ptok			; if so, branch
00010514 0203 0003                  		and.b	#3,d3			; get channel offset only
00010518 7402                       		moveq	#2,d2			; prepare part 2 value
0001051A                            
0001051A                            .ptok
0001051A 264F                       		move.l	sp,a3			; copy free space pointer to a3 again
0001051C 721D                       		moveq	#VoiceRegs,d1		; prepare loop point
0001051E                            		AMPS_Debug_CuePtr 0		; make sure cue is valid
0001051E B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
00010524 6500                     M 	blo.s	.fail_753
00010526 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0001052C 6500                     M 	blo.s	.ok_753
0001052E                          M .fail_753
0001052E 4EBA D782                M 	jsr	amps_debug_cueptr0
00010532                          M .ok_753
00010532                            	StopZ80					; wait for Z80 to stop
00010532 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001053A                          M 	waitz80stop
0001053A 0839 0000 00A1 1100      M .wait_755:	btst	#0,z80_bus_req
00010542 66F6                     M 	bne.s	.wait_755
00010544                            
00010544                            .write
00010544 10C2                       		move.b	d2,(a0)+		; select YM port to access (4000 or 4002)
00010546 10DB                       		move.b	(a3)+,(a0)+		; write command values
00010548                            
00010548 101B                       		move.b	(a3)+,d0		; load YM command
0001054A 8003                       		or.b	d3,d0			; add the channel offset to command
0001054C 10C0                       		move.b	d0,(a0)+		; save to Z80 cue
0001054E 51C9 FFF4                  		dbf	d1,.write		; write all registers
00010552 50D0                       		st	(a0)			; mark as end of the cue
00010554                            
00010554                            	StartZ80				; enable Z80 execution
00010554 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001055C DEFC 003C                  		add.w	#(VoiceRegs+1)*2,sp	; reset stack pointer
00010560 4E75                       		rts
00010562                            ; ===========================================================================
00010562                            ; ---------------------------------------------------------------------------
00010562                            ; Tracker command for stopping the current channel
00010562                            ; ---------------------------------------------------------------------------
00010562                            
00010562                            dcStop:
00010562 0215 007B                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRun),(a5); clear hold and running tracker flags
00010566 4A2D 0001                  		tst.b	cType(a5)		; check if this was a PSG channel
0001056A 6B00                       		bmi.s	.mutePSG		; if yes, mute it
0001056C                            
0001056C 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this was a DAC channel
00010572 6600                       		bne.s	.cont			; if we are, skip
00010574 4EBA EFB0                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
00010578 6000                       		bra.s	.cont
0001057A                            ; ---------------------------------------------------------------------------
0001057A                            
0001057A                            .mutePSG
0001057A 4EBA F87C                  		jsr	dMutePSGmus(pc)		; mute PSG channel
0001057E                            
0001057E                            .cont
0001057E BAFC C698                  		cmpa.w	#mSFXFM3,a5		; check if this is a SFX channel
00010582 6500                       		blo.s	.exit			; if not, skip all this mess
00010584 422D 001A                  		clr.b	cPrio(a5)		; clear channel priority
00010588                            
00010588 43FA E7F2                  		lea	dSFXoverList(pc),a1	; load quick reference to the SFX override list to a1
0001058C 7600                       		moveq	#0,d3
0001058E 162D 0001                  		move.b	cType(a5),d3		; load channel type to d3
00010592 6B00                       		bmi.s	.psg			; if this is a PSG channel, branch
00010594 3F0D                       		move.w	a5,-(sp)		; push channel pointer
00010596                            
00010596 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001059A 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001059C D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001059E 3A71 3000                  		move.w	(a1,d3.w),a5		; get the SFX channel we were overriding
000105A2                            
000105A2                            .dacdone
000105A2 4A15                       		tst.b	(a5)			; check if that channel is running a tracker
000105A4 6A00                       		bpl.s	.fixch			; if not, branch
000105A6                            
000105A6 08D5 0005                  		bset	#cfbVol,(a5)		; set update volume flag (cleared by dUpdateVoiceFM)
000105AA 0895 0001                  		bclr	#cfbInt,(a5)		; reset sfx override flag
000105AE 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if the channel is a DAC channel
000105B4 6600                       		bne.s	.fixch			; if yes, skip
000105B6                            
000105B6 08D5 0000                  		bset	#cfbRest,(a5)		; Set channel resting flag
000105BA 43FA 0000                  		lea	VoiceBankMusic(pc),a1	; load music voice table to a1
000105BE 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
000105C2 4EBA FE44                  		jsr	dUpdateVoiceFM(pc)	; send FM voice for this channel
000105C6                            
000105C6                            .fixch
000105C6 3A5F                       		move.w	(sp)+,a5		; pop the current channel
000105C8                            .exit
000105C8 5497                       		addq.l	#2,(sp)			; go to next channel immediately
000105CA 4E75                       		rts
000105CC                            ; ---------------------------------------------------------------------------
000105CC                            ; There is nothing that would break even if the channel is not
000105CC                            ; running a tracker, so we do not bother checking
000105CC                            ; ---------------------------------------------------------------------------
000105CC                            
000105CC                            .psg
000105CC E80B                       		lsr.b	#4,d3			; make it easier to reference the right offset in the table
000105CE 3271 3000                  		movea.w	(a1,d3.w),a1		; get the SFX channel we were overriding
000105D2 0891 0001                  		bclr	#cfbInt,(a1)		; channel is not interrupted anymore
000105D6 08D1 0000                  		bset	#cfbRest,(a1)		; reset sfx override flag
000105DA                            
000105DA 0C29 00E0 0001             		cmp.b	#ctPSG4,cType(a1)	; check if this channel is in PSG4 mode
000105E0 66E6                       		bne.s	.exit			; if not, skip
000105E2 13E9 001B 00C0 0011        		move.b	cStatPSG4(a1),dPSG	; update PSG4 status to PSG port
000105EA 60DC                       		bra.s	.exit
000105EC                            ; ===========================================================================
000105EC                            ; ---------------------------------------------------------------------------
000105EC                            ; Tracker command for enabling LFO
000105EC                            ; ---------------------------------------------------------------------------
000105EC                            
000105EC                            dcsLFO:
000105EC 7000                       		moveq	#0,d0
000105EE 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
000105F2 224E                       		move.l	a6,a1			; load voice table to a1
000105F4                            
000105F4                            	dCALC_VOICE 9				; get address of the specific voice to a1
000105F4 EB48                     M 	lsl.w	#5,d0
000105F6 0640 0009                M 	add.w	#9,d0
000105FA D2C0                     M 	add.w	d0,a1
000105FC 1614                       		move.b	(a4),d3			; load LFO enable operators to d3
000105FE 45FA EBAA                  		lea	dAMSEn_Ops(pc),a2	; load Decay 1 Rate address table to a2
00010602 7C03                       		moveq	#4-1,d6			; prepare 4 operators to d5
00010604                            
00010604                            .decayloop
00010604 1219                       		move.b	(a1)+,d1		; get Decay 1 Level value from voice to d1
00010606 101A                       		move.b	(a2)+,d0		; load YM address to write to d0
00010608                            
00010608 D603                       		add.b	d3,d3			; check if LFO is enabled for this channeÃ¶
0001060A 6400                       		bcc.s	.noLFO			; if not, skip
0001060C 0001 0080                  		or.b	#$80,d1			; set enable LFO bit
00010610 4EBA EF2E                  		jsr	WriteChYM(pc)		; write to YM according to channel
00010614                            
00010614                            .noLFO
00010614 51CE FFEE                  		dbf	d6,.decayloop		; repeat for each Decay 1 Level operator
00010618                            
00010618 121C                       		move.b	(a4)+,d1		; load LFO frequency value from tracker
0001061A 7022                       		moveq	#$22,d0			; YM command: LFO
0001061C 4EBA EF2E                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
00010620                            
00010620 121C                       		move.b	(a4)+,d1		; load AMS, FMS & Panning from tracker
00010622 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel panning
00010626                            
00010626 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
00010628 4EFA EF10                  		jmp	dWriteYMchnInt(pc)	; write to YM according to channel
0001062C                            ; ===========================================================================
0001062C                            ; ---------------------------------------------------------------------------
0001062C                            ; Tracker command for resetting condition
0001062C                            ; ---------------------------------------------------------------------------
0001062C                            
0001062C                            dcResetCond:
0001062C 0895 0004                  		bclr	#cfbCond,(a5)		; reset condition flag
00010630 4E75                       		rts
00010632                            ; ===========================================================================
00010632                            ; ---------------------------------------------------------------------------
00010632                            ; Tracker command for writing to communications flags
00010632                            ; ---------------------------------------------------------------------------
00010632                            
00010632                            dcsComm:
00010632 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
00010636 7000                       		moveq	#0,d0
00010638 101C                       		move.b	(a4)+,d0		; load byte number to write from tracker
0001063A 139C 0000                  		move.b	(a4)+,(a1,d0.w)		; load vaue from tracker to communications byte
0001063E 4E75                       		rts
00010640                            ; ===========================================================================
00010640                            ; ---------------------------------------------------------------------------
00010640                            ; RAM addresses for special condition code
00010640                            ; ---------------------------------------------------------------------------
00010640                            
00010640                            dcCondRegTable:
00010640 C746 C4A6                  	dc.w hwVersion, mFlags	; 0
00010644 C4B8 C4B9                  	dc.w mTempoMain, mTempoSpeed	; 2
00010648 0000 0000                  	dc.w 0, 0			; 4
0001064C 0000 0000                  	dc.w 0, 0			; 6
00010650 0000 0000                  	dc.w 0, 0			; 8
00010654 0000 0000                  	dc.w 0, 0			; $A
00010658 0000 0000                  	dc.w 0, 0			; $C
0001065C 0000 0001                  	dc.w 0, cType			; $E
00010660                            ; ===========================================================================
00010660                            ; ---------------------------------------------------------------------------
00010660                            ; Tracker command for checking special RAM addresses
00010660                            ; ---------------------------------------------------------------------------
00010660                            
00010660                            dcCondReg:
00010660 101C                       		move.b	(a4)+,d0		; get value from tracker
00010662 1200                       		move.b	d0,d1			; copy to d1
00010664                            
00010664 0240 000F                  		and.w	#$F,d0			; get RAM table offset to d0
00010668 D040                       		add.w	d0,d0			; double it (each entry is 1 word)
0001066A 303B 00D4                  		move.w	dcCondRegTable(pc,d0.w),d0; get data to read from
0001066E 6B00                       		bmi.s	.gotit			; branch if if was a RAM address
00010670 D04D                       		add.w	a5,d0			; else it was a channel offset
00010672                            
00010672                            .gotit
00010672 3240                       		move.w	d0,a1			; get the desired address from d0 to a1
00010674 1011                       		move.b	(a1),d0			; read byte from it
00010676 6000                       		bra.s	dcCondCom
00010678                            ; ===========================================================================
00010678                            ; ---------------------------------------------------------------------------
00010678                            ; Tracker command for checking communications bytes
00010678                            ; ---------------------------------------------------------------------------
00010678                            
00010678                            dcCond:
00010678 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001067C 101C                       		move.b	(a4)+,d0		; load condition and offset from tracker to d0
0001067E 1200                       		move.b	d0,d1			; copy to d1
00010680 0240 000F                  		and.w	#$F,d0			; get offset only
00010684 1031 0000                  		move.b	(a1,d0.w),d0		; load value from communcations byte to d0
00010688                            
00010688                            dcCondCom:
00010688 0895 0004                  		bclr	#cfbCond,(a5)		; set condition to true
0001068C 0241 00F0                  		and.w	#$F0,d1			; get condition value only
00010690 E449                       		lsr.w	#2,d1			; shift 2 bits down (each entry is 4 bytes large)
00010692 B01C                       		cmp.b	(a4)+,d0		; check value against tracker byte
00010694 4EFB 1000                  		jmp	.cond(pc,d1.w)		; handle conditional code
00010698                            ; ===========================================================================
00010698                            ; ---------------------------------------------------------------------------
00010698                            ; Code for setting the condition flag
00010698                            ; ---------------------------------------------------------------------------
00010698                            
00010698                            .c	macro x
00010698                            	\x	.false
00010698                            	rts
00010698                                 endm
00010698                            
00010698                            .false
00010698 08D5 0004                  		bset	#cfbCond,(a5)		; set condition to false
0001069C                            
0001069C 4E75                       .cond	rts		; T
0001069E 4E75                       	rts
000106A0                            	.c bra.s	; F
000106A0 60F6                     M 	bra.s	.false
000106A2 4E75                     M 	rts
000106A4                            	.c bls.s	; HI
000106A4 63F2                     M 	bls.s	.false
000106A6 4E75                     M 	rts
000106A8                            	.c bhi.s	; LS
000106A8 62EE                     M 	bhi.s	.false
000106AA 4E75                     M 	rts
000106AC                            	.c blo.s	; HS/CC
000106AC 65EA                     M 	blo.s	.false
000106AE 4E75                     M 	rts
000106B0                            	.c bhs.s	; LO/CS
000106B0 64E6                     M 	bhs.s	.false
000106B2 4E75                     M 	rts
000106B4                            	.c beq.s	; NE
000106B4 67E2                     M 	beq.s	.false
000106B6 4E75                     M 	rts
000106B8                            	.c bne.s	; EQ
000106B8 66DE                     M 	bne.s	.false
000106BA 4E75                     M 	rts
000106BC                            	.c bvs.s	; VC
000106BC 69DA                     M 	bvs.s	.false
000106BE 4E75                     M 	rts
000106C0                            	.c bvc.s	; VS
000106C0 68D6                     M 	bvc.s	.false
000106C2 4E75                     M 	rts
000106C4                            	.c bmi.s	; PL
000106C4 6BD2                     M 	bmi.s	.false
000106C6 4E75                     M 	rts
000106C8                            	.c bpl.s	; MI
000106C8 6ACE                     M 	bpl.s	.false
000106CA 4E75                     M 	rts
000106CC                            	.c blt.s	; GE
000106CC 6DCA                     M 	blt.s	.false
000106CE 4E75                     M 	rts
000106D0                            	.c bge.s	; LT
000106D0 6CC6                     M 	bge.s	.false
000106D2 4E75                     M 	rts
000106D4                            	.c ble.s	; GT
000106D4 6FC2                     M 	ble.s	.false
000106D6 4E75                     M 	rts
000106D8                            	.c bgt.s	; LE
000106D8 6EBE                     M 	bgt.s	.false
000106DA 4E75                     M 	rts
000106DC                            ; ===========================================================================
000106DC                            ; ---------------------------------------------------------------------------
000106DC                            ; Tracker command for freezing the CPU. DEBUG FLAG
000106DC                            ; ---------------------------------------------------------------------------
000106DC                            
000106DC                            dcFreeze:
000106DC 6000 FFFE                  		bra.w	*		; Freeze CPU here
000106E0 4E75                       		rts
000106E2                            ; ===========================================================================
000106E2                            ; ---------------------------------------------------------------------------
000106E2                            ; Tracker command for debugging tracker data. DEBUG FLAG
000106E2                            ; ---------------------------------------------------------------------------
000106E2                            
000106E2                            dcTracker:
000106E2 50F8 C740                  		st	msChktracker.w	; set debug flag
000106E6 4E75                       		rts
000106E8                            ; ===========================================================================
000106E8                            ; ---------------------------------------------------------------------------
000106E8                            ; Check if a song is playing
000106E8                            ; ---------------------------------------------------------------------------
000106E8                            
000106E8                            dChkSongPlay:
000106E8 43F8 C4C4                  	lea	mDAC1.w,a1		; Music track RAM
000106EC 7209                       	moveq	#Mus_Ch-1,d1
000106EE                            
000106EE                            .ChkTracks:
000106EE 4A11                       	tst.b	cFlags(a1)		; Is this track playing?
000106F0 6B00                       	bmi.s	.Playing		; If so, branch
000106F2 43E9 002C                  	lea	cSize(a1),a1		; Next track
000106F6 51C9 FFF6                  	dbf	d1,.ChkTracks		; Loop
000106FA 7200                       	moveq	#0,d1
000106FC 4E75                       	rts
000106FE                            
000106FE                            .Playing:
000106FE 50C1                       	st	d1
00010700 4E75                       	rts
00010702                            ; ===========================================================================
00010702                            ; ---------------------------------------------------------------------------
00010702                            ; Define music and SFX
00010702                            ; ---------------------------------------------------------------------------
00010702                            
00010702                            	opt oz-				; disable zero-offset optimization
00010702                            
00010702 =00000082                  __sfx =		SFXoff
00010702 =0000000A                  __mus =		MusOff
00010702                            	include	"Sound/sfx.asm"
00010702                            
00010702                            
00010702                            ; ------------------------------------------------------------------------
00010702                            ; AMPS SFX list
00010702                            ; -------------------------------------------------------------------------
00010702                            
00010702                            ; -------------------------------------------------------------------------
00010702                            ; SFX index
00010702                            ; -------------------------------------------------------------------------
00010702                            
00010702                            SoundIndex:
00010702                            	ptrSFX	$00, Snd_Jump
00010702 =00000000                M .type	=	$00<<24
00010702                          M 	rept	narg-1
00010702 0000 0000                M 	dc.l	snd_jump|.type
00010706 =00000083                M __sfx	=	__sfx+1
00010706                          M 	shift
00010706                            	ptrSFX	$00, Snd_Skid
00010706 =00000000                M .type	=	$00<<24
00010706                          M 	rept	narg-1
00010706 0000 0000                M 	dc.l	snd_skid|.type
0001070A =00000084                M __sfx	=	__sfx+1
0001070A                          M 	shift
0001070A                            	ptrSFX	$00, Snd_Death
0001070A =00000000                M .type	=	$00<<24
0001070A                          M 	rept	narg-1
0001070A 0000 0000                M 	dc.l	snd_death|.type
0001070E =00000085                M __sfx	=	__sfx+1
0001070E                          M 	shift
0001070E                            	ptrSFX	$00, Snd_Push
0001070E =00000000                M .type	=	$00<<24
0001070E                          M 	rept	narg-1
0001070E 0000 0000                M 	dc.l	snd_push|.type
00010712 =00000086                M __sfx	=	__sfx+1
00010712                          M 	shift
00010712                            	ptrSFX	$00, Snd_Bubble
00010712 =00000000                M .type	=	$00<<24
00010712                          M 	rept	narg-1
00010712 0000 0000                M 	dc.l	snd_bubble|.type
00010716 =00000087                M __sfx	=	__sfx+1
00010716                          M 	shift
00010716                            	ptrSFX	$00, Snd_Drown
00010716 =00000000                M .type	=	$00<<24
00010716                          M 	rept	narg-1
00010716 0000 0000                M 	dc.l	snd_drown|.type
0001071A =00000088                M __sfx	=	__sfx+1
0001071A                          M 	shift
0001071A                            	ptrSFX	$00, Snd_DrownWarning
0001071A =00000000                M .type	=	$00<<24
0001071A                          M 	rept	narg-1
0001071A 0000 0000                M 	dc.l	snd_drownwarning|.type
0001071E =00000089                M __sfx	=	__sfx+1
0001071E                          M 	shift
0001071E                            	ptrSFX	$00, Snd_DrownCountdown
0001071E =00000000                M .type	=	$00<<24
0001071E                          M 	rept	narg-1
0001071E 0000 0000                M 	dc.l	snd_drowncountdown|.type
00010722 =0000008A                M __sfx	=	__sfx+1
00010722                          M 	shift
00010722                            	ptrSFX	$00, Snd_Checkpoint
00010722 =00000000                M .type	=	$00<<24
00010722                          M 	rept	narg-1
00010722 0000 0000                M 	dc.l	snd_checkpoint|.type
00010726 =0000008B                M __sfx	=	__sfx+1
00010726                          M 	shift
00010726                            	ptrSFX	$00, Snd_SpikeMove
00010726 =00000000                M .type	=	$00<<24
00010726                          M 	rept	narg-1
00010726 0000 0000                M 	dc.l	snd_spikemove|.type
0001072A =0000008C                M __sfx	=	__sfx+1
0001072A                          M 	shift
0001072A                            	ptrSFX	$00, Snd_Ring
0001072A =00000000                M .type	=	$00<<24
0001072A                          M 	rept	narg-1
0001072A 0000 0000                M 	dc.l	snd_ring|.type
0001072E =0000008D                M __sfx	=	__sfx+1
0001072E                          M 	shift
0001072E                            	ptrSFX	$00, Snd_RingLoss
0001072E =00000000                M .type	=	$00<<24
0001072E                          M 	rept	narg-1
0001072E 0000 0000                M 	dc.l	snd_ringloss|.type
00010732 =0000008E                M __sfx	=	__sfx+1
00010732                          M 	shift
00010732                            	ptrSFX	$00, Snd_Spring
00010732 =00000000                M .type	=	$00<<24
00010732                          M 	rept	narg-1
00010732 0000 0000                M 	dc.l	snd_spring|.type
00010736 =0000008F                M __sfx	=	__sfx+1
00010736                          M 	shift
00010736                            	ptrSFX	$00, Snd_Shield
00010736 =00000000                M .type	=	$00<<24
00010736                          M 	rept	narg-1
00010736 0000 0000                M 	dc.l	snd_shield|.type
0001073A =00000090                M __sfx	=	__sfx+1
0001073A                          M 	shift
0001073A                            	ptrSFX	$00, Snd_Splash
0001073A =00000000                M .type	=	$00<<24
0001073A                          M 	rept	narg-1
0001073A 0000 0000                M 	dc.l	snd_splash|.type
0001073E =00000091                M __sfx	=	__sfx+1
0001073E                          M 	shift
0001073E                            	ptrSFX	$00, Snd_Bumper
0001073E =00000000                M .type	=	$00<<24
0001073E                          M 	rept	narg-1
0001073E 0000 0000                M 	dc.l	snd_bumper|.type
00010742 =00000092                M __sfx	=	__sfx+1
00010742                          M 	shift
00010742                            	ptrSFX	$00, Snd_Switch
00010742 =00000000                M .type	=	$00<<24
00010742                          M 	rept	narg-1
00010742 0000 0000                M 	dc.l	snd_switch|.type
00010746 =00000093                M __sfx	=	__sfx+1
00010746                          M 	shift
00010746                            	ptrSFX	$00, Snd_Signpost
00010746 =00000000                M .type	=	$00<<24
00010746                          M 	rept	narg-1
00010746 0000 0000                M 	dc.l	snd_signpost|.type
0001074A =00000094                M __sfx	=	__sfx+1
0001074A                          M 	shift
0001074A                            	ptrSFX	$00, Snd_Collapse
0001074A =00000000                M .type	=	$00<<24
0001074A                          M 	rept	narg-1
0001074A 0000 0000                M 	dc.l	snd_collapse|.type
0001074E =00000095                M __sfx	=	__sfx+1
0001074E                          M 	shift
0001074E                            	ptrSFX	$00, Snd_WallSmash
0001074E =00000000                M .type	=	$00<<24
0001074E                          M 	rept	narg-1
0001074E 0000 0000                M 	dc.l	snd_wallsmash|.type
00010752 =00000096                M __sfx	=	__sfx+1
00010752                          M 	shift
00010752                            	ptrSFX	$00, Snd_Rumble
00010752 =00000000                M .type	=	$00<<24
00010752                          M 	rept	narg-1
00010752 0000 0000                M 	dc.l	snd_rumble|.type
00010756 =00000097                M __sfx	=	__sfx+1
00010756                          M 	shift
00010756                            	ptrSFX	$00, Snd_Warp
00010756 =00000000                M .type	=	$00<<24
00010756                          M 	rept	narg-1
00010756 0000 0000                M 	dc.l	snd_warp|.type
0001075A =00000098                M __sfx	=	__sfx+1
0001075A                          M 	shift
0001075A                            	ptrSFX	$00, Snd_BossHit
0001075A =00000000                M .type	=	$00<<24
0001075A                          M 	rept	narg-1
0001075A 0000 0000                M 	dc.l	snd_bosshit|.type
0001075E =00000099                M __sfx	=	__sfx+1
0001075E                          M 	shift
0001075E                            	ptrSFX	$00, Snd_Bomb
0001075E =00000000                M .type	=	$00<<24
0001075E                          M 	rept	narg-1
0001075E 0000 0000                M 	dc.l	snd_bomb|.type
00010762 =0000009A                M __sfx	=	__sfx+1
00010762                          M 	shift
00010762                            	ptrSFX	$00, Snd_BreakItem
00010762 =00000000                M .type	=	$00<<24
00010762                          M 	rept	narg-1
00010762 0000 0000                M 	dc.l	snd_breakitem|.type
00010766 =0000009B                M __sfx	=	__sfx+1
00010766                          M 	shift
00010766                            	ptrSFX	$00, Snd_FloorBounce
00010766 =00000000                M .type	=	$00<<24
00010766                          M 	rept	narg-1
00010766 0000 0000                M 	dc.l	snd_floorbounce|.type
0001076A =0000009C                M __sfx	=	__sfx+1
0001076A                          M 	shift
0001076A                            	ptrSFX	$00, Snd_Charge
0001076A =00000000                M .type	=	$00<<24
0001076A                          M 	rept	narg-1
0001076A 0000 0000                M 	dc.l	snd_charge|.type
0001076E =0000009D                M __sfx	=	__sfx+1
0001076E                          M 	shift
0001076E                            	ptrSFX	$00, Snd_ChargeStop
0001076E =00000000                M .type	=	$00<<24
0001076E                          M 	rept	narg-1
0001076E 0000 0000                M 	dc.l	snd_chargestop|.type
00010772 =0000009E                M __sfx	=	__sfx+1
00010772                          M 	shift
00010772                            	ptrSFX	$00, Snd_ChargeRelease
00010772 =00000000                M .type	=	$00<<24
00010772                          M 	rept	narg-1
00010772 0000 0000                M 	dc.l	snd_chargerelease|.type
00010776 =0000009F                M __sfx	=	__sfx+1
00010776                          M 	shift
00010776                            	ptrSFX	$00, Snd_DiamondBreak
00010776 =00000000                M .type	=	$00<<24
00010776                          M 	rept	narg-1
00010776 0000 0000                M 	dc.l	snd_diamondbreak|.type
0001077A =000000A0                M __sfx	=	__sfx+1
0001077A                          M 	shift
0001077A                            SoundIndex_End:
0001077A                            
0001077A                            ; -------------------------------------------------------------------------
0001077A                            	include	"Sound/music.asm"
0001077A                            
0001077A                            
0001077A                            ; ------------------------------------------------------------------------
0001077A                            ; AMPS music list
0001077A                            ; -------------------------------------------------------------------------
0001077A                            
0001077A                            ; -------------------------------------------------------------------------
0001077A                            ; Music index
0001077A                            ; -------------------------------------------------------------------------
0001077A                            
0001077A                            MusicIndex:
0001077A                            	ptrMusic	Mus_WWZ,		$00
0001077A                          M 	rept	narg/2
0001077A 0000 0000                M 	dc.l	(($00)<<24)|mus_wwz
0001077E =0000000B                M __mus	=	__mus+1
0001077E                          M 	shift
0001077E                          M 	shift
0001077E                            	ptrMusic	Mus_WWZ,		$00
0001077E                          M 	rept	narg/2
0001077E 0000 0000                M 	dc.l	(($00)<<24)|mus_wwz
00010782 =0000000C                M __mus	=	__mus+1
00010782                          M 	shift
00010782                          M 	shift
00010782                            	ptrMusic	Mus_Boss,		$00
00010782                          M 	rept	narg/2
00010782 0000 0000                M 	dc.l	(($00)<<24)|mus_boss
00010786 =0000000D                M __mus	=	__mus+1
00010786                          M 	shift
00010786                          M 	shift
00010786                            MusicIndex_End:
00010786                            
00010786                            ; -------------------------------------------------------------------------
00010786                            ; ===========================================================================
00010786                            ; ---------------------------------------------------------------------------
00010786                            ; Define samples
00010786                            ; ---------------------------------------------------------------------------
00010786                            
00010786 =00000080                  __samp =	$80
00010786                            	include	"Sound/dac.asm"
00010786                            
00010786                            
00010786                            ; ------------------------------------------------------------------------
00010786                            ; AMPS DAC list
00010786                            ; -------------------------------------------------------------------------
00010786                            
00010786                            ; -------------------------------------------------------------------------
00010786                            ; Sample 68k PCM list
00010786                            ; -------------------------------------------------------------------------
00010786                            
00010786                            SampleList:
00010786                            	sample	$0000, Stop,		Stop,		Stop		; 80 (THIS IS A REST NOTE, DO NOT EDIT...)
00010786 =00000080                M dstop	=	__samp
00010786 =00000081                M __samp	=	__samp+1
00010786 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010789 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
0001078C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001078F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010792 FF00                     M 	dc.w	$0000-$100
00010794 0000                     M 	dc.w	0
00010796                            	sample	$0100, Kick,		Stop,		Kick		; 81
00010796 =00000081                M dkick	=	__samp
00010796 =00000082                M __samp	=	__samp+1
00010796 0000 00                  M 	dc.b	swf_kick&$ff,((swf_kick>>$08)&$7f)|$80,(swf_kick>>$0f)&$ff
00010799 0000 00                  M 	dc.b	(swfr_kick-1)&$ff,(((swfr_kick-1)>>$08)&$7f)|$80,((swfr_kick-1)>>$0f)&$ff
0001079C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001079F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
000107A2 0000                     M 	dc.w	$0100-$100
000107A4 0000                     M 	dc.w	0
000107A6                            	sample	$0100, Kick,		Stop,		Kick2		; 82
000107A6 =00000082                M dkick2	=	__samp
000107A6 =00000083                M __samp	=	__samp+1
000107A6 0000 00                  M 	dc.b	swf_kick&$ff,((swf_kick>>$08)&$7f)|$80,(swf_kick>>$0f)&$ff
000107A9 0000 00                  M 	dc.b	(swfr_kick-1)&$ff,(((swfr_kick-1)>>$08)&$7f)|$80,((swfr_kick-1)>>$0f)&$ff
000107AC 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
000107AF 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
000107B2 0000                     M 	dc.w	$0100-$100
000107B4 0000                     M 	dc.w	0
000107B6                            	sample	$0100, Snare,		Stop,		Snare		; 83
000107B6 =00000083                M dsnare	=	__samp
000107B6 =00000084                M __samp	=	__samp+1
000107B6 0000 00                  M 	dc.b	swf_snare&$ff,((swf_snare>>$08)&$7f)|$80,(swf_snare>>$0f)&$ff
000107B9 0000 00                  M 	dc.b	(swfr_snare-1)&$ff,(((swfr_snare-1)>>$08)&$7f)|$80,((swfr_snare-1)>>$0f)&$ff
000107BC 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
000107BF 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
000107C2 0000                     M 	dc.w	$0100-$100
000107C4 0000                     M 	dc.w	0
000107C6                            	sample	$0100, Snare,		Stop,		Snare2		; 84
000107C6 =00000084                M dsnare2	=	__samp
000107C6 =00000085                M __samp	=	__samp+1
000107C6 0000 00                  M 	dc.b	swf_snare&$ff,((swf_snare>>$08)&$7f)|$80,(swf_snare>>$0f)&$ff
000107C9 0000 00                  M 	dc.b	(swfr_snare-1)&$ff,(((swfr_snare-1)>>$08)&$7f)|$80,((swfr_snare-1)>>$0f)&$ff
000107CC 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
000107CF 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
000107D2 0000                     M 	dc.w	$0100-$100
000107D4 0000                     M 	dc.w	0
000107D6                            	sample	$0100, Tom,		Stop,		Tom		; 85
000107D6 =00000085                M dtom	=	__samp
000107D6 =00000086                M __samp	=	__samp+1
000107D6 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
000107D9 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
000107DC 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
000107DF 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
000107E2 0000                     M 	dc.w	$0100-$100
000107E4 0000                     M 	dc.w	0
000107E6                            	sample	$0160, Tom,		Stop,		TomH 		; 86
000107E6 =00000086                M dtomh	=	__samp
000107E6 =00000087                M __samp	=	__samp+1
000107E6 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
000107E9 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
000107EC 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
000107EF 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
000107F2 0060                     M 	dc.w	$0160-$100
000107F4 0000                     M 	dc.w	0
000107F6                            	sample	$0130, Tom,		Stop,		TomMid		; 87
000107F6 =00000087                M dtommid	=	__samp
000107F6 =00000088                M __samp	=	__samp+1
000107F6 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
000107F9 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
000107FC 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
000107FF 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010802 0030                     M 	dc.w	$0130-$100
00010804 0000                     M 	dc.w	0
00010806                            	sample	$0100, Tom,		Stop,		TomMidL		; 88
00010806 =00000088                M dtommidl	=	__samp
00010806 =00000089                M __samp	=	__samp+1
00010806 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010809 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
0001080C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001080F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010812 0000                     M 	dc.w	$0100-$100
00010814 0000                     M 	dc.w	0
00010816                            	sample	$00E0, Tom,		Stop,		TomL		; 89
00010816 =00000089                M dtoml	=	__samp
00010816 =0000008A                M __samp	=	__samp+1
00010816 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010819 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
0001081C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001081F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010822 FFE0                     M 	dc.w	$00e0-$100
00010824 0000                     M 	dc.w	0
00010826                            	sample	$0100, Stop,		Stop,		Stop2		; 8A
00010826 =0000008A                M dstop2	=	__samp
00010826 =0000008B                M __samp	=	__samp+1
00010826 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010829 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
0001082C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001082F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010832 0000                     M 	dc.w	$0100-$100
00010834 0000                     M 	dc.w	0
00010836                            	sample	$0100, Stop,		Stop,		Stop3		; 8B
00010836 =0000008B                M dstop3	=	__samp
00010836 =0000008C                M __samp	=	__samp+1
00010836 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010839 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
0001083C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001083F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010842 0000                     M 	dc.w	$0100-$100
00010844 0000                     M 	dc.w	0
00010846                            	sample	$0104, Title,		Title,		Title		; 8C
00010846 =0000008C                M dtitle	=	__samp
00010846 =0000008D                M __samp	=	__samp+1
00010846 0000 00                  M 	dc.b	swf_title&$ff,((swf_title>>$08)&$7f)|$80,(swf_title>>$0f)&$ff
00010849 0000 00                  M 	dc.b	(swfr_title-1)&$ff,(((swfr_title-1)>>$08)&$7f)|$80,((swfr_title-1)>>$0f)&$ff
0001084C 0000 00                  M 	dc.b	swf_title&$ff,((swf_title>>$08)&$7f)|$80,(swf_title>>$0f)&$ff
0001084F 0000 00                  M 	dc.b	(swfr_title-1)&$ff,(((swfr_title-1)>>$08)&$7f)|$80,((swfr_title-1)>>$0f)&$ff
00010852 0004                     M 	dc.w	$0104-$100
00010854 0000                     M 	dc.w	0
00010856                            	sample	$0104, Sega,		Stop,		Sega		; 8D
00010856 =0000008D                M dsega	=	__samp
00010856 =0000008E                M __samp	=	__samp+1
00010856 0000 00                  M 	dc.b	swf_sega&$ff,((swf_sega>>$08)&$7f)|$80,(swf_sega>>$0f)&$ff
00010859 0000 00                  M 	dc.b	(swfr_sega-1)&$ff,(((swfr_sega-1)>>$08)&$7f)|$80,((swfr_sega-1)>>$0f)&$ff
0001085C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001085F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010862 0004                     M 	dc.w	$0104-$100
00010864 0000                     M 	dc.w	0
00010866                            	sample	$0104, Punch,		Stop,		Punch		; 8E
00010866 =0000008E                M dpunch	=	__samp
00010866 =0000008F                M __samp	=	__samp+1
00010866 0000 00                  M 	dc.b	swf_punch&$ff,((swf_punch>>$08)&$7f)|$80,(swf_punch>>$0f)&$ff
00010869 0000 00                  M 	dc.b	(swfr_punch-1)&$ff,(((swfr_punch-1)>>$08)&$7f)|$80,((swfr_punch-1)>>$0f)&$ff
0001086C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001086F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010872 0004                     M 	dc.w	$0104-$100
00010874 0000                     M 	dc.w	0
00010876                            	sample	$0114, EndingSong,	EndingSong,	EndingSong	; 8F
00010876 =0000008F                M dendingsong	=	__samp
00010876 =00000090                M __samp	=	__samp+1
00010876 0000 00                  M 	dc.b	swf_endingsong&$ff,((swf_endingsong>>$08)&$7f)|$80,(swf_endingsong>>$0f)&$ff
00010879 0000 00                  M 	dc.b	(swfr_endingsong-1)&$ff,(((swfr_endingsong-1)>>$08)&$7f)|$80,((swfr_endingsong-1)>>$0f)&$ff
0001087C 0000 00                  M 	dc.b	swf_endingsong&$ff,((swf_endingsong>>$08)&$7f)|$80,(swf_endingsong>>$0f)&$ff
0001087F 0000 00                  M 	dc.b	(swfr_endingsong-1)&$ff,(((swfr_endingsong-1)>>$08)&$7f)|$80,((swfr_endingsong-1)>>$0f)&$ff
00010882 0014                     M 	dc.w	$0114-$100
00010884 0000                     M 	dc.w	0
00010886                            	sample	$0114, BinBowie,	Stop,		BinBowie	; 90
00010886 =00000090                M dbinbowie	=	__samp
00010886 =00000091                M __samp	=	__samp+1
00010886 0000 00                  M 	dc.b	swf_binbowie&$ff,((swf_binbowie>>$08)&$7f)|$80,(swf_binbowie>>$0f)&$ff
00010889 0000 00                  M 	dc.b	(swfr_binbowie-1)&$ff,(((swfr_binbowie-1)>>$08)&$7f)|$80,((swfr_binbowie-1)>>$0f)&$ff
0001088C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001088F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010892 0014                     M 	dc.w	$0114-$100
00010894 0000                     M 	dc.w	0
00010896                            	sample	$0114, Wacky_Base_Loud,	Stop,		WackyBase	; 91
00010896 =00000091                M dwackybase	=	__samp
00010896 =00000092                M __samp	=	__samp+1
00010896 0000 00                  M 	dc.b	swf_wacky_base_loud&$ff,((swf_wacky_base_loud>>$08)&$7f)|$80,(swf_wacky_base_loud>>$0f)&$ff
00010899 0000 00                  M 	dc.b	(swfr_wacky_base_loud-1)&$ff,(((swfr_wacky_base_loud-1)>>$08)&$7f)|$80,((swfr_wacky_base_loud-1)>>$0f)&$ff
0001089C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
0001089F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
000108A2 0014                     M 	dc.w	$0114-$100
000108A4 0000                     M 	dc.w	0
000108A6                            SampleList_End:
000108A6                            
000108A6                            ; -------------------------------------------------------------------------
000108A6                            ; ===========================================================================
000108A6                            ; ---------------------------------------------------------------------------
000108A6                            ; Define volume envelopes and their data
000108A6                            ; ---------------------------------------------------------------------------
000108A6                            
000108A6 =00000001                  __venv =	$01
000108A6                            	include	"Sound/psg.asm"
000108A6                            
000108A6                            
000108A6                            ; ------------------------------------------------------------------------
000108A6                            ; AMPS PSG envelopes
000108A6                            ; -------------------------------------------------------------------------
000108A6                            
000108A6                            ; -------------------------------------------------------------------------
000108A6                            ; PSG envelope index
000108A6                            ; -------------------------------------------------------------------------
000108A6                            
000108A6                            VolEnvs:
000108A6                            	volenv	01
000108A6                          M 	rept	narg
000108A6 =00000001                M v01	=	__venv
000108A6 0000 0000                M 	dc.l	vd01
000108AA =00000002                M __venv	=	__venv+1
000108AA                          M 	shift
000108AA                            	volenv	02
000108AA                          M 	rept	narg
000108AA =00000002                M v02	=	__venv
000108AA 0000 0000                M 	dc.l	vd02
000108AE =00000003                M __venv	=	__venv+1
000108AE                          M 	shift
000108AE                            	volenv	03
000108AE                          M 	rept	narg
000108AE =00000003                M v03	=	__venv
000108AE 0000 0000                M 	dc.l	vd03
000108B2 =00000004                M __venv	=	__venv+1
000108B2                          M 	shift
000108B2                            	volenv	04
000108B2                          M 	rept	narg
000108B2 =00000004                M v04	=	__venv
000108B2 0000 0000                M 	dc.l	vd04
000108B6 =00000005                M __venv	=	__venv+1
000108B6                          M 	shift
000108B6                            	volenv	05
000108B6                          M 	rept	narg
000108B6 =00000005                M v05	=	__venv
000108B6 0000 0000                M 	dc.l	vd05
000108BA =00000006                M __venv	=	__venv+1
000108BA                          M 	shift
000108BA                            	volenv	06
000108BA                          M 	rept	narg
000108BA =00000006                M v06	=	__venv
000108BA 0000 0000                M 	dc.l	vd06
000108BE =00000007                M __venv	=	__venv+1
000108BE                          M 	shift
000108BE                            	volenv	07
000108BE                          M 	rept	narg
000108BE =00000007                M v07	=	__venv
000108BE 0000 0000                M 	dc.l	vd07
000108C2 =00000008                M __venv	=	__venv+1
000108C2                          M 	shift
000108C2                            	volenv	08
000108C2                          M 	rept	narg
000108C2 =00000008                M v08	=	__venv
000108C2 0000 0000                M 	dc.l	vd08
000108C6 =00000009                M __venv	=	__venv+1
000108C6                          M 	shift
000108C6                            	volenv	09
000108C6                          M 	rept	narg
000108C6 =00000009                M v09	=	__venv
000108C6 0000 0000                M 	dc.l	vd09
000108CA =0000000A                M __venv	=	__venv+1
000108CA                          M 	shift
000108CA                            	volenv	0A
000108CA                          M 	rept	narg
000108CA =0000000A                M v0a	=	__venv
000108CA 0000 0000                M 	dc.l	vd0a
000108CE =0000000B                M __venv	=	__venv+1
000108CE                          M 	shift
000108CE                            	volenv	0B
000108CE                          M 	rept	narg
000108CE =0000000B                M v0b	=	__venv
000108CE 0000 0000                M 	dc.l	vd0b
000108D2 =0000000C                M __venv	=	__venv+1
000108D2                          M 	shift
000108D2                            	volenv	0C
000108D2                          M 	rept	narg
000108D2 =0000000C                M v0c	=	__venv
000108D2 0000 0000                M 	dc.l	vd0c
000108D6 =0000000D                M __venv	=	__venv+1
000108D6                          M 	shift
000108D6                            	volenv	0D
000108D6                          M 	rept	narg
000108D6 =0000000D                M v0d	=	__venv
000108D6 0000 0000                M 	dc.l	vd0d
000108DA =0000000E                M __venv	=	__venv+1
000108DA                          M 	shift
000108DA                            VolEnvs_End:
000108DA                            	opt ae-
000108DA                            
000108DA                            ; -------------------------------------------------------------------------
000108DA                            ; PSG envelope data
000108DA                            ; -------------------------------------------------------------------------
000108DA                            
000108DA 0000 0001 0101 0202        vd01:	dc.b	$00, $00, $00, $01, $01, $01, $02, $02
000108E2 0203 0303 0404 0405        	dc.b	$02, $03, $03, $03, $04, $04, $04, $05
000108EA 0505 0606 0607 82          	dc.b	$05, $05, $06, $06, $06, $07, eHold
000108F1                            
000108F1 0002 0406 0810 82          vd02:	dc.b	$00, $02, $04, $06, $08, $10, eHold
000108F8                            
000108F8 0000 0101 0202 0303        vd03:	dc.b	$00, $00, $01, $01, $02, $02, $03, $03
00010900 0404 0505 0606 0707        	dc.b	$04, $04, $05, $05, $06, $06, $07, $07
00010908 82                         	dc.b	eHold
00010909                            
00010909 0000 0203 0404 0505        vd04:	dc.b	$00, $00, $02, $03, $04, $04, $05, $05
00010911 0506 82                    	dc.b	$05, $06, eHold
00010914                            
00010914 0000 0000 0000 0000        vd05:	dc.b	$00, $00, $00, $00, $00, $00, $00, $00
0001091C 0000 0101 0101 0101        	dc.b	$00, $00, $01, $01, $01, $01, $01, $01
00010924 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
0001092C 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010934 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
0001093C 0482                       	dc.b	$04, eHold
0001093E                            
0001093E 0303 0302 0202 0201        vd06:	dc.b	$03, $03, $03, $02, $02, $02, $02, $01
00010946 0101 0000 0000 82          	dc.b	$01, $01, $00, $00, $00, $00, eHold
0001094D                            
0001094D 0000 0000 0000 0101        vd07:	dc.b	$00, $00, $00, $00, $00, $00, $01, $01
00010955 0101 0102 0202 0202        	dc.b	$01, $01, $01, $02, $02, $02, $02, $02
0001095D 0303 0304 0404 0505        	dc.b	$03, $03, $03, $04, $04, $04, $05, $05
00010965 0506 0782                  	dc.b	$05, $06, $07, eHold
00010969                            
00010969 0000 0000 0001 0101        vd08:	dc.b	$00, $00, $00, $00, $00, $01, $01, $01
00010971 0101 0202 0202 0202        	dc.b	$01, $01, $02, $02, $02, $02, $02, $02
00010979 0303 0303 0304 0404        	dc.b	$03, $03, $03, $03, $03, $04, $04, $04
00010981 0404 0505 0505 0506        	dc.b	$04, $04, $05, $05, $05, $05, $05, $06
00010989 0606 0606 0707 0782        	dc.b	$06, $06, $06, $06, $07, $07, $07, eHold
00010991                            
00010991 0001 0203 0405 0607        vd09:	dc.b	$00, $01, $02, $03, $04, $05, $06, $07
00010999 0809 0A0B 0C0D 0E0F        	dc.b	$08, $09, $0A, $0B, $0C, $0D, $0E, $0F
000109A1 82                         	dc.b	eHold
000109A2                            	even
000109A2                            
000109A2 0000 0000 0000 0000        vd0A:	dc.b	$00, $00, $00, $00, $00, $00, $00, $00
000109AA 0000 0101 0101 0101        	dc.b	$00, $00, $01, $01, $01, $01, $01, $01
000109B2 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
000109BA 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
000109C2 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
000109CA 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
000109D2 0202 0303 0303 0303        	dc.b	$02, $02, $03, $03, $03, $03, $03, $03
000109DA 0303 0303 0304 82          	dc.b	$03, $03, $03, $03, $03, $04, eHold
000109E2 00                         	even
000109E2                            
000109E2 0404 0403 0303 0202        vd0B:	dc.b	$04, $04, $04, $03, $03, $03, $02, $02
000109EA 0201 0101 0101 0101        	dc.b	$02, $01, $01, $01, $01, $01, $01, $01
000109F2 0202 0202 0203 0303        	dc.b	$02, $02, $02, $02, $02, $03, $03, $03
000109FA 0303 0482                  	dc.b	$03, $03, $04, eHold
000109FE                            	even
000109FE                            
000109FE 0404 0303 0202 0101        vd0C:	dc.b	$04, $04, $03, $03, $02, $02, $01, $01
00010A06 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010A0E 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010A16 0101 0202 0202 0202        	dc.b	$01, $01, $02, $02, $02, $02, $02, $02
00010A1E 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010A26 0202 0202 0202 0303        	dc.b	$02, $02, $02, $02, $02, $02, $03, $03
00010A2E 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010A36 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010A3E 0303 0404 0404 0404        	dc.b	$03, $03, $04, $04, $04, $04, $04, $04
00010A46 0404 0404 0404 0404        	dc.b	$04, $04, $04, $04, $04, $04, $04, $04
00010A4E 0404 0404 0404 0505        	dc.b	$04, $04, $04, $04, $04, $04, $05, $05
00010A56 0505 0505 0505 0505        	dc.b	$05, $05, $05, $05, $05, $05, $05, $05
00010A5E 0505 0505 0505 0505        	dc.b	$05, $05, $05, $05, $05, $05, $05, $05
00010A66 0505 0606 0606 0606        	dc.b	$05, $05, $06, $06, $06, $06, $06, $06
00010A6E 0606 0606 0606 0606        	dc.b	$06, $06, $06, $06, $06, $06, $06, $06
00010A76 0606 0606 0606 0782        	dc.b	$06, $06, $06, $06, $06, $06, $07, eHold
00010A7E                            	even
00010A7E                            
00010A7E 0E0D 0C0B 0A09 0807        vd0D:	dc.b	$0E, $0D, $0C, $0B, $0A, $09, $08, $07
00010A86 0605 0403 0201 000F        	dc.b	$06, $05, $04, $03, $02, $01, $00, $0F
00010A8E 82                         	dc.b	eHold
00010A90 00                         	even
00010A90                            
00010A90                            ; -------------------------------------------------------------------------
00010A90                            ; ===========================================================================
00010A90                            ; ---------------------------------------------------------------------------
00010A90                            ; Include music, sound effects and voice table
00010A90                            ; ---------------------------------------------------------------------------
00010A90                            
00010A90                            VoiceBankMusic:
00010A90 =00000000                  sPatNum = 0
00010A90                            	include "Sound/unipatchmus.asm"; include universal Voice banks
00010A90                            
00010A90                            
00010A90                            ; ------------------------------------------------------------------------
00010A90                            ; AMPS music patch list
00010A90                            ; -------------------------------------------------------------------------
00010A90                            
00010A90                            	; Patch $00
00010A90                            	; $2A
00010A90                            	; $02, $32, $03, $01,	$5F, $5F, $9F, $9C
00010A90                            	; $9F, $1F, $9F, $04,	$00, $00, $00, $07
00010A90                            	; $15, $15, $15, $F5,	$05, $08, $0C, $1A
00010A90                            	spAlgorithm	$02
00010A90 =00000001                M spatnum	=	spatnum+1
00010A90 =00000002                M spal	=	val
00010A90                            	spFeedback	$05
00010A90 =00000005                M spfe	=	val
00010A90                            	spDetune	$00, $00, $03, $00
00010A90 =00000000                M spde1	=	op1
00010A90 =00000000                M spde2	=	op2
00010A90 =00000003                M spde3	=	op3
00010A90 =00000000                M spde4	=	op4
00010A90                            	spMultiple	$02, $03, $02, $01
00010A90 =00000002                M spmu1	=	op1
00010A90 =00000003                M spmu2	=	op2
00010A90 =00000002                M spmu3	=	op3
00010A90 =00000001                M spmu4	=	op4
00010A90                            	spRateScale	$01, $02, $01, $02
00010A90 =00000001                M sprs1	=	op1
00010A90 =00000002                M sprs2	=	op2
00010A90 =00000001                M sprs3	=	op3
00010A90 =00000002                M sprs4	=	op4
00010A90                            	spAttackRt	$1F, $1F, $1F, $1C
00010A90 =0000001F                M spar1	=	op1
00010A90 =0000001F                M spar2	=	op2
00010A90 =0000001F                M spar3	=	op3
00010A90 =0000001C                M spar4	=	op4
00010A90                            	spAmpMod	$01, $01, $00, $00
00010A90 =00000001                M spam1	=	op1
00010A90 =00000001                M spam2	=	op2
00010A90 =00000000                M spam3	=	op3
00010A90 =00000000                M spam4	=	op4
00010A90                            	spSustainRt	$1F, $1F, $1F, $04
00010A90 =0000001F                M spsr1	=	op1
00010A90 =0000001F                M spsr2	=	op2
00010A90 =0000001F                M spsr3	=	op3
00010A90 =00000004                M spsr4	=	op4
00010A90                            	spDecayRt	$00, $00, $00, $07
00010A90 =00000000                M spdr1	=	op1
00010A90 =00000000                M spdr2	=	op2
00010A90 =00000000                M spdr3	=	op3
00010A90 =00000007                M spdr4	=	op4
00010A90                            	spSustainLv	$01, $01, $01, $0F
00010A90 =00000001                M spsl1	=	op1
00010A90 =00000001                M spsl2	=	op2
00010A90 =00000001                M spsl3	=	op3
00010A90 =0000000F                M spsl4	=	op4
00010A90                            	spReleaseRt	$05, $05, $05, $05
00010A90 =00000005                M sprr1	=	op1
00010A90 =00000005                M sprr2	=	op2
00010A90 =00000005                M sprr3	=	op3
00010A90 =00000005                M sprr4	=	op4
00010A90                            	spSSGEG		$00, $00, $00, $00
00010A90 =00000000                M spss1	=	op1
00010A90 =00000000                M spss2	=	op2
00010A90 =00000000                M spss3	=	op3
00010A90 =00000000                M spss4	=	op4
00010A90                            	spTotalLv	$05, $0C, $08, $1A
00010A90 =00000005                M sptl1	=	op1
00010A90 =0000000C                M sptl2	=	op2
00010A90 =00000008                M sptl3	=	op3
00010A90 =0000001A                M sptl4	=	op4
00010A90 2A                       M 	dc.b	(spfe<<3)+spal
00010A91 =00000080                M sptlmask4	set	$80
00010A91 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010A91 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010A91 =00000000                M sptlmask1	set	((spal=7)<<7)
00010A91 0232 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010A95 5F5F 9F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010A99 9F1F 9F04                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010A9D 0000 0007                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010AA1 1515 15F5                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010AA5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010AA9 0508 0C9A                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010AAD 4E41 54                  M 	dc.b	'NAT'
00010AB0                            
00010AB0                            	; Patch $01
00010AB0                            	; $38
00010AB0                            	; $01, $00, $01, $00,	$1F, $1F, $1F, $1F
00010AB0                            	; $00, $00, $00, $0D,	$0E, $00, $00, $1F
00010AB0                            	; $00, $00, $00, $30,	$1C, $11, $28, $04
00010AB0                            	spAlgorithm	$00
00010AB0 =00000002                M spatnum	=	spatnum+1
00010AB0 =00000000                M spal	=	val
00010AB0                            	spFeedback	$07
00010AB0 =00000007                M spfe	=	val
00010AB0                            	spDetune	$00, $00, $00, $00
00010AB0 =00000000                M spde1	=	op1
00010AB0 =00000000                M spde2	=	op2
00010AB0 =00000000                M spde3	=	op3
00010AB0 =00000000                M spde4	=	op4
00010AB0                            	spMultiple	$01, $01, $00, $00
00010AB0 =00000001                M spmu1	=	op1
00010AB0 =00000001                M spmu2	=	op2
00010AB0 =00000000                M spmu3	=	op3
00010AB0 =00000000                M spmu4	=	op4
00010AB0                            	spRateScale	$00, $00, $00, $00
00010AB0 =00000000                M sprs1	=	op1
00010AB0 =00000000                M sprs2	=	op2
00010AB0 =00000000                M sprs3	=	op3
00010AB0 =00000000                M sprs4	=	op4
00010AB0                            	spAttackRt	$1F, $1F, $1F, $1F
00010AB0 =0000001F                M spar1	=	op1
00010AB0 =0000001F                M spar2	=	op2
00010AB0 =0000001F                M spar3	=	op3
00010AB0 =0000001F                M spar4	=	op4
00010AB0                            	spAmpMod	$00, $00, $00, $00
00010AB0 =00000000                M spam1	=	op1
00010AB0 =00000000                M spam2	=	op2
00010AB0 =00000000                M spam3	=	op3
00010AB0 =00000000                M spam4	=	op4
00010AB0                            	spSustainRt	$00, $00, $00, $0D
00010AB0 =00000000                M spsr1	=	op1
00010AB0 =00000000                M spsr2	=	op2
00010AB0 =00000000                M spsr3	=	op3
00010AB0 =0000000D                M spsr4	=	op4
00010AB0                            	spDecayRt	$0E, $00, $00, $1F
00010AB0 =0000000E                M spdr1	=	op1
00010AB0 =00000000                M spdr2	=	op2
00010AB0 =00000000                M spdr3	=	op3
00010AB0 =0000001F                M spdr4	=	op4
00010AB0                            	spSustainLv	$00, $00, $00, $03
00010AB0 =00000000                M spsl1	=	op1
00010AB0 =00000000                M spsl2	=	op2
00010AB0 =00000000                M spsl3	=	op3
00010AB0 =00000003                M spsl4	=	op4
00010AB0                            	spReleaseRt	$00, $00, $00, $00
00010AB0 =00000000                M sprr1	=	op1
00010AB0 =00000000                M sprr2	=	op2
00010AB0 =00000000                M sprr3	=	op3
00010AB0 =00000000                M sprr4	=	op4
00010AB0                            	spSSGEG		$00, $00, $00, $00
00010AB0 =00000000                M spss1	=	op1
00010AB0 =00000000                M spss2	=	op2
00010AB0 =00000000                M spss3	=	op3
00010AB0 =00000000                M spss4	=	op4
00010AB0                            	spTotalLv	$1C, $28, $11, $04
00010AB0 =0000001C                M sptl1	=	op1
00010AB0 =00000028                M sptl2	=	op2
00010AB0 =00000011                M sptl3	=	op3
00010AB0 =00000004                M sptl4	=	op4
00010AB0 38                       M 	dc.b	(spfe<<3)+spal
00010AB1 =00000080                M sptlmask4	set	$80
00010AB1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010AB1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010AB1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010AB1 0100 0100                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010AB5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010AB9 0000 000D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010ABD 0E00 001F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010AC1 0000 0030                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010AC5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010AC9 1C11 2884                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010ACD 4E41 54                  M 	dc.b	'NAT'
00010AD0                            
00010AD0                            	; Patch $02
00010AD0                            	; $21
00010AD0                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $1F
00010AD0                            	; $0B, $08, $0F, $0B,	$01, $13, $1F, $1F
00010AD0                            	; $14, $B4, $44, $14,	$7F, $7F, $14, $04
00010AD0                            	spAlgorithm	$01
00010AD0 =00000003                M spatnum	=	spatnum+1
00010AD0 =00000001                M spal	=	val
00010AD0                            	spFeedback	$04
00010AD0 =00000004                M spfe	=	val
00010AD0                            	spDetune	$00, $00, $00, $00
00010AD0 =00000000                M spde1	=	op1
00010AD0 =00000000                M spde2	=	op2
00010AD0 =00000000                M spde3	=	op3
00010AD0 =00000000                M spde4	=	op4
00010AD0                            	spMultiple	$00, $00, $00, $00
00010AD0 =00000000                M spmu1	=	op1
00010AD0 =00000000                M spmu2	=	op2
00010AD0 =00000000                M spmu3	=	op3
00010AD0 =00000000                M spmu4	=	op4
00010AD0                            	spRateScale	$00, $00, $00, $00
00010AD0 =00000000                M sprs1	=	op1
00010AD0 =00000000                M sprs2	=	op2
00010AD0 =00000000                M sprs3	=	op3
00010AD0 =00000000                M sprs4	=	op4
00010AD0                            	spAttackRt	$1F, $1F, $1F, $1F
00010AD0 =0000001F                M spar1	=	op1
00010AD0 =0000001F                M spar2	=	op2
00010AD0 =0000001F                M spar3	=	op3
00010AD0 =0000001F                M spar4	=	op4
00010AD0                            	spAmpMod	$00, $00, $00, $00
00010AD0 =00000000                M spam1	=	op1
00010AD0 =00000000                M spam2	=	op2
00010AD0 =00000000                M spam3	=	op3
00010AD0 =00000000                M spam4	=	op4
00010AD0                            	spSustainRt	$0B, $0F, $08, $0B
00010AD0 =0000000B                M spsr1	=	op1
00010AD0 =0000000F                M spsr2	=	op2
00010AD0 =00000008                M spsr3	=	op3
00010AD0 =0000000B                M spsr4	=	op4
00010AD0                            	spDecayRt	$01, $1F, $13, $1F
00010AD0 =00000001                M spdr1	=	op1
00010AD0 =0000001F                M spdr2	=	op2
00010AD0 =00000013                M spdr3	=	op3
00010AD0 =0000001F                M spdr4	=	op4
00010AD0                            	spSustainLv	$01, $04, $0B, $01
00010AD0 =00000001                M spsl1	=	op1
00010AD0 =00000004                M spsl2	=	op2
00010AD0 =0000000B                M spsl3	=	op3
00010AD0 =00000001                M spsl4	=	op4
00010AD0                            	spReleaseRt	$04, $04, $04, $04
00010AD0 =00000004                M sprr1	=	op1
00010AD0 =00000004                M sprr2	=	op2
00010AD0 =00000004                M sprr3	=	op3
00010AD0 =00000004                M sprr4	=	op4
00010AD0                            	spSSGEG		$00, $00, $00, $00
00010AD0 =00000000                M spss1	=	op1
00010AD0 =00000000                M spss2	=	op2
00010AD0 =00000000                M spss3	=	op3
00010AD0 =00000000                M spss4	=	op4
00010AD0                            	spTotalLv	$7F, $14, $7F, $04
00010AD0 =0000007F                M sptl1	=	op1
00010AD0 =00000014                M sptl2	=	op2
00010AD0 =0000007F                M sptl3	=	op3
00010AD0 =00000004                M sptl4	=	op4
00010AD0 21                       M 	dc.b	(spfe<<3)+spal
00010AD1 =00000080                M sptlmask4	set	$80
00010AD1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010AD1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010AD1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010AD1 0000 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010AD5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010AD9 0B08 0F0B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010ADD 0113 1F1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010AE1 14B4 4414                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010AE5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010AE9 7F7F 1484                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010AED 4E41 54                  M 	dc.b	'NAT'
00010AF0                            
00010AF0                            	; Patch $03
00010AF0                            	; $34
00010AF0                            	; $74, $02, $6B, $02,	$1F, $53, $53, $11
00010AF0                            	; $11, $1F, $12, $01,	$00, $00, $00, $00
00010AF0                            	; $2B, $0B, $F9, $69,	$2A, $0C, $13, $04
00010AF0                            	spAlgorithm	$04
00010AF0 =00000004                M spatnum	=	spatnum+1
00010AF0 =00000004                M spal	=	val
00010AF0                            	spFeedback	$06
00010AF0 =00000006                M spfe	=	val
00010AF0                            	spDetune	$07, $06, $00, $00
00010AF0 =00000007                M spde1	=	op1
00010AF0 =00000006                M spde2	=	op2
00010AF0 =00000000                M spde3	=	op3
00010AF0 =00000000                M spde4	=	op4
00010AF0                            	spMultiple	$04, $0B, $02, $02
00010AF0 =00000004                M spmu1	=	op1
00010AF0 =0000000B                M spmu2	=	op2
00010AF0 =00000002                M spmu3	=	op3
00010AF0 =00000002                M spmu4	=	op4
00010AF0                            	spRateScale	$00, $01, $01, $00
00010AF0 =00000000                M sprs1	=	op1
00010AF0 =00000001                M sprs2	=	op2
00010AF0 =00000001                M sprs3	=	op3
00010AF0 =00000000                M sprs4	=	op4
00010AF0                            	spAttackRt	$1F, $13, $13, $11
00010AF0 =0000001F                M spar1	=	op1
00010AF0 =00000013                M spar2	=	op2
00010AF0 =00000013                M spar3	=	op3
00010AF0 =00000011                M spar4	=	op4
00010AF0                            	spAmpMod	$00, $00, $00, $00
00010AF0 =00000000                M spam1	=	op1
00010AF0 =00000000                M spam2	=	op2
00010AF0 =00000000                M spam3	=	op3
00010AF0 =00000000                M spam4	=	op4
00010AF0                            	spSustainRt	$11, $12, $1F, $01
00010AF0 =00000011                M spsr1	=	op1
00010AF0 =00000012                M spsr2	=	op2
00010AF0 =0000001F                M spsr3	=	op3
00010AF0 =00000001                M spsr4	=	op4
00010AF0                            	spDecayRt	$00, $00, $00, $00
00010AF0 =00000000                M spdr1	=	op1
00010AF0 =00000000                M spdr2	=	op2
00010AF0 =00000000                M spdr3	=	op3
00010AF0 =00000000                M spdr4	=	op4
00010AF0                            	spSustainLv	$02, $0F, $00, $06
00010AF0 =00000002                M spsl1	=	op1
00010AF0 =0000000F                M spsl2	=	op2
00010AF0 =00000000                M spsl3	=	op3
00010AF0 =00000006                M spsl4	=	op4
00010AF0                            	spReleaseRt	$0B, $09, $0B, $09
00010AF0 =0000000B                M sprr1	=	op1
00010AF0 =00000009                M sprr2	=	op2
00010AF0 =0000000B                M sprr3	=	op3
00010AF0 =00000009                M sprr4	=	op4
00010AF0                            	spSSGEG		$00, $00, $00, $00
00010AF0 =00000000                M spss1	=	op1
00010AF0 =00000000                M spss2	=	op2
00010AF0 =00000000                M spss3	=	op3
00010AF0 =00000000                M spss4	=	op4
00010AF0                            	spTotalLv	$2A, $13, $0C, $04
00010AF0 =0000002A                M sptl1	=	op1
00010AF0 =00000013                M sptl2	=	op2
00010AF0 =0000000C                M sptl3	=	op3
00010AF0 =00000004                M sptl4	=	op4
00010AF0 34                       M 	dc.b	(spfe<<3)+spal
00010AF1 =00000080                M sptlmask4	set	$80
00010AF1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010AF1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010AF1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010AF1 7402 6B02                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010AF5 1F53 5311                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010AF9 111F 1201                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010AFD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010B01 2B0B F969                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010B05 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010B09 2A8C 1384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010B0D 4E41 54                  M 	dc.b	'NAT'
00010B10                            
00010B10                            	; Patch $04
00010B10                            	; $24
00010B10                            	; $10, $01, $31, $11,	$9B, $5C, $1B, $5C
00010B10                            	; $0A, $10, $0A, $10,	$03, $04, $03, $04
00010B10                            	; $1F, $0C, $8F, $0C,	$06, $05, $04, $05
00010B10                            	spAlgorithm	$04
00010B10 =00000005                M spatnum	=	spatnum+1
00010B10 =00000004                M spal	=	val
00010B10                            	spFeedback	$04
00010B10 =00000004                M spfe	=	val
00010B10                            	spDetune	$01, $03, $00, $01
00010B10 =00000001                M spde1	=	op1
00010B10 =00000003                M spde2	=	op2
00010B10 =00000000                M spde3	=	op3
00010B10 =00000001                M spde4	=	op4
00010B10                            	spMultiple	$00, $01, $01, $01
00010B10 =00000000                M spmu1	=	op1
00010B10 =00000001                M spmu2	=	op2
00010B10 =00000001                M spmu3	=	op3
00010B10 =00000001                M spmu4	=	op4
00010B10                            	spRateScale	$02, $00, $01, $01
00010B10 =00000002                M sprs1	=	op1
00010B10 =00000000                M sprs2	=	op2
00010B10 =00000001                M sprs3	=	op3
00010B10 =00000001                M sprs4	=	op4
00010B10                            	spAttackRt	$1B, $1B, $1C, $1C
00010B10 =0000001B                M spar1	=	op1
00010B10 =0000001B                M spar2	=	op2
00010B10 =0000001C                M spar3	=	op3
00010B10 =0000001C                M spar4	=	op4
00010B10                            	spAmpMod	$00, $00, $00, $00
00010B10 =00000000                M spam1	=	op1
00010B10 =00000000                M spam2	=	op2
00010B10 =00000000                M spam3	=	op3
00010B10 =00000000                M spam4	=	op4
00010B10                            	spSustainRt	$0A, $0A, $10, $10
00010B10 =0000000A                M spsr1	=	op1
00010B10 =0000000A                M spsr2	=	op2
00010B10 =00000010                M spsr3	=	op3
00010B10 =00000010                M spsr4	=	op4
00010B10                            	spDecayRt	$03, $03, $04, $04
00010B10 =00000003                M spdr1	=	op1
00010B10 =00000003                M spdr2	=	op2
00010B10 =00000004                M spdr3	=	op3
00010B10 =00000004                M spdr4	=	op4
00010B10                            	spSustainLv	$01, $08, $00, $00
00010B10 =00000001                M spsl1	=	op1
00010B10 =00000008                M spsl2	=	op2
00010B10 =00000000                M spsl3	=	op3
00010B10 =00000000                M spsl4	=	op4
00010B10                            	spReleaseRt	$0F, $0F, $0C, $0C
00010B10 =0000000F                M sprr1	=	op1
00010B10 =0000000F                M sprr2	=	op2
00010B10 =0000000C                M sprr3	=	op3
00010B10 =0000000C                M sprr4	=	op4
00010B10                            	spSSGEG		$00, $00, $00, $00
00010B10 =00000000                M spss1	=	op1
00010B10 =00000000                M spss2	=	op2
00010B10 =00000000                M spss3	=	op3
00010B10 =00000000                M spss4	=	op4
00010B10                            	spTotalLv	$06, $04, $05, $05
00010B10 =00000006                M sptl1	=	op1
00010B10 =00000004                M sptl2	=	op2
00010B10 =00000005                M sptl3	=	op3
00010B10 =00000005                M sptl4	=	op4
00010B10 24                       M 	dc.b	(spfe<<3)+spal
00010B11 =00000080                M sptlmask4	set	$80
00010B11 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010B11 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010B11 =00000000                M sptlmask1	set	((spal=7)<<7)
00010B11 1001 3111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010B15 9B5C 1B5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010B19 0A10 0A10                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010B1D 0304 0304                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010B21 1F0C 8F0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010B25 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010B29 0685 0485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010B2D 4E41 54                  M 	dc.b	'NAT'
00010B30                            
00010B30                            	; Patch $05
00010B30                            	; $38
00010B30                            	; $56, $15, $10, $72,	$1F, $1F, $1F, $1F
00010B30                            	; $08, $08, $0A, $00,	$07, $07, $07, $06
00010B30                            	; $F0, $F5, $F6, $F8,	$2C, $28, $12, $05
00010B30                            	spAlgorithm	$00
00010B30 =00000006                M spatnum	=	spatnum+1
00010B30 =00000000                M spal	=	val
00010B30                            	spFeedback	$07
00010B30 =00000007                M spfe	=	val
00010B30                            	spDetune	$05, $01, $01, $07
00010B30 =00000005                M spde1	=	op1
00010B30 =00000001                M spde2	=	op2
00010B30 =00000001                M spde3	=	op3
00010B30 =00000007                M spde4	=	op4
00010B30                            	spMultiple	$06, $00, $05, $02
00010B30 =00000006                M spmu1	=	op1
00010B30 =00000000                M spmu2	=	op2
00010B30 =00000005                M spmu3	=	op3
00010B30 =00000002                M spmu4	=	op4
00010B30                            	spRateScale	$00, $00, $00, $00
00010B30 =00000000                M sprs1	=	op1
00010B30 =00000000                M sprs2	=	op2
00010B30 =00000000                M sprs3	=	op3
00010B30 =00000000                M sprs4	=	op4
00010B30                            	spAttackRt	$1F, $1F, $1F, $1F
00010B30 =0000001F                M spar1	=	op1
00010B30 =0000001F                M spar2	=	op2
00010B30 =0000001F                M spar3	=	op3
00010B30 =0000001F                M spar4	=	op4
00010B30                            	spAmpMod	$00, $00, $00, $00
00010B30 =00000000                M spam1	=	op1
00010B30 =00000000                M spam2	=	op2
00010B30 =00000000                M spam3	=	op3
00010B30 =00000000                M spam4	=	op4
00010B30                            	spSustainRt	$08, $0A, $08, $00
00010B30 =00000008                M spsr1	=	op1
00010B30 =0000000A                M spsr2	=	op2
00010B30 =00000008                M spsr3	=	op3
00010B30 =00000000                M spsr4	=	op4
00010B30                            	spDecayRt	$07, $07, $07, $06
00010B30 =00000007                M spdr1	=	op1
00010B30 =00000007                M spdr2	=	op2
00010B30 =00000007                M spdr3	=	op3
00010B30 =00000006                M spdr4	=	op4
00010B30                            	spSustainLv	$0F, $0F, $0F, $0F
00010B30 =0000000F                M spsl1	=	op1
00010B30 =0000000F                M spsl2	=	op2
00010B30 =0000000F                M spsl3	=	op3
00010B30 =0000000F                M spsl4	=	op4
00010B30                            	spReleaseRt	$00, $06, $05, $08
00010B30 =00000000                M sprr1	=	op1
00010B30 =00000006                M sprr2	=	op2
00010B30 =00000005                M sprr3	=	op3
00010B30 =00000008                M sprr4	=	op4
00010B30                            	spSSGEG		$00, $00, $00, $00
00010B30 =00000000                M spss1	=	op1
00010B30 =00000000                M spss2	=	op2
00010B30 =00000000                M spss3	=	op3
00010B30 =00000000                M spss4	=	op4
00010B30                            	spTotalLv	$2C, $12, $28, $05
00010B30 =0000002C                M sptl1	=	op1
00010B30 =00000012                M sptl2	=	op2
00010B30 =00000028                M sptl3	=	op3
00010B30 =00000005                M sptl4	=	op4
00010B30 38                       M 	dc.b	(spfe<<3)+spal
00010B31 =00000080                M sptlmask4	set	$80
00010B31 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010B31 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010B31 =00000000                M sptlmask1	set	((spal=7)<<7)
00010B31 5615 1072                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010B35 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010B39 0808 0A00                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010B3D 0707 0706                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010B41 F0F5 F6F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010B45 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010B49 2C28 1285                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010B4D 4E41 54                  M 	dc.b	'NAT'
00010B50                            
00010B50                            	; Patch $06
00010B50                            	; $02
00010B50                            	; $71, $32, $06, $01,	$5F, $5E, $9F, $9C
00010B50                            	; $02, $06, $05, $04,	$08, $07, $08, $07
00010B50                            	; $F8, $F8, $F8, $F8,	$00, $10, $07, $05
00010B50                            	spAlgorithm	$02
00010B50 =00000007                M spatnum	=	spatnum+1
00010B50 =00000002                M spal	=	val
00010B50                            	spFeedback	$00
00010B50 =00000000                M spfe	=	val
00010B50                            	spDetune	$07, $00, $03, $00
00010B50 =00000007                M spde1	=	op1
00010B50 =00000000                M spde2	=	op2
00010B50 =00000003                M spde3	=	op3
00010B50 =00000000                M spde4	=	op4
00010B50                            	spMultiple	$01, $06, $02, $01
00010B50 =00000001                M spmu1	=	op1
00010B50 =00000006                M spmu2	=	op2
00010B50 =00000002                M spmu3	=	op3
00010B50 =00000001                M spmu4	=	op4
00010B50                            	spRateScale	$01, $02, $01, $02
00010B50 =00000001                M sprs1	=	op1
00010B50 =00000002                M sprs2	=	op2
00010B50 =00000001                M sprs3	=	op3
00010B50 =00000002                M sprs4	=	op4
00010B50                            	spAttackRt	$1F, $1F, $1E, $1C
00010B50 =0000001F                M spar1	=	op1
00010B50 =0000001F                M spar2	=	op2
00010B50 =0000001E                M spar3	=	op3
00010B50 =0000001C                M spar4	=	op4
00010B50                            	spAmpMod	$00, $00, $00, $00
00010B50 =00000000                M spam1	=	op1
00010B50 =00000000                M spam2	=	op2
00010B50 =00000000                M spam3	=	op3
00010B50 =00000000                M spam4	=	op4
00010B50                            	spSustainRt	$02, $05, $06, $04
00010B50 =00000002                M spsr1	=	op1
00010B50 =00000005                M spsr2	=	op2
00010B50 =00000006                M spsr3	=	op3
00010B50 =00000004                M spsr4	=	op4
00010B50                            	spDecayRt	$08, $08, $07, $07
00010B50 =00000008                M spdr1	=	op1
00010B50 =00000008                M spdr2	=	op2
00010B50 =00000007                M spdr3	=	op3
00010B50 =00000007                M spdr4	=	op4
00010B50                            	spSustainLv	$0F, $0F, $0F, $0F
00010B50 =0000000F                M spsl1	=	op1
00010B50 =0000000F                M spsl2	=	op2
00010B50 =0000000F                M spsl3	=	op3
00010B50 =0000000F                M spsl4	=	op4
00010B50                            	spReleaseRt	$08, $08, $08, $08
00010B50 =00000008                M sprr1	=	op1
00010B50 =00000008                M sprr2	=	op2
00010B50 =00000008                M sprr3	=	op3
00010B50 =00000008                M sprr4	=	op4
00010B50                            	spSSGEG		$00, $00, $00, $00
00010B50 =00000000                M spss1	=	op1
00010B50 =00000000                M spss2	=	op2
00010B50 =00000000                M spss3	=	op3
00010B50 =00000000                M spss4	=	op4
00010B50                            	spTotalLv	$00, $07, $10, $05
00010B50 =00000000                M sptl1	=	op1
00010B50 =00000007                M sptl2	=	op2
00010B50 =00000010                M sptl3	=	op3
00010B50 =00000005                M sptl4	=	op4
00010B50 02                       M 	dc.b	(spfe<<3)+spal
00010B51 =00000080                M sptlmask4	set	$80
00010B51 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010B51 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010B51 =00000000                M sptlmask1	set	((spal=7)<<7)
00010B51 7132 0601                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010B55 5F5E 9F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010B59 0206 0504                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010B5D 0807 0807                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010B61 F8F8 F8F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010B65 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010B69 0010 0785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010B6D 4E41 54                  M 	dc.b	'NAT'
00010B70                            
00010B70                            	; Patch $07
00010B70                            	; $3D
00010B70                            	; $01, $01, $01, $01,	$8E, $52, $14, $4C
00010B70                            	; $08, $08, $0E, $03,	$00, $00, $00, $00
00010B70                            	; $1F, $1F, $1F, $1F,	$1B, $05, $05, $05
00010B70                            	spAlgorithm	$05
00010B70 =00000008                M spatnum	=	spatnum+1
00010B70 =00000005                M spal	=	val
00010B70                            	spFeedback	$07
00010B70 =00000007                M spfe	=	val
00010B70                            	spDetune	$00, $00, $00, $00
00010B70 =00000000                M spde1	=	op1
00010B70 =00000000                M spde2	=	op2
00010B70 =00000000                M spde3	=	op3
00010B70 =00000000                M spde4	=	op4
00010B70                            	spMultiple	$01, $01, $01, $01
00010B70 =00000001                M spmu1	=	op1
00010B70 =00000001                M spmu2	=	op2
00010B70 =00000001                M spmu3	=	op3
00010B70 =00000001                M spmu4	=	op4
00010B70                            	spRateScale	$02, $00, $01, $01
00010B70 =00000002                M sprs1	=	op1
00010B70 =00000000                M sprs2	=	op2
00010B70 =00000001                M sprs3	=	op3
00010B70 =00000001                M sprs4	=	op4
00010B70                            	spAttackRt	$0E, $14, $12, $0C
00010B70 =0000000E                M spar1	=	op1
00010B70 =00000014                M spar2	=	op2
00010B70 =00000012                M spar3	=	op3
00010B70 =0000000C                M spar4	=	op4
00010B70                            	spAmpMod	$00, $00, $00, $00
00010B70 =00000000                M spam1	=	op1
00010B70 =00000000                M spam2	=	op2
00010B70 =00000000                M spam3	=	op3
00010B70 =00000000                M spam4	=	op4
00010B70                            	spSustainRt	$08, $0E, $08, $03
00010B70 =00000008                M spsr1	=	op1
00010B70 =0000000E                M spsr2	=	op2
00010B70 =00000008                M spsr3	=	op3
00010B70 =00000003                M spsr4	=	op4
00010B70                            	spDecayRt	$00, $00, $00, $00
00010B70 =00000000                M spdr1	=	op1
00010B70 =00000000                M spdr2	=	op2
00010B70 =00000000                M spdr3	=	op3
00010B70 =00000000                M spdr4	=	op4
00010B70                            	spSustainLv	$01, $01, $01, $01
00010B70 =00000001                M spsl1	=	op1
00010B70 =00000001                M spsl2	=	op2
00010B70 =00000001                M spsl3	=	op3
00010B70 =00000001                M spsl4	=	op4
00010B70                            	spReleaseRt	$0F, $0F, $0F, $0F
00010B70 =0000000F                M sprr1	=	op1
00010B70 =0000000F                M sprr2	=	op2
00010B70 =0000000F                M sprr3	=	op3
00010B70 =0000000F                M sprr4	=	op4
00010B70                            	spSSGEG		$00, $00, $00, $00
00010B70 =00000000                M spss1	=	op1
00010B70 =00000000                M spss2	=	op2
00010B70 =00000000                M spss3	=	op3
00010B70 =00000000                M spss4	=	op4
00010B70                            	spTotalLv	$1B, $05, $05, $05
00010B70 =0000001B                M sptl1	=	op1
00010B70 =00000005                M sptl2	=	op2
00010B70 =00000005                M sptl3	=	op3
00010B70 =00000005                M sptl4	=	op4
00010B70 3D                       M 	dc.b	(spfe<<3)+spal
00010B71 =00000080                M sptlmask4	set	$80
00010B71 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010B71 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010B71 =00000000                M sptlmask1	set	((spal=7)<<7)
00010B71 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010B75 8E52 144C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010B79 0808 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010B7D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010B81 1F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010B85 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010B89 1B85 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010B8D 4E41 54                  M 	dc.b	'NAT'
00010B90                            
00010B90                            	; Patch $08
00010B90                            	; $0D
00010B90                            	; $77, $65, $05, $15,	$1F, $5F, $5F, $5F
00010B90                            	; $00, $10, $08, $10,	$00, $03, $05, $04
00010B90                            	; $0F, $FC, $8C, $CC,	$1F, $05, $05, $05
00010B90                            	spAlgorithm	$05
00010B90 =00000009                M spatnum	=	spatnum+1
00010B90 =00000005                M spal	=	val
00010B90                            	spFeedback	$01
00010B90 =00000001                M spfe	=	val
00010B90                            	spDetune	$07, $00, $06, $01
00010B90 =00000007                M spde1	=	op1
00010B90 =00000000                M spde2	=	op2
00010B90 =00000006                M spde3	=	op3
00010B90 =00000001                M spde4	=	op4
00010B90                            	spMultiple	$07, $05, $05, $05
00010B90 =00000007                M spmu1	=	op1
00010B90 =00000005                M spmu2	=	op2
00010B90 =00000005                M spmu3	=	op3
00010B90 =00000005                M spmu4	=	op4
00010B90                            	spRateScale	$00, $01, $01, $01
00010B90 =00000000                M sprs1	=	op1
00010B90 =00000001                M sprs2	=	op2
00010B90 =00000001                M sprs3	=	op3
00010B90 =00000001                M sprs4	=	op4
00010B90                            	spAttackRt	$1F, $1F, $1F, $1F
00010B90 =0000001F                M spar1	=	op1
00010B90 =0000001F                M spar2	=	op2
00010B90 =0000001F                M spar3	=	op3
00010B90 =0000001F                M spar4	=	op4
00010B90                            	spAmpMod	$00, $00, $00, $00
00010B90 =00000000                M spam1	=	op1
00010B90 =00000000                M spam2	=	op2
00010B90 =00000000                M spam3	=	op3
00010B90 =00000000                M spam4	=	op4
00010B90                            	spSustainRt	$00, $08, $10, $10
00010B90 =00000000                M spsr1	=	op1
00010B90 =00000008                M spsr2	=	op2
00010B90 =00000010                M spsr3	=	op3
00010B90 =00000010                M spsr4	=	op4
00010B90                            	spDecayRt	$00, $05, $03, $04
00010B90 =00000000                M spdr1	=	op1
00010B90 =00000005                M spdr2	=	op2
00010B90 =00000003                M spdr3	=	op3
00010B90 =00000004                M spdr4	=	op4
00010B90                            	spSustainLv	$00, $08, $0F, $0C
00010B90 =00000000                M spsl1	=	op1
00010B90 =00000008                M spsl2	=	op2
00010B90 =0000000F                M spsl3	=	op3
00010B90 =0000000C                M spsl4	=	op4
00010B90                            	spReleaseRt	$0F, $0C, $0C, $0C
00010B90 =0000000F                M sprr1	=	op1
00010B90 =0000000C                M sprr2	=	op2
00010B90 =0000000C                M sprr3	=	op3
00010B90 =0000000C                M sprr4	=	op4
00010B90                            	spSSGEG		$00, $00, $00, $00
00010B90 =00000000                M spss1	=	op1
00010B90 =00000000                M spss2	=	op2
00010B90 =00000000                M spss3	=	op3
00010B90 =00000000                M spss4	=	op4
00010B90                            	spTotalLv	$1F, $05, $05, $05
00010B90 =0000001F                M sptl1	=	op1
00010B90 =00000005                M sptl2	=	op2
00010B90 =00000005                M sptl3	=	op3
00010B90 =00000005                M sptl4	=	op4
00010B90 0D                       M 	dc.b	(spfe<<3)+spal
00010B91 =00000080                M sptlmask4	set	$80
00010B91 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010B91 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010B91 =00000000                M sptlmask1	set	((spal=7)<<7)
00010B91 7765 0515                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010B95 1F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010B99 0010 0810                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010B9D 0003 0504                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010BA1 0FFC 8CCC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010BA5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010BA9 1F85 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010BAD 4E41 54                  M 	dc.b	'NAT'
00010BB0                            
00010BB0                            	; Patch $09
00010BB0                            	; $32
00010BB0                            	; $71, $0D, $33, $01,	$5F, $99, $5F, $94
00010BB0                            	; $05, $05, $05, $07,	$02, $02, $02, $02
00010BB0                            	; $11, $11, $11, $72,	$23, $2D, $26, $05
00010BB0                            	spAlgorithm	$02
00010BB0 =0000000A                M spatnum	=	spatnum+1
00010BB0 =00000002                M spal	=	val
00010BB0                            	spFeedback	$06
00010BB0 =00000006                M spfe	=	val
00010BB0                            	spDetune	$07, $03, $00, $00
00010BB0 =00000007                M spde1	=	op1
00010BB0 =00000003                M spde2	=	op2
00010BB0 =00000000                M spde3	=	op3
00010BB0 =00000000                M spde4	=	op4
00010BB0                            	spMultiple	$01, $03, $0D, $01
00010BB0 =00000001                M spmu1	=	op1
00010BB0 =00000003                M spmu2	=	op2
00010BB0 =0000000D                M spmu3	=	op3
00010BB0 =00000001                M spmu4	=	op4
00010BB0                            	spRateScale	$01, $01, $02, $02
00010BB0 =00000001                M sprs1	=	op1
00010BB0 =00000001                M sprs2	=	op2
00010BB0 =00000002                M sprs3	=	op3
00010BB0 =00000002                M sprs4	=	op4
00010BB0                            	spAttackRt	$1F, $1F, $19, $14
00010BB0 =0000001F                M spar1	=	op1
00010BB0 =0000001F                M spar2	=	op2
00010BB0 =00000019                M spar3	=	op3
00010BB0 =00000014                M spar4	=	op4
00010BB0                            	spAmpMod	$00, $00, $00, $00
00010BB0 =00000000                M spam1	=	op1
00010BB0 =00000000                M spam2	=	op2
00010BB0 =00000000                M spam3	=	op3
00010BB0 =00000000                M spam4	=	op4
00010BB0                            	spSustainRt	$05, $05, $05, $07
00010BB0 =00000005                M spsr1	=	op1
00010BB0 =00000005                M spsr2	=	op2
00010BB0 =00000005                M spsr3	=	op3
00010BB0 =00000007                M spsr4	=	op4
00010BB0                            	spDecayRt	$02, $02, $02, $02
00010BB0 =00000002                M spdr1	=	op1
00010BB0 =00000002                M spdr2	=	op2
00010BB0 =00000002                M spdr3	=	op3
00010BB0 =00000002                M spdr4	=	op4
00010BB0                            	spSustainLv	$01, $01, $01, $07
00010BB0 =00000001                M spsl1	=	op1
00010BB0 =00000001                M spsl2	=	op2
00010BB0 =00000001                M spsl3	=	op3
00010BB0 =00000007                M spsl4	=	op4
00010BB0                            	spReleaseRt	$01, $01, $01, $02
00010BB0 =00000001                M sprr1	=	op1
00010BB0 =00000001                M sprr2	=	op2
00010BB0 =00000001                M sprr3	=	op3
00010BB0 =00000002                M sprr4	=	op4
00010BB0                            	spSSGEG		$00, $00, $00, $00
00010BB0 =00000000                M spss1	=	op1
00010BB0 =00000000                M spss2	=	op2
00010BB0 =00000000                M spss3	=	op3
00010BB0 =00000000                M spss4	=	op4
00010BB0                            	spTotalLv	$23, $26, $2D, $05
00010BB0 =00000023                M sptl1	=	op1
00010BB0 =00000026                M sptl2	=	op2
00010BB0 =0000002D                M sptl3	=	op3
00010BB0 =00000005                M sptl4	=	op4
00010BB0 32                       M 	dc.b	(spfe<<3)+spal
00010BB1 =00000080                M sptlmask4	set	$80
00010BB1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010BB1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010BB1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010BB1 710D 3301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010BB5 5F99 5F94                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010BB9 0505 0507                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010BBD 0202 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010BC1 1111 1172                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010BC5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010BC9 232D 2685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010BCD 4E41 54                  M 	dc.b	'NAT'
00010BD0                            
00010BD0                            	; Patch $0A
00010BD0                            	; $08
00010BD0                            	; $0A, $70, $30, $00,	$1F, $1F, $5F, $5F
00010BD0                            	; $12, $0E, $0A, $0A,	$00, $04, $04, $03
00010BD0                            	; $2F, $2F, $2F, $2F,	$22, $2E, $13, $04
00010BD0                            	spAlgorithm	$00
00010BD0 =0000000B                M spatnum	=	spatnum+1
00010BD0 =00000000                M spal	=	val
00010BD0                            	spFeedback	$01
00010BD0 =00000001                M spfe	=	val
00010BD0                            	spDetune	$00, $03, $07, $00
00010BD0 =00000000                M spde1	=	op1
00010BD0 =00000003                M spde2	=	op2
00010BD0 =00000007                M spde3	=	op3
00010BD0 =00000000                M spde4	=	op4
00010BD0                            	spMultiple	$0A, $00, $00, $00
00010BD0 =0000000A                M spmu1	=	op1
00010BD0 =00000000                M spmu2	=	op2
00010BD0 =00000000                M spmu3	=	op3
00010BD0 =00000000                M spmu4	=	op4
00010BD0                            	spRateScale	$00, $01, $00, $01
00010BD0 =00000000                M sprs1	=	op1
00010BD0 =00000001                M sprs2	=	op2
00010BD0 =00000000                M sprs3	=	op3
00010BD0 =00000001                M sprs4	=	op4
00010BD0                            	spAttackRt	$1F, $1F, $1F, $1F
00010BD0 =0000001F                M spar1	=	op1
00010BD0 =0000001F                M spar2	=	op2
00010BD0 =0000001F                M spar3	=	op3
00010BD0 =0000001F                M spar4	=	op4
00010BD0                            	spAmpMod	$00, $00, $00, $00
00010BD0 =00000000                M spam1	=	op1
00010BD0 =00000000                M spam2	=	op2
00010BD0 =00000000                M spam3	=	op3
00010BD0 =00000000                M spam4	=	op4
00010BD0                            	spSustainRt	$12, $0A, $0E, $0A
00010BD0 =00000012                M spsr1	=	op1
00010BD0 =0000000A                M spsr2	=	op2
00010BD0 =0000000E                M spsr3	=	op3
00010BD0 =0000000A                M spsr4	=	op4
00010BD0                            	spDecayRt	$00, $04, $04, $03
00010BD0 =00000000                M spdr1	=	op1
00010BD0 =00000004                M spdr2	=	op2
00010BD0 =00000004                M spdr3	=	op3
00010BD0 =00000003                M spdr4	=	op4
00010BD0                            	spSustainLv	$02, $02, $02, $02
00010BD0 =00000002                M spsl1	=	op1
00010BD0 =00000002                M spsl2	=	op2
00010BD0 =00000002                M spsl3	=	op3
00010BD0 =00000002                M spsl4	=	op4
00010BD0                            	spReleaseRt	$0F, $0F, $0F, $0F
00010BD0 =0000000F                M sprr1	=	op1
00010BD0 =0000000F                M sprr2	=	op2
00010BD0 =0000000F                M sprr3	=	op3
00010BD0 =0000000F                M sprr4	=	op4
00010BD0                            	spSSGEG		$00, $00, $00, $00
00010BD0 =00000000                M spss1	=	op1
00010BD0 =00000000                M spss2	=	op2
00010BD0 =00000000                M spss3	=	op3
00010BD0 =00000000                M spss4	=	op4
00010BD0                            	spTotalLv	$22, $13, $2E, $04
00010BD0 =00000022                M sptl1	=	op1
00010BD0 =00000013                M sptl2	=	op2
00010BD0 =0000002E                M sptl3	=	op3
00010BD0 =00000004                M sptl4	=	op4
00010BD0 08                       M 	dc.b	(spfe<<3)+spal
00010BD1 =00000080                M sptlmask4	set	$80
00010BD1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010BD1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010BD1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010BD1 0A70 3000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010BD5 1F1F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010BD9 120E 0A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010BDD 0004 0403                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010BE1 2F2F 2F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010BE5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010BE9 222E 1384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010BED 4E41 54                  M 	dc.b	'NAT'
00010BF0                            
00010BF0                            	; Patch $0B
00010BF0                            	; $28
00010BF0                            	; $39, $35, $30, $31,	$1F, $1F, $1F, $1F
00010BF0                            	; $0C, $0A, $07, $0A,	$07, $07, $07, $09
00010BF0                            	; $26, $16, $16, $F6,	$17, $32, $14, $05
00010BF0                            	spAlgorithm	$00
00010BF0 =0000000C                M spatnum	=	spatnum+1
00010BF0 =00000000                M spal	=	val
00010BF0                            	spFeedback	$05
00010BF0 =00000005                M spfe	=	val
00010BF0                            	spDetune	$03, $03, $03, $03
00010BF0 =00000003                M spde1	=	op1
00010BF0 =00000003                M spde2	=	op2
00010BF0 =00000003                M spde3	=	op3
00010BF0 =00000003                M spde4	=	op4
00010BF0                            	spMultiple	$09, $00, $05, $01
00010BF0 =00000009                M spmu1	=	op1
00010BF0 =00000000                M spmu2	=	op2
00010BF0 =00000005                M spmu3	=	op3
00010BF0 =00000001                M spmu4	=	op4
00010BF0                            	spRateScale	$00, $00, $00, $00
00010BF0 =00000000                M sprs1	=	op1
00010BF0 =00000000                M sprs2	=	op2
00010BF0 =00000000                M sprs3	=	op3
00010BF0 =00000000                M sprs4	=	op4
00010BF0                            	spAttackRt	$1F, $1F, $1F, $1F
00010BF0 =0000001F                M spar1	=	op1
00010BF0 =0000001F                M spar2	=	op2
00010BF0 =0000001F                M spar3	=	op3
00010BF0 =0000001F                M spar4	=	op4
00010BF0                            	spAmpMod	$00, $00, $00, $00
00010BF0 =00000000                M spam1	=	op1
00010BF0 =00000000                M spam2	=	op2
00010BF0 =00000000                M spam3	=	op3
00010BF0 =00000000                M spam4	=	op4
00010BF0                            	spSustainRt	$0C, $07, $0A, $0A
00010BF0 =0000000C                M spsr1	=	op1
00010BF0 =00000007                M spsr2	=	op2
00010BF0 =0000000A                M spsr3	=	op3
00010BF0 =0000000A                M spsr4	=	op4
00010BF0                            	spDecayRt	$07, $07, $07, $09
00010BF0 =00000007                M spdr1	=	op1
00010BF0 =00000007                M spdr2	=	op2
00010BF0 =00000007                M spdr3	=	op3
00010BF0 =00000009                M spdr4	=	op4
00010BF0                            	spSustainLv	$02, $01, $01, $0F
00010BF0 =00000002                M spsl1	=	op1
00010BF0 =00000001                M spsl2	=	op2
00010BF0 =00000001                M spsl3	=	op3
00010BF0 =0000000F                M spsl4	=	op4
00010BF0                            	spReleaseRt	$06, $06, $06, $06
00010BF0 =00000006                M sprr1	=	op1
00010BF0 =00000006                M sprr2	=	op2
00010BF0 =00000006                M sprr3	=	op3
00010BF0 =00000006                M sprr4	=	op4
00010BF0                            	spSSGEG		$00, $00, $00, $00
00010BF0 =00000000                M spss1	=	op1
00010BF0 =00000000                M spss2	=	op2
00010BF0 =00000000                M spss3	=	op3
00010BF0 =00000000                M spss4	=	op4
00010BF0                            	spTotalLv	$17, $14, $32, $05
00010BF0 =00000017                M sptl1	=	op1
00010BF0 =00000014                M sptl2	=	op2
00010BF0 =00000032                M sptl3	=	op3
00010BF0 =00000005                M sptl4	=	op4
00010BF0 28                       M 	dc.b	(spfe<<3)+spal
00010BF1 =00000080                M sptlmask4	set	$80
00010BF1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010BF1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010BF1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010BF1 3935 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010BF5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010BF9 0C0A 070A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010BFD 0707 0709                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010C01 2616 16F6                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010C05 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010C09 1732 1485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010C0D 4E41 54                  M 	dc.b	'NAT'
00010C10                            
00010C10                            	; Patch $0C
00010C10                            	; $3D
00010C10                            	; $6F, $22, $62, $22,	$1F, $1F, $1F, $1F
00010C10                            	; $0F, $0F, $0F, $0F,	$08, $08, $08, $08
00010C10                            	; $25, $25, $25, $25,	$1E, $36, $05, $09
00010C10                            	spAlgorithm	$05
00010C10 =0000000D                M spatnum	=	spatnum+1
00010C10 =00000005                M spal	=	val
00010C10                            	spFeedback	$07
00010C10 =00000007                M spfe	=	val
00010C10                            	spDetune	$06, $06, $02, $02
00010C10 =00000006                M spde1	=	op1
00010C10 =00000006                M spde2	=	op2
00010C10 =00000002                M spde3	=	op3
00010C10 =00000002                M spde4	=	op4
00010C10                            	spMultiple	$0F, $02, $02, $02
00010C10 =0000000F                M spmu1	=	op1
00010C10 =00000002                M spmu2	=	op2
00010C10 =00000002                M spmu3	=	op3
00010C10 =00000002                M spmu4	=	op4
00010C10                            	spRateScale	$00, $00, $00, $00
00010C10 =00000000                M sprs1	=	op1
00010C10 =00000000                M sprs2	=	op2
00010C10 =00000000                M sprs3	=	op3
00010C10 =00000000                M sprs4	=	op4
00010C10                            	spAttackRt	$1F, $1F, $1F, $1F
00010C10 =0000001F                M spar1	=	op1
00010C10 =0000001F                M spar2	=	op2
00010C10 =0000001F                M spar3	=	op3
00010C10 =0000001F                M spar4	=	op4
00010C10                            	spAmpMod	$00, $00, $00, $00
00010C10 =00000000                M spam1	=	op1
00010C10 =00000000                M spam2	=	op2
00010C10 =00000000                M spam3	=	op3
00010C10 =00000000                M spam4	=	op4
00010C10                            	spSustainRt	$0F, $0F, $0F, $0F
00010C10 =0000000F                M spsr1	=	op1
00010C10 =0000000F                M spsr2	=	op2
00010C10 =0000000F                M spsr3	=	op3
00010C10 =0000000F                M spsr4	=	op4
00010C10                            	spDecayRt	$08, $08, $08, $08
00010C10 =00000008                M spdr1	=	op1
00010C10 =00000008                M spdr2	=	op2
00010C10 =00000008                M spdr3	=	op3
00010C10 =00000008                M spdr4	=	op4
00010C10                            	spSustainLv	$02, $02, $02, $02
00010C10 =00000002                M spsl1	=	op1
00010C10 =00000002                M spsl2	=	op2
00010C10 =00000002                M spsl3	=	op3
00010C10 =00000002                M spsl4	=	op4
00010C10                            	spReleaseRt	$05, $05, $05, $05
00010C10 =00000005                M sprr1	=	op1
00010C10 =00000005                M sprr2	=	op2
00010C10 =00000005                M sprr3	=	op3
00010C10 =00000005                M sprr4	=	op4
00010C10                            	spSSGEG		$00, $00, $00, $00
00010C10 =00000000                M spss1	=	op1
00010C10 =00000000                M spss2	=	op2
00010C10 =00000000                M spss3	=	op3
00010C10 =00000000                M spss4	=	op4
00010C10                            	spTotalLv	$1E, $05, $36, $09
00010C10 =0000001E                M sptl1	=	op1
00010C10 =00000005                M sptl2	=	op2
00010C10 =00000036                M sptl3	=	op3
00010C10 =00000009                M sptl4	=	op4
00010C10 3D                       M 	dc.b	(spfe<<3)+spal
00010C11 =00000080                M sptlmask4	set	$80
00010C11 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010C11 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010C11 =00000000                M sptlmask1	set	((spal=7)<<7)
00010C11 6F22 6222                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010C15 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010C19 0F0F 0F0F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010C1D 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010C21 2525 2525                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010C25 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010C29 1EB6 8589                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010C2D 4E41 54                  M 	dc.b	'NAT'
00010C30                            
00010C30                            	; Patch $0D
00010C30                            	; $06
00010C30                            	; $61, $03, $32, $71,	$1F, $1F, $1F, $1F
00010C30                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00010C30                            	; $07, $07, $07, $07,	$1E, $0A, $05, $05
00010C30                            	spAlgorithm	$06
00010C30 =0000000E                M spatnum	=	spatnum+1
00010C30 =00000006                M spal	=	val
00010C30                            	spFeedback	$00
00010C30 =00000000                M spfe	=	val
00010C30                            	spDetune	$06, $03, $00, $07
00010C30 =00000006                M spde1	=	op1
00010C30 =00000003                M spde2	=	op2
00010C30 =00000000                M spde3	=	op3
00010C30 =00000007                M spde4	=	op4
00010C30                            	spMultiple	$01, $02, $03, $01
00010C30 =00000001                M spmu1	=	op1
00010C30 =00000002                M spmu2	=	op2
00010C30 =00000003                M spmu3	=	op3
00010C30 =00000001                M spmu4	=	op4
00010C30                            	spRateScale	$00, $00, $00, $00
00010C30 =00000000                M sprs1	=	op1
00010C30 =00000000                M sprs2	=	op2
00010C30 =00000000                M sprs3	=	op3
00010C30 =00000000                M sprs4	=	op4
00010C30                            	spAttackRt	$1F, $1F, $1F, $1F
00010C30 =0000001F                M spar1	=	op1
00010C30 =0000001F                M spar2	=	op2
00010C30 =0000001F                M spar3	=	op3
00010C30 =0000001F                M spar4	=	op4
00010C30                            	spAmpMod	$00, $00, $00, $00
00010C30 =00000000                M spam1	=	op1
00010C30 =00000000                M spam2	=	op2
00010C30 =00000000                M spam3	=	op3
00010C30 =00000000                M spam4	=	op4
00010C30                            	spSustainRt	$00, $00, $00, $00
00010C30 =00000000                M spsr1	=	op1
00010C30 =00000000                M spsr2	=	op2
00010C30 =00000000                M spsr3	=	op3
00010C30 =00000000                M spsr4	=	op4
00010C30                            	spDecayRt	$00, $00, $00, $00
00010C30 =00000000                M spdr1	=	op1
00010C30 =00000000                M spdr2	=	op2
00010C30 =00000000                M spdr3	=	op3
00010C30 =00000000                M spdr4	=	op4
00010C30                            	spSustainLv	$00, $00, $00, $00
00010C30 =00000000                M spsl1	=	op1
00010C30 =00000000                M spsl2	=	op2
00010C30 =00000000                M spsl3	=	op3
00010C30 =00000000                M spsl4	=	op4
00010C30                            	spReleaseRt	$07, $07, $07, $07
00010C30 =00000007                M sprr1	=	op1
00010C30 =00000007                M sprr2	=	op2
00010C30 =00000007                M sprr3	=	op3
00010C30 =00000007                M sprr4	=	op4
00010C30                            	spSSGEG		$00, $00, $00, $00
00010C30 =00000000                M spss1	=	op1
00010C30 =00000000                M spss2	=	op2
00010C30 =00000000                M spss3	=	op3
00010C30 =00000000                M spss4	=	op4
00010C30                            	spTotalLv	$1E, $05, $0A, $05
00010C30 =0000001E                M sptl1	=	op1
00010C30 =00000005                M sptl2	=	op2
00010C30 =0000000A                M sptl3	=	op3
00010C30 =00000005                M sptl4	=	op4
00010C30 06                       M 	dc.b	(spfe<<3)+spal
00010C31 =00000080                M sptlmask4	set	$80
00010C31 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010C31 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010C31 =00000000                M sptlmask1	set	((spal=7)<<7)
00010C31 6103 3271                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010C35 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010C39 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010C3D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010C41 0707 0707                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010C45 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010C49 1E8A 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010C4D 4E41 54                  M 	dc.b	'NAT'
00010C50                            
00010C50                            	; Patch $0E
00010C50                            	; $24
00010C50                            	; $31, $71, $61, $16,	$11, $55, $14, $55
00010C50                            	; $1F, $01, $00, $04,	$00, $00, $00, $01
00010C50                            	; $11, $97, $05, $A7,	$04, $05, $00, $05
00010C50                            	spAlgorithm	$04
00010C50 =0000000F                M spatnum	=	spatnum+1
00010C50 =00000004                M spal	=	val
00010C50                            	spFeedback	$04
00010C50 =00000004                M spfe	=	val
00010C50                            	spDetune	$03, $06, $07, $01
00010C50 =00000003                M spde1	=	op1
00010C50 =00000006                M spde2	=	op2
00010C50 =00000007                M spde3	=	op3
00010C50 =00000001                M spde4	=	op4
00010C50                            	spMultiple	$01, $01, $01, $06
00010C50 =00000001                M spmu1	=	op1
00010C50 =00000001                M spmu2	=	op2
00010C50 =00000001                M spmu3	=	op3
00010C50 =00000006                M spmu4	=	op4
00010C50                            	spRateScale	$00, $00, $01, $01
00010C50 =00000000                M sprs1	=	op1
00010C50 =00000000                M sprs2	=	op2
00010C50 =00000001                M sprs3	=	op3
00010C50 =00000001                M sprs4	=	op4
00010C50                            	spAttackRt	$11, $14, $15, $15
00010C50 =00000011                M spar1	=	op1
00010C50 =00000014                M spar2	=	op2
00010C50 =00000015                M spar3	=	op3
00010C50 =00000015                M spar4	=	op4
00010C50                            	spAmpMod	$00, $00, $00, $00
00010C50 =00000000                M spam1	=	op1
00010C50 =00000000                M spam2	=	op2
00010C50 =00000000                M spam3	=	op3
00010C50 =00000000                M spam4	=	op4
00010C50                            	spSustainRt	$1F, $00, $01, $04
00010C50 =0000001F                M spsr1	=	op1
00010C50 =00000000                M spsr2	=	op2
00010C50 =00000001                M spsr3	=	op3
00010C50 =00000004                M spsr4	=	op4
00010C50                            	spDecayRt	$00, $00, $00, $01
00010C50 =00000000                M spdr1	=	op1
00010C50 =00000000                M spdr2	=	op2
00010C50 =00000000                M spdr3	=	op3
00010C50 =00000001                M spdr4	=	op4
00010C50                            	spSustainLv	$01, $00, $09, $0A
00010C50 =00000001                M spsl1	=	op1
00010C50 =00000000                M spsl2	=	op2
00010C50 =00000009                M spsl3	=	op3
00010C50 =0000000A                M spsl4	=	op4
00010C50                            	spReleaseRt	$01, $05, $07, $07
00010C50 =00000001                M sprr1	=	op1
00010C50 =00000005                M sprr2	=	op2
00010C50 =00000007                M sprr3	=	op3
00010C50 =00000007                M sprr4	=	op4
00010C50                            	spSSGEG		$00, $00, $00, $00
00010C50 =00000000                M spss1	=	op1
00010C50 =00000000                M spss2	=	op2
00010C50 =00000000                M spss3	=	op3
00010C50 =00000000                M spss4	=	op4
00010C50                            	spTotalLv	$04, $00, $05, $05
00010C50 =00000004                M sptl1	=	op1
00010C50 =00000000                M sptl2	=	op2
00010C50 =00000005                M sptl3	=	op3
00010C50 =00000005                M sptl4	=	op4
00010C50 24                       M 	dc.b	(spfe<<3)+spal
00010C51 =00000080                M sptlmask4	set	$80
00010C51 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010C51 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010C51 =00000000                M sptlmask1	set	((spal=7)<<7)
00010C51 3171 6116                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010C55 1155 1455                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010C59 1F01 0004                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010C5D 0000 0001                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010C61 1197 05A7                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010C65 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010C69 0485 0085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010C6D 4E41 54                  M 	dc.b	'NAT'
00010C70                            
00010C70                            	; Patch $0F
00010C70                            	; $36
00010C70                            	; $72, $02, $01, $01,	$D8, $47, $8D, $87
00010C70                            	; $01, $04, $01, $05,	$00, $05, $07, $00
00010C70                            	; $51, $14, $15, $14,	$11, $05, $7F, $7F
00010C70                            	spAlgorithm	$06
00010C70 =00000010                M spatnum	=	spatnum+1
00010C70 =00000006                M spal	=	val
00010C70                            	spFeedback	$06
00010C70 =00000006                M spfe	=	val
00010C70                            	spDetune	$07, $00, $00, $00
00010C70 =00000007                M spde1	=	op1
00010C70 =00000000                M spde2	=	op2
00010C70 =00000000                M spde3	=	op3
00010C70 =00000000                M spde4	=	op4
00010C70                            	spMultiple	$02, $01, $02, $01
00010C70 =00000002                M spmu1	=	op1
00010C70 =00000001                M spmu2	=	op2
00010C70 =00000002                M spmu3	=	op3
00010C70 =00000001                M spmu4	=	op4
00010C70                            	spRateScale	$03, $02, $01, $02
00010C70 =00000003                M sprs1	=	op1
00010C70 =00000002                M sprs2	=	op2
00010C70 =00000001                M sprs3	=	op3
00010C70 =00000002                M sprs4	=	op4
00010C70                            	spAttackRt	$18, $0D, $07, $07
00010C70 =00000018                M spar1	=	op1
00010C70 =0000000D                M spar2	=	op2
00010C70 =00000007                M spar3	=	op3
00010C70 =00000007                M spar4	=	op4
00010C70                            	spAmpMod	$00, $00, $00, $00
00010C70 =00000000                M spam1	=	op1
00010C70 =00000000                M spam2	=	op2
00010C70 =00000000                M spam3	=	op3
00010C70 =00000000                M spam4	=	op4
00010C70                            	spSustainRt	$01, $01, $04, $05
00010C70 =00000001                M spsr1	=	op1
00010C70 =00000001                M spsr2	=	op2
00010C70 =00000004                M spsr3	=	op3
00010C70 =00000005                M spsr4	=	op4
00010C70                            	spDecayRt	$00, $07, $05, $00
00010C70 =00000000                M spdr1	=	op1
00010C70 =00000007                M spdr2	=	op2
00010C70 =00000005                M spdr3	=	op3
00010C70 =00000000                M spdr4	=	op4
00010C70                            	spSustainLv	$05, $01, $01, $01
00010C70 =00000005                M spsl1	=	op1
00010C70 =00000001                M spsl2	=	op2
00010C70 =00000001                M spsl3	=	op3
00010C70 =00000001                M spsl4	=	op4
00010C70                            	spReleaseRt	$01, $05, $04, $04
00010C70 =00000001                M sprr1	=	op1
00010C70 =00000005                M sprr2	=	op2
00010C70 =00000004                M sprr3	=	op3
00010C70 =00000004                M sprr4	=	op4
00010C70                            	spSSGEG		$00, $00, $00, $00
00010C70 =00000000                M spss1	=	op1
00010C70 =00000000                M spss2	=	op2
00010C70 =00000000                M spss3	=	op3
00010C70 =00000000                M spss4	=	op4
00010C70                            	spTotalLv	$11, $7F, $05, $7F
00010C70 =00000011                M sptl1	=	op1
00010C70 =0000007F                M sptl2	=	op2
00010C70 =00000005                M sptl3	=	op3
00010C70 =0000007F                M sptl4	=	op4
00010C70 36                       M 	dc.b	(spfe<<3)+spal
00010C71 =00000080                M sptlmask4	set	$80
00010C71 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010C71 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010C71 =00000000                M sptlmask1	set	((spal=7)<<7)
00010C71 7202 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010C75 D847 8D87                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010C79 0104 0105                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010C7D 0005 0700                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010C81 5114 1514                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010C85 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010C89 1185 FFFF                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010C8D 4E41 54                  M 	dc.b	'NAT'
00010C90                            
00010C90                            	; Patch $10
00010C90                            	; $24
00010C90                            	; $10, $01, $31, $11,	$9B, $5C, $1B, $5C
00010C90                            	; $0A, $10, $0A, $10,	$03, $04, $03, $04
00010C90                            	; $1F, $0C, $8F, $0C,	$06, $05, $04, $05
00010C90                            	spAlgorithm	$04
00010C90 =00000011                M spatnum	=	spatnum+1
00010C90 =00000004                M spal	=	val
00010C90                            	spFeedback	$04
00010C90 =00000004                M spfe	=	val
00010C90                            	spDetune	$01, $03, $00, $01
00010C90 =00000001                M spde1	=	op1
00010C90 =00000003                M spde2	=	op2
00010C90 =00000000                M spde3	=	op3
00010C90 =00000001                M spde4	=	op4
00010C90                            	spMultiple	$00, $01, $01, $01
00010C90 =00000000                M spmu1	=	op1
00010C90 =00000001                M spmu2	=	op2
00010C90 =00000001                M spmu3	=	op3
00010C90 =00000001                M spmu4	=	op4
00010C90                            	spRateScale	$02, $00, $01, $01
00010C90 =00000002                M sprs1	=	op1
00010C90 =00000000                M sprs2	=	op2
00010C90 =00000001                M sprs3	=	op3
00010C90 =00000001                M sprs4	=	op4
00010C90                            	spAttackRt	$1B, $1B, $1C, $1C
00010C90 =0000001B                M spar1	=	op1
00010C90 =0000001B                M spar2	=	op2
00010C90 =0000001C                M spar3	=	op3
00010C90 =0000001C                M spar4	=	op4
00010C90                            	spAmpMod	$00, $00, $00, $00
00010C90 =00000000                M spam1	=	op1
00010C90 =00000000                M spam2	=	op2
00010C90 =00000000                M spam3	=	op3
00010C90 =00000000                M spam4	=	op4
00010C90                            	spSustainRt	$0A, $0A, $10, $10
00010C90 =0000000A                M spsr1	=	op1
00010C90 =0000000A                M spsr2	=	op2
00010C90 =00000010                M spsr3	=	op3
00010C90 =00000010                M spsr4	=	op4
00010C90                            	spDecayRt	$03, $03, $04, $04
00010C90 =00000003                M spdr1	=	op1
00010C90 =00000003                M spdr2	=	op2
00010C90 =00000004                M spdr3	=	op3
00010C90 =00000004                M spdr4	=	op4
00010C90                            	spSustainLv	$01, $08, $00, $00
00010C90 =00000001                M spsl1	=	op1
00010C90 =00000008                M spsl2	=	op2
00010C90 =00000000                M spsl3	=	op3
00010C90 =00000000                M spsl4	=	op4
00010C90                            	spReleaseRt	$0F, $0F, $0C, $0C
00010C90 =0000000F                M sprr1	=	op1
00010C90 =0000000F                M sprr2	=	op2
00010C90 =0000000C                M sprr3	=	op3
00010C90 =0000000C                M sprr4	=	op4
00010C90                            	spSSGEG		$00, $00, $00, $00
00010C90 =00000000                M spss1	=	op1
00010C90 =00000000                M spss2	=	op2
00010C90 =00000000                M spss3	=	op3
00010C90 =00000000                M spss4	=	op4
00010C90                            	spTotalLv	$06, $04, $05, $05
00010C90 =00000006                M sptl1	=	op1
00010C90 =00000004                M sptl2	=	op2
00010C90 =00000005                M sptl3	=	op3
00010C90 =00000005                M sptl4	=	op4
00010C90 24                       M 	dc.b	(spfe<<3)+spal
00010C91 =00000080                M sptlmask4	set	$80
00010C91 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010C91 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010C91 =00000000                M sptlmask1	set	((spal=7)<<7)
00010C91 1001 3111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010C95 9B5C 1B5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010C99 0A10 0A10                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010C9D 0304 0304                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010CA1 1F0C 8F0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010CA5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010CA9 0685 0485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010CAD 4E41 54                  M 	dc.b	'NAT'
00010CB0                            
00010CB0                            	; Patch $11
00010CB0                            	; $23
00010CB0                            	; $30, $75, $30, $70,	$08, $1F, $1D, $5B
00010CB0                            	; $8B, $16, $96, $95,	$01, $00, $00, $00
00010CB0                            	; $8B, $3A, $3A, $3A,	$05, $0D, $0B, $02
00010CB0                            	spAlgorithm	$03
00010CB0 =00000012                M spatnum	=	spatnum+1
00010CB0 =00000003                M spal	=	val
00010CB0                            	spFeedback	$04
00010CB0 =00000004                M spfe	=	val
00010CB0                            	spDetune	$03, $03, $07, $07
00010CB0 =00000003                M spde1	=	op1
00010CB0 =00000003                M spde2	=	op2
00010CB0 =00000007                M spde3	=	op3
00010CB0 =00000007                M spde4	=	op4
00010CB0                            	spMultiple	$00, $00, $05, $00
00010CB0 =00000000                M spmu1	=	op1
00010CB0 =00000000                M spmu2	=	op2
00010CB0 =00000005                M spmu3	=	op3
00010CB0 =00000000                M spmu4	=	op4
00010CB0                            	spRateScale	$00, $00, $00, $01
00010CB0 =00000000                M sprs1	=	op1
00010CB0 =00000000                M sprs2	=	op2
00010CB0 =00000000                M sprs3	=	op3
00010CB0 =00000001                M sprs4	=	op4
00010CB0                            	spAttackRt	$08, $1D, $1F, $1B
00010CB0 =00000008                M spar1	=	op1
00010CB0 =0000001D                M spar2	=	op2
00010CB0 =0000001F                M spar3	=	op3
00010CB0 =0000001B                M spar4	=	op4
00010CB0                            	spAmpMod	$01, $01, $00, $01
00010CB0 =00000001                M spam1	=	op1
00010CB0 =00000001                M spam2	=	op2
00010CB0 =00000000                M spam3	=	op3
00010CB0 =00000001                M spam4	=	op4
00010CB0                            	spSustainRt	$0B, $16, $16, $15
00010CB0 =0000000B                M spsr1	=	op1
00010CB0 =00000016                M spsr2	=	op2
00010CB0 =00000016                M spsr3	=	op3
00010CB0 =00000015                M spsr4	=	op4
00010CB0                            	spDecayRt	$01, $00, $00, $00
00010CB0 =00000001                M spdr1	=	op1
00010CB0 =00000000                M spdr2	=	op2
00010CB0 =00000000                M spdr3	=	op3
00010CB0 =00000000                M spdr4	=	op4
00010CB0                            	spSustainLv	$08, $03, $03, $03
00010CB0 =00000008                M spsl1	=	op1
00010CB0 =00000003                M spsl2	=	op2
00010CB0 =00000003                M spsl3	=	op3
00010CB0 =00000003                M spsl4	=	op4
00010CB0                            	spReleaseRt	$0B, $0A, $0A, $0A
00010CB0 =0000000B                M sprr1	=	op1
00010CB0 =0000000A                M sprr2	=	op2
00010CB0 =0000000A                M sprr3	=	op3
00010CB0 =0000000A                M sprr4	=	op4
00010CB0                            	spSSGEG		$00, $00, $00, $00
00010CB0 =00000000                M spss1	=	op1
00010CB0 =00000000                M spss2	=	op2
00010CB0 =00000000                M spss3	=	op3
00010CB0 =00000000                M spss4	=	op4
00010CB0                            	spTotalLv	$05, $0B, $0D, $02
00010CB0 =00000005                M sptl1	=	op1
00010CB0 =0000000B                M sptl2	=	op2
00010CB0 =0000000D                M sptl3	=	op3
00010CB0 =00000002                M sptl4	=	op4
00010CB0 23                       M 	dc.b	(spfe<<3)+spal
00010CB1 =00000080                M sptlmask4	set	$80
00010CB1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010CB1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010CB1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010CB1 3075 3070                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010CB5 081F 1D5B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010CB9 8B16 9695                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010CBD 0100 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010CC1 8B3A 3A3A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010CC5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010CC9 050D 0B82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010CCD 4E41 54                  M 	dc.b	'NAT'
00010CD0                            
00010CD0                            	; Patch $12
00010CD0                            	; $2C
00010CD0                            	; $70, $32, $00, $00,	$9F, $1F, $5F, $5E
00010CD0                            	; $1A, $15, $0C, $05,	$08, $06, $02, $09
00010CD0                            	; $28, $AA, $BA, $8A,	$08, $05, $0B, $05
00010CD0                            	spAlgorithm	$04
00010CD0 =00000013                M spatnum	=	spatnum+1
00010CD0 =00000004                M spal	=	val
00010CD0                            	spFeedback	$05
00010CD0 =00000005                M spfe	=	val
00010CD0                            	spDetune	$07, $00, $03, $00
00010CD0 =00000007                M spde1	=	op1
00010CD0 =00000000                M spde2	=	op2
00010CD0 =00000003                M spde3	=	op3
00010CD0 =00000000                M spde4	=	op4
00010CD0                            	spMultiple	$00, $00, $02, $00
00010CD0 =00000000                M spmu1	=	op1
00010CD0 =00000000                M spmu2	=	op2
00010CD0 =00000002                M spmu3	=	op3
00010CD0 =00000000                M spmu4	=	op4
00010CD0                            	spRateScale	$02, $01, $00, $01
00010CD0 =00000002                M sprs1	=	op1
00010CD0 =00000001                M sprs2	=	op2
00010CD0 =00000000                M sprs3	=	op3
00010CD0 =00000001                M sprs4	=	op4
00010CD0                            	spAttackRt	$1F, $1F, $1F, $1E
00010CD0 =0000001F                M spar1	=	op1
00010CD0 =0000001F                M spar2	=	op2
00010CD0 =0000001F                M spar3	=	op3
00010CD0 =0000001E                M spar4	=	op4
00010CD0                            	spAmpMod	$00, $00, $00, $00
00010CD0 =00000000                M spam1	=	op1
00010CD0 =00000000                M spam2	=	op2
00010CD0 =00000000                M spam3	=	op3
00010CD0 =00000000                M spam4	=	op4
00010CD0                            	spSustainRt	$1A, $0C, $15, $05
00010CD0 =0000001A                M spsr1	=	op1
00010CD0 =0000000C                M spsr2	=	op2
00010CD0 =00000015                M spsr3	=	op3
00010CD0 =00000005                M spsr4	=	op4
00010CD0                            	spDecayRt	$08, $02, $06, $09
00010CD0 =00000008                M spdr1	=	op1
00010CD0 =00000002                M spdr2	=	op2
00010CD0 =00000006                M spdr3	=	op3
00010CD0 =00000009                M spdr4	=	op4
00010CD0                            	spSustainLv	$02, $0B, $0A, $08
00010CD0 =00000002                M spsl1	=	op1
00010CD0 =0000000B                M spsl2	=	op2
00010CD0 =0000000A                M spsl3	=	op3
00010CD0 =00000008                M spsl4	=	op4
00010CD0                            	spReleaseRt	$08, $0A, $0A, $0A
00010CD0 =00000008                M sprr1	=	op1
00010CD0 =0000000A                M sprr2	=	op2
00010CD0 =0000000A                M sprr3	=	op3
00010CD0 =0000000A                M sprr4	=	op4
00010CD0                            	spSSGEG		$00, $00, $00, $00
00010CD0 =00000000                M spss1	=	op1
00010CD0 =00000000                M spss2	=	op2
00010CD0 =00000000                M spss3	=	op3
00010CD0 =00000000                M spss4	=	op4
00010CD0                            	spTotalLv	$08, $0B, $05, $05
00010CD0 =00000008                M sptl1	=	op1
00010CD0 =0000000B                M sptl2	=	op2
00010CD0 =00000005                M sptl3	=	op3
00010CD0 =00000005                M sptl4	=	op4
00010CD0 2C                       M 	dc.b	(spfe<<3)+spal
00010CD1 =00000080                M sptlmask4	set	$80
00010CD1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010CD1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010CD1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010CD1 7032 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010CD5 9F1F 5F5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010CD9 1A15 0C05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010CDD 0806 0209                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010CE1 28AA BA8A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010CE5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010CE9 0885 0B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010CED 4E41 54                  M 	dc.b	'NAT'
00010CF0                            
00010CF0                            	; Patch $13
00010CF0                            	; $35
00010CF0                            	; $77, $03, $74, $32,	$1A, $14, $56, $17
00010CF0                            	; $97, $9F, $9D, $9F,	$13, $0F, $0F, $0E
00010CF0                            	; $7C, $1D, $1D, $1D,	$13, $04, $02, $06
00010CF0                            	spAlgorithm	$05
00010CF0 =00000014                M spatnum	=	spatnum+1
00010CF0 =00000005                M spal	=	val
00010CF0                            	spFeedback	$06
00010CF0 =00000006                M spfe	=	val
00010CF0                            	spDetune	$07, $07, $00, $03
00010CF0 =00000007                M spde1	=	op1
00010CF0 =00000007                M spde2	=	op2
00010CF0 =00000000                M spde3	=	op3
00010CF0 =00000003                M spde4	=	op4
00010CF0                            	spMultiple	$07, $04, $03, $02
00010CF0 =00000007                M spmu1	=	op1
00010CF0 =00000004                M spmu2	=	op2
00010CF0 =00000003                M spmu3	=	op3
00010CF0 =00000002                M spmu4	=	op4
00010CF0                            	spRateScale	$00, $01, $00, $00
00010CF0 =00000000                M sprs1	=	op1
00010CF0 =00000001                M sprs2	=	op2
00010CF0 =00000000                M sprs3	=	op3
00010CF0 =00000000                M sprs4	=	op4
00010CF0                            	spAttackRt	$1A, $16, $14, $17
00010CF0 =0000001A                M spar1	=	op1
00010CF0 =00000016                M spar2	=	op2
00010CF0 =00000014                M spar3	=	op3
00010CF0 =00000017                M spar4	=	op4
00010CF0                            	spAmpMod	$01, $01, $01, $01
00010CF0 =00000001                M spam1	=	op1
00010CF0 =00000001                M spam2	=	op2
00010CF0 =00000001                M spam3	=	op3
00010CF0 =00000001                M spam4	=	op4
00010CF0                            	spSustainRt	$17, $1D, $1F, $1F
00010CF0 =00000017                M spsr1	=	op1
00010CF0 =0000001D                M spsr2	=	op2
00010CF0 =0000001F                M spsr3	=	op3
00010CF0 =0000001F                M spsr4	=	op4
00010CF0                            	spDecayRt	$13, $0F, $0F, $0E
00010CF0 =00000013                M spdr1	=	op1
00010CF0 =0000000F                M spdr2	=	op2
00010CF0 =0000000F                M spdr3	=	op3
00010CF0 =0000000E                M spdr4	=	op4
00010CF0                            	spSustainLv	$07, $01, $01, $01
00010CF0 =00000007                M spsl1	=	op1
00010CF0 =00000001                M spsl2	=	op2
00010CF0 =00000001                M spsl3	=	op3
00010CF0 =00000001                M spsl4	=	op4
00010CF0                            	spReleaseRt	$0C, $0D, $0D, $0D
00010CF0 =0000000C                M sprr1	=	op1
00010CF0 =0000000D                M sprr2	=	op2
00010CF0 =0000000D                M sprr3	=	op3
00010CF0 =0000000D                M sprr4	=	op4
00010CF0                            	spSSGEG		$00, $00, $00, $00
00010CF0 =00000000                M spss1	=	op1
00010CF0 =00000000                M spss2	=	op2
00010CF0 =00000000                M spss3	=	op3
00010CF0 =00000000                M spss4	=	op4
00010CF0                            	spTotalLv	$13, $02, $04, $06
00010CF0 =00000013                M sptl1	=	op1
00010CF0 =00000002                M sptl2	=	op2
00010CF0 =00000004                M sptl3	=	op3
00010CF0 =00000006                M sptl4	=	op4
00010CF0 35                       M 	dc.b	(spfe<<3)+spal
00010CF1 =00000080                M sptlmask4	set	$80
00010CF1 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010CF1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010CF1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010CF1 7703 7432                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010CF5 1A14 5617                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010CF9 979F 9D9F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010CFD 130F 0F0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010D01 7C1D 1D1D                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010D05 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010D09 1384 8286                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010D0D 4E41 54                  M 	dc.b	'NAT'
00010D10                            
00010D10                            	; Patch $14
00010D10                            	; $35
00010D10                            	; $21, $31, $20, $15,	$8E, $9B, $95, $94
00010D10                            	; $00, $05, $00, $80,	$01, $02, $02, $02
00010D10                            	; $47, $37, $19, $07,	$19, $05, $0E, $08
00010D10                            	spAlgorithm	$05
00010D10 =00000015                M spatnum	=	spatnum+1
00010D10 =00000005                M spal	=	val
00010D10                            	spFeedback	$06
00010D10 =00000006                M spfe	=	val
00010D10                            	spDetune	$02, $02, $03, $01
00010D10 =00000002                M spde1	=	op1
00010D10 =00000002                M spde2	=	op2
00010D10 =00000003                M spde3	=	op3
00010D10 =00000001                M spde4	=	op4
00010D10                            	spMultiple	$01, $00, $01, $05
00010D10 =00000001                M spmu1	=	op1
00010D10 =00000000                M spmu2	=	op2
00010D10 =00000001                M spmu3	=	op3
00010D10 =00000005                M spmu4	=	op4
00010D10                            	spRateScale	$02, $02, $02, $02
00010D10 =00000002                M sprs1	=	op1
00010D10 =00000002                M sprs2	=	op2
00010D10 =00000002                M sprs3	=	op3
00010D10 =00000002                M sprs4	=	op4
00010D10                            	spAttackRt	$0E, $15, $1B, $14
00010D10 =0000000E                M spar1	=	op1
00010D10 =00000015                M spar2	=	op2
00010D10 =0000001B                M spar3	=	op3
00010D10 =00000014                M spar4	=	op4
00010D10                            	spAmpMod	$00, $00, $00, $01
00010D10 =00000000                M spam1	=	op1
00010D10 =00000000                M spam2	=	op2
00010D10 =00000000                M spam3	=	op3
00010D10 =00000001                M spam4	=	op4
00010D10                            	spSustainRt	$00, $00, $05, $00
00010D10 =00000000                M spsr1	=	op1
00010D10 =00000000                M spsr2	=	op2
00010D10 =00000005                M spsr3	=	op3
00010D10 =00000000                M spsr4	=	op4
00010D10                            	spDecayRt	$01, $02, $02, $02
00010D10 =00000001                M spdr1	=	op1
00010D10 =00000002                M spdr2	=	op2
00010D10 =00000002                M spdr3	=	op3
00010D10 =00000002                M spdr4	=	op4
00010D10                            	spSustainLv	$04, $01, $03, $00
00010D10 =00000004                M spsl1	=	op1
00010D10 =00000001                M spsl2	=	op2
00010D10 =00000003                M spsl3	=	op3
00010D10 =00000000                M spsl4	=	op4
00010D10                            	spReleaseRt	$07, $09, $07, $07
00010D10 =00000007                M sprr1	=	op1
00010D10 =00000009                M sprr2	=	op2
00010D10 =00000007                M sprr3	=	op3
00010D10 =00000007                M sprr4	=	op4
00010D10                            	spSSGEG		$00, $00, $00, $00
00010D10 =00000000                M spss1	=	op1
00010D10 =00000000                M spss2	=	op2
00010D10 =00000000                M spss3	=	op3
00010D10 =00000000                M spss4	=	op4
00010D10                            	spTotalLv	$19, $0E, $05, $08
00010D10 =00000019                M sptl1	=	op1
00010D10 =0000000E                M sptl2	=	op2
00010D10 =00000005                M sptl3	=	op3
00010D10 =00000008                M sptl4	=	op4
00010D10 35                       M 	dc.b	(spfe<<3)+spal
00010D11 =00000080                M sptlmask4	set	$80
00010D11 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010D11 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010D11 =00000000                M sptlmask1	set	((spal=7)<<7)
00010D11 2131 2015                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010D15 8E9B 9594                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010D19 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010D1D 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010D21 4737 1907                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010D25 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010D29 1985 8E88                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010D2D 4E41 54                  M 	dc.b	'NAT'
00010D30                            
00010D30                            	; Patch $15
00010D30                            	; $35
00010D30                            	; $22, $32, $21, $34,	$8E, $9B, $8F, $94
00010D30                            	; $00, $05, $00, $80,	$01, $02, $02, $02
00010D30                            	; $07, $36, $17, $08,	$15, $12, $14, $05
00010D30                            	spAlgorithm	$05
00010D30 =00000016                M spatnum	=	spatnum+1
00010D30 =00000005                M spal	=	val
00010D30                            	spFeedback	$06
00010D30 =00000006                M spfe	=	val
00010D30                            	spDetune	$02, $02, $03, $03
00010D30 =00000002                M spde1	=	op1
00010D30 =00000002                M spde2	=	op2
00010D30 =00000003                M spde3	=	op3
00010D30 =00000003                M spde4	=	op4
00010D30                            	spMultiple	$02, $01, $02, $04
00010D30 =00000002                M spmu1	=	op1
00010D30 =00000001                M spmu2	=	op2
00010D30 =00000002                M spmu3	=	op3
00010D30 =00000004                M spmu4	=	op4
00010D30                            	spRateScale	$02, $02, $02, $02
00010D30 =00000002                M sprs1	=	op1
00010D30 =00000002                M sprs2	=	op2
00010D30 =00000002                M sprs3	=	op3
00010D30 =00000002                M sprs4	=	op4
00010D30                            	spAttackRt	$0E, $0F, $1B, $14
00010D30 =0000000E                M spar1	=	op1
00010D30 =0000000F                M spar2	=	op2
00010D30 =0000001B                M spar3	=	op3
00010D30 =00000014                M spar4	=	op4
00010D30                            	spAmpMod	$00, $00, $00, $01
00010D30 =00000000                M spam1	=	op1
00010D30 =00000000                M spam2	=	op2
00010D30 =00000000                M spam3	=	op3
00010D30 =00000001                M spam4	=	op4
00010D30                            	spSustainRt	$00, $00, $05, $00
00010D30 =00000000                M spsr1	=	op1
00010D30 =00000000                M spsr2	=	op2
00010D30 =00000005                M spsr3	=	op3
00010D30 =00000000                M spsr4	=	op4
00010D30                            	spDecayRt	$01, $02, $02, $02
00010D30 =00000001                M spdr1	=	op1
00010D30 =00000002                M spdr2	=	op2
00010D30 =00000002                M spdr3	=	op3
00010D30 =00000002                M spdr4	=	op4
00010D30                            	spSustainLv	$00, $01, $03, $00
00010D30 =00000000                M spsl1	=	op1
00010D30 =00000001                M spsl2	=	op2
00010D30 =00000003                M spsl3	=	op3
00010D30 =00000000                M spsl4	=	op4
00010D30                            	spReleaseRt	$07, $07, $06, $08
00010D30 =00000007                M sprr1	=	op1
00010D30 =00000007                M sprr2	=	op2
00010D30 =00000006                M sprr3	=	op3
00010D30 =00000008                M sprr4	=	op4
00010D30                            	spSSGEG		$00, $00, $00, $00
00010D30 =00000000                M spss1	=	op1
00010D30 =00000000                M spss2	=	op2
00010D30 =00000000                M spss3	=	op3
00010D30 =00000000                M spss4	=	op4
00010D30                            	spTotalLv	$15, $14, $12, $05
00010D30 =00000015                M sptl1	=	op1
00010D30 =00000014                M sptl2	=	op2
00010D30 =00000012                M sptl3	=	op3
00010D30 =00000005                M sptl4	=	op4
00010D30 35                       M 	dc.b	(spfe<<3)+spal
00010D31 =00000080                M sptlmask4	set	$80
00010D31 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010D31 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010D31 =00000000                M sptlmask1	set	((spal=7)<<7)
00010D31 2232 2134                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010D35 8E9B 8F94                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010D39 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010D3D 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010D41 0736 1708                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010D45 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010D49 1592 9485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010D4D 4E41 54                  M 	dc.b	'NAT'
00010D50                            
00010D50                            	; Patch $16
00010D50                            	; $2B
00010D50                            	; $31, $32, $35, $31,	$1F, $59, $9E, $5E
00010D50                            	; $06, $80, $80, $85,	$01, $17, $12, $0A
00010D50                            	; $AA, $AF, $F9, $FC,	$0E, $12, $46, $05
00010D50                            	spAlgorithm	$03
00010D50 =00000017                M spatnum	=	spatnum+1
00010D50 =00000003                M spal	=	val
00010D50                            	spFeedback	$05
00010D50 =00000005                M spfe	=	val
00010D50                            	spDetune	$03, $03, $03, $03
00010D50 =00000003                M spde1	=	op1
00010D50 =00000003                M spde2	=	op2
00010D50 =00000003                M spde3	=	op3
00010D50 =00000003                M spde4	=	op4
00010D50                            	spMultiple	$01, $05, $02, $01
00010D50 =00000001                M spmu1	=	op1
00010D50 =00000005                M spmu2	=	op2
00010D50 =00000002                M spmu3	=	op3
00010D50 =00000001                M spmu4	=	op4
00010D50                            	spRateScale	$00, $02, $01, $01
00010D50 =00000000                M sprs1	=	op1
00010D50 =00000002                M sprs2	=	op2
00010D50 =00000001                M sprs3	=	op3
00010D50 =00000001                M sprs4	=	op4
00010D50                            	spAttackRt	$1F, $1E, $19, $1E
00010D50 =0000001F                M spar1	=	op1
00010D50 =0000001E                M spar2	=	op2
00010D50 =00000019                M spar3	=	op3
00010D50 =0000001E                M spar4	=	op4
00010D50                            	spAmpMod	$00, $01, $01, $01
00010D50 =00000000                M spam1	=	op1
00010D50 =00000001                M spam2	=	op2
00010D50 =00000001                M spam3	=	op3
00010D50 =00000001                M spam4	=	op4
00010D50                            	spSustainRt	$06, $00, $00, $05
00010D50 =00000006                M spsr1	=	op1
00010D50 =00000000                M spsr2	=	op2
00010D50 =00000000                M spsr3	=	op3
00010D50 =00000005                M spsr4	=	op4
00010D50                            	spDecayRt	$01, $12, $17, $0A
00010D50 =00000001                M spdr1	=	op1
00010D50 =00000012                M spdr2	=	op2
00010D50 =00000017                M spdr3	=	op3
00010D50 =0000000A                M spdr4	=	op4
00010D50                            	spSustainLv	$0A, $0F, $0A, $0F
00010D50 =0000000A                M spsl1	=	op1
00010D50 =0000000F                M spsl2	=	op2
00010D50 =0000000A                M spsl3	=	op3
00010D50 =0000000F                M spsl4	=	op4
00010D50                            	spReleaseRt	$0A, $09, $0F, $0C
00010D50 =0000000A                M sprr1	=	op1
00010D50 =00000009                M sprr2	=	op2
00010D50 =0000000F                M sprr3	=	op3
00010D50 =0000000C                M sprr4	=	op4
00010D50                            	spSSGEG		$00, $00, $00, $00
00010D50 =00000000                M spss1	=	op1
00010D50 =00000000                M spss2	=	op2
00010D50 =00000000                M spss3	=	op3
00010D50 =00000000                M spss4	=	op4
00010D50                            	spTotalLv	$0E, $46, $12, $05
00010D50 =0000000E                M sptl1	=	op1
00010D50 =00000046                M sptl2	=	op2
00010D50 =00000012                M sptl3	=	op3
00010D50 =00000005                M sptl4	=	op4
00010D50 2B                       M 	dc.b	(spfe<<3)+spal
00010D51 =00000080                M sptlmask4	set	$80
00010D51 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010D51 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010D51 =00000000                M sptlmask1	set	((spal=7)<<7)
00010D51 3132 3531                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010D55 1F59 9E5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010D59 0680 8085                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010D5D 0117 120A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010D61 AAAF F9FC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010D65 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010D69 0E12 4685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010D6D 4E41 54                  M 	dc.b	'NAT'
00010D70                            
00010D70                            	; Patch $17
00010D70                            	; $04
00010D70                            	; $00, $00, $01, $02,	$9F, $1F, $9F, $1F
00010D70                            	; $8A, $8A, $91, $94,	$0E, $0A, $0E, $0E
00010D70                            	; $F8, $48, $F8, $F8,	$17, $04, $07, $04
00010D70                            	spAlgorithm	$04
00010D70 =00000018                M spatnum	=	spatnum+1
00010D70 =00000004                M spal	=	val
00010D70                            	spFeedback	$00
00010D70 =00000000                M spfe	=	val
00010D70                            	spDetune	$00, $00, $00, $00
00010D70 =00000000                M spde1	=	op1
00010D70 =00000000                M spde2	=	op2
00010D70 =00000000                M spde3	=	op3
00010D70 =00000000                M spde4	=	op4
00010D70                            	spMultiple	$00, $01, $00, $02
00010D70 =00000000                M spmu1	=	op1
00010D70 =00000001                M spmu2	=	op2
00010D70 =00000000                M spmu3	=	op3
00010D70 =00000002                M spmu4	=	op4
00010D70                            	spRateScale	$02, $02, $00, $00
00010D70 =00000002                M sprs1	=	op1
00010D70 =00000002                M sprs2	=	op2
00010D70 =00000000                M sprs3	=	op3
00010D70 =00000000                M sprs4	=	op4
00010D70                            	spAttackRt	$1F, $1F, $1F, $1F
00010D70 =0000001F                M spar1	=	op1
00010D70 =0000001F                M spar2	=	op2
00010D70 =0000001F                M spar3	=	op3
00010D70 =0000001F                M spar4	=	op4
00010D70                            	spAmpMod	$01, $01, $01, $01
00010D70 =00000001                M spam1	=	op1
00010D70 =00000001                M spam2	=	op2
00010D70 =00000001                M spam3	=	op3
00010D70 =00000001                M spam4	=	op4
00010D70                            	spSustainRt	$0A, $11, $0A, $14
00010D70 =0000000A                M spsr1	=	op1
00010D70 =00000011                M spsr2	=	op2
00010D70 =0000000A                M spsr3	=	op3
00010D70 =00000014                M spsr4	=	op4
00010D70                            	spDecayRt	$0E, $0E, $0A, $0E
00010D70 =0000000E                M spdr1	=	op1
00010D70 =0000000E                M spdr2	=	op2
00010D70 =0000000A                M spdr3	=	op3
00010D70 =0000000E                M spdr4	=	op4
00010D70                            	spSustainLv	$0F, $0F, $04, $0F
00010D70 =0000000F                M spsl1	=	op1
00010D70 =0000000F                M spsl2	=	op2
00010D70 =00000004                M spsl3	=	op3
00010D70 =0000000F                M spsl4	=	op4
00010D70                            	spReleaseRt	$08, $08, $08, $08
00010D70 =00000008                M sprr1	=	op1
00010D70 =00000008                M sprr2	=	op2
00010D70 =00000008                M sprr3	=	op3
00010D70 =00000008                M sprr4	=	op4
00010D70                            	spSSGEG		$00, $00, $00, $00
00010D70 =00000000                M spss1	=	op1
00010D70 =00000000                M spss2	=	op2
00010D70 =00000000                M spss3	=	op3
00010D70 =00000000                M spss4	=	op4
00010D70                            	spTotalLv	$17, $07, $04, $04
00010D70 =00000017                M sptl1	=	op1
00010D70 =00000007                M sptl2	=	op2
00010D70 =00000004                M sptl3	=	op3
00010D70 =00000004                M sptl4	=	op4
00010D70 04                       M 	dc.b	(spfe<<3)+spal
00010D71 =00000080                M sptlmask4	set	$80
00010D71 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010D71 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010D71 =00000000                M sptlmask1	set	((spal=7)<<7)
00010D71 0000 0102                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010D75 9F1F 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010D79 8A8A 9194                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010D7D 0E0A 0E0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010D81 F848 F8F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010D85 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010D89 1784 0784                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010D8D 4E41 54                  M 	dc.b	'NAT'
00010D90                            
00010D90                            	; Patch $18
00010D90                            	; $3A
00010D90                            	; $71, $0C, $33, $01,	$5F, $5F, $5F, $5F
00010D90                            	; $84, $89, $84, $8A,	$00, $01, $03, $06
00010D90                            	; $15, $12, $16, $28,	$25, $2F, $25, $03
00010D90                            	spAlgorithm	$02
00010D90 =00000019                M spatnum	=	spatnum+1
00010D90 =00000002                M spal	=	val
00010D90                            	spFeedback	$07
00010D90 =00000007                M spfe	=	val
00010D90                            	spDetune	$07, $03, $00, $00
00010D90 =00000007                M spde1	=	op1
00010D90 =00000003                M spde2	=	op2
00010D90 =00000000                M spde3	=	op3
00010D90 =00000000                M spde4	=	op4
00010D90                            	spMultiple	$01, $03, $0C, $01
00010D90 =00000001                M spmu1	=	op1
00010D90 =00000003                M spmu2	=	op2
00010D90 =0000000C                M spmu3	=	op3
00010D90 =00000001                M spmu4	=	op4
00010D90                            	spRateScale	$01, $01, $01, $01
00010D90 =00000001                M sprs1	=	op1
00010D90 =00000001                M sprs2	=	op2
00010D90 =00000001                M sprs3	=	op3
00010D90 =00000001                M sprs4	=	op4
00010D90                            	spAttackRt	$1F, $1F, $1F, $1F
00010D90 =0000001F                M spar1	=	op1
00010D90 =0000001F                M spar2	=	op2
00010D90 =0000001F                M spar3	=	op3
00010D90 =0000001F                M spar4	=	op4
00010D90                            	spAmpMod	$01, $01, $01, $01
00010D90 =00000001                M spam1	=	op1
00010D90 =00000001                M spam2	=	op2
00010D90 =00000001                M spam3	=	op3
00010D90 =00000001                M spam4	=	op4
00010D90                            	spSustainRt	$04, $04, $09, $0A
00010D90 =00000004                M spsr1	=	op1
00010D90 =00000004                M spsr2	=	op2
00010D90 =00000009                M spsr3	=	op3
00010D90 =0000000A                M spsr4	=	op4
00010D90                            	spDecayRt	$00, $03, $01, $06
00010D90 =00000000                M spdr1	=	op1
00010D90 =00000003                M spdr2	=	op2
00010D90 =00000001                M spdr3	=	op3
00010D90 =00000006                M spdr4	=	op4
00010D90                            	spSustainLv	$01, $01, $01, $02
00010D90 =00000001                M spsl1	=	op1
00010D90 =00000001                M spsl2	=	op2
00010D90 =00000001                M spsl3	=	op3
00010D90 =00000002                M spsl4	=	op4
00010D90                            	spReleaseRt	$05, $06, $02, $08
00010D90 =00000005                M sprr1	=	op1
00010D90 =00000006                M sprr2	=	op2
00010D90 =00000002                M sprr3	=	op3
00010D90 =00000008                M sprr4	=	op4
00010D90                            	spSSGEG		$00, $00, $00, $00
00010D90 =00000000                M spss1	=	op1
00010D90 =00000000                M spss2	=	op2
00010D90 =00000000                M spss3	=	op3
00010D90 =00000000                M spss4	=	op4
00010D90                            	spTotalLv	$25, $25, $2F, $03
00010D90 =00000025                M sptl1	=	op1
00010D90 =00000025                M sptl2	=	op2
00010D90 =0000002F                M sptl3	=	op3
00010D90 =00000003                M sptl4	=	op4
00010D90 3A                       M 	dc.b	(spfe<<3)+spal
00010D91 =00000080                M sptlmask4	set	$80
00010D91 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010D91 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010D91 =00000000                M sptlmask1	set	((spal=7)<<7)
00010D91 710C 3301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010D95 5F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010D99 8489 848A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010D9D 0001 0306                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010DA1 1512 1628                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010DA5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010DA9 252F 2583                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010DAD 4E41 54                  M 	dc.b	'NAT'
00010DB0                            
00010DB0                            	; Patch $19
00010DB0                            	; $3A
00010DB0                            	; $04, $02, $08, $02,	$1F, $1F, $1F, $1F
00010DB0                            	; $00, $00, $00, $11,	$15, $0F, $0B, $1F
00010DB0                            	; $00, $00, $00, $50,	$09, $07, $3F, $04
00010DB0                            	spAlgorithm	$02
00010DB0 =0000001A                M spatnum	=	spatnum+1
00010DB0 =00000002                M spal	=	val
00010DB0                            	spFeedback	$07
00010DB0 =00000007                M spfe	=	val
00010DB0                            	spDetune	$00, $00, $00, $00
00010DB0 =00000000                M spde1	=	op1
00010DB0 =00000000                M spde2	=	op2
00010DB0 =00000000                M spde3	=	op3
00010DB0 =00000000                M spde4	=	op4
00010DB0                            	spMultiple	$04, $08, $02, $02
00010DB0 =00000004                M spmu1	=	op1
00010DB0 =00000008                M spmu2	=	op2
00010DB0 =00000002                M spmu3	=	op3
00010DB0 =00000002                M spmu4	=	op4
00010DB0                            	spRateScale	$00, $00, $00, $00
00010DB0 =00000000                M sprs1	=	op1
00010DB0 =00000000                M sprs2	=	op2
00010DB0 =00000000                M sprs3	=	op3
00010DB0 =00000000                M sprs4	=	op4
00010DB0                            	spAttackRt	$1F, $1F, $1F, $1F
00010DB0 =0000001F                M spar1	=	op1
00010DB0 =0000001F                M spar2	=	op2
00010DB0 =0000001F                M spar3	=	op3
00010DB0 =0000001F                M spar4	=	op4
00010DB0                            	spAmpMod	$00, $00, $00, $00
00010DB0 =00000000                M spam1	=	op1
00010DB0 =00000000                M spam2	=	op2
00010DB0 =00000000                M spam3	=	op3
00010DB0 =00000000                M spam4	=	op4
00010DB0                            	spSustainRt	$00, $00, $00, $11
00010DB0 =00000000                M spsr1	=	op1
00010DB0 =00000000                M spsr2	=	op2
00010DB0 =00000000                M spsr3	=	op3
00010DB0 =00000011                M spsr4	=	op4
00010DB0                            	spDecayRt	$15, $0B, $0F, $1F
00010DB0 =00000015                M spdr1	=	op1
00010DB0 =0000000B                M spdr2	=	op2
00010DB0 =0000000F                M spdr3	=	op3
00010DB0 =0000001F                M spdr4	=	op4
00010DB0                            	spSustainLv	$00, $00, $00, $05
00010DB0 =00000000                M spsl1	=	op1
00010DB0 =00000000                M spsl2	=	op2
00010DB0 =00000000                M spsl3	=	op3
00010DB0 =00000005                M spsl4	=	op4
00010DB0                            	spReleaseRt	$00, $00, $00, $00
00010DB0 =00000000                M sprr1	=	op1
00010DB0 =00000000                M sprr2	=	op2
00010DB0 =00000000                M sprr3	=	op3
00010DB0 =00000000                M sprr4	=	op4
00010DB0                            	spSSGEG		$00, $00, $00, $00
00010DB0 =00000000                M spss1	=	op1
00010DB0 =00000000                M spss2	=	op2
00010DB0 =00000000                M spss3	=	op3
00010DB0 =00000000                M spss4	=	op4
00010DB0                            	spTotalLv	$09, $3F, $07, $04
00010DB0 =00000009                M sptl1	=	op1
00010DB0 =0000003F                M sptl2	=	op2
00010DB0 =00000007                M sptl3	=	op3
00010DB0 =00000004                M sptl4	=	op4
00010DB0 3A                       M 	dc.b	(spfe<<3)+spal
00010DB1 =00000080                M sptlmask4	set	$80
00010DB1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010DB1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010DB1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010DB1 0402 0802                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010DB5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010DB9 0000 0011                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010DBD 150F 0B1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010DC1 0000 0050                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010DC5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010DC9 0907 3F84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010DCD 4E41 54                  M 	dc.b	'NAT'
00010DD0                            
00010DD0                            	; Patch $1A
00010DD0                            	; $39
00010DD0                            	; $11, $0C, $00, $00,	$1F, $5F, $D4, $D3
00010DD0                            	; $07, $15, $0B, $0A,	$00, $10, $06, $01
00010DD0                            	; $17, $8D, $06, $06,	$27, $24, $0C, $05
00010DD0                            	spAlgorithm	$01
00010DD0 =0000001B                M spatnum	=	spatnum+1
00010DD0 =00000001                M spal	=	val
00010DD0                            	spFeedback	$07
00010DD0 =00000007                M spfe	=	val
00010DD0                            	spDetune	$01, $00, $00, $00
00010DD0 =00000001                M spde1	=	op1
00010DD0 =00000000                M spde2	=	op2
00010DD0 =00000000                M spde3	=	op3
00010DD0 =00000000                M spde4	=	op4
00010DD0                            	spMultiple	$01, $00, $0C, $00
00010DD0 =00000001                M spmu1	=	op1
00010DD0 =00000000                M spmu2	=	op2
00010DD0 =0000000C                M spmu3	=	op3
00010DD0 =00000000                M spmu4	=	op4
00010DD0                            	spRateScale	$00, $03, $01, $03
00010DD0 =00000000                M sprs1	=	op1
00010DD0 =00000003                M sprs2	=	op2
00010DD0 =00000001                M sprs3	=	op3
00010DD0 =00000003                M sprs4	=	op4
00010DD0                            	spAttackRt	$1F, $14, $1F, $13
00010DD0 =0000001F                M spar1	=	op1
00010DD0 =00000014                M spar2	=	op2
00010DD0 =0000001F                M spar3	=	op3
00010DD0 =00000013                M spar4	=	op4
00010DD0                            	spAmpMod	$00, $00, $00, $00
00010DD0 =00000000                M spam1	=	op1
00010DD0 =00000000                M spam2	=	op2
00010DD0 =00000000                M spam3	=	op3
00010DD0 =00000000                M spam4	=	op4
00010DD0                            	spSustainRt	$07, $0B, $15, $0A
00010DD0 =00000007                M spsr1	=	op1
00010DD0 =0000000B                M spsr2	=	op2
00010DD0 =00000015                M spsr3	=	op3
00010DD0 =0000000A                M spsr4	=	op4
00010DD0                            	spDecayRt	$00, $06, $10, $01
00010DD0 =00000000                M spdr1	=	op1
00010DD0 =00000006                M spdr2	=	op2
00010DD0 =00000010                M spdr3	=	op3
00010DD0 =00000001                M spdr4	=	op4
00010DD0                            	spSustainLv	$01, $00, $08, $00
00010DD0 =00000001                M spsl1	=	op1
00010DD0 =00000000                M spsl2	=	op2
00010DD0 =00000008                M spsl3	=	op3
00010DD0 =00000000                M spsl4	=	op4
00010DD0                            	spReleaseRt	$07, $06, $0D, $06
00010DD0 =00000007                M sprr1	=	op1
00010DD0 =00000006                M sprr2	=	op2
00010DD0 =0000000D                M sprr3	=	op3
00010DD0 =00000006                M sprr4	=	op4
00010DD0                            	spSSGEG		$00, $00, $00, $00
00010DD0 =00000000                M spss1	=	op1
00010DD0 =00000000                M spss2	=	op2
00010DD0 =00000000                M spss3	=	op3
00010DD0 =00000000                M spss4	=	op4
00010DD0                            	spTotalLv	$27, $0C, $24, $05
00010DD0 =00000027                M sptl1	=	op1
00010DD0 =0000000C                M sptl2	=	op2
00010DD0 =00000024                M sptl3	=	op3
00010DD0 =00000005                M sptl4	=	op4
00010DD0 39                       M 	dc.b	(spfe<<3)+spal
00010DD1 =00000080                M sptlmask4	set	$80
00010DD1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010DD1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010DD1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010DD1 110C 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010DD5 1F5F D4D3                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010DD9 0715 0B0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010DDD 0010 0601                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010DE1 178D 0606                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010DE5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010DE9 2724 0C85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010DED 4E41 54                  M 	dc.b	'NAT'
00010DF0                            
00010DF0                            	; Patch $1B
00010DF0                            	; $3A
00010DF0                            	; $60, $70, $21, $13,	$1F, $1F, $1F, $1F
00010DF0                            	; $08, $09, $09, $09,	$00, $00, $00, $00
00010DF0                            	; $FF, $FF, $FF, $FF,	$2C, $3C, $16, $05
00010DF0                            	spAlgorithm	$02
00010DF0 =0000001C                M spatnum	=	spatnum+1
00010DF0 =00000002                M spal	=	val
00010DF0                            	spFeedback	$07
00010DF0 =00000007                M spfe	=	val
00010DF0                            	spDetune	$06, $02, $07, $01
00010DF0 =00000006                M spde1	=	op1
00010DF0 =00000002                M spde2	=	op2
00010DF0 =00000007                M spde3	=	op3
00010DF0 =00000001                M spde4	=	op4
00010DF0                            	spMultiple	$00, $01, $00, $03
00010DF0 =00000000                M spmu1	=	op1
00010DF0 =00000001                M spmu2	=	op2
00010DF0 =00000000                M spmu3	=	op3
00010DF0 =00000003                M spmu4	=	op4
00010DF0                            	spRateScale	$00, $00, $00, $00
00010DF0 =00000000                M sprs1	=	op1
00010DF0 =00000000                M sprs2	=	op2
00010DF0 =00000000                M sprs3	=	op3
00010DF0 =00000000                M sprs4	=	op4
00010DF0                            	spAttackRt	$1F, $1F, $1F, $1F
00010DF0 =0000001F                M spar1	=	op1
00010DF0 =0000001F                M spar2	=	op2
00010DF0 =0000001F                M spar3	=	op3
00010DF0 =0000001F                M spar4	=	op4
00010DF0                            	spAmpMod	$00, $00, $00, $00
00010DF0 =00000000                M spam1	=	op1
00010DF0 =00000000                M spam2	=	op2
00010DF0 =00000000                M spam3	=	op3
00010DF0 =00000000                M spam4	=	op4
00010DF0                            	spSustainRt	$08, $09, $09, $09
00010DF0 =00000008                M spsr1	=	op1
00010DF0 =00000009                M spsr2	=	op2
00010DF0 =00000009                M spsr3	=	op3
00010DF0 =00000009                M spsr4	=	op4
00010DF0                            	spDecayRt	$00, $00, $00, $00
00010DF0 =00000000                M spdr1	=	op1
00010DF0 =00000000                M spdr2	=	op2
00010DF0 =00000000                M spdr3	=	op3
00010DF0 =00000000                M spdr4	=	op4
00010DF0                            	spSustainLv	$0F, $0F, $0F, $0F
00010DF0 =0000000F                M spsl1	=	op1
00010DF0 =0000000F                M spsl2	=	op2
00010DF0 =0000000F                M spsl3	=	op3
00010DF0 =0000000F                M spsl4	=	op4
00010DF0                            	spReleaseRt	$0F, $0F, $0F, $0F
00010DF0 =0000000F                M sprr1	=	op1
00010DF0 =0000000F                M sprr2	=	op2
00010DF0 =0000000F                M sprr3	=	op3
00010DF0 =0000000F                M sprr4	=	op4
00010DF0                            	spSSGEG		$00, $00, $00, $00
00010DF0 =00000000                M spss1	=	op1
00010DF0 =00000000                M spss2	=	op2
00010DF0 =00000000                M spss3	=	op3
00010DF0 =00000000                M spss4	=	op4
00010DF0                            	spTotalLv	$2C, $16, $3C, $05
00010DF0 =0000002C                M sptl1	=	op1
00010DF0 =00000016                M sptl2	=	op2
00010DF0 =0000003C                M sptl3	=	op3
00010DF0 =00000005                M sptl4	=	op4
00010DF0 3A                       M 	dc.b	(spfe<<3)+spal
00010DF1 =00000080                M sptlmask4	set	$80
00010DF1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010DF1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010DF1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010DF1 6070 2113                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010DF5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010DF9 0809 0909                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010DFD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E01 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E05 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E09 2C3C 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E0D 4E41 54                  M 	dc.b	'NAT'
00010E10                            
00010E10                            	; Patch $1C
00010E10                            	; $3A
00010E10                            	; $62, $62, $20, $13,	$1F, $1F, $1F, $1F
00010E10                            	; $05, $10, $05, $08,	$1F, $1F, $1F, $1F
00010E10                            	; $FF, $FF, $FF, $FF,	$2C, $3C, $16, $05
00010E10                            	spAlgorithm	$02
00010E10 =0000001D                M spatnum	=	spatnum+1
00010E10 =00000002                M spal	=	val
00010E10                            	spFeedback	$07
00010E10 =00000007                M spfe	=	val
00010E10                            	spDetune	$06, $02, $06, $01
00010E10 =00000006                M spde1	=	op1
00010E10 =00000002                M spde2	=	op2
00010E10 =00000006                M spde3	=	op3
00010E10 =00000001                M spde4	=	op4
00010E10                            	spMultiple	$02, $00, $02, $03
00010E10 =00000002                M spmu1	=	op1
00010E10 =00000000                M spmu2	=	op2
00010E10 =00000002                M spmu3	=	op3
00010E10 =00000003                M spmu4	=	op4
00010E10                            	spRateScale	$00, $00, $00, $00
00010E10 =00000000                M sprs1	=	op1
00010E10 =00000000                M sprs2	=	op2
00010E10 =00000000                M sprs3	=	op3
00010E10 =00000000                M sprs4	=	op4
00010E10                            	spAttackRt	$1F, $1F, $1F, $1F
00010E10 =0000001F                M spar1	=	op1
00010E10 =0000001F                M spar2	=	op2
00010E10 =0000001F                M spar3	=	op3
00010E10 =0000001F                M spar4	=	op4
00010E10                            	spAmpMod	$00, $00, $00, $00
00010E10 =00000000                M spam1	=	op1
00010E10 =00000000                M spam2	=	op2
00010E10 =00000000                M spam3	=	op3
00010E10 =00000000                M spam4	=	op4
00010E10                            	spSustainRt	$05, $05, $10, $08
00010E10 =00000005                M spsr1	=	op1
00010E10 =00000005                M spsr2	=	op2
00010E10 =00000010                M spsr3	=	op3
00010E10 =00000008                M spsr4	=	op4
00010E10                            	spDecayRt	$1F, $1F, $1F, $1F
00010E10 =0000001F                M spdr1	=	op1
00010E10 =0000001F                M spdr2	=	op2
00010E10 =0000001F                M spdr3	=	op3
00010E10 =0000001F                M spdr4	=	op4
00010E10                            	spSustainLv	$0F, $0F, $0F, $0F
00010E10 =0000000F                M spsl1	=	op1
00010E10 =0000000F                M spsl2	=	op2
00010E10 =0000000F                M spsl3	=	op3
00010E10 =0000000F                M spsl4	=	op4
00010E10                            	spReleaseRt	$0F, $0F, $0F, $0F
00010E10 =0000000F                M sprr1	=	op1
00010E10 =0000000F                M sprr2	=	op2
00010E10 =0000000F                M sprr3	=	op3
00010E10 =0000000F                M sprr4	=	op4
00010E10                            	spSSGEG		$00, $00, $00, $00
00010E10 =00000000                M spss1	=	op1
00010E10 =00000000                M spss2	=	op2
00010E10 =00000000                M spss3	=	op3
00010E10 =00000000                M spss4	=	op4
00010E10                            	spTotalLv	$2C, $16, $3C, $05
00010E10 =0000002C                M sptl1	=	op1
00010E10 =00000016                M sptl2	=	op2
00010E10 =0000003C                M sptl3	=	op3
00010E10 =00000005                M sptl4	=	op4
00010E10 3A                       M 	dc.b	(spfe<<3)+spal
00010E11 =00000080                M sptlmask4	set	$80
00010E11 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E11 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E11 =00000000                M sptlmask1	set	((spal=7)<<7)
00010E11 6262 2013                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E15 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E19 0510 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E1D 1F1F 1F1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E21 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E25 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E29 2C3C 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E2D 4E41 54                  M 	dc.b	'NAT'
00010E30                            
00010E30                            	; Patch $1D
00010E30                            	; $17
00010E30                            	; $08, $70, $70, $30,	$1F, $19, $1C, $5F
00010E30                            	; $93, $8F, $93, $95,	$00, $09, $06, $09
00010E30                            	; $2F, $3F, $0C, $1A,	$05, $13, $20, $0B
00010E30                            	spAlgorithm	$07
00010E30 =0000001E                M spatnum	=	spatnum+1
00010E30 =00000007                M spal	=	val
00010E30                            	spFeedback	$02
00010E30 =00000002                M spfe	=	val
00010E30                            	spDetune	$00, $07, $07, $03
00010E30 =00000000                M spde1	=	op1
00010E30 =00000007                M spde2	=	op2
00010E30 =00000007                M spde3	=	op3
00010E30 =00000003                M spde4	=	op4
00010E30                            	spMultiple	$08, $00, $00, $00
00010E30 =00000008                M spmu1	=	op1
00010E30 =00000000                M spmu2	=	op2
00010E30 =00000000                M spmu3	=	op3
00010E30 =00000000                M spmu4	=	op4
00010E30                            	spRateScale	$00, $00, $00, $01
00010E30 =00000000                M sprs1	=	op1
00010E30 =00000000                M sprs2	=	op2
00010E30 =00000000                M sprs3	=	op3
00010E30 =00000001                M sprs4	=	op4
00010E30                            	spAttackRt	$1F, $1C, $19, $1F
00010E30 =0000001F                M spar1	=	op1
00010E30 =0000001C                M spar2	=	op2
00010E30 =00000019                M spar3	=	op3
00010E30 =0000001F                M spar4	=	op4
00010E30                            	spAmpMod	$01, $01, $01, $01
00010E30 =00000001                M spam1	=	op1
00010E30 =00000001                M spam2	=	op2
00010E30 =00000001                M spam3	=	op3
00010E30 =00000001                M spam4	=	op4
00010E30                            	spSustainRt	$13, $13, $0F, $15
00010E30 =00000013                M spsr1	=	op1
00010E30 =00000013                M spsr2	=	op2
00010E30 =0000000F                M spsr3	=	op3
00010E30 =00000015                M spsr4	=	op4
00010E30                            	spDecayRt	$00, $06, $09, $09
00010E30 =00000000                M spdr1	=	op1
00010E30 =00000006                M spdr2	=	op2
00010E30 =00000009                M spdr3	=	op3
00010E30 =00000009                M spdr4	=	op4
00010E30                            	spSustainLv	$02, $00, $03, $01
00010E30 =00000002                M spsl1	=	op1
00010E30 =00000000                M spsl2	=	op2
00010E30 =00000003                M spsl3	=	op3
00010E30 =00000001                M spsl4	=	op4
00010E30                            	spReleaseRt	$0F, $0C, $0F, $0A
00010E30 =0000000F                M sprr1	=	op1
00010E30 =0000000C                M sprr2	=	op2
00010E30 =0000000F                M sprr3	=	op3
00010E30 =0000000A                M sprr4	=	op4
00010E30                            	spSSGEG		$00, $00, $00, $00
00010E30 =00000000                M spss1	=	op1
00010E30 =00000000                M spss2	=	op2
00010E30 =00000000                M spss3	=	op3
00010E30 =00000000                M spss4	=	op4
00010E30                            	spTotalLv	$05, $20, $13, $0B
00010E30 =00000005                M sptl1	=	op1
00010E30 =00000020                M sptl2	=	op2
00010E30 =00000013                M sptl3	=	op3
00010E30 =0000000B                M sptl4	=	op4
00010E30 17                       M 	dc.b	(spfe<<3)+spal
00010E31 =00000080                M sptlmask4	set	$80
00010E31 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010E31 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010E31 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
00010E31 0870 7030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E35 1F19 1C5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E39 938F 9395                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E3D 0009 0609                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E41 2F3F 0C1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E45 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E49 8593 A08B                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E4D 4E41 54                  M 	dc.b	'NAT'
00010E50                            
00010E50                            	; Patch $1E
00010E50                            	; $33
00010E50                            	; $52, $60, $1B, $31,	$9A, $1F, $9C, $9F
00010E50                            	; $08, $1F, $09, $19,	$00, $00, $00, $02
00010E50                            	; $05, $16, $07, $08,	$23, $04, $19, $05
00010E50                            	spAlgorithm	$03
00010E50 =0000001F                M spatnum	=	spatnum+1
00010E50 =00000003                M spal	=	val
00010E50                            	spFeedback	$06
00010E50 =00000006                M spfe	=	val
00010E50                            	spDetune	$05, $01, $06, $03
00010E50 =00000005                M spde1	=	op1
00010E50 =00000001                M spde2	=	op2
00010E50 =00000006                M spde3	=	op3
00010E50 =00000003                M spde4	=	op4
00010E50                            	spMultiple	$02, $0B, $00, $01
00010E50 =00000002                M spmu1	=	op1
00010E50 =0000000B                M spmu2	=	op2
00010E50 =00000000                M spmu3	=	op3
00010E50 =00000001                M spmu4	=	op4
00010E50                            	spRateScale	$02, $02, $00, $02
00010E50 =00000002                M sprs1	=	op1
00010E50 =00000002                M sprs2	=	op2
00010E50 =00000000                M sprs3	=	op3
00010E50 =00000002                M sprs4	=	op4
00010E50                            	spAttackRt	$1A, $1C, $1F, $1F
00010E50 =0000001A                M spar1	=	op1
00010E50 =0000001C                M spar2	=	op2
00010E50 =0000001F                M spar3	=	op3
00010E50 =0000001F                M spar4	=	op4
00010E50                            	spAmpMod	$00, $00, $00, $00
00010E50 =00000000                M spam1	=	op1
00010E50 =00000000                M spam2	=	op2
00010E50 =00000000                M spam3	=	op3
00010E50 =00000000                M spam4	=	op4
00010E50                            	spSustainRt	$08, $09, $1F, $19
00010E50 =00000008                M spsr1	=	op1
00010E50 =00000009                M spsr2	=	op2
00010E50 =0000001F                M spsr3	=	op3
00010E50 =00000019                M spsr4	=	op4
00010E50                            	spDecayRt	$00, $00, $00, $02
00010E50 =00000000                M spdr1	=	op1
00010E50 =00000000                M spdr2	=	op2
00010E50 =00000000                M spdr3	=	op3
00010E50 =00000002                M spdr4	=	op4
00010E50                            	spSustainLv	$00, $00, $01, $00
00010E50 =00000000                M spsl1	=	op1
00010E50 =00000000                M spsl2	=	op2
00010E50 =00000001                M spsl3	=	op3
00010E50 =00000000                M spsl4	=	op4
00010E50                            	spReleaseRt	$05, $07, $06, $08
00010E50 =00000005                M sprr1	=	op1
00010E50 =00000007                M sprr2	=	op2
00010E50 =00000006                M sprr3	=	op3
00010E50 =00000008                M sprr4	=	op4
00010E50                            	spSSGEG		$00, $00, $00, $00
00010E50 =00000000                M spss1	=	op1
00010E50 =00000000                M spss2	=	op2
00010E50 =00000000                M spss3	=	op3
00010E50 =00000000                M spss4	=	op4
00010E50                            	spTotalLv	$23, $19, $04, $05
00010E50 =00000023                M sptl1	=	op1
00010E50 =00000019                M sptl2	=	op2
00010E50 =00000004                M sptl3	=	op3
00010E50 =00000005                M sptl4	=	op4
00010E50 33                       M 	dc.b	(spfe<<3)+spal
00010E51 =00000080                M sptlmask4	set	$80
00010E51 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E51 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E51 =00000000                M sptlmask1	set	((spal=7)<<7)
00010E51 5260 1B31                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E55 9A1F 9C9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E59 081F 0919                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E5D 0000 0002                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E61 0516 0708                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E65 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E69 2304 1985                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E6D 4E41 54                  M 	dc.b	'NAT'
00010E70                            
00010E70                            	; Patch $1F
00010E70                            	; $1B
00010E70                            	; $31, $13, $71, $52,	$18, $10, $16, $13
00010E70                            	; $17, $9F, $1F, $1F,	$00, $00, $00, $00
00010E70                            	; $06, $01, $07, $0C,	$0C, $10, $0E, $05
00010E70                            	spAlgorithm	$03
00010E70 =00000020                M spatnum	=	spatnum+1
00010E70 =00000003                M spal	=	val
00010E70                            	spFeedback	$03
00010E70 =00000003                M spfe	=	val
00010E70                            	spDetune	$03, $07, $01, $05
00010E70 =00000003                M spde1	=	op1
00010E70 =00000007                M spde2	=	op2
00010E70 =00000001                M spde3	=	op3
00010E70 =00000005                M spde4	=	op4
00010E70                            	spMultiple	$01, $01, $03, $02
00010E70 =00000001                M spmu1	=	op1
00010E70 =00000001                M spmu2	=	op2
00010E70 =00000003                M spmu3	=	op3
00010E70 =00000002                M spmu4	=	op4
00010E70                            	spRateScale	$00, $00, $00, $00
00010E70 =00000000                M sprs1	=	op1
00010E70 =00000000                M sprs2	=	op2
00010E70 =00000000                M sprs3	=	op3
00010E70 =00000000                M sprs4	=	op4
00010E70                            	spAttackRt	$18, $16, $10, $13
00010E70 =00000018                M spar1	=	op1
00010E70 =00000016                M spar2	=	op2
00010E70 =00000010                M spar3	=	op3
00010E70 =00000013                M spar4	=	op4
00010E70                            	spAmpMod	$00, $00, $01, $00
00010E70 =00000000                M spam1	=	op1
00010E70 =00000000                M spam2	=	op2
00010E70 =00000001                M spam3	=	op3
00010E70 =00000000                M spam4	=	op4
00010E70                            	spSustainRt	$17, $1F, $1F, $1F
00010E70 =00000017                M spsr1	=	op1
00010E70 =0000001F                M spsr2	=	op2
00010E70 =0000001F                M spsr3	=	op3
00010E70 =0000001F                M spsr4	=	op4
00010E70                            	spDecayRt	$00, $00, $00, $00
00010E70 =00000000                M spdr1	=	op1
00010E70 =00000000                M spdr2	=	op2
00010E70 =00000000                M spdr3	=	op3
00010E70 =00000000                M spdr4	=	op4
00010E70                            	spSustainLv	$00, $00, $00, $00
00010E70 =00000000                M spsl1	=	op1
00010E70 =00000000                M spsl2	=	op2
00010E70 =00000000                M spsl3	=	op3
00010E70 =00000000                M spsl4	=	op4
00010E70                            	spReleaseRt	$06, $07, $01, $0C
00010E70 =00000006                M sprr1	=	op1
00010E70 =00000007                M sprr2	=	op2
00010E70 =00000001                M sprr3	=	op3
00010E70 =0000000C                M sprr4	=	op4
00010E70                            	spSSGEG		$00, $00, $00, $00
00010E70 =00000000                M spss1	=	op1
00010E70 =00000000                M spss2	=	op2
00010E70 =00000000                M spss3	=	op3
00010E70 =00000000                M spss4	=	op4
00010E70                            	spTotalLv	$0C, $0E, $10, $05
00010E70 =0000000C                M sptl1	=	op1
00010E70 =0000000E                M sptl2	=	op2
00010E70 =00000010                M sptl3	=	op3
00010E70 =00000005                M sptl4	=	op4
00010E70 1B                       M 	dc.b	(spfe<<3)+spal
00010E71 =00000080                M sptlmask4	set	$80
00010E71 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E71 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E71 =00000000                M sptlmask1	set	((spal=7)<<7)
00010E71 3113 7152                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E75 1810 1613                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E79 179F 1F1F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E7D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E81 0601 070C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E85 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E89 0C10 0E85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E8D 4E41 54                  M 	dc.b	'NAT'
00010E90                            
00010E90                            	; Patch $20
00010E90                            	; $11
00010E90                            	; $01, $75, $64, $31,	$1F, $9F, $5F, $9F
00010E90                            	; $04, $88, $06, $01,	$02, $02, $02, $02
00010E90                            	; $81, $31, $51, $6A,	$08, $12, $16, $05
00010E90                            	spAlgorithm	$01
00010E90 =00000021                M spatnum	=	spatnum+1
00010E90 =00000001                M spal	=	val
00010E90                            	spFeedback	$02
00010E90 =00000002                M spfe	=	val
00010E90                            	spDetune	$00, $06, $07, $03
00010E90 =00000000                M spde1	=	op1
00010E90 =00000006                M spde2	=	op2
00010E90 =00000007                M spde3	=	op3
00010E90 =00000003                M spde4	=	op4
00010E90                            	spMultiple	$01, $04, $05, $01
00010E90 =00000001                M spmu1	=	op1
00010E90 =00000004                M spmu2	=	op2
00010E90 =00000005                M spmu3	=	op3
00010E90 =00000001                M spmu4	=	op4
00010E90                            	spRateScale	$00, $01, $02, $02
00010E90 =00000000                M sprs1	=	op1
00010E90 =00000001                M sprs2	=	op2
00010E90 =00000002                M sprs3	=	op3
00010E90 =00000002                M sprs4	=	op4
00010E90                            	spAttackRt	$1F, $1F, $1F, $1F
00010E90 =0000001F                M spar1	=	op1
00010E90 =0000001F                M spar2	=	op2
00010E90 =0000001F                M spar3	=	op3
00010E90 =0000001F                M spar4	=	op4
00010E90                            	spAmpMod	$00, $00, $01, $00
00010E90 =00000000                M spam1	=	op1
00010E90 =00000000                M spam2	=	op2
00010E90 =00000001                M spam3	=	op3
00010E90 =00000000                M spam4	=	op4
00010E90                            	spSustainRt	$04, $06, $08, $01
00010E90 =00000004                M spsr1	=	op1
00010E90 =00000006                M spsr2	=	op2
00010E90 =00000008                M spsr3	=	op3
00010E90 =00000001                M spsr4	=	op4
00010E90                            	spDecayRt	$02, $02, $02, $02
00010E90 =00000002                M spdr1	=	op1
00010E90 =00000002                M spdr2	=	op2
00010E90 =00000002                M spdr3	=	op3
00010E90 =00000002                M spdr4	=	op4
00010E90                            	spSustainLv	$08, $05, $03, $06
00010E90 =00000008                M spsl1	=	op1
00010E90 =00000005                M spsl2	=	op2
00010E90 =00000003                M spsl3	=	op3
00010E90 =00000006                M spsl4	=	op4
00010E90                            	spReleaseRt	$01, $01, $01, $0A
00010E90 =00000001                M sprr1	=	op1
00010E90 =00000001                M sprr2	=	op2
00010E90 =00000001                M sprr3	=	op3
00010E90 =0000000A                M sprr4	=	op4
00010E90                            	spSSGEG		$00, $00, $00, $00
00010E90 =00000000                M spss1	=	op1
00010E90 =00000000                M spss2	=	op2
00010E90 =00000000                M spss3	=	op3
00010E90 =00000000                M spss4	=	op4
00010E90                            	spTotalLv	$08, $16, $12, $05
00010E90 =00000008                M sptl1	=	op1
00010E90 =00000016                M sptl2	=	op2
00010E90 =00000012                M sptl3	=	op3
00010E90 =00000005                M sptl4	=	op4
00010E90 11                       M 	dc.b	(spfe<<3)+spal
00010E91 =00000080                M sptlmask4	set	$80
00010E91 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E91 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E91 =00000000                M sptlmask1	set	((spal=7)<<7)
00010E91 0175 6431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E95 1F9F 5F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E99 0488 0601                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E9D 0202 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EA1 8131 516A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EA5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010EA9 0812 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010EAD 4E41 54                  M 	dc.b	'NAT'
00010EB0                            
00010EB0                            	; Patch $21
00010EB0                            	; $22
00010EB0                            	; $50, $05, $10, $00,	$D8, $DD, $DD, $9F
00010EB0                            	; $04, $05, $08, $0B,	$00, $00, $00, $06
00010EB0                            	; $FC, $FF, $FC, $FF,	$14, $16, $2B, $02
00010EB0                            	spAlgorithm	$02
00010EB0 =00000022                M spatnum	=	spatnum+1
00010EB0 =00000002                M spal	=	val
00010EB0                            	spFeedback	$04
00010EB0 =00000004                M spfe	=	val
00010EB0                            	spDetune	$05, $01, $00, $00
00010EB0 =00000005                M spde1	=	op1
00010EB0 =00000001                M spde2	=	op2
00010EB0 =00000000                M spde3	=	op3
00010EB0 =00000000                M spde4	=	op4
00010EB0                            	spMultiple	$00, $00, $05, $00
00010EB0 =00000000                M spmu1	=	op1
00010EB0 =00000000                M spmu2	=	op2
00010EB0 =00000005                M spmu3	=	op3
00010EB0 =00000000                M spmu4	=	op4
00010EB0                            	spRateScale	$03, $03, $03, $02
00010EB0 =00000003                M sprs1	=	op1
00010EB0 =00000003                M sprs2	=	op2
00010EB0 =00000003                M sprs3	=	op3
00010EB0 =00000002                M sprs4	=	op4
00010EB0                            	spAttackRt	$18, $1D, $1D, $1F
00010EB0 =00000018                M spar1	=	op1
00010EB0 =0000001D                M spar2	=	op2
00010EB0 =0000001D                M spar3	=	op3
00010EB0 =0000001F                M spar4	=	op4
00010EB0                            	spAmpMod	$00, $00, $00, $00
00010EB0 =00000000                M spam1	=	op1
00010EB0 =00000000                M spam2	=	op2
00010EB0 =00000000                M spam3	=	op3
00010EB0 =00000000                M spam4	=	op4
00010EB0                            	spSustainRt	$04, $08, $05, $0B
00010EB0 =00000004                M spsr1	=	op1
00010EB0 =00000008                M spsr2	=	op2
00010EB0 =00000005                M spsr3	=	op3
00010EB0 =0000000B                M spsr4	=	op4
00010EB0                            	spDecayRt	$00, $00, $00, $06
00010EB0 =00000000                M spdr1	=	op1
00010EB0 =00000000                M spdr2	=	op2
00010EB0 =00000000                M spdr3	=	op3
00010EB0 =00000006                M spdr4	=	op4
00010EB0                            	spSustainLv	$0F, $0F, $0F, $0F
00010EB0 =0000000F                M spsl1	=	op1
00010EB0 =0000000F                M spsl2	=	op2
00010EB0 =0000000F                M spsl3	=	op3
00010EB0 =0000000F                M spsl4	=	op4
00010EB0                            	spReleaseRt	$0C, $0C, $0F, $0F
00010EB0 =0000000C                M sprr1	=	op1
00010EB0 =0000000C                M sprr2	=	op2
00010EB0 =0000000F                M sprr3	=	op3
00010EB0 =0000000F                M sprr4	=	op4
00010EB0                            	spSSGEG		$00, $00, $00, $00
00010EB0 =00000000                M spss1	=	op1
00010EB0 =00000000                M spss2	=	op2
00010EB0 =00000000                M spss3	=	op3
00010EB0 =00000000                M spss4	=	op4
00010EB0                            	spTotalLv	$14, $2B, $16, $02
00010EB0 =00000014                M sptl1	=	op1
00010EB0 =0000002B                M sptl2	=	op2
00010EB0 =00000016                M sptl3	=	op3
00010EB0 =00000002                M sptl4	=	op4
00010EB0 22                       M 	dc.b	(spfe<<3)+spal
00010EB1 =00000080                M sptlmask4	set	$80
00010EB1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010EB1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010EB1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010EB1 5005 1000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EB5 D8DD DD9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EB9 0405 080B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EBD 0000 0006                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EC1 FCFF FCFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EC5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010EC9 1416 2B82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010ECD 4E41 54                  M 	dc.b	'NAT'
00010ED0                            
00010ED0                            	; Patch $22
00010ED0                            	; $35
00010ED0                            	; $01, $00, $72, $31,	$9F, $14, $52, $52
00010ED0                            	; $0A, $8A, $8A, $0A,	$09, $0E, $0F, $10
00010ED0                            	; $11, $26, $26, $26,	$0F, $08, $05, $05
00010ED0                            	spAlgorithm	$05
00010ED0 =00000023                M spatnum	=	spatnum+1
00010ED0 =00000005                M spal	=	val
00010ED0                            	spFeedback	$06
00010ED0 =00000006                M spfe	=	val
00010ED0                            	spDetune	$00, $07, $00, $03
00010ED0 =00000000                M spde1	=	op1
00010ED0 =00000007                M spde2	=	op2
00010ED0 =00000000                M spde3	=	op3
00010ED0 =00000003                M spde4	=	op4
00010ED0                            	spMultiple	$01, $02, $00, $01
00010ED0 =00000001                M spmu1	=	op1
00010ED0 =00000002                M spmu2	=	op2
00010ED0 =00000000                M spmu3	=	op3
00010ED0 =00000001                M spmu4	=	op4
00010ED0                            	spRateScale	$02, $01, $00, $01
00010ED0 =00000002                M sprs1	=	op1
00010ED0 =00000001                M sprs2	=	op2
00010ED0 =00000000                M sprs3	=	op3
00010ED0 =00000001                M sprs4	=	op4
00010ED0                            	spAttackRt	$1F, $12, $14, $12
00010ED0 =0000001F                M spar1	=	op1
00010ED0 =00000012                M spar2	=	op2
00010ED0 =00000014                M spar3	=	op3
00010ED0 =00000012                M spar4	=	op4
00010ED0                            	spAmpMod	$00, $01, $01, $00
00010ED0 =00000000                M spam1	=	op1
00010ED0 =00000001                M spam2	=	op2
00010ED0 =00000001                M spam3	=	op3
00010ED0 =00000000                M spam4	=	op4
00010ED0                            	spSustainRt	$0A, $0A, $0A, $0A
00010ED0 =0000000A                M spsr1	=	op1
00010ED0 =0000000A                M spsr2	=	op2
00010ED0 =0000000A                M spsr3	=	op3
00010ED0 =0000000A                M spsr4	=	op4
00010ED0                            	spDecayRt	$09, $0F, $0E, $10
00010ED0 =00000009                M spdr1	=	op1
00010ED0 =0000000F                M spdr2	=	op2
00010ED0 =0000000E                M spdr3	=	op3
00010ED0 =00000010                M spdr4	=	op4
00010ED0                            	spSustainLv	$01, $02, $02, $02
00010ED0 =00000001                M spsl1	=	op1
00010ED0 =00000002                M spsl2	=	op2
00010ED0 =00000002                M spsl3	=	op3
00010ED0 =00000002                M spsl4	=	op4
00010ED0                            	spReleaseRt	$01, $06, $06, $06
00010ED0 =00000001                M sprr1	=	op1
00010ED0 =00000006                M sprr2	=	op2
00010ED0 =00000006                M sprr3	=	op3
00010ED0 =00000006                M sprr4	=	op4
00010ED0                            	spSSGEG		$00, $00, $00, $00
00010ED0 =00000000                M spss1	=	op1
00010ED0 =00000000                M spss2	=	op2
00010ED0 =00000000                M spss3	=	op3
00010ED0 =00000000                M spss4	=	op4
00010ED0                            	spTotalLv	$0F, $05, $08, $05
00010ED0 =0000000F                M sptl1	=	op1
00010ED0 =00000005                M sptl2	=	op2
00010ED0 =00000008                M sptl3	=	op3
00010ED0 =00000005                M sptl4	=	op4
00010ED0 35                       M 	dc.b	(spfe<<3)+spal
00010ED1 =00000080                M sptlmask4	set	$80
00010ED1 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010ED1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010ED1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010ED1 0100 7231                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010ED5 9F14 5252                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010ED9 0A8A 8A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EDD 090E 0F10                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EE1 1126 2626                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EE5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010EE9 0F88 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010EED 4E41 54                  M 	dc.b	'NAT'
00010EF0                            
00010EF0                            	; Patch $23
00010EF0                            	; $0D
00010EF0                            	; $50, $02, $14, $00,	$9D, $5E, $9D, $5C
00010EF0                            	; $8C, $09, $8B, $02,	$00, $00, $09, $00
00010EF0                            	; $FF, $FF, $FF, $FF,	$0C, $10, $0B, $05
00010EF0                            	spAlgorithm	$05
00010EF0 =00000024                M spatnum	=	spatnum+1
00010EF0 =00000005                M spal	=	val
00010EF0                            	spFeedback	$01
00010EF0 =00000001                M spfe	=	val
00010EF0                            	spDetune	$05, $01, $00, $00
00010EF0 =00000005                M spde1	=	op1
00010EF0 =00000001                M spde2	=	op2
00010EF0 =00000000                M spde3	=	op3
00010EF0 =00000000                M spde4	=	op4
00010EF0                            	spMultiple	$00, $04, $02, $00
00010EF0 =00000000                M spmu1	=	op1
00010EF0 =00000004                M spmu2	=	op2
00010EF0 =00000002                M spmu3	=	op3
00010EF0 =00000000                M spmu4	=	op4
00010EF0                            	spRateScale	$02, $02, $01, $01
00010EF0 =00000002                M sprs1	=	op1
00010EF0 =00000002                M sprs2	=	op2
00010EF0 =00000001                M sprs3	=	op3
00010EF0 =00000001                M sprs4	=	op4
00010EF0                            	spAttackRt	$1D, $1D, $1E, $1C
00010EF0 =0000001D                M spar1	=	op1
00010EF0 =0000001D                M spar2	=	op2
00010EF0 =0000001E                M spar3	=	op3
00010EF0 =0000001C                M spar4	=	op4
00010EF0                            	spAmpMod	$01, $01, $00, $00
00010EF0 =00000001                M spam1	=	op1
00010EF0 =00000001                M spam2	=	op2
00010EF0 =00000000                M spam3	=	op3
00010EF0 =00000000                M spam4	=	op4
00010EF0                            	spSustainRt	$0C, $0B, $09, $02
00010EF0 =0000000C                M spsr1	=	op1
00010EF0 =0000000B                M spsr2	=	op2
00010EF0 =00000009                M spsr3	=	op3
00010EF0 =00000002                M spsr4	=	op4
00010EF0                            	spDecayRt	$00, $09, $00, $00
00010EF0 =00000000                M spdr1	=	op1
00010EF0 =00000009                M spdr2	=	op2
00010EF0 =00000000                M spdr3	=	op3
00010EF0 =00000000                M spdr4	=	op4
00010EF0                            	spSustainLv	$0F, $0F, $0F, $0F
00010EF0 =0000000F                M spsl1	=	op1
00010EF0 =0000000F                M spsl2	=	op2
00010EF0 =0000000F                M spsl3	=	op3
00010EF0 =0000000F                M spsl4	=	op4
00010EF0                            	spReleaseRt	$0F, $0F, $0F, $0F
00010EF0 =0000000F                M sprr1	=	op1
00010EF0 =0000000F                M sprr2	=	op2
00010EF0 =0000000F                M sprr3	=	op3
00010EF0 =0000000F                M sprr4	=	op4
00010EF0                            	spSSGEG		$00, $00, $00, $00
00010EF0 =00000000                M spss1	=	op1
00010EF0 =00000000                M spss2	=	op2
00010EF0 =00000000                M spss3	=	op3
00010EF0 =00000000                M spss4	=	op4
00010EF0                            	spTotalLv	$0C, $0B, $10, $05
00010EF0 =0000000C                M sptl1	=	op1
00010EF0 =0000000B                M sptl2	=	op2
00010EF0 =00000010                M sptl3	=	op3
00010EF0 =00000005                M sptl4	=	op4
00010EF0 0D                       M 	dc.b	(spfe<<3)+spal
00010EF1 =00000080                M sptlmask4	set	$80
00010EF1 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010EF1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010EF1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010EF1 5002 1400                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EF5 9D5E 9D5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EF9 8C09 8B02                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EFD 0000 0900                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F01 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F05 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F09 0C90 8B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F0D 4E41 54                  M 	dc.b	'NAT'
00010F10                            
00010F10                            	; Patch $24
00010F10                            	; $35
00010F10                            	; $30, $01, $70, $30,	$5F, $57, $56, $5F
00010F10                            	; $19, $0A, $0A, $0A,	$0F, $0F, $0F, $0F
00010F10                            	; $05, $35, $35, $35,	$13, $05, $05, $05
00010F10                            	spAlgorithm	$05
00010F10 =00000025                M spatnum	=	spatnum+1
00010F10 =00000005                M spal	=	val
00010F10                            	spFeedback	$06
00010F10 =00000006                M spfe	=	val
00010F10                            	spDetune	$03, $07, $00, $03
00010F10 =00000003                M spde1	=	op1
00010F10 =00000007                M spde2	=	op2
00010F10 =00000000                M spde3	=	op3
00010F10 =00000003                M spde4	=	op4
00010F10                            	spMultiple	$00, $00, $01, $00
00010F10 =00000000                M spmu1	=	op1
00010F10 =00000000                M spmu2	=	op2
00010F10 =00000001                M spmu3	=	op3
00010F10 =00000000                M spmu4	=	op4
00010F10                            	spRateScale	$01, $01, $01, $01
00010F10 =00000001                M sprs1	=	op1
00010F10 =00000001                M sprs2	=	op2
00010F10 =00000001                M sprs3	=	op3
00010F10 =00000001                M sprs4	=	op4
00010F10                            	spAttackRt	$1F, $16, $17, $1F
00010F10 =0000001F                M spar1	=	op1
00010F10 =00000016                M spar2	=	op2
00010F10 =00000017                M spar3	=	op3
00010F10 =0000001F                M spar4	=	op4
00010F10                            	spAmpMod	$00, $00, $00, $00
00010F10 =00000000                M spam1	=	op1
00010F10 =00000000                M spam2	=	op2
00010F10 =00000000                M spam3	=	op3
00010F10 =00000000                M spam4	=	op4
00010F10                            	spSustainRt	$19, $0A, $0A, $0A
00010F10 =00000019                M spsr1	=	op1
00010F10 =0000000A                M spsr2	=	op2
00010F10 =0000000A                M spsr3	=	op3
00010F10 =0000000A                M spsr4	=	op4
00010F10                            	spDecayRt	$0F, $0F, $0F, $0F
00010F10 =0000000F                M spdr1	=	op1
00010F10 =0000000F                M spdr2	=	op2
00010F10 =0000000F                M spdr3	=	op3
00010F10 =0000000F                M spdr4	=	op4
00010F10                            	spSustainLv	$00, $03, $03, $03
00010F10 =00000000                M spsl1	=	op1
00010F10 =00000003                M spsl2	=	op2
00010F10 =00000003                M spsl3	=	op3
00010F10 =00000003                M spsl4	=	op4
00010F10                            	spReleaseRt	$05, $05, $05, $05
00010F10 =00000005                M sprr1	=	op1
00010F10 =00000005                M sprr2	=	op2
00010F10 =00000005                M sprr3	=	op3
00010F10 =00000005                M sprr4	=	op4
00010F10                            	spSSGEG		$00, $00, $00, $00
00010F10 =00000000                M spss1	=	op1
00010F10 =00000000                M spss2	=	op2
00010F10 =00000000                M spss3	=	op3
00010F10 =00000000                M spss4	=	op4
00010F10                            	spTotalLv	$13, $05, $05, $05
00010F10 =00000013                M sptl1	=	op1
00010F10 =00000005                M sptl2	=	op2
00010F10 =00000005                M sptl3	=	op3
00010F10 =00000005                M sptl4	=	op4
00010F10 35                       M 	dc.b	(spfe<<3)+spal
00010F11 =00000080                M sptlmask4	set	$80
00010F11 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010F11 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F11 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F11 3001 7030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F15 5F57 565F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F19 190A 0A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F1D 0F0F 0F0F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F21 0535 3535                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F25 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F29 1385 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F2D 4E41 54                  M 	dc.b	'NAT'
00010F30                            
00010F30                            	; Patch $25
00010F30                            	; $3B
00010F30                            	; $00, $01, $00, $03,	$1F, $1F, $16, $14
00010F30                            	; $03, $02, $02, $00,	$02, $02, $02, $1F
00010F30                            	; $22, $14, $13, $15,	$0E, $04, $23, $04
00010F30                            	spAlgorithm	$03
00010F30 =00000026                M spatnum	=	spatnum+1
00010F30 =00000003                M spal	=	val
00010F30                            	spFeedback	$07
00010F30 =00000007                M spfe	=	val
00010F30                            	spDetune	$00, $00, $00, $00
00010F30 =00000000                M spde1	=	op1
00010F30 =00000000                M spde2	=	op2
00010F30 =00000000                M spde3	=	op3
00010F30 =00000000                M spde4	=	op4
00010F30                            	spMultiple	$00, $00, $01, $03
00010F30 =00000000                M spmu1	=	op1
00010F30 =00000000                M spmu2	=	op2
00010F30 =00000001                M spmu3	=	op3
00010F30 =00000003                M spmu4	=	op4
00010F30                            	spRateScale	$00, $00, $00, $00
00010F30 =00000000                M sprs1	=	op1
00010F30 =00000000                M sprs2	=	op2
00010F30 =00000000                M sprs3	=	op3
00010F30 =00000000                M sprs4	=	op4
00010F30                            	spAttackRt	$1F, $16, $1F, $14
00010F30 =0000001F                M spar1	=	op1
00010F30 =00000016                M spar2	=	op2
00010F30 =0000001F                M spar3	=	op3
00010F30 =00000014                M spar4	=	op4
00010F30                            	spAmpMod	$00, $00, $00, $00
00010F30 =00000000                M spam1	=	op1
00010F30 =00000000                M spam2	=	op2
00010F30 =00000000                M spam3	=	op3
00010F30 =00000000                M spam4	=	op4
00010F30                            	spSustainRt	$03, $02, $02, $00
00010F30 =00000003                M spsr1	=	op1
00010F30 =00000002                M spsr2	=	op2
00010F30 =00000002                M spsr3	=	op3
00010F30 =00000000                M spsr4	=	op4
00010F30                            	spDecayRt	$02, $02, $02, $1F
00010F30 =00000002                M spdr1	=	op1
00010F30 =00000002                M spdr2	=	op2
00010F30 =00000002                M spdr3	=	op3
00010F30 =0000001F                M spdr4	=	op4
00010F30                            	spSustainLv	$02, $01, $01, $01
00010F30 =00000002                M spsl1	=	op1
00010F30 =00000001                M spsl2	=	op2
00010F30 =00000001                M spsl3	=	op3
00010F30 =00000001                M spsl4	=	op4
00010F30                            	spReleaseRt	$02, $03, $04, $05
00010F30 =00000002                M sprr1	=	op1
00010F30 =00000003                M sprr2	=	op2
00010F30 =00000004                M sprr3	=	op3
00010F30 =00000005                M sprr4	=	op4
00010F30                            	spSSGEG		$00, $00, $00, $00
00010F30 =00000000                M spss1	=	op1
00010F30 =00000000                M spss2	=	op2
00010F30 =00000000                M spss3	=	op3
00010F30 =00000000                M spss4	=	op4
00010F30                            	spTotalLv	$0E, $23, $04, $04
00010F30 =0000000E                M sptl1	=	op1
00010F30 =00000023                M sptl2	=	op2
00010F30 =00000004                M sptl3	=	op3
00010F30 =00000004                M sptl4	=	op4
00010F30 3B                       M 	dc.b	(spfe<<3)+spal
00010F31 =00000080                M sptlmask4	set	$80
00010F31 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F31 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010F31 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F31 0001 0003                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F35 1F1F 1614                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F39 0302 0200                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F3D 0202 021F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F41 2214 1315                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F45 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F49 0E04 2384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F4D 4E41 54                  M 	dc.b	'NAT'
00010F50                            
00010F50                            	; Patch $26
00010F50                            	; $3B
00010F50                            	; $30, $50, $33, $10,	$59, $55, $19, $1A
00010F50                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $03
00010F50                            	; $7E, $17, $27, $17,	$0F, $00, $0D, $05
00010F50                            	spAlgorithm	$03
00010F50 =00000027                M spatnum	=	spatnum+1
00010F50 =00000003                M spal	=	val
00010F50                            	spFeedback	$07
00010F50 =00000007                M spfe	=	val
00010F50                            	spDetune	$03, $03, $05, $01
00010F50 =00000003                M spde1	=	op1
00010F50 =00000003                M spde2	=	op2
00010F50 =00000005                M spde3	=	op3
00010F50 =00000001                M spde4	=	op4
00010F50                            	spMultiple	$00, $03, $00, $00
00010F50 =00000000                M spmu1	=	op1
00010F50 =00000003                M spmu2	=	op2
00010F50 =00000000                M spmu3	=	op3
00010F50 =00000000                M spmu4	=	op4
00010F50                            	spRateScale	$01, $00, $01, $00
00010F50 =00000001                M sprs1	=	op1
00010F50 =00000000                M sprs2	=	op2
00010F50 =00000001                M sprs3	=	op3
00010F50 =00000000                M sprs4	=	op4
00010F50                            	spAttackRt	$19, $19, $15, $1A
00010F50 =00000019                M spar1	=	op1
00010F50 =00000019                M spar2	=	op2
00010F50 =00000015                M spar3	=	op3
00010F50 =0000001A                M spar4	=	op4
00010F50                            	spAmpMod	$00, $00, $00, $00
00010F50 =00000000                M spam1	=	op1
00010F50 =00000000                M spam2	=	op2
00010F50 =00000000                M spam3	=	op3
00010F50 =00000000                M spam4	=	op4
00010F50                            	spSustainRt	$00, $00, $00, $00
00010F50 =00000000                M spsr1	=	op1
00010F50 =00000000                M spsr2	=	op2
00010F50 =00000000                M spsr3	=	op3
00010F50 =00000000                M spsr4	=	op4
00010F50                            	spDecayRt	$1F, $1F, $1F, $03
00010F50 =0000001F                M spdr1	=	op1
00010F50 =0000001F                M spdr2	=	op2
00010F50 =0000001F                M spdr3	=	op3
00010F50 =00000003                M spdr4	=	op4
00010F50                            	spSustainLv	$07, $02, $01, $01
00010F50 =00000007                M spsl1	=	op1
00010F50 =00000002                M spsl2	=	op2
00010F50 =00000001                M spsl3	=	op3
00010F50 =00000001                M spsl4	=	op4
00010F50                            	spReleaseRt	$0E, $07, $07, $07
00010F50 =0000000E                M sprr1	=	op1
00010F50 =00000007                M sprr2	=	op2
00010F50 =00000007                M sprr3	=	op3
00010F50 =00000007                M sprr4	=	op4
00010F50                            	spSSGEG		$00, $00, $00, $00
00010F50 =00000000                M spss1	=	op1
00010F50 =00000000                M spss2	=	op2
00010F50 =00000000                M spss3	=	op3
00010F50 =00000000                M spss4	=	op4
00010F50                            	spTotalLv	$0F, $0D, $00, $05
00010F50 =0000000F                M sptl1	=	op1
00010F50 =0000000D                M sptl2	=	op2
00010F50 =00000000                M sptl3	=	op3
00010F50 =00000005                M sptl4	=	op4
00010F50 3B                       M 	dc.b	(spfe<<3)+spal
00010F51 =00000080                M sptlmask4	set	$80
00010F51 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F51 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010F51 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F51 3050 3310                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F55 5955 191A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F59 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F5D 1F1F 1F03                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F61 7E17 2717                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F65 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F69 0F00 0D85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F6D 4E41 54                  M 	dc.b	'NAT'
00010F70                            
00010F70                            	; Patch $27
00010F70                            	; $35
00010F70                            	; $21, $31, $20, $14,	$8E, $9B, $95, $94
00010F70                            	; $00, $05, $00, $80,	$01, $02, $02, $02
00010F70                            	; $4F, $3F, $1F, $0F,	$16, $06, $08, $05
00010F70                            	spAlgorithm	$05
00010F70 =00000028                M spatnum	=	spatnum+1
00010F70 =00000005                M spal	=	val
00010F70                            	spFeedback	$06
00010F70 =00000006                M spfe	=	val
00010F70                            	spDetune	$02, $02, $03, $01
00010F70 =00000002                M spde1	=	op1
00010F70 =00000002                M spde2	=	op2
00010F70 =00000003                M spde3	=	op3
00010F70 =00000001                M spde4	=	op4
00010F70                            	spMultiple	$01, $00, $01, $04
00010F70 =00000001                M spmu1	=	op1
00010F70 =00000000                M spmu2	=	op2
00010F70 =00000001                M spmu3	=	op3
00010F70 =00000004                M spmu4	=	op4
00010F70                            	spRateScale	$02, $02, $02, $02
00010F70 =00000002                M sprs1	=	op1
00010F70 =00000002                M sprs2	=	op2
00010F70 =00000002                M sprs3	=	op3
00010F70 =00000002                M sprs4	=	op4
00010F70                            	spAttackRt	$0E, $15, $1B, $14
00010F70 =0000000E                M spar1	=	op1
00010F70 =00000015                M spar2	=	op2
00010F70 =0000001B                M spar3	=	op3
00010F70 =00000014                M spar4	=	op4
00010F70                            	spAmpMod	$00, $00, $00, $01
00010F70 =00000000                M spam1	=	op1
00010F70 =00000000                M spam2	=	op2
00010F70 =00000000                M spam3	=	op3
00010F70 =00000001                M spam4	=	op4
00010F70                            	spSustainRt	$00, $00, $05, $00
00010F70 =00000000                M spsr1	=	op1
00010F70 =00000000                M spsr2	=	op2
00010F70 =00000005                M spsr3	=	op3
00010F70 =00000000                M spsr4	=	op4
00010F70                            	spDecayRt	$01, $02, $02, $02
00010F70 =00000001                M spdr1	=	op1
00010F70 =00000002                M spdr2	=	op2
00010F70 =00000002                M spdr3	=	op3
00010F70 =00000002                M spdr4	=	op4
00010F70                            	spSustainLv	$04, $01, $03, $00
00010F70 =00000004                M spsl1	=	op1
00010F70 =00000001                M spsl2	=	op2
00010F70 =00000003                M spsl3	=	op3
00010F70 =00000000                M spsl4	=	op4
00010F70                            	spReleaseRt	$0F, $0F, $0F, $0F
00010F70 =0000000F                M sprr1	=	op1
00010F70 =0000000F                M sprr2	=	op2
00010F70 =0000000F                M sprr3	=	op3
00010F70 =0000000F                M sprr4	=	op4
00010F70                            	spSSGEG		$00, $00, $00, $00
00010F70 =00000000                M spss1	=	op1
00010F70 =00000000                M spss2	=	op2
00010F70 =00000000                M spss3	=	op3
00010F70 =00000000                M spss4	=	op4
00010F70                            	spTotalLv	$16, $08, $06, $05
00010F70 =00000016                M sptl1	=	op1
00010F70 =00000008                M sptl2	=	op2
00010F70 =00000006                M sptl3	=	op3
00010F70 =00000005                M sptl4	=	op4
00010F70 35                       M 	dc.b	(spfe<<3)+spal
00010F71 =00000080                M sptlmask4	set	$80
00010F71 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010F71 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F71 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F71 2131 2014                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F75 8E9B 9594                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F79 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F7D 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F81 4F3F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F85 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F89 1686 8885                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F8D 4E41 54                  M 	dc.b	'NAT'
00010F90                            
00010F90                            	; Patch $28
00010F90                            	; $24
00010F90                            	; $01, $33, $00, $00,	$12, $0A, $0D, $0C
00010F90                            	; $00, $8F, $03, $0F,	$00, $00, $00, $00
00010F90                            	; $4F, $1F, $1F, $1F,	$03, $05, $10, $05
00010F90                            	spAlgorithm	$04
00010F90 =00000029                M spatnum	=	spatnum+1
00010F90 =00000004                M spal	=	val
00010F90                            	spFeedback	$04
00010F90 =00000004                M spfe	=	val
00010F90                            	spDetune	$00, $00, $03, $00
00010F90 =00000000                M spde1	=	op1
00010F90 =00000000                M spde2	=	op2
00010F90 =00000003                M spde3	=	op3
00010F90 =00000000                M spde4	=	op4
00010F90                            	spMultiple	$01, $00, $03, $00
00010F90 =00000001                M spmu1	=	op1
00010F90 =00000000                M spmu2	=	op2
00010F90 =00000003                M spmu3	=	op3
00010F90 =00000000                M spmu4	=	op4
00010F90                            	spRateScale	$00, $00, $00, $00
00010F90 =00000000                M sprs1	=	op1
00010F90 =00000000                M sprs2	=	op2
00010F90 =00000000                M sprs3	=	op3
00010F90 =00000000                M sprs4	=	op4
00010F90                            	spAttackRt	$12, $0D, $0A, $0C
00010F90 =00000012                M spar1	=	op1
00010F90 =0000000D                M spar2	=	op2
00010F90 =0000000A                M spar3	=	op3
00010F90 =0000000C                M spar4	=	op4
00010F90                            	spAmpMod	$00, $00, $01, $00
00010F90 =00000000                M spam1	=	op1
00010F90 =00000000                M spam2	=	op2
00010F90 =00000001                M spam3	=	op3
00010F90 =00000000                M spam4	=	op4
00010F90                            	spSustainRt	$00, $03, $0F, $0F
00010F90 =00000000                M spsr1	=	op1
00010F90 =00000003                M spsr2	=	op2
00010F90 =0000000F                M spsr3	=	op3
00010F90 =0000000F                M spsr4	=	op4
00010F90                            	spDecayRt	$00, $00, $00, $00
00010F90 =00000000                M spdr1	=	op1
00010F90 =00000000                M spdr2	=	op2
00010F90 =00000000                M spdr3	=	op3
00010F90 =00000000                M spdr4	=	op4
00010F90                            	spSustainLv	$04, $01, $01, $01
00010F90 =00000004                M spsl1	=	op1
00010F90 =00000001                M spsl2	=	op2
00010F90 =00000001                M spsl3	=	op3
00010F90 =00000001                M spsl4	=	op4
00010F90                            	spReleaseRt	$0F, $0F, $0F, $0F
00010F90 =0000000F                M sprr1	=	op1
00010F90 =0000000F                M sprr2	=	op2
00010F90 =0000000F                M sprr3	=	op3
00010F90 =0000000F                M sprr4	=	op4
00010F90                            	spSSGEG		$00, $00, $00, $00
00010F90 =00000000                M spss1	=	op1
00010F90 =00000000                M spss2	=	op2
00010F90 =00000000                M spss3	=	op3
00010F90 =00000000                M spss4	=	op4
00010F90                            	spTotalLv	$03, $10, $05, $05
00010F90 =00000003                M sptl1	=	op1
00010F90 =00000010                M sptl2	=	op2
00010F90 =00000005                M sptl3	=	op3
00010F90 =00000005                M sptl4	=	op4
00010F90 24                       M 	dc.b	(spfe<<3)+spal
00010F91 =00000080                M sptlmask4	set	$80
00010F91 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F91 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F91 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F91 0133 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F95 120A 0D0C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F99 008F 030F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F9D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FA1 4F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FA5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FA9 0385 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FAD 4E41 54                  M 	dc.b	'NAT'
00010FB0                            
00010FB0                            	; Patch $29
00010FB0                            	; $29
00010FB0                            	; $33, $50, $02, $25,	$9D, $56, $13, $5E
00010FB0                            	; $01, $01, $00, $01,	$15, $0F, $0C, $0F
00010FB0                            	; $4F, $3F, $3F, $3F,	$13, $10, $1B, $05
00010FB0                            	spAlgorithm	$01
00010FB0 =0000002A                M spatnum	=	spatnum+1
00010FB0 =00000001                M spal	=	val
00010FB0                            	spFeedback	$05
00010FB0 =00000005                M spfe	=	val
00010FB0                            	spDetune	$03, $00, $05, $02
00010FB0 =00000003                M spde1	=	op1
00010FB0 =00000000                M spde2	=	op2
00010FB0 =00000005                M spde3	=	op3
00010FB0 =00000002                M spde4	=	op4
00010FB0                            	spMultiple	$03, $02, $00, $05
00010FB0 =00000003                M spmu1	=	op1
00010FB0 =00000002                M spmu2	=	op2
00010FB0 =00000000                M spmu3	=	op3
00010FB0 =00000005                M spmu4	=	op4
00010FB0                            	spRateScale	$02, $00, $01, $01
00010FB0 =00000002                M sprs1	=	op1
00010FB0 =00000000                M sprs2	=	op2
00010FB0 =00000001                M sprs3	=	op3
00010FB0 =00000001                M sprs4	=	op4
00010FB0                            	spAttackRt	$1D, $13, $16, $1E
00010FB0 =0000001D                M spar1	=	op1
00010FB0 =00000013                M spar2	=	op2
00010FB0 =00000016                M spar3	=	op3
00010FB0 =0000001E                M spar4	=	op4
00010FB0                            	spAmpMod	$00, $00, $00, $00
00010FB0 =00000000                M spam1	=	op1
00010FB0 =00000000                M spam2	=	op2
00010FB0 =00000000                M spam3	=	op3
00010FB0 =00000000                M spam4	=	op4
00010FB0                            	spSustainRt	$01, $00, $01, $01
00010FB0 =00000001                M spsr1	=	op1
00010FB0 =00000000                M spsr2	=	op2
00010FB0 =00000001                M spsr3	=	op3
00010FB0 =00000001                M spsr4	=	op4
00010FB0                            	spDecayRt	$15, $0C, $0F, $0F
00010FB0 =00000015                M spdr1	=	op1
00010FB0 =0000000C                M spdr2	=	op2
00010FB0 =0000000F                M spdr3	=	op3
00010FB0 =0000000F                M spdr4	=	op4
00010FB0                            	spSustainLv	$04, $03, $03, $03
00010FB0 =00000004                M spsl1	=	op1
00010FB0 =00000003                M spsl2	=	op2
00010FB0 =00000003                M spsl3	=	op3
00010FB0 =00000003                M spsl4	=	op4
00010FB0                            	spReleaseRt	$0F, $0F, $0F, $0F
00010FB0 =0000000F                M sprr1	=	op1
00010FB0 =0000000F                M sprr2	=	op2
00010FB0 =0000000F                M sprr3	=	op3
00010FB0 =0000000F                M sprr4	=	op4
00010FB0                            	spSSGEG		$00, $00, $00, $00
00010FB0 =00000000                M spss1	=	op1
00010FB0 =00000000                M spss2	=	op2
00010FB0 =00000000                M spss3	=	op3
00010FB0 =00000000                M spss4	=	op4
00010FB0                            	spTotalLv	$13, $1B, $10, $05
00010FB0 =00000013                M sptl1	=	op1
00010FB0 =0000001B                M sptl2	=	op2
00010FB0 =00000010                M sptl3	=	op3
00010FB0 =00000005                M sptl4	=	op4
00010FB0 29                       M 	dc.b	(spfe<<3)+spal
00010FB1 =00000080                M sptlmask4	set	$80
00010FB1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010FB1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010FB1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010FB1 3350 0225                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FB5 9D56 135E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FB9 0101 0001                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FBD 150F 0C0F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FC1 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FC5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FC9 1310 1B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FCD 4E41 54                  M 	dc.b	'NAT'
00010FD0                            
00010FD0                            	; Patch $2A
00010FD0                            	; $2B
00010FD0                            	; $31, $32, $35, $31,	$1F, $59, $9E, $5E
00010FD0                            	; $80, $80, $80, $85,	$01, $17, $12, $0A
00010FD0                            	; $AA, $AF, $F9, $FC,	$0F, $12, $46, $05
00010FD0                            	spAlgorithm	$03
00010FD0 =0000002B                M spatnum	=	spatnum+1
00010FD0 =00000003                M spal	=	val
00010FD0                            	spFeedback	$05
00010FD0 =00000005                M spfe	=	val
00010FD0                            	spDetune	$03, $03, $03, $03
00010FD0 =00000003                M spde1	=	op1
00010FD0 =00000003                M spde2	=	op2
00010FD0 =00000003                M spde3	=	op3
00010FD0 =00000003                M spde4	=	op4
00010FD0                            	spMultiple	$01, $05, $02, $01
00010FD0 =00000001                M spmu1	=	op1
00010FD0 =00000005                M spmu2	=	op2
00010FD0 =00000002                M spmu3	=	op3
00010FD0 =00000001                M spmu4	=	op4
00010FD0                            	spRateScale	$00, $02, $01, $01
00010FD0 =00000000                M sprs1	=	op1
00010FD0 =00000002                M sprs2	=	op2
00010FD0 =00000001                M sprs3	=	op3
00010FD0 =00000001                M sprs4	=	op4
00010FD0                            	spAttackRt	$1F, $1E, $19, $1E
00010FD0 =0000001F                M spar1	=	op1
00010FD0 =0000001E                M spar2	=	op2
00010FD0 =00000019                M spar3	=	op3
00010FD0 =0000001E                M spar4	=	op4
00010FD0                            	spAmpMod	$01, $01, $01, $01
00010FD0 =00000001                M spam1	=	op1
00010FD0 =00000001                M spam2	=	op2
00010FD0 =00000001                M spam3	=	op3
00010FD0 =00000001                M spam4	=	op4
00010FD0                            	spSustainRt	$00, $00, $00, $05
00010FD0 =00000000                M spsr1	=	op1
00010FD0 =00000000                M spsr2	=	op2
00010FD0 =00000000                M spsr3	=	op3
00010FD0 =00000005                M spsr4	=	op4
00010FD0                            	spDecayRt	$01, $12, $17, $0A
00010FD0 =00000001                M spdr1	=	op1
00010FD0 =00000012                M spdr2	=	op2
00010FD0 =00000017                M spdr3	=	op3
00010FD0 =0000000A                M spdr4	=	op4
00010FD0                            	spSustainLv	$0A, $0F, $0A, $0F
00010FD0 =0000000A                M spsl1	=	op1
00010FD0 =0000000F                M spsl2	=	op2
00010FD0 =0000000A                M spsl3	=	op3
00010FD0 =0000000F                M spsl4	=	op4
00010FD0                            	spReleaseRt	$0A, $09, $0F, $0C
00010FD0 =0000000A                M sprr1	=	op1
00010FD0 =00000009                M sprr2	=	op2
00010FD0 =0000000F                M sprr3	=	op3
00010FD0 =0000000C                M sprr4	=	op4
00010FD0                            	spSSGEG		$00, $00, $00, $00
00010FD0 =00000000                M spss1	=	op1
00010FD0 =00000000                M spss2	=	op2
00010FD0 =00000000                M spss3	=	op3
00010FD0 =00000000                M spss4	=	op4
00010FD0                            	spTotalLv	$0F, $46, $12, $05
00010FD0 =0000000F                M sptl1	=	op1
00010FD0 =00000046                M sptl2	=	op2
00010FD0 =00000012                M sptl3	=	op3
00010FD0 =00000005                M sptl4	=	op4
00010FD0 2B                       M 	dc.b	(spfe<<3)+spal
00010FD1 =00000080                M sptlmask4	set	$80
00010FD1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010FD1 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010FD1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010FD1 3132 3531                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FD5 1F59 9E5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FD9 8080 8085                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FDD 0117 120A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FE1 AAAF F9FC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FE5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FE9 0F12 4685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FED 4E41 54                  M 	dc.b	'NAT'
00010FF0                            
00010FF0                            	; Patch $2B
00010FF0                            	; $04
00010FF0                            	; $70, $70, $30, $31,	$9F, $1F, $9F, $1F
00010FF0                            	; $80, $80, $9F, $8E,	$00, $00, $12, $00
00010FF0                            	; $09, $09, $09, $09,	$33, $05, $08, $05
00010FF0                            	spAlgorithm	$04
00010FF0 =0000002C                M spatnum	=	spatnum+1
00010FF0 =00000004                M spal	=	val
00010FF0                            	spFeedback	$00
00010FF0 =00000000                M spfe	=	val
00010FF0                            	spDetune	$07, $03, $07, $03
00010FF0 =00000007                M spde1	=	op1
00010FF0 =00000003                M spde2	=	op2
00010FF0 =00000007                M spde3	=	op3
00010FF0 =00000003                M spde4	=	op4
00010FF0                            	spMultiple	$00, $00, $00, $01
00010FF0 =00000000                M spmu1	=	op1
00010FF0 =00000000                M spmu2	=	op2
00010FF0 =00000000                M spmu3	=	op3
00010FF0 =00000001                M spmu4	=	op4
00010FF0                            	spRateScale	$02, $02, $00, $00
00010FF0 =00000002                M sprs1	=	op1
00010FF0 =00000002                M sprs2	=	op2
00010FF0 =00000000                M sprs3	=	op3
00010FF0 =00000000                M sprs4	=	op4
00010FF0                            	spAttackRt	$1F, $1F, $1F, $1F
00010FF0 =0000001F                M spar1	=	op1
00010FF0 =0000001F                M spar2	=	op2
00010FF0 =0000001F                M spar3	=	op3
00010FF0 =0000001F                M spar4	=	op4
00010FF0                            	spAmpMod	$01, $01, $01, $01
00010FF0 =00000001                M spam1	=	op1
00010FF0 =00000001                M spam2	=	op2
00010FF0 =00000001                M spam3	=	op3
00010FF0 =00000001                M spam4	=	op4
00010FF0                            	spSustainRt	$00, $1F, $00, $0E
00010FF0 =00000000                M spsr1	=	op1
00010FF0 =0000001F                M spsr2	=	op2
00010FF0 =00000000                M spsr3	=	op3
00010FF0 =0000000E                M spsr4	=	op4
00010FF0                            	spDecayRt	$00, $12, $00, $00
00010FF0 =00000000                M spdr1	=	op1
00010FF0 =00000012                M spdr2	=	op2
00010FF0 =00000000                M spdr3	=	op3
00010FF0 =00000000                M spdr4	=	op4
00010FF0                            	spSustainLv	$00, $00, $00, $00
00010FF0 =00000000                M spsl1	=	op1
00010FF0 =00000000                M spsl2	=	op2
00010FF0 =00000000                M spsl3	=	op3
00010FF0 =00000000                M spsl4	=	op4
00010FF0                            	spReleaseRt	$09, $09, $09, $09
00010FF0 =00000009                M sprr1	=	op1
00010FF0 =00000009                M sprr2	=	op2
00010FF0 =00000009                M sprr3	=	op3
00010FF0 =00000009                M sprr4	=	op4
00010FF0                            	spSSGEG		$00, $00, $00, $00
00010FF0 =00000000                M spss1	=	op1
00010FF0 =00000000                M spss2	=	op2
00010FF0 =00000000                M spss3	=	op3
00010FF0 =00000000                M spss4	=	op4
00010FF0                            	spTotalLv	$33, $08, $05, $05
00010FF0 =00000033                M sptl1	=	op1
00010FF0 =00000008                M sptl2	=	op2
00010FF0 =00000005                M sptl3	=	op3
00010FF0 =00000005                M sptl4	=	op4
00010FF0 04                       M 	dc.b	(spfe<<3)+spal
00010FF1 =00000080                M sptlmask4	set	$80
00010FF1 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010FF1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010FF1 =00000000                M sptlmask1	set	((spal=7)<<7)
00010FF1 7070 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FF5 9F1F 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FF9 8080 9F8E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FFD 0000 1200                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011001 0909 0909                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011005 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011009 3385 0885                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001100D 4E41 54                  M 	dc.b	'NAT'
00011010                            
00011010                            	; Patch $2C
00011010                            	; $1F
00011010                            	; $16, $61, $03, $52,	$1C, $9F, $1F, $1F
00011010                            	; $92, $8F, $8F, $8F,	$00, $00, $00, $00
00011010                            	; $FF, $0F, $0F, $0F,	$05, $05, $05, $05
00011010                            	spAlgorithm	$07
00011010 =0000002D                M spatnum	=	spatnum+1
00011010 =00000007                M spal	=	val
00011010                            	spFeedback	$03
00011010 =00000003                M spfe	=	val
00011010                            	spDetune	$01, $00, $06, $05
00011010 =00000001                M spde1	=	op1
00011010 =00000000                M spde2	=	op2
00011010 =00000006                M spde3	=	op3
00011010 =00000005                M spde4	=	op4
00011010                            	spMultiple	$06, $03, $01, $02
00011010 =00000006                M spmu1	=	op1
00011010 =00000003                M spmu2	=	op2
00011010 =00000001                M spmu3	=	op3
00011010 =00000002                M spmu4	=	op4
00011010                            	spRateScale	$00, $00, $02, $00
00011010 =00000000                M sprs1	=	op1
00011010 =00000000                M sprs2	=	op2
00011010 =00000002                M sprs3	=	op3
00011010 =00000000                M sprs4	=	op4
00011010                            	spAttackRt	$1C, $1F, $1F, $1F
00011010 =0000001C                M spar1	=	op1
00011010 =0000001F                M spar2	=	op2
00011010 =0000001F                M spar3	=	op3
00011010 =0000001F                M spar4	=	op4
00011010                            	spAmpMod	$01, $01, $01, $01
00011010 =00000001                M spam1	=	op1
00011010 =00000001                M spam2	=	op2
00011010 =00000001                M spam3	=	op3
00011010 =00000001                M spam4	=	op4
00011010                            	spSustainRt	$12, $0F, $0F, $0F
00011010 =00000012                M spsr1	=	op1
00011010 =0000000F                M spsr2	=	op2
00011010 =0000000F                M spsr3	=	op3
00011010 =0000000F                M spsr4	=	op4
00011010                            	spDecayRt	$00, $00, $00, $00
00011010 =00000000                M spdr1	=	op1
00011010 =00000000                M spdr2	=	op2
00011010 =00000000                M spdr3	=	op3
00011010 =00000000                M spdr4	=	op4
00011010                            	spSustainLv	$0F, $00, $00, $00
00011010 =0000000F                M spsl1	=	op1
00011010 =00000000                M spsl2	=	op2
00011010 =00000000                M spsl3	=	op3
00011010 =00000000                M spsl4	=	op4
00011010                            	spReleaseRt	$0F, $0F, $0F, $0F
00011010 =0000000F                M sprr1	=	op1
00011010 =0000000F                M sprr2	=	op2
00011010 =0000000F                M sprr3	=	op3
00011010 =0000000F                M sprr4	=	op4
00011010                            	spSSGEG		$00, $00, $00, $00
00011010 =00000000                M spss1	=	op1
00011010 =00000000                M spss2	=	op2
00011010 =00000000                M spss3	=	op3
00011010 =00000000                M spss4	=	op4
00011010                            	spTotalLv	$05, $05, $05, $05
00011010 =00000005                M sptl1	=	op1
00011010 =00000005                M sptl2	=	op2
00011010 =00000005                M sptl3	=	op3
00011010 =00000005                M sptl4	=	op4
00011010 1F                       M 	dc.b	(spfe<<3)+spal
00011011 =00000080                M sptlmask4	set	$80
00011011 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011011 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011011 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
00011011 1661 0352                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011015 1C9F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011019 928F 8F8F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001101D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011021 FF0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011025 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011029 8585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001102D 4E41 54                  M 	dc.b	'NAT'
00011030                            
00011030                            	; Patch $2D
00011030                            	; $2C
00011030                            	; $74, $74, $34, $34,	$12, $12, $12, $12
00011030                            	; $80, $80, $80, $80,	$00, $01, $00, $01
00011030                            	; $07, $37, $07, $37,	$16, $05, $17, $05
00011030                            	spAlgorithm	$04
00011030 =0000002E                M spatnum	=	spatnum+1
00011030 =00000004                M spal	=	val
00011030                            	spFeedback	$05
00011030 =00000005                M spfe	=	val
00011030                            	spDetune	$07, $03, $07, $03
00011030 =00000007                M spde1	=	op1
00011030 =00000003                M spde2	=	op2
00011030 =00000007                M spde3	=	op3
00011030 =00000003                M spde4	=	op4
00011030                            	spMultiple	$04, $04, $04, $04
00011030 =00000004                M spmu1	=	op1
00011030 =00000004                M spmu2	=	op2
00011030 =00000004                M spmu3	=	op3
00011030 =00000004                M spmu4	=	op4
00011030                            	spRateScale	$00, $00, $00, $00
00011030 =00000000                M sprs1	=	op1
00011030 =00000000                M sprs2	=	op2
00011030 =00000000                M sprs3	=	op3
00011030 =00000000                M sprs4	=	op4
00011030                            	spAttackRt	$12, $12, $12, $12
00011030 =00000012                M spar1	=	op1
00011030 =00000012                M spar2	=	op2
00011030 =00000012                M spar3	=	op3
00011030 =00000012                M spar4	=	op4
00011030                            	spAmpMod	$01, $01, $01, $01
00011030 =00000001                M spam1	=	op1
00011030 =00000001                M spam2	=	op2
00011030 =00000001                M spam3	=	op3
00011030 =00000001                M spam4	=	op4
00011030                            	spSustainRt	$00, $00, $00, $00
00011030 =00000000                M spsr1	=	op1
00011030 =00000000                M spsr2	=	op2
00011030 =00000000                M spsr3	=	op3
00011030 =00000000                M spsr4	=	op4
00011030                            	spDecayRt	$00, $00, $01, $01
00011030 =00000000                M spdr1	=	op1
00011030 =00000000                M spdr2	=	op2
00011030 =00000001                M spdr3	=	op3
00011030 =00000001                M spdr4	=	op4
00011030                            	spSustainLv	$00, $00, $03, $03
00011030 =00000000                M spsl1	=	op1
00011030 =00000000                M spsl2	=	op2
00011030 =00000003                M spsl3	=	op3
00011030 =00000003                M spsl4	=	op4
00011030                            	spReleaseRt	$07, $07, $07, $07
00011030 =00000007                M sprr1	=	op1
00011030 =00000007                M sprr2	=	op2
00011030 =00000007                M sprr3	=	op3
00011030 =00000007                M sprr4	=	op4
00011030                            	spSSGEG		$00, $00, $00, $00
00011030 =00000000                M spss1	=	op1
00011030 =00000000                M spss2	=	op2
00011030 =00000000                M spss3	=	op3
00011030 =00000000                M spss4	=	op4
00011030                            	spTotalLv	$16, $17, $05, $05
00011030 =00000016                M sptl1	=	op1
00011030 =00000017                M sptl2	=	op2
00011030 =00000005                M sptl3	=	op3
00011030 =00000005                M sptl4	=	op4
00011030 2C                       M 	dc.b	(spfe<<3)+spal
00011031 =00000080                M sptlmask4	set	$80
00011031 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011031 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011031 =00000000                M sptlmask1	set	((spal=7)<<7)
00011031 7474 3434                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011035 1212 1212                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011039 8080 8080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001103D 0001 0001                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011041 0737 0737                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011045 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011049 1685 1785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001104D 4E41 54                  M 	dc.b	'NAT'
00011050                            
00011050                            	; Patch $2E
00011050                            	; $07
00011050                            	; $34, $74, $32, $70,	$1F, $1F, $1F, $1F
00011050                            	; $0A, $0A, $05, $03,	$00, $00, $00, $00
00011050                            	; $3F, $3F, $2F, $2F,	$05, $05, $05, $05
00011050                            	spAlgorithm	$07
00011050 =0000002F                M spatnum	=	spatnum+1
00011050 =00000007                M spal	=	val
00011050                            	spFeedback	$00
00011050 =00000000                M spfe	=	val
00011050                            	spDetune	$03, $03, $07, $07
00011050 =00000003                M spde1	=	op1
00011050 =00000003                M spde2	=	op2
00011050 =00000007                M spde3	=	op3
00011050 =00000007                M spde4	=	op4
00011050                            	spMultiple	$04, $02, $04, $00
00011050 =00000004                M spmu1	=	op1
00011050 =00000002                M spmu2	=	op2
00011050 =00000004                M spmu3	=	op3
00011050 =00000000                M spmu4	=	op4
00011050                            	spRateScale	$00, $00, $00, $00
00011050 =00000000                M sprs1	=	op1
00011050 =00000000                M sprs2	=	op2
00011050 =00000000                M sprs3	=	op3
00011050 =00000000                M sprs4	=	op4
00011050                            	spAttackRt	$1F, $1F, $1F, $1F
00011050 =0000001F                M spar1	=	op1
00011050 =0000001F                M spar2	=	op2
00011050 =0000001F                M spar3	=	op3
00011050 =0000001F                M spar4	=	op4
00011050                            	spAmpMod	$00, $00, $00, $00
00011050 =00000000                M spam1	=	op1
00011050 =00000000                M spam2	=	op2
00011050 =00000000                M spam3	=	op3
00011050 =00000000                M spam4	=	op4
00011050                            	spSustainRt	$0A, $05, $0A, $03
00011050 =0000000A                M spsr1	=	op1
00011050 =00000005                M spsr2	=	op2
00011050 =0000000A                M spsr3	=	op3
00011050 =00000003                M spsr4	=	op4
00011050                            	spDecayRt	$00, $00, $00, $00
00011050 =00000000                M spdr1	=	op1
00011050 =00000000                M spdr2	=	op2
00011050 =00000000                M spdr3	=	op3
00011050 =00000000                M spdr4	=	op4
00011050                            	spSustainLv	$03, $02, $03, $02
00011050 =00000003                M spsl1	=	op1
00011050 =00000002                M spsl2	=	op2
00011050 =00000003                M spsl3	=	op3
00011050 =00000002                M spsl4	=	op4
00011050                            	spReleaseRt	$0F, $0F, $0F, $0F
00011050 =0000000F                M sprr1	=	op1
00011050 =0000000F                M sprr2	=	op2
00011050 =0000000F                M sprr3	=	op3
00011050 =0000000F                M sprr4	=	op4
00011050                            	spSSGEG		$00, $00, $00, $00
00011050 =00000000                M spss1	=	op1
00011050 =00000000                M spss2	=	op2
00011050 =00000000                M spss3	=	op3
00011050 =00000000                M spss4	=	op4
00011050                            	spTotalLv	$05, $05, $05, $05
00011050 =00000005                M sptl1	=	op1
00011050 =00000005                M sptl2	=	op2
00011050 =00000005                M sptl3	=	op3
00011050 =00000005                M sptl4	=	op4
00011050 07                       M 	dc.b	(spfe<<3)+spal
00011051 =00000080                M sptlmask4	set	$80
00011051 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011051 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011051 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
00011051 3474 3270                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011055 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011059 0A0A 0503                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001105D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011061 3F3F 2F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011065 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011069 8585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001106D 4E41 54                  M 	dc.b	'NAT'
00011070                            
00011070                            	; Patch $2F
00011070                            	; $3A
00011070                            	; $70, $76, $30, $71,	$1F, $95, $1F, $1F
00011070                            	; $0E, $0F, $05, $0C,	$07, $06, $06, $07
00011070                            	; $2F, $4F, $1F, $5F,	$18, $0E, $0F, $02
00011070                            	spAlgorithm	$02
00011070 =00000030                M spatnum	=	spatnum+1
00011070 =00000002                M spal	=	val
00011070                            	spFeedback	$07
00011070 =00000007                M spfe	=	val
00011070                            	spDetune	$07, $03, $07, $07
00011070 =00000007                M spde1	=	op1
00011070 =00000003                M spde2	=	op2
00011070 =00000007                M spde3	=	op3
00011070 =00000007                M spde4	=	op4
00011070                            	spMultiple	$00, $00, $06, $01
00011070 =00000000                M spmu1	=	op1
00011070 =00000000                M spmu2	=	op2
00011070 =00000006                M spmu3	=	op3
00011070 =00000001                M spmu4	=	op4
00011070                            	spRateScale	$00, $00, $02, $00
00011070 =00000000                M sprs1	=	op1
00011070 =00000000                M sprs2	=	op2
00011070 =00000002                M sprs3	=	op3
00011070 =00000000                M sprs4	=	op4
00011070                            	spAttackRt	$1F, $1F, $15, $1F
00011070 =0000001F                M spar1	=	op1
00011070 =0000001F                M spar2	=	op2
00011070 =00000015                M spar3	=	op3
00011070 =0000001F                M spar4	=	op4
00011070                            	spAmpMod	$00, $00, $00, $00
00011070 =00000000                M spam1	=	op1
00011070 =00000000                M spam2	=	op2
00011070 =00000000                M spam3	=	op3
00011070 =00000000                M spam4	=	op4
00011070                            	spSustainRt	$0E, $05, $0F, $0C
00011070 =0000000E                M spsr1	=	op1
00011070 =00000005                M spsr2	=	op2
00011070 =0000000F                M spsr3	=	op3
00011070 =0000000C                M spsr4	=	op4
00011070                            	spDecayRt	$07, $06, $06, $07
00011070 =00000007                M spdr1	=	op1
00011070 =00000006                M spdr2	=	op2
00011070 =00000006                M spdr3	=	op3
00011070 =00000007                M spdr4	=	op4
00011070                            	spSustainLv	$02, $01, $04, $05
00011070 =00000002                M spsl1	=	op1
00011070 =00000001                M spsl2	=	op2
00011070 =00000004                M spsl3	=	op3
00011070 =00000005                M spsl4	=	op4
00011070                            	spReleaseRt	$0F, $0F, $0F, $0F
00011070 =0000000F                M sprr1	=	op1
00011070 =0000000F                M sprr2	=	op2
00011070 =0000000F                M sprr3	=	op3
00011070 =0000000F                M sprr4	=	op4
00011070                            	spSSGEG		$00, $00, $00, $00
00011070 =00000000                M spss1	=	op1
00011070 =00000000                M spss2	=	op2
00011070 =00000000                M spss3	=	op3
00011070 =00000000                M spss4	=	op4
00011070                            	spTotalLv	$18, $0F, $0E, $02
00011070 =00000018                M sptl1	=	op1
00011070 =0000000F                M sptl2	=	op2
00011070 =0000000E                M sptl3	=	op3
00011070 =00000002                M sptl4	=	op4
00011070 3A                       M 	dc.b	(spfe<<3)+spal
00011071 =00000080                M sptlmask4	set	$80
00011071 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011071 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011071 =00000000                M sptlmask1	set	((spal=7)<<7)
00011071 7076 3071                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011075 1F95 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011079 0E0F 050C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001107D 0706 0607                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011081 2F4F 1F5F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011085 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011089 180E 0F82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001108D 4E41 54                  M 	dc.b	'NAT'
00011090                            
00011090                            	; Patch $30
00011090                            	; $20
00011090                            	; $34, $38, $30, $31,	$DF, $DF, $9F, $9F
00011090                            	; $07, $08, $08, $0A,	$07, $0E, $0A, $11
00011090                            	; $20, $1F, $1F, $1F,	$22, $37, $14, $00
00011090                            	spAlgorithm	$00
00011090 =00000031                M spatnum	=	spatnum+1
00011090 =00000000                M spal	=	val
00011090                            	spFeedback	$04
00011090 =00000004                M spfe	=	val
00011090                            	spDetune	$03, $03, $03, $03
00011090 =00000003                M spde1	=	op1
00011090 =00000003                M spde2	=	op2
00011090 =00000003                M spde3	=	op3
00011090 =00000003                M spde4	=	op4
00011090                            	spMultiple	$04, $00, $08, $01
00011090 =00000004                M spmu1	=	op1
00011090 =00000000                M spmu2	=	op2
00011090 =00000008                M spmu3	=	op3
00011090 =00000001                M spmu4	=	op4
00011090                            	spRateScale	$03, $02, $03, $02
00011090 =00000003                M sprs1	=	op1
00011090 =00000002                M sprs2	=	op2
00011090 =00000003                M sprs3	=	op3
00011090 =00000002                M sprs4	=	op4
00011090                            	spAttackRt	$1F, $1F, $1F, $1F
00011090 =0000001F                M spar1	=	op1
00011090 =0000001F                M spar2	=	op2
00011090 =0000001F                M spar3	=	op3
00011090 =0000001F                M spar4	=	op4
00011090                            	spAmpMod	$00, $00, $00, $00
00011090 =00000000                M spam1	=	op1
00011090 =00000000                M spam2	=	op2
00011090 =00000000                M spam3	=	op3
00011090 =00000000                M spam4	=	op4
00011090                            	spSustainRt	$07, $08, $08, $0A
00011090 =00000007                M spsr1	=	op1
00011090 =00000008                M spsr2	=	op2
00011090 =00000008                M spsr3	=	op3
00011090 =0000000A                M spsr4	=	op4
00011090                            	spDecayRt	$07, $0A, $0E, $11
00011090 =00000007                M spdr1	=	op1
00011090 =0000000A                M spdr2	=	op2
00011090 =0000000E                M spdr3	=	op3
00011090 =00000011                M spdr4	=	op4
00011090                            	spSustainLv	$02, $01, $01, $01
00011090 =00000002                M spsl1	=	op1
00011090 =00000001                M spsl2	=	op2
00011090 =00000001                M spsl3	=	op3
00011090 =00000001                M spsl4	=	op4
00011090                            	spReleaseRt	$00, $0F, $0F, $0F
00011090 =00000000                M sprr1	=	op1
00011090 =0000000F                M sprr2	=	op2
00011090 =0000000F                M sprr3	=	op3
00011090 =0000000F                M sprr4	=	op4
00011090                            	spSSGEG		$00, $00, $00, $00
00011090 =00000000                M spss1	=	op1
00011090 =00000000                M spss2	=	op2
00011090 =00000000                M spss3	=	op3
00011090 =00000000                M spss4	=	op4
00011090                            	spTotalLv	$22, $14, $37, $00
00011090 =00000022                M sptl1	=	op1
00011090 =00000014                M sptl2	=	op2
00011090 =00000037                M sptl3	=	op3
00011090 =00000000                M sptl4	=	op4
00011090 20                       M 	dc.b	(spfe<<3)+spal
00011091 =00000080                M sptlmask4	set	$80
00011091 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011091 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011091 =00000000                M sptlmask1	set	((spal=7)<<7)
00011091 3438 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011095 DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011099 0708 080A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001109D 070E 0A11                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110A1 201F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110A9 2237 1480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110AD 4E41 54                  M 	dc.b	'NAT'
000110B0                            
000110B0                            	; Patch $31
000110B0                            	; $3A
000110B0                            	; $31, $7F, $61, $0A,	$9C, $DB, $9C, $9A
000110B0                            	; $04, $08, $03, $09,	$03, $01, $00, $00
000110B0                            	; $1F, $0F, $FF, $FF,	$23, $25, $1B, $06
000110B0                            	spAlgorithm	$02
000110B0 =00000032                M spatnum	=	spatnum+1
000110B0 =00000002                M spal	=	val
000110B0                            	spFeedback	$07
000110B0 =00000007                M spfe	=	val
000110B0                            	spDetune	$03, $06, $07, $00
000110B0 =00000003                M spde1	=	op1
000110B0 =00000006                M spde2	=	op2
000110B0 =00000007                M spde3	=	op3
000110B0 =00000000                M spde4	=	op4
000110B0                            	spMultiple	$01, $01, $0F, $0A
000110B0 =00000001                M spmu1	=	op1
000110B0 =00000001                M spmu2	=	op2
000110B0 =0000000F                M spmu3	=	op3
000110B0 =0000000A                M spmu4	=	op4
000110B0                            	spRateScale	$02, $02, $03, $02
000110B0 =00000002                M sprs1	=	op1
000110B0 =00000002                M sprs2	=	op2
000110B0 =00000003                M sprs3	=	op3
000110B0 =00000002                M sprs4	=	op4
000110B0                            	spAttackRt	$1C, $1C, $1B, $1A
000110B0 =0000001C                M spar1	=	op1
000110B0 =0000001C                M spar2	=	op2
000110B0 =0000001B                M spar3	=	op3
000110B0 =0000001A                M spar4	=	op4
000110B0                            	spAmpMod	$00, $00, $00, $00
000110B0 =00000000                M spam1	=	op1
000110B0 =00000000                M spam2	=	op2
000110B0 =00000000                M spam3	=	op3
000110B0 =00000000                M spam4	=	op4
000110B0                            	spSustainRt	$04, $03, $08, $09
000110B0 =00000004                M spsr1	=	op1
000110B0 =00000003                M spsr2	=	op2
000110B0 =00000008                M spsr3	=	op3
000110B0 =00000009                M spsr4	=	op4
000110B0                            	spDecayRt	$03, $00, $01, $00
000110B0 =00000003                M spdr1	=	op1
000110B0 =00000000                M spdr2	=	op2
000110B0 =00000001                M spdr3	=	op3
000110B0 =00000000                M spdr4	=	op4
000110B0                            	spSustainLv	$01, $0F, $00, $0F
000110B0 =00000001                M spsl1	=	op1
000110B0 =0000000F                M spsl2	=	op2
000110B0 =00000000                M spsl3	=	op3
000110B0 =0000000F                M spsl4	=	op4
000110B0                            	spReleaseRt	$0F, $0F, $0F, $0F
000110B0 =0000000F                M sprr1	=	op1
000110B0 =0000000F                M sprr2	=	op2
000110B0 =0000000F                M sprr3	=	op3
000110B0 =0000000F                M sprr4	=	op4
000110B0                            	spSSGEG		$00, $00, $00, $00
000110B0 =00000000                M spss1	=	op1
000110B0 =00000000                M spss2	=	op2
000110B0 =00000000                M spss3	=	op3
000110B0 =00000000                M spss4	=	op4
000110B0                            	spTotalLv	$23, $1B, $25, $06
000110B0 =00000023                M sptl1	=	op1
000110B0 =0000001B                M sptl2	=	op2
000110B0 =00000025                M sptl3	=	op3
000110B0 =00000006                M sptl4	=	op4
000110B0 3A                       M 	dc.b	(spfe<<3)+spal
000110B1 =00000080                M sptlmask4	set	$80
000110B1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000110B1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000110B1 =00000000                M sptlmask1	set	((spal=7)<<7)
000110B1 317F 610A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110B5 9CDB 9C9A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110B9 0408 0309                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110BD 0301 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110C1 1F0F FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110C5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110C9 2325 1B86                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110CD 4E41 54                  M 	dc.b	'NAT'
000110D0                            
000110D0                            	; Patch $32
000110D0                            	; $04
000110D0                            	; $02, $02, $03, $03,	$13, $10, $13, $10
000110D0                            	; $06, $0C, $06, $0C,	$00, $00, $00, $00
000110D0                            	; $4F, $2F, $4F, $2F,	$18, $06, $18, $06
000110D0                            	spAlgorithm	$04
000110D0 =00000033                M spatnum	=	spatnum+1
000110D0 =00000004                M spal	=	val
000110D0                            	spFeedback	$00
000110D0 =00000000                M spfe	=	val
000110D0                            	spDetune	$00, $00, $00, $00
000110D0 =00000000                M spde1	=	op1
000110D0 =00000000                M spde2	=	op2
000110D0 =00000000                M spde3	=	op3
000110D0 =00000000                M spde4	=	op4
000110D0                            	spMultiple	$02, $03, $02, $03
000110D0 =00000002                M spmu1	=	op1
000110D0 =00000003                M spmu2	=	op2
000110D0 =00000002                M spmu3	=	op3
000110D0 =00000003                M spmu4	=	op4
000110D0                            	spRateScale	$00, $00, $00, $00
000110D0 =00000000                M sprs1	=	op1
000110D0 =00000000                M sprs2	=	op2
000110D0 =00000000                M sprs3	=	op3
000110D0 =00000000                M sprs4	=	op4
000110D0                            	spAttackRt	$13, $13, $10, $10
000110D0 =00000013                M spar1	=	op1
000110D0 =00000013                M spar2	=	op2
000110D0 =00000010                M spar3	=	op3
000110D0 =00000010                M spar4	=	op4
000110D0                            	spAmpMod	$00, $00, $00, $00
000110D0 =00000000                M spam1	=	op1
000110D0 =00000000                M spam2	=	op2
000110D0 =00000000                M spam3	=	op3
000110D0 =00000000                M spam4	=	op4
000110D0                            	spSustainRt	$06, $06, $0C, $0C
000110D0 =00000006                M spsr1	=	op1
000110D0 =00000006                M spsr2	=	op2
000110D0 =0000000C                M spsr3	=	op3
000110D0 =0000000C                M spsr4	=	op4
000110D0                            	spDecayRt	$00, $00, $00, $00
000110D0 =00000000                M spdr1	=	op1
000110D0 =00000000                M spdr2	=	op2
000110D0 =00000000                M spdr3	=	op3
000110D0 =00000000                M spdr4	=	op4
000110D0                            	spSustainLv	$04, $04, $02, $02
000110D0 =00000004                M spsl1	=	op1
000110D0 =00000004                M spsl2	=	op2
000110D0 =00000002                M spsl3	=	op3
000110D0 =00000002                M spsl4	=	op4
000110D0                            	spReleaseRt	$0F, $0F, $0F, $0F
000110D0 =0000000F                M sprr1	=	op1
000110D0 =0000000F                M sprr2	=	op2
000110D0 =0000000F                M sprr3	=	op3
000110D0 =0000000F                M sprr4	=	op4
000110D0                            	spSSGEG		$00, $00, $00, $00
000110D0 =00000000                M spss1	=	op1
000110D0 =00000000                M spss2	=	op2
000110D0 =00000000                M spss3	=	op3
000110D0 =00000000                M spss4	=	op4
000110D0                            	spTotalLv	$18, $18, $06, $06
000110D0 =00000018                M sptl1	=	op1
000110D0 =00000018                M sptl2	=	op2
000110D0 =00000006                M sptl3	=	op3
000110D0 =00000006                M sptl4	=	op4
000110D0 04                       M 	dc.b	(spfe<<3)+spal
000110D1 =00000080                M sptlmask4	set	$80
000110D1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000110D1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000110D1 =00000000                M sptlmask1	set	((spal=7)<<7)
000110D1 0202 0303                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110D5 1310 1310                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110D9 060C 060C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110DD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110E1 4F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110E5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110E9 1886 1886                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110ED 4E41 54                  M 	dc.b	'NAT'
000110F0                            
000110F0                            	; Patch $33
000110F0                            	; $38
000110F0                            	; $75, $13, $71, $11,	$DF, $5F, $1F, $1F
000110F0                            	; $0C, $0D, $01, $01,	$00, $00, $00, $00
000110F0                            	; $FF, $FF, $FF, $FF,	$1E, $1E, $1E, $03
000110F0                            	spAlgorithm	$00
000110F0 =00000034                M spatnum	=	spatnum+1
000110F0 =00000000                M spal	=	val
000110F0                            	spFeedback	$07
000110F0 =00000007                M spfe	=	val
000110F0                            	spDetune	$07, $07, $01, $01
000110F0 =00000007                M spde1	=	op1
000110F0 =00000007                M spde2	=	op2
000110F0 =00000001                M spde3	=	op3
000110F0 =00000001                M spde4	=	op4
000110F0                            	spMultiple	$05, $01, $03, $01
000110F0 =00000005                M spmu1	=	op1
000110F0 =00000001                M spmu2	=	op2
000110F0 =00000003                M spmu3	=	op3
000110F0 =00000001                M spmu4	=	op4
000110F0                            	spRateScale	$03, $00, $01, $00
000110F0 =00000003                M sprs1	=	op1
000110F0 =00000000                M sprs2	=	op2
000110F0 =00000001                M sprs3	=	op3
000110F0 =00000000                M sprs4	=	op4
000110F0                            	spAttackRt	$1F, $1F, $1F, $1F
000110F0 =0000001F                M spar1	=	op1
000110F0 =0000001F                M spar2	=	op2
000110F0 =0000001F                M spar3	=	op3
000110F0 =0000001F                M spar4	=	op4
000110F0                            	spAmpMod	$00, $00, $00, $00
000110F0 =00000000                M spam1	=	op1
000110F0 =00000000                M spam2	=	op2
000110F0 =00000000                M spam3	=	op3
000110F0 =00000000                M spam4	=	op4
000110F0                            	spSustainRt	$0C, $01, $0D, $01
000110F0 =0000000C                M spsr1	=	op1
000110F0 =00000001                M spsr2	=	op2
000110F0 =0000000D                M spsr3	=	op3
000110F0 =00000001                M spsr4	=	op4
000110F0                            	spDecayRt	$00, $00, $00, $00
000110F0 =00000000                M spdr1	=	op1
000110F0 =00000000                M spdr2	=	op2
000110F0 =00000000                M spdr3	=	op3
000110F0 =00000000                M spdr4	=	op4
000110F0                            	spSustainLv	$0F, $0F, $0F, $0F
000110F0 =0000000F                M spsl1	=	op1
000110F0 =0000000F                M spsl2	=	op2
000110F0 =0000000F                M spsl3	=	op3
000110F0 =0000000F                M spsl4	=	op4
000110F0                            	spReleaseRt	$0F, $0F, $0F, $0F
000110F0 =0000000F                M sprr1	=	op1
000110F0 =0000000F                M sprr2	=	op2
000110F0 =0000000F                M sprr3	=	op3
000110F0 =0000000F                M sprr4	=	op4
000110F0                            	spSSGEG		$00, $00, $00, $00
000110F0 =00000000                M spss1	=	op1
000110F0 =00000000                M spss2	=	op2
000110F0 =00000000                M spss3	=	op3
000110F0 =00000000                M spss4	=	op4
000110F0                            	spTotalLv	$1E, $1E, $1E, $03
000110F0 =0000001E                M sptl1	=	op1
000110F0 =0000001E                M sptl2	=	op2
000110F0 =0000001E                M sptl3	=	op3
000110F0 =00000003                M sptl4	=	op4
000110F0 38                       M 	dc.b	(spfe<<3)+spal
000110F1 =00000080                M sptlmask4	set	$80
000110F1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000110F1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000110F1 =00000000                M sptlmask1	set	((spal=7)<<7)
000110F1 7513 7111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110F5 DF5F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110F9 0C0D 0101                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110FD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011101 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011105 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011109 1E1E 1E83                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001110D 4E41 54                  M 	dc.b	'NAT'
00011110                            
00011110                            	; Patch $34
00011110                            	; $34
00011110                            	; $74, $21, $16, $71,	$11, $1F, $1F, $1F
00011110                            	; $08, $05, $08, $09,	$00, $00, $00, $00
00011110                            	; $FF, $FF, $FF, $FF,	$17, $05, $10, $05
00011110                            	spAlgorithm	$04
00011110 =00000035                M spatnum	=	spatnum+1
00011110 =00000004                M spal	=	val
00011110                            	spFeedback	$06
00011110 =00000006                M spfe	=	val
00011110                            	spDetune	$07, $01, $02, $07
00011110 =00000007                M spde1	=	op1
00011110 =00000001                M spde2	=	op2
00011110 =00000002                M spde3	=	op3
00011110 =00000007                M spde4	=	op4
00011110                            	spMultiple	$04, $06, $01, $01
00011110 =00000004                M spmu1	=	op1
00011110 =00000006                M spmu2	=	op2
00011110 =00000001                M spmu3	=	op3
00011110 =00000001                M spmu4	=	op4
00011110                            	spRateScale	$00, $00, $00, $00
00011110 =00000000                M sprs1	=	op1
00011110 =00000000                M sprs2	=	op2
00011110 =00000000                M sprs3	=	op3
00011110 =00000000                M sprs4	=	op4
00011110                            	spAttackRt	$11, $1F, $1F, $1F
00011110 =00000011                M spar1	=	op1
00011110 =0000001F                M spar2	=	op2
00011110 =0000001F                M spar3	=	op3
00011110 =0000001F                M spar4	=	op4
00011110                            	spAmpMod	$00, $00, $00, $00
00011110 =00000000                M spam1	=	op1
00011110 =00000000                M spam2	=	op2
00011110 =00000000                M spam3	=	op3
00011110 =00000000                M spam4	=	op4
00011110                            	spSustainRt	$08, $08, $05, $09
00011110 =00000008                M spsr1	=	op1
00011110 =00000008                M spsr2	=	op2
00011110 =00000005                M spsr3	=	op3
00011110 =00000009                M spsr4	=	op4
00011110                            	spDecayRt	$00, $00, $00, $00
00011110 =00000000                M spdr1	=	op1
00011110 =00000000                M spdr2	=	op2
00011110 =00000000                M spdr3	=	op3
00011110 =00000000                M spdr4	=	op4
00011110                            	spSustainLv	$0F, $0F, $0F, $0F
00011110 =0000000F                M spsl1	=	op1
00011110 =0000000F                M spsl2	=	op2
00011110 =0000000F                M spsl3	=	op3
00011110 =0000000F                M spsl4	=	op4
00011110                            	spReleaseRt	$0F, $0F, $0F, $0F
00011110 =0000000F                M sprr1	=	op1
00011110 =0000000F                M sprr2	=	op2
00011110 =0000000F                M sprr3	=	op3
00011110 =0000000F                M sprr4	=	op4
00011110                            	spSSGEG		$00, $00, $00, $00
00011110 =00000000                M spss1	=	op1
00011110 =00000000                M spss2	=	op2
00011110 =00000000                M spss3	=	op3
00011110 =00000000                M spss4	=	op4
00011110                            	spTotalLv	$17, $10, $05, $05
00011110 =00000017                M sptl1	=	op1
00011110 =00000010                M sptl2	=	op2
00011110 =00000005                M sptl3	=	op3
00011110 =00000005                M sptl4	=	op4
00011110 34                       M 	dc.b	(spfe<<3)+spal
00011111 =00000080                M sptlmask4	set	$80
00011111 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011111 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011111 =00000000                M sptlmask1	set	((spal=7)<<7)
00011111 7421 1671                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011115 111F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011119 0805 0809                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001111D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011121 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011125 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011129 1785 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001112D 4E41 54                  M 	dc.b	'NAT'
00011130                            
00011130                            	; Patch $35
00011130                            	; $38
00011130                            	; $41, $11, $71, $41,	$16, $13, $0F, $17
00011130                            	; $02, $0C, $05, $01,	$00, $0F, $00, $00
00011130                            	; $1F, $3F, $5F, $1F,	$2A, $12, $24, $04
00011130                            	spAlgorithm	$00
00011130 =00000036                M spatnum	=	spatnum+1
00011130 =00000000                M spal	=	val
00011130                            	spFeedback	$07
00011130 =00000007                M spfe	=	val
00011130                            	spDetune	$04, $07, $01, $04
00011130 =00000004                M spde1	=	op1
00011130 =00000007                M spde2	=	op2
00011130 =00000001                M spde3	=	op3
00011130 =00000004                M spde4	=	op4
00011130                            	spMultiple	$01, $01, $01, $01
00011130 =00000001                M spmu1	=	op1
00011130 =00000001                M spmu2	=	op2
00011130 =00000001                M spmu3	=	op3
00011130 =00000001                M spmu4	=	op4
00011130                            	spRateScale	$00, $00, $00, $00
00011130 =00000000                M sprs1	=	op1
00011130 =00000000                M sprs2	=	op2
00011130 =00000000                M sprs3	=	op3
00011130 =00000000                M sprs4	=	op4
00011130                            	spAttackRt	$16, $0F, $13, $17
00011130 =00000016                M spar1	=	op1
00011130 =0000000F                M spar2	=	op2
00011130 =00000013                M spar3	=	op3
00011130 =00000017                M spar4	=	op4
00011130                            	spAmpMod	$00, $00, $00, $00
00011130 =00000000                M spam1	=	op1
00011130 =00000000                M spam2	=	op2
00011130 =00000000                M spam3	=	op3
00011130 =00000000                M spam4	=	op4
00011130                            	spSustainRt	$02, $05, $0C, $01
00011130 =00000002                M spsr1	=	op1
00011130 =00000005                M spsr2	=	op2
00011130 =0000000C                M spsr3	=	op3
00011130 =00000001                M spsr4	=	op4
00011130                            	spDecayRt	$00, $00, $0F, $00
00011130 =00000000                M spdr1	=	op1
00011130 =00000000                M spdr2	=	op2
00011130 =0000000F                M spdr3	=	op3
00011130 =00000000                M spdr4	=	op4
00011130                            	spSustainLv	$01, $05, $03, $01
00011130 =00000001                M spsl1	=	op1
00011130 =00000005                M spsl2	=	op2
00011130 =00000003                M spsl3	=	op3
00011130 =00000001                M spsl4	=	op4
00011130                            	spReleaseRt	$0F, $0F, $0F, $0F
00011130 =0000000F                M sprr1	=	op1
00011130 =0000000F                M sprr2	=	op2
00011130 =0000000F                M sprr3	=	op3
00011130 =0000000F                M sprr4	=	op4
00011130                            	spSSGEG		$00, $00, $00, $00
00011130 =00000000                M spss1	=	op1
00011130 =00000000                M spss2	=	op2
00011130 =00000000                M spss3	=	op3
00011130 =00000000                M spss4	=	op4
00011130                            	spTotalLv	$2A, $24, $12, $04
00011130 =0000002A                M sptl1	=	op1
00011130 =00000024                M sptl2	=	op2
00011130 =00000012                M sptl3	=	op3
00011130 =00000004                M sptl4	=	op4
00011130 38                       M 	dc.b	(spfe<<3)+spal
00011131 =00000080                M sptlmask4	set	$80
00011131 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011131 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011131 =00000000                M sptlmask1	set	((spal=7)<<7)
00011131 4111 7141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011135 1613 0F17                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011139 020C 0501                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001113D 000F 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011141 1F3F 5F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011145 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011149 2A12 2484                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001114D 4E41 54                  M 	dc.b	'NAT'
00011150                            
00011150                            	; Patch $36
00011150                            	; $3D
00011150                            	; $01, $01, $01, $01,	$94, $19, $19, $19
00011150                            	; $0F, $0D, $0D, $0D,	$07, $04, $04, $04
00011150                            	; $25, $1A, $1A, $1A,	$15, $05, $05, $05
00011150                            	spAlgorithm	$05
00011150 =00000037                M spatnum	=	spatnum+1
00011150 =00000005                M spal	=	val
00011150                            	spFeedback	$07
00011150 =00000007                M spfe	=	val
00011150                            	spDetune	$00, $00, $00, $00
00011150 =00000000                M spde1	=	op1
00011150 =00000000                M spde2	=	op2
00011150 =00000000                M spde3	=	op3
00011150 =00000000                M spde4	=	op4
00011150                            	spMultiple	$01, $01, $01, $01
00011150 =00000001                M spmu1	=	op1
00011150 =00000001                M spmu2	=	op2
00011150 =00000001                M spmu3	=	op3
00011150 =00000001                M spmu4	=	op4
00011150                            	spRateScale	$02, $00, $00, $00
00011150 =00000002                M sprs1	=	op1
00011150 =00000000                M sprs2	=	op2
00011150 =00000000                M sprs3	=	op3
00011150 =00000000                M sprs4	=	op4
00011150                            	spAttackRt	$14, $19, $19, $19
00011150 =00000014                M spar1	=	op1
00011150 =00000019                M spar2	=	op2
00011150 =00000019                M spar3	=	op3
00011150 =00000019                M spar4	=	op4
00011150                            	spAmpMod	$00, $00, $00, $00
00011150 =00000000                M spam1	=	op1
00011150 =00000000                M spam2	=	op2
00011150 =00000000                M spam3	=	op3
00011150 =00000000                M spam4	=	op4
00011150                            	spSustainRt	$0F, $0D, $0D, $0D
00011150 =0000000F                M spsr1	=	op1
00011150 =0000000D                M spsr2	=	op2
00011150 =0000000D                M spsr3	=	op3
00011150 =0000000D                M spsr4	=	op4
00011150                            	spDecayRt	$07, $04, $04, $04
00011150 =00000007                M spdr1	=	op1
00011150 =00000004                M spdr2	=	op2
00011150 =00000004                M spdr3	=	op3
00011150 =00000004                M spdr4	=	op4
00011150                            	spSustainLv	$02, $01, $01, $01
00011150 =00000002                M spsl1	=	op1
00011150 =00000001                M spsl2	=	op2
00011150 =00000001                M spsl3	=	op3
00011150 =00000001                M spsl4	=	op4
00011150                            	spReleaseRt	$05, $0A, $0A, $0A
00011150 =00000005                M sprr1	=	op1
00011150 =0000000A                M sprr2	=	op2
00011150 =0000000A                M sprr3	=	op3
00011150 =0000000A                M sprr4	=	op4
00011150                            	spSSGEG		$00, $00, $00, $00
00011150 =00000000                M spss1	=	op1
00011150 =00000000                M spss2	=	op2
00011150 =00000000                M spss3	=	op3
00011150 =00000000                M spss4	=	op4
00011150                            	spTotalLv	$15, $05, $05, $05
00011150 =00000015                M sptl1	=	op1
00011150 =00000005                M sptl2	=	op2
00011150 =00000005                M sptl3	=	op3
00011150 =00000005                M sptl4	=	op4
00011150 3D                       M 	dc.b	(spfe<<3)+spal
00011151 =00000080                M sptlmask4	set	$80
00011151 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011151 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011151 =00000000                M sptlmask1	set	((spal=7)<<7)
00011151 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011155 9419 1919                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011159 0F0D 0D0D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001115D 0704 0404                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011161 251A 1A1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011165 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011169 1585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001116D 4E41 54                  M 	dc.b	'NAT'
00011170                            
00011170                            	; Patch $37
00011170                            	; $3A
00011170                            	; $31, $77, $32, $02,	$1C, $13, $0E, $4E
00011170                            	; $04, $10, $09, $0A,	$0C, $00, $03, $00
00011170                            	; $16, $2B, $24, $18,	$1D, $13, $2A, $04
00011170                            	spAlgorithm	$02
00011170 =00000038                M spatnum	=	spatnum+1
00011170 =00000002                M spal	=	val
00011170                            	spFeedback	$07
00011170 =00000007                M spfe	=	val
00011170                            	spDetune	$03, $03, $07, $00
00011170 =00000003                M spde1	=	op1
00011170 =00000003                M spde2	=	op2
00011170 =00000007                M spde3	=	op3
00011170 =00000000                M spde4	=	op4
00011170                            	spMultiple	$01, $02, $07, $02
00011170 =00000001                M spmu1	=	op1
00011170 =00000002                M spmu2	=	op2
00011170 =00000007                M spmu3	=	op3
00011170 =00000002                M spmu4	=	op4
00011170                            	spRateScale	$00, $00, $00, $01
00011170 =00000000                M sprs1	=	op1
00011170 =00000000                M sprs2	=	op2
00011170 =00000000                M sprs3	=	op3
00011170 =00000001                M sprs4	=	op4
00011170                            	spAttackRt	$1C, $0E, $13, $0E
00011170 =0000001C                M spar1	=	op1
00011170 =0000000E                M spar2	=	op2
00011170 =00000013                M spar3	=	op3
00011170 =0000000E                M spar4	=	op4
00011170                            	spAmpMod	$00, $00, $00, $00
00011170 =00000000                M spam1	=	op1
00011170 =00000000                M spam2	=	op2
00011170 =00000000                M spam3	=	op3
00011170 =00000000                M spam4	=	op4
00011170                            	spSustainRt	$04, $09, $10, $0A
00011170 =00000004                M spsr1	=	op1
00011170 =00000009                M spsr2	=	op2
00011170 =00000010                M spsr3	=	op3
00011170 =0000000A                M spsr4	=	op4
00011170                            	spDecayRt	$0C, $03, $00, $00
00011170 =0000000C                M spdr1	=	op1
00011170 =00000003                M spdr2	=	op2
00011170 =00000000                M spdr3	=	op3
00011170 =00000000                M spdr4	=	op4
00011170                            	spSustainLv	$01, $02, $02, $01
00011170 =00000001                M spsl1	=	op1
00011170 =00000002                M spsl2	=	op2
00011170 =00000002                M spsl3	=	op3
00011170 =00000001                M spsl4	=	op4
00011170                            	spReleaseRt	$06, $04, $0B, $08
00011170 =00000006                M sprr1	=	op1
00011170 =00000004                M sprr2	=	op2
00011170 =0000000B                M sprr3	=	op3
00011170 =00000008                M sprr4	=	op4
00011170                            	spSSGEG		$00, $00, $00, $00
00011170 =00000000                M spss1	=	op1
00011170 =00000000                M spss2	=	op2
00011170 =00000000                M spss3	=	op3
00011170 =00000000                M spss4	=	op4
00011170                            	spTotalLv	$1D, $2A, $13, $04
00011170 =0000001D                M sptl1	=	op1
00011170 =0000002A                M sptl2	=	op2
00011170 =00000013                M sptl3	=	op3
00011170 =00000004                M sptl4	=	op4
00011170 3A                       M 	dc.b	(spfe<<3)+spal
00011171 =00000080                M sptlmask4	set	$80
00011171 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011171 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011171 =00000000                M sptlmask1	set	((spal=7)<<7)
00011171 3177 3202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011175 1C13 0E4E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011179 0410 090A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001117D 0C00 0300                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011181 162B 2418                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011185 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011189 1D13 2A84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001118D 4E41 54                  M 	dc.b	'NAT'
00011190                            
00011190                            	; Patch $38
00011190                            	; $03
00011190                            	; $01, $78, $39, $3A,	$1F, $1F, $1F, $1F
00011190                            	; $06, $00, $08, $0A,	$00, $00, $00, $00
00011190                            	; $F4, $02, $56, $F5,	$33, $1B, $43, $04
00011190                            	spAlgorithm	$03
00011190 =00000039                M spatnum	=	spatnum+1
00011190 =00000003                M spal	=	val
00011190                            	spFeedback	$00
00011190 =00000000                M spfe	=	val
00011190                            	spDetune	$00, $03, $07, $03
00011190 =00000000                M spde1	=	op1
00011190 =00000003                M spde2	=	op2
00011190 =00000007                M spde3	=	op3
00011190 =00000003                M spde4	=	op4
00011190                            	spMultiple	$01, $09, $08, $0A
00011190 =00000001                M spmu1	=	op1
00011190 =00000009                M spmu2	=	op2
00011190 =00000008                M spmu3	=	op3
00011190 =0000000A                M spmu4	=	op4
00011190                            	spRateScale	$00, $00, $00, $00
00011190 =00000000                M sprs1	=	op1
00011190 =00000000                M sprs2	=	op2
00011190 =00000000                M sprs3	=	op3
00011190 =00000000                M sprs4	=	op4
00011190                            	spAttackRt	$1F, $1F, $1F, $1F
00011190 =0000001F                M spar1	=	op1
00011190 =0000001F                M spar2	=	op2
00011190 =0000001F                M spar3	=	op3
00011190 =0000001F                M spar4	=	op4
00011190                            	spAmpMod	$00, $00, $00, $00
00011190 =00000000                M spam1	=	op1
00011190 =00000000                M spam2	=	op2
00011190 =00000000                M spam3	=	op3
00011190 =00000000                M spam4	=	op4
00011190                            	spSustainRt	$06, $08, $00, $0A
00011190 =00000006                M spsr1	=	op1
00011190 =00000008                M spsr2	=	op2
00011190 =00000000                M spsr3	=	op3
00011190 =0000000A                M spsr4	=	op4
00011190                            	spDecayRt	$00, $00, $00, $00
00011190 =00000000                M spdr1	=	op1
00011190 =00000000                M spdr2	=	op2
00011190 =00000000                M spdr3	=	op3
00011190 =00000000                M spdr4	=	op4
00011190                            	spSustainLv	$0F, $05, $00, $0F
00011190 =0000000F                M spsl1	=	op1
00011190 =00000005                M spsl2	=	op2
00011190 =00000000                M spsl3	=	op3
00011190 =0000000F                M spsl4	=	op4
00011190                            	spReleaseRt	$04, $06, $02, $05
00011190 =00000004                M sprr1	=	op1
00011190 =00000006                M sprr2	=	op2
00011190 =00000002                M sprr3	=	op3
00011190 =00000005                M sprr4	=	op4
00011190                            	spSSGEG		$00, $00, $00, $00
00011190 =00000000                M spss1	=	op1
00011190 =00000000                M spss2	=	op2
00011190 =00000000                M spss3	=	op3
00011190 =00000000                M spss4	=	op4
00011190                            	spTotalLv	$33, $43, $1B, $04
00011190 =00000033                M sptl1	=	op1
00011190 =00000043                M sptl2	=	op2
00011190 =0000001B                M sptl3	=	op3
00011190 =00000004                M sptl4	=	op4
00011190 03                       M 	dc.b	(spfe<<3)+spal
00011191 =00000080                M sptlmask4	set	$80
00011191 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011191 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011191 =00000000                M sptlmask1	set	((spal=7)<<7)
00011191 0178 393A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011195 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011199 0600 080A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001119D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111A1 F402 56F5                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111A9 331B 4384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111AD 4E41 54                  M 	dc.b	'NAT'
000111B0                            
000111B0                            	; Patch $39
000111B0                            	; $3A
000111B0                            	; $01, $07, $01, $01,	$8E, $8E, $8D, $53
000111B0                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
000111B0                            	; $13, $FA, $13, $0A,	$18, $1E, $27, $04
000111B0                            	spAlgorithm	$02
000111B0 =0000003A                M spatnum	=	spatnum+1
000111B0 =00000002                M spal	=	val
000111B0                            	spFeedback	$07
000111B0 =00000007                M spfe	=	val
000111B0                            	spDetune	$00, $00, $00, $00
000111B0 =00000000                M spde1	=	op1
000111B0 =00000000                M spde2	=	op2
000111B0 =00000000                M spde3	=	op3
000111B0 =00000000                M spde4	=	op4
000111B0                            	spMultiple	$01, $01, $07, $01
000111B0 =00000001                M spmu1	=	op1
000111B0 =00000001                M spmu2	=	op2
000111B0 =00000007                M spmu3	=	op3
000111B0 =00000001                M spmu4	=	op4
000111B0                            	spRateScale	$02, $02, $02, $01
000111B0 =00000002                M sprs1	=	op1
000111B0 =00000002                M sprs2	=	op2
000111B0 =00000002                M sprs3	=	op3
000111B0 =00000001                M sprs4	=	op4
000111B0                            	spAttackRt	$0E, $0D, $0E, $13
000111B0 =0000000E                M spar1	=	op1
000111B0 =0000000D                M spar2	=	op2
000111B0 =0000000E                M spar3	=	op3
000111B0 =00000013                M spar4	=	op4
000111B0                            	spAmpMod	$00, $00, $00, $00
000111B0 =00000000                M spam1	=	op1
000111B0 =00000000                M spam2	=	op2
000111B0 =00000000                M spam3	=	op3
000111B0 =00000000                M spam4	=	op4
000111B0                            	spSustainRt	$0E, $0E, $0E, $03
000111B0 =0000000E                M spsr1	=	op1
000111B0 =0000000E                M spsr2	=	op2
000111B0 =0000000E                M spsr3	=	op3
000111B0 =00000003                M spsr4	=	op4
000111B0                            	spDecayRt	$00, $00, $00, $00
000111B0 =00000000                M spdr1	=	op1
000111B0 =00000000                M spdr2	=	op2
000111B0 =00000000                M spdr3	=	op3
000111B0 =00000000                M spdr4	=	op4
000111B0                            	spSustainLv	$01, $01, $0F, $00
000111B0 =00000001                M spsl1	=	op1
000111B0 =00000001                M spsl2	=	op2
000111B0 =0000000F                M spsl3	=	op3
000111B0 =00000000                M spsl4	=	op4
000111B0                            	spReleaseRt	$03, $03, $0A, $0A
000111B0 =00000003                M sprr1	=	op1
000111B0 =00000003                M sprr2	=	op2
000111B0 =0000000A                M sprr3	=	op3
000111B0 =0000000A                M sprr4	=	op4
000111B0                            	spSSGEG		$00, $00, $00, $00
000111B0 =00000000                M spss1	=	op1
000111B0 =00000000                M spss2	=	op2
000111B0 =00000000                M spss3	=	op3
000111B0 =00000000                M spss4	=	op4
000111B0                            	spTotalLv	$18, $27, $1E, $04
000111B0 =00000018                M sptl1	=	op1
000111B0 =00000027                M sptl2	=	op2
000111B0 =0000001E                M sptl3	=	op3
000111B0 =00000004                M sptl4	=	op4
000111B0 3A                       M 	dc.b	(spfe<<3)+spal
000111B1 =00000080                M sptlmask4	set	$80
000111B1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000111B1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000111B1 =00000000                M sptlmask1	set	((spal=7)<<7)
000111B1 0107 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111B5 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111B9 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111BD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111C1 13FA 130A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111C5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111C9 181E 2784                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111CD 4E41 54                  M 	dc.b	'NAT'
000111D0                            
000111D0                            	; Patch $3A
000111D0                            	; $24
000111D0                            	; $7D, $35, $3D, $75,	$1F, $1F, $1F, $1F
000111D0                            	; $01, $0D, $01, $0D,	$10, $12, $10, $12
000111D0                            	; $F5, $38, $F5, $38,	$00, $04, $00, $04
000111D0                            	spAlgorithm	$04
000111D0 =0000003B                M spatnum	=	spatnum+1
000111D0 =00000004                M spal	=	val
000111D0                            	spFeedback	$04
000111D0 =00000004                M spfe	=	val
000111D0                            	spDetune	$07, $03, $03, $07
000111D0 =00000007                M spde1	=	op1
000111D0 =00000003                M spde2	=	op2
000111D0 =00000003                M spde3	=	op3
000111D0 =00000007                M spde4	=	op4
000111D0                            	spMultiple	$0D, $0D, $05, $05
000111D0 =0000000D                M spmu1	=	op1
000111D0 =0000000D                M spmu2	=	op2
000111D0 =00000005                M spmu3	=	op3
000111D0 =00000005                M spmu4	=	op4
000111D0                            	spRateScale	$00, $00, $00, $00
000111D0 =00000000                M sprs1	=	op1
000111D0 =00000000                M sprs2	=	op2
000111D0 =00000000                M sprs3	=	op3
000111D0 =00000000                M sprs4	=	op4
000111D0                            	spAttackRt	$1F, $1F, $1F, $1F
000111D0 =0000001F                M spar1	=	op1
000111D0 =0000001F                M spar2	=	op2
000111D0 =0000001F                M spar3	=	op3
000111D0 =0000001F                M spar4	=	op4
000111D0                            	spAmpMod	$00, $00, $00, $00
000111D0 =00000000                M spam1	=	op1
000111D0 =00000000                M spam2	=	op2
000111D0 =00000000                M spam3	=	op3
000111D0 =00000000                M spam4	=	op4
000111D0                            	spSustainRt	$01, $01, $0D, $0D
000111D0 =00000001                M spsr1	=	op1
000111D0 =00000001                M spsr2	=	op2
000111D0 =0000000D                M spsr3	=	op3
000111D0 =0000000D                M spsr4	=	op4
000111D0                            	spDecayRt	$10, $10, $12, $12
000111D0 =00000010                M spdr1	=	op1
000111D0 =00000010                M spdr2	=	op2
000111D0 =00000012                M spdr3	=	op3
000111D0 =00000012                M spdr4	=	op4
000111D0                            	spSustainLv	$0F, $0F, $03, $03
000111D0 =0000000F                M spsl1	=	op1
000111D0 =0000000F                M spsl2	=	op2
000111D0 =00000003                M spsl3	=	op3
000111D0 =00000003                M spsl4	=	op4
000111D0                            	spReleaseRt	$05, $05, $08, $08
000111D0 =00000005                M sprr1	=	op1
000111D0 =00000005                M sprr2	=	op2
000111D0 =00000008                M sprr3	=	op3
000111D0 =00000008                M sprr4	=	op4
000111D0                            	spSSGEG		$00, $00, $00, $00
000111D0 =00000000                M spss1	=	op1
000111D0 =00000000                M spss2	=	op2
000111D0 =00000000                M spss3	=	op3
000111D0 =00000000                M spss4	=	op4
000111D0                            	spTotalLv	$00, $00, $04, $04
000111D0 =00000000                M sptl1	=	op1
000111D0 =00000000                M sptl2	=	op2
000111D0 =00000004                M sptl3	=	op3
000111D0 =00000004                M sptl4	=	op4
000111D0 24                       M 	dc.b	(spfe<<3)+spal
000111D1 =00000080                M sptlmask4	set	$80
000111D1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000111D1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000111D1 =00000000                M sptlmask1	set	((spal=7)<<7)
000111D1 7D35 3D75                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111D5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111D9 010D 010D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111DD 1012 1012                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111E1 F538 F538                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111E5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111E9 0084 0084                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111ED 4E41 54                  M 	dc.b	'NAT'
000111F0                            
000111F0                            	; Patch $3B
000111F0                            	; $32
000111F0                            	; $2A, $61, $65, $23,	$94, $10, $54, $19
000111F0                            	; $85, $0B, $0E, $05,	$06, $04, $03, $03
000111F0                            	; $12, $14, $24, $27,	$2E, $0A, $1B, $05
000111F0                            	spAlgorithm	$02
000111F0 =0000003C                M spatnum	=	spatnum+1
000111F0 =00000002                M spal	=	val
000111F0                            	spFeedback	$06
000111F0 =00000006                M spfe	=	val
000111F0                            	spDetune	$02, $06, $06, $02
000111F0 =00000002                M spde1	=	op1
000111F0 =00000006                M spde2	=	op2
000111F0 =00000006                M spde3	=	op3
000111F0 =00000002                M spde4	=	op4
000111F0                            	spMultiple	$0A, $05, $01, $03
000111F0 =0000000A                M spmu1	=	op1
000111F0 =00000005                M spmu2	=	op2
000111F0 =00000001                M spmu3	=	op3
000111F0 =00000003                M spmu4	=	op4
000111F0                            	spRateScale	$02, $01, $00, $00
000111F0 =00000002                M sprs1	=	op1
000111F0 =00000001                M sprs2	=	op2
000111F0 =00000000                M sprs3	=	op3
000111F0 =00000000                M sprs4	=	op4
000111F0                            	spAttackRt	$14, $14, $10, $19
000111F0 =00000014                M spar1	=	op1
000111F0 =00000014                M spar2	=	op2
000111F0 =00000010                M spar3	=	op3
000111F0 =00000019                M spar4	=	op4
000111F0                            	spAmpMod	$01, $00, $00, $00
000111F0 =00000001                M spam1	=	op1
000111F0 =00000000                M spam2	=	op2
000111F0 =00000000                M spam3	=	op3
000111F0 =00000000                M spam4	=	op4
000111F0                            	spSustainRt	$05, $0E, $0B, $05
000111F0 =00000005                M spsr1	=	op1
000111F0 =0000000E                M spsr2	=	op2
000111F0 =0000000B                M spsr3	=	op3
000111F0 =00000005                M spsr4	=	op4
000111F0                            	spDecayRt	$06, $03, $04, $03
000111F0 =00000006                M spdr1	=	op1
000111F0 =00000003                M spdr2	=	op2
000111F0 =00000004                M spdr3	=	op3
000111F0 =00000003                M spdr4	=	op4
000111F0                            	spSustainLv	$01, $02, $01, $02
000111F0 =00000001                M spsl1	=	op1
000111F0 =00000002                M spsl2	=	op2
000111F0 =00000001                M spsl3	=	op3
000111F0 =00000002                M spsl4	=	op4
000111F0                            	spReleaseRt	$02, $04, $04, $07
000111F0 =00000002                M sprr1	=	op1
000111F0 =00000004                M sprr2	=	op2
000111F0 =00000004                M sprr3	=	op3
000111F0 =00000007                M sprr4	=	op4
000111F0                            	spSSGEG		$00, $00, $00, $00
000111F0 =00000000                M spss1	=	op1
000111F0 =00000000                M spss2	=	op2
000111F0 =00000000                M spss3	=	op3
000111F0 =00000000                M spss4	=	op4
000111F0                            	spTotalLv	$2E, $1B, $0A, $05
000111F0 =0000002E                M sptl1	=	op1
000111F0 =0000001B                M sptl2	=	op2
000111F0 =0000000A                M sptl3	=	op3
000111F0 =00000005                M sptl4	=	op4
000111F0 32                       M 	dc.b	(spfe<<3)+spal
000111F1 =00000080                M sptlmask4	set	$80
000111F1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000111F1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000111F1 =00000000                M sptlmask1	set	((spal=7)<<7)
000111F1 2A61 6523                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111F5 9410 5419                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111F9 850B 0E05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111FD 0604 0303                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011201 1214 2427                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011205 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011209 2E0A 1B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001120D 4E41 54                  M 	dc.b	'NAT'
00011210                            
00011210                            	; Patch $3C
00011210                            	; $38
00011210                            	; $71, $31, $71, $41,	$5F, $1F, $1F, $1F
00011210                            	; $07, $06, $09, $1F,	$00, $00, $00, $00
00011210                            	; $98, $9A, $09, $0C,	$1C, $1B, $1A, $04
00011210                            	spAlgorithm	$00
00011210 =0000003D                M spatnum	=	spatnum+1
00011210 =00000000                M spal	=	val
00011210                            	spFeedback	$07
00011210 =00000007                M spfe	=	val
00011210                            	spDetune	$07, $07, $03, $04
00011210 =00000007                M spde1	=	op1
00011210 =00000007                M spde2	=	op2
00011210 =00000003                M spde3	=	op3
00011210 =00000004                M spde4	=	op4
00011210                            	spMultiple	$01, $01, $01, $01
00011210 =00000001                M spmu1	=	op1
00011210 =00000001                M spmu2	=	op2
00011210 =00000001                M spmu3	=	op3
00011210 =00000001                M spmu4	=	op4
00011210                            	spRateScale	$01, $00, $00, $00
00011210 =00000001                M sprs1	=	op1
00011210 =00000000                M sprs2	=	op2
00011210 =00000000                M sprs3	=	op3
00011210 =00000000                M sprs4	=	op4
00011210                            	spAttackRt	$1F, $1F, $1F, $1F
00011210 =0000001F                M spar1	=	op1
00011210 =0000001F                M spar2	=	op2
00011210 =0000001F                M spar3	=	op3
00011210 =0000001F                M spar4	=	op4
00011210                            	spAmpMod	$00, $00, $00, $00
00011210 =00000000                M spam1	=	op1
00011210 =00000000                M spam2	=	op2
00011210 =00000000                M spam3	=	op3
00011210 =00000000                M spam4	=	op4
00011210                            	spSustainRt	$07, $09, $06, $1F
00011210 =00000007                M spsr1	=	op1
00011210 =00000009                M spsr2	=	op2
00011210 =00000006                M spsr3	=	op3
00011210 =0000001F                M spsr4	=	op4
00011210                            	spDecayRt	$00, $00, $00, $00
00011210 =00000000                M spdr1	=	op1
00011210 =00000000                M spdr2	=	op2
00011210 =00000000                M spdr3	=	op3
00011210 =00000000                M spdr4	=	op4
00011210                            	spSustainLv	$09, $00, $09, $00
00011210 =00000009                M spsl1	=	op1
00011210 =00000000                M spsl2	=	op2
00011210 =00000009                M spsl3	=	op3
00011210 =00000000                M spsl4	=	op4
00011210                            	spReleaseRt	$08, $09, $0A, $0C
00011210 =00000008                M sprr1	=	op1
00011210 =00000009                M sprr2	=	op2
00011210 =0000000A                M sprr3	=	op3
00011210 =0000000C                M sprr4	=	op4
00011210                            	spSSGEG		$00, $00, $00, $00
00011210 =00000000                M spss1	=	op1
00011210 =00000000                M spss2	=	op2
00011210 =00000000                M spss3	=	op3
00011210 =00000000                M spss4	=	op4
00011210                            	spTotalLv	$1C, $1A, $1B, $04
00011210 =0000001C                M sptl1	=	op1
00011210 =0000001A                M sptl2	=	op2
00011210 =0000001B                M sptl3	=	op3
00011210 =00000004                M sptl4	=	op4
00011210 38                       M 	dc.b	(spfe<<3)+spal
00011211 =00000080                M sptlmask4	set	$80
00011211 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011211 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011211 =00000000                M sptlmask1	set	((spal=7)<<7)
00011211 7131 7141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011215 5F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011219 0706 091F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001121D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011221 989A 090C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011225 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011229 1C1B 1A84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001122D 4E41 54                  M 	dc.b	'NAT'
00011230                            
00011230                            	; Patch $3D
00011230                            	; $02
00011230                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
00011230                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
00011230                            	; $01, $11, $31, $88,	$1C, $2D, $27, $05
00011230                            	spAlgorithm	$02
00011230 =0000003E                M spatnum	=	spatnum+1
00011230 =00000002                M spal	=	val
00011230                            	spFeedback	$00
00011230 =00000000                M spfe	=	val
00011230                            	spDetune	$06, $00, $07, $03
00011230 =00000006                M spde1	=	op1
00011230 =00000000                M spde2	=	op2
00011230 =00000007                M spde3	=	op3
00011230 =00000003                M spde4	=	op4
00011230                            	spMultiple	$01, $04, $0C, $01
00011230 =00000001                M spmu1	=	op1
00011230 =00000004                M spmu2	=	op2
00011230 =0000000C                M spmu3	=	op3
00011230 =00000001                M spmu4	=	op4
00011230                            	spRateScale	$00, $02, $03, $01
00011230 =00000000                M sprs1	=	op1
00011230 =00000002                M sprs2	=	op2
00011230 =00000003                M sprs3	=	op3
00011230 =00000001                M sprs4	=	op4
00011230                            	spAttackRt	$14, $0F, $10, $14
00011230 =00000014                M spar1	=	op1
00011230 =0000000F                M spar2	=	op2
00011230 =00000010                M spar3	=	op3
00011230 =00000014                M spar4	=	op4
00011230                            	spAmpMod	$00, $00, $00, $00
00011230 =00000000                M spam1	=	op1
00011230 =00000000                M spam2	=	op2
00011230 =00000000                M spam3	=	op3
00011230 =00000000                M spam4	=	op4
00011230                            	spSustainRt	$01, $05, $05, $08
00011230 =00000001                M spsr1	=	op1
00011230 =00000005                M spsr2	=	op2
00011230 =00000005                M spsr3	=	op3
00011230 =00000008                M spsr4	=	op4
00011230                            	spDecayRt	$02, $05, $02, $1F
00011230 =00000002                M spdr1	=	op1
00011230 =00000005                M spdr2	=	op2
00011230 =00000002                M spdr3	=	op3
00011230 =0000001F                M spdr4	=	op4
00011230                            	spSustainLv	$00, $03, $01, $08
00011230 =00000000                M spsl1	=	op1
00011230 =00000003                M spsl2	=	op2
00011230 =00000001                M spsl3	=	op3
00011230 =00000008                M spsl4	=	op4
00011230                            	spReleaseRt	$01, $01, $01, $08
00011230 =00000001                M sprr1	=	op1
00011230 =00000001                M sprr2	=	op2
00011230 =00000001                M sprr3	=	op3
00011230 =00000008                M sprr4	=	op4
00011230                            	spSSGEG		$00, $00, $00, $00
00011230 =00000000                M spss1	=	op1
00011230 =00000000                M spss2	=	op2
00011230 =00000000                M spss3	=	op3
00011230 =00000000                M spss4	=	op4
00011230                            	spTotalLv	$1C, $27, $2D, $05
00011230 =0000001C                M sptl1	=	op1
00011230 =00000027                M sptl2	=	op2
00011230 =0000002D                M sptl3	=	op3
00011230 =00000005                M sptl4	=	op4
00011230 02                       M 	dc.b	(spfe<<3)+spal
00011231 =00000080                M sptlmask4	set	$80
00011231 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011231 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011231 =00000000                M sptlmask1	set	((spal=7)<<7)
00011231 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011235 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011239 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001123D 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011241 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011245 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011249 1C2D 2785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001124D 4E41 54                  M 	dc.b	'NAT'
00011250                            
00011250                            	; Patch $3E
00011250                            	; $13
00011250                            	; $01, $04, $00, $01,	$1C, $9D, $DE, $DF
00011250                            	; $11, $0D, $02, $01,	$1F, $18, $0B, $01
00011250                            	; $6F, $63, $FF, $3F,	$1E, $1C, $19, $05
00011250                            	spAlgorithm	$03
00011250 =0000003F                M spatnum	=	spatnum+1
00011250 =00000003                M spal	=	val
00011250                            	spFeedback	$02
00011250 =00000002                M spfe	=	val
00011250                            	spDetune	$00, $00, $00, $00
00011250 =00000000                M spde1	=	op1
00011250 =00000000                M spde2	=	op2
00011250 =00000000                M spde3	=	op3
00011250 =00000000                M spde4	=	op4
00011250                            	spMultiple	$01, $00, $04, $01
00011250 =00000001                M spmu1	=	op1
00011250 =00000000                M spmu2	=	op2
00011250 =00000004                M spmu3	=	op3
00011250 =00000001                M spmu4	=	op4
00011250                            	spRateScale	$00, $03, $02, $03
00011250 =00000000                M sprs1	=	op1
00011250 =00000003                M sprs2	=	op2
00011250 =00000002                M sprs3	=	op3
00011250 =00000003                M sprs4	=	op4
00011250                            	spAttackRt	$1C, $1E, $1D, $1F
00011250 =0000001C                M spar1	=	op1
00011250 =0000001E                M spar2	=	op2
00011250 =0000001D                M spar3	=	op3
00011250 =0000001F                M spar4	=	op4
00011250                            	spAmpMod	$00, $00, $00, $00
00011250 =00000000                M spam1	=	op1
00011250 =00000000                M spam2	=	op2
00011250 =00000000                M spam3	=	op3
00011250 =00000000                M spam4	=	op4
00011250                            	spSustainRt	$11, $02, $0D, $01
00011250 =00000011                M spsr1	=	op1
00011250 =00000002                M spsr2	=	op2
00011250 =0000000D                M spsr3	=	op3
00011250 =00000001                M spsr4	=	op4
00011250                            	spDecayRt	$1F, $0B, $18, $01
00011250 =0000001F                M spdr1	=	op1
00011250 =0000000B                M spdr2	=	op2
00011250 =00000018                M spdr3	=	op3
00011250 =00000001                M spdr4	=	op4
00011250                            	spSustainLv	$06, $0F, $06, $03
00011250 =00000006                M spsl1	=	op1
00011250 =0000000F                M spsl2	=	op2
00011250 =00000006                M spsl3	=	op3
00011250 =00000003                M spsl4	=	op4
00011250                            	spReleaseRt	$0F, $0F, $03, $0F
00011250 =0000000F                M sprr1	=	op1
00011250 =0000000F                M sprr2	=	op2
00011250 =00000003                M sprr3	=	op3
00011250 =0000000F                M sprr4	=	op4
00011250                            	spSSGEG		$00, $00, $00, $00
00011250 =00000000                M spss1	=	op1
00011250 =00000000                M spss2	=	op2
00011250 =00000000                M spss3	=	op3
00011250 =00000000                M spss4	=	op4
00011250                            	spTotalLv	$1E, $19, $1C, $05
00011250 =0000001E                M sptl1	=	op1
00011250 =00000019                M sptl2	=	op2
00011250 =0000001C                M sptl3	=	op3
00011250 =00000005                M sptl4	=	op4
00011250 13                       M 	dc.b	(spfe<<3)+spal
00011251 =00000080                M sptlmask4	set	$80
00011251 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011251 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011251 =00000000                M sptlmask1	set	((spal=7)<<7)
00011251 0104 0001                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011255 1C9D DEDF                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011259 110D 0201                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001125D 1F18 0B01                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011261 6F63 FF3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011265 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011269 1E1C 1985                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001126D 4E41 54                  M 	dc.b	'NAT'
00011270                            
00011270                            	; Patch $3F
00011270                            	; $17
00011270                            	; $32, $72, $32, $12,	$C8, $88, $8C, $C8
00011270                            	; $00, $13, $8C, $8D,	$01, $01, $01, $00
00011270                            	; $08, $58, $A8, $78,	$04, $08, $09, $07
00011270                            	spAlgorithm	$07
00011270 =00000040                M spatnum	=	spatnum+1
00011270 =00000007                M spal	=	val
00011270                            	spFeedback	$02
00011270 =00000002                M spfe	=	val
00011270                            	spDetune	$03, $03, $07, $01
00011270 =00000003                M spde1	=	op1
00011270 =00000003                M spde2	=	op2
00011270 =00000007                M spde3	=	op3
00011270 =00000001                M spde4	=	op4
00011270                            	spMultiple	$02, $02, $02, $02
00011270 =00000002                M spmu1	=	op1
00011270 =00000002                M spmu2	=	op2
00011270 =00000002                M spmu3	=	op3
00011270 =00000002                M spmu4	=	op4
00011270                            	spRateScale	$03, $02, $02, $03
00011270 =00000003                M sprs1	=	op1
00011270 =00000002                M sprs2	=	op2
00011270 =00000002                M sprs3	=	op3
00011270 =00000003                M sprs4	=	op4
00011270                            	spAttackRt	$08, $0C, $08, $08
00011270 =00000008                M spar1	=	op1
00011270 =0000000C                M spar2	=	op2
00011270 =00000008                M spar3	=	op3
00011270 =00000008                M spar4	=	op4
00011270                            	spAmpMod	$00, $01, $00, $01
00011270 =00000000                M spam1	=	op1
00011270 =00000001                M spam2	=	op2
00011270 =00000000                M spam3	=	op3
00011270 =00000001                M spam4	=	op4
00011270                            	spSustainRt	$00, $0C, $13, $0D
00011270 =00000000                M spsr1	=	op1
00011270 =0000000C                M spsr2	=	op2
00011270 =00000013                M spsr3	=	op3
00011270 =0000000D                M spsr4	=	op4
00011270                            	spDecayRt	$01, $01, $01, $00
00011270 =00000001                M spdr1	=	op1
00011270 =00000001                M spdr2	=	op2
00011270 =00000001                M spdr3	=	op3
00011270 =00000000                M spdr4	=	op4
00011270                            	spSustainLv	$00, $0A, $05, $07
00011270 =00000000                M spsl1	=	op1
00011270 =0000000A                M spsl2	=	op2
00011270 =00000005                M spsl3	=	op3
00011270 =00000007                M spsl4	=	op4
00011270                            	spReleaseRt	$08, $08, $08, $08
00011270 =00000008                M sprr1	=	op1
00011270 =00000008                M sprr2	=	op2
00011270 =00000008                M sprr3	=	op3
00011270 =00000008                M sprr4	=	op4
00011270                            	spSSGEG		$00, $00, $00, $00
00011270 =00000000                M spss1	=	op1
00011270 =00000000                M spss2	=	op2
00011270 =00000000                M spss3	=	op3
00011270 =00000000                M spss4	=	op4
00011270                            	spTotalLv	$04, $09, $08, $07
00011270 =00000004                M sptl1	=	op1
00011270 =00000009                M sptl2	=	op2
00011270 =00000008                M sptl3	=	op3
00011270 =00000007                M sptl4	=	op4
00011270 17                       M 	dc.b	(spfe<<3)+spal
00011271 =00000080                M sptlmask4	set	$80
00011271 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011271 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011271 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
00011271 3272 3212                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011275 C888 8CC8                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011279 0013 8C8D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001127D 0101 0100                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011281 0858 A878                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011285 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011289 8488 8987                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001128D 4E41 54                  M 	dc.b	'NAT'
00011290                            
00011290                            	; Patch $40
00011290                            	; $3D
00011290                            	; $01, $01, $01, $01,	$10, $50, $50, $50
00011290                            	; $07, $08, $08, $08,	$01, $00, $00, $00
00011290                            	; $20, $1A, $1A, $1A,	$19, $05, $05, $05
00011290                            	spAlgorithm	$05
00011290 =00000041                M spatnum	=	spatnum+1
00011290 =00000005                M spal	=	val
00011290                            	spFeedback	$07
00011290 =00000007                M spfe	=	val
00011290                            	spDetune	$00, $00, $00, $00
00011290 =00000000                M spde1	=	op1
00011290 =00000000                M spde2	=	op2
00011290 =00000000                M spde3	=	op3
00011290 =00000000                M spde4	=	op4
00011290                            	spMultiple	$01, $01, $01, $01
00011290 =00000001                M spmu1	=	op1
00011290 =00000001                M spmu2	=	op2
00011290 =00000001                M spmu3	=	op3
00011290 =00000001                M spmu4	=	op4
00011290                            	spRateScale	$00, $01, $01, $01
00011290 =00000000                M sprs1	=	op1
00011290 =00000001                M sprs2	=	op2
00011290 =00000001                M sprs3	=	op3
00011290 =00000001                M sprs4	=	op4
00011290                            	spAttackRt	$10, $10, $10, $10
00011290 =00000010                M spar1	=	op1
00011290 =00000010                M spar2	=	op2
00011290 =00000010                M spar3	=	op3
00011290 =00000010                M spar4	=	op4
00011290                            	spAmpMod	$00, $00, $00, $00
00011290 =00000000                M spam1	=	op1
00011290 =00000000                M spam2	=	op2
00011290 =00000000                M spam3	=	op3
00011290 =00000000                M spam4	=	op4
00011290                            	spSustainRt	$07, $08, $08, $08
00011290 =00000007                M spsr1	=	op1
00011290 =00000008                M spsr2	=	op2
00011290 =00000008                M spsr3	=	op3
00011290 =00000008                M spsr4	=	op4
00011290                            	spDecayRt	$01, $00, $00, $00
00011290 =00000001                M spdr1	=	op1
00011290 =00000000                M spdr2	=	op2
00011290 =00000000                M spdr3	=	op3
00011290 =00000000                M spdr4	=	op4
00011290                            	spSustainLv	$02, $01, $01, $01
00011290 =00000002                M spsl1	=	op1
00011290 =00000001                M spsl2	=	op2
00011290 =00000001                M spsl3	=	op3
00011290 =00000001                M spsl4	=	op4
00011290                            	spReleaseRt	$00, $0A, $0A, $0A
00011290 =00000000                M sprr1	=	op1
00011290 =0000000A                M sprr2	=	op2
00011290 =0000000A                M sprr3	=	op3
00011290 =0000000A                M sprr4	=	op4
00011290                            	spSSGEG		$00, $00, $00, $00
00011290 =00000000                M spss1	=	op1
00011290 =00000000                M spss2	=	op2
00011290 =00000000                M spss3	=	op3
00011290 =00000000                M spss4	=	op4
00011290                            	spTotalLv	$19, $05, $05, $05
00011290 =00000019                M sptl1	=	op1
00011290 =00000005                M sptl2	=	op2
00011290 =00000005                M sptl3	=	op3
00011290 =00000005                M sptl4	=	op4
00011290 3D                       M 	dc.b	(spfe<<3)+spal
00011291 =00000080                M sptlmask4	set	$80
00011291 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011291 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011291 =00000000                M sptlmask1	set	((spal=7)<<7)
00011291 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011295 1050 5050                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011299 0708 0808                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001129D 0100 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112A1 201A 1A1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112A9 1985 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112AD 4E41 54                  M 	dc.b	'NAT'
000112B0                            
000112B0                            	; Patch $41
000112B0                            	; $3A
000112B0                            	; $03, $08, $03, $01,	$8E, $8E, $8D, $53
000112B0                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
000112B0                            	; $1F, $FF, $1F, $0F,	$17, $28, $20, $05
000112B0                            	spAlgorithm	$02
000112B0 =00000042                M spatnum	=	spatnum+1
000112B0 =00000002                M spal	=	val
000112B0                            	spFeedback	$07
000112B0 =00000007                M spfe	=	val
000112B0                            	spDetune	$00, $00, $00, $00
000112B0 =00000000                M spde1	=	op1
000112B0 =00000000                M spde2	=	op2
000112B0 =00000000                M spde3	=	op3
000112B0 =00000000                M spde4	=	op4
000112B0                            	spMultiple	$03, $03, $08, $01
000112B0 =00000003                M spmu1	=	op1
000112B0 =00000003                M spmu2	=	op2
000112B0 =00000008                M spmu3	=	op3
000112B0 =00000001                M spmu4	=	op4
000112B0                            	spRateScale	$02, $02, $02, $01
000112B0 =00000002                M sprs1	=	op1
000112B0 =00000002                M sprs2	=	op2
000112B0 =00000002                M sprs3	=	op3
000112B0 =00000001                M sprs4	=	op4
000112B0                            	spAttackRt	$0E, $0D, $0E, $13
000112B0 =0000000E                M spar1	=	op1
000112B0 =0000000D                M spar2	=	op2
000112B0 =0000000E                M spar3	=	op3
000112B0 =00000013                M spar4	=	op4
000112B0                            	spAmpMod	$00, $00, $00, $00
000112B0 =00000000                M spam1	=	op1
000112B0 =00000000                M spam2	=	op2
000112B0 =00000000                M spam3	=	op3
000112B0 =00000000                M spam4	=	op4
000112B0                            	spSustainRt	$0E, $0E, $0E, $03
000112B0 =0000000E                M spsr1	=	op1
000112B0 =0000000E                M spsr2	=	op2
000112B0 =0000000E                M spsr3	=	op3
000112B0 =00000003                M spsr4	=	op4
000112B0                            	spDecayRt	$00, $00, $00, $00
000112B0 =00000000                M spdr1	=	op1
000112B0 =00000000                M spdr2	=	op2
000112B0 =00000000                M spdr3	=	op3
000112B0 =00000000                M spdr4	=	op4
000112B0                            	spSustainLv	$01, $01, $0F, $00
000112B0 =00000001                M spsl1	=	op1
000112B0 =00000001                M spsl2	=	op2
000112B0 =0000000F                M spsl3	=	op3
000112B0 =00000000                M spsl4	=	op4
000112B0                            	spReleaseRt	$0F, $0F, $0F, $0F
000112B0 =0000000F                M sprr1	=	op1
000112B0 =0000000F                M sprr2	=	op2
000112B0 =0000000F                M sprr3	=	op3
000112B0 =0000000F                M sprr4	=	op4
000112B0                            	spSSGEG		$00, $00, $00, $00
000112B0 =00000000                M spss1	=	op1
000112B0 =00000000                M spss2	=	op2
000112B0 =00000000                M spss3	=	op3
000112B0 =00000000                M spss4	=	op4
000112B0                            	spTotalLv	$17, $20, $28, $05
000112B0 =00000017                M sptl1	=	op1
000112B0 =00000020                M sptl2	=	op2
000112B0 =00000028                M sptl3	=	op3
000112B0 =00000005                M sptl4	=	op4
000112B0 3A                       M 	dc.b	(spfe<<3)+spal
000112B1 =00000080                M sptlmask4	set	$80
000112B1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000112B1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000112B1 =00000000                M sptlmask1	set	((spal=7)<<7)
000112B1 0308 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112B5 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112B9 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112BD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112C1 1FFF 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112C5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112C9 1728 2085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112CD 4E41 54                  M 	dc.b	'NAT'
000112D0                            
000112D0                            	; Patch $42
000112D0                            	; $07
000112D0                            	; $06, $7C, $75, $0A,	$1F, $1F, $1F, $1F
000112D0                            	; $00, $00, $00, $00,	$00, $00, $00, $00
000112D0                            	; $0F, $0F, $0F, $0F,	$07, $07, $07, $07
000112D0                            	spAlgorithm	$07
000112D0 =00000043                M spatnum	=	spatnum+1
000112D0 =00000007                M spal	=	val
000112D0                            	spFeedback	$00
000112D0 =00000000                M spfe	=	val
000112D0                            	spDetune	$00, $07, $07, $00
000112D0 =00000000                M spde1	=	op1
000112D0 =00000007                M spde2	=	op2
000112D0 =00000007                M spde3	=	op3
000112D0 =00000000                M spde4	=	op4
000112D0                            	spMultiple	$06, $05, $0C, $0A
000112D0 =00000006                M spmu1	=	op1
000112D0 =00000005                M spmu2	=	op2
000112D0 =0000000C                M spmu3	=	op3
000112D0 =0000000A                M spmu4	=	op4
000112D0                            	spRateScale	$00, $00, $00, $00
000112D0 =00000000                M sprs1	=	op1
000112D0 =00000000                M sprs2	=	op2
000112D0 =00000000                M sprs3	=	op3
000112D0 =00000000                M sprs4	=	op4
000112D0                            	spAttackRt	$1F, $1F, $1F, $1F
000112D0 =0000001F                M spar1	=	op1
000112D0 =0000001F                M spar2	=	op2
000112D0 =0000001F                M spar3	=	op3
000112D0 =0000001F                M spar4	=	op4
000112D0                            	spAmpMod	$00, $00, $00, $00
000112D0 =00000000                M spam1	=	op1
000112D0 =00000000                M spam2	=	op2
000112D0 =00000000                M spam3	=	op3
000112D0 =00000000                M spam4	=	op4
000112D0                            	spSustainRt	$00, $00, $00, $00
000112D0 =00000000                M spsr1	=	op1
000112D0 =00000000                M spsr2	=	op2
000112D0 =00000000                M spsr3	=	op3
000112D0 =00000000                M spsr4	=	op4
000112D0                            	spDecayRt	$00, $00, $00, $00
000112D0 =00000000                M spdr1	=	op1
000112D0 =00000000                M spdr2	=	op2
000112D0 =00000000                M spdr3	=	op3
000112D0 =00000000                M spdr4	=	op4
000112D0                            	spSustainLv	$00, $00, $00, $00
000112D0 =00000000                M spsl1	=	op1
000112D0 =00000000                M spsl2	=	op2
000112D0 =00000000                M spsl3	=	op3
000112D0 =00000000                M spsl4	=	op4
000112D0                            	spReleaseRt	$0F, $0F, $0F, $0F
000112D0 =0000000F                M sprr1	=	op1
000112D0 =0000000F                M sprr2	=	op2
000112D0 =0000000F                M sprr3	=	op3
000112D0 =0000000F                M sprr4	=	op4
000112D0                            	spSSGEG		$00, $00, $00, $00
000112D0 =00000000                M spss1	=	op1
000112D0 =00000000                M spss2	=	op2
000112D0 =00000000                M spss3	=	op3
000112D0 =00000000                M spss4	=	op4
000112D0                            	spTotalLv	$07, $07, $07, $07
000112D0 =00000007                M sptl1	=	op1
000112D0 =00000007                M sptl2	=	op2
000112D0 =00000007                M sptl3	=	op3
000112D0 =00000007                M sptl4	=	op4
000112D0 07                       M 	dc.b	(spfe<<3)+spal
000112D1 =00000080                M sptlmask4	set	$80
000112D1 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000112D1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000112D1 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
000112D1 067C 750A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112D5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112D9 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112DD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112E1 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112E5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112E9 8787 8787                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112ED 4E41 54                  M 	dc.b	'NAT'
000112F0                            
000112F0                            	; Patch $43
000112F0                            	; $3A
000112F0                            	; $01, $40, $01, $31,	$1F, $1F, $1F, $1F
000112F0                            	; $0B, $04, $04, $04,	$02, $04, $03, $02
000112F0                            	; $5F, $1F, $5F, $2F,	$18, $05, $11, $05
000112F0                            	spAlgorithm	$02
000112F0 =00000044                M spatnum	=	spatnum+1
000112F0 =00000002                M spal	=	val
000112F0                            	spFeedback	$07
000112F0 =00000007                M spfe	=	val
000112F0                            	spDetune	$00, $00, $04, $03
000112F0 =00000000                M spde1	=	op1
000112F0 =00000000                M spde2	=	op2
000112F0 =00000004                M spde3	=	op3
000112F0 =00000003                M spde4	=	op4
000112F0                            	spMultiple	$01, $01, $00, $01
000112F0 =00000001                M spmu1	=	op1
000112F0 =00000001                M spmu2	=	op2
000112F0 =00000000                M spmu3	=	op3
000112F0 =00000001                M spmu4	=	op4
000112F0                            	spRateScale	$00, $00, $00, $00
000112F0 =00000000                M sprs1	=	op1
000112F0 =00000000                M sprs2	=	op2
000112F0 =00000000                M sprs3	=	op3
000112F0 =00000000                M sprs4	=	op4
000112F0                            	spAttackRt	$1F, $1F, $1F, $1F
000112F0 =0000001F                M spar1	=	op1
000112F0 =0000001F                M spar2	=	op2
000112F0 =0000001F                M spar3	=	op3
000112F0 =0000001F                M spar4	=	op4
000112F0                            	spAmpMod	$00, $00, $00, $00
000112F0 =00000000                M spam1	=	op1
000112F0 =00000000                M spam2	=	op2
000112F0 =00000000                M spam3	=	op3
000112F0 =00000000                M spam4	=	op4
000112F0                            	spSustainRt	$0B, $04, $04, $04
000112F0 =0000000B                M spsr1	=	op1
000112F0 =00000004                M spsr2	=	op2
000112F0 =00000004                M spsr3	=	op3
000112F0 =00000004                M spsr4	=	op4
000112F0                            	spDecayRt	$02, $03, $04, $02
000112F0 =00000002                M spdr1	=	op1
000112F0 =00000003                M spdr2	=	op2
000112F0 =00000004                M spdr3	=	op3
000112F0 =00000002                M spdr4	=	op4
000112F0                            	spSustainLv	$05, $05, $01, $02
000112F0 =00000005                M spsl1	=	op1
000112F0 =00000005                M spsl2	=	op2
000112F0 =00000001                M spsl3	=	op3
000112F0 =00000002                M spsl4	=	op4
000112F0                            	spReleaseRt	$0F, $0F, $0F, $0F
000112F0 =0000000F                M sprr1	=	op1
000112F0 =0000000F                M sprr2	=	op2
000112F0 =0000000F                M sprr3	=	op3
000112F0 =0000000F                M sprr4	=	op4
000112F0                            	spSSGEG		$00, $00, $00, $00
000112F0 =00000000                M spss1	=	op1
000112F0 =00000000                M spss2	=	op2
000112F0 =00000000                M spss3	=	op3
000112F0 =00000000                M spss4	=	op4
000112F0                            	spTotalLv	$18, $11, $05, $05
000112F0 =00000018                M sptl1	=	op1
000112F0 =00000011                M sptl2	=	op2
000112F0 =00000005                M sptl3	=	op3
000112F0 =00000005                M sptl4	=	op4
000112F0 3A                       M 	dc.b	(spfe<<3)+spal
000112F1 =00000080                M sptlmask4	set	$80
000112F1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000112F1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000112F1 =00000000                M sptlmask1	set	((spal=7)<<7)
000112F1 0140 0131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112F5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112F9 0B04 0404                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112FD 0204 0302                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011301 5F1F 5F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011305 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011309 1805 1185                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001130D 4E41 54                  M 	dc.b	'NAT'
00011310                            
00011310                            	; Patch $44
00011310                            	; $3C
00011310                            	; $01, $01, $0E, $04,	$8D, $52, $9F, $1F
00011310                            	; $09, $00, $00, $0D,	$00, $00, $00, $00
00011310                            	; $23, $08, $02, $6F,	$15, $02, $10, $05
00011310                            	spAlgorithm	$04
00011310 =00000045                M spatnum	=	spatnum+1
00011310 =00000004                M spal	=	val
00011310                            	spFeedback	$07
00011310 =00000007                M spfe	=	val
00011310                            	spDetune	$00, $00, $00, $00
00011310 =00000000                M spde1	=	op1
00011310 =00000000                M spde2	=	op2
00011310 =00000000                M spde3	=	op3
00011310 =00000000                M spde4	=	op4
00011310                            	spMultiple	$01, $0E, $01, $04
00011310 =00000001                M spmu1	=	op1
00011310 =0000000E                M spmu2	=	op2
00011310 =00000001                M spmu3	=	op3
00011310 =00000004                M spmu4	=	op4
00011310                            	spRateScale	$02, $02, $01, $00
00011310 =00000002                M sprs1	=	op1
00011310 =00000002                M sprs2	=	op2
00011310 =00000001                M sprs3	=	op3
00011310 =00000000                M sprs4	=	op4
00011310                            	spAttackRt	$0D, $1F, $12, $1F
00011310 =0000000D                M spar1	=	op1
00011310 =0000001F                M spar2	=	op2
00011310 =00000012                M spar3	=	op3
00011310 =0000001F                M spar4	=	op4
00011310                            	spAmpMod	$00, $00, $00, $00
00011310 =00000000                M spam1	=	op1
00011310 =00000000                M spam2	=	op2
00011310 =00000000                M spam3	=	op3
00011310 =00000000                M spam4	=	op4
00011310                            	spSustainRt	$09, $00, $00, $0D
00011310 =00000009                M spsr1	=	op1
00011310 =00000000                M spsr2	=	op2
00011310 =00000000                M spsr3	=	op3
00011310 =0000000D                M spsr4	=	op4
00011310                            	spDecayRt	$00, $00, $00, $00
00011310 =00000000                M spdr1	=	op1
00011310 =00000000                M spdr2	=	op2
00011310 =00000000                M spdr3	=	op3
00011310 =00000000                M spdr4	=	op4
00011310                            	spSustainLv	$02, $00, $00, $06
00011310 =00000002                M spsl1	=	op1
00011310 =00000000                M spsl2	=	op2
00011310 =00000000                M spsl3	=	op3
00011310 =00000006                M spsl4	=	op4
00011310                            	spReleaseRt	$03, $02, $08, $0F
00011310 =00000003                M sprr1	=	op1
00011310 =00000002                M sprr2	=	op2
00011310 =00000008                M sprr3	=	op3
00011310 =0000000F                M sprr4	=	op4
00011310                            	spSSGEG		$00, $00, $00, $00
00011310 =00000000                M spss1	=	op1
00011310 =00000000                M spss2	=	op2
00011310 =00000000                M spss3	=	op3
00011310 =00000000                M spss4	=	op4
00011310                            	spTotalLv	$15, $10, $02, $05
00011310 =00000015                M sptl1	=	op1
00011310 =00000010                M sptl2	=	op2
00011310 =00000002                M sptl3	=	op3
00011310 =00000005                M sptl4	=	op4
00011310 3C                       M 	dc.b	(spfe<<3)+spal
00011311 =00000080                M sptlmask4	set	$80
00011311 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011311 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011311 =00000000                M sptlmask1	set	((spal=7)<<7)
00011311 0101 0E04                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011315 8D52 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011319 0900 000D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001131D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011321 2308 026F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011325 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011329 1582 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001132D 4E41 54                  M 	dc.b	'NAT'
00011330                            
00011330                            	; Patch $45
00011330                            	; $04
00011330                            	; $37, $72, $77, $49,	$1F, $1F, $1F, $1F
00011330                            	; $07, $0A, $07, $0D,	$00, $0B, $00, $0B
00011330                            	; $1F, $0F, $1F, $0F,	$23, $00, $23, $00
00011330                            	spAlgorithm	$04
00011330 =00000046                M spatnum	=	spatnum+1
00011330 =00000004                M spal	=	val
00011330                            	spFeedback	$00
00011330 =00000000                M spfe	=	val
00011330                            	spDetune	$03, $07, $07, $04
00011330 =00000003                M spde1	=	op1
00011330 =00000007                M spde2	=	op2
00011330 =00000007                M spde3	=	op3
00011330 =00000004                M spde4	=	op4
00011330                            	spMultiple	$07, $07, $02, $09
00011330 =00000007                M spmu1	=	op1
00011330 =00000007                M spmu2	=	op2
00011330 =00000002                M spmu3	=	op3
00011330 =00000009                M spmu4	=	op4
00011330                            	spRateScale	$00, $00, $00, $00
00011330 =00000000                M sprs1	=	op1
00011330 =00000000                M sprs2	=	op2
00011330 =00000000                M sprs3	=	op3
00011330 =00000000                M sprs4	=	op4
00011330                            	spAttackRt	$1F, $1F, $1F, $1F
00011330 =0000001F                M spar1	=	op1
00011330 =0000001F                M spar2	=	op2
00011330 =0000001F                M spar3	=	op3
00011330 =0000001F                M spar4	=	op4
00011330                            	spAmpMod	$00, $00, $00, $00
00011330 =00000000                M spam1	=	op1
00011330 =00000000                M spam2	=	op2
00011330 =00000000                M spam3	=	op3
00011330 =00000000                M spam4	=	op4
00011330                            	spSustainRt	$07, $07, $0A, $0D
00011330 =00000007                M spsr1	=	op1
00011330 =00000007                M spsr2	=	op2
00011330 =0000000A                M spsr3	=	op3
00011330 =0000000D                M spsr4	=	op4
00011330                            	spDecayRt	$00, $00, $0B, $0B
00011330 =00000000                M spdr1	=	op1
00011330 =00000000                M spdr2	=	op2
00011330 =0000000B                M spdr3	=	op3
00011330 =0000000B                M spdr4	=	op4
00011330                            	spSustainLv	$01, $01, $00, $00
00011330 =00000001                M spsl1	=	op1
00011330 =00000001                M spsl2	=	op2
00011330 =00000000                M spsl3	=	op3
00011330 =00000000                M spsl4	=	op4
00011330                            	spReleaseRt	$0F, $0F, $0F, $0F
00011330 =0000000F                M sprr1	=	op1
00011330 =0000000F                M sprr2	=	op2
00011330 =0000000F                M sprr3	=	op3
00011330 =0000000F                M sprr4	=	op4
00011330                            	spSSGEG		$00, $00, $00, $00
00011330 =00000000                M spss1	=	op1
00011330 =00000000                M spss2	=	op2
00011330 =00000000                M spss3	=	op3
00011330 =00000000                M spss4	=	op4
00011330                            	spTotalLv	$23, $23, $00, $00
00011330 =00000023                M sptl1	=	op1
00011330 =00000023                M sptl2	=	op2
00011330 =00000000                M sptl3	=	op3
00011330 =00000000                M sptl4	=	op4
00011330 04                       M 	dc.b	(spfe<<3)+spal
00011331 =00000080                M sptlmask4	set	$80
00011331 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011331 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011331 =00000000                M sptlmask1	set	((spal=7)<<7)
00011331 3772 7749                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011335 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011339 070A 070D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001133D 000B 000B                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011341 1F0F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011345 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011349 2380 2380                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001134D 4E41 54                  M 	dc.b	'NAT'
00011350                            
00011350                            	; Patch $46
00011350                            	; $3C
00011350                            	; $31, $73, $71, $31,	$10, $8C, $0A, $13
00011350                            	; $00, $00, $00, $00,	$00, $0C, $00, $03
00011350                            	; $0F, $0F, $0F, $0F,	$20, $00, $20, $00
00011350                            	spAlgorithm	$04
00011350 =00000047                M spatnum	=	spatnum+1
00011350 =00000004                M spal	=	val
00011350                            	spFeedback	$07
00011350 =00000007                M spfe	=	val
00011350                            	spDetune	$03, $07, $07, $03
00011350 =00000003                M spde1	=	op1
00011350 =00000007                M spde2	=	op2
00011350 =00000007                M spde3	=	op3
00011350 =00000003                M spde4	=	op4
00011350                            	spMultiple	$01, $01, $03, $01
00011350 =00000001                M spmu1	=	op1
00011350 =00000001                M spmu2	=	op2
00011350 =00000003                M spmu3	=	op3
00011350 =00000001                M spmu4	=	op4
00011350                            	spRateScale	$00, $00, $02, $00
00011350 =00000000                M sprs1	=	op1
00011350 =00000000                M sprs2	=	op2
00011350 =00000002                M sprs3	=	op3
00011350 =00000000                M sprs4	=	op4
00011350                            	spAttackRt	$10, $0A, $0C, $13
00011350 =00000010                M spar1	=	op1
00011350 =0000000A                M spar2	=	op2
00011350 =0000000C                M spar3	=	op3
00011350 =00000013                M spar4	=	op4
00011350                            	spAmpMod	$00, $00, $00, $00
00011350 =00000000                M spam1	=	op1
00011350 =00000000                M spam2	=	op2
00011350 =00000000                M spam3	=	op3
00011350 =00000000                M spam4	=	op4
00011350                            	spSustainRt	$00, $00, $00, $00
00011350 =00000000                M spsr1	=	op1
00011350 =00000000                M spsr2	=	op2
00011350 =00000000                M spsr3	=	op3
00011350 =00000000                M spsr4	=	op4
00011350                            	spDecayRt	$00, $00, $0C, $03
00011350 =00000000                M spdr1	=	op1
00011350 =00000000                M spdr2	=	op2
00011350 =0000000C                M spdr3	=	op3
00011350 =00000003                M spdr4	=	op4
00011350                            	spSustainLv	$00, $00, $00, $00
00011350 =00000000                M spsl1	=	op1
00011350 =00000000                M spsl2	=	op2
00011350 =00000000                M spsl3	=	op3
00011350 =00000000                M spsl4	=	op4
00011350                            	spReleaseRt	$0F, $0F, $0F, $0F
00011350 =0000000F                M sprr1	=	op1
00011350 =0000000F                M sprr2	=	op2
00011350 =0000000F                M sprr3	=	op3
00011350 =0000000F                M sprr4	=	op4
00011350                            	spSSGEG		$00, $00, $00, $00
00011350 =00000000                M spss1	=	op1
00011350 =00000000                M spss2	=	op2
00011350 =00000000                M spss3	=	op3
00011350 =00000000                M spss4	=	op4
00011350                            	spTotalLv	$20, $20, $00, $00
00011350 =00000020                M sptl1	=	op1
00011350 =00000020                M sptl2	=	op2
00011350 =00000000                M sptl3	=	op3
00011350 =00000000                M sptl4	=	op4
00011350 3C                       M 	dc.b	(spfe<<3)+spal
00011351 =00000080                M sptlmask4	set	$80
00011351 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011351 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011351 =00000000                M sptlmask1	set	((spal=7)<<7)
00011351 3173 7131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011355 108C 0A13                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011359 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001135D 000C 0003                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011361 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011365 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011369 2080 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001136D 4E41 54                  M 	dc.b	'NAT'
00011370                            
00011370                            	; Patch $47
00011370                            	; $24
00011370                            	; $00, $04, $01, $04,	$10, $19, $10, $0D
00011370                            	; $00, $03, $00, $00,	$02, $00, $01, $00
00011370                            	; $0A, $0C, $0D, $0C,	$08, $04, $0B, $05
00011370                            	spAlgorithm	$04
00011370 =00000048                M spatnum	=	spatnum+1
00011370 =00000004                M spal	=	val
00011370                            	spFeedback	$04
00011370 =00000004                M spfe	=	val
00011370                            	spDetune	$00, $00, $00, $00
00011370 =00000000                M spde1	=	op1
00011370 =00000000                M spde2	=	op2
00011370 =00000000                M spde3	=	op3
00011370 =00000000                M spde4	=	op4
00011370                            	spMultiple	$00, $01, $04, $04
00011370 =00000000                M spmu1	=	op1
00011370 =00000001                M spmu2	=	op2
00011370 =00000004                M spmu3	=	op3
00011370 =00000004                M spmu4	=	op4
00011370                            	spRateScale	$00, $00, $00, $00
00011370 =00000000                M sprs1	=	op1
00011370 =00000000                M sprs2	=	op2
00011370 =00000000                M sprs3	=	op3
00011370 =00000000                M sprs4	=	op4
00011370                            	spAttackRt	$10, $10, $19, $0D
00011370 =00000010                M spar1	=	op1
00011370 =00000010                M spar2	=	op2
00011370 =00000019                M spar3	=	op3
00011370 =0000000D                M spar4	=	op4
00011370                            	spAmpMod	$00, $00, $00, $00
00011370 =00000000                M spam1	=	op1
00011370 =00000000                M spam2	=	op2
00011370 =00000000                M spam3	=	op3
00011370 =00000000                M spam4	=	op4
00011370                            	spSustainRt	$00, $00, $03, $00
00011370 =00000000                M spsr1	=	op1
00011370 =00000000                M spsr2	=	op2
00011370 =00000003                M spsr3	=	op3
00011370 =00000000                M spsr4	=	op4
00011370                            	spDecayRt	$02, $01, $00, $00
00011370 =00000002                M spdr1	=	op1
00011370 =00000001                M spdr2	=	op2
00011370 =00000000                M spdr3	=	op3
00011370 =00000000                M spdr4	=	op4
00011370                            	spSustainLv	$00, $00, $00, $00
00011370 =00000000                M spsl1	=	op1
00011370 =00000000                M spsl2	=	op2
00011370 =00000000                M spsl3	=	op3
00011370 =00000000                M spsl4	=	op4
00011370                            	spReleaseRt	$0A, $0D, $0C, $0C
00011370 =0000000A                M sprr1	=	op1
00011370 =0000000D                M sprr2	=	op2
00011370 =0000000C                M sprr3	=	op3
00011370 =0000000C                M sprr4	=	op4
00011370                            	spSSGEG		$00, $00, $00, $00
00011370 =00000000                M spss1	=	op1
00011370 =00000000                M spss2	=	op2
00011370 =00000000                M spss3	=	op3
00011370 =00000000                M spss4	=	op4
00011370                            	spTotalLv	$08, $0B, $04, $05
00011370 =00000008                M sptl1	=	op1
00011370 =0000000B                M sptl2	=	op2
00011370 =00000004                M sptl3	=	op3
00011370 =00000005                M sptl4	=	op4
00011370 24                       M 	dc.b	(spfe<<3)+spal
00011371 =00000080                M sptlmask4	set	$80
00011371 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011371 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011371 =00000000                M sptlmask1	set	((spal=7)<<7)
00011371 0004 0104                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011375 1019 100D                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011379 0003 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001137D 0200 0100                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011381 0A0C 0D0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011385 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011389 0884 0B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001138D 4E41 54                  M 	dc.b	'NAT'
00011390                            
00011390                            	; Patch $48
00011390                            	; $22
00011390                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
00011390                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
00011390                            	; $01, $11, $31, $88,	$19, $28, $24, $00
00011390                            	spAlgorithm	$02
00011390 =00000049                M spatnum	=	spatnum+1
00011390 =00000002                M spal	=	val
00011390                            	spFeedback	$04
00011390 =00000004                M spfe	=	val
00011390                            	spDetune	$06, $00, $07, $03
00011390 =00000006                M spde1	=	op1
00011390 =00000000                M spde2	=	op2
00011390 =00000007                M spde3	=	op3
00011390 =00000003                M spde4	=	op4
00011390                            	spMultiple	$01, $04, $0C, $01
00011390 =00000001                M spmu1	=	op1
00011390 =00000004                M spmu2	=	op2
00011390 =0000000C                M spmu3	=	op3
00011390 =00000001                M spmu4	=	op4
00011390                            	spRateScale	$00, $02, $03, $01
00011390 =00000000                M sprs1	=	op1
00011390 =00000002                M sprs2	=	op2
00011390 =00000003                M sprs3	=	op3
00011390 =00000001                M sprs4	=	op4
00011390                            	spAttackRt	$14, $0F, $10, $14
00011390 =00000014                M spar1	=	op1
00011390 =0000000F                M spar2	=	op2
00011390 =00000010                M spar3	=	op3
00011390 =00000014                M spar4	=	op4
00011390                            	spAmpMod	$00, $00, $00, $00
00011390 =00000000                M spam1	=	op1
00011390 =00000000                M spam2	=	op2
00011390 =00000000                M spam3	=	op3
00011390 =00000000                M spam4	=	op4
00011390                            	spSustainRt	$01, $05, $05, $08
00011390 =00000001                M spsr1	=	op1
00011390 =00000005                M spsr2	=	op2
00011390 =00000005                M spsr3	=	op3
00011390 =00000008                M spsr4	=	op4
00011390                            	spDecayRt	$02, $05, $02, $1F
00011390 =00000002                M spdr1	=	op1
00011390 =00000005                M spdr2	=	op2
00011390 =00000002                M spdr3	=	op3
00011390 =0000001F                M spdr4	=	op4
00011390                            	spSustainLv	$00, $03, $01, $08
00011390 =00000000                M spsl1	=	op1
00011390 =00000003                M spsl2	=	op2
00011390 =00000001                M spsl3	=	op3
00011390 =00000008                M spsl4	=	op4
00011390                            	spReleaseRt	$01, $01, $01, $08
00011390 =00000001                M sprr1	=	op1
00011390 =00000001                M sprr2	=	op2
00011390 =00000001                M sprr3	=	op3
00011390 =00000008                M sprr4	=	op4
00011390                            	spSSGEG		$00, $00, $00, $00
00011390 =00000000                M spss1	=	op1
00011390 =00000000                M spss2	=	op2
00011390 =00000000                M spss3	=	op3
00011390 =00000000                M spss4	=	op4
00011390                            	spTotalLv	$19, $24, $28, $00
00011390 =00000019                M sptl1	=	op1
00011390 =00000024                M sptl2	=	op2
00011390 =00000028                M sptl3	=	op3
00011390 =00000000                M sptl4	=	op4
00011390 22                       M 	dc.b	(spfe<<3)+spal
00011391 =00000080                M sptlmask4	set	$80
00011391 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011391 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011391 =00000000                M sptlmask1	set	((spal=7)<<7)
00011391 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011395 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011399 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001139D 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113A1 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113A9 1928 2480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113AD 4E41 54                  M 	dc.b	'NAT'
000113B0                            
000113B0                            	; Patch $49
000113B0                            	; $3B
000113B0                            	; $51, $71, $61, $41,	$51, $16, $18, $1A
000113B0                            	; $05, $01, $01, $00,	$09, $01, $01, $01
000113B0                            	; $17, $97, $27, $87,	$1C, $22, $15, $00
000113B0                            	spAlgorithm	$03
000113B0 =0000004A                M spatnum	=	spatnum+1
000113B0 =00000003                M spal	=	val
000113B0                            	spFeedback	$07
000113B0 =00000007                M spfe	=	val
000113B0                            	spDetune	$05, $06, $07, $04
000113B0 =00000005                M spde1	=	op1
000113B0 =00000006                M spde2	=	op2
000113B0 =00000007                M spde3	=	op3
000113B0 =00000004                M spde4	=	op4
000113B0                            	spMultiple	$01, $01, $01, $01
000113B0 =00000001                M spmu1	=	op1
000113B0 =00000001                M spmu2	=	op2
000113B0 =00000001                M spmu3	=	op3
000113B0 =00000001                M spmu4	=	op4
000113B0                            	spRateScale	$01, $00, $00, $00
000113B0 =00000001                M sprs1	=	op1
000113B0 =00000000                M sprs2	=	op2
000113B0 =00000000                M sprs3	=	op3
000113B0 =00000000                M sprs4	=	op4
000113B0                            	spAttackRt	$11, $18, $16, $1A
000113B0 =00000011                M spar1	=	op1
000113B0 =00000018                M spar2	=	op2
000113B0 =00000016                M spar3	=	op3
000113B0 =0000001A                M spar4	=	op4
000113B0                            	spAmpMod	$00, $00, $00, $00
000113B0 =00000000                M spam1	=	op1
000113B0 =00000000                M spam2	=	op2
000113B0 =00000000                M spam3	=	op3
000113B0 =00000000                M spam4	=	op4
000113B0                            	spSustainRt	$05, $01, $01, $00
000113B0 =00000005                M spsr1	=	op1
000113B0 =00000001                M spsr2	=	op2
000113B0 =00000001                M spsr3	=	op3
000113B0 =00000000                M spsr4	=	op4
000113B0                            	spDecayRt	$09, $01, $01, $01
000113B0 =00000009                M spdr1	=	op1
000113B0 =00000001                M spdr2	=	op2
000113B0 =00000001                M spdr3	=	op3
000113B0 =00000001                M spdr4	=	op4
000113B0                            	spSustainLv	$01, $02, $09, $08
000113B0 =00000001                M spsl1	=	op1
000113B0 =00000002                M spsl2	=	op2
000113B0 =00000009                M spsl3	=	op3
000113B0 =00000008                M spsl4	=	op4
000113B0                            	spReleaseRt	$07, $07, $07, $07
000113B0 =00000007                M sprr1	=	op1
000113B0 =00000007                M sprr2	=	op2
000113B0 =00000007                M sprr3	=	op3
000113B0 =00000007                M sprr4	=	op4
000113B0                            	spSSGEG		$00, $00, $00, $00
000113B0 =00000000                M spss1	=	op1
000113B0 =00000000                M spss2	=	op2
000113B0 =00000000                M spss3	=	op3
000113B0 =00000000                M spss4	=	op4
000113B0                            	spTotalLv	$1C, $15, $22, $00
000113B0 =0000001C                M sptl1	=	op1
000113B0 =00000015                M sptl2	=	op2
000113B0 =00000022                M sptl3	=	op3
000113B0 =00000000                M sptl4	=	op4
000113B0 3B                       M 	dc.b	(spfe<<3)+spal
000113B1 =00000080                M sptlmask4	set	$80
000113B1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000113B1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000113B1 =00000000                M sptlmask1	set	((spal=7)<<7)
000113B1 5171 6141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113B5 5116 181A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113B9 0501 0100                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113BD 0901 0101                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113C1 1797 2787                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113C5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113C9 1C22 1580                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113CD 4E41 54                  M 	dc.b	'NAT'
000113D0                            
000113D0                            	; Patch $4A
000113D0                            	; $32
000113D0                            	; $00, $01, $04, $04,	$1F, $16, $18, $1B
000113D0                            	; $08, $07, $07, $04,	$07, $08, $06, $1F
000113D0                            	; $04, $58, $05, $77,	$06, $05, $15, $00
000113D0                            	spAlgorithm	$02
000113D0 =0000004B                M spatnum	=	spatnum+1
000113D0 =00000002                M spal	=	val
000113D0                            	spFeedback	$06
000113D0 =00000006                M spfe	=	val
000113D0                            	spDetune	$00, $00, $00, $00
000113D0 =00000000                M spde1	=	op1
000113D0 =00000000                M spde2	=	op2
000113D0 =00000000                M spde3	=	op3
000113D0 =00000000                M spde4	=	op4
000113D0                            	spMultiple	$00, $04, $01, $04
000113D0 =00000000                M spmu1	=	op1
000113D0 =00000004                M spmu2	=	op2
000113D0 =00000001                M spmu3	=	op3
000113D0 =00000004                M spmu4	=	op4
000113D0                            	spRateScale	$00, $00, $00, $00
000113D0 =00000000                M sprs1	=	op1
000113D0 =00000000                M sprs2	=	op2
000113D0 =00000000                M sprs3	=	op3
000113D0 =00000000                M sprs4	=	op4
000113D0                            	spAttackRt	$1F, $18, $16, $1B
000113D0 =0000001F                M spar1	=	op1
000113D0 =00000018                M spar2	=	op2
000113D0 =00000016                M spar3	=	op3
000113D0 =0000001B                M spar4	=	op4
000113D0                            	spAmpMod	$00, $00, $00, $00
000113D0 =00000000                M spam1	=	op1
000113D0 =00000000                M spam2	=	op2
000113D0 =00000000                M spam3	=	op3
000113D0 =00000000                M spam4	=	op4
000113D0                            	spSustainRt	$08, $07, $07, $04
000113D0 =00000008                M spsr1	=	op1
000113D0 =00000007                M spsr2	=	op2
000113D0 =00000007                M spsr3	=	op3
000113D0 =00000004                M spsr4	=	op4
000113D0                            	spDecayRt	$07, $06, $08, $1F
000113D0 =00000007                M spdr1	=	op1
000113D0 =00000006                M spdr2	=	op2
000113D0 =00000008                M spdr3	=	op3
000113D0 =0000001F                M spdr4	=	op4
000113D0                            	spSustainLv	$00, $00, $05, $07
000113D0 =00000000                M spsl1	=	op1
000113D0 =00000000                M spsl2	=	op2
000113D0 =00000005                M spsl3	=	op3
000113D0 =00000007                M spsl4	=	op4
000113D0                            	spReleaseRt	$04, $05, $08, $07
000113D0 =00000004                M sprr1	=	op1
000113D0 =00000005                M sprr2	=	op2
000113D0 =00000008                M sprr3	=	op3
000113D0 =00000007                M sprr4	=	op4
000113D0                            	spSSGEG		$00, $00, $00, $00
000113D0 =00000000                M spss1	=	op1
000113D0 =00000000                M spss2	=	op2
000113D0 =00000000                M spss3	=	op3
000113D0 =00000000                M spss4	=	op4
000113D0                            	spTotalLv	$06, $15, $05, $00
000113D0 =00000006                M sptl1	=	op1
000113D0 =00000015                M sptl2	=	op2
000113D0 =00000005                M sptl3	=	op3
000113D0 =00000000                M sptl4	=	op4
000113D0 32                       M 	dc.b	(spfe<<3)+spal
000113D1 =00000080                M sptlmask4	set	$80
000113D1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000113D1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000113D1 =00000000                M sptlmask1	set	((spal=7)<<7)
000113D1 0001 0404                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113D5 1F16 181B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113D9 0807 0704                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113DD 0708 061F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113E1 0458 0577                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113E5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113E9 0605 1580                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113ED 4E41 54                  M 	dc.b	'NAT'
000113F0                            
000113F0                            	; Patch $4B
000113F0                            	; $39
000113F0                            	; $01, $61, $00, $00,	$1F, $5F, $5F, $5F
000113F0                            	; $10, $11, $09, $09,	$1F, $1F, $1E, $1C
000113F0                            	; $FF, $FF, $FF, $FF,	$1C, $22, $1F, $02
000113F0                            	spAlgorithm	$01
000113F0 =0000004C                M spatnum	=	spatnum+1
000113F0 =00000001                M spal	=	val
000113F0                            	spFeedback	$07
000113F0 =00000007                M spfe	=	val
000113F0                            	spDetune	$00, $00, $06, $00
000113F0 =00000000                M spde1	=	op1
000113F0 =00000000                M spde2	=	op2
000113F0 =00000006                M spde3	=	op3
000113F0 =00000000                M spde4	=	op4
000113F0                            	spMultiple	$01, $00, $01, $00
000113F0 =00000001                M spmu1	=	op1
000113F0 =00000000                M spmu2	=	op2
000113F0 =00000001                M spmu3	=	op3
000113F0 =00000000                M spmu4	=	op4
000113F0                            	spRateScale	$00, $01, $01, $01
000113F0 =00000000                M sprs1	=	op1
000113F0 =00000001                M sprs2	=	op2
000113F0 =00000001                M sprs3	=	op3
000113F0 =00000001                M sprs4	=	op4
000113F0                            	spAttackRt	$1F, $1F, $1F, $1F
000113F0 =0000001F                M spar1	=	op1
000113F0 =0000001F                M spar2	=	op2
000113F0 =0000001F                M spar3	=	op3
000113F0 =0000001F                M spar4	=	op4
000113F0                            	spAmpMod	$00, $00, $00, $00
000113F0 =00000000                M spam1	=	op1
000113F0 =00000000                M spam2	=	op2
000113F0 =00000000                M spam3	=	op3
000113F0 =00000000                M spam4	=	op4
000113F0                            	spSustainRt	$10, $09, $11, $09
000113F0 =00000010                M spsr1	=	op1
000113F0 =00000009                M spsr2	=	op2
000113F0 =00000011                M spsr3	=	op3
000113F0 =00000009                M spsr4	=	op4
000113F0                            	spDecayRt	$1F, $1E, $1F, $1C
000113F0 =0000001F                M spdr1	=	op1
000113F0 =0000001E                M spdr2	=	op2
000113F0 =0000001F                M spdr3	=	op3
000113F0 =0000001C                M spdr4	=	op4
000113F0                            	spSustainLv	$0F, $0F, $0F, $0F
000113F0 =0000000F                M spsl1	=	op1
000113F0 =0000000F                M spsl2	=	op2
000113F0 =0000000F                M spsl3	=	op3
000113F0 =0000000F                M spsl4	=	op4
000113F0                            	spReleaseRt	$0F, $0F, $0F, $0F
000113F0 =0000000F                M sprr1	=	op1
000113F0 =0000000F                M sprr2	=	op2
000113F0 =0000000F                M sprr3	=	op3
000113F0 =0000000F                M sprr4	=	op4
000113F0                            	spSSGEG		$00, $00, $00, $00
000113F0 =00000000                M spss1	=	op1
000113F0 =00000000                M spss2	=	op2
000113F0 =00000000                M spss3	=	op3
000113F0 =00000000                M spss4	=	op4
000113F0                            	spTotalLv	$1C, $1F, $22, $02
000113F0 =0000001C                M sptl1	=	op1
000113F0 =0000001F                M sptl2	=	op2
000113F0 =00000022                M sptl3	=	op3
000113F0 =00000002                M sptl4	=	op4
000113F0 39                       M 	dc.b	(spfe<<3)+spal
000113F1 =00000080                M sptlmask4	set	$80
000113F1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000113F1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000113F1 =00000000                M sptlmask1	set	((spal=7)<<7)
000113F1 0161 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113F5 1F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113F9 1011 0909                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113FD 1F1F 1E1C                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011401 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011405 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011409 1C22 1F82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001140D 4E41 54                  M 	dc.b	'NAT'
00011410                            
00011410                            	; Patch $4C
00011410                            	; $27
00011410                            	; $14, $30, $51, $62,	$5C, $5C, $5C, $5C
00011410                            	; $00, $00, $00, $00,	$04, $1B, $04, $04
00011410                            	; $FA, $F8, $F8, $FA,	$08, $08, $08, $08
00011410                            	spAlgorithm	$07
00011410 =0000004D                M spatnum	=	spatnum+1
00011410 =00000007                M spal	=	val
00011410                            	spFeedback	$04
00011410 =00000004                M spfe	=	val
00011410                            	spDetune	$01, $05, $03, $06
00011410 =00000001                M spde1	=	op1
00011410 =00000005                M spde2	=	op2
00011410 =00000003                M spde3	=	op3
00011410 =00000006                M spde4	=	op4
00011410                            	spMultiple	$04, $01, $00, $02
00011410 =00000004                M spmu1	=	op1
00011410 =00000001                M spmu2	=	op2
00011410 =00000000                M spmu3	=	op3
00011410 =00000002                M spmu4	=	op4
00011410                            	spRateScale	$01, $01, $01, $01
00011410 =00000001                M sprs1	=	op1
00011410 =00000001                M sprs2	=	op2
00011410 =00000001                M sprs3	=	op3
00011410 =00000001                M sprs4	=	op4
00011410                            	spAttackRt	$1C, $1C, $1C, $1C
00011410 =0000001C                M spar1	=	op1
00011410 =0000001C                M spar2	=	op2
00011410 =0000001C                M spar3	=	op3
00011410 =0000001C                M spar4	=	op4
00011410                            	spAmpMod	$00, $00, $00, $00
00011410 =00000000                M spam1	=	op1
00011410 =00000000                M spam2	=	op2
00011410 =00000000                M spam3	=	op3
00011410 =00000000                M spam4	=	op4
00011410                            	spSustainRt	$00, $00, $00, $00
00011410 =00000000                M spsr1	=	op1
00011410 =00000000                M spsr2	=	op2
00011410 =00000000                M spsr3	=	op3
00011410 =00000000                M spsr4	=	op4
00011410                            	spDecayRt	$04, $04, $1B, $04
00011410 =00000004                M spdr1	=	op1
00011410 =00000004                M spdr2	=	op2
00011410 =0000001B                M spdr3	=	op3
00011410 =00000004                M spdr4	=	op4
00011410                            	spSustainLv	$0F, $0F, $0F, $0F
00011410 =0000000F                M spsl1	=	op1
00011410 =0000000F                M spsl2	=	op2
00011410 =0000000F                M spsl3	=	op3
00011410 =0000000F                M spsl4	=	op4
00011410                            	spReleaseRt	$0A, $08, $08, $0A
00011410 =0000000A                M sprr1	=	op1
00011410 =00000008                M sprr2	=	op2
00011410 =00000008                M sprr3	=	op3
00011410 =0000000A                M sprr4	=	op4
00011410                            	spSSGEG		$00, $00, $00, $00
00011410 =00000000                M spss1	=	op1
00011410 =00000000                M spss2	=	op2
00011410 =00000000                M spss3	=	op3
00011410 =00000000                M spss4	=	op4
00011410                            	spTotalLv	$08, $08, $08, $08
00011410 =00000008                M sptl1	=	op1
00011410 =00000008                M sptl2	=	op2
00011410 =00000008                M sptl3	=	op3
00011410 =00000008                M sptl4	=	op4
00011410 27                       M 	dc.b	(spfe<<3)+spal
00011411 =00000080                M sptlmask4	set	$80
00011411 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011411 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011411 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
00011411 1430 5162                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011415 5C5C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011419 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001141D 041B 0404                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011421 FAF8 F8FA                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011425 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011429 8888 8888                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001142D 4E41 54                  M 	dc.b	'NAT'
00011430                            
00011430                            	; Patch $4D
00011430                            	; $26
00011430                            	; $01, $02, $01, $00,	$11, $19, $10, $17
00011430                            	; $01, $01, $03, $01,	$07, $04, $03, $03
00011430                            	; $05, $45, $3A, $0A,	$0A, $02, $0E, $00
00011430                            	spAlgorithm	$06
00011430 =0000004E                M spatnum	=	spatnum+1
00011430 =00000006                M spal	=	val
00011430                            	spFeedback	$04
00011430 =00000004                M spfe	=	val
00011430                            	spDetune	$00, $00, $00, $00
00011430 =00000000                M spde1	=	op1
00011430 =00000000                M spde2	=	op2
00011430 =00000000                M spde3	=	op3
00011430 =00000000                M spde4	=	op4
00011430                            	spMultiple	$01, $01, $02, $00
00011430 =00000001                M spmu1	=	op1
00011430 =00000001                M spmu2	=	op2
00011430 =00000002                M spmu3	=	op3
00011430 =00000000                M spmu4	=	op4
00011430                            	spRateScale	$00, $00, $00, $00
00011430 =00000000                M sprs1	=	op1
00011430 =00000000                M sprs2	=	op2
00011430 =00000000                M sprs3	=	op3
00011430 =00000000                M sprs4	=	op4
00011430                            	spAttackRt	$11, $10, $19, $17
00011430 =00000011                M spar1	=	op1
00011430 =00000010                M spar2	=	op2
00011430 =00000019                M spar3	=	op3
00011430 =00000017                M spar4	=	op4
00011430                            	spAmpMod	$00, $00, $00, $00
00011430 =00000000                M spam1	=	op1
00011430 =00000000                M spam2	=	op2
00011430 =00000000                M spam3	=	op3
00011430 =00000000                M spam4	=	op4
00011430                            	spSustainRt	$01, $03, $01, $01
00011430 =00000001                M spsr1	=	op1
00011430 =00000003                M spsr2	=	op2
00011430 =00000001                M spsr3	=	op3
00011430 =00000001                M spsr4	=	op4
00011430                            	spDecayRt	$07, $03, $04, $03
00011430 =00000007                M spdr1	=	op1
00011430 =00000003                M spdr2	=	op2
00011430 =00000004                M spdr3	=	op3
00011430 =00000003                M spdr4	=	op4
00011430                            	spSustainLv	$00, $03, $04, $00
00011430 =00000000                M spsl1	=	op1
00011430 =00000003                M spsl2	=	op2
00011430 =00000004                M spsl3	=	op3
00011430 =00000000                M spsl4	=	op4
00011430                            	spReleaseRt	$05, $0A, $05, $0A
00011430 =00000005                M sprr1	=	op1
00011430 =0000000A                M sprr2	=	op2
00011430 =00000005                M sprr3	=	op3
00011430 =0000000A                M sprr4	=	op4
00011430                            	spSSGEG		$00, $00, $00, $00
00011430 =00000000                M spss1	=	op1
00011430 =00000000                M spss2	=	op2
00011430 =00000000                M spss3	=	op3
00011430 =00000000                M spss4	=	op4
00011430                            	spTotalLv	$0A, $0E, $02, $00
00011430 =0000000A                M sptl1	=	op1
00011430 =0000000E                M sptl2	=	op2
00011430 =00000002                M sptl3	=	op3
00011430 =00000000                M sptl4	=	op4
00011430 26                       M 	dc.b	(spfe<<3)+spal
00011431 =00000080                M sptlmask4	set	$80
00011431 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011431 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011431 =00000000                M sptlmask1	set	((spal=7)<<7)
00011431 0102 0100                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011435 1119 1017                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011439 0101 0301                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001143D 0704 0303                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011441 0545 3A0A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011445 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011449 0A82 8E80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001144D 4E41 54                  M 	dc.b	'NAT'
00011450                            
00011450                            	; Patch $4E
00011450                            	; $32
00011450                            	; $30, $51, $72, $72,	$13, $18, $1F, $1F
00011450                            	; $18, $1E, $1A, $05,	$05, $04, $02, $04
00011450                            	; $25, $D5, $35, $25,	$15, $04, $1C, $00
00011450                            	spAlgorithm	$02
00011450 =0000004F                M spatnum	=	spatnum+1
00011450 =00000002                M spal	=	val
00011450                            	spFeedback	$06
00011450 =00000006                M spfe	=	val
00011450                            	spDetune	$03, $07, $05, $07
00011450 =00000003                M spde1	=	op1
00011450 =00000007                M spde2	=	op2
00011450 =00000005                M spde3	=	op3
00011450 =00000007                M spde4	=	op4
00011450                            	spMultiple	$00, $02, $01, $02
00011450 =00000000                M spmu1	=	op1
00011450 =00000002                M spmu2	=	op2
00011450 =00000001                M spmu3	=	op3
00011450 =00000002                M spmu4	=	op4
00011450                            	spRateScale	$00, $00, $00, $00
00011450 =00000000                M sprs1	=	op1
00011450 =00000000                M sprs2	=	op2
00011450 =00000000                M sprs3	=	op3
00011450 =00000000                M sprs4	=	op4
00011450                            	spAttackRt	$13, $1F, $18, $1F
00011450 =00000013                M spar1	=	op1
00011450 =0000001F                M spar2	=	op2
00011450 =00000018                M spar3	=	op3
00011450 =0000001F                M spar4	=	op4
00011450                            	spAmpMod	$00, $00, $00, $00
00011450 =00000000                M spam1	=	op1
00011450 =00000000                M spam2	=	op2
00011450 =00000000                M spam3	=	op3
00011450 =00000000                M spam4	=	op4
00011450                            	spSustainRt	$18, $1A, $1E, $05
00011450 =00000018                M spsr1	=	op1
00011450 =0000001A                M spsr2	=	op2
00011450 =0000001E                M spsr3	=	op3
00011450 =00000005                M spsr4	=	op4
00011450                            	spDecayRt	$05, $02, $04, $04
00011450 =00000005                M spdr1	=	op1
00011450 =00000002                M spdr2	=	op2
00011450 =00000004                M spdr3	=	op3
00011450 =00000004                M spdr4	=	op4
00011450                            	spSustainLv	$02, $03, $0D, $02
00011450 =00000002                M spsl1	=	op1
00011450 =00000003                M spsl2	=	op2
00011450 =0000000D                M spsl3	=	op3
00011450 =00000002                M spsl4	=	op4
00011450                            	spReleaseRt	$05, $05, $05, $05
00011450 =00000005                M sprr1	=	op1
00011450 =00000005                M sprr2	=	op2
00011450 =00000005                M sprr3	=	op3
00011450 =00000005                M sprr4	=	op4
00011450                            	spSSGEG		$00, $00, $00, $00
00011450 =00000000                M spss1	=	op1
00011450 =00000000                M spss2	=	op2
00011450 =00000000                M spss3	=	op3
00011450 =00000000                M spss4	=	op4
00011450                            	spTotalLv	$15, $1C, $04, $00
00011450 =00000015                M sptl1	=	op1
00011450 =0000001C                M sptl2	=	op2
00011450 =00000004                M sptl3	=	op3
00011450 =00000000                M sptl4	=	op4
00011450 32                       M 	dc.b	(spfe<<3)+spal
00011451 =00000080                M sptlmask4	set	$80
00011451 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011451 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011451 =00000000                M sptlmask1	set	((spal=7)<<7)
00011451 3051 7272                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011455 1318 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011459 181E 1A05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001145D 0504 0204                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011461 25D5 3525                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011465 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011469 1504 1C80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001146D 4E41 54                  M 	dc.b	'NAT'
00011470                            
00011470                            	; Patch $4F
00011470                            	; $3E
00011470                            	; $38, $01, $7A, $34,	$59, $D9, $5F, $9C
00011470                            	; $0F, $04, $0F, $0A,	$02, $02, $05, $05
00011470                            	; $AF, $AF, $66, $66,	$28, $00, $23, $00
00011470                            	spAlgorithm	$06
00011470 =00000050                M spatnum	=	spatnum+1
00011470 =00000006                M spal	=	val
00011470                            	spFeedback	$07
00011470 =00000007                M spfe	=	val
00011470                            	spDetune	$03, $07, $00, $03
00011470 =00000003                M spde1	=	op1
00011470 =00000007                M spde2	=	op2
00011470 =00000000                M spde3	=	op3
00011470 =00000003                M spde4	=	op4
00011470                            	spMultiple	$08, $0A, $01, $04
00011470 =00000008                M spmu1	=	op1
00011470 =0000000A                M spmu2	=	op2
00011470 =00000001                M spmu3	=	op3
00011470 =00000004                M spmu4	=	op4
00011470                            	spRateScale	$01, $01, $03, $02
00011470 =00000001                M sprs1	=	op1
00011470 =00000001                M sprs2	=	op2
00011470 =00000003                M sprs3	=	op3
00011470 =00000002                M sprs4	=	op4
00011470                            	spAttackRt	$19, $1F, $19, $1C
00011470 =00000019                M spar1	=	op1
00011470 =0000001F                M spar2	=	op2
00011470 =00000019                M spar3	=	op3
00011470 =0000001C                M spar4	=	op4
00011470                            	spAmpMod	$00, $00, $00, $00
00011470 =00000000                M spam1	=	op1
00011470 =00000000                M spam2	=	op2
00011470 =00000000                M spam3	=	op3
00011470 =00000000                M spam4	=	op4
00011470                            	spSustainRt	$0F, $0F, $04, $0A
00011470 =0000000F                M spsr1	=	op1
00011470 =0000000F                M spsr2	=	op2
00011470 =00000004                M spsr3	=	op3
00011470 =0000000A                M spsr4	=	op4
00011470                            	spDecayRt	$02, $05, $02, $05
00011470 =00000002                M spdr1	=	op1
00011470 =00000005                M spdr2	=	op2
00011470 =00000002                M spdr3	=	op3
00011470 =00000005                M spdr4	=	op4
00011470                            	spSustainLv	$0A, $06, $0A, $06
00011470 =0000000A                M spsl1	=	op1
00011470 =00000006                M spsl2	=	op2
00011470 =0000000A                M spsl3	=	op3
00011470 =00000006                M spsl4	=	op4
00011470                            	spReleaseRt	$0F, $06, $0F, $06
00011470 =0000000F                M sprr1	=	op1
00011470 =00000006                M sprr2	=	op2
00011470 =0000000F                M sprr3	=	op3
00011470 =00000006                M sprr4	=	op4
00011470                            	spSSGEG		$00, $00, $00, $00
00011470 =00000000                M spss1	=	op1
00011470 =00000000                M spss2	=	op2
00011470 =00000000                M spss3	=	op3
00011470 =00000000                M spss4	=	op4
00011470                            	spTotalLv	$28, $23, $00, $00
00011470 =00000028                M sptl1	=	op1
00011470 =00000023                M sptl2	=	op2
00011470 =00000000                M sptl3	=	op3
00011470 =00000000                M sptl4	=	op4
00011470 3E                       M 	dc.b	(spfe<<3)+spal
00011471 =00000080                M sptlmask4	set	$80
00011471 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011471 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011471 =00000000                M sptlmask1	set	((spal=7)<<7)
00011471 3801 7A34                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011475 59D9 5F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011479 0F04 0F0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001147D 0202 0505                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011481 AFAF 6666                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011485 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011489 2880 A380                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001148D 4E41 54                  M 	dc.b	'NAT'
00011490                            
00011490                            	; Patch $50
00011490                            	; $3A
00011490                            	; $31, $37, $72, $02,	$0F, $0B, $0B, $8B
00011490                            	; $04, $10, $09, $0A,	$00, $00, $03, $00
00011490                            	; $19, $08, $08, $18,	$1E, $21, $37, $00
00011490                            	spAlgorithm	$02
00011490 =00000051                M spatnum	=	spatnum+1
00011490 =00000002                M spal	=	val
00011490                            	spFeedback	$07
00011490 =00000007                M spfe	=	val
00011490                            	spDetune	$03, $07, $03, $00
00011490 =00000003                M spde1	=	op1
00011490 =00000007                M spde2	=	op2
00011490 =00000003                M spde3	=	op3
00011490 =00000000                M spde4	=	op4
00011490                            	spMultiple	$01, $02, $07, $02
00011490 =00000001                M spmu1	=	op1
00011490 =00000002                M spmu2	=	op2
00011490 =00000007                M spmu3	=	op3
00011490 =00000002                M spmu4	=	op4
00011490                            	spRateScale	$00, $00, $00, $02
00011490 =00000000                M sprs1	=	op1
00011490 =00000000                M sprs2	=	op2
00011490 =00000000                M sprs3	=	op3
00011490 =00000002                M sprs4	=	op4
00011490                            	spAttackRt	$0F, $0B, $0B, $0B
00011490 =0000000F                M spar1	=	op1
00011490 =0000000B                M spar2	=	op2
00011490 =0000000B                M spar3	=	op3
00011490 =0000000B                M spar4	=	op4
00011490                            	spAmpMod	$00, $00, $00, $00
00011490 =00000000                M spam1	=	op1
00011490 =00000000                M spam2	=	op2
00011490 =00000000                M spam3	=	op3
00011490 =00000000                M spam4	=	op4
00011490                            	spSustainRt	$04, $09, $10, $0A
00011490 =00000004                M spsr1	=	op1
00011490 =00000009                M spsr2	=	op2
00011490 =00000010                M spsr3	=	op3
00011490 =0000000A                M spsr4	=	op4
00011490                            	spDecayRt	$00, $03, $00, $00
00011490 =00000000                M spdr1	=	op1
00011490 =00000003                M spdr2	=	op2
00011490 =00000000                M spdr3	=	op3
00011490 =00000000                M spdr4	=	op4
00011490                            	spSustainLv	$01, $00, $00, $01
00011490 =00000001                M spsl1	=	op1
00011490 =00000000                M spsl2	=	op2
00011490 =00000000                M spsl3	=	op3
00011490 =00000001                M spsl4	=	op4
00011490                            	spReleaseRt	$09, $08, $08, $08
00011490 =00000009                M sprr1	=	op1
00011490 =00000008                M sprr2	=	op2
00011490 =00000008                M sprr3	=	op3
00011490 =00000008                M sprr4	=	op4
00011490                            	spSSGEG		$00, $00, $00, $00
00011490 =00000000                M spss1	=	op1
00011490 =00000000                M spss2	=	op2
00011490 =00000000                M spss3	=	op3
00011490 =00000000                M spss4	=	op4
00011490                            	spTotalLv	$1E, $37, $21, $00
00011490 =0000001E                M sptl1	=	op1
00011490 =00000037                M sptl2	=	op2
00011490 =00000021                M sptl3	=	op3
00011490 =00000000                M sptl4	=	op4
00011490 3A                       M 	dc.b	(spfe<<3)+spal
00011491 =00000080                M sptlmask4	set	$80
00011491 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011491 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011491 =00000000                M sptlmask1	set	((spal=7)<<7)
00011491 3137 7202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011495 0F0B 0B8B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011499 0410 090A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001149D 0000 0300                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114A1 1908 0818                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114A9 1E21 3780                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114AD 4E41 54                  M 	dc.b	'NAT'
000114B0                            
000114B0                            	; Patch $51
000114B0                            	; $3D
000114B0                            	; $0A, $06, $06, $06,	$1F, $0C, $0C, $0C
000114B0                            	; $00, $09, $09, $01,	$01, $02, $05, $01
000114B0                            	; $F6, $F8, $F7, $F7,	$00, $00, $00, $00
000114B0                            	spAlgorithm	$05
000114B0 =00000052                M spatnum	=	spatnum+1
000114B0 =00000005                M spal	=	val
000114B0                            	spFeedback	$07
000114B0 =00000007                M spfe	=	val
000114B0                            	spDetune	$00, $00, $00, $00
000114B0 =00000000                M spde1	=	op1
000114B0 =00000000                M spde2	=	op2
000114B0 =00000000                M spde3	=	op3
000114B0 =00000000                M spde4	=	op4
000114B0                            	spMultiple	$0A, $06, $06, $06
000114B0 =0000000A                M spmu1	=	op1
000114B0 =00000006                M spmu2	=	op2
000114B0 =00000006                M spmu3	=	op3
000114B0 =00000006                M spmu4	=	op4
000114B0                            	spRateScale	$00, $00, $00, $00
000114B0 =00000000                M sprs1	=	op1
000114B0 =00000000                M sprs2	=	op2
000114B0 =00000000                M sprs3	=	op3
000114B0 =00000000                M sprs4	=	op4
000114B0                            	spAttackRt	$1F, $0C, $0C, $0C
000114B0 =0000001F                M spar1	=	op1
000114B0 =0000000C                M spar2	=	op2
000114B0 =0000000C                M spar3	=	op3
000114B0 =0000000C                M spar4	=	op4
000114B0                            	spAmpMod	$00, $00, $00, $00
000114B0 =00000000                M spam1	=	op1
000114B0 =00000000                M spam2	=	op2
000114B0 =00000000                M spam3	=	op3
000114B0 =00000000                M spam4	=	op4
000114B0                            	spSustainRt	$00, $09, $09, $01
000114B0 =00000000                M spsr1	=	op1
000114B0 =00000009                M spsr2	=	op2
000114B0 =00000009                M spsr3	=	op3
000114B0 =00000001                M spsr4	=	op4
000114B0                            	spSustainLv	$0F, $0F, $0F, $0F
000114B0 =0000000F                M spsl1	=	op1
000114B0 =0000000F                M spsl2	=	op2
000114B0 =0000000F                M spsl3	=	op3
000114B0 =0000000F                M spsl4	=	op4
000114B0                            	spDecayRt	$01, $05, $02, $01
000114B0 =00000001                M spdr1	=	op1
000114B0 =00000005                M spdr2	=	op2
000114B0 =00000002                M spdr3	=	op3
000114B0 =00000001                M spdr4	=	op4
000114B0                            	spReleaseRt	$06, $07, $08, $07
000114B0 =00000006                M sprr1	=	op1
000114B0 =00000007                M sprr2	=	op2
000114B0 =00000008                M sprr3	=	op3
000114B0 =00000007                M sprr4	=	op4
000114B0                            	spSSGEG		$00, $00, $00, $00
000114B0 =00000000                M spss1	=	op1
000114B0 =00000000                M spss2	=	op2
000114B0 =00000000                M spss3	=	op3
000114B0 =00000000                M spss4	=	op4
000114B0                            	spTotalLv	$00, $00, $00, $00
000114B0 =00000000                M sptl1	=	op1
000114B0 =00000000                M sptl2	=	op2
000114B0 =00000000                M sptl3	=	op3
000114B0 =00000000                M sptl4	=	op4
000114B0 3D                       M 	dc.b	(spfe<<3)+spal
000114B1 =00000080                M sptlmask4	set	$80
000114B1 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000114B1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000114B1 =00000000                M sptlmask1	set	((spal=7)<<7)
000114B1 0A06 0606                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114B5 1F0C 0C0C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114B9 0009 0901                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114BD 0102 0501                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114C1 F6F8 F7F7                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114C5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114C9 0080 8080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114CD 4E41 54                  M 	dc.b	'NAT'
000114D0                            
000114D0                            	; Patch $52
000114D0                            	; $3C
000114D0                            	; $31, $73, $71, $31,	$10, $8C, $0A, $13
000114D0                            	; $00, $00, $00, $00,	$00, $0C, $00, $03
000114D0                            	; $0F, $0F, $0F, $0F,	$20, $00, $20, $00
000114D0                            	spAlgorithm	$04
000114D0 =00000053                M spatnum	=	spatnum+1
000114D0 =00000004                M spal	=	val
000114D0                            	spFeedback	$07
000114D0 =00000007                M spfe	=	val
000114D0                            	spDetune	$03, $07, $07, $03
000114D0 =00000003                M spde1	=	op1
000114D0 =00000007                M spde2	=	op2
000114D0 =00000007                M spde3	=	op3
000114D0 =00000003                M spde4	=	op4
000114D0                            	spMultiple	$01, $01, $03, $01
000114D0 =00000001                M spmu1	=	op1
000114D0 =00000001                M spmu2	=	op2
000114D0 =00000003                M spmu3	=	op3
000114D0 =00000001                M spmu4	=	op4
000114D0                            	spRateScale	$00, $00, $02, $00
000114D0 =00000000                M sprs1	=	op1
000114D0 =00000000                M sprs2	=	op2
000114D0 =00000002                M sprs3	=	op3
000114D0 =00000000                M sprs4	=	op4
000114D0                            	spAttackRt	$10, $0A, $0C, $13
000114D0 =00000010                M spar1	=	op1
000114D0 =0000000A                M spar2	=	op2
000114D0 =0000000C                M spar3	=	op3
000114D0 =00000013                M spar4	=	op4
000114D0                            	spAmpMod	$00, $00, $00, $00
000114D0 =00000000                M spam1	=	op1
000114D0 =00000000                M spam2	=	op2
000114D0 =00000000                M spam3	=	op3
000114D0 =00000000                M spam4	=	op4
000114D0                            	spSustainRt	$00, $00, $00, $00
000114D0 =00000000                M spsr1	=	op1
000114D0 =00000000                M spsr2	=	op2
000114D0 =00000000                M spsr3	=	op3
000114D0 =00000000                M spsr4	=	op4
000114D0                            	spSustainLv	$00, $00, $00, $00
000114D0 =00000000                M spsl1	=	op1
000114D0 =00000000                M spsl2	=	op2
000114D0 =00000000                M spsl3	=	op3
000114D0 =00000000                M spsl4	=	op4
000114D0                            	spDecayRt	$00, $00, $0C, $03
000114D0 =00000000                M spdr1	=	op1
000114D0 =00000000                M spdr2	=	op2
000114D0 =0000000C                M spdr3	=	op3
000114D0 =00000003                M spdr4	=	op4
000114D0                            	spReleaseRt	$0F, $0F, $0F, $0F
000114D0 =0000000F                M sprr1	=	op1
000114D0 =0000000F                M sprr2	=	op2
000114D0 =0000000F                M sprr3	=	op3
000114D0 =0000000F                M sprr4	=	op4
000114D0                            	spSSGEG		$00, $00, $00, $00
000114D0 =00000000                M spss1	=	op1
000114D0 =00000000                M spss2	=	op2
000114D0 =00000000                M spss3	=	op3
000114D0 =00000000                M spss4	=	op4
000114D0                            	spTotalLv	$20, $20, $00, $00
000114D0 =00000020                M sptl1	=	op1
000114D0 =00000020                M sptl2	=	op2
000114D0 =00000000                M sptl3	=	op3
000114D0 =00000000                M sptl4	=	op4
000114D0 3C                       M 	dc.b	(spfe<<3)+spal
000114D1 =00000080                M sptlmask4	set	$80
000114D1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000114D1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000114D1 =00000000                M sptlmask1	set	((spal=7)<<7)
000114D1 3173 7131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114D5 108C 0A13                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114D9 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114DD 000C 0003                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114E1 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114E5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114E9 2080 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114ED 4E41 54                  M 	dc.b	'NAT'
000114F0                            
000114F0                            	; Patch $53
000114F0                            	; $3C
000114F0                            	; $33, $41, $7F, $74,	$5B, $9F, $5F, $1F
000114F0                            	; $04, $07, $07, $08,	$00, $00, $00, $00
000114F0                            	; $A7, $C6, $C9, $D9,	$21, $00, $2D, $06
000114F0                            	spAlgorithm	$04
000114F0 =00000054                M spatnum	=	spatnum+1
000114F0 =00000004                M spal	=	val
000114F0                            	spFeedback	$07
000114F0 =00000007                M spfe	=	val
000114F0                            	spDetune	$03, $07, $04, $07
000114F0 =00000003                M spde1	=	op1
000114F0 =00000007                M spde2	=	op2
000114F0 =00000004                M spde3	=	op3
000114F0 =00000007                M spde4	=	op4
000114F0                            	spMultiple	$03, $0F, $01, $04
000114F0 =00000003                M spmu1	=	op1
000114F0 =0000000F                M spmu2	=	op2
000114F0 =00000001                M spmu3	=	op3
000114F0 =00000004                M spmu4	=	op4
000114F0                            	spRateScale	$01, $01, $02, $00
000114F0 =00000001                M sprs1	=	op1
000114F0 =00000001                M sprs2	=	op2
000114F0 =00000002                M sprs3	=	op3
000114F0 =00000000                M sprs4	=	op4
000114F0                            	spAttackRt	$1B, $1F, $1F, $1F
000114F0 =0000001B                M spar1	=	op1
000114F0 =0000001F                M spar2	=	op2
000114F0 =0000001F                M spar3	=	op3
000114F0 =0000001F                M spar4	=	op4
000114F0                            	spAmpMod	$00, $00, $00, $00
000114F0 =00000000                M spam1	=	op1
000114F0 =00000000                M spam2	=	op2
000114F0 =00000000                M spam3	=	op3
000114F0 =00000000                M spam4	=	op4
000114F0                            	spSustainRt	$04, $07, $07, $08
000114F0 =00000004                M spsr1	=	op1
000114F0 =00000007                M spsr2	=	op2
000114F0 =00000007                M spsr3	=	op3
000114F0 =00000008                M spsr4	=	op4
000114F0                            	spSustainLv	$0A, $0C, $0C, $0D
000114F0 =0000000A                M spsl1	=	op1
000114F0 =0000000C                M spsl2	=	op2
000114F0 =0000000C                M spsl3	=	op3
000114F0 =0000000D                M spsl4	=	op4
000114F0                            	spDecayRt	$00, $00, $00, $00
000114F0 =00000000                M spdr1	=	op1
000114F0 =00000000                M spdr2	=	op2
000114F0 =00000000                M spdr3	=	op3
000114F0 =00000000                M spdr4	=	op4
000114F0                            	spReleaseRt	$07, $09, $06, $09
000114F0 =00000007                M sprr1	=	op1
000114F0 =00000009                M sprr2	=	op2
000114F0 =00000006                M sprr3	=	op3
000114F0 =00000009                M sprr4	=	op4
000114F0                            	spSSGEG		$00, $00, $00, $00
000114F0 =00000000                M spss1	=	op1
000114F0 =00000000                M spss2	=	op2
000114F0 =00000000                M spss3	=	op3
000114F0 =00000000                M spss4	=	op4
000114F0                            	spTotalLv	$21, $2D, $00, $06
000114F0 =00000021                M sptl1	=	op1
000114F0 =0000002D                M sptl2	=	op2
000114F0 =00000000                M sptl3	=	op3
000114F0 =00000006                M sptl4	=	op4
000114F0 3C                       M 	dc.b	(spfe<<3)+spal
000114F1 =00000080                M sptlmask4	set	$80
000114F1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000114F1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000114F1 =00000000                M sptlmask1	set	((spal=7)<<7)
000114F1 3341 7F74                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114F5 5B9F 5F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114F9 0407 0708                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114FD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011501 A7C6 C9D9                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011505 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011509 2180 2D86                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001150D 4E41 54                  M 	dc.b	'NAT'
00011510                            
00011510                            	; Patch $54
00011510                            	; $22
00011510                            	; $61, $77, $02, $31,	$14, $D0, $8F, $54
00011510                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
00011510                            	; $01, $11, $31, $88,	$19, $28, $20, $00
00011510                            	spAlgorithm	$02
00011510 =00000055                M spatnum	=	spatnum+1
00011510 =00000002                M spal	=	val
00011510                            	spFeedback	$04
00011510 =00000004                M spfe	=	val
00011510                            	spDetune	$06, $00, $07, $03
00011510 =00000006                M spde1	=	op1
00011510 =00000000                M spde2	=	op2
00011510 =00000007                M spde3	=	op3
00011510 =00000003                M spde4	=	op4
00011510                            	spMultiple	$01, $02, $07, $01
00011510 =00000001                M spmu1	=	op1
00011510 =00000002                M spmu2	=	op2
00011510 =00000007                M spmu3	=	op3
00011510 =00000001                M spmu4	=	op4
00011510                            	spRateScale	$00, $02, $03, $01
00011510 =00000000                M sprs1	=	op1
00011510 =00000002                M sprs2	=	op2
00011510 =00000003                M sprs3	=	op3
00011510 =00000001                M sprs4	=	op4
00011510                            	spAttackRt	$14, $0F, $10, $14
00011510 =00000014                M spar1	=	op1
00011510 =0000000F                M spar2	=	op2
00011510 =00000010                M spar3	=	op3
00011510 =00000014                M spar4	=	op4
00011510                            	spAmpMod	$00, $00, $00, $00
00011510 =00000000                M spam1	=	op1
00011510 =00000000                M spam2	=	op2
00011510 =00000000                M spam3	=	op3
00011510 =00000000                M spam4	=	op4
00011510                            	spSustainRt	$01, $05, $05, $08
00011510 =00000001                M spsr1	=	op1
00011510 =00000005                M spsr2	=	op2
00011510 =00000005                M spsr3	=	op3
00011510 =00000008                M spsr4	=	op4
00011510                            	spSustainLv	$00, $03, $01, $08
00011510 =00000000                M spsl1	=	op1
00011510 =00000003                M spsl2	=	op2
00011510 =00000001                M spsl3	=	op3
00011510 =00000008                M spsl4	=	op4
00011510                            	spDecayRt	$02, $05, $02, $1F
00011510 =00000002                M spdr1	=	op1
00011510 =00000005                M spdr2	=	op2
00011510 =00000002                M spdr3	=	op3
00011510 =0000001F                M spdr4	=	op4
00011510                            	spReleaseRt	$01, $01, $01, $08
00011510 =00000001                M sprr1	=	op1
00011510 =00000001                M sprr2	=	op2
00011510 =00000001                M sprr3	=	op3
00011510 =00000008                M sprr4	=	op4
00011510                            	spSSGEG		$00, $00, $00, $00
00011510 =00000000                M spss1	=	op1
00011510 =00000000                M spss2	=	op2
00011510 =00000000                M spss3	=	op3
00011510 =00000000                M spss4	=	op4
00011510                            	spTotalLv	$19, $20, $28, $00
00011510 =00000019                M sptl1	=	op1
00011510 =00000020                M sptl2	=	op2
00011510 =00000028                M sptl3	=	op3
00011510 =00000000                M sptl4	=	op4
00011510 22                       M 	dc.b	(spfe<<3)+spal
00011511 =00000080                M sptlmask4	set	$80
00011511 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011511 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011511 =00000000                M sptlmask1	set	((spal=7)<<7)
00011511 6177 0231                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011515 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011519 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001151D 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011521 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011525 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011529 1928 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001152D 4E41 54                  M 	dc.b	'NAT'
00011530                            
00011530                            	; Patch $55
00011530                            	; $22
00011530                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
00011530                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
00011530                            	; $01, $11, $31, $88,	$19, $28, $24, $00
00011530                            	spAlgorithm	$02
00011530 =00000056                M spatnum	=	spatnum+1
00011530 =00000002                M spal	=	val
00011530                            	spFeedback	$04
00011530 =00000004                M spfe	=	val
00011530                            	spDetune	$06, $00, $07, $03
00011530 =00000006                M spde1	=	op1
00011530 =00000000                M spde2	=	op2
00011530 =00000007                M spde3	=	op3
00011530 =00000003                M spde4	=	op4
00011530                            	spMultiple	$01, $04, $0C, $01
00011530 =00000001                M spmu1	=	op1
00011530 =00000004                M spmu2	=	op2
00011530 =0000000C                M spmu3	=	op3
00011530 =00000001                M spmu4	=	op4
00011530                            	spRateScale	$00, $02, $03, $01
00011530 =00000000                M sprs1	=	op1
00011530 =00000002                M sprs2	=	op2
00011530 =00000003                M sprs3	=	op3
00011530 =00000001                M sprs4	=	op4
00011530                            	spAttackRt	$14, $0F, $10, $14
00011530 =00000014                M spar1	=	op1
00011530 =0000000F                M spar2	=	op2
00011530 =00000010                M spar3	=	op3
00011530 =00000014                M spar4	=	op4
00011530                            	spAmpMod	$00, $00, $00, $00
00011530 =00000000                M spam1	=	op1
00011530 =00000000                M spam2	=	op2
00011530 =00000000                M spam3	=	op3
00011530 =00000000                M spam4	=	op4
00011530                            	spSustainRt	$01, $05, $05, $08
00011530 =00000001                M spsr1	=	op1
00011530 =00000005                M spsr2	=	op2
00011530 =00000005                M spsr3	=	op3
00011530 =00000008                M spsr4	=	op4
00011530                            	spSustainLv	$00, $03, $01, $08
00011530 =00000000                M spsl1	=	op1
00011530 =00000003                M spsl2	=	op2
00011530 =00000001                M spsl3	=	op3
00011530 =00000008                M spsl4	=	op4
00011530                            	spDecayRt	$02, $05, $02, $1F
00011530 =00000002                M spdr1	=	op1
00011530 =00000005                M spdr2	=	op2
00011530 =00000002                M spdr3	=	op3
00011530 =0000001F                M spdr4	=	op4
00011530                            	spReleaseRt	$01, $01, $01, $08
00011530 =00000001                M sprr1	=	op1
00011530 =00000001                M sprr2	=	op2
00011530 =00000001                M sprr3	=	op3
00011530 =00000008                M sprr4	=	op4
00011530                            	spSSGEG		$00, $00, $00, $00
00011530 =00000000                M spss1	=	op1
00011530 =00000000                M spss2	=	op2
00011530 =00000000                M spss3	=	op3
00011530 =00000000                M spss4	=	op4
00011530                            	spTotalLv	$19, $24, $28, $00
00011530 =00000019                M sptl1	=	op1
00011530 =00000024                M sptl2	=	op2
00011530 =00000028                M sptl3	=	op3
00011530 =00000000                M sptl4	=	op4
00011530 22                       M 	dc.b	(spfe<<3)+spal
00011531 =00000080                M sptlmask4	set	$80
00011531 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011531 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011531 =00000000                M sptlmask1	set	((spal=7)<<7)
00011531 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011535 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011539 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001153D 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011541 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011545 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011549 1928 2480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001154D 4E41 54                  M 	dc.b	'NAT'
00011550                            
00011550                            	; Patch $56
00011550                            	; $20
00011550                            	; $66, $65, $60, $61,	$DF, $DF, $9F, $9F
00011550                            	; $07, $06, $09, $06,	$07, $06, $06, $08
00011550                            	; $29, $19, $19, $F9,	$1C, $3A, $16, $00
00011550                            	spAlgorithm	$00
00011550 =00000057                M spatnum	=	spatnum+1
00011550 =00000000                M spal	=	val
00011550                            	spFeedback	$04
00011550 =00000004                M spfe	=	val
00011550                            	spDetune	$06, $06, $06, $06
00011550 =00000006                M spde1	=	op1
00011550 =00000006                M spde2	=	op2
00011550 =00000006                M spde3	=	op3
00011550 =00000006                M spde4	=	op4
00011550                            	spMultiple	$06, $00, $05, $01
00011550 =00000006                M spmu1	=	op1
00011550 =00000000                M spmu2	=	op2
00011550 =00000005                M spmu3	=	op3
00011550 =00000001                M spmu4	=	op4
00011550                            	spRateScale	$03, $02, $03, $02
00011550 =00000003                M sprs1	=	op1
00011550 =00000002                M sprs2	=	op2
00011550 =00000003                M sprs3	=	op3
00011550 =00000002                M sprs4	=	op4
00011550                            	spAttackRt	$1F, $1F, $1F, $1F
00011550 =0000001F                M spar1	=	op1
00011550 =0000001F                M spar2	=	op2
00011550 =0000001F                M spar3	=	op3
00011550 =0000001F                M spar4	=	op4
00011550                            	spAmpMod	$00, $00, $00, $00
00011550 =00000000                M spam1	=	op1
00011550 =00000000                M spam2	=	op2
00011550 =00000000                M spam3	=	op3
00011550 =00000000                M spam4	=	op4
00011550                            	spSustainRt	$07, $09, $06, $06
00011550 =00000007                M spsr1	=	op1
00011550 =00000009                M spsr2	=	op2
00011550 =00000006                M spsr3	=	op3
00011550 =00000006                M spsr4	=	op4
00011550                            	spDecayRt	$07, $06, $06, $08
00011550 =00000007                M spdr1	=	op1
00011550 =00000006                M spdr2	=	op2
00011550 =00000006                M spdr3	=	op3
00011550 =00000008                M spdr4	=	op4
00011550                            	spSustainLv	$02, $01, $01, $0F
00011550 =00000002                M spsl1	=	op1
00011550 =00000001                M spsl2	=	op2
00011550 =00000001                M spsl3	=	op3
00011550 =0000000F                M spsl4	=	op4
00011550                            	spReleaseRt	$09, $09, $09, $09
00011550 =00000009                M sprr1	=	op1
00011550 =00000009                M sprr2	=	op2
00011550 =00000009                M sprr3	=	op3
00011550 =00000009                M sprr4	=	op4
00011550                            	spSSGEG		$00, $00, $00, $00
00011550 =00000000                M spss1	=	op1
00011550 =00000000                M spss2	=	op2
00011550 =00000000                M spss3	=	op3
00011550 =00000000                M spss4	=	op4
00011550                            	spTotalLv	$1C, $16, $3A, $00
00011550 =0000001C                M sptl1	=	op1
00011550 =00000016                M sptl2	=	op2
00011550 =0000003A                M sptl3	=	op3
00011550 =00000000                M sptl4	=	op4
00011550 20                       M 	dc.b	(spfe<<3)+spal
00011551 =00000080                M sptlmask4	set	$80
00011551 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011551 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011551 =00000000                M sptlmask1	set	((spal=7)<<7)
00011551 6665 6061                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011555 DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011559 0706 0906                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001155D 0706 0608                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011561 2919 19F9                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011565 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011569 1C3A 1680                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001156D 4E41 54                  M 	dc.b	'NAT'
00011570                            
00011570                            	; Patch $57
00011570                            	; $3A
00011570                            	; $31, $01, $01, $71,	$8F, $8F, $4F, $4D
00011570                            	; $09, $09, $00, $03,	$00, $00, $00, $00
00011570                            	; $15, $F5, $05, $0A,	$19, $1F, $19, $01
00011570                            	spAlgorithm	$02
00011570 =00000058                M spatnum	=	spatnum+1
00011570 =00000002                M spal	=	val
00011570                            	spFeedback	$07
00011570 =00000007                M spfe	=	val
00011570                            	spDetune	$03, $00, $00, $07
00011570 =00000003                M spde1	=	op1
00011570 =00000000                M spde2	=	op2
00011570 =00000000                M spde3	=	op3
00011570 =00000007                M spde4	=	op4
00011570                            	spMultiple	$01, $01, $01, $01
00011570 =00000001                M spmu1	=	op1
00011570 =00000001                M spmu2	=	op2
00011570 =00000001                M spmu3	=	op3
00011570 =00000001                M spmu4	=	op4
00011570                            	spRateScale	$02, $01, $02, $01
00011570 =00000002                M sprs1	=	op1
00011570 =00000001                M sprs2	=	op2
00011570 =00000002                M sprs3	=	op3
00011570 =00000001                M sprs4	=	op4
00011570                            	spAttackRt	$0F, $0F, $0F, $0D
00011570 =0000000F                M spar1	=	op1
00011570 =0000000F                M spar2	=	op2
00011570 =0000000F                M spar3	=	op3
00011570 =0000000D                M spar4	=	op4
00011570                            	spAmpMod	$00, $00, $00, $00
00011570 =00000000                M spam1	=	op1
00011570 =00000000                M spam2	=	op2
00011570 =00000000                M spam3	=	op3
00011570 =00000000                M spam4	=	op4
00011570                            	spSustainRt	$09, $00, $09, $03
00011570 =00000009                M spsr1	=	op1
00011570 =00000000                M spsr2	=	op2
00011570 =00000009                M spsr3	=	op3
00011570 =00000003                M spsr4	=	op4
00011570                            	spDecayRt	$00, $00, $00, $00
00011570 =00000000                M spdr1	=	op1
00011570 =00000000                M spdr2	=	op2
00011570 =00000000                M spdr3	=	op3
00011570 =00000000                M spdr4	=	op4
00011570                            	spSustainLv	$01, $00, $0F, $00
00011570 =00000001                M spsl1	=	op1
00011570 =00000000                M spsl2	=	op2
00011570 =0000000F                M spsl3	=	op3
00011570 =00000000                M spsl4	=	op4
00011570                            	spReleaseRt	$05, $05, $05, $0A
00011570 =00000005                M sprr1	=	op1
00011570 =00000005                M sprr2	=	op2
00011570 =00000005                M sprr3	=	op3
00011570 =0000000A                M sprr4	=	op4
00011570                            	spSSGEG		$00, $00, $00, $00
00011570 =00000000                M spss1	=	op1
00011570 =00000000                M spss2	=	op2
00011570 =00000000                M spss3	=	op3
00011570 =00000000                M spss4	=	op4
00011570                            	spTotalLv	$19, $19, $1F, $01
00011570 =00000019                M sptl1	=	op1
00011570 =00000019                M sptl2	=	op2
00011570 =0000001F                M sptl3	=	op3
00011570 =00000001                M sptl4	=	op4
00011570 3A                       M 	dc.b	(spfe<<3)+spal
00011571 =00000080                M sptlmask4	set	$80
00011571 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011571 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011571 =00000000                M sptlmask1	set	((spal=7)<<7)
00011571 3101 0171                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011575 8F8F 4F4D                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011579 0909 0003                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001157D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011581 15F5 050A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011585 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011589 191F 1981                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001158D 4E41 54                  M 	dc.b	'NAT'
00011590                            
00011590                            	; Patch $58
00011590                            	; $3A
00011590                            	; $01, $07, $01, $01,	$8E, $8E, $8D, $53
00011590                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
00011590                            	; $1F, $FF, $1F, $0F,	$17, $28, $27, $86
00011590                            	spAlgorithm	$02
00011590 =00000059                M spatnum	=	spatnum+1
00011590 =00000002                M spal	=	val
00011590                            	spFeedback	$07
00011590 =00000007                M spfe	=	val
00011590                            	spDetune	$00, $00, $00, $00
00011590 =00000000                M spde1	=	op1
00011590 =00000000                M spde2	=	op2
00011590 =00000000                M spde3	=	op3
00011590 =00000000                M spde4	=	op4
00011590                            	spMultiple	$01, $01, $07, $01
00011590 =00000001                M spmu1	=	op1
00011590 =00000001                M spmu2	=	op2
00011590 =00000007                M spmu3	=	op3
00011590 =00000001                M spmu4	=	op4
00011590                            	spRateScale	$02, $02, $02, $01
00011590 =00000002                M sprs1	=	op1
00011590 =00000002                M sprs2	=	op2
00011590 =00000002                M sprs3	=	op3
00011590 =00000001                M sprs4	=	op4
00011590                            	spAttackRt	$0E, $0D, $0E, $13
00011590 =0000000E                M spar1	=	op1
00011590 =0000000D                M spar2	=	op2
00011590 =0000000E                M spar3	=	op3
00011590 =00000013                M spar4	=	op4
00011590                            	spAmpMod	$00, $00, $00, $00
00011590 =00000000                M spam1	=	op1
00011590 =00000000                M spam2	=	op2
00011590 =00000000                M spam3	=	op3
00011590 =00000000                M spam4	=	op4
00011590                            	spSustainRt	$0E, $0E, $0E, $03
00011590 =0000000E                M spsr1	=	op1
00011590 =0000000E                M spsr2	=	op2
00011590 =0000000E                M spsr3	=	op3
00011590 =00000003                M spsr4	=	op4
00011590                            	spDecayRt	$00, $00, $00, $00
00011590 =00000000                M spdr1	=	op1
00011590 =00000000                M spdr2	=	op2
00011590 =00000000                M spdr3	=	op3
00011590 =00000000                M spdr4	=	op4
00011590                            	spSustainLv	$01, $01, $0F, $00
00011590 =00000001                M spsl1	=	op1
00011590 =00000001                M spsl2	=	op2
00011590 =0000000F                M spsl3	=	op3
00011590 =00000000                M spsl4	=	op4
00011590                            	spReleaseRt	$0F, $0F, $0F, $0F
00011590 =0000000F                M sprr1	=	op1
00011590 =0000000F                M sprr2	=	op2
00011590 =0000000F                M sprr3	=	op3
00011590 =0000000F                M sprr4	=	op4
00011590                            	spSSGEG		$00, $00, $00, $00
00011590 =00000000                M spss1	=	op1
00011590 =00000000                M spss2	=	op2
00011590 =00000000                M spss3	=	op3
00011590 =00000000                M spss4	=	op4
00011590                            	spTotalLv	$17, $27, $28, $06
00011590 =00000017                M sptl1	=	op1
00011590 =00000027                M sptl2	=	op2
00011590 =00000028                M sptl3	=	op3
00011590 =00000006                M sptl4	=	op4
00011590 3A                       M 	dc.b	(spfe<<3)+spal
00011591 =00000080                M sptlmask4	set	$80
00011591 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011591 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011591 =00000000                M sptlmask1	set	((spal=7)<<7)
00011591 0107 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011595 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011599 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001159D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115A1 1FFF 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115A9 1728 2786                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115AD 4E41 54                  M 	dc.b	'NAT'
000115B0                            
000115B0                            	; Patch $59
000115B0                            	; $3A
000115B0                            	; $51, $07, $51, $02,	$0F, $0B, $0F, $0F
000115B0                            	; $1F, $1F, $1F, $0F,	$00, $00, $00, $02
000115B0                            	; $0F, $0F, $0F, $1F,	$1C, $28, $22, $81
000115B0                            	spAlgorithm	$02
000115B0 =0000005A                M spatnum	=	spatnum+1
000115B0 =00000002                M spal	=	val
000115B0                            	spFeedback	$07
000115B0 =00000007                M spfe	=	val
000115B0                            	spDetune	$05, $05, $00, $00
000115B0 =00000005                M spde1	=	op1
000115B0 =00000005                M spde2	=	op2
000115B0 =00000000                M spde3	=	op3
000115B0 =00000000                M spde4	=	op4
000115B0                            	spMultiple	$01, $01, $07, $02
000115B0 =00000001                M spmu1	=	op1
000115B0 =00000001                M spmu2	=	op2
000115B0 =00000007                M spmu3	=	op3
000115B0 =00000002                M spmu4	=	op4
000115B0                            	spRateScale	$00, $00, $00, $00
000115B0 =00000000                M sprs1	=	op1
000115B0 =00000000                M sprs2	=	op2
000115B0 =00000000                M sprs3	=	op3
000115B0 =00000000                M sprs4	=	op4
000115B0                            	spAttackRt	$0F, $0F, $0B, $0F
000115B0 =0000000F                M spar1	=	op1
000115B0 =0000000F                M spar2	=	op2
000115B0 =0000000B                M spar3	=	op3
000115B0 =0000000F                M spar4	=	op4
000115B0                            	spAmpMod	$00, $00, $00, $00
000115B0 =00000000                M spam1	=	op1
000115B0 =00000000                M spam2	=	op2
000115B0 =00000000                M spam3	=	op3
000115B0 =00000000                M spam4	=	op4
000115B0                            	spSustainRt	$1F, $1F, $1F, $0F
000115B0 =0000001F                M spsr1	=	op1
000115B0 =0000001F                M spsr2	=	op2
000115B0 =0000001F                M spsr3	=	op3
000115B0 =0000000F                M spsr4	=	op4
000115B0                            	spDecayRt	$00, $00, $00, $02
000115B0 =00000000                M spdr1	=	op1
000115B0 =00000000                M spdr2	=	op2
000115B0 =00000000                M spdr3	=	op3
000115B0 =00000002                M spdr4	=	op4
000115B0                            	spSustainLv	$00, $00, $00, $01
000115B0 =00000000                M spsl1	=	op1
000115B0 =00000000                M spsl2	=	op2
000115B0 =00000000                M spsl3	=	op3
000115B0 =00000001                M spsl4	=	op4
000115B0                            	spReleaseRt	$0F, $0F, $0F, $0F
000115B0 =0000000F                M sprr1	=	op1
000115B0 =0000000F                M sprr2	=	op2
000115B0 =0000000F                M sprr3	=	op3
000115B0 =0000000F                M sprr4	=	op4
000115B0                            	spSSGEG		$00, $00, $00, $00
000115B0 =00000000                M spss1	=	op1
000115B0 =00000000                M spss2	=	op2
000115B0 =00000000                M spss3	=	op3
000115B0 =00000000                M spss4	=	op4
000115B0                            	spTotalLv	$1C, $22, $28, $01
000115B0 =0000001C                M sptl1	=	op1
000115B0 =00000022                M sptl2	=	op2
000115B0 =00000028                M sptl3	=	op3
000115B0 =00000001                M sptl4	=	op4
000115B0 3A                       M 	dc.b	(spfe<<3)+spal
000115B1 =00000080                M sptlmask4	set	$80
000115B1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000115B1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000115B1 =00000000                M sptlmask1	set	((spal=7)<<7)
000115B1 5107 5102                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115B5 0F0B 0F0F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115B9 1F1F 1F0F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115BD 0000 0002                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115C1 0F0F 0F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115C5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115C9 1C28 2281                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115CD 4E41 54                  M 	dc.b	'NAT'
000115D0                            
000115D0                            	even
000115D0                            
000115D0                            ; -------------------------------------------------------------------------
000115D0                            VoiceBankSFX:
000115D0 =00000000                  sPatNum = 0
000115D0                            	include "Sound/unipatchsfx.asm"; include universal Voice banks
000115D0                            
000115D0                            ; ------------------------------------------------------------------------
000115D0                            ; AMPS SFX patch list
000115D0                            ; -------------------------------------------------------------------------
000115D0                            
000115D0                            	; Patch $00
000115D0                            	; $07
000115D0                            	; $07, $07, $08, $08,	$1F, $1F, $1F, $1F
000115D0                            	; $00, $00, $00, $00,	$00, $00, $00, $00
000115D0                            	; $0F, $0F, $0F, $0F,	$80, $80, $80, $80
000115D0                            	spAlgorithm	$07
000115D0 =00000001                M spatnum	=	spatnum+1
000115D0 =00000007                M spal	=	val
000115D0                            	spFeedback	$00
000115D0 =00000000                M spfe	=	val
000115D0                            	spDetune	$00, $00, $00, $00
000115D0 =00000000                M spde1	=	op1
000115D0 =00000000                M spde2	=	op2
000115D0 =00000000                M spde3	=	op3
000115D0 =00000000                M spde4	=	op4
000115D0                            	spMultiple	$07, $08, $07, $08
000115D0 =00000007                M spmu1	=	op1
000115D0 =00000008                M spmu2	=	op2
000115D0 =00000007                M spmu3	=	op3
000115D0 =00000008                M spmu4	=	op4
000115D0                            	spRateScale	$00, $00, $00, $00
000115D0 =00000000                M sprs1	=	op1
000115D0 =00000000                M sprs2	=	op2
000115D0 =00000000                M sprs3	=	op3
000115D0 =00000000                M sprs4	=	op4
000115D0                            	spAttackRt	$1F, $1F, $1F, $1F
000115D0 =0000001F                M spar1	=	op1
000115D0 =0000001F                M spar2	=	op2
000115D0 =0000001F                M spar3	=	op3
000115D0 =0000001F                M spar4	=	op4
000115D0                            	spAmpMod	$00, $00, $00, $00
000115D0 =00000000                M spam1	=	op1
000115D0 =00000000                M spam2	=	op2
000115D0 =00000000                M spam3	=	op3
000115D0 =00000000                M spam4	=	op4
000115D0                            	spSustainRt	$00, $00, $00, $00
000115D0 =00000000                M spsr1	=	op1
000115D0 =00000000                M spsr2	=	op2
000115D0 =00000000                M spsr3	=	op3
000115D0 =00000000                M spsr4	=	op4
000115D0                            	spDecayRt	$00, $00, $00, $00
000115D0 =00000000                M spdr1	=	op1
000115D0 =00000000                M spdr2	=	op2
000115D0 =00000000                M spdr3	=	op3
000115D0 =00000000                M spdr4	=	op4
000115D0                            	spSustainLv	$00, $00, $00, $00
000115D0 =00000000                M spsl1	=	op1
000115D0 =00000000                M spsl2	=	op2
000115D0 =00000000                M spsl3	=	op3
000115D0 =00000000                M spsl4	=	op4
000115D0                            	spReleaseRt	$0F, $0F, $0F, $0F
000115D0 =0000000F                M sprr1	=	op1
000115D0 =0000000F                M sprr2	=	op2
000115D0 =0000000F                M sprr3	=	op3
000115D0 =0000000F                M sprr4	=	op4
000115D0                            	spSSGEG		$00, $00, $00, $00
000115D0 =00000000                M spss1	=	op1
000115D0 =00000000                M spss2	=	op2
000115D0 =00000000                M spss3	=	op3
000115D0 =00000000                M spss4	=	op4
000115D0                            	spTotalLv2	$80, $80, $80, $80
000115D0 =00000080                M sptl1	=	op1
000115D0 =00000080                M sptl2	=	op2
000115D0 =00000080                M sptl3	=	op3
000115D0 =00000080                M sptl4	=	op4
000115D0 07                       M 	dc.b	(spfe<<3)+spal
000115D1 0707 0808                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115D5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115D9 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115DD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115E1 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115E5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115E9 8080 8080                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000115ED 4E41 54                  M 	dc.b	'NAT'
000115F0                            
000115F0                            	; Patch $01
000115F0                            	; $0C
000115F0                            	; $08, $08, $08, $08,	$1F, $1F, $1F, $1F
000115F0                            	; $00, $0A, $00, $0A,	$00, $00, $00, $0A
000115F0                            	; $FF, $FF, $FF, $FF,	$55, $81, $33, $81
000115F0                            	spAlgorithm	$04
000115F0 =00000002                M spatnum	=	spatnum+1
000115F0 =00000004                M spal	=	val
000115F0                            	spFeedback	$01
000115F0 =00000001                M spfe	=	val
000115F0                            	spDetune	$00, $00, $00, $00
000115F0 =00000000                M spde1	=	op1
000115F0 =00000000                M spde2	=	op2
000115F0 =00000000                M spde3	=	op3
000115F0 =00000000                M spde4	=	op4
000115F0                            	spMultiple	$08, $08, $08, $08
000115F0 =00000008                M spmu1	=	op1
000115F0 =00000008                M spmu2	=	op2
000115F0 =00000008                M spmu3	=	op3
000115F0 =00000008                M spmu4	=	op4
000115F0                            	spRateScale	$00, $00, $00, $00
000115F0 =00000000                M sprs1	=	op1
000115F0 =00000000                M sprs2	=	op2
000115F0 =00000000                M sprs3	=	op3
000115F0 =00000000                M sprs4	=	op4
000115F0                            	spAttackRt	$1F, $1F, $1F, $1F
000115F0 =0000001F                M spar1	=	op1
000115F0 =0000001F                M spar2	=	op2
000115F0 =0000001F                M spar3	=	op3
000115F0 =0000001F                M spar4	=	op4
000115F0                            	spAmpMod	$00, $00, $00, $00
000115F0 =00000000                M spam1	=	op1
000115F0 =00000000                M spam2	=	op2
000115F0 =00000000                M spam3	=	op3
000115F0 =00000000                M spam4	=	op4
000115F0                            	spSustainRt	$00, $00, $0A, $0A
000115F0 =00000000                M spsr1	=	op1
000115F0 =00000000                M spsr2	=	op2
000115F0 =0000000A                M spsr3	=	op3
000115F0 =0000000A                M spsr4	=	op4
000115F0                            	spDecayRt	$00, $00, $00, $0A
000115F0 =00000000                M spdr1	=	op1
000115F0 =00000000                M spdr2	=	op2
000115F0 =00000000                M spdr3	=	op3
000115F0 =0000000A                M spdr4	=	op4
000115F0                            	spSustainLv	$0F, $0F, $0F, $0F
000115F0 =0000000F                M spsl1	=	op1
000115F0 =0000000F                M spsl2	=	op2
000115F0 =0000000F                M spsl3	=	op3
000115F0 =0000000F                M spsl4	=	op4
000115F0                            	spReleaseRt	$0F, $0F, $0F, $0F
000115F0 =0000000F                M sprr1	=	op1
000115F0 =0000000F                M sprr2	=	op2
000115F0 =0000000F                M sprr3	=	op3
000115F0 =0000000F                M sprr4	=	op4
000115F0                            	spSSGEG		$00, $00, $00, $00
000115F0 =00000000                M spss1	=	op1
000115F0 =00000000                M spss2	=	op2
000115F0 =00000000                M spss3	=	op3
000115F0 =00000000                M spss4	=	op4
000115F0                            	spTotalLv	$55, $33, $01, $01
000115F0 =00000055                M sptl1	=	op1
000115F0 =00000033                M sptl2	=	op2
000115F0 =00000001                M sptl3	=	op3
000115F0 =00000001                M sptl4	=	op4
000115F0 0C                       M 	dc.b	(spfe<<3)+spal
000115F1 =00000080                M sptlmask4	set	$80
000115F1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000115F1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000115F1 =00000000                M sptlmask1	set	((spal=7)<<7)
000115F1 0808 0808                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115F5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115F9 000A 000A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115FD 0000 000A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011601 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011605 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011609 5581 3381                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001160D 4E41 54                  M 	dc.b	'NAT'
00011610                            
00011610                            	; Patch $02
00011610                            	; $30
00011610                            	; $30, $30, $30, $30,	$9E, $D8, $DC, $DC
00011610                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
00011610                            	; $BF, $BF, $BF, $BF,	$14, $3A, $14, $80
00011610                            	spAlgorithm	$00
00011610 =00000003                M spatnum	=	spatnum+1
00011610 =00000000                M spal	=	val
00011610                            	spFeedback	$06
00011610 =00000006                M spfe	=	val
00011610                            	spDetune	$03, $03, $03, $03
00011610 =00000003                M spde1	=	op1
00011610 =00000003                M spde2	=	op2
00011610 =00000003                M spde3	=	op3
00011610 =00000003                M spde4	=	op4
00011610                            	spMultiple	$00, $00, $00, $00
00011610 =00000000                M spmu1	=	op1
00011610 =00000000                M spmu2	=	op2
00011610 =00000000                M spmu3	=	op3
00011610 =00000000                M spmu4	=	op4
00011610                            	spRateScale	$02, $03, $03, $03
00011610 =00000002                M sprs1	=	op1
00011610 =00000003                M sprs2	=	op2
00011610 =00000003                M sprs3	=	op3
00011610 =00000003                M sprs4	=	op4
00011610                            	spAttackRt	$1E, $1C, $18, $1C
00011610 =0000001E                M spar1	=	op1
00011610 =0000001C                M spar2	=	op2
00011610 =00000018                M spar3	=	op3
00011610 =0000001C                M spar4	=	op4
00011610                            	spAmpMod	$00, $00, $00, $00
00011610 =00000000                M spam1	=	op1
00011610 =00000000                M spam2	=	op2
00011610 =00000000                M spam3	=	op3
00011610 =00000000                M spam4	=	op4
00011610                            	spSustainRt	$0E, $04, $0A, $05
00011610 =0000000E                M spsr1	=	op1
00011610 =00000004                M spsr2	=	op2
00011610 =0000000A                M spsr3	=	op3
00011610 =00000005                M spsr4	=	op4
00011610                            	spDecayRt	$08, $08, $08, $08
00011610 =00000008                M spdr1	=	op1
00011610 =00000008                M spdr2	=	op2
00011610 =00000008                M spdr3	=	op3
00011610 =00000008                M spdr4	=	op4
00011610                            	spSustainLv	$0B, $0B, $0B, $0B
00011610 =0000000B                M spsl1	=	op1
00011610 =0000000B                M spsl2	=	op2
00011610 =0000000B                M spsl3	=	op3
00011610 =0000000B                M spsl4	=	op4
00011610                            	spReleaseRt	$0F, $0F, $0F, $0F
00011610 =0000000F                M sprr1	=	op1
00011610 =0000000F                M sprr2	=	op2
00011610 =0000000F                M sprr3	=	op3
00011610 =0000000F                M sprr4	=	op4
00011610                            	spSSGEG		$00, $00, $00, $00
00011610 =00000000                M spss1	=	op1
00011610 =00000000                M spss2	=	op2
00011610 =00000000                M spss3	=	op3
00011610 =00000000                M spss4	=	op4
00011610                            	spTotalLv2	$14, $14, $3A, $80
00011610 =00000014                M sptl1	=	op1
00011610 =00000014                M sptl2	=	op2
00011610 =0000003A                M sptl3	=	op3
00011610 =00000080                M sptl4	=	op4
00011610 30                       M 	dc.b	(spfe<<3)+spal
00011611 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011615 9ED8 DCDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011619 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001161D 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011621 BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011625 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011629 143A 1480                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001162D 4E41 54                  M 	dc.b	'NAT'
00011630                            
00011630                            	; Patch $03
00011630                            	; $04
00011630                            	; $37, $72, $77, $49,	$1F, $1F, $1F, $1F
00011630                            	; $07, $0A, $07, $0D,	$00, $0B, $00, $0B
00011630                            	; $1F, $0F, $1F, $0F,	$23, $00, $23, $00
00011630                            	spAlgorithm	$04
00011630 =00000004                M spatnum	=	spatnum+1
00011630 =00000004                M spal	=	val
00011630                            	spFeedback	$00
00011630 =00000000                M spfe	=	val
00011630                            	spDetune	$03, $07, $07, $04
00011630 =00000003                M spde1	=	op1
00011630 =00000007                M spde2	=	op2
00011630 =00000007                M spde3	=	op3
00011630 =00000004                M spde4	=	op4
00011630                            	spMultiple	$07, $07, $02, $09
00011630 =00000007                M spmu1	=	op1
00011630 =00000007                M spmu2	=	op2
00011630 =00000002                M spmu3	=	op3
00011630 =00000009                M spmu4	=	op4
00011630                            	spRateScale	$00, $00, $00, $00
00011630 =00000000                M sprs1	=	op1
00011630 =00000000                M sprs2	=	op2
00011630 =00000000                M sprs3	=	op3
00011630 =00000000                M sprs4	=	op4
00011630                            	spAttackRt	$1F, $1F, $1F, $1F
00011630 =0000001F                M spar1	=	op1
00011630 =0000001F                M spar2	=	op2
00011630 =0000001F                M spar3	=	op3
00011630 =0000001F                M spar4	=	op4
00011630                            	spAmpMod	$00, $00, $00, $00
00011630 =00000000                M spam1	=	op1
00011630 =00000000                M spam2	=	op2
00011630 =00000000                M spam3	=	op3
00011630 =00000000                M spam4	=	op4
00011630                            	spSustainRt	$07, $07, $0A, $0D
00011630 =00000007                M spsr1	=	op1
00011630 =00000007                M spsr2	=	op2
00011630 =0000000A                M spsr3	=	op3
00011630 =0000000D                M spsr4	=	op4
00011630                            	spDecayRt	$00, $00, $0B, $0B
00011630 =00000000                M spdr1	=	op1
00011630 =00000000                M spdr2	=	op2
00011630 =0000000B                M spdr3	=	op3
00011630 =0000000B                M spdr4	=	op4
00011630                            	spSustainLv	$01, $01, $00, $00
00011630 =00000001                M spsl1	=	op1
00011630 =00000001                M spsl2	=	op2
00011630 =00000000                M spsl3	=	op3
00011630 =00000000                M spsl4	=	op4
00011630                            	spReleaseRt	$0F, $0F, $0F, $0F
00011630 =0000000F                M sprr1	=	op1
00011630 =0000000F                M sprr2	=	op2
00011630 =0000000F                M sprr3	=	op3
00011630 =0000000F                M sprr4	=	op4
00011630                            	spSSGEG		$00, $00, $00, $00
00011630 =00000000                M spss1	=	op1
00011630 =00000000                M spss2	=	op2
00011630 =00000000                M spss3	=	op3
00011630 =00000000                M spss4	=	op4
00011630                            	spTotalLv2	$23, $23, $00, $00
00011630 =00000023                M sptl1	=	op1
00011630 =00000023                M sptl2	=	op2
00011630 =00000000                M sptl3	=	op3
00011630 =00000000                M sptl4	=	op4
00011630 04                       M 	dc.b	(spfe<<3)+spal
00011631 3772 7749                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011635 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011639 070A 070D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001163D 000B 000B                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011641 1F0F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011645 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011649 2300 2300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001164D 4E41 54                  M 	dc.b	'NAT'
00011650                            
00011650                            	; Patch $04
00011650                            	; $3C
00011650                            	; $0F, $01, $03, $01,	$1F, $1F, $1F, $1F
00011650                            	; $19, $12, $19, $0E,	$05, $12, $00, $0F
00011650                            	; $0F, $7F, $FF, $FF,	$00, $00, $00, $00
00011650                            	spAlgorithm	$04
00011650 =00000005                M spatnum	=	spatnum+1
00011650 =00000004                M spal	=	val
00011650                            	spFeedback	$07
00011650 =00000007                M spfe	=	val
00011650                            	spDetune	$00, $00, $00, $00
00011650 =00000000                M spde1	=	op1
00011650 =00000000                M spde2	=	op2
00011650 =00000000                M spde3	=	op3
00011650 =00000000                M spde4	=	op4
00011650                            	spMultiple	$0F, $03, $01, $01
00011650 =0000000F                M spmu1	=	op1
00011650 =00000003                M spmu2	=	op2
00011650 =00000001                M spmu3	=	op3
00011650 =00000001                M spmu4	=	op4
00011650                            	spRateScale	$00, $00, $00, $00
00011650 =00000000                M sprs1	=	op1
00011650 =00000000                M sprs2	=	op2
00011650 =00000000                M sprs3	=	op3
00011650 =00000000                M sprs4	=	op4
00011650                            	spAttackRt	$1F, $1F, $1F, $1F
00011650 =0000001F                M spar1	=	op1
00011650 =0000001F                M spar2	=	op2
00011650 =0000001F                M spar3	=	op3
00011650 =0000001F                M spar4	=	op4
00011650                            	spAmpMod	$00, $00, $00, $00
00011650 =00000000                M spam1	=	op1
00011650 =00000000                M spam2	=	op2
00011650 =00000000                M spam3	=	op3
00011650 =00000000                M spam4	=	op4
00011650                            	spSustainRt	$19, $19, $12, $0E
00011650 =00000019                M spsr1	=	op1
00011650 =00000019                M spsr2	=	op2
00011650 =00000012                M spsr3	=	op3
00011650 =0000000E                M spsr4	=	op4
00011650                            	spDecayRt	$05, $00, $12, $0F
00011650 =00000005                M spdr1	=	op1
00011650 =00000000                M spdr2	=	op2
00011650 =00000012                M spdr3	=	op3
00011650 =0000000F                M spdr4	=	op4
00011650                            	spSustainLv	$00, $0F, $07, $0F
00011650 =00000000                M spsl1	=	op1
00011650 =0000000F                M spsl2	=	op2
00011650 =00000007                M spsl3	=	op3
00011650 =0000000F                M spsl4	=	op4
00011650                            	spReleaseRt	$0F, $0F, $0F, $0F
00011650 =0000000F                M sprr1	=	op1
00011650 =0000000F                M sprr2	=	op2
00011650 =0000000F                M sprr3	=	op3
00011650 =0000000F                M sprr4	=	op4
00011650                            	spSSGEG		$00, $00, $00, $00
00011650 =00000000                M spss1	=	op1
00011650 =00000000                M spss2	=	op2
00011650 =00000000                M spss3	=	op3
00011650 =00000000                M spss4	=	op4
00011650                            	spTotalLv2	$00, $00, $00, $00
00011650 =00000000                M sptl1	=	op1
00011650 =00000000                M sptl2	=	op2
00011650 =00000000                M sptl3	=	op3
00011650 =00000000                M sptl4	=	op4
00011650 3C                       M 	dc.b	(spfe<<3)+spal
00011651 0F01 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011655 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011659 1912 190E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001165D 0512 000F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011661 0F7F FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011665 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011669 0000 0000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001166D 4E41 54                  M 	dc.b	'NAT'
00011670                            
00011670                            	; Patch $05
00011670                            	; $30
00011670                            	; $30, $30, $30, $30,	$9E, $A8, $AC, $DC
00011670                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
00011670                            	; $BF, $BF, $BF, $BF,	$04, $2C, $14, $00
00011670                            	spAlgorithm	$00
00011670 =00000006                M spatnum	=	spatnum+1
00011670 =00000000                M spal	=	val
00011670                            	spFeedback	$06
00011670 =00000006                M spfe	=	val
00011670                            	spDetune	$03, $03, $03, $03
00011670 =00000003                M spde1	=	op1
00011670 =00000003                M spde2	=	op2
00011670 =00000003                M spde3	=	op3
00011670 =00000003                M spde4	=	op4
00011670                            	spMultiple	$00, $00, $00, $00
00011670 =00000000                M spmu1	=	op1
00011670 =00000000                M spmu2	=	op2
00011670 =00000000                M spmu3	=	op3
00011670 =00000000                M spmu4	=	op4
00011670                            	spRateScale	$02, $02, $02, $03
00011670 =00000002                M sprs1	=	op1
00011670 =00000002                M sprs2	=	op2
00011670 =00000002                M sprs3	=	op3
00011670 =00000003                M sprs4	=	op4
00011670                            	spAttackRt	$1E, $0C, $08, $1C
00011670 =0000001E                M spar1	=	op1
00011670 =0000000C                M spar2	=	op2
00011670 =00000008                M spar3	=	op3
00011670 =0000001C                M spar4	=	op4
00011670                            	spAmpMod	$00, $00, $00, $00
00011670 =00000000                M spam1	=	op1
00011670 =00000000                M spam2	=	op2
00011670 =00000000                M spam3	=	op3
00011670 =00000000                M spam4	=	op4
00011670                            	spSustainRt	$0E, $04, $0A, $05
00011670 =0000000E                M spsr1	=	op1
00011670 =00000004                M spsr2	=	op2
00011670 =0000000A                M spsr3	=	op3
00011670 =00000005                M spsr4	=	op4
00011670                            	spDecayRt	$08, $08, $08, $08
00011670 =00000008                M spdr1	=	op1
00011670 =00000008                M spdr2	=	op2
00011670 =00000008                M spdr3	=	op3
00011670 =00000008                M spdr4	=	op4
00011670                            	spSustainLv	$0B, $0B, $0B, $0B
00011670 =0000000B                M spsl1	=	op1
00011670 =0000000B                M spsl2	=	op2
00011670 =0000000B                M spsl3	=	op3
00011670 =0000000B                M spsl4	=	op4
00011670                            	spReleaseRt	$0F, $0F, $0F, $0F
00011670 =0000000F                M sprr1	=	op1
00011670 =0000000F                M sprr2	=	op2
00011670 =0000000F                M sprr3	=	op3
00011670 =0000000F                M sprr4	=	op4
00011670                            	spSSGEG		$00, $00, $00, $00
00011670 =00000000                M spss1	=	op1
00011670 =00000000                M spss2	=	op2
00011670 =00000000                M spss3	=	op3
00011670 =00000000                M spss4	=	op4
00011670                            	spTotalLv2	$04, $14, $2C, $00
00011670 =00000004                M sptl1	=	op1
00011670 =00000014                M sptl2	=	op2
00011670 =0000002C                M sptl3	=	op3
00011670 =00000000                M sptl4	=	op4
00011670 30                       M 	dc.b	(spfe<<3)+spal
00011671 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011675 9E88 8CDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011679 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001167D 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011681 BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011685 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011689 042C 1400                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001168D 4E41 54                  M 	dc.b	'NAT'
00011690                            
00011690                            	; Patch $06
00011690                            	; $20
00011690                            	; $36, $35, $30, $31,	$DF, $DF, $9F, $9F
00011690                            	; $07, $06, $09, $06,	$07, $06, $06, $08
00011690                            	; $2F, $1F, $1F, $FF,	$16, $30, $13, $00
00011690                            	spAlgorithm	$00
00011690 =00000007                M spatnum	=	spatnum+1
00011690 =00000000                M spal	=	val
00011690                            	spFeedback	$04
00011690 =00000004                M spfe	=	val
00011690                            	spDetune	$03, $03, $03, $03
00011690 =00000003                M spde1	=	op1
00011690 =00000003                M spde2	=	op2
00011690 =00000003                M spde3	=	op3
00011690 =00000003                M spde4	=	op4
00011690                            	spMultiple	$06, $00, $05, $01
00011690 =00000006                M spmu1	=	op1
00011690 =00000000                M spmu2	=	op2
00011690 =00000005                M spmu3	=	op3
00011690 =00000001                M spmu4	=	op4
00011690                            	spRateScale	$03, $02, $03, $02
00011690 =00000003                M sprs1	=	op1
00011690 =00000002                M sprs2	=	op2
00011690 =00000003                M sprs3	=	op3
00011690 =00000002                M sprs4	=	op4
00011690                            	spAttackRt	$1F, $1F, $1F, $1F
00011690 =0000001F                M spar1	=	op1
00011690 =0000001F                M spar2	=	op2
00011690 =0000001F                M spar3	=	op3
00011690 =0000001F                M spar4	=	op4
00011690                            	spAmpMod	$00, $00, $00, $00
00011690 =00000000                M spam1	=	op1
00011690 =00000000                M spam2	=	op2
00011690 =00000000                M spam3	=	op3
00011690 =00000000                M spam4	=	op4
00011690                            	spSustainRt	$07, $09, $06, $06
00011690 =00000007                M spsr1	=	op1
00011690 =00000009                M spsr2	=	op2
00011690 =00000006                M spsr3	=	op3
00011690 =00000006                M spsr4	=	op4
00011690                            	spDecayRt	$07, $06, $06, $08
00011690 =00000007                M spdr1	=	op1
00011690 =00000006                M spdr2	=	op2
00011690 =00000006                M spdr3	=	op3
00011690 =00000008                M spdr4	=	op4
00011690                            	spSustainLv	$02, $01, $01, $0F
00011690 =00000002                M spsl1	=	op1
00011690 =00000001                M spsl2	=	op2
00011690 =00000001                M spsl3	=	op3
00011690 =0000000F                M spsl4	=	op4
00011690                            	spReleaseRt	$0F, $0F, $0F, $0F
00011690 =0000000F                M sprr1	=	op1
00011690 =0000000F                M sprr2	=	op2
00011690 =0000000F                M sprr3	=	op3
00011690 =0000000F                M sprr4	=	op4
00011690                            	spSSGEG		$00, $00, $00, $00
00011690 =00000000                M spss1	=	op1
00011690 =00000000                M spss2	=	op2
00011690 =00000000                M spss3	=	op3
00011690 =00000000                M spss4	=	op4
00011690                            	spTotalLv2	$16, $13, $30, $00
00011690 =00000016                M sptl1	=	op1
00011690 =00000013                M sptl2	=	op2
00011690 =00000030                M sptl3	=	op3
00011690 =00000000                M sptl4	=	op4
00011690 20                       M 	dc.b	(spfe<<3)+spal
00011691 3635 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011695 DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011699 0706 0906                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001169D 0706 0608                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116A1 2F1F 1FFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116A9 1630 1300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000116AD 4E41 54                  M 	dc.b	'NAT'
000116B0                            
000116B0                            	; Patch $07
000116B0                            	; $35
000116B0                            	; $05, $09, $08, $07,	$1E, $0D, $0D, $0E
000116B0                            	; $0C, $15, $03, $06,	$16, $0E, $09, $10
000116B0                            	; $2F, $2F, $1F, $1F,	$15, $12, $12, $00
000116B0                            	spAlgorithm	$05
000116B0 =00000008                M spatnum	=	spatnum+1
000116B0 =00000005                M spal	=	val
000116B0                            	spFeedback	$06
000116B0 =00000006                M spfe	=	val
000116B0                            	spDetune	$00, $00, $00, $00
000116B0 =00000000                M spde1	=	op1
000116B0 =00000000                M spde2	=	op2
000116B0 =00000000                M spde3	=	op3
000116B0 =00000000                M spde4	=	op4
000116B0                            	spMultiple	$05, $08, $09, $07
000116B0 =00000005                M spmu1	=	op1
000116B0 =00000008                M spmu2	=	op2
000116B0 =00000009                M spmu3	=	op3
000116B0 =00000007                M spmu4	=	op4
000116B0                            	spRateScale	$00, $00, $00, $00
000116B0 =00000000                M sprs1	=	op1
000116B0 =00000000                M sprs2	=	op2
000116B0 =00000000                M sprs3	=	op3
000116B0 =00000000                M sprs4	=	op4
000116B0                            	spAttackRt	$1E, $0D, $0D, $0E
000116B0 =0000001E                M spar1	=	op1
000116B0 =0000000D                M spar2	=	op2
000116B0 =0000000D                M spar3	=	op3
000116B0 =0000000E                M spar4	=	op4
000116B0                            	spAmpMod	$00, $00, $00, $00
000116B0 =00000000                M spam1	=	op1
000116B0 =00000000                M spam2	=	op2
000116B0 =00000000                M spam3	=	op3
000116B0 =00000000                M spam4	=	op4
000116B0                            	spSustainRt	$0C, $03, $15, $06
000116B0 =0000000C                M spsr1	=	op1
000116B0 =00000003                M spsr2	=	op2
000116B0 =00000015                M spsr3	=	op3
000116B0 =00000006                M spsr4	=	op4
000116B0                            	spDecayRt	$16, $09, $0E, $10
000116B0 =00000016                M spdr1	=	op1
000116B0 =00000009                M spdr2	=	op2
000116B0 =0000000E                M spdr3	=	op3
000116B0 =00000010                M spdr4	=	op4
000116B0                            	spSustainLv	$02, $01, $02, $01
000116B0 =00000002                M spsl1	=	op1
000116B0 =00000001                M spsl2	=	op2
000116B0 =00000002                M spsl3	=	op3
000116B0 =00000001                M spsl4	=	op4
000116B0                            	spReleaseRt	$0F, $0F, $0F, $0F
000116B0 =0000000F                M sprr1	=	op1
000116B0 =0000000F                M sprr2	=	op2
000116B0 =0000000F                M sprr3	=	op3
000116B0 =0000000F                M sprr4	=	op4
000116B0                            	spSSGEG		$00, $00, $00, $00
000116B0 =00000000                M spss1	=	op1
000116B0 =00000000                M spss2	=	op2
000116B0 =00000000                M spss3	=	op3
000116B0 =00000000                M spss4	=	op4
000116B0                            	spTotalLv2	$15, $12, $12, $00
000116B0 =00000015                M sptl1	=	op1
000116B0 =00000012                M sptl2	=	op2
000116B0 =00000012                M sptl3	=	op3
000116B0 =00000000                M sptl4	=	op4
000116B0 35                       M 	dc.b	(spfe<<3)+spal
000116B1 0509 0807                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116B5 1E0D 0D0E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116B9 0C15 0306                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116BD 160E 0910                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116C1 2F2F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116C5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116C9 1512 1200                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000116CD 4E41 54                  M 	dc.b	'NAT'
000116D0                            
000116D0                            	; Patch $08
000116D0                            	; $3E
000116D0                            	; $36, $01, $00, $04,	$59, $D9, $5F, $9C
000116D0                            	; $0F, $04, $0F, $0A,	$02, $02, $05, $05
000116D0                            	; $A9, $AF, $66, $66,	$20, $00, $0A, $00
000116D0                            	spAlgorithm	$06
000116D0 =00000009                M spatnum	=	spatnum+1
000116D0 =00000006                M spal	=	val
000116D0                            	spFeedback	$07
000116D0 =00000007                M spfe	=	val
000116D0                            	spDetune	$03, $00, $00, $00
000116D0 =00000003                M spde1	=	op1
000116D0 =00000000                M spde2	=	op2
000116D0 =00000000                M spde3	=	op3
000116D0 =00000000                M spde4	=	op4
000116D0                            	spMultiple	$06, $00, $01, $04
000116D0 =00000006                M spmu1	=	op1
000116D0 =00000000                M spmu2	=	op2
000116D0 =00000001                M spmu3	=	op3
000116D0 =00000004                M spmu4	=	op4
000116D0                            	spRateScale	$01, $01, $03, $02
000116D0 =00000001                M sprs1	=	op1
000116D0 =00000001                M sprs2	=	op2
000116D0 =00000003                M sprs3	=	op3
000116D0 =00000002                M sprs4	=	op4
000116D0                            	spAttackRt	$19, $1F, $19, $1C
000116D0 =00000019                M spar1	=	op1
000116D0 =0000001F                M spar2	=	op2
000116D0 =00000019                M spar3	=	op3
000116D0 =0000001C                M spar4	=	op4
000116D0                            	spAmpMod	$00, $00, $00, $00
000116D0 =00000000                M spam1	=	op1
000116D0 =00000000                M spam2	=	op2
000116D0 =00000000                M spam3	=	op3
000116D0 =00000000                M spam4	=	op4
000116D0                            	spSustainRt	$0F, $0F, $04, $0A
000116D0 =0000000F                M spsr1	=	op1
000116D0 =0000000F                M spsr2	=	op2
000116D0 =00000004                M spsr3	=	op3
000116D0 =0000000A                M spsr4	=	op4
000116D0                            	spDecayRt	$02, $05, $02, $05
000116D0 =00000002                M spdr1	=	op1
000116D0 =00000005                M spdr2	=	op2
000116D0 =00000002                M spdr3	=	op3
000116D0 =00000005                M spdr4	=	op4
000116D0                            	spSustainLv	$0A, $06, $0A, $06
000116D0 =0000000A                M spsl1	=	op1
000116D0 =00000006                M spsl2	=	op2
000116D0 =0000000A                M spsl3	=	op3
000116D0 =00000006                M spsl4	=	op4
000116D0                            	spReleaseRt	$09, $06, $0F, $06
000116D0 =00000009                M sprr1	=	op1
000116D0 =00000006                M sprr2	=	op2
000116D0 =0000000F                M sprr3	=	op3
000116D0 =00000006                M sprr4	=	op4
000116D0                            	spSSGEG		$00, $00, $00, $00
000116D0 =00000000                M spss1	=	op1
000116D0 =00000000                M spss2	=	op2
000116D0 =00000000                M spss3	=	op3
000116D0 =00000000                M spss4	=	op4
000116D0                            	spTotalLv2	$20, $0A, $00, $00
000116D0 =00000020                M sptl1	=	op1
000116D0 =0000000A                M sptl2	=	op2
000116D0 =00000000                M sptl3	=	op3
000116D0 =00000000                M sptl4	=	op4
000116D0 3E                       M 	dc.b	(spfe<<3)+spal
000116D1 3601 0004                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116D5 59D9 5F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116D9 0F04 0F0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116DD 0202 0505                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116E1 A9AF 6666                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116E5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116E9 2000 0A00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000116ED 4E41 54                  M 	dc.b	'NAT'
000116F0                            
000116F0                            	; Patch $09
000116F0                            	; $3A
000116F0                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
000116F0                            	; $05, $18, $05, $10,	$0B, $1F, $10, $10
000116F0                            	; $1F, $2F, $4F, $2F,	$0D, $07, $04, $00
000116F0                            	spAlgorithm	$02
000116F0 =0000000A                M spatnum	=	spatnum+1
000116F0 =00000002                M spal	=	val
000116F0                            	spFeedback	$07
000116F0 =00000007                M spfe	=	val
000116F0                            	spDetune	$02, $01, $03, $03
000116F0 =00000002                M spde1	=	op1
000116F0 =00000001                M spde2	=	op2
000116F0 =00000003                M spde3	=	op3
000116F0 =00000003                M spde4	=	op4
000116F0                            	spMultiple	$01, $00, $00, $02
000116F0 =00000001                M spmu1	=	op1
000116F0 =00000000                M spmu2	=	op2
000116F0 =00000000                M spmu3	=	op3
000116F0 =00000002                M spmu4	=	op4
000116F0                            	spRateScale	$00, $00, $00, $00
000116F0 =00000000                M sprs1	=	op1
000116F0 =00000000                M sprs2	=	op2
000116F0 =00000000                M sprs3	=	op3
000116F0 =00000000                M sprs4	=	op4
000116F0                            	spAttackRt	$1F, $1F, $1F, $1F
000116F0 =0000001F                M spar1	=	op1
000116F0 =0000001F                M spar2	=	op2
000116F0 =0000001F                M spar3	=	op3
000116F0 =0000001F                M spar4	=	op4
000116F0                            	spAmpMod	$00, $00, $00, $00
000116F0 =00000000                M spam1	=	op1
000116F0 =00000000                M spam2	=	op2
000116F0 =00000000                M spam3	=	op3
000116F0 =00000000                M spam4	=	op4
000116F0                            	spSustainRt	$05, $05, $18, $10
000116F0 =00000005                M spsr1	=	op1
000116F0 =00000005                M spsr2	=	op2
000116F0 =00000018                M spsr3	=	op3
000116F0 =00000010                M spsr4	=	op4
000116F0                            	spDecayRt	$0B, $10, $1F, $10
000116F0 =0000000B                M spdr1	=	op1
000116F0 =00000010                M spdr2	=	op2
000116F0 =0000001F                M spdr3	=	op3
000116F0 =00000010                M spdr4	=	op4
000116F0                            	spSustainLv	$01, $04, $02, $02
000116F0 =00000001                M spsl1	=	op1
000116F0 =00000004                M spsl2	=	op2
000116F0 =00000002                M spsl3	=	op3
000116F0 =00000002                M spsl4	=	op4
000116F0                            	spReleaseRt	$0F, $0F, $0F, $0F
000116F0 =0000000F                M sprr1	=	op1
000116F0 =0000000F                M sprr2	=	op2
000116F0 =0000000F                M sprr3	=	op3
000116F0 =0000000F                M sprr4	=	op4
000116F0                            	spSSGEG		$00, $00, $00, $00
000116F0 =00000000                M spss1	=	op1
000116F0 =00000000                M spss2	=	op2
000116F0 =00000000                M spss3	=	op3
000116F0 =00000000                M spss4	=	op4
000116F0                            	spTotalLv2	$0D, $04, $07, $00
000116F0 =0000000D                M sptl1	=	op1
000116F0 =00000004                M sptl2	=	op2
000116F0 =00000007                M sptl3	=	op3
000116F0 =00000000                M sptl4	=	op4
000116F0 3A                       M 	dc.b	(spfe<<3)+spal
000116F1 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116F5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116F9 0518 0510                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116FD 0B1F 1010                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011701 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011705 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011709 0D07 0400                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001170D 4E41 54                  M 	dc.b	'NAT'
00011710                            
00011710                            	; Patch $0A
00011710                            	; $3C
00011710                            	; $00, $44, $02, $02, 	$1F, $1F, $1F, $15
00011710                            	; $00, $1F, $00, $00,	$00, $00, $00, $00
00011710                            	; $0F, $0F, $0F, $0F, 	$0D, $80, $28, $80
00011710                            	spAlgorithm	$04
00011710 =0000000B                M spatnum	=	spatnum+1
00011710 =00000004                M spal	=	val
00011710                            	spFeedback	$07
00011710 =00000007                M spfe	=	val
00011710                            	spDetune	$00, $00, $04, $00
00011710 =00000000                M spde1	=	op1
00011710 =00000000                M spde2	=	op2
00011710 =00000004                M spde3	=	op3
00011710 =00000000                M spde4	=	op4
00011710                            	spMultiple	$00, $02, $04, $02
00011710 =00000000                M spmu1	=	op1
00011710 =00000002                M spmu2	=	op2
00011710 =00000004                M spmu3	=	op3
00011710 =00000002                M spmu4	=	op4
00011710                            	spRateScale	$00, $00, $00, $00
00011710 =00000000                M sprs1	=	op1
00011710 =00000000                M sprs2	=	op2
00011710 =00000000                M sprs3	=	op3
00011710 =00000000                M sprs4	=	op4
00011710                            	spAttackRt	$1F, $1F, $1F, $15
00011710 =0000001F                M spar1	=	op1
00011710 =0000001F                M spar2	=	op2
00011710 =0000001F                M spar3	=	op3
00011710 =00000015                M spar4	=	op4
00011710                            	spAmpMod	$00, $00, $00, $00
00011710 =00000000                M spam1	=	op1
00011710 =00000000                M spam2	=	op2
00011710 =00000000                M spam3	=	op3
00011710 =00000000                M spam4	=	op4
00011710                            	spSustainRt	$00, $00, $1F, $00
00011710 =00000000                M spsr1	=	op1
00011710 =00000000                M spsr2	=	op2
00011710 =0000001F                M spsr3	=	op3
00011710 =00000000                M spsr4	=	op4
00011710                            	spDecayRt	$00, $00, $00, $00
00011710 =00000000                M spdr1	=	op1
00011710 =00000000                M spdr2	=	op2
00011710 =00000000                M spdr3	=	op3
00011710 =00000000                M spdr4	=	op4
00011710                            	spSustainLv	$00, $00, $00, $00
00011710 =00000000                M spsl1	=	op1
00011710 =00000000                M spsl2	=	op2
00011710 =00000000                M spsl3	=	op3
00011710 =00000000                M spsl4	=	op4
00011710                            	spReleaseRt	$0F, $0F, $0F, $0F
00011710 =0000000F                M sprr1	=	op1
00011710 =0000000F                M sprr2	=	op2
00011710 =0000000F                M sprr3	=	op3
00011710 =0000000F                M sprr4	=	op4
00011710                            	spSSGEG		$00, $00, $00, $00
00011710 =00000000                M spss1	=	op1
00011710 =00000000                M spss2	=	op2
00011710 =00000000                M spss3	=	op3
00011710 =00000000                M spss4	=	op4
00011710                            	spTotalLv2	$0D, $28, $80, $80
00011710 =0000000D                M sptl1	=	op1
00011710 =00000028                M sptl2	=	op2
00011710 =00000080                M sptl3	=	op3
00011710 =00000080                M sptl4	=	op4
00011710 3C                       M 	dc.b	(spfe<<3)+spal
00011711 0044 0202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011715 1F1F 1F15                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011719 001F 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001171D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011721 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011725 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011729 0D80 2880                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001172D 4E41 54                  M 	dc.b	'NAT'
00011730                            
00011730                            	; Patch $0B
00011730                            	; $3A
00011730                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011730                            	; $05, $18, $09, $02,	$06, $0F, $06, $02
00011730                            	; $1F, $2F, $4F, $2F,	$0F, $1A, $0E, $00
00011730                            	spAlgorithm	$02
00011730 =0000000C                M spatnum	=	spatnum+1
00011730 =00000002                M spal	=	val
00011730                            	spFeedback	$07
00011730 =00000007                M spfe	=	val
00011730                            	spDetune	$02, $01, $03, $03
00011730 =00000002                M spde1	=	op1
00011730 =00000001                M spde2	=	op2
00011730 =00000003                M spde3	=	op3
00011730 =00000003                M spde4	=	op4
00011730                            	spMultiple	$01, $00, $00, $02
00011730 =00000001                M spmu1	=	op1
00011730 =00000000                M spmu2	=	op2
00011730 =00000000                M spmu3	=	op3
00011730 =00000002                M spmu4	=	op4
00011730                            	spRateScale	$00, $00, $00, $00
00011730 =00000000                M sprs1	=	op1
00011730 =00000000                M sprs2	=	op2
00011730 =00000000                M sprs3	=	op3
00011730 =00000000                M sprs4	=	op4
00011730                            	spAttackRt	$1F, $1F, $1F, $1F
00011730 =0000001F                M spar1	=	op1
00011730 =0000001F                M spar2	=	op2
00011730 =0000001F                M spar3	=	op3
00011730 =0000001F                M spar4	=	op4
00011730                            	spAmpMod	$00, $00, $00, $00
00011730 =00000000                M spam1	=	op1
00011730 =00000000                M spam2	=	op2
00011730 =00000000                M spam3	=	op3
00011730 =00000000                M spam4	=	op4
00011730                            	spSustainRt	$05, $09, $18, $02
00011730 =00000005                M spsr1	=	op1
00011730 =00000009                M spsr2	=	op2
00011730 =00000018                M spsr3	=	op3
00011730 =00000002                M spsr4	=	op4
00011730                            	spDecayRt	$06, $06, $0F, $02
00011730 =00000006                M spdr1	=	op1
00011730 =00000006                M spdr2	=	op2
00011730 =0000000F                M spdr3	=	op3
00011730 =00000002                M spdr4	=	op4
00011730                            	spSustainLv	$01, $04, $02, $02
00011730 =00000001                M spsl1	=	op1
00011730 =00000004                M spsl2	=	op2
00011730 =00000002                M spsl3	=	op3
00011730 =00000002                M spsl4	=	op4
00011730                            	spReleaseRt	$0F, $0F, $0F, $0F
00011730 =0000000F                M sprr1	=	op1
00011730 =0000000F                M sprr2	=	op2
00011730 =0000000F                M sprr3	=	op3
00011730 =0000000F                M sprr4	=	op4
00011730                            	spSSGEG		$00, $00, $00, $00
00011730 =00000000                M spss1	=	op1
00011730 =00000000                M spss2	=	op2
00011730 =00000000                M spss3	=	op3
00011730 =00000000                M spss4	=	op4
00011730                            	spTotalLv2	$0F, $0E, $1A, $00
00011730 =0000000F                M sptl1	=	op1
00011730 =0000000E                M sptl2	=	op2
00011730 =0000001A                M sptl3	=	op3
00011730 =00000000                M sptl4	=	op4
00011730 3A                       M 	dc.b	(spfe<<3)+spal
00011731 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011735 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011739 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001173D 060F 0602                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011741 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011745 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011749 0F1A 0E00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001174D 4E41 54                  M 	dc.b	'NAT'
00011750                            
00011750                            	; Patch $0C
00011750                            	; $FD
00011750                            	; $09, $03, $00, $00, 	$1F, $1F, $1F, $1F
00011750                            	; $10, $0C, $0C, $0C,	$0B, $1F, $10, $05
00011750                            	; $1F, $2F, $4F, $2F, 	$09, $80, $8E, $88
00011750                            	spAlgorithm	$05
00011750 =0000000D                M spatnum	=	spatnum+1
00011750 =00000005                M spal	=	val
00011750                            	spFeedback	$07
00011750 =00000007                M spfe	=	val
00011750                            	spDetune	$00, $00, $00, $00
00011750 =00000000                M spde1	=	op1
00011750 =00000000                M spde2	=	op2
00011750 =00000000                M spde3	=	op3
00011750 =00000000                M spde4	=	op4
00011750                            	spMultiple	$09, $00, $03, $00
00011750 =00000009                M spmu1	=	op1
00011750 =00000000                M spmu2	=	op2
00011750 =00000003                M spmu3	=	op3
00011750 =00000000                M spmu4	=	op4
00011750                            	spRateScale	$00, $00, $00, $00
00011750 =00000000                M sprs1	=	op1
00011750 =00000000                M sprs2	=	op2
00011750 =00000000                M sprs3	=	op3
00011750 =00000000                M sprs4	=	op4
00011750                            	spAttackRt	$1F, $1F, $1F, $1F
00011750 =0000001F                M spar1	=	op1
00011750 =0000001F                M spar2	=	op2
00011750 =0000001F                M spar3	=	op3
00011750 =0000001F                M spar4	=	op4
00011750                            	spAmpMod	$00, $00, $00, $00
00011750 =00000000                M spam1	=	op1
00011750 =00000000                M spam2	=	op2
00011750 =00000000                M spam3	=	op3
00011750 =00000000                M spam4	=	op4
00011750                            	spSustainRt	$10, $0C, $0C, $0C
00011750 =00000010                M spsr1	=	op1
00011750 =0000000C                M spsr2	=	op2
00011750 =0000000C                M spsr3	=	op3
00011750 =0000000C                M spsr4	=	op4
00011750                            	spDecayRt	$0B, $10, $1F, $05
00011750 =0000000B                M spdr1	=	op1
00011750 =00000010                M spdr2	=	op2
00011750 =0000001F                M spdr3	=	op3
00011750 =00000005                M spdr4	=	op4
00011750                            	spSustainLv	$01, $04, $02, $02
00011750 =00000001                M spsl1	=	op1
00011750 =00000004                M spsl2	=	op2
00011750 =00000002                M spsl3	=	op3
00011750 =00000002                M spsl4	=	op4
00011750                            	spReleaseRt	$0F, $0F, $0F, $0F
00011750 =0000000F                M sprr1	=	op1
00011750 =0000000F                M sprr2	=	op2
00011750 =0000000F                M sprr3	=	op3
00011750 =0000000F                M sprr4	=	op4
00011750                            	spSSGEG		$00, $00, $00, $00
00011750 =00000000                M spss1	=	op1
00011750 =00000000                M spss2	=	op2
00011750 =00000000                M spss3	=	op3
00011750 =00000000                M spss4	=	op4
00011750                            	spTotalLv2	$09, $8E, $80, $88
00011750 =00000009                M sptl1	=	op1
00011750 =0000008E                M sptl2	=	op2
00011750 =00000080                M sptl3	=	op3
00011750 =00000088                M sptl4	=	op4
00011750 3D                       M 	dc.b	(spfe<<3)+spal
00011751 0903 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011755 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011759 100C 0C0C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001175D 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011761 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011765 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011769 0980 8E88                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001176D 4E41 54                  M 	dc.b	'NAT'
00011770                            
00011770                            	; Patch $0D
00011770                            	; $3C
00011770                            	; $05, $01, $0A, $01,	$56, $5C, $5C, $5C
00011770                            	; $0E, $11, $11, $11,	$09, $0A, $06, $0A
00011770                            	; $4F, $3F, $3F, $3F,	$1F, $00, $2B, $00
00011770                            	spAlgorithm	$04
00011770 =0000000E                M spatnum	=	spatnum+1
00011770 =00000004                M spal	=	val
00011770                            	spFeedback	$07
00011770 =00000007                M spfe	=	val
00011770                            	spDetune	$00, $00, $00, $00
00011770 =00000000                M spde1	=	op1
00011770 =00000000                M spde2	=	op2
00011770 =00000000                M spde3	=	op3
00011770 =00000000                M spde4	=	op4
00011770                            	spMultiple	$05, $0A, $01, $01
00011770 =00000005                M spmu1	=	op1
00011770 =0000000A                M spmu2	=	op2
00011770 =00000001                M spmu3	=	op3
00011770 =00000001                M spmu4	=	op4
00011770                            	spRateScale	$01, $01, $01, $01
00011770 =00000001                M sprs1	=	op1
00011770 =00000001                M sprs2	=	op2
00011770 =00000001                M sprs3	=	op3
00011770 =00000001                M sprs4	=	op4
00011770                            	spAttackRt	$16, $1C, $1C, $1C
00011770 =00000016                M spar1	=	op1
00011770 =0000001C                M spar2	=	op2
00011770 =0000001C                M spar3	=	op3
00011770 =0000001C                M spar4	=	op4
00011770                            	spAmpMod	$00, $00, $00, $00
00011770 =00000000                M spam1	=	op1
00011770 =00000000                M spam2	=	op2
00011770 =00000000                M spam3	=	op3
00011770 =00000000                M spam4	=	op4
00011770                            	spSustainRt	$0E, $11, $11, $11
00011770 =0000000E                M spsr1	=	op1
00011770 =00000011                M spsr2	=	op2
00011770 =00000011                M spsr3	=	op3
00011770 =00000011                M spsr4	=	op4
00011770                            	spDecayRt	$09, $06, $0A, $0A
00011770 =00000009                M spdr1	=	op1
00011770 =00000006                M spdr2	=	op2
00011770 =0000000A                M spdr3	=	op3
00011770 =0000000A                M spdr4	=	op4
00011770                            	spSustainLv	$04, $03, $03, $03
00011770 =00000004                M spsl1	=	op1
00011770 =00000003                M spsl2	=	op2
00011770 =00000003                M spsl3	=	op3
00011770 =00000003                M spsl4	=	op4
00011770                            	spReleaseRt	$0F, $0F, $0F, $0F
00011770 =0000000F                M sprr1	=	op1
00011770 =0000000F                M sprr2	=	op2
00011770 =0000000F                M sprr3	=	op3
00011770 =0000000F                M sprr4	=	op4
00011770                            	spSSGEG		$00, $00, $00, $00
00011770 =00000000                M spss1	=	op1
00011770 =00000000                M spss2	=	op2
00011770 =00000000                M spss3	=	op3
00011770 =00000000                M spss4	=	op4
00011770                            	spTotalLv2	$1F, $2B, $00, $00
00011770 =0000001F                M sptl1	=	op1
00011770 =0000002B                M sptl2	=	op2
00011770 =00000000                M sptl3	=	op3
00011770 =00000000                M sptl4	=	op4
00011770 3C                       M 	dc.b	(spfe<<3)+spal
00011771 0501 0A01                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011775 565C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011779 0E11 1111                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001177D 090A 060A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011781 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011785 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011789 1F00 2B00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001178D 4E41 54                  M 	dc.b	'NAT'
00011790                            
00011790                            	; Patch $0E
00011790                            	; $05
00011790                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $1F
00011790                            	; $12, $0C, $0C, $0C,	$12, $08, $08, $08
00011790                            	; $1F, $5F, $5F, $5F,	$07, $00, $00, $00
00011790                            	spAlgorithm	$05
00011790 =0000000F                M spatnum	=	spatnum+1
00011790 =00000005                M spal	=	val
00011790                            	spFeedback	$00
00011790 =00000000                M spfe	=	val
00011790                            	spDetune	$00, $00, $00, $00
00011790 =00000000                M spde1	=	op1
00011790 =00000000                M spde2	=	op2
00011790 =00000000                M spde3	=	op3
00011790 =00000000                M spde4	=	op4
00011790                            	spMultiple	$00, $00, $00, $00
00011790 =00000000                M spmu1	=	op1
00011790 =00000000                M spmu2	=	op2
00011790 =00000000                M spmu3	=	op3
00011790 =00000000                M spmu4	=	op4
00011790                            	spRateScale	$00, $00, $00, $00
00011790 =00000000                M sprs1	=	op1
00011790 =00000000                M sprs2	=	op2
00011790 =00000000                M sprs3	=	op3
00011790 =00000000                M sprs4	=	op4
00011790                            	spAttackRt	$1F, $1F, $1F, $1F
00011790 =0000001F                M spar1	=	op1
00011790 =0000001F                M spar2	=	op2
00011790 =0000001F                M spar3	=	op3
00011790 =0000001F                M spar4	=	op4
00011790                            	spAmpMod	$00, $00, $00, $00
00011790 =00000000                M spam1	=	op1
00011790 =00000000                M spam2	=	op2
00011790 =00000000                M spam3	=	op3
00011790 =00000000                M spam4	=	op4
00011790                            	spSustainRt	$12, $0C, $0C, $0C
00011790 =00000012                M spsr1	=	op1
00011790 =0000000C                M spsr2	=	op2
00011790 =0000000C                M spsr3	=	op3
00011790 =0000000C                M spsr4	=	op4
00011790                            	spDecayRt	$12, $08, $08, $08
00011790 =00000012                M spdr1	=	op1
00011790 =00000008                M spdr2	=	op2
00011790 =00000008                M spdr3	=	op3
00011790 =00000008                M spdr4	=	op4
00011790                            	spSustainLv	$01, $05, $05, $05
00011790 =00000001                M spsl1	=	op1
00011790 =00000005                M spsl2	=	op2
00011790 =00000005                M spsl3	=	op3
00011790 =00000005                M spsl4	=	op4
00011790                            	spReleaseRt	$0F, $0F, $0F, $0F
00011790 =0000000F                M sprr1	=	op1
00011790 =0000000F                M sprr2	=	op2
00011790 =0000000F                M sprr3	=	op3
00011790 =0000000F                M sprr4	=	op4
00011790                            	spSSGEG		$00, $00, $00, $00
00011790 =00000000                M spss1	=	op1
00011790 =00000000                M spss2	=	op2
00011790 =00000000                M spss3	=	op3
00011790 =00000000                M spss4	=	op4
00011790                            	spTotalLv2	$07, $00, $00, $00
00011790 =00000007                M sptl1	=	op1
00011790 =00000000                M sptl2	=	op2
00011790 =00000000                M sptl3	=	op3
00011790 =00000000                M sptl4	=	op4
00011790 05                       M 	dc.b	(spfe<<3)+spal
00011791 0000 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011795 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011799 120C 0C0C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001179D 1208 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117A1 1F5F 5F5F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117A9 0700 0000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000117AD 4E41 54                  M 	dc.b	'NAT'
000117B0                            
000117B0                            	; Patch $0F
000117B0                            	; $39
000117B0                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
000117B0                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
000117B0                            	; $1F, $2F, $4F, $2F,	$0E, $07, $04, $00
000117B0                            	spAlgorithm	$01
000117B0 =00000010                M spatnum	=	spatnum+1
000117B0 =00000001                M spal	=	val
000117B0                            	spFeedback	$07
000117B0 =00000007                M spfe	=	val
000117B0                            	spDetune	$02, $01, $03, $03
000117B0 =00000002                M spde1	=	op1
000117B0 =00000001                M spde2	=	op2
000117B0 =00000003                M spde3	=	op3
000117B0 =00000003                M spde4	=	op4
000117B0                            	spMultiple	$01, $00, $00, $02
000117B0 =00000001                M spmu1	=	op1
000117B0 =00000000                M spmu2	=	op2
000117B0 =00000000                M spmu3	=	op3
000117B0 =00000002                M spmu4	=	op4
000117B0                            	spRateScale	$00, $00, $00, $00
000117B0 =00000000                M sprs1	=	op1
000117B0 =00000000                M sprs2	=	op2
000117B0 =00000000                M sprs3	=	op3
000117B0 =00000000                M sprs4	=	op4
000117B0                            	spAttackRt	$1F, $1F, $1F, $1F
000117B0 =0000001F                M spar1	=	op1
000117B0 =0000001F                M spar2	=	op2
000117B0 =0000001F                M spar3	=	op3
000117B0 =0000001F                M spar4	=	op4
000117B0                            	spAmpMod	$00, $00, $00, $00
000117B0 =00000000                M spam1	=	op1
000117B0 =00000000                M spam2	=	op2
000117B0 =00000000                M spam3	=	op3
000117B0 =00000000                M spam4	=	op4
000117B0                            	spSustainRt	$05, $09, $18, $02
000117B0 =00000005                M spsr1	=	op1
000117B0 =00000009                M spsr2	=	op2
000117B0 =00000018                M spsr3	=	op3
000117B0 =00000002                M spsr4	=	op4
000117B0                            	spDecayRt	$0B, $10, $1F, $05
000117B0 =0000000B                M spdr1	=	op1
000117B0 =00000010                M spdr2	=	op2
000117B0 =0000001F                M spdr3	=	op3
000117B0 =00000005                M spdr4	=	op4
000117B0                            	spSustainLv	$01, $04, $02, $02
000117B0 =00000001                M spsl1	=	op1
000117B0 =00000004                M spsl2	=	op2
000117B0 =00000002                M spsl3	=	op3
000117B0 =00000002                M spsl4	=	op4
000117B0                            	spReleaseRt	$0F, $0F, $0F, $0F
000117B0 =0000000F                M sprr1	=	op1
000117B0 =0000000F                M sprr2	=	op2
000117B0 =0000000F                M sprr3	=	op3
000117B0 =0000000F                M sprr4	=	op4
000117B0                            	spSSGEG		$00, $00, $00, $00
000117B0 =00000000                M spss1	=	op1
000117B0 =00000000                M spss2	=	op2
000117B0 =00000000                M spss3	=	op3
000117B0 =00000000                M spss4	=	op4
000117B0                            	spTotalLv	$0E, $04, $07, $00
000117B0 =0000000E                M sptl1	=	op1
000117B0 =00000004                M sptl2	=	op2
000117B0 =00000007                M sptl3	=	op3
000117B0 =00000000                M sptl4	=	op4
000117B0 39                       M 	dc.b	(spfe<<3)+spal
000117B1 =00000080                M sptlmask4	set	$80
000117B1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000117B1 =00000000                M sptlmask3	set	((spal>=4)<<7)
000117B1 =00000000                M sptlmask1	set	((spal=7)<<7)
000117B1 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117B5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117B9 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117BD 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117C1 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117C5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117C9 0E07 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117CD 4E41 54                  M 	dc.b	'NAT'
000117D0                            
000117D0                            	; Patch $10
000117D0                            	; $35
000117D0                            	; $14, $1A, $04, $09,	$0E, $10, $11, $0E
000117D0                            	; $0C, $15, $03, $06,	$16, $0E, $09, $10
000117D0                            	; $2F, $2F, $4F, $4F,	$2F, $12, $12, $80
000117D0                            	spAlgorithm	$05
000117D0 =00000011                M spatnum	=	spatnum+1
000117D0 =00000005                M spal	=	val
000117D0                            	spFeedback	$06
000117D0 =00000006                M spfe	=	val
000117D0                            	spDetune	$01, $00, $01, $00
000117D0 =00000001                M spde1	=	op1
000117D0 =00000000                M spde2	=	op2
000117D0 =00000001                M spde3	=	op3
000117D0 =00000000                M spde4	=	op4
000117D0                            	spMultiple	$04, $04, $0A, $09
000117D0 =00000004                M spmu1	=	op1
000117D0 =00000004                M spmu2	=	op2
000117D0 =0000000A                M spmu3	=	op3
000117D0 =00000009                M spmu4	=	op4
000117D0                            	spRateScale	$00, $00, $00, $00
000117D0 =00000000                M sprs1	=	op1
000117D0 =00000000                M sprs2	=	op2
000117D0 =00000000                M sprs3	=	op3
000117D0 =00000000                M sprs4	=	op4
000117D0                            	spAttackRt	$0E, $11, $10, $0E
000117D0 =0000000E                M spar1	=	op1
000117D0 =00000011                M spar2	=	op2
000117D0 =00000010                M spar3	=	op3
000117D0 =0000000E                M spar4	=	op4
000117D0                            	spAmpMod	$00, $00, $00, $00
000117D0 =00000000                M spam1	=	op1
000117D0 =00000000                M spam2	=	op2
000117D0 =00000000                M spam3	=	op3
000117D0 =00000000                M spam4	=	op4
000117D0                            	spSustainRt	$0C, $03, $15, $06
000117D0 =0000000C                M spsr1	=	op1
000117D0 =00000003                M spsr2	=	op2
000117D0 =00000015                M spsr3	=	op3
000117D0 =00000006                M spsr4	=	op4
000117D0                            	spDecayRt	$16, $09, $0E, $10
000117D0 =00000016                M spdr1	=	op1
000117D0 =00000009                M spdr2	=	op2
000117D0 =0000000E                M spdr3	=	op3
000117D0 =00000010                M spdr4	=	op4
000117D0                            	spSustainLv	$02, $04, $02, $04
000117D0 =00000002                M spsl1	=	op1
000117D0 =00000004                M spsl2	=	op2
000117D0 =00000002                M spsl3	=	op3
000117D0 =00000004                M spsl4	=	op4
000117D0                            	spReleaseRt	$0F, $0F, $0F, $0F
000117D0 =0000000F                M sprr1	=	op1
000117D0 =0000000F                M sprr2	=	op2
000117D0 =0000000F                M sprr3	=	op3
000117D0 =0000000F                M sprr4	=	op4
000117D0                            	spSSGEG		$00, $00, $00, $00
000117D0 =00000000                M spss1	=	op1
000117D0 =00000000                M spss2	=	op2
000117D0 =00000000                M spss3	=	op3
000117D0 =00000000                M spss4	=	op4
000117D0                            	spTotalLv2	$2F, $12, $12, $80
000117D0 =0000002F                M sptl1	=	op1
000117D0 =00000012                M sptl2	=	op2
000117D0 =00000012                M sptl3	=	op3
000117D0 =00000080                M sptl4	=	op4
000117D0 35                       M 	dc.b	(spfe<<3)+spal
000117D1 141A 0409                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117D5 0E10 110E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117D9 0C15 0306                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117DD 160E 0910                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117E1 2F2F 4F4F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117E5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117E9 2F12 1280                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000117ED 4E41 54                  M 	dc.b	'NAT'
000117F0                            
000117F0                            	; Patch $11
000117F0                            	; $38
000117F0                            	; $01, $00, $00, $00,	$1F, $1F, $1F, $1F
000117F0                            	; $09, $09, $09, $0B,	$00, $00, $00, $00
000117F0                            	; $FF, $FF, $FF, $FF,	$5C, $22, $27, $80
000117F0                            	spAlgorithm	$00
000117F0 =00000012                M spatnum	=	spatnum+1
000117F0 =00000000                M spal	=	val
000117F0                            	spFeedback	$07
000117F0 =00000007                M spfe	=	val
000117F0                            	spDetune	$00, $00, $00, $00
000117F0 =00000000                M spde1	=	op1
000117F0 =00000000                M spde2	=	op2
000117F0 =00000000                M spde3	=	op3
000117F0 =00000000                M spde4	=	op4
000117F0                            	spMultiple	$01, $00, $00, $00
000117F0 =00000001                M spmu1	=	op1
000117F0 =00000000                M spmu2	=	op2
000117F0 =00000000                M spmu3	=	op3
000117F0 =00000000                M spmu4	=	op4
000117F0                            	spRateScale	$00, $00, $00, $00
000117F0 =00000000                M sprs1	=	op1
000117F0 =00000000                M sprs2	=	op2
000117F0 =00000000                M sprs3	=	op3
000117F0 =00000000                M sprs4	=	op4
000117F0                            	spAttackRt	$1F, $1F, $1F, $1F
000117F0 =0000001F                M spar1	=	op1
000117F0 =0000001F                M spar2	=	op2
000117F0 =0000001F                M spar3	=	op3
000117F0 =0000001F                M spar4	=	op4
000117F0                            	spAmpMod	$00, $00, $00, $00
000117F0 =00000000                M spam1	=	op1
000117F0 =00000000                M spam2	=	op2
000117F0 =00000000                M spam3	=	op3
000117F0 =00000000                M spam4	=	op4
000117F0                            	spSustainRt	$09, $09, $09, $0B
000117F0 =00000009                M spsr1	=	op1
000117F0 =00000009                M spsr2	=	op2
000117F0 =00000009                M spsr3	=	op3
000117F0 =0000000B                M spsr4	=	op4
000117F0                            	spDecayRt	$00, $00, $00, $00
000117F0 =00000000                M spdr1	=	op1
000117F0 =00000000                M spdr2	=	op2
000117F0 =00000000                M spdr3	=	op3
000117F0 =00000000                M spdr4	=	op4
000117F0                            	spSustainLv	$0F, $0F, $0F, $0F
000117F0 =0000000F                M spsl1	=	op1
000117F0 =0000000F                M spsl2	=	op2
000117F0 =0000000F                M spsl3	=	op3
000117F0 =0000000F                M spsl4	=	op4
000117F0                            	spReleaseRt	$0F, $0F, $0F, $0F
000117F0 =0000000F                M sprr1	=	op1
000117F0 =0000000F                M sprr2	=	op2
000117F0 =0000000F                M sprr3	=	op3
000117F0 =0000000F                M sprr4	=	op4
000117F0                            	spSSGEG		$00, $00, $00, $00
000117F0 =00000000                M spss1	=	op1
000117F0 =00000000                M spss2	=	op2
000117F0 =00000000                M spss3	=	op3
000117F0 =00000000                M spss4	=	op4
000117F0                            	spTotalLv2	$5C, $27, $22, $80
000117F0 =0000005C                M sptl1	=	op1
000117F0 =00000027                M sptl2	=	op2
000117F0 =00000022                M sptl3	=	op3
000117F0 =00000080                M sptl4	=	op4
000117F0 38                       M 	dc.b	(spfe<<3)+spal
000117F1 0100 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117F5 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117F9 0909 090B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117FD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011801 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011805 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011809 5C22 2780                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001180D 4E41 54                  M 	dc.b	'NAT'
00011810                            
00011810                            	; Patch $12
00011810                            	; $3B
00011810                            	; $3C, $39, $30, $31,	$DF, $1F, $1F, $DF
00011810                            	; $04, $05, $04, $01,	$04, $04, $04, $02
00011810                            	; $FF, $0F, $1F, $AF,	$29, $20, $0F, $00
00011810                            	spAlgorithm	$03
00011810 =00000013                M spatnum	=	spatnum+1
00011810 =00000003                M spal	=	val
00011810                            	spFeedback	$07
00011810 =00000007                M spfe	=	val
00011810                            	spDetune	$03, $03, $03, $03
00011810 =00000003                M spde1	=	op1
00011810 =00000003                M spde2	=	op2
00011810 =00000003                M spde3	=	op3
00011810 =00000003                M spde4	=	op4
00011810                            	spMultiple	$0C, $00, $09, $01
00011810 =0000000C                M spmu1	=	op1
00011810 =00000000                M spmu2	=	op2
00011810 =00000009                M spmu3	=	op3
00011810 =00000001                M spmu4	=	op4
00011810                            	spRateScale	$03, $00, $00, $03
00011810 =00000003                M sprs1	=	op1
00011810 =00000000                M sprs2	=	op2
00011810 =00000000                M sprs3	=	op3
00011810 =00000003                M sprs4	=	op4
00011810                            	spAttackRt	$1F, $1F, $1F, $1F
00011810 =0000001F                M spar1	=	op1
00011810 =0000001F                M spar2	=	op2
00011810 =0000001F                M spar3	=	op3
00011810 =0000001F                M spar4	=	op4
00011810                            	spAmpMod	$00, $00, $00, $00
00011810 =00000000                M spam1	=	op1
00011810 =00000000                M spam2	=	op2
00011810 =00000000                M spam3	=	op3
00011810 =00000000                M spam4	=	op4
00011810                            	spSustainRt	$04, $04, $05, $01
00011810 =00000004                M spsr1	=	op1
00011810 =00000004                M spsr2	=	op2
00011810 =00000005                M spsr3	=	op3
00011810 =00000001                M spsr4	=	op4
00011810                            	spDecayRt	$04, $04, $04, $02
00011810 =00000004                M spdr1	=	op1
00011810 =00000004                M spdr2	=	op2
00011810 =00000004                M spdr3	=	op3
00011810 =00000002                M spdr4	=	op4
00011810                            	spSustainLv	$0F, $01, $00, $0A
00011810 =0000000F                M spsl1	=	op1
00011810 =00000001                M spsl2	=	op2
00011810 =00000000                M spsl3	=	op3
00011810 =0000000A                M spsl4	=	op4
00011810                            	spReleaseRt	$0F, $0F, $0F, $0F
00011810 =0000000F                M sprr1	=	op1
00011810 =0000000F                M sprr2	=	op2
00011810 =0000000F                M sprr3	=	op3
00011810 =0000000F                M sprr4	=	op4
00011810                            	spSSGEG		$00, $00, $00, $00
00011810 =00000000                M spss1	=	op1
00011810 =00000000                M spss2	=	op2
00011810 =00000000                M spss3	=	op3
00011810 =00000000                M spss4	=	op4
00011810                            	spTotalLv2	$29, $0F, $20, $00
00011810 =00000029                M sptl1	=	op1
00011810 =0000000F                M sptl2	=	op2
00011810 =00000020                M sptl3	=	op3
00011810 =00000000                M sptl4	=	op4
00011810 3B                       M 	dc.b	(spfe<<3)+spal
00011811 3C39 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011815 DF1F 1FDF                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011819 0405 0401                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001181D 0404 0402                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011821 FF0F 1FAF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011825 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011829 2920 0F00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001182D 4E41 54                  M 	dc.b	'NAT'
00011830                            
00011830                            	; Patch $13
00011830                            	; $3A
00011830                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011830                            	; $05, $18, $09, $02,	$06, $0F, $06, $02
00011830                            	; $1F, $2F, $4F, $2F,	$0F, $0E, $0E, $00
00011830                            	spAlgorithm	$02
00011830 =00000014                M spatnum	=	spatnum+1
00011830 =00000002                M spal	=	val
00011830                            	spFeedback	$07
00011830 =00000007                M spfe	=	val
00011830                            	spDetune	$02, $01, $03, $03
00011830 =00000002                M spde1	=	op1
00011830 =00000001                M spde2	=	op2
00011830 =00000003                M spde3	=	op3
00011830 =00000003                M spde4	=	op4
00011830                            	spMultiple	$01, $00, $00, $02
00011830 =00000001                M spmu1	=	op1
00011830 =00000000                M spmu2	=	op2
00011830 =00000000                M spmu3	=	op3
00011830 =00000002                M spmu4	=	op4
00011830                            	spRateScale	$00, $00, $00, $00
00011830 =00000000                M sprs1	=	op1
00011830 =00000000                M sprs2	=	op2
00011830 =00000000                M sprs3	=	op3
00011830 =00000000                M sprs4	=	op4
00011830                            	spAttackRt	$1F, $1F, $1F, $1F
00011830 =0000001F                M spar1	=	op1
00011830 =0000001F                M spar2	=	op2
00011830 =0000001F                M spar3	=	op3
00011830 =0000001F                M spar4	=	op4
00011830                            	spAmpMod	$00, $00, $00, $00
00011830 =00000000                M spam1	=	op1
00011830 =00000000                M spam2	=	op2
00011830 =00000000                M spam3	=	op3
00011830 =00000000                M spam4	=	op4
00011830                            	spSustainRt	$05, $09, $18, $02
00011830 =00000005                M spsr1	=	op1
00011830 =00000009                M spsr2	=	op2
00011830 =00000018                M spsr3	=	op3
00011830 =00000002                M spsr4	=	op4
00011830                            	spDecayRt	$06, $06, $0F, $02
00011830 =00000006                M spdr1	=	op1
00011830 =00000006                M spdr2	=	op2
00011830 =0000000F                M spdr3	=	op3
00011830 =00000002                M spdr4	=	op4
00011830                            	spSustainLv	$01, $04, $02, $02
00011830 =00000001                M spsl1	=	op1
00011830 =00000004                M spsl2	=	op2
00011830 =00000002                M spsl3	=	op3
00011830 =00000002                M spsl4	=	op4
00011830                            	spReleaseRt	$0F, $0F, $0F, $0F
00011830 =0000000F                M sprr1	=	op1
00011830 =0000000F                M sprr2	=	op2
00011830 =0000000F                M sprr3	=	op3
00011830 =0000000F                M sprr4	=	op4
00011830                            	spSSGEG		$00, $00, $00, $00
00011830 =00000000                M spss1	=	op1
00011830 =00000000                M spss2	=	op2
00011830 =00000000                M spss3	=	op3
00011830 =00000000                M spss4	=	op4
00011830                            	spTotalLv2	$0F, $0E, $0E, $00
00011830 =0000000F                M sptl1	=	op1
00011830 =0000000E                M sptl2	=	op2
00011830 =0000000E                M sptl3	=	op3
00011830 =00000000                M sptl4	=	op4
00011830 3A                       M 	dc.b	(spfe<<3)+spal
00011831 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011835 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011839 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001183D 060F 0602                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011841 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011845 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011849 0F0E 0E00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001184D 4E41 54                  M 	dc.b	'NAT'
00011850                            
00011850                            	; Patch $14
00011850                            	; $07
00011850                            	; $04, $04, $05, $04,	$1F, $1F, $15, $15
00011850                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00011850                            	; $1F, $1F, $1F, $1F,	$7F, $7F, $80, $80
00011850                            	spAlgorithm	$07
00011850 =00000015                M spatnum	=	spatnum+1
00011850 =00000007                M spal	=	val
00011850                            	spFeedback	$00
00011850 =00000000                M spfe	=	val
00011850                            	spDetune	$00, $00, $00, $00
00011850 =00000000                M spde1	=	op1
00011850 =00000000                M spde2	=	op2
00011850 =00000000                M spde3	=	op3
00011850 =00000000                M spde4	=	op4
00011850                            	spMultiple	$04, $05, $04, $04
00011850 =00000004                M spmu1	=	op1
00011850 =00000005                M spmu2	=	op2
00011850 =00000004                M spmu3	=	op3
00011850 =00000004                M spmu4	=	op4
00011850                            	spRateScale	$00, $00, $00, $00
00011850 =00000000                M sprs1	=	op1
00011850 =00000000                M sprs2	=	op2
00011850 =00000000                M sprs3	=	op3
00011850 =00000000                M sprs4	=	op4
00011850                            	spAttackRt	$1F, $15, $1F, $15
00011850 =0000001F                M spar1	=	op1
00011850 =00000015                M spar2	=	op2
00011850 =0000001F                M spar3	=	op3
00011850 =00000015                M spar4	=	op4
00011850                            	spAmpMod	$00, $00, $00, $00
00011850 =00000000                M spam1	=	op1
00011850 =00000000                M spam2	=	op2
00011850 =00000000                M spam3	=	op3
00011850 =00000000                M spam4	=	op4
00011850                            	spSustainRt	$00, $00, $00, $00
00011850 =00000000                M spsr1	=	op1
00011850 =00000000                M spsr2	=	op2
00011850 =00000000                M spsr3	=	op3
00011850 =00000000                M spsr4	=	op4
00011850                            	spDecayRt	$00, $00, $00, $00
00011850 =00000000                M spdr1	=	op1
00011850 =00000000                M spdr2	=	op2
00011850 =00000000                M spdr3	=	op3
00011850 =00000000                M spdr4	=	op4
00011850                            	spSustainLv	$01, $01, $01, $01
00011850 =00000001                M spsl1	=	op1
00011850 =00000001                M spsl2	=	op2
00011850 =00000001                M spsl3	=	op3
00011850 =00000001                M spsl4	=	op4
00011850                            	spReleaseRt	$0F, $0F, $0F, $0F
00011850 =0000000F                M sprr1	=	op1
00011850 =0000000F                M sprr2	=	op2
00011850 =0000000F                M sprr3	=	op3
00011850 =0000000F                M sprr4	=	op4
00011850                            	spSSGEG		$00, $00, $00, $00
00011850 =00000000                M spss1	=	op1
00011850 =00000000                M spss2	=	op2
00011850 =00000000                M spss3	=	op3
00011850 =00000000                M spss4	=	op4
00011850                            	spTotalLv2	$7F, $80, $7F, $80
00011850 =0000007F                M sptl1	=	op1
00011850 =00000080                M sptl2	=	op2
00011850 =0000007F                M sptl3	=	op3
00011850 =00000080                M sptl4	=	op4
00011850 07                       M 	dc.b	(spfe<<3)+spal
00011851 0404 0504                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011855 1F1F 1515                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011859 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001185D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011861 1F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011865 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011869 7F7F 8080                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001186D 4E41 54                  M 	dc.b	'NAT'
00011870                            
00011870                            	; Patch $15
00011870                            	; $00
00011870                            	; $00, $03, $02, $00,	$D9, $DF, $1F, $1F
00011870                            	; $12, $11, $14, $0F,	$0A, $00, $0A, $0D
00011870                            	; $FF, $FF, $FF, $FF,	$22, $07, $27, $00
00011870                            	spAlgorithm	$00
00011870 =00000016                M spatnum	=	spatnum+1
00011870 =00000000                M spal	=	val
00011870                            	spFeedback	$00
00011870 =00000000                M spfe	=	val
00011870                            	spDetune	$00, $00, $00, $00
00011870 =00000000                M spde1	=	op1
00011870 =00000000                M spde2	=	op2
00011870 =00000000                M spde3	=	op3
00011870 =00000000                M spde4	=	op4
00011870                            	spMultiple	$00, $02, $03, $00
00011870 =00000000                M spmu1	=	op1
00011870 =00000002                M spmu2	=	op2
00011870 =00000003                M spmu3	=	op3
00011870 =00000000                M spmu4	=	op4
00011870                            	spRateScale	$03, $00, $03, $00
00011870 =00000003                M sprs1	=	op1
00011870 =00000000                M sprs2	=	op2
00011870 =00000003                M sprs3	=	op3
00011870 =00000000                M sprs4	=	op4
00011870                            	spAttackRt	$19, $1F, $1F, $1F
00011870 =00000019                M spar1	=	op1
00011870 =0000001F                M spar2	=	op2
00011870 =0000001F                M spar3	=	op3
00011870 =0000001F                M spar4	=	op4
00011870                            	spAmpMod	$00, $00, $00, $00
00011870 =00000000                M spam1	=	op1
00011870 =00000000                M spam2	=	op2
00011870 =00000000                M spam3	=	op3
00011870 =00000000                M spam4	=	op4
00011870                            	spSustainRt	$12, $14, $11, $0F
00011870 =00000012                M spsr1	=	op1
00011870 =00000014                M spsr2	=	op2
00011870 =00000011                M spsr3	=	op3
00011870 =0000000F                M spsr4	=	op4
00011870                            	spDecayRt	$0A, $0A, $00, $0D
00011870 =0000000A                M spdr1	=	op1
00011870 =0000000A                M spdr2	=	op2
00011870 =00000000                M spdr3	=	op3
00011870 =0000000D                M spdr4	=	op4
00011870                            	spSustainLv	$0F, $0F, $0F, $0F
00011870 =0000000F                M spsl1	=	op1
00011870 =0000000F                M spsl2	=	op2
00011870 =0000000F                M spsl3	=	op3
00011870 =0000000F                M spsl4	=	op4
00011870                            	spReleaseRt	$0F, $0F, $0F, $0F
00011870 =0000000F                M sprr1	=	op1
00011870 =0000000F                M sprr2	=	op2
00011870 =0000000F                M sprr3	=	op3
00011870 =0000000F                M sprr4	=	op4
00011870                            	spSSGEG		$00, $00, $00, $00
00011870 =00000000                M spss1	=	op1
00011870 =00000000                M spss2	=	op2
00011870 =00000000                M spss3	=	op3
00011870 =00000000                M spss4	=	op4
00011870                            	spTotalLv2	$22, $27, $07, $00
00011870 =00000022                M sptl1	=	op1
00011870 =00000027                M sptl2	=	op2
00011870 =00000007                M sptl3	=	op3
00011870 =00000000                M sptl4	=	op4
00011870 00                       M 	dc.b	(spfe<<3)+spal
00011871 0003 0200                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011875 D9DF 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011879 1211 140F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001187D 0A00 0A0D                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011881 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011885 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011889 2207 2700                M 	dc.b	sptl1,sptl3,sptl2,sptl4
0001188D 4E41 54                  M 	dc.b	'NAT'
00011890                            
00011890                            	; Patch $16
00011890                            	; $20
00011890                            	; $36, $35, $30, $31,	$41, $49, $3B, $4B
00011890                            	; $09, $06, $09, $08,	$01, $03, $02, $A9
00011890                            	; $0F, $0F, $0F, $0F,	$29, $27, $23, $00
00011890                            	spAlgorithm	$00
00011890 =00000017                M spatnum	=	spatnum+1
00011890 =00000000                M spal	=	val
00011890                            	spFeedback	$04
00011890 =00000004                M spfe	=	val
00011890                            	spDetune	$03, $03, $03, $03
00011890 =00000003                M spde1	=	op1
00011890 =00000003                M spde2	=	op2
00011890 =00000003                M spde3	=	op3
00011890 =00000003                M spde4	=	op4
00011890                            	spMultiple	$06, $00, $05, $01
00011890 =00000006                M spmu1	=	op1
00011890 =00000000                M spmu2	=	op2
00011890 =00000005                M spmu3	=	op3
00011890 =00000001                M spmu4	=	op4
00011890                            	spRateScale	$01, $00, $01, $01
00011890 =00000001                M sprs1	=	op1
00011890 =00000000                M sprs2	=	op2
00011890 =00000001                M sprs3	=	op3
00011890 =00000001                M sprs4	=	op4
00011890                            	spAttackRt	$01, $1B, $09, $0B
00011890 =00000001                M spar1	=	op1
00011890 =0000001B                M spar2	=	op2
00011890 =00000009                M spar3	=	op3
00011890 =0000000B                M spar4	=	op4
00011890                            	spAmpMod	$00, $00, $00, $00
00011890 =00000000                M spam1	=	op1
00011890 =00000000                M spam2	=	op2
00011890 =00000000                M spam3	=	op3
00011890 =00000000                M spam4	=	op4
00011890                            	spSustainRt	$09, $09, $06, $08
00011890 =00000009                M spsr1	=	op1
00011890 =00000009                M spsr2	=	op2
00011890 =00000006                M spsr3	=	op3
00011890 =00000008                M spsr4	=	op4
00011890                            	spDecayRt	$01, $02, $03, $A9
00011890 =00000001                M spdr1	=	op1
00011890 =00000002                M spdr2	=	op2
00011890 =00000003                M spdr3	=	op3
00011890 =000000A9                M spdr4	=	op4
00011890                            	spSustainLv	$00, $00, $00, $00
00011890 =00000000                M spsl1	=	op1
00011890 =00000000                M spsl2	=	op2
00011890 =00000000                M spsl3	=	op3
00011890 =00000000                M spsl4	=	op4
00011890                            	spReleaseRt	$0F, $0F, $0F, $0F
00011890 =0000000F                M sprr1	=	op1
00011890 =0000000F                M sprr2	=	op2
00011890 =0000000F                M sprr3	=	op3
00011890 =0000000F                M sprr4	=	op4
00011890                            	spSSGEG		$00, $00, $00, $00
00011890 =00000000                M spss1	=	op1
00011890 =00000000                M spss2	=	op2
00011890 =00000000                M spss3	=	op3
00011890 =00000000                M spss4	=	op4
00011890                            	spTotalLv2	$29, $23, $27, $00
00011890 =00000029                M sptl1	=	op1
00011890 =00000023                M sptl2	=	op2
00011890 =00000027                M sptl3	=	op3
00011890 =00000000                M sptl4	=	op4
00011890 20                       M 	dc.b	(spfe<<3)+spal
00011891 3635 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011895 4149 1B4B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011899 0906 0908                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001189D 0103 02A9                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118A1 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118A9 2927 2300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000118AD 4E41 54                  M 	dc.b	'NAT'
000118B0                            
000118B0                            	; Patch $17
000118B0                            	; $30
000118B0                            	; $30, $30, $30, $30,	$9E, $D8, $DC, $DC
000118B0                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
000118B0                            	; $BF, $BF, $BF, $BF,	$10, $3A, $10, $00
000118B0                            	spAlgorithm	$00
000118B0 =00000018                M spatnum	=	spatnum+1
000118B0 =00000000                M spal	=	val
000118B0                            	spFeedback	$06
000118B0 =00000006                M spfe	=	val
000118B0                            	spDetune	$03, $03, $03, $03
000118B0 =00000003                M spde1	=	op1
000118B0 =00000003                M spde2	=	op2
000118B0 =00000003                M spde3	=	op3
000118B0 =00000003                M spde4	=	op4
000118B0                            	spMultiple	$00, $00, $00, $00
000118B0 =00000000                M spmu1	=	op1
000118B0 =00000000                M spmu2	=	op2
000118B0 =00000000                M spmu3	=	op3
000118B0 =00000000                M spmu4	=	op4
000118B0                            	spRateScale	$02, $03, $03, $03
000118B0 =00000002                M sprs1	=	op1
000118B0 =00000003                M sprs2	=	op2
000118B0 =00000003                M sprs3	=	op3
000118B0 =00000003                M sprs4	=	op4
000118B0                            	spAttackRt	$1E, $1C, $18, $1C
000118B0 =0000001E                M spar1	=	op1
000118B0 =0000001C                M spar2	=	op2
000118B0 =00000018                M spar3	=	op3
000118B0 =0000001C                M spar4	=	op4
000118B0                            	spAmpMod	$00, $00, $00, $00
000118B0 =00000000                M spam1	=	op1
000118B0 =00000000                M spam2	=	op2
000118B0 =00000000                M spam3	=	op3
000118B0 =00000000                M spam4	=	op4
000118B0                            	spSustainRt	$0E, $04, $0A, $05
000118B0 =0000000E                M spsr1	=	op1
000118B0 =00000004                M spsr2	=	op2
000118B0 =0000000A                M spsr3	=	op3
000118B0 =00000005                M spsr4	=	op4
000118B0                            	spDecayRt	$08, $08, $08, $08
000118B0 =00000008                M spdr1	=	op1
000118B0 =00000008                M spdr2	=	op2
000118B0 =00000008                M spdr3	=	op3
000118B0 =00000008                M spdr4	=	op4
000118B0                            	spSustainLv	$0B, $0B, $0B, $0B
000118B0 =0000000B                M spsl1	=	op1
000118B0 =0000000B                M spsl2	=	op2
000118B0 =0000000B                M spsl3	=	op3
000118B0 =0000000B                M spsl4	=	op4
000118B0                            	spReleaseRt	$0F, $0F, $0F, $0F
000118B0 =0000000F                M sprr1	=	op1
000118B0 =0000000F                M sprr2	=	op2
000118B0 =0000000F                M sprr3	=	op3
000118B0 =0000000F                M sprr4	=	op4
000118B0                            	spSSGEG		$00, $00, $00, $00
000118B0 =00000000                M spss1	=	op1
000118B0 =00000000                M spss2	=	op2
000118B0 =00000000                M spss3	=	op3
000118B0 =00000000                M spss4	=	op4
000118B0                            	spTotalLv2	$10, $10, $3A, $00
000118B0 =00000010                M sptl1	=	op1
000118B0 =00000010                M sptl2	=	op2
000118B0 =0000003A                M sptl3	=	op3
000118B0 =00000000                M sptl4	=	op4
000118B0 30                       M 	dc.b	(spfe<<3)+spal
000118B1 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118B5 9ED8 DCDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118B9 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118BD 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118C1 BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118C5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118C9 103A 1000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000118CD 4E41 54                  M 	dc.b	'NAT'
000118D0                            
000118D0                            	; Patch $18
000118D0                            	; $04
000118D0                            	; $00, $01, $00, $05,	$0F, $1F, $0F, $1F
000118D0                            	; $00, $00, $00, $00,	$00, $00, $00, $00
000118D0                            	; $8F, $8F, $8F, $8F,	$1F, $8D, $1F, $80
000118D0                            	spAlgorithm	$04
000118D0 =00000019                M spatnum	=	spatnum+1
000118D0 =00000004                M spal	=	val
000118D0                            	spFeedback	$00
000118D0 =00000000                M spfe	=	val
000118D0                            	spDetune	$00, $00, $00, $00
000118D0 =00000000                M spde1	=	op1
000118D0 =00000000                M spde2	=	op2
000118D0 =00000000                M spde3	=	op3
000118D0 =00000000                M spde4	=	op4
000118D0                            	spMultiple	$00, $00, $01, $05
000118D0 =00000000                M spmu1	=	op1
000118D0 =00000000                M spmu2	=	op2
000118D0 =00000001                M spmu3	=	op3
000118D0 =00000005                M spmu4	=	op4
000118D0                            	spRateScale	$00, $00, $00, $00
000118D0 =00000000                M sprs1	=	op1
000118D0 =00000000                M sprs2	=	op2
000118D0 =00000000                M sprs3	=	op3
000118D0 =00000000                M sprs4	=	op4
000118D0                            	spAttackRt	$0F, $0F, $1F, $1F
000118D0 =0000000F                M spar1	=	op1
000118D0 =0000000F                M spar2	=	op2
000118D0 =0000001F                M spar3	=	op3
000118D0 =0000001F                M spar4	=	op4
000118D0                            	spAmpMod	$00, $00, $00, $00
000118D0 =00000000                M spam1	=	op1
000118D0 =00000000                M spam2	=	op2
000118D0 =00000000                M spam3	=	op3
000118D0 =00000000                M spam4	=	op4
000118D0                            	spSustainRt	$00, $00, $00, $00
000118D0 =00000000                M spsr1	=	op1
000118D0 =00000000                M spsr2	=	op2
000118D0 =00000000                M spsr3	=	op3
000118D0 =00000000                M spsr4	=	op4
000118D0                            	spDecayRt	$00, $00, $00, $00
000118D0 =00000000                M spdr1	=	op1
000118D0 =00000000                M spdr2	=	op2
000118D0 =00000000                M spdr3	=	op3
000118D0 =00000000                M spdr4	=	op4
000118D0                            	spSustainLv	$08, $08, $08, $08
000118D0 =00000008                M spsl1	=	op1
000118D0 =00000008                M spsl2	=	op2
000118D0 =00000008                M spsl3	=	op3
000118D0 =00000008                M spsl4	=	op4
000118D0                            	spReleaseRt	$0F, $0F, $0F, $0F
000118D0 =0000000F                M sprr1	=	op1
000118D0 =0000000F                M sprr2	=	op2
000118D0 =0000000F                M sprr3	=	op3
000118D0 =0000000F                M sprr4	=	op4
000118D0                            	spSSGEG		$00, $00, $00, $00
000118D0 =00000000                M spss1	=	op1
000118D0 =00000000                M spss2	=	op2
000118D0 =00000000                M spss3	=	op3
000118D0 =00000000                M spss4	=	op4
000118D0                            	spTotalLv2	$1F, $1F, $8D, $80
000118D0 =0000001F                M sptl1	=	op1
000118D0 =0000001F                M sptl2	=	op2
000118D0 =0000008D                M sptl3	=	op3
000118D0 =00000080                M sptl4	=	op4
000118D0 04                       M 	dc.b	(spfe<<3)+spal
000118D1 0001 0005                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118D5 0F1F 0F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118D9 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118DD 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118E1 8F8F 8F8F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118E5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118E9 1F8D 1F80                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000118ED 4E41 54                  M 	dc.b	'NAT'
000118F0                            
000118F0                            	; Patch $19
000118F0                            	; $3C
000118F0                            	; $05, $01, $0A, $01,	$56, $5C, $5C, $5C
000118F0                            	; $0E, $11, $11, $11,	$09, $0A, $06, $0A
000118F0                            	; $4F, $3F, $3F, $3F,	$17, $80, $20, $80
000118F0                            	spAlgorithm	$04
000118F0 =0000001A                M spatnum	=	spatnum+1
000118F0 =00000004                M spal	=	val
000118F0                            	spFeedback	$07
000118F0 =00000007                M spfe	=	val
000118F0                            	spDetune	$00, $00, $00, $00
000118F0 =00000000                M spde1	=	op1
000118F0 =00000000                M spde2	=	op2
000118F0 =00000000                M spde3	=	op3
000118F0 =00000000                M spde4	=	op4
000118F0                            	spMultiple	$05, $0A, $01, $01
000118F0 =00000005                M spmu1	=	op1
000118F0 =0000000A                M spmu2	=	op2
000118F0 =00000001                M spmu3	=	op3
000118F0 =00000001                M spmu4	=	op4
000118F0                            	spRateScale	$01, $01, $01, $01
000118F0 =00000001                M sprs1	=	op1
000118F0 =00000001                M sprs2	=	op2
000118F0 =00000001                M sprs3	=	op3
000118F0 =00000001                M sprs4	=	op4
000118F0                            	spAttackRt	$16, $1C, $1C, $1C
000118F0 =00000016                M spar1	=	op1
000118F0 =0000001C                M spar2	=	op2
000118F0 =0000001C                M spar3	=	op3
000118F0 =0000001C                M spar4	=	op4
000118F0                            	spAmpMod	$00, $00, $00, $00
000118F0 =00000000                M spam1	=	op1
000118F0 =00000000                M spam2	=	op2
000118F0 =00000000                M spam3	=	op3
000118F0 =00000000                M spam4	=	op4
000118F0                            	spSustainRt	$0E, $11, $11, $11
000118F0 =0000000E                M spsr1	=	op1
000118F0 =00000011                M spsr2	=	op2
000118F0 =00000011                M spsr3	=	op3
000118F0 =00000011                M spsr4	=	op4
000118F0                            	spDecayRt	$09, $06, $0A, $0A
000118F0 =00000009                M spdr1	=	op1
000118F0 =00000006                M spdr2	=	op2
000118F0 =0000000A                M spdr3	=	op3
000118F0 =0000000A                M spdr4	=	op4
000118F0                            	spSustainLv	$04, $03, $03, $03
000118F0 =00000004                M spsl1	=	op1
000118F0 =00000003                M spsl2	=	op2
000118F0 =00000003                M spsl3	=	op3
000118F0 =00000003                M spsl4	=	op4
000118F0                            	spReleaseRt	$0F, $0F, $0F, $0F
000118F0 =0000000F                M sprr1	=	op1
000118F0 =0000000F                M sprr2	=	op2
000118F0 =0000000F                M sprr3	=	op3
000118F0 =0000000F                M sprr4	=	op4
000118F0                            	spSSGEG		$00, $00, $00, $00
000118F0 =00000000                M spss1	=	op1
000118F0 =00000000                M spss2	=	op2
000118F0 =00000000                M spss3	=	op3
000118F0 =00000000                M spss4	=	op4
000118F0                            	spTotalLv	$17, $20, $00, $00
000118F0 =00000017                M sptl1	=	op1
000118F0 =00000020                M sptl2	=	op2
000118F0 =00000000                M sptl3	=	op3
000118F0 =00000000                M sptl4	=	op4
000118F0 3C                       M 	dc.b	(spfe<<3)+spal
000118F1 =00000080                M sptlmask4	set	$80
000118F1 =00000000                M sptlmask2	set	((spal>=5)<<7)
000118F1 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000118F1 =00000000                M sptlmask1	set	((spal=7)<<7)
000118F1 0501 0A01                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118F5 565C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118F9 0E11 1111                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118FD 090A 060A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011901 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011905 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011909 1780 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001190D 4E41 54                  M 	dc.b	'NAT'
00011910                            
00011910                            	; Patch $1A
00011910                            	; $F9
00011910                            	; $21, $30, $10, $32,	$1C, $1F, $1F, $10
00011910                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011910                            	; $1F, $2F, $4F, $2F,	$0C, $06, $04, $80
00011910                            	spAlgorithm	$01
00011910 =0000001B                M spatnum	=	spatnum+1
00011910 =00000001                M spal	=	val
00011910                            	spFeedback	$07
00011910 =00000007                M spfe	=	val
00011910                            	spDetune	$02, $01, $03, $03
00011910 =00000002                M spde1	=	op1
00011910 =00000001                M spde2	=	op2
00011910 =00000003                M spde3	=	op3
00011910 =00000003                M spde4	=	op4
00011910                            	spMultiple	$01, $00, $00, $02
00011910 =00000001                M spmu1	=	op1
00011910 =00000000                M spmu2	=	op2
00011910 =00000000                M spmu3	=	op3
00011910 =00000002                M spmu4	=	op4
00011910                            	spRateScale	$00, $00, $00, $00
00011910 =00000000                M sprs1	=	op1
00011910 =00000000                M sprs2	=	op2
00011910 =00000000                M sprs3	=	op3
00011910 =00000000                M sprs4	=	op4
00011910                            	spAttackRt	$1C, $1F, $1F, $10
00011910 =0000001C                M spar1	=	op1
00011910 =0000001F                M spar2	=	op2
00011910 =0000001F                M spar3	=	op3
00011910 =00000010                M spar4	=	op4
00011910                            	spAmpMod	$00, $00, $00, $00
00011910 =00000000                M spam1	=	op1
00011910 =00000000                M spam2	=	op2
00011910 =00000000                M spam3	=	op3
00011910 =00000000                M spam4	=	op4
00011910                            	spSustainRt	$05, $09, $18, $02
00011910 =00000005                M spsr1	=	op1
00011910 =00000009                M spsr2	=	op2
00011910 =00000018                M spsr3	=	op3
00011910 =00000002                M spsr4	=	op4
00011910                            	spDecayRt	$0B, $10, $1F, $05
00011910 =0000000B                M spdr1	=	op1
00011910 =00000010                M spdr2	=	op2
00011910 =0000001F                M spdr3	=	op3
00011910 =00000005                M spdr4	=	op4
00011910                            	spSustainLv	$01, $04, $02, $02
00011910 =00000001                M spsl1	=	op1
00011910 =00000004                M spsl2	=	op2
00011910 =00000002                M spsl3	=	op3
00011910 =00000002                M spsl4	=	op4
00011910                            	spReleaseRt	$0F, $0F, $0F, $0F
00011910 =0000000F                M sprr1	=	op1
00011910 =0000000F                M sprr2	=	op2
00011910 =0000000F                M sprr3	=	op3
00011910 =0000000F                M sprr4	=	op4
00011910                            	spSSGEG		$00, $00, $00, $00
00011910 =00000000                M spss1	=	op1
00011910 =00000000                M spss2	=	op2
00011910 =00000000                M spss3	=	op3
00011910 =00000000                M spss4	=	op4
00011910                            	spTotalLv	$0C, $04, $06, $00
00011910 =0000000C                M sptl1	=	op1
00011910 =00000004                M sptl2	=	op2
00011910 =00000006                M sptl3	=	op3
00011910 =00000000                M sptl4	=	op4
00011910 39                       M 	dc.b	(spfe<<3)+spal
00011911 =00000080                M sptlmask4	set	$80
00011911 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011911 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011911 =00000000                M sptlmask1	set	((spal=7)<<7)
00011911 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011915 1C1F 1F10                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011919 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001191D 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011921 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011925 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011929 0C06 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001192D 4E41 54                  M 	dc.b	'NAT'
00011930                            
00011930                            	; Patch $1B
00011930                            	; $00
00011930                            	; $00, $03, $02, $00,	$D9, $DF, $1F, $1F
00011930                            	; $12, $11, $14, $0F,	$0A, $00, $0A, $0D
00011930                            	; $FF, $FF, $FF, $FF,	$22, $07, $27, $80
00011930                            	spAlgorithm	$00
00011930 =0000001C                M spatnum	=	spatnum+1
00011930 =00000000                M spal	=	val
00011930                            	spFeedback	$00
00011930 =00000000                M spfe	=	val
00011930                            	spDetune	$00, $00, $00, $00
00011930 =00000000                M spde1	=	op1
00011930 =00000000                M spde2	=	op2
00011930 =00000000                M spde3	=	op3
00011930 =00000000                M spde4	=	op4
00011930                            	spMultiple	$00, $02, $03, $00
00011930 =00000000                M spmu1	=	op1
00011930 =00000002                M spmu2	=	op2
00011930 =00000003                M spmu3	=	op3
00011930 =00000000                M spmu4	=	op4
00011930                            	spRateScale	$03, $00, $03, $00
00011930 =00000003                M sprs1	=	op1
00011930 =00000000                M sprs2	=	op2
00011930 =00000003                M sprs3	=	op3
00011930 =00000000                M sprs4	=	op4
00011930                            	spAttackRt	$19, $1F, $1F, $1F
00011930 =00000019                M spar1	=	op1
00011930 =0000001F                M spar2	=	op2
00011930 =0000001F                M spar3	=	op3
00011930 =0000001F                M spar4	=	op4
00011930                            	spAmpMod	$00, $00, $00, $00
00011930 =00000000                M spam1	=	op1
00011930 =00000000                M spam2	=	op2
00011930 =00000000                M spam3	=	op3
00011930 =00000000                M spam4	=	op4
00011930                            	spSustainRt	$12, $14, $11, $0F
00011930 =00000012                M spsr1	=	op1
00011930 =00000014                M spsr2	=	op2
00011930 =00000011                M spsr3	=	op3
00011930 =0000000F                M spsr4	=	op4
00011930                            	spDecayRt	$0A, $0A, $00, $0D
00011930 =0000000A                M spdr1	=	op1
00011930 =0000000A                M spdr2	=	op2
00011930 =00000000                M spdr3	=	op3
00011930 =0000000D                M spdr4	=	op4
00011930                            	spSustainLv	$0F, $0F, $0F, $0F
00011930 =0000000F                M spsl1	=	op1
00011930 =0000000F                M spsl2	=	op2
00011930 =0000000F                M spsl3	=	op3
00011930 =0000000F                M spsl4	=	op4
00011930                            	spReleaseRt	$0F, $0F, $0F, $0F
00011930 =0000000F                M sprr1	=	op1
00011930 =0000000F                M sprr2	=	op2
00011930 =0000000F                M sprr3	=	op3
00011930 =0000000F                M sprr4	=	op4
00011930                            	spSSGEG		$00, $00, $00, $00
00011930 =00000000                M spss1	=	op1
00011930 =00000000                M spss2	=	op2
00011930 =00000000                M spss3	=	op3
00011930 =00000000                M spss4	=	op4
00011930                            	spTotalLv	$22, $27, $07, $00
00011930 =00000022                M sptl1	=	op1
00011930 =00000027                M sptl2	=	op2
00011930 =00000007                M sptl3	=	op3
00011930 =00000000                M sptl4	=	op4
00011930 00                       M 	dc.b	(spfe<<3)+spal
00011931 =00000080                M sptlmask4	set	$80
00011931 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011931 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011931 =00000000                M sptlmask1	set	((spal=7)<<7)
00011931 0003 0200                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011935 D9DF 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011939 1211 140F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001193D 0A00 0A0D                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011941 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011945 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011949 2207 2780                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001194D 4E41 54                  M 	dc.b	'NAT'
00011950                            
00011950                            	; Patch $1C
00011950                            	; $34
00011950                            	; $09, $0F, $01, $D7,	$1F, $1F, $1F, $1F
00011950                            	; $0C, $11, $09, $0F,	$0A, $0E, $0D, $0E
00011950                            	; $35, $1A, $55, $3A,	$0C, $80, $0F, $80
00011950                            	spAlgorithm	$04
00011950 =0000001D                M spatnum	=	spatnum+1
00011950 =00000004                M spal	=	val
00011950                            	spFeedback	$06
00011950 =00000006                M spfe	=	val
00011950                            	spDetune	$00, $00, $00, $0D
00011950 =00000000                M spde1	=	op1
00011950 =00000000                M spde2	=	op2
00011950 =00000000                M spde3	=	op3
00011950 =0000000D                M spde4	=	op4
00011950                            	spMultiple	$09, $01, $0F, $07
00011950 =00000009                M spmu1	=	op1
00011950 =00000001                M spmu2	=	op2
00011950 =0000000F                M spmu3	=	op3
00011950 =00000007                M spmu4	=	op4
00011950                            	spRateScale	$00, $00, $00, $00
00011950 =00000000                M sprs1	=	op1
00011950 =00000000                M sprs2	=	op2
00011950 =00000000                M sprs3	=	op3
00011950 =00000000                M sprs4	=	op4
00011950                            	spAttackRt	$1F, $1F, $1F, $1F
00011950 =0000001F                M spar1	=	op1
00011950 =0000001F                M spar2	=	op2
00011950 =0000001F                M spar3	=	op3
00011950 =0000001F                M spar4	=	op4
00011950                            	spAmpMod	$00, $00, $00, $00
00011950 =00000000                M spam1	=	op1
00011950 =00000000                M spam2	=	op2
00011950 =00000000                M spam3	=	op3
00011950 =00000000                M spam4	=	op4
00011950                            	spSustainRt	$0C, $09, $11, $0F
00011950 =0000000C                M spsr1	=	op1
00011950 =00000009                M spsr2	=	op2
00011950 =00000011                M spsr3	=	op3
00011950 =0000000F                M spsr4	=	op4
00011950                            	spDecayRt	$0A, $0D, $0E, $0E
00011950 =0000000A                M spdr1	=	op1
00011950 =0000000D                M spdr2	=	op2
00011950 =0000000E                M spdr3	=	op3
00011950 =0000000E                M spdr4	=	op4
00011950                            	spSustainLv	$03, $05, $01, $03
00011950 =00000003                M spsl1	=	op1
00011950 =00000005                M spsl2	=	op2
00011950 =00000001                M spsl3	=	op3
00011950 =00000003                M spsl4	=	op4
00011950                            	spReleaseRt	$05, $05, $0A, $0A
00011950 =00000005                M sprr1	=	op1
00011950 =00000005                M sprr2	=	op2
00011950 =0000000A                M sprr3	=	op3
00011950 =0000000A                M sprr4	=	op4
00011950                            	spSSGEG		$00, $00, $00, $00
00011950 =00000000                M spss1	=	op1
00011950 =00000000                M spss2	=	op2
00011950 =00000000                M spss3	=	op3
00011950 =00000000                M spss4	=	op4
00011950                            	spTotalLv	$0C, $0F, $00, $00
00011950 =0000000C                M sptl1	=	op1
00011950 =0000000F                M sptl2	=	op2
00011950 =00000000                M sptl3	=	op3
00011950 =00000000                M sptl4	=	op4
00011950 34                       M 	dc.b	(spfe<<3)+spal
00011951 =00000080                M sptlmask4	set	$80
00011951 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011951 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011951 =00000000                M sptlmask1	set	((spal=7)<<7)
00011951 090F 01D7                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011955 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011959 0C11 090F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001195D 0A0E 0D0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011961 351A 553A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011965 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011969 0C80 0F80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001196D 4E41 54                  M 	dc.b	'NAT'
00011970                            
00011970                            	; Patch $1D
00011970                            	; $FA
00011970                            	; $21, $3A, $19, $30,	$1F, $1F, $1F, $1F
00011970                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011970                            	; $1F, $2F, $4F, $2F,	$0E, $07, $04, $80
00011970                            	spAlgorithm	$02
00011970 =0000001E                M spatnum	=	spatnum+1
00011970 =00000002                M spal	=	val
00011970                            	spFeedback	$07
00011970 =00000007                M spfe	=	val
00011970                            	spDetune	$02, $01, $03, $03
00011970 =00000002                M spde1	=	op1
00011970 =00000001                M spde2	=	op2
00011970 =00000003                M spde3	=	op3
00011970 =00000003                M spde4	=	op4
00011970                            	spMultiple	$01, $09, $0A, $00
00011970 =00000001                M spmu1	=	op1
00011970 =00000009                M spmu2	=	op2
00011970 =0000000A                M spmu3	=	op3
00011970 =00000000                M spmu4	=	op4
00011970                            	spRateScale	$00, $00, $00, $00
00011970 =00000000                M sprs1	=	op1
00011970 =00000000                M sprs2	=	op2
00011970 =00000000                M sprs3	=	op3
00011970 =00000000                M sprs4	=	op4
00011970                            	spAttackRt	$1F, $1F, $1F, $1F
00011970 =0000001F                M spar1	=	op1
00011970 =0000001F                M spar2	=	op2
00011970 =0000001F                M spar3	=	op3
00011970 =0000001F                M spar4	=	op4
00011970                            	spAmpMod	$00, $00, $00, $00
00011970 =00000000                M spam1	=	op1
00011970 =00000000                M spam2	=	op2
00011970 =00000000                M spam3	=	op3
00011970 =00000000                M spam4	=	op4
00011970                            	spSustainRt	$05, $09, $18, $02
00011970 =00000005                M spsr1	=	op1
00011970 =00000009                M spsr2	=	op2
00011970 =00000018                M spsr3	=	op3
00011970 =00000002                M spsr4	=	op4
00011970                            	spDecayRt	$0B, $10, $1F, $05
00011970 =0000000B                M spdr1	=	op1
00011970 =00000010                M spdr2	=	op2
00011970 =0000001F                M spdr3	=	op3
00011970 =00000005                M spdr4	=	op4
00011970                            	spSustainLv	$01, $04, $02, $02
00011970 =00000001                M spsl1	=	op1
00011970 =00000004                M spsl2	=	op2
00011970 =00000002                M spsl3	=	op3
00011970 =00000002                M spsl4	=	op4
00011970                            	spReleaseRt	$0F, $0F, $0F, $0F
00011970 =0000000F                M sprr1	=	op1
00011970 =0000000F                M sprr2	=	op2
00011970 =0000000F                M sprr3	=	op3
00011970 =0000000F                M sprr4	=	op4
00011970                            	spSSGEG		$00, $00, $00, $00
00011970 =00000000                M spss1	=	op1
00011970 =00000000                M spss2	=	op2
00011970 =00000000                M spss3	=	op3
00011970 =00000000                M spss4	=	op4
00011970                            	spTotalLv	$0E, $04, $07, $00
00011970 =0000000E                M sptl1	=	op1
00011970 =00000004                M sptl2	=	op2
00011970 =00000007                M sptl3	=	op3
00011970 =00000000                M sptl4	=	op4
00011970 3A                       M 	dc.b	(spfe<<3)+spal
00011971 =00000080                M sptlmask4	set	$80
00011971 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011971 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011971 =00000000                M sptlmask1	set	((spal=7)<<7)
00011971 213A 1930                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011975 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011979 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001197D 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011981 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011985 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011989 0E07 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
0001198D 4E41 54                  M 	dc.b	'NAT'
00011990                            
00011990                            	; Patch $1E
00011990                            	; $1C
00011990                            	; $2E, $02, $0F, $02,	$1F, $1F, $1F, $1F
00011990                            	; $18, $04, $14, $0E,	$00, $00, $00, $00
00011990                            	; $FF, $FF, $FF, $FF,	$20, $80, $1B, $80
00011990                            	spAlgorithm	$0C
00011990 =0000001F                M spatnum	=	spatnum+1
00011990 =0000000C                M spal	=	val
00011990                            	spFeedback	$01
00011990 =00000001                M spfe	=	val
00011990                            	spDetune	$02, $00, $00, $00
00011990 =00000002                M spde1	=	op1
00011990 =00000000                M spde2	=	op2
00011990 =00000000                M spde3	=	op3
00011990 =00000000                M spde4	=	op4
00011990                            	spMultiple	$0E, $0F, $02, $02
00011990 =0000000E                M spmu1	=	op1
00011990 =0000000F                M spmu2	=	op2
00011990 =00000002                M spmu3	=	op3
00011990 =00000002                M spmu4	=	op4
00011990                            	spRateScale	$00, $00, $00, $00
00011990 =00000000                M sprs1	=	op1
00011990 =00000000                M sprs2	=	op2
00011990 =00000000                M sprs3	=	op3
00011990 =00000000                M sprs4	=	op4
00011990                            	spAttackRt	$1F, $1F, $1F, $1F
00011990 =0000001F                M spar1	=	op1
00011990 =0000001F                M spar2	=	op2
00011990 =0000001F                M spar3	=	op3
00011990 =0000001F                M spar4	=	op4
00011990                            	spAmpMod	$00, $00, $00, $00
00011990 =00000000                M spam1	=	op1
00011990 =00000000                M spam2	=	op2
00011990 =00000000                M spam3	=	op3
00011990 =00000000                M spam4	=	op4
00011990                            	spSustainRt	$18, $14, $04, $0E
00011990 =00000018                M spsr1	=	op1
00011990 =00000014                M spsr2	=	op2
00011990 =00000004                M spsr3	=	op3
00011990 =0000000E                M spsr4	=	op4
00011990                            	spDecayRt	$00, $00, $00, $00
00011990 =00000000                M spdr1	=	op1
00011990 =00000000                M spdr2	=	op2
00011990 =00000000                M spdr3	=	op3
00011990 =00000000                M spdr4	=	op4
00011990                            	spSustainLv	$0F, $0F, $0F, $0F
00011990 =0000000F                M spsl1	=	op1
00011990 =0000000F                M spsl2	=	op2
00011990 =0000000F                M spsl3	=	op3
00011990 =0000000F                M spsl4	=	op4
00011990                            	spReleaseRt	$0F, $0F, $0F, $0F
00011990 =0000000F                M sprr1	=	op1
00011990 =0000000F                M sprr2	=	op2
00011990 =0000000F                M sprr3	=	op3
00011990 =0000000F                M sprr4	=	op4
00011990                            	spSSGEG		$00, $00, $00, $00
00011990 =00000000                M spss1	=	op1
00011990 =00000000                M spss2	=	op2
00011990 =00000000                M spss3	=	op3
00011990 =00000000                M spss4	=	op4
00011990                            	spTotalLv	$20, $1B, $00, $00
00011990 =00000020                M sptl1	=	op1
00011990 =0000001B                M sptl2	=	op2
00011990 =00000000                M sptl3	=	op3
00011990 =00000000                M sptl4	=	op4
00011990 14                       M 	dc.b	(spfe<<3)+spal
00011991 =00000080                M sptlmask4	set	$80
00011991 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011991 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011991 =00000000                M sptlmask1	set	((spal=7)<<7)
00011991 2E02 0F02                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011995 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011999 1804 140E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
0001199D 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119A1 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119A5 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119A9 2080 9B80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000119AD 4E41 54                  M 	dc.b	'NAT'
000119B0                            
000119B0                            	even
000119B0                            
000119B0                            ; -------------------------------------------------------------------------
000119B0                            	opt ae-				; disable automatic evens
000119B0                            
000119B0                            sfxaddr	include	"Sound/sfxdata.asm"	; include all sfx
000119B0                            
000119B0                            
000119B0                            ; ------------------------------------------------------------------------
000119B0                            ; AMPS SFX data
000119B0                            ; -------------------------------------------------------------------------
000119B0                            
000119B0                            Snd_Jump:
000119B0                            		include	"Sound/sfx/Jump.asm"
000119B0                            SndJump_Header:
000119B0                            	sHeaderInit	
000119B0 =000119B0                M spointzero	=	*
000119B0 =00000000                M spatnum	=	0
000119B0                            	sHeaderPrio	$60
000119B0 60                       M 	dc.b	$60
000119B1                            	sHeaderCh	$01
000119B1 00                       M 	dc.b	$01-1
000119B2                            	sHeaderSFX	$80, $C0, SndJump_FM5, -1, $00
000119B2 80C0                     M 	dc.b	$80,$c0
000119B4 0000                     M 	dc.w	sndjump_fm5-spointzero
000119B6 FF00                     M 	dc.b	-1,$00
000119B8                            
000119B8                            SndJump_FM5:
000119B8 F3E7                       	dc.b	$F3,	$E7
000119BA                            	ssMod68k	$00, $01, -5, $10
000119BA F000 01FB 10             M 	dc.b	$f0,$00,$01,-5,$10
000119BF A510                       	dc.b nC3, $10
000119C1                            	sModOff
000119C1 EC                       M 	dc.b	$ec
000119C2                            	
000119C2                            Jumploop:
000119C2 E702                       	dc.b	$E7,	$02
000119C4                            	saVol	$01
000119C4 ED01                     M 	dc.b	$ed,$01
000119C6                            	sLoop		$00, $0B, Jumploop
000119C6 F700                     M 	dc.b	$f7,$00
000119C8 FFF9                     M 	dc.w	jumploop-*-1
000119CA 0B                       M 	dc.b	$0b
000119CB                            	
000119CB                            	sStop	
000119CB F5                       M 	dc.b	$f5
000119CC                            		even
000119CC                            Snd_Skid:
000119CC                            		include	"Sound/sfx/Skid.asm"
000119CC                            Skid_Header:
000119CC                            	sHeaderInit	
000119CC =000119CC                M spointzero	=	*
000119CC =00000000                M spatnum	=	0
000119CC                            	sHeaderPrio	$60
000119CC 60                       M 	dc.b	$60
000119CD                            	sHeaderCh	$01
000119CD 00                       M 	dc.b	$01-1
000119CE                            	sHeaderSFX	$80, $C0, Skid_FM5, $00, $00
000119CE 80C0                     M 	dc.b	$80,$c0
000119D0 0000                     M 	dc.w	skid_fm5-spointzero
000119D2 0000                     M 	dc.b	$00,$00
000119D4                            
000119D4                            Skid_FM5:
000119D4 F3E7                       	dc.b	$F3,	$E7
000119D6 8001                       	dc.b nRst, $01
000119D8                            	
000119D8                            Skid_Loop1:
000119D8 AD01 8001                  	dc.b nAb3, $01, nRst, $01
000119DC                            	sLoop		$00, $03, Skid_Loop1
000119DC F700                     M 	dc.b	$f7,$00
000119DE FFF9                     M 	dc.w	skid_loop1-*-1
000119E0 03                       M 	dc.b	$03
000119E1                            
000119E1                            Skid_Loop2:
000119E1 AD01 8001                  	dc.b nAb3, $01, nRst, $01
000119E5                            	saVol	$01
000119E5 ED01                     M 	dc.b	$ed,$01
000119E7                            	sLoop		$00, $09, Skid_Loop2
000119E7 F700                     M 	dc.b	$f7,$00
000119E9 FFF7                     M 	dc.w	skid_loop2-*-1
000119EB 09                       M 	dc.b	$09
000119EC                            	sStop	
000119EC F5                       M 	dc.b	$f5
000119EE 00                         		even
000119EE                            Snd_Death:
000119EE                            		include	"Sound/sfx/Death.asm"
000119EE                            Death_Header:
000119EE                            	sHeaderInit	
000119EE =000119EE                M spointzero	=	*
000119EE =00000000                M spatnum	=	0
000119EE                            	sHeaderPrio	$60
000119EE 60                       M 	dc.b	$60
000119EF                            	sHeaderCh	$01
000119EF 00                       M 	dc.b	$01-1
000119F0                            	sHeaderSFX	$80, $05, Death_FM5, $F4, $00
000119F0 8005                     M 	dc.b	$80,$05
000119F2 0000                     M 	dc.w	death_fm5-spointzero
000119F4 F400                     M 	dc.b	$f4,$00
000119F6                            
000119F6                            Death_FM5:
000119F6                            	sVoice		$02
000119F6 E802                     M 	dc.b	$e8,$02
000119F8 B007 E7AD                  	dc.b nB3, $07, sHold, nAb3
000119FC                            
000119FC                            Death_Loop1:
000119FC 01                         	dc.b $01
000119FD                            	saVol		$01
000119FD ED01                     M 	dc.b	$ed,$01
000119FF                            	sLoop		$00, $2F, Death_Loop1
000119FF F700                     M 	dc.b	$f7,$00
00011A01 FFFA                     M 	dc.w	death_loop1-*-1
00011A03 2F                       M 	dc.b	$2f
00011A04                            	sStop	
00011A04 F5                       M 	dc.b	$f5
00011A06 00                         		even
00011A06                            Snd_Push:
00011A06                            		include	"Sound/sfx/Push.asm"
00011A06                            Push_Header:
00011A06                            	sHeaderInit	
00011A06 =00011A06                M spointzero	=	*
00011A06 =00000000                M spatnum	=	0
00011A06                            	sHeaderPrio	$60
00011A06 60                       M 	dc.b	$60
00011A07                            	sHeaderCh	$01
00011A07 00                       M 	dc.b	$01-1
00011A08                            	sHeaderSFX	$80, $05, Push_FM5, $00, $06
00011A08 8005                     M 	dc.b	$80,$05
00011A0A 0000                     M 	dc.w	push_fm5-spointzero
00011A0C 0006                     M 	dc.b	$00,$06
00011A0E                            
00011A0E                            Push_FM5:
00011A0E                            	sVoice		$13
00011A0E E813                     M 	dc.b	$e8,$13
00011A10 8F07 8002 8F06 8010        	dc.b nD1, $07, nRst, $02, nD1, $06, nRst, $10
00011A18                            	sStop	
00011A18 F5                       M 	dc.b	$f5
00011A1A 00                         		even
00011A1A                            Snd_Bubble:
00011A1A                            Snd_Drown:
00011A1A                            Snd_DrownWarning:
00011A1A                            Snd_DrownCountdown:
00011A1A                            Snd_Checkpoint:
00011A1A                            		include	"Sound/sfx/Checkpoint.asm"
00011A1A                            Attack_Header:
00011A1A                            	sHeaderInit	
00011A1A =00011A1A                M spointzero	=	*
00011A1A =00000000                M spatnum	=	0
00011A1A                            	sHeaderPrio	$60
00011A1A 60                       M 	dc.b	$60
00011A1B                            	sHeaderCh	$02
00011A1B 01                       M 	dc.b	$02-1
00011A1C                            	sHeaderSFX	$80, $80, Attack_FM5, $00, $00
00011A1C 8080                     M 	dc.b	$80,$80
00011A1E 0000                     M 	dc.w	attack_fm5-spointzero
00011A20 0000                     M 	dc.b	$00,$00
00011A22                            	sHeaderSFX	$80, $A0, Attack_FM5B, $00, $04
00011A22 80A0                     M 	dc.b	$80,$a0
00011A24 0000                     M 	dc.w	attack_fm5b-spointzero
00011A26 0004                     M 	dc.b	$00,$04
00011A28                            
00011A28                            Attack_FM5B:
00011A28 8002                       	dc.b	nRst,	$02
00011A2A                            
00011A2A                            Attack_FM5:
00011A2A                            
00011A2A                            Attack_Loop1:
00011A2A B103 8001                  	dc.b nC4, $03, nRst, $01
00011A2E                            	sLoop		$00, $01, Attack_Loop1
00011A2E F700                     M 	dc.b	$f7,$00
00011A30 FFF9                     M 	dc.w	attack_loop1-*-1
00011A32 01                       M 	dc.b	$01
00011A33                            
00011A33                            Attack_Loop2:
00011A33 B103 8001                  	dc.b nC4, $03, nRst, $01
00011A37                            	saVol	$01
00011A37 ED01                     M 	dc.b	$ed,$01
00011A39 B003 8001                  	dc.b nB3, $03, nRst, $01
00011A3D                            	saVol	$01
00011A3D ED01                     M 	dc.b	$ed,$01
00011A3F AF03 8001                  	dc.b nBb3, $03, nRst, $01
00011A43                            	saVol	$01
00011A43 ED01                     M 	dc.b	$ed,$01
00011A45 AE03 8001                  	dc.b nBb3-1, $03, nRst, $01
00011A49                            	saVol	$01
00011A49 ED01                     M 	dc.b	$ed,$01
00011A4B                            	sLoop		$00, $03, Attack_Loop2
00011A4B F700                     M 	dc.b	$f7,$00
00011A4D FFE5                     M 	dc.w	attack_loop2-*-1
00011A4F 03                       M 	dc.b	$03
00011A50                            	sStop	
00011A50 F5                       M 	dc.b	$f5
00011A52 00                         		even
00011A52                            Snd_SpikeMove:
00011A52                            Snd_Ring:
00011A52                            		include	"Sound/sfx/Ring.asm"
00011A52                            Ring_Header:
00011A52                            	sHeaderInit	
00011A52 =00011A52                M spointzero	=	*
00011A52 =00000000                M spatnum	=	0
00011A52                            	sHeaderPrio	$60
00011A52 60                       M 	dc.b	$60
00011A53                            	sHeaderCh	$01
00011A53 00                       M 	dc.b	$01-1
00011A54                            	sHeaderSFX	$80, $05, Ring_FM5, $00, $0A
00011A54 8005                     M 	dc.b	$80,$05
00011A56 0000                     M 	dc.w	ring_fm5-spointzero
00011A58 000A                     M 	dc.b	$00,$0a
00011A5A                            
00011A5A                            Ring_FM5:
00011A5A                            	sVoice		$03
00011A5A E803                     M 	dc.b	$e8,$03
00011A5C C105 C405 C91B             	dc.b nE5, $05, nG5, $05, nC6, $1B
00011A62                            	sStop	
00011A62 F5                       M 	dc.b	$f5
00011A64 00                         		even
00011A64                            Snd_RingLoss:
00011A64                            		include	"Sound/sfx/Ring Loss.asm"
00011A64                            RingLoss_Header:
00011A64                            	sHeaderInit	
00011A64 =00011A64                M spointzero	=	*
00011A64 =00000000                M spatnum	=	0
00011A64                            	sHeaderPrio	$60
00011A64 60                       M 	dc.b	$60
00011A65                            	sHeaderCh	$02
00011A65 01                       M 	dc.b	$02-1
00011A66                            	sHeaderSFX	$80, $04, RingLoss_FM4, $00, $05
00011A66 8004                     M 	dc.b	$80,$04
00011A68 0000                     M 	dc.w	ringloss_fm4-spointzero
00011A6A 0005                     M 	dc.b	$00,$05
00011A6C                            	sHeaderSFX	$80, $05, RingLoss_FM5, $00, $08
00011A6C 8005                     M 	dc.b	$80,$05
00011A6E 0000                     M 	dc.w	ringloss_fm5-spointzero
00011A70 0008                     M 	dc.b	$00,$08
00011A72                            
00011A72                            RingLoss_FM4:
00011A72                            	sVoice		$03
00011A72 E803                     M 	dc.b	$e8,$03
00011A74 C602 0505 0505 0505 3A     	dc.b nA5, $02, $05, $05, $05, $05, $05, $05, $3A
00011A7D                            	sStop	
00011A7D F5                       M 	dc.b	$f5
00011A7E                            
00011A7E                            RingLoss_FM5:
00011A7E                            	sVoice		$03
00011A7E E803                     M 	dc.b	$e8,$03
00011A80 8002 C402 0515 0205 32     	dc.b nRst, $02, nG5, $02, $05, $15, $02, $05, $32
00011A89                            	sStop	
00011A89 F5                       M 	dc.b	$f5
00011A8A                            		even
00011A8A                            Snd_Spring:
00011A8A                            		include	"Sound/sfx/Spring.asm"
00011A8A                            Spring_Header:
00011A8A                            	sHeaderInit	
00011A8A =00011A8A                M spointzero	=	*
00011A8A =00000000                M spatnum	=	0
00011A8A                            	sHeaderPrio	$60
00011A8A 60                       M 	dc.b	$60
00011A8B                            	sHeaderCh	$01
00011A8B 00                       M 	dc.b	$01-1
00011A8C                            	sHeaderSFX	$80, $04, Spring_FM4, $00, $02
00011A8C 8004                     M 	dc.b	$80,$04
00011A8E 0000                     M 	dc.w	spring_fm4-spointzero
00011A90 0002                     M 	dc.b	$00,$02
00011A92                            
00011A92                            Spring_FM4:
00011A92                            	sVoice		$06
00011A92 E806                     M 	dc.b	$e8,$06
00011A94 8001                       	dc.b nRst, $01
00011A96                            	ssMod68k	$03, $01, $5D, $0F
00011A96 F003 015D 0F             M 	dc.b	$f0,$03,$01,$5d,$0f
00011A9B B00C                       	dc.b nB3, $0C
00011A9D                            	sModOff	
00011A9D EC                       M 	dc.b	$ec
00011A9E                            
00011A9E                            Spring_Loop1:
00011A9E E7                         	dc.b sHold
00011A9F                            	saVol		$02
00011A9F ED02                     M 	dc.b	$ed,$02
00011AA1 BD02                       	dc.b nC5, $02
00011AA3                            	sLoop		$00, $19, Spring_Loop1
00011AA3 F700                     M 	dc.b	$f7,$00
00011AA5 FFF8                     M 	dc.w	spring_loop1-*-1
00011AA7 19                       M 	dc.b	$19
00011AA8                            	sStop	
00011AA8 F5                       M 	dc.b	$f5
00011AAA 00                         		even
00011AAA                            Snd_Shield:
00011AAA                            Snd_Splash:
00011AAA                            Snd_Bumper:
00011AAA                            		include	"Sound/sfx/Bumper.asm"
00011AAA                            BumperHeader:
00011AAA                            	sHeaderInit	
00011AAA =00011AAA                M spointzero	=	*
00011AAA =00000000                M spatnum	=	0
00011AAA                            	sHeaderPrio	$60
00011AAA 60                       M 	dc.b	$60
00011AAB                            	sHeaderCh	$03
00011AAB 02                       M 	dc.b	$03-1
00011AAC                            	sHeaderSFX	$80, $05, BumperFM5, $00, $00
00011AAC 8005                     M 	dc.b	$80,$05
00011AAE 0000                     M 	dc.w	bumperfm5-spointzero
00011AB0 0000                     M 	dc.b	$00,$00
00011AB2                            	sHeaderSFX	$80, $04, BumperFM4, $00, $00
00011AB2 8004                     M 	dc.b	$80,$04
00011AB4 0000                     M 	dc.w	bumperfm4-spointzero
00011AB6 0000                     M 	dc.b	$00,$00
00011AB8                            	sHeaderSFX	$80, $02, BumperFM3, $00, $02
00011AB8 8002                     M 	dc.b	$80,$02
00011ABA 0000                     M 	dc.w	bumperfm3-spointzero
00011ABC 0002                     M 	dc.b	$00,$02
00011ABE                            
00011ABE                            BumperFM5:
00011ABE                            	sVoice		$0D
00011ABE E80D                     M 	dc.b	$e8,$0d
00011AC0                            	ssJump		BumperJump1
00011AC0 F6                       M 	dc.b	$f6
00011AC1 0000                     M 	dc.w	bumperjump1-*-1
00011AC3                            
00011AC3                            BumperFM4:
00011AC3                            	sVoice		$0D
00011AC3 E80D                     M 	dc.b	$e8,$0d
00011AC5                            	saDetune	$07
00011AC5 E207                     M 	dc.b	$e2,$07
00011AC7 8001                       	dc.b nRst, $01
00011AC9                            
00011AC9                            BumperJump1:
00011AC9 BA20                       	dc.b nA4, $20
00011ACB                            	sStop	
00011ACB F5                       M 	dc.b	$f5
00011ACC                            
00011ACC                            BumperFM3:
00011ACC                            	sVoice		$0E
00011ACC E80E                     M 	dc.b	$e8,$0e
00011ACE 9A03                       	dc.b nCs2, $03
00011AD0                            	sStop	
00011AD0 F5                       M 	dc.b	$f5
00011AD2 00                         		even
00011AD2                            Snd_Switch:
00011AD2                            Snd_Signpost:
00011AD2                            Snd_Collapse:
00011AD2                            Snd_WallSmash:
00011AD2                            Snd_Rumble:
00011AD2                            Snd_Warp:
00011AD2                            Snd_BossHit:
00011AD2                            		include	"Sound/sfx/Boss Hit.asm"
00011AD2                            BossHit_Header:
00011AD2                            	sHeaderInit	
00011AD2 =00011AD2                M spointzero	=	*
00011AD2 =00000000                M spatnum	=	0
00011AD2                            	sHeaderPrio	$60
00011AD2 60                       M 	dc.b	$60
00011AD3                            	sHeaderCh	$01
00011AD3 00                       M 	dc.b	$01-1
00011AD4                            	sHeaderSFX	$80, $05, BossHit_FM4, $00, $00
00011AD4 8005                     M 	dc.b	$80,$05
00011AD6 0000                     M 	dc.w	bosshit_fm4-spointzero
00011AD8 0000                     M 	dc.b	$00,$00
00011ADA                            
00011ADA                            BossHit_FM4:
00011ADA                            	sVoice		$0F
00011ADA E80F                     M 	dc.b	$e8,$0f
00011ADC                            	ssMod68k	$01, $01, $0C, $01
00011ADC F001 010C 01             M 	dc.b	$f0,$01,$01,$0c,$01
00011AE1                            
00011AE1                            BossHit_Loop1:
00011AE1 810A                       	dc.b nC0, $0A
00011AE3                            	saVol		$10
00011AE3 ED10                     M 	dc.b	$ed,$10
00011AE5                            	sLoop		$00, $04, BossHit_Loop1
00011AE5 F700                     M 	dc.b	$f7,$00
00011AE7 FFF9                     M 	dc.w	bosshit_loop1-*-1
00011AE9 04                       M 	dc.b	$04
00011AEA                            	sStop	
00011AEA F5                       M 	dc.b	$f5
00011AEC 00                         		even
00011AEC                            Snd_Bomb:
00011AEC                            		include	"Sound/sfx/Bomb.asm"
00011AEC                            Bomb_Header:
00011AEC                            	sHeaderInit	
00011AEC =00011AEC                M spointzero	=	*
00011AEC =00000000                M spatnum	=	0
00011AEC                            	sHeaderPrio	$60
00011AEC 60                       M 	dc.b	$60
00011AED                            	sHeaderCh	$01
00011AED 00                       M 	dc.b	$01-1
00011AEE                            	sHeaderSFX	$80, $05, Bomb_FM5, $00, $00
00011AEE 8005                     M 	dc.b	$80,$05
00011AF0 0000                     M 	dc.w	bomb_fm5-spointzero
00011AF2 0000                     M 	dc.b	$00,$00
00011AF4                            
00011AF4                            Bomb_FM5:
00011AF4                            	sVoice		$09
00011AF4 E809                     M 	dc.b	$e8,$09
00011AF6 8A22                       	dc.b nA0, $22
00011AF8                            	sStop	
00011AF8 F5                       M 	dc.b	$f5
00011AFA 00                         		even
00011AFA                            Snd_BreakItem:
00011AFA                            		include	"Sound/sfx/Break Item.asm"
00011AFA                            BreakItem_Header:
00011AFA                            	sHeaderInit	
00011AFA =00011AFA                M spointzero	=	*
00011AFA =00000000                M spatnum	=	0
00011AFA                            	sHeaderPrio	$60
00011AFA 60                       M 	dc.b	$60
00011AFB                            	sHeaderCh	$01
00011AFB 00                       M 	dc.b	$01-1
00011AFC                            	sHeaderSFX	$80, $05, BreakItem_FM5, $00, $00
00011AFC 8005                     M 	dc.b	$80,$05
00011AFE 0000                     M 	dc.w	breakitem_fm5-spointzero
00011B00 0000                     M 	dc.b	$00,$00
00011B02                            
00011B02                            BreakItem_FM5:
00011B02                            	ssMod68k	$03, $01, $72, $0B
00011B02 F003 0172 0B             M 	dc.b	$f0,$03,$01,$72,$0b
00011B07                            	sVoice		$04
00011B07 E804                     M 	dc.b	$e8,$04
00011B09 BA16                       	dc.b nA4, $16
00011B0B                            	sStop	
00011B0B F5                       M 	dc.b	$f5
00011B0C                            		even
00011B0C                            Snd_FloorBounce:
00011B0C                            		include	"Sound/sfx/Floor Bounce.asm"
00011B0C                            FloorBounce_Header:
00011B0C                            	sHeaderInit	
00011B0C =00011B0C                M spointzero	=	*
00011B0C =00000000                M spatnum	=	0
00011B0C                            	sHeaderPrio	$60
00011B0C 60                       M 	dc.b	$60
00011B0D                            	sHeaderCh	$01
00011B0D 00                       M 	dc.b	$01-1
00011B0E                            	sHeaderSFX	$80, $05, FloorBounce_FM5, $00, $00
00011B0E 8005                     M 	dc.b	$80,$05
00011B10 0000                     M 	dc.w	floorbounce_fm5-spointzero
00011B12 0000                     M 	dc.b	$00,$00
00011B14                            
00011B14                            FloorBounce_FM5:
00011B14                            	sVoice		$18
00011B14 E818                     M 	dc.b	$e8,$18
00011B16 A00F                       	dc.b nG2, $0F
00011B18                            	saVol		$0F
00011B18 ED0F                     M 	dc.b	$ed,$0f
00011B1A                            	sLoop		$00, $04, FloorBounce_FM5
00011B1A F700                     M 	dc.b	$f7,$00
00011B1C FFF7                     M 	dc.w	floorbounce_fm5-*-1
00011B1E 04                       M 	dc.b	$04
00011B1F                            	sStop	
00011B1F F5                       M 	dc.b	$f5
00011B20                            		even
00011B20                            Snd_Charge:
00011B20                            		include	"Sound/sfx/Charge.asm"
00011B20                            PeeloutCharge_Header:
00011B20                            	sHeaderInit
00011B20 =00011B20                M spointzero	=	*
00011B20 =00000000                M spatnum	=	0
00011B20                            	sHeaderPrio	$60
00011B20 60                       M 	dc.b	$60
00011B21                            	sHeaderCh	$01
00011B21 00                       M 	dc.b	$01-1
00011B22                            
00011B22                            	sHeaderSFX	$80, $05, PeeloutCharge_FM5, $00, $05
00011B22 8005                     M 	dc.b	$80,$05
00011B24 0000                     M 	dc.w	peeloutcharge_fm5-spointzero
00011B26 0005                     M 	dc.b	$00,$05
00011B28                            
00011B28                            ; FM5 Data
00011B28                            PeeloutCharge_FM5:
00011B28                            	sVoice	$0A
00011B28 E80A                     M 	dc.b	$e8,$0a
00011B2A 8001                       	dc.b	nRst, $01
00011B2C                            	ssMod68k	$01, $01, $09, $FF
00011B2C F001 0109 FF             M 	dc.b	$f0,$01,$01,$09,$ff
00011B31 CA22                       	dc.b	nCs6, $22
00011B33                            	sModOn
00011B33 EB                       M 	dc.b	$eb
00011B34                            	saVol	$02
00011B34 ED02                     M 	dc.b	$ed,$02
00011B36                            	sModOff
00011B36 EC                       M 	dc.b	$ec
00011B37                            
00011B37                            PeeloutCharge_Jump00:
00011B37 E7D1 02                    	dc.b	sHold, nAb6, $02
00011B3A                            	ssJump	PeeloutCharge_Jump00
00011B3A F6                       M 	dc.b	$f6
00011B3B FFFB                     M 	dc.w	peeloutcharge_jump00-*-1
00011B3E 00                         		even
00011B3E                            Snd_ChargeStop:
00011B3E                            		include	"Sound/sfx/Charge Stop.asm"
00011B3E                            PeeloutStop_Header:
00011B3E                            	sHeaderInit
00011B3E =00011B3E                M spointzero	=	*
00011B3E =00000000                M spatnum	=	0
00011B3E                            	sHeaderPrio	$60
00011B3E 60                       M 	dc.b	$60
00011B3F                            	sHeaderCh   $01
00011B3F 00                       M 	dc.b	$01-1
00011B40                            
00011B40                            	sHeaderSFX $80, $05, PeeloutStop_FM5,	$00, $00
00011B40 8005                     M 	dc.b	$80,$05
00011B42 0000                     M 	dc.w	peeloutstop_fm5-spointzero
00011B44 0000                     M 	dc.b	$00,$00
00011B46                            
00011B46                            ; FM5 Data
00011B46                            PeeloutStop_FM5:
00011B46                            	sStop
00011B46 F5                       M 	dc.b	$f5
00011B48 00                         		even
00011B48                            Snd_ChargeRelease:
00011B48                            		include	"Sound/sfx/Charge Release.asm"
00011B48                            Peelout_Release_Header:
00011B48                            	sHeaderInit
00011B48 =00011B48                M spointzero	=	*
00011B48 =00000000                M spatnum	=	0
00011B48                            	sHeaderPrio	$60
00011B48 60                       M 	dc.b	$60
00011B49                            	sHeaderCh	$02
00011B49 01                       M 	dc.b	$02-1
00011B4A                            
00011B4A                            	sHeaderSFX	$80, $04, Peelout_Release_FM4, $00, $00
00011B4A 8004                     M 	dc.b	$80,$04
00011B4C 0000                     M 	dc.w	peelout_release_fm4-spointzero
00011B4E 0000                     M 	dc.b	$00,$00
00011B50                            	sHeaderSFX	$80, $05, Peelout_Release_FM5, $00, $08
00011B50 8005                     M 	dc.b	$80,$05
00011B52 0000                     M 	dc.w	peelout_release_fm5-spointzero
00011B54 0008                     M 	dc.b	$00,$08
00011B56                            
00011B56                            ; FM4 Data
00011B56                            Peelout_Release_FM4:
00011B56                            	sVoice		$0C
00011B56 E80C                     M 	dc.b	$e8,$0c
00011B58                            	ssMod68k	$01, $01, $C5, $1A
00011B58 F001 01C5 1A             M 	dc.b	$f0,$01,$01,$c5,$1a
00011B5D CD07                       	dc.b		nE6, $07
00011B5F                            	saVol		$09
00011B5F ED09                     M 	dc.b	$ed,$09
00011B61                            	sPan		spCenter, $00
00011B61 E0C0                     M 	dc.b	$e0,spcenter|$00
00011B63                            	sVoice		$0A
00011B63 E80A                     M 	dc.b	$e8,$0a
00011B65                            	ssMod68k	$03, $01, $09, $FF
00011B65 F003 0109 FF             M 	dc.b	$f0,$03,$01,$09,$ff
00011B6A D625                       	dc.b		nCs7, $25
00011B6C                            	sModOff
00011B6C EC                       M 	dc.b	$ec
00011B6D                            
00011B6D                            Peelout_Release_Loop00:
00011B6D E7                         	dc.b		sHold
00011B6E                            	saVol		$01
00011B6E ED01                     M 	dc.b	$ed,$01
00011B70 DC02                       	dc.b		nG7, $02
00011B72                            	sLoop		$00, $2A, Peelout_Release_Loop00
00011B72 F700                     M 	dc.b	$f7,$00
00011B74 FFF8                     M 	dc.w	peelout_release_loop00-*-1
00011B76 2A                       M 	dc.b	$2a
00011B77                            	sStop
00011B77 F5                       M 	dc.b	$f5
00011B78                            
00011B78                            ; FM5 Data
00011B78                            Peelout_Release_FM5:
00011B78                            	sVoice		$0B
00011B78 E80B                     M 	dc.b	$e8,$0b
00011B7A                            	ssMod68k	$01, $01, $20, $08
00011B7A F001 0120 08             M 	dc.b	$f0,$01,$01,$20,$08
00011B7F 800A                       	dc.b		nRst, $0A
00011B81                            
00011B81                            Peelout_Release_Loop01:
00011B81 880F                       	dc.b		nG0, $0F
00011B83                            	sLoop		$00, $03, Peelout_Release_Loop01
00011B83 F700                     M 	dc.b	$f7,$00
00011B85 FFFB                     M 	dc.w	peelout_release_loop01-*-1
00011B87 03                       M 	dc.b	$03
00011B88                            
00011B88                            Peelout_Release_Loop02:
00011B88 880A                       	dc.b		nG0, $0A
00011B8A                            	saVol		$05
00011B8A ED05                     M 	dc.b	$ed,$05
00011B8C                            	sLoop		$00, $06, Peelout_Release_Loop02
00011B8C F700                     M 	dc.b	$f7,$00
00011B8E FFF9                     M 	dc.w	peelout_release_loop02-*-1
00011B90 06                       M 	dc.b	$06
00011B91                            	sStop
00011B91 F5                       M 	dc.b	$f5
00011B92                            		even
00011B92                            Snd_DiamondBreak:
00011B92                            		include	"Sound/sfx/Diamond Break.asm"
00011B92                            DiamondBreak_Header:
00011B92                            	sHeaderInit	
00011B92 =00011B92                M spointzero	=	*
00011B92 =00000000                M spatnum	=	0
00011B92                            	sHeaderPrio	$60
00011B92 60                       M 	dc.b	$60
00011B93                            	sHeaderCh	$01
00011B93 00                       M 	dc.b	$01-1
00011B94                            	sHeaderSFX	$80, $05, DiamondBreak_FM5, $00, $07
00011B94 8005                     M 	dc.b	$80,$05
00011B96 0000                     M 	dc.w	diamondbreak_fm5-spointzero
00011B98 0007                     M 	dc.b	$00,$07
00011B9A                            
00011B9A                            DiamondBreak_FM5:
00011B9A                            	sVoice		$1E
00011B9A E81E                     M 	dc.b	$e8,$1e
00011B9C AE08                       	dc.b nA3, $08
00011B9E                            	sStop	
00011B9E F5                       M 	dc.b	$f5
00011BA0 00                         		even
00011BA0                            
00011BA0                            ; -------------------------------------------------------------------------
00011BA0                            musaddr	include	"Sound/musicdata.asm"	; include all music
00011BA0                            
00011BA0                            
00011BA0                            ; ------------------------------------------------------------------------
00011BA0                            ; AMPS music data
00011BA0                            ; -------------------------------------------------------------------------
00011BA0                            
00011BA0                            Mus_WWZ:
00011BA0                            		include	"Sound/music/Wacky Workbench.asm"
00011BA0                            ; Level music was replaced with a silent music track, since I did not create the music, 
00011BA0                            ; nor do I currently have permission to share it.
00011BA0                            
00011BA0                            Mus_WWZ_Header:
00011BA0                            	sHeaderInit
00011BA0 =00011BA0                M spointzero	=	*
00011BA0 =00000000                M spatnum	=	0
00011BA0                            	sHeaderTempo	$02, $33
00011BA0 0133                     M 	dc.b	$02-1,$33
00011BA2                            	sHeaderCh	$05, $03
00011BA2 04                       M 	dc.b	$05-1
00011BA3 02                       M 	dc.b	$03-1
00011BA4                            	sHeaderDAC	Mus_WWZ_DAC2
00011BA4 0000                     M 	dc.w	mus_wwz_dac2-spointzero
00011BA6 0000                     M 	dc.w	$00
00011BA8                            	sHeaderDAC	Mus_WWZ_DAC
00011BA8 0000                     M 	dc.w	mus_wwz_dac-spointzero
00011BAA 0000                     M 	dc.w	$00
00011BAC                            	sHeaderFM	Mus_WWZ_FM1, $00, $0A
00011BAC 0000                     M 	dc.w	mus_wwz_fm1-spointzero
00011BAE 000A                     M 	dc.b	$00,$0a
00011BB0                            	sHeaderFM	Mus_WWZ_FM2, $00, $11
00011BB0 0000                     M 	dc.w	mus_wwz_fm2-spointzero
00011BB2 0011                     M 	dc.b	$00,$11
00011BB4                            	sHeaderFM	Mus_WWZ_FM3, $00, $10
00011BB4 0000                     M 	dc.w	mus_wwz_fm3-spointzero
00011BB6 0010                     M 	dc.b	$00,$10
00011BB8                            	sHeaderFM	Mus_WWZ_FM4, $00, $10
00011BB8 0000                     M 	dc.w	mus_wwz_fm4-spointzero
00011BBA 0010                     M 	dc.b	$00,$10
00011BBC                            	sHeaderFM	Mus_WWZ_FM5, $00, $0C
00011BBC 0000                     M 	dc.w	mus_wwz_fm5-spointzero
00011BBE 000C                     M 	dc.b	$00,$0c
00011BC0                            	sHeaderPSG	Mus_WWZ_PSG1, $00, $20>>3, $00, v00
00011BC0 0000                     M 	dc.w	mus_wwz_psg1-spointzero
00011BC2 0004 0000                M 	dc.b	$00,$20>>3,$00,v00
00011BC6                            	sHeaderPSG	Mus_WWZ_PSG2, $00, $40>>3, $00, v00
00011BC6 0000                     M 	dc.w	mus_wwz_psg2-spointzero
00011BC8 0008 0000                M 	dc.b	$00,$40>>3,$00,v00
00011BCC                            	sHeaderPSG	Mus_WWZ_PSG3, $00, $18>>3, $00, v00
00011BCC 0000                     M 	dc.w	mus_wwz_psg3-spointzero
00011BCE 0003 0000                M 	dc.b	$00,$18>>3,$00,v00
00011BD2                            
00011BD2                            Mus_WWZ_DAC:
00011BD2                            Mus_WWZ_DAC2:
00011BD2                            Mus_WWZ_FM1:
00011BD2                            Mus_WWZ_FM2:
00011BD2                            Mus_WWZ_FM3:
00011BD2                            Mus_WWZ_FM4:
00011BD2                            Mus_WWZ_FM5:
00011BD2                            Mus_WWZ_PSG1:
00011BD2                            Mus_WWZ_PSG2:
00011BD2                            Mus_WWZ_PSG3:
00011BD2                            	sStop
00011BD2 F5                       M 	dc.b	$f5
00011BD4 00                         		even
00011BD4                            Mus_Boss:
00011BD4                            		include	"Sound/music/Boss.asm"
00011BD4                            Boss_Header:
00011BD4                            	sHeaderInit
00011BD4 =00011BD4                M spointzero	=	*
00011BD4 =00000000                M spatnum	=	0
00011BD4                            	sHeaderTempo	$01, $1D
00011BD4 001D                     M 	dc.b	$01-1,$1d
00011BD6                            	sHeaderCh	$05, $03
00011BD6 04                       M 	dc.b	$05-1
00011BD7 02                       M 	dc.b	$03-1
00011BD8                            
00011BD8                            	sHeaderDAC	Boss_DAC2
00011BD8 0000                     M 	dc.w	boss_dac2-spointzero
00011BDA 0000                     M 	dc.w	$00
00011BDC                            	sHeaderDAC	Boss_DAC
00011BDC 0000                     M 	dc.w	boss_dac-spointzero
00011BDE 0000                     M 	dc.w	$00
00011BE0                            	sHeaderFM	Boss_FM1,	$0C, $0A
00011BE0 0000                     M 	dc.w	boss_fm1-spointzero
00011BE2 0C0A                     M 	dc.b	$0c,$0a
00011BE4                            	sHeaderFM	Boss_FM2,	$0C, $06
00011BE4 0000                     M 	dc.w	boss_fm2-spointzero
00011BE6 0C06                     M 	dc.b	$0c,$06
00011BE8                            	sHeaderFM	Boss_FM3,	$0C, $08
00011BE8 0000                     M 	dc.w	boss_fm3-spointzero
00011BEA 0C08                     M 	dc.b	$0c,$08
00011BEC                            	sHeaderFM	Boss_FM4,	$00, $0F
00011BEC 0000                     M 	dc.w	boss_fm4-spointzero
00011BEE 000F                     M 	dc.b	$00,$0f
00011BF0                            	sHeaderFM	Boss_FM5,	$00, $0F
00011BF0 0000                     M 	dc.w	boss_fm5-spointzero
00011BF2 000F                     M 	dc.b	$00,$0f
00011BF4                            	sHeaderPSG	Boss_PSG1,	$E8-$0C, $04, $00, v0C
00011BF4 0000                     M 	dc.w	boss_psg1-spointzero
00011BF6 DC04 000C                M 	dc.b	$e8-$0c,$04,$00,v0c
00011BFA                            	sHeaderPSG	Boss_PSG2,	$E8-$0C, $06, $00, v0C
00011BFA 0000                     M 	dc.w	boss_psg2-spointzero
00011BFC DC06 000C                M 	dc.b	$e8-$0c,$06,$00,v0c
00011C00                            	sHeaderPSG	Boss_PSG3,	$FE-$0C, $03, $00, v04
00011C00 0000                     M 	dc.w	boss_psg3-spointzero
00011C02 F203 0004                M 	dc.b	$fe-$0c,$03,$00,v04
00011C06                            
00011C06                            ; FM1 Data
00011C06                            Boss_FM1:
00011C06                            	sVoice        $56
00011C06 E856                     M 	dc.b	$e8,$56
00011C08                            
00011C08                            Boss_Jump01:
00011C08                            	sNoteTimeOut        $08
00011C08 FD08                     M 	dc.b	$fd,$08
00011C0A                            	sCall            Boss_Call02
00011C0A F8                       M 	dc.b	$f8
00011C0B 0000                     M 	dc.w	boss_call02-*-1
00011C0D                            	sNoteTimeOut        $0A
00011C0D FD0A                     M 	dc.b	$fd,$0a
00011C0F                            
00011C0F                            Boss_Loop0B:
00011C0F 910C 9D                    	dc.b	nE1, $0C, nE2
00011C12                            	sLoop            $00, $04, Boss_Loop0B
00011C12 F700                     M 	dc.b	$f7,$00
00011C14 FFFA                     M 	dc.w	boss_loop0b-*-1
00011C16 04                       M 	dc.b	$04
00011C17                            	sNoteTimeOut        $08
00011C17 FD08                     M 	dc.b	$fd,$08
00011C19                            	sCall            Boss_Call02
00011C19 F8                       M 	dc.b	$f8
00011C1A 0000                     M 	dc.w	boss_call02-*-1
00011C1C                            	sNoteTimeOut        $0A
00011C1C FD0A                     M 	dc.b	$fd,$0a
00011C1E 910C 9D93 9F94 A095 A1     	dc.b	nE1, $0C, nE2, nFs1, nFs2, nG1, nG2, nAb1, nAb2
00011C27                            
00011C27                            Boss_Loop0C:
00011C27                            	sCall            Boss_Call03
00011C27 F8                       M 	dc.b	$f8
00011C28 0000                     M 	dc.w	boss_call03-*-1
00011C2A 940C A006 A094 0CA0 06A0   	dc.b	nG1, $0C, nG2, $06, nG2, nG1, $0C, nG2, $06, nG2
00011C34                            	sCall            Boss_Call03
00011C34 F8                       M 	dc.b	$f8
00011C35 0000                     M 	dc.w	boss_call03-*-1
00011C37 910C 9D06 9D91 0C9D 069D   	dc.b	nE1, $0C, nE2, $06, nE2, nE1, $0C, nE2, $06, nE2
00011C41                            	sLoop            $00, $04, Boss_Loop0C
00011C41 F700                     M 	dc.b	$f7,$00
00011C43 FFE3                     M 	dc.w	boss_loop0c-*-1
00011C45 04                       M 	dc.b	$04
00011C46                            	ssJump            Boss_Jump01
00011C46 F6                       M 	dc.b	$f6
00011C47 FFC0                     M 	dc.w	boss_jump01-*-1
00011C49                            
00011C49                            Boss_Call03:
00011C49 960C A206 A296 0CA2 06A2+  	dc.b	nA1, $0C, nA2, $06, nA2, nA1, $0C, nA2, $06, nA2, nA1, $0C
00011C55 A206 A296 0CA2 06A2 940C+  	dc.b	nA2, $06, nA2, nA1, $0C, nA2, $06, nA2, nG1, $0C, nG2, $06
00011C61 A094 0CA0 06A0             	dc.b	nG2, nG1, $0C, nG2, $06, nG2
00011C67                            	sRet
00011C67 F9                       M 	dc.b	$f9
00011C68                            
00011C68                            Boss_Call02:
00011C68 960C A2A2 96A2 A296 A2     	dc.b	nA1, $0C, nA2, nA2, nA1, nA2, nA2, nA1, nA2
00011C71                            	sRet
00011C71 F9                       M 	dc.b	$f9
00011C72                            
00011C72                            ; PSG1 Data
00011C72                            Boss_PSG1:
00011C72                            ; PSG2 Data
00011C72                            Boss_PSG2:
00011C72                            Boss_DAC2:
00011C72                            	sStop
00011C72 F5                       M 	dc.b	$f5
00011C73                            
00011C73                            ; FM2 Data
00011C73                            Boss_FM2:
00011C73                            	sVoice        $58
00011C73 E858                     M 	dc.b	$e8,$58
00011C75                            
00011C75                            Boss_Loop09:
00011C75                            	sNoteTimeOut        $08
00011C75 FD08                     M 	dc.b	$fd,$08
00011C77 AE0C A9A9 AEA9 A9AE A9     	dc.b	nA3, $0C, nE3, nE3, nA3, nE3, nE3, nA3, nE3
00011C80                            	sNoteTimeOut        $17
00011C80 FD17                     M 	dc.b	$fd,$17
00011C82 B018 B0B0 B0               	dc.b	nB3, $18, nB3, nB3, nB3
00011C87                            	sLoop            $00, $02, Boss_Loop09
00011C87 F700                     M 	dc.b	$f7,$00
00011C89 FFEB                     M 	dc.w	boss_loop09-*-1
00011C8B 02                       M 	dc.b	$02
00011C8C                            	saTranspose      $F4
00011C8C E4F4                     M 	dc.b	$e4,$f4
00011C8E                            	sVoice        $59
00011C8E E859                     M 	dc.b	$e8,$59
00011C90                            
00011C90                            Boss_Loop0A:
00011C90                            	sCall            Boss_Call01
00011C90 F8                       M 	dc.b	$f8
00011C91 0000                     M 	dc.w	boss_call01-*-1
00011C93                            	sLoop            $00, $04, Boss_Loop0A
00011C93 F700                     M 	dc.b	$f7,$00
00011C95 FFFA                     M 	dc.w	boss_loop0a-*-1
00011C97 04                       M 	dc.b	$04
00011C98                            	saTranspose      $0C
00011C98 E40C                     M 	dc.b	$e4,$0c
00011C9A                            	ssJump            Boss_FM2
00011C9A F6                       M 	dc.b	$f6
00011C9B FFD7                     M 	dc.w	boss_fm2-*-1
00011C9D                            
00011C9D                            Boss_Call01:
00011C9D AE06 80B0 80B1 18B3 B1B0+  	dc.b	nA3, $06, nRst, nB3, nRst, nC4, $18, nD4, nC4, nB3, $06, nRst
00011CA9 B180 B080 AC18 A906 80AC+  	dc.b	nC4, nRst, nB3, nRst, nG3, $18, nE3, $06, nRst, nG3, $18, nA3
00011CB5 0680 B080 B118 B3B1 B006+  	dc.b	$06, nRst, nB3, nRst, nC4, $18, nD4, nC4, nB3, $06, nRst, nC4
00011CC1 80B3 80B4 80B5 0C80 24     	dc.b	nRst, nD4, nRst, nEb4, nRst, nE4, $0C, nRst, $24
00011CCA                            	sRet
00011CCA F9                       M 	dc.b	$f9
00011CCB                            
00011CCB                            ; FM3 Data
00011CCB                            Boss_FM3:
00011CCB                            	sVoice        $58
00011CCB E858                     M 	dc.b	$e8,$58
00011CCD                            
00011CCD                            Boss_Loop06:
00011CCD                            	sNoteTimeOut        $08
00011CCD FD08                     M 	dc.b	$fd,$08
00011CCF B10C AEAE B1AE AEB1 AE     	dc.b	nC4, $0C, nA3, nA3, nC4, nA3, nA3, nC4, nA3
00011CD8                            	sNoteTimeOut        $17
00011CD8 FD17                     M 	dc.b	$fd,$17
00011CDA AD18 ADAD AD               	dc.b	nAb3, $18, nAb3, nAb3, nAb3
00011CDF                            	sLoop            $00, $02, Boss_Loop06
00011CDF F700                     M 	dc.b	$f7,$00
00011CE1 FFEB                     M 	dc.w	boss_loop06-*-1
00011CE3 02                       M 	dc.b	$02
00011CE4                            
00011CE4                            Boss_Loop07:
00011CE4 8030                       	dc.b	nRst, $30
00011CE6                            	sLoop            $00, $10, Boss_Loop07
00011CE6 F700                     M 	dc.b	$f7,$00
00011CE8 FFFB                     M 	dc.w	boss_loop07-*-1
00011CEA 10                       M 	dc.b	$10
00011CEB                            	ssDetune       $03
00011CEB E103                     M 	dc.b	$e1,$03
00011CED                            	saVol        $FC
00011CED EDFC                     M 	dc.b	$ed,$fc
00011CEF                            
00011CEF                            Boss_Loop08:
00011CEF                            	sCall            Boss_Call01
00011CEF F8                       M 	dc.b	$f8
00011CF0 FFAC                     M 	dc.w	boss_call01-*-1
00011CF2                            	sLoop            $00, $02, Boss_Loop08
00011CF2 F700                     M 	dc.b	$f7,$00
00011CF4 FFFA                     M 	dc.w	boss_loop08-*-1
00011CF6 02                       M 	dc.b	$02
00011CF7                            	ssDetune       $00
00011CF7 E100                     M 	dc.b	$e1,$00
00011CF9                            	saVol        $04
00011CF9 ED04                     M 	dc.b	$ed,$04
00011CFB                            	ssJump            Boss_FM3
00011CFB F6                       M 	dc.b	$f6
00011CFC FFCE                     M 	dc.w	boss_fm3-*-1
00011CFE                            
00011CFE                            ; FM4 Data
00011CFE                            Boss_FM4:
00011CFE                            	sPan             spLeft, $00
00011CFE E080                     M 	dc.b	$e0,spleft|$00
00011D00                            	ssDetune       $02
00011D00 E102                     M 	dc.b	$e1,$02
00011D02                            	ssMod68k          $0C, $01, $04, $04
00011D02 F00C 0104 04             M 	dc.b	$f0,$0c,$01,$04,$04
00011D07                            	ssJump            Boss_Jump00
00011D07 F6                       M 	dc.b	$f6
00011D08 0000                     M 	dc.w	boss_jump00-*-1
00011D0A                            
00011D0A                            ; FM5 Data
00011D0A                            Boss_FM5:
00011D0A                            	sPan             spRight, $00
00011D0A E040                     M 	dc.b	$e0,spright|$00
00011D0C                            	ssMod68k          $0C, $01, $FC, $04
00011D0C F00C 01FC 04             M 	dc.b	$f0,$0c,$01,$fc,$04
00011D11                            
00011D11                            Boss_Jump00:
00011D11                            	sModOff
00011D11 EC                       M 	dc.b	$ec
00011D12                            	sVoice        $57
00011D12 E857                     M 	dc.b	$e8,$57
00011D14 8030 8024 BF06 C1C2 0CC2+  	dc.b	nRst, $30, nRst, $24, nD5, $06, nE5, nF5, $0C, nF5, nE5, nE5
00011D20 BFBF C180 8030 8024 BF06+  	dc.b	nD5, nD5, nE5, nRst, nRst, $30, nRst, $24, nD5, $06, nE5, nF5
00011D2C 0CC1 C0C1 C518 C1          	dc.b	$0C, nE5, nEb5, nE5, nAb5, $18, nE5
00011D33                            
00011D33                            Boss_Loop05:
00011D33 8030 80                    	dc.b	nRst, $30, nRst
00011D36                            	sLoop            $00, $04, Boss_Loop05
00011D36 F700                     M 	dc.b	$f7,$00
00011D38 FFFA                     M 	dc.w	boss_loop05-*-1
00011D3A 04                       M 	dc.b	$04
00011D3B                            	sModOn
00011D3B EB                       M 	dc.b	$eb
00011D3C                            	saVol        $02
00011D3C ED02                     M 	dc.b	$ed,$02
00011D3E                            	sCall            Boss_Call00
00011D3E F8                       M 	dc.b	$f8
00011D3F 0000                     M 	dc.w	boss_call00-*-1
00011D41 AC                         	dc.b	nG3
00011D42                            	sCall            Boss_Call00
00011D42 F8                       M 	dc.b	$f8
00011D43 0000                     M 	dc.w	boss_call00-*-1
00011D45 ADBD E718 BF0C BDBC 30B8+  	dc.b	nAb3, nC5, sHold, $18, nD5, $0C, nC5, nB4, $30, nG4, nC5, sHold
00011D51 18BF 0CBD BC30 B9          	dc.b	$18, nD5, $0C, nC5, nB4, $30, nAb4
00011D58                            	saVol        $F5
00011D58 EDF5                     M 	dc.b	$ed,$f5
00011D5A                            	sVoice        $58
00011D5A E858                     M 	dc.b	$e8,$58
00011D5C BD06 80BF 80C1 18C2 C1BF+  	dc.b	nC5, $06, nRst, nD5, nRst, nE5, $18, nF5, nE5, nD5, $06, nRst
00011D68 C180 BF80 BC18 B806 80BC+  	dc.b	nE5, nRst, nD5, nRst, nB4, $18, nG4, $06, nRst, nB4, $18, nC5
00011D74 0680 BF80 C118 C2C1 BF06+  	dc.b	$06, nRst, nD5, nRst, nE5, $18, nF5, nE5, nD5, $06, nRst, nE5
00011D80 80C2 80C3 80C5 0C80 24     	dc.b	nRst, nF5, nRst, nFs5, nRst, nAb5, $0C, nRst, $24
00011D89                            	saVol        $09
00011D89 ED09                     M 	dc.b	$ed,$09
00011D8B                            	ssJump            Boss_Jump00
00011D8B F6                       M 	dc.b	$f6
00011D8C FF84                     M 	dc.w	boss_jump00-*-1
00011D8E                            
00011D8E                            Boss_Call00:
00011D8E B130 E718 B30C B1B0 30     	dc.b	nC4, $30, sHold, $18, nD4, $0C, nC4, nB3, $30
00011D97                            	sRet
00011D97 F9                       M 	dc.b	$f9
00011D98                            
00011D98                            ; PSG3 Data
00011D98                            Boss_PSG3:
00011D98                            	sNoisePSG         $E7
00011D98 F3E7                     M 	dc.b	$f3,$e7
00011D9A                            	sNoteTimeOut        $05
00011D9A FD05                     M 	dc.b	$fd,$05
00011D9C                            
00011D9C                            Boss_Loop0D:
00011D9C C624 2418 8030 80          	dc.b	nA5, $24, $24, $18, nRst, $30, nRst
00011DA3                            	sLoop            $00, $02, Boss_Loop0D
00011DA3 F700                     M 	dc.b	$f7,$00
00011DA5 FFF6                     M 	dc.w	boss_loop0d-*-1
00011DA7 02                       M 	dc.b	$02
00011DA8                            
00011DA8                            Boss_Loop0E:
00011DA8 C618                       	dc.b	nA5, $18
00011DAA                            	sLoop            $00, $40, Boss_Loop0E
00011DAA F700                     M 	dc.b	$f7,$00
00011DAC FFFB                     M 	dc.w	boss_loop0e-*-1
00011DAE 40                       M 	dc.b	$40
00011DAF                            	ssJump            Boss_Loop0D
00011DAF F6                       M 	dc.b	$f6
00011DB0 FFEB                     M 	dc.w	boss_loop0d-*-1
00011DB2                            
00011DB2                            ; DAC Data
00011DB2                            Boss_DAC:
00011DB2 830C 8383 8383 8383 8387+  	dc.b	dSnare, $0C, dSnare, dSnare, dSnare, dSnare, dSnare, dSnare, dSnare, dTomMid, $0C, dTomL
00011DBE 8789 8789 8789             	dc.b	dTomMid, dTomL, dTomMid, dTomL, dTomMid, dTomL
00011DC4                            	sLoop            $00, $02, Boss_DAC
00011DC4 F700                     M 	dc.b	$f7,$00
00011DC6 FFEB                     M 	dc.w	boss_dac-*-1
00011DC8 02                       M 	dc.b	$02
00011DC9 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00011DCE                            
00011DCE                            Boss_Loop00:
00011DCE 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00011DD3                            	sLoop            $00, $06, Boss_Loop00
00011DD3 F700                     M 	dc.b	$f7,$00
00011DD5 FFF8                     M 	dc.w	boss_loop00-*-1
00011DD7 06                       M 	dc.b	$06
00011DD8 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
00011DE4 8306 83                    	dc.b	dSnare, $06, dSnare
00011DE7                            
00011DE7                            Boss_Loop01:
00011DE7 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00011DEC                            	sLoop            $00, $05, Boss_Loop01
00011DEC F700                     M 	dc.b	$f7,$00
00011DEE FFF8                     M 	dc.w	boss_loop01-*-1
00011DF0 05                       M 	dc.b	$05
00011DF1 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
00011DFD 8302 8704 8302 8704 890C+  	dc.b	dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C, dSnare, $06
00011E09 83                         	dc.b	dSnare
00011E0A                            	sLoop            $01, $03, Boss_Loop00
00011E0A F701                     M 	dc.b	$f7,$01
00011E0C FFC1                     M 	dc.w	boss_loop00-*-1
00011E0E 03                       M 	dc.b	$03
00011E0F                            
00011E0F                            Boss_Loop02:
00011E0F 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00011E14                            	sLoop            $00, $06, Boss_Loop02
00011E14 F700                     M 	dc.b	$f7,$00
00011E16 FFF8                     M 	dc.w	boss_loop02-*-1
00011E18 06                       M 	dc.b	$06
00011E19 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
00011E25 8306 83                    	dc.b	dSnare, $06, dSnare
00011E28                            
00011E28                            Boss_Loop03:
00011E28 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00011E2D                            	sLoop            $00, $03, Boss_Loop03
00011E2D F700                     M 	dc.b	$f7,$00
00011E2F FFF8                     M 	dc.w	boss_loop03-*-1
00011E31 03                       M 	dc.b	$03
00011E32                            
00011E32                            Boss_Loop04:
00011E32 890C 8302 8704 8302 8704   	dc.b	dTomL, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04
00011E3C                            	sLoop            $00, $04, Boss_Loop04
00011E3C F700                     M 	dc.b	$f7,$00
00011E3E FFF3                     M 	dc.w	boss_loop04-*-1
00011E40 04                       M 	dc.b	$04
00011E41                            	ssJump            Boss_DAC
00011E41 F6                       M 	dc.b	$f6
00011E42 FF6F                     M 	dc.w	boss_dac-*-1
00011E44                            		even
00011E44                            
00011E44                            ; -------------------------------------------------------------------------
00011E44                            musend
00011E44                            ; ===========================================================================
00011E44                            ; ---------------------------------------------------------------------------
00011E44                            ; Include samples and filters
00011E44                            ; ---------------------------------------------------------------------------
00011E44                            
00011E44                            		align	$8000		; must be aligned to bank...
00011E44                          M 	cnop	0,$8000
00018000                            fLog:		incbin "Sound/amps/filters/Logarithmic.dat"	; logarithmic filter (no filter)
00020000                            ;fLinear:	incbin "Sound/amps/filters/Linear.dat"	; linear filter (no filter)
00020000                            
00020000                            dacaddr		dcb.b	Z80E_Read*(MaxPitch/$100),$00
00020180                            SWF_Stop:	dcb.b	$8000-(2*Z80E_Read*(MaxPitch/$100)),$80
00027E80                            SWFR_Stop:	dcb.b	Z80E_Read*(MaxPitch/$100),$00
00028000                            
00028000                            	include	"Sound/dacdata.asm"
00028000                            
00028000                            
00028000                            ; ------------------------------------------------------------------------
00028000                            ; AMPS sample data
00028000                            ; -------------------------------------------------------------------------
00028000                            
00028000                            	incSWF	Kick,		"Sound/dac/incswf/Kick.swf"
00028000                          M swf_kick	incbin	"Sound/dac/incswf/Kick.swf"
00028E4A                          M swfr_kick	dcb.b	z80e_read*(maxpitch/$100),$00
00028FCA                            	incSWF	Snare,		"Sound/dac/incswf/Snare.swf"
00028FCA                          M swf_snare	incbin	"Sound/dac/incswf/Snare.swf"
0002B874                          M swfr_snare	dcb.b	z80e_read*(maxpitch/$100),$00
0002B9F4                            	incSWF	Tom,		"Sound/dac/incswf/Space Tom.swf"
0002B9F4                          M swf_tom	incbin	"Sound/dac/incswf/Space Tom.swf"
0002E288                          M swfr_tom	dcb.b	z80e_read*(maxpitch/$100),$00
0002E408                            	incSWF	Title,		"Sound/dac/incswf/Title.swf"
0002E408                          M swf_title	incbin	"Sound/dac/incswf/Title.swf"
00084EC7                          M swfr_title	dcb.b	z80e_read*(maxpitch/$100),$00
00085047                            	incSWF	Sega,		"Sound/dac/incswf/Sega.swf"
00085047                          M swf_sega	incbin	"Sound/dac/incswf/Sega.swf"
0008AC9D                          M swfr_sega	dcb.b	z80e_read*(maxpitch/$100),$00
0008AE1D                            	incSWF	Punch,		"Sound/dac/incswf/Punch.swf"
0008AE1D                          M swf_punch	incbin	"Sound/dac/incswf/Punch.swf"
0008D145                          M swfr_punch	dcb.b	z80e_read*(maxpitch/$100),$00
0008D2C5                            	incSWF	EndingSong,	"Sound/dac/incswf/EndingSong.swf"
0008D2C5                          M swf_endingsong	incbin	"Sound/dac/incswf/EndingSong.swf"
0009A6D8                          M swfr_endingsong	dcb.b	z80e_read*(maxpitch/$100),$00
0009A858                            	incSWF	BinBowie,	"Sound/dac/incswf/BinBowie.swf"
0009A858                          M swf_binbowie	incbin	"Sound/dac/incswf/BinBowie.swf"
000AF3FE                          M swfr_binbowie	dcb.b	z80e_read*(maxpitch/$100),$00
000AF57E                            	incSWF	Wacky_Base_Loud,"Sound/dac/incswf/Wacky_Base_Loud.swf"
000AF57E                          M swf_wacky_base_loud	incbin	"Sound/dac/incswf/Wacky_Base_Loud.swf"
000BB808                          M swfr_wacky_base_loud	dcb.b	z80e_read*(maxpitch/$100),$00
000BB988                            
000BB988                            ; -------------------------------------------------------------------------
000BB988                            	opt ae+				; enable automatic evens
000BB988                            	list				; continue source listing
000BB988                            ; ===========================================================================
000BB988                            DualPCM:
000BB988                            		z80prog	0
000BB988                          M 	pusho
000BB988                          M 	opt	ae-
000BB988                          M 	opt	an+
00000000                            		include	"Sound/amps/code/Z80.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DUAL-PCM - by MarkeyJester
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Read		macro
00000000                            		ldi					; 16	; copy from window to buffer, and increment register
00000000                            		zadd	a,b				; 04	; add dividend
00000000                            		adc	hl,sp				; 15	; add quotient
00000000                            		endm					; Total: 35
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_CapPCM	macro
00000000                            		jp	po, .ov\@			; 10	; if the sample hasn't overflown the 7F/80 boundary, branch
00000000                            		sbc	a,a				; 04	; erase sample, and subtract the carry to get either FF or 00, depending on overflow direction
00000000                            		xor	07Fh				; 07	; reverse FF/00 (xor 80 below helps)
00000000                            .ov\@		xor	080h				; 07	; convert to unsigned
00000000                            		endm					; Total: 17/28
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush01	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 2 to volume 1
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush02	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 1 to volume 2
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert01	macro
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert02	macro
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Wrap		macro
00000000                            		dec	l				; 04	; check l...
00000000                            		inc	l				; 04	; ''
00000000                            		M_WrapCondition
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_WrapCondition	macro
00000000                            		jp	nz, .c\@			; 10	; if it's not 0, branch
00000000                            		inc	h				; 04	; advance OUT buffers
00000000                            		bit	004h,h				; 08	; have the OUT buffer addresses reached 1000 (end of buffer) yet?
00000000                            		jp	z, .c\@				; 10	; if not, branch
00000000                            		ld	hl,PCM_Buffer2			; 10	; reset OUT buffers
00000000                            .c\@
00000000                            		endm
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start of Z80 ROM
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80_Start:
0000000B                            
0000000B 0000 0000 00               		align	MaxPitch/$100
00000010                            
00000010                            	; The space from "Start" until the maximum pitch amount, is the space
00000010                            	; where data could potentially be pushed into, thanks to the sp.
00000010                            
00000010                            	; The sp will likely be from roughly FFEF - 000F for the quotient of
00000010                            	; the pitch.  Now, FFEF - FFFF will be fine, since that points to the
00000010                            	; 68k window, which will be pointing to 68k ROM, so nothing will happen.
00000010                            	; But the address from 0000 - 000F points to the beginning of ROM, so
00000010                            	; this place must be free from use outside of V-blank.
00000010                            
00000010                            Z80_Stack:
00000010                            
00000010                            ; ===========================================================================
00000010                            ; ---------------------------------------------------------------------------
00000010                            ; PCM 1 Resetting
00000010                            ; ---------------------------------------------------------------------------
00000010                            		align	010h
00000010                            ; ---------------------------------------------------------------------------
00000010                            
00000010                            BreakLate:
00000019                            
00000019                            ; ===========================================================================
00000019                            ; ---------------------------------------------------------------------------
00000019                            ; PCM 1 Resetting
00000019                            ; ---------------------------------------------------------------------------
00000019 0000 0000 0000 0000 0000+  		align	028h
00000028                            ; ---------------------------------------------------------------------------
00000028                            
00000028                            PCM1_ResetJmp:
0000002B                            
0000002B                            ; ===========================================================================
0000002B                            ; ---------------------------------------------------------------------------
0000002B                            ; PCM 2 Resetting
0000002B                            ; ---------------------------------------------------------------------------
0000002B 0000 0000 00               		align	030h
00000030                            ; ---------------------------------------------------------------------------
00000030                            
00000030                            PCM2_ResetJmp:
00000033                            
00000033                            ; ===========================================================================
00000033                            ; ---------------------------------------------------------------------------
00000033                            ; Breaking out for V-blank
00000033                            ; ---------------------------------------------------------------------------
00000033 0000 0000 00               		align	038h
00000038                            ; ---------------------------------------------------------------------------
00000038                            
00000038                            BreakVBlank:
0000003C 2F                         		cpl					; 04	; change buffer
00000040                            
00000040                            BVB_Check:
00000046                            
00000046                            ; ---------------------------------------------------------------------------
00000046                            ; Breaking out for V-blank, during non-read
00000046                            ; ---------------------------------------------------------------------------
00000046                            
00000046                            BreakPrep:
00000061                            	;	ei					; 04	; enable interrupts
00000061 ED4D                       		reti					; 14	; return
00000063                            
00000063                            ; ===========================================================================
00000063                            ; ---------------------------------------------------------------------------
00000063                            ; Breaking out for V-blank, during read of window or bank register
00000063                            ; ---------------------------------------------------------------------------
00000063                            
00000063                            BreakDMA:
00000066                            
00000066                            	; --- Finding out which registers we're dealing with ---
00000066                            
00000074 1F                         BDMA_NoExchange:	rra					; 04	; get buffer we're currently reading from
00000083 D9                         BDMA_NoFixFlush:	exx					; 04	; swap to the "read" set of exx registers
00000084                            BDMA_ReadSet:
00000084                            
00000084                            ; ---------------------------------------------------------------------------
00000084                            ; Flush remaining data
00000084                            ; ---------------------------------------------------------------------------
00000084                            
00000084                            BreakBank:
00000084 D9                         			exx					; 04	; switch registers
00000086 D9                         			exx					; 04	; switch registers
00000087 ED44                       		zneg	a				; 08	; reverse position
00000090                            
00000090                            BDMA_NoMax:
0000009A                            
0000009A                            BDMA_FlushLoop:
0000009E                            
0000009E                            BDMA_Flush02:
0000009E D9                         			exx					; 04	; switch registers
000000B2 D9                         			exx					; 04	; switch registers
000000B7                            
000000B7                            BDMA_Flush01:
000000B7 D9                         			exx					; 04	; switch registers
000000CB D9                         			exx					; 04	; switch registers
000000D0                            
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            ; Wrapping OUT buffers
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            
000000D0 D9                         			exx					; 04	; switch registers
000000DF D9                         			exx					; 04	; switch back
000000E0                            
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            ; Restore interrupt instructions
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            
00000107                            
00000107                            BDMA_NoRestore:
00000107                            
00000107                            ; ---------------------------------------------------------------------------
00000107                            ; YM2612 flushing
00000107                            ; ---------------------------------------------------------------------------
00000107                            
0000010A                            
00000116                            
00000116                            YMF_Buff1:
0000011F D9                         			exx					; 04	; switch registers back
00000120                            
00000120                            YM_Flush:
00000123                            
00000123                            YMF_NextByte:
00000136 D9                         			exx					; 04	; switch registers
00000149 D9                         			exx					; 04	; switch registers
0000015D D9                         			exx					; 04	; switch registers
00000170 D9                         			exx					; 04	; switch registers
00000176                            
00000176                            	; --- Advance/Wrap OUT buffers ---
00000176                            
00000189                            
00000189                            YMF_Finish02:
00000192                            
00000192                            YMF_Finish01:
0000019B                            
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            ; Waiting for v-blank to finish
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            
0000019B                            PCM_Flush_exx:
0000019B D9                         			exx
0000019C                            
0000019C                            PCM_Flush:
0000019F                            
0000019F                            PCM_NextByte:
000001B2 D9                         			exx					; 04	; switch registers
000001B7                            
000001B7                            
000001B7 D9                         			exx					; 04	; switch registers
000001CB D9                         			exx					; 04	; switch registers
000001CC                            
000001D0                            
000001D0 D9                         			exx					; 04	; switch registers
000001D6                            
000001D6                            	; --- Advance/Wrap OUT buffers ---
000001D6                            
000001E4                            
000001E9 D9                         		exx					; 04	; switch registers down again...
000001EA                            
000001F6                            
000001F6                            YMF_SetBuff1:
000001F8                            
00000202                            
00000202                            VB_PCM1_VolOK:
0000020C                            
0000020C                            VB_PCM2_VolOK:
0000020C                            
0000020C 37                         		scf					; 04	; set carry flag
0000020D                            
00000222                            
00000222                            PCM_VolChangeNo:
00000222                            
00000222                            
0000022D                            
0000022D                            ; ===========================================================================
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            ; Setup/Init
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            
0000022D                            Z80_Init:
00000230                            
00000230                            	; --- YM2612 DAC Setup ---
00000230                            
0000023F                            
0000023F                            	; --- Setting up channels to be mute ---
0000023F                            
00000251                            
0000025A EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000261 EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000268 EDB0                       			ldir					; 21 16	; copy mute sample data over...
0000026F EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000271                            
00000271                            	; --- Setting up PCM 1 switch ---
00000271                            
0000027A                            
0000027A                            	; --- Setting up PCM 2 switch ---
0000027A                            
00000283                            
00000283                            	; --- Final register setup ---
00000283                            
0000028B                            
00000290                            
00000290 D9                         			exx					; 04	; switch registers
00000291                            
00000291                            ; ===========================================================================
00000291                            ; ---------------------------------------------------------------------------
00000291                            ; The catch up loop
00000291                            ; ---------------------------------------------------------------------------
00000291                            
00000291                            CatchUp:
00000291 D9                         			exx					; 04	; switch registers
00000292                            
00000292                            CatchUp_Exx:
000002A5 D9                         			exx					; 04	; switch registers
000002A6                            
000002A6                            Z80_Int2:	;ei
000002A6 00                         		znop					; 04
000002A7                            
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            ; PCM 1
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            
000002A7                            PCM1_MuteRet:
000002AC 00                         Int1_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
000002C8 D9                         			exx					; 04	; switch registers
000002DC D9                         			exx					; 04	; switch registers
000002E4                            
000002E4                            PCM1_PrepRet:
000002E4                            
000002F2                            
000002FC EDA0                       PCM1_PreInst03:	ldi					; 16	; copy from window to buffer, and increment register
000002FE D9                         			exx					; 04	; switch registers
00000313 D9                         			exx					; 04	; switch registers
0000032C D9                         			exx					; 04	; switch registers
00000341 D9                         			exx					; 04	; switch registers
00000357 EDA0                       PCM1_PreInst0C:	ldi					; 16	; copy from window to buffer, and increment register
00000359 D9                         			exx					; 04	; switch registers
0000036E D9                         			exx					; 04	; switch registers
00000387 D9                         			exx					; 04	; switch registers
0000039C D9                         			exx					; 04	; switch registers
000003B2 EDA0                       PCM1_PreInst15:	ldi					; 16	; copy from window to buffer, and increment register
000003B4 D9                         			exx					; 04	; switch registers
000003C9 D9                         			exx					; 04	; switch registers
000003E6 D9                         			exx					; 04	; switch registers
000003FB D9                         			exx					; 04	; switch registers
00000403                            
00000403                            ; ---------------------------------------------------------------------------
00000403                            ; PCM 2
00000403                            ; ---------------------------------------------------------------------------
00000403                            
00000403                            PCM2_MuteRet:
00000408 00                         Int2_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
0000041A D9                         			exx					; 04	; switch registers
0000042E D9                         			exx					; 04	; switch registers
00000440                            
00000440                            PCM2_PrepRet:
00000440                            
0000044E                            
00000453 D9                         			exx					; 04	; switch registers
00000468 D9                         			exx					; 04	; switch registers
0000047E EDA0                       PCM2_PreInst06:	ldi					; 16	; copy from window to buffer, and increment register
00000480 D9                         			exx					; 04	; switch registers
00000495 D9                         			exx					; 04	; switch registers
000004AE D9                         			exx					; 04	; switch registers
000004C3 D9                         			exx					; 04	; switch registers
000004D9 EDA0                       PCM2_PreInst0F:	ldi					; 16	; copy from window to buffer, and increment register
000004DB D9                         			exx					; 04	; switch registers
000004F0 D9                         			exx					; 04	; switch registers
00000509 D9                         			exx					; 04	; switch registers
0000051E D9                         			exx					; 04	; switch registers
00000534 EDA0                       PCM2_PreInst18:	ldi					; 16	; copy from window to buffer, and increment register
00000536 D9                         			exx					; 04	; switch registers
0000054B D9                         			exx					; 04	; switch registers
0000055F                            
00000570                            
00000570                            ; ---------------------------------------------------------------------------
00000570                            ; Wrapping OUT buffers
00000570                            ; ---------------------------------------------------------------------------
00000570                            
00000570 D9                         			exx					; 04	; switch registers
00000590 D9                         			exx					; 04	; switch back
00000591                            
00000591                            ; ---------------------------------------------------------------------------
00000591                            ; Wrap IN buffers
00000591                            ; ---------------------------------------------------------------------------
00000591                            
000005A3                            
000005A3                            PCM_BuffNoReset:
000005A3                            
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            ; Rebank...
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            
000005A3 37                         		scf					; 04	; set carry flag
000005BA 37                         		scf					; 04	; set carry flag
000005BB                            
000005BB                            PCM1_IgnoreBank:
000005D1 37                         		scf					; 04	; set carry flag
000005D2                            
000005D2                            PCM2_IgnoreBank:
000005D2                            
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            ; Pitch control
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            
000005DA                            
00000602 37                         		scf					; 04	; set carry flag
00000603                            
00000603                            PCM1_IgnorePitch:
00000603                            
0000060B                            
00000633 37                         		scf					; 04	; set carry flag
00000634                            
00000634                            PCM2_IgnorePitch:
00000634                            
00000634                            ; ---------------------------------------------------------------------------
00000634                            ; Updating Volume
00000634                            ; ---------------------------------------------------------------------------
00000634                            
0000064B                            	;	scf					; 04	; don't think it's necessary here...
0000064B                            
0000064E                            PCM_VolumeRet:
0000064E                            
0000064E                            
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            ; New samples...
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            
00000654                            
00000654                            ; ---------------------------------------------------------------------------
00000654                            ; Checking for "Flush" mode
00000654                            ; ---------------------------------------------------------------------------
00000654                            
00000654                            PCM_NoUpdate:
00000654 D9                         		exx					; 04	; switch registers
00000656 1F                         			rra					; 04	; get upper bit only into carry
00000658 1F                         			rra					; 04	; shift address down with carry
00000659 D9                         		exx					; 04	; switch registers
0000066A                            
0000066A                            CU_ValidDist:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; New sample playback
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F                            CU_Flush:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; Main "Flush" loop
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F D9                         			exx					; 04	; switch registers back
00000673                            
00000673                            FL_NextByte:
00000686 D9                         			exx					; 04	; switch registers
0000068C D9                         			exx					; 04	; switch registers
000006A0 D9                         			exx					; 04	; switch registers
000006A5 D9                         			exx					; 04	; switch registers
000006A6                            
000006AB                            
000006AB                            	; --- Advance/Wrap OUT buffers ---
000006AB                            
000006BC                            
000006BC                            ; ===========================================================================
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            ; When PCM sample 1 has reached an end marker & needs to loop back
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            
000006BC                            PCM1_Mute:
000006CE                            
000006CE                            PCM1_Normal:
000006D4                            
000006D4                            PCM1_Reverse:
000006E4 D9                         			exx					; 04	; switch registers
000006E9 D9                         			exx					; 04	; switch registers
000006ED                            
000006ED                            ; ===========================================================================
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            ; When PCM sample 1 address has reached the end of a window, just to play the last bit
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            
000006ED                            PCM1_PrepReset:
000006FC                            
000006FC                            PCM1_PrepCount:
00000715 D9                         			exx					; 04	; switch registers
00000729 D9                         			exx					; 04	; switch registers
00000731                            
00000731                            ; ===========================================================================
00000731                            ; ---------------------------------------------------------------------------
00000731                            ; When PCM sample 1 address has gone outside the window, and needs to reset
00000731                            ; ---------------------------------------------------------------------------
00000731                            
00000731                            PCM1_Reset:
0000074B                            
00000755                            
00000758                            
0000075A                            
0000075F                            
0000076B                            
00000771 0F                         		rrca					; 04
00000773 0F                         		rrca					; 04
00000775 0F                         		rrca					; 04
00000777 0F                         		rrca					; 04
00000779 0F                         		rrca					; 04
0000077B 0F                         		rrca					; 04
0000077D 0F                         		rrca					; 04
00000780                            
00000782                            
00000787                            
00000797                            
0000079A                            
0000079A                            ; ===========================================================================
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            ; 68K SET - routine to load a new sample 1
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            
0000079A                            PCM1_NewSample:
000007AA                            
000007AA                            PCM1_NewNormal:
000007B0                            
000007B0                            PCM1_NewReverse:
000007C0                            
000007C5 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000007C7                            
000007C7                            ; ===========================================================================
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            ; When PCM sample 2 has reached an end marker & needs to loop back
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            
000007C7                            PCM2_Mute:
000007D9                            
000007D9                            PCM2_Normal:
000007DF                            
000007DF                            PCM2_Reverse:
000007EF D9                         			exx					; 04	; switch registers
000007F4 D9                         			exx					; 04	; switch registers
000007F8                            
000007F8                            ; ===========================================================================
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            ; When PCM sample 2 address has reached the end of a window, just to play the last bit
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            
000007F8                            PCM2_PrepReset:
00000807                            
00000807                            PCM2_PrepCount:
00000827                            
00000827                            ; ===========================================================================
00000827                            ; ---------------------------------------------------------------------------
00000827                            ; When PCM sample 2 address has gone outside the window, and needs to reset
00000827                            ; ---------------------------------------------------------------------------
00000827                            
00000827                            PCM2_Reset:
00000841                            
0000084B                            
0000084E                            
00000850                            
00000855                            
00000861                            
00000867 0F                         		rrca					; 04
00000869 0F                         		rrca					; 04
0000086B 0F                         		rrca					; 04
0000086D 0F                         		rrca					; 04
0000086F 0F                         		rrca					; 04
00000871 0F                         		rrca					; 04
00000873 0F                         		rrca					; 04
00000876                            
00000878                            
0000087D                            
0000088D                            
00000890                            
00000890                            ; ===========================================================================
00000890                            ; ---------------------------------------------------------------------------
00000890                            ; 68K SET - routine to load a new sample 2
00000890                            ; ---------------------------------------------------------------------------
00000890                            
00000890                            PCM2_NewSample:
000008A0                            
000008A0                            PCM2_NewNormal:
000008A6                            
000008A6                            PCM2_NewReverse:
000008B6                            
000008BB 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000008BD                            
000008BD                            ; ===========================================================================
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            ; PCM volume Lists
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            		align	00200h
00000A00                            ; ---------------------------------------------------------------------------
00000A00                            
00000A00 0081 8283 8485 8687 8889+  PCM_Volume1:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000A10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000A20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000A30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000A40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000A50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000A60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000A70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000A80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000A90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000AA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000AB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000AC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000AD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000AE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000AF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000B00                            
00000B00 0081 8283 8485 8687 8889+  PCM_Volume2:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000B10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000B20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000B30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000B40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000B50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000B60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000B70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000B80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000B90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000BA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000BB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000BC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000BD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000BE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000BF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000C00                            
00000C00                            ; ===========================================================================
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            ; Bank interrupt preparation list
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            		align	00080h
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            
00000C00 F202                       PCM1_PrepTable:	dw	PCM1_PreInst01
00000C02 F702                       		dw	PCM1_PreInst02
00000C04 FC02                       		dw	PCM1_PreInst03
00000C06 1803                       		dw	PCM1_PreInst04
00000C08 1D03                       		dw	PCM1_PreInst05
00000C0A 2203                       		dw	PCM1_PreInst06
00000C0C 2703                       		dw	PCM1_PreInst07
00000C0E 4303                       		dw	PCM1_PreInst08
00000C10 4803                       		dw	PCM1_PreInst09
00000C12 4D03                       		dw	PCM1_PreInst0A
00000C14 5203                       		dw	PCM1_PreInst0B
00000C16 5703                       		dw	PCM1_PreInst0C
00000C18 7303                       		dw	PCM1_PreInst0D
00000C1A 7803                       		dw	PCM1_PreInst0E
00000C1C 7D03                       		dw	PCM1_PreInst0F
00000C1E 8203                       		dw	PCM1_PreInst10
00000C20 9E03                       		dw	PCM1_PreInst11
00000C22 A303                       		dw	PCM1_PreInst12
00000C24 A803                       		dw	PCM1_PreInst13
00000C26 AD03                       		dw	PCM1_PreInst14
00000C28 B203                       		dw	PCM1_PreInst15
00000C2A CE03                       		dw	PCM1_PreInst16
00000C2C D303                       		dw	PCM1_PreInst17
00000C2E D803                       		dw	PCM1_PreInst18
00000C30 4E04                       PCM2_PrepTable:	dw	PCM2_PreInst01
00000C32 6A04                       		dw	PCM2_PreInst02
00000C34 6F04                       		dw	PCM2_PreInst03
00000C36 7404                       		dw	PCM2_PreInst04
00000C38 7904                       		dw	PCM2_PreInst05
00000C3A 7E04                       		dw	PCM2_PreInst06
00000C3C 9A04                       		dw	PCM2_PreInst07
00000C3E 9F04                       		dw	PCM2_PreInst08
00000C40 A404                       		dw	PCM2_PreInst09
00000C42 A904                       		dw	PCM2_PreInst0A
00000C44 C504                       		dw	PCM2_PreInst0B
00000C46 CA04                       		dw	PCM2_PreInst0C
00000C48 CF04                       		dw	PCM2_PreInst0D
00000C4A D404                       		dw	PCM2_PreInst0E
00000C4C D904                       		dw	PCM2_PreInst0F
00000C4E F504                       		dw	PCM2_PreInst10
00000C50 FA04                       		dw	PCM2_PreInst11
00000C52 FF04                       		dw	PCM2_PreInst12
00000C54 0405                       		dw	PCM2_PreInst13
00000C56 2005                       		dw	PCM2_PreInst14
00000C58 2505                       		dw	PCM2_PreInst15
00000C5A 2A05                       		dw	PCM2_PreInst16
00000C5C 2F05                       		dw	PCM2_PreInst17
00000C5E 3405                       		dw	PCM2_PreInst18
00000C60                            
00000C60                            ; ===========================================================================
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            ; Specific variable data...
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            
00000C60                            	; --- Current bank address for PCM channels ---
00000C60                            
00000C60 00                         PCM1_BankCur:	db	000h					; The current bank address of PCM 1
00000C61 00                         PCM2_BankCur:	db	000h					; The current bank address of PCM 2
00000C62                            
00000C62                            	; --- "Mute Sample" pointer into 68k memory ---
00000C62                            
00000C62 0000                       MuteSample:	dw	00000h					; sample window address
00000C64 00                         MuteBank:	db	000h					; sample bank address
00000C65 0000                       MuteSample_Rev:	dw	00000h					; sample window address
00000C67 00                         MuteBank_Rev:	db	000h					; sample bank address
00000C68                            
00000C68                            	; --- YM2612 Pointers ---
00000C68                            
00000C68 00                         YM_Buffer:	db	000h					; 00 = Z80 Buffer 1 | 68k Buffer 2 ... FF = Z80 Buffer 2 | 68k Buffer 1
00000C69                            
00000C69                            ; ===========================================================================
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            ; Sample requested by 68k
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            
00000C69                            	; --- PCM 1 start sample ---
00000C69                            
00000C69 0000                       PCM1_Sample:		dw	00000h					; PCM 1 requested sample
00000C6B 00                         PCM1_Bank:		db	000h					; PCM 1 requested bank
00000C6C 0000                       PCM1_Sample_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C6E 00                         PCM1_Bank_Rev:		db	000h					; PCM 1 requested bank (reverse position)
00000C6F                            
00000C6F                            	; --- PCM 1 next sample ---
00000C6F                            
00000C6F 0000                       PCM1_SampleNext:	dw	00000h					; PCM 1 requested sample
00000C71 00                         PCM1_BankNext:		db	000h					; PCM 1 requested bank
00000C72 0000                       PCM1_SampleNext_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C74 00                         PCM1_BankNext_Rev:	db	000h					; PCM 1 requested bank (reverse position)
00000C75                            
00000C75                            	; --- PCM 2 start sample ---
00000C75                            
00000C75 0000                       PCM2_Sample:		dw	00000h					; PCM 2 requested sample
00000C77 00                         PCM2_Bank:		db	000h					; PCM 2 requested bank
00000C78 0000                       PCM2_Sample_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C7A 00                         PCM2_Bank_Rev:		db	000h					; PCM 2 requested bank (reverse position)
00000C7B                            
00000C7B                            	; --- PCM 2 next sample ---
00000C7B                            
00000C7B 0000                       PCM2_SampleNext:	dw	00000h					; PCM 2 requested sample
00000C7D 00                         PCM2_BankNext:		db	000h					; PCM 2 requested bank
00000C7E 0000                       PCM2_SampleNext_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C80 00                         PCM2_BankNext_Rev:	db	000h					; PCM 2 requested bank (reverse position)
00000C81                            
00000C81                            ; ===========================================================================
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            ; PCM buffer (1000h = start of cue, Make sure both buffers end in a multiple of 100)
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            
00000C81 0000 0000 0000 0000 0000+  		align	(01000h-00200h)-00150h
00000CB0                            PCM_Buffer1:	rept	00150h
00000CB0                            		db	080h
00000CB0 8080 8080 8080 8080 8080+  		endr
00000E00                            
00000E00 0000 0000 0000 0000 0000+  		align	01000h-00150h
00000EB0                            PCM_Buffer2:	rept	00150h
00000EB0                            		db	080h
00000EB0 8080 8080 8080 8080 8080+  		endr
00001000                            
00001000                            ; ===========================================================================
00001000                            ; ---------------------------------------------------------------------------
00001000                            ; The YM2612 operator writing lists (68k writes here, z80 must flush off)
00001000                            ; ---------------------------------------------------------------------------
00001000                            
00001000                            YM_Buffer1:	rept	00400h
00001000                            		db	0FFh
00001000 FFFF FFFF FFFF FFFF FFFF+  		endr
00001400                            
00001400                            YM_Buffer2:	rept	00400h
00001400                            		db	0FFh
00001400 FFFF FFFF FFFF FFFF FFFF+  		endr
00001800                            
00001800                            ; ===========================================================================
00001800                            ; ---------------------------------------------------------------------------
00001800                            ; Overflow calculation multiplication tables
00001800                            ; ---------------------------------------------------------------------------
00001800                            
00001800                            PCM_OverflwCalc:
00001800                            
00001800                            		; --- Lower byte ---
00001800                            
00001800 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001810 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001820 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001830 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001840 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001850 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001860 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001870 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001880 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001890 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018A0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018B0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018C0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018D0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018E0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018F0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001900                            
00001900                            		; --- Upper byte ---
00001900                            
00001900 0000 0000 0000 0000 0000+  		db	000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,001h,001h,001h,001h,001h
00001910 0101 0101 0101 0202 0202+  		db	001h,001h,001h,001h,001h,001h,002h,002h,002h,002h,002h,002h,002h,002h,002h,002h
00001920 0303 0303 0303 0303 0303+  		db	003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,004h,004h,004h,004h,004h
00001930 0404 0404 0404 0505 0505+  		db	004h,004h,004h,004h,004h,004h,005h,005h,005h,005h,005h,005h,005h,005h,005h,005h
00001940 0606 0606 0606 0606 0606+  		db	006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,007h,007h,007h,007h,007h
00001950 0707 0707 0707 0808 0808+  		db	007h,007h,007h,007h,007h,007h,008h,008h,008h,008h,008h,008h,008h,008h,008h,008h
00001960 0909 0909 0909 0909 0909+  		db	009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,00Ah,00Ah,00Ah,00Ah,00Ah
00001970 0A0A 0A0A 0A0A 0B0B 0B0B+  		db	00Ah,00Ah,00Ah,00Ah,00Ah,00Ah,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh
00001980 0C0C 0C0C 0C0C 0C0C 0C0C+  		db	00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Dh,00Dh,00Dh,00Dh,00Dh
00001990 0D0D 0D0D 0D0D 0E0E 0E0E+  		db	00Dh,00Dh,00Dh,00Dh,00Dh,00Dh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh
000019A0 0F0F 0F0F 0F0F 0F0F 0F0F+  		db	00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,010h,010h,010h,010h,010h
000019B0 1010 1010 1010 1111 1111+  		db	010h,010h,010h,010h,010h,010h,011h,011h,011h,011h,011h,011h,011h,011h,011h,011h
000019C0 1212 1212 1212 1212 1212+  		db	012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,013h,013h,013h,013h,013h
000019D0 1313 1313 1313 1414 1414+  		db	013h,013h,013h,013h,013h,013h,014h,014h,014h,014h,014h,014h,014h,014h,014h,014h
000019E0 1515 1515 1515 1515 1515+  		db	015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,016h,016h,016h,016h,016h
000019F0 1616 1616 1616 1717 1717+  		db	016h,016h,016h,016h,016h,016h,017h,017h,017h,017h,017h,017h,017h,017h,017h,017h
00001A00                            
00001A00                            ; ===========================================================================
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            ; Subroutine to change a channel's volume table
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            
00001A00                            PCM_VolumeControl:
00001A06                            
00001A1B                            
00001A1B                            PCM1_NoVolume:
00001A1B                            
00001A30                            
00001A30                            PCM2_NoVolume:
00001A31 37                         		scf					; 04	; set carry flag
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; The volume changing itself
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            SwitchVolume:
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; Software version of volume table (This is slower to process but will save
00001A35                            ; 8000 bytes of ROM space).  It'll also cause chopping in the sample playback
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            ;		ld	b,a				; 04	; store volume
00001A35                            ;		zneg					; 08	; convert volume to 00 - 80 (mute - loud)
00001A35                            ;		zadd	a,080h				; 07	; ''
00001A35                            ;		zadd	a,a				; 04	; shift MSB into carry
00001A35                            ;		ld	(SV_fraction+001h),a		; 13	; store fraction
00001A35                            ;		sbc	a,a				; 04	; get only the carry (for quotient)
00001A35                            ;		zneg					; 08	; ''
00001A35                            ;		ld	c,a				; 04	; store quotient in c
00001A35                            ;		ld	hl,00000h			; 10	; reset current fraction/dividend
00001A35                            ;		ld	a,b				; 04	; reload volume
00001A35                            ;		zadd	a,080h				; 07	; rotate starting volume
00001A35                            ;SV_fraction:	ld	b,000h				; 07	; set fraction/dividend
00001A35                            ;
00001A35                            ;SV_SetNormal:
00001A35                            ;		ld	(de),a				; 07	; save to table
00001A35                            ;		zadd	hl,bc 				; 11	; add fraction/dividend
00001A35                            ;		adc	a,c				; 04	; add carry to quotient
00001A35                            ;		inc	e				; 04	; advance table
00001A35                            ;		jp	nz,SV_SetNormal			; 10	; repeat until the table is finished (should reach 100)
00001A35                            ;
00001A35                            ;SV_Return:	jp	00000h				; 10	; return
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A46                            
00001A46                            	; --- Non-flush version ---
00001A46                            
00001A55                            
00001A55                            SV_NoMute:
00001A5A                            
00001A5A                            SV_LoadVolume:
00001A5A                            		rept	008h
00001A5A                            		ldi					; 16	; copy volume bytes over
00001A5A EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001A6E                            
00001A6E                            	; --- Flush version ---
00001A6E                            
00001A6E                            SV_Flush:
00001A79 D9                         			exx					; 04	; switch registers
00001A8D D9                         			exx					; 04	; switch registers
00001A91                            
00001A91                            SVF_NoMute:
00001A96                            
00001A96                            SVF_LoadVolume:
00001A96 D9                         			exx					; 04	; switch registers
00001AAA D9                         			exx					; 04	; switch registers
00001AAB                            
00001AAB                            SVF_StartVolume:
00001AAB                            		rept	008h
00001AAB                            		ldi					; 16	; copy volume bytes over
00001AAB EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001ABB D9                         			exx					; 04	; switch registers
00001ACF D9                         			exx					; 04	; switch registers
00001AD0                            		rept	008h
00001AD0                            		ldi					; 16	; copy volume bytes over
00001AD0 EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001AE2 D9                         			exx					; 04	; switch registers
00001AF1 D9                         			exx					; 04	; switch registers
00001AFC                            
00001AFC                            ; ===========================================================================
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ; Switching a channel's bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	hl,PCM1_BankCur			; 10	; address of bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		ld	a,(PCM1_PitchQuo+001h)		; 13	; load pitch quotient
00001AFC                            ;		call	SwitchBank			; 17	; change the bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	a,(PCM1_BankCur)		; 13	; load bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		call	SetBank				; 17	; set bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            
00001AFC                            SwitchBank:
00001B03                            
00001B03                            SetBank:
00001B06                            	rept	008h
00001B06                            		xor	a				; 04	; clear a
00001B06                            		rrc	l				; 08	; shift bit into carry
00001B06                            		adc	a,h				; 04	; set instruction bits (with carry register bit)
00001B06                            		ld	(de),a				; 07	; write instruction
00001B06                            		inc	e	; WARNING (see comment)	; 04	; advance to next instruction (ONLY WORKS IF THE INSTRUCTIONS DON'T CROSS A 100 BYTE BOUNDARY, please align)
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            ; Warning stuff
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            
00001B37                            
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ===========================================================================
00001B37                            DualPCM_sz:
000BD4BF =00000000                M z80prg	=	0
000BD4BF                          M 	mexit
000BD4BF                            
000BD4BF                            ; =========================================================================================================================================================
000BD4BF                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000BD4BF                            ; Error handler
000BD4BF                            ; -------------------------------------------------------------------------------------------------------------------------------------------------------
000BD4BF                            		include	"Config/Error/error.asm"
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Vladikcomper's debugger
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Error handler control flags
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            ; Screen appearence flags
000BD4BF =00000001                  _eh_address_error	equ	$01	; use for address and bus errors only (tells error handler to display additional "Address" field)
000BD4BF =00000002                  _eh_show_sr_usp		equ	$02	; displays SR and USP registers content on error screen
000BD4BF                            
000BD4BF                            ; Advanced execution flags
000BD4BF                            ; WARNING! For experts only, DO NOT USES them unless you know what you're doing
000BD4BF =00000020                  _eh_return		equ	$20
000BD4BF =00000040                  _eh_enter_console	equ	$40
000BD4BF =00000080                  _eh_align_offset	equ	$80
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Errors vector table
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            ; Default screen configuration
000BD4BF =00000000                  _eh_default		equ	0	;_eh_show_sr_usp
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            exBus:
000BD4BF                            	__ErrorMessage "BUS ERROR", _eh_default|_eh_address_error
000BD4BF                          M 	__fstring_generateargumentscode	"BUS ERROR"
000BD4BF =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
000BD4BF =00000000                M 	__stack:set	0
000BD4BF =00000000                M 	__sp:	set 0
000BD4BF                          M 	while	(__pos)
000BD4BF                          M 	rept	__stack
000BD4C0 004E B900 0000 00        M 	jsr	errorhandler
000BD4C6                          M 	__fstring_generatedecodedstring	"BUS ERROR"
000BD4C6 =00000001                M 	__lpos:	set 1
000BD4C6 =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
000BD4C6                          M 	while	(__pos)
000BD4C6                          M 	__substr:	substr __lpos,,"BUS ERROR"
000BD4C6 4255 5320 4552 524F 52   M 	dc.b	"BUS ERROR"
000BD4CF 00                       M 	dc.b	0
000BD4D0 01                       M 	dc.b	_eh_default|_eh_address_error+0
000BD4D2 00                       M 	even
000BD4D2                            
000BD4D2                            exAddr:
000BD4D2                            	__ErrorMessage "ADDRESS ERROR", _eh_default|_eh_address_error
000BD4D2                          M 	__fstring_generateargumentscode	"ADDRESS ERROR"
000BD4D2 =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
000BD4D2 =00000000                M 	__stack:set	0
000BD4D2 =00000000                M 	__sp:	set 0
000BD4D2                          M 	while	(__pos)
000BD4D2                          M 	rept	__stack
000BD4D2 4EB9 0000 0000           M 	jsr	errorhandler
000BD4D8                          M 	__fstring_generatedecodedstring	"ADDRESS ERROR"
000BD4D8 =00000001                M 	__lpos:	set 1
000BD4D8 =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
000BD4D8                          M 	while	(__pos)
000BD4D8                          M 	__substr:	substr __lpos,,"ADDRESS ERROR"
000BD4D8 4144 4452 4553 5320 4552+M 	dc.b	"ADDRESS ERROR"
000BD4E5 00                       M 	dc.b	0
000BD4E6 01                       M 	dc.b	_eh_default|_eh_address_error+0
000BD4E8 00                       M 	even
000BD4E8                            
000BD4E8                            exIll:
000BD4E8                            	__ErrorMessage "ILLEGAL INSTRUCTION", _eh_default
000BD4E8                          M 	__fstring_generateargumentscode	"ILLEGAL INSTRUCTION"
000BD4E8 =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
000BD4E8 =00000000                M 	__stack:set	0
000BD4E8 =00000000                M 	__sp:	set 0
000BD4E8                          M 	while	(__pos)
000BD4E8                          M 	rept	__stack
000BD4E8 4EB9 0000 0000           M 	jsr	errorhandler
000BD4EE                          M 	__fstring_generatedecodedstring	"ILLEGAL INSTRUCTION"
000BD4EE =00000001                M 	__lpos:	set 1
000BD4EE =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
000BD4EE                          M 	while	(__pos)
000BD4EE                          M 	__substr:	substr __lpos,,"ILLEGAL INSTRUCTION"
000BD4EE 494C 4C45 4741 4C20 494E+M 	dc.b	"ILLEGAL INSTRUCTION"
000BD501 00                       M 	dc.b	0
000BD502 00                       M 	dc.b	_eh_default+0
000BD504 00                       M 	even
000BD504                            
000BD504                            exDiv:
000BD504                            	__ErrorMessage "ZERO DIVIDE", _eh_default
000BD504                          M 	__fstring_generateargumentscode	"ZERO DIVIDE"
000BD504 =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000BD504 =00000000                M 	__stack:set	0
000BD504 =00000000                M 	__sp:	set 0
000BD504                          M 	while	(__pos)
000BD504                          M 	rept	__stack
000BD504 4EB9 0000 0000           M 	jsr	errorhandler
000BD50A                          M 	__fstring_generatedecodedstring	"ZERO DIVIDE"
000BD50A =00000001                M 	__lpos:	set 1
000BD50A =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000BD50A                          M 	while	(__pos)
000BD50A                          M 	__substr:	substr __lpos,,"ZERO DIVIDE"
000BD50A 5A45 524F 2044 4956 4944+M 	dc.b	"ZERO DIVIDE"
000BD515 00                       M 	dc.b	0
000BD516 00                       M 	dc.b	_eh_default+0
000BD518 00                       M 	even
000BD518                            
000BD518                            exChk:
000BD518                            	__ErrorMessage "CHK INSTRUCTION", _eh_default
000BD518                          M 	__fstring_generateargumentscode	"CHK INSTRUCTION"
000BD518 =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000BD518 =00000000                M 	__stack:set	0
000BD518 =00000000                M 	__sp:	set 0
000BD518                          M 	while	(__pos)
000BD518                          M 	rept	__stack
000BD518 4EB9 0000 0000           M 	jsr	errorhandler
000BD51E                          M 	__fstring_generatedecodedstring	"CHK INSTRUCTION"
000BD51E =00000001                M 	__lpos:	set 1
000BD51E =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000BD51E                          M 	while	(__pos)
000BD51E                          M 	__substr:	substr __lpos,,"CHK INSTRUCTION"
000BD51E 4348 4B20 494E 5354 5255+M 	dc.b	"CHK INSTRUCTION"
000BD52D 00                       M 	dc.b	0
000BD52E 00                       M 	dc.b	_eh_default+0
000BD530 00                       M 	even
000BD530                            
000BD530                            Trapv:
000BD530                            	__ErrorMessage "TRAPV INSTRUCTION", _eh_default
000BD530                          M 	__fstring_generateargumentscode	"TRAPV INSTRUCTION"
000BD530 =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000BD530 =00000000                M 	__stack:set	0
000BD530 =00000000                M 	__sp:	set 0
000BD530                          M 	while	(__pos)
000BD530                          M 	rept	__stack
000BD530 4EB9 0000 0000           M 	jsr	errorhandler
000BD536                          M 	__fstring_generatedecodedstring	"TRAPV INSTRUCTION"
000BD536 =00000001                M 	__lpos:	set 1
000BD536 =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000BD536                          M 	while	(__pos)
000BD536                          M 	__substr:	substr __lpos,,"TRAPV INSTRUCTION"
000BD536 5452 4150 5620 494E 5354+M 	dc.b	"TRAPV INSTRUCTION"
000BD547 00                       M 	dc.b	0
000BD548 00                       M 	dc.b	_eh_default+0
000BD54A 00                       M 	even
000BD54A                            
000BD54A                            exPriv:
000BD54A                            	__ErrorMessage "PRIVILEGE VIOLATION", _eh_default
000BD54A                          M 	__fstring_generateargumentscode	"PRIVILEGE VIOLATION"
000BD54A =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000BD54A =00000000                M 	__stack:set	0
000BD54A =00000000                M 	__sp:	set 0
000BD54A                          M 	while	(__pos)
000BD54A                          M 	rept	__stack
000BD54A 4EB9 0000 0000           M 	jsr	errorhandler
000BD550                          M 	__fstring_generatedecodedstring	"PRIVILEGE VIOLATION"
000BD550 =00000001                M 	__lpos:	set 1
000BD550 =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000BD550                          M 	while	(__pos)
000BD550                          M 	__substr:	substr __lpos,,"PRIVILEGE VIOLATION"
000BD550 5052 4956 494C 4547 4520+M 	dc.b	"PRIVILEGE VIOLATION"
000BD563 00                       M 	dc.b	0
000BD564 00                       M 	dc.b	_eh_default+0
000BD566 00                       M 	even
000BD566                            
000BD566                            exTrace:
000BD566                            	__ErrorMessage "TRACE", _eh_default
000BD566                          M 	__fstring_generateargumentscode	"TRACE"
000BD566 =00000000                M 	__pos:	set instr("TRACE",'%<')
000BD566 =00000000                M 	__stack:set	0
000BD566 =00000000                M 	__sp:	set 0
000BD566                          M 	while	(__pos)
000BD566                          M 	rept	__stack
000BD566 4EB9 0000 0000           M 	jsr	errorhandler
000BD56C                          M 	__fstring_generatedecodedstring	"TRACE"
000BD56C =00000001                M 	__lpos:	set 1
000BD56C =00000000                M 	__pos:	set instr("TRACE",'%<')
000BD56C                          M 	while	(__pos)
000BD56C                          M 	__substr:	substr __lpos,,"TRACE"
000BD56C 5452 4143 45             M 	dc.b	"TRACE"
000BD571 00                       M 	dc.b	0
000BD572 00                       M 	dc.b	_eh_default+0
000BD574 00                       M 	even
000BD574                            
000BD574                            exLineA:
000BD574                            	__ErrorMessage "LINE A EMULATOR", _eh_default
000BD574                          M 	__fstring_generateargumentscode	"LINE A EMULATOR"
000BD574 =00000000                M 	__pos:	set instr("LINE A EMULATOR",'%<')
000BD574 =00000000                M 	__stack:set	0
000BD574 =00000000                M 	__sp:	set 0
000BD574                          M 	while	(__pos)
000BD574                          M 	rept	__stack
000BD574 4EB9 0000 0000           M 	jsr	errorhandler
000BD57A                          M 	__fstring_generatedecodedstring	"LINE A EMULATOR"
000BD57A =00000001                M 	__lpos:	set 1
000BD57A =00000000                M 	__pos:	set instr("LINE A EMULATOR",'%<')
000BD57A                          M 	while	(__pos)
000BD57A                          M 	__substr:	substr __lpos,,"LINE A EMULATOR"
000BD57A 4C49 4E45 2041 2045 4D55+M 	dc.b	"LINE A EMULATOR"
000BD589 00                       M 	dc.b	0
000BD58A 00                       M 	dc.b	_eh_default+0
000BD58C 00                       M 	even
000BD58C                            
000BD58C                            exLineF:
000BD58C                            	__ErrorMessage "LINE F EMULATOR", _eh_default
000BD58C                          M 	__fstring_generateargumentscode	"LINE F EMULATOR"
000BD58C =00000000                M 	__pos:	set instr("LINE F EMULATOR",'%<')
000BD58C =00000000                M 	__stack:set	0
000BD58C =00000000                M 	__sp:	set 0
000BD58C                          M 	while	(__pos)
000BD58C                          M 	rept	__stack
000BD58C 4EB9 0000 0000           M 	jsr	errorhandler
000BD592                          M 	__fstring_generatedecodedstring	"LINE F EMULATOR"
000BD592 =00000001                M 	__lpos:	set 1
000BD592 =00000000                M 	__pos:	set instr("LINE F EMULATOR",'%<')
000BD592                          M 	while	(__pos)
000BD592                          M 	__substr:	substr __lpos,,"LINE F EMULATOR"
000BD592 4C49 4E45 2046 2045 4D55+M 	dc.b	"LINE F EMULATOR"
000BD5A1 00                       M 	dc.b	0
000BD5A2 00                       M 	dc.b	_eh_default+0
000BD5A4 00                       M 	even
000BD5A4                            
000BD5A4                            exMisc:
000BD5A4                            	__ErrorMessage "MISC EXCEPTION", _eh_default
000BD5A4                          M 	__fstring_generateargumentscode	"MISC EXCEPTION"
000BD5A4 =00000000                M 	__pos:	set instr("MISC EXCEPTION",'%<')
000BD5A4 =00000000                M 	__stack:set	0
000BD5A4 =00000000                M 	__sp:	set 0
000BD5A4                          M 	while	(__pos)
000BD5A4                          M 	rept	__stack
000BD5A4 4EB9 0000 0000           M 	jsr	errorhandler
000BD5AA                          M 	__fstring_generatedecodedstring	"MISC EXCEPTION"
000BD5AA =00000001                M 	__lpos:	set 1
000BD5AA =00000000                M 	__pos:	set instr("MISC EXCEPTION",'%<')
000BD5AA                          M 	while	(__pos)
000BD5AA                          M 	__substr:	substr __lpos,,"MISC EXCEPTION"
000BD5AA 4D49 5343 2045 5843 4550+M 	dc.b	"MISC EXCEPTION"
000BD5B8 00                       M 	dc.b	0
000BD5B9 00                       M 	dc.b	_eh_default+0
000BD5BA                          M 	even
000BD5BA                            
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            ; Import error handler global functions
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            
000BD5BA                            ErrorHandler.__global__error_initconsole		equ	ErrorHandler+$146
000BD5BA                            ErrorHandler.__global__errorhandler_setupvdp		equ	ErrorHandler+$234
000BD5BA                            ErrorHandler.__global__console_loadpalette		equ	ErrorHandler+$A1C
000BD5BA                            ErrorHandler.__global__console_setposasxy_stack		equ	ErrorHandler+$A58
000BD5BA                            ErrorHandler.__global__console_setposasxy		equ	ErrorHandler+$A5E
000BD5BA                            ErrorHandler.__global__console_getposasxy		equ	ErrorHandler+$A8A
000BD5BA                            ErrorHandler.__global__console_startnewline		equ	ErrorHandler+$AAC
000BD5BA                            ErrorHandler.__global__console_setbasepattern		equ	ErrorHandler+$AD4
000BD5BA                            ErrorHandler.__global__console_setwidth			equ	ErrorHandler+$AE8
000BD5BA                            ErrorHandler.__global__console_writeline_withpattern	equ	ErrorHandler+$AFE
000BD5BA                            ErrorHandler.__global__console_writeline		equ	ErrorHandler+$B00
000BD5BA                            ErrorHandler.__global__console_write			equ	ErrorHandler+$B04
000BD5BA                            ErrorHandler.__global__console_writeline_formatted	equ	ErrorHandler+$BB0
000BD5BA                            ErrorHandler.__global__console_write_formatted		equ	ErrorHandler+$BB4
000BD5BA                            
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            ; Error handler external functions (compiled only when used)
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            
000BD5BA                            
000BD5BA                            ErrorHandler.__extern__console_only:
000BD5BA 46FC 2700 4FEF FFF2 48E7+  	dc.l	$46FC2700, $4FEFFFF2, $48E7FFFE, $47EF003C
000BD5CA 4EBA 0000                  	jsr		ErrorHandler.__global__errorhandler_setupvdp(pc)
000BD5CE 4EBA 0000                  	jsr		ErrorHandler.__global__error_initconsole(pc)
000BD5D2 4CDF 7FFF 487A 0008 2F2F+  	dc.l	$4CDF7FFF, $487A0008, $2F2F0012, $4E7560FE
000BD5E2                            
000BD5E2                            
000BD5E2                            ; -------------------------------------------------------------------------
000BD5E2                            ; Include error handler binary module
000BD5E2                            ; -------------------------------------------------------------------------
000BD5E2                            
000BD5E2                            ErrorHandler:
000BD5E2                            	incbin	"Config/Error/ErrorHandler.bin"
000BEFF6                            
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            ; WARNING!
000BEFF6                            ;	DO NOT put any data from now on! DO NOT use ROM padding!
000BEFF6                            ;	Symbol data should be appended here after ROM is compiled
000BEFF6                            ;	by ConvSym utility, otherwise debugger modules won't be able
000BEFF6                            ;	to resolve symbol names.
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            
000BEFF6                            
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            ; =========================================================================================================================================================
