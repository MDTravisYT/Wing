00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Includes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"_INCLUDE_/Configuration.asm"	; User configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ASM68K Options
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		opt	l.				; Use "." for local labels
00000000                            		opt	ws+				; allow white spaces in operand parsing
00000000                            		opt	op+				; Optimize to PC relative addressing
00000000                            		opt	os+				; Optimize short branches
00000000                            		opt	ow+				; Optimize absolute long addressing
00000000                            		opt	oz+				; Optimize zero displacements
00000000                            		opt	oaq+				; Optimize to addq
00000000                            		opt	osq+				; Optimize to subq
00000000                            		opt	omq+				; Optimize to moveq
00000000                            		opt	ae-				; Disable automatic evens
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Required
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            GAME_NAME	equs	"Mighty The Armadillo in -|=| PRISM PARADISE |=|-"; International name
00000000                            IO_SUPPORT	equs	"J"				; I/O support
00000000 =20202020                  SRAM_SUPPORT	equ	$20202020			; SRAM support
00000000 =20202020                  SRAM_START	equ	$20202020			; SRAM start address
00000000 =20202020                  SRAM_END	equ	$20202020			; SRAM end address
00000000                            NOTES		equs	""; Notes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  DEBUG_BUILD	equ	0				; Debug build flag (0 = Disabled)
00000000                            ENABLE_HANDLER	equ	0|DEBUG				; Vladikcomper's error handler enable flag (0 = Disabled)
00000000 =00000000                  ENABLE_LAGMETER	equ	0				; Lag meter enable flag (0 = Disabled)
00000000 =00000000                  DEBUG		equ	DEBUG_BUILD			; Hack
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Shared.asm"		; MegaDrive includes
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive Shared Includes
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Definitions.asm"	; Definitions
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ROM addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  ROM_START		EQU	$000000		; ROM start address
00000000 =00400000                  ROM_END			EQU	$3FFFFF+1	; ROM end address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Z80 addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00A00000                  Z80_RAM			EQU	$A00000		; Z80 RAM start address
00000000 =00A02000                  Z80_RAM_END		EQU	$A02000		; Z80 RAM end address
00000000 =00A11100                  Z80_BUS_REQ		EQU	$A11100		; Z80 bus rEQUest
00000000 =00A11200                  Z80_RESET		EQU	$A11200		; Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sound addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00A04000                  YM2612_A0		EQU	$A04000		; M68K YM2612 register port 0
00000000 =00A04001                  YM2612_D0		EQU	$A04001		; M68K YM2612 data port 0
00000000 =00A04002                  YM2612_A1		EQU	$A04002		; M68K YM2612 register port 1
00000000 =00A04003                  YM2612_D1		EQU	$A04003		; M68K YM2612 data port 1
00000000 =00C00011                  PSG_INPUT		EQU	$C00011		; M68K PSG input
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; I/O addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00A10001                  HW_VERSION		EQU	$A10001		; Hardware version
00000000 =00A10003                  PORT_A_DATA		EQU	$A10003		; Port A data
00000000 =00A10005                  PORT_B_DATA		EQU	$A10005		; Port B data
00000000 =00A10007                  PORT_C_DATA		EQU	$A10007		; Port C data
00000000 =00A10009                  PORT_A_CTRL		EQU	$A10009		; Port A control
00000000 =00A1000B                  PORT_B_CTRL		EQU	$A1000B		; Port B control
00000000 =00A1000D                  PORT_C_CTRL		EQU	$A1000D		; Port C control
00000000 =00A1000F                  PORT_A_TX		EQU	$A1000F		; Port A Tx data
00000000 =00A10011                  PORT_A_RX		EQU	$A10011		; Port A Rx data
00000000 =00A10013                  PORT_A_SCTRL		EQU	$A10013		; Port A S control
00000000 =00A10015                  PORT_B_TX		EQU	$A10015		; Port B Tx data
00000000 =00A10017                  PORT_B_RX		EQU	$A10017		; Port B Rx data
00000000 =00A10019                  PORT_B_SCTRL		EQU	$A10019		; Port B S control
00000000 =00A1001B                  PORT_C_TX		EQU	$A1001B		; Port C Tx data
00000000 =00A1001D                  PORT_C_RX		EQU	$A1001D		; Port C Rx data
00000000 =00A1001F                  PORT_C_SCTRL		EQU	$A1001F		; Port C S control
00000000 =00A130F1                  SRAM_ACCESS		EQU	$A130F1		; SRAM access port
00000000 =00A14000                  TMSS_PORT		EQU	$A14000		; TMSS port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00C00000                  VDP_DATA		EQU	$C00000		; VDP data port
00000000 =00C00004                  VDP_CTRL		EQU	$C00004		; VDP control port
00000000 =00C00008                  VDP_HV			EQU	$C00008		; VDP H/V counter
00000000 =00C0001C                  VDP_DEBUG		EQU	$C0001C		; VDP debug register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RAM addresses
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00FF0000                  RAM_START		EQU	$FF0000		; RAM start address
00000000 =01000000                  RAM_END			EQU	$FFFFFF+1	; RAM end address
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Align
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound	- Size boundary
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            align		macros	bound
00000000                            		cnop	0,\bound
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pad RS to even address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------
00000000                            rsEven		macros
00000000                            		rs.b	__rs&1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Push registers to stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to push
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            push		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 \regs,-(sp)
00000000                            			else
00000000                            				move.\0	\regs,-(sp)
00000000                            			endif
00000000                            		else
00000000                            			zpush	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Pop registers from stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to pop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            pop		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 (sp)+,\regs
00000000                            			else
00000000                            				move.\0	(sp)+,\regs
00000000                            			endif
00000000                            		else
00000000                            			zpop	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Clear memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	starta	- Address to start clearing memory at
00000000                            ;	enda	- Address to finish clearing memory at
00000000                            ;		  (not rEQUired if there exists a label that is the same as the starting label, but with "_End" at the end of it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            clrRAM		macro	starta, enda
00000000                            		local	endaddr
00000000                            		if narg<2
00000000                            endaddr			EQUS	"\starta\_End"
00000000                            		else
00000000                            endaddr			EQUS	"\enda"
00000000                            		endif
00000000                            
00000000                            		moveq	#0,d0
00000000                            
00000000                            		if ((\starta)&$8000)=0
00000000                            			lea	\starta,a1
00000000                            		else
00000000                            			lea	(\starta).w,a1
00000000                            		endif
00000000                            		if (\starta)&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            
00000000                            		move.w	#(((\endaddr)-(\starta))-((\starta)&1))>>2-1,d1
00000000                            .Clear\@:	move.l	d0,(a1)+
00000000                            		dbf	d1,.Clear\@
00000000                            
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&2
00000000                            			move.w	d0,(a1)+
00000000                            		endif
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOff		macros
00000000                            		move.b	#0,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOn		macros
00000000                            		move.b	#1,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOff		macros
00000000                            		ori	#$700,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOn		macros
00000000                            		andi	#$F8FF,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            doZ80Stop	macros
00000000                            		move.w	#$100,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to stop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Stop	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80 and wait for it to
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            stopZ80		macro
00000000                            		doZ80Stop
00000000                          M 	move.w	#$100,z80_bus_req
00000000                            		waitZ80Stop
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            startZ80	macros
00000000                            		move.w	#0,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to start
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Start	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		beq.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80Off	macros
00000000                            		move.w	#$100,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Reset the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80	macros
00000000                            		move.w	#0,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the YM2612 to not be busy
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitYM		macro
00000000                            		nop
00000000                            		nop
00000000                            		nop
00000000                            @Wait\@:	tst.b	(a0)
00000000                            		bmi.s	@Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for DMA finish
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	port	- Something to represent the VDP control port (default is VDP_CTRL_PORT)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00000000                            waitDMA		macro	port
00000000                            .Wait\@:
00000000                            		if narg>0
00000000                            			move.w	\port,d1
00000000                            		else
00000000                            			move.w	VDP_CTRL,d1
00000000                            		endif
00000000                            		btst	#1,d1
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr	- Address in VDP memory
00000000                            ;	type	- Type of VDP memory
00000000                            ;	rwd	- VDP command
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000021                  VRAM		EQU	%100001		; VRAM
00000000 =0000002B                  CRAM		EQU	%101011		; CRAM
00000000 =00000025                  VSRAM		EQU	%100101		; VSRAM
00000000 =0000000C                  READ		EQU	%001100		; VDP read
00000000 =00000007                  WRITE		EQU	%000111		; VDP write
00000000 =00000027                  DMA		EQU	%100111		; VDP DMA
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            vdpCmd		macro	ins, addr, type, rwd, end, end2
00000000                            		if narg=5
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14)), \end
00000000                            		elseif narg>=6
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))\end, \end2
00000000                            		else
00000000                            			\ins	((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in 68000 memory
00000000                            ;	dest	- Destination address in VDP memory
00000000                            ;	len	- Length of data in bytes
00000000                            ;	type	- Type of VDP memory
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dma68k		macro	src, dest, len, type, port
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(a6)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(a6)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, >>16, (a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, &$FFFF, -(sp)
00000000                            		move.w	(sp)+,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Fill VRAM with byte
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte	- Byte to fill VRAM with
00000000                            ;	addr	- Address in VRAM
00000000                            ;	len	- Length of fill in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaFill		macro	byte, addr, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.w	#$9780,(a6)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(a6)
00000000                            		move.w	#(\byte)<<8,-4(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Copy a region of VRAM to a location in VRAM
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in VRAM
00000000                            ;	dest	- Destination address in VRAM
00000000                            ;	len	- Length of copy in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaCopy		macro	src, dest, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(a6)
00000000                            		move.w	#$97C0,(a6)
00000000                            		move.l	#$000000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"../include/Z80.asm"		; Z80 opcodes macros
00000000                            ; MADE BY NATSUMI 2017
00000000                            
00000000                            ; DEFINE HELPERS
00000000 =00000000                  z80prg =	0		; 0 IN 68K MODE, 1 IN Z80 MODE
00000000 =00000000                  ztemp =		0		; TEMPORARY REGISTER
00000000 =00000000                  zundoc =	0		; SET TO 0 TO USE UNDOCUMENTED OPCODES
00000000 =00000001                  zchkoffs =	1		; SET TO 0 TO NOT CHECK IX/IY AND JR OFFSETS
00000000                            z80regstr	EQUS "a b c d e h l bc de hl sp af ix iy i r ixh ixl iyh iyl (bc) (de) (hl) (sp) af' (ix) (iy)"
00000000                            
00000000                            ; EASILY MAKE SECTIONS
00000000                            z80prog	macro obj
00000000                            	if narg=0
00000000                            		OBJEND
00000000                            
00000000                            	; magic function that fixes all the jr and djnz opcodes, along with offsets.
00000000                            	; Used for detecting illegal forward jumps
00000000                            		local lastpos
00000000                            lastpos =	*
00000000                            			local off, byte
00000000                            		rept zfuturec
00000000                            			popp off
00000000                            			popp byte
00000000                            			org zfuturepos-zfutureobj+off
00000000                            			dc.b byte
00000000                            		endr
00000000                            
00000000                            		org lastpos
00000000                            
00000000                            		POPO		; restore options
00000000                            z80prg =	0
00000000                            		MEXIT		; exit macro here
00000000                            	endif
00000000                            
00000000                            	PUSHO			; push options
00000000                            	OPT AE-			; automatic evens off
00000000                            	OPT AN+			; allow use of 100H instead of $100
00000000                            	OPT M-			; do not print better macro info. Comment out for large text dump.
00000000                            	OPT D-			; make sure EQU/SET do not descope local lables
00000000                            
00000000                            zfutureobj =	\obj
00000000                            zfuturepos =	*
00000000                            zfuturec =	0
00000000                            
00000000                            	if narg=1
00000000                            		OBJ \obj
00000000                            z80prg =	1
00000000                            	else
00000000                            		inform 0,"Invalid num of args!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; CREATE A LITTLE-ENDIAN Z80 ABSOLUTE ADDRESS
00000000                            z80word	macro word
00000000                            	dc.b ((\word)&$FF), ((\word)>>8&$FF)
00000000                                endm
00000000                            
00000000                            ; SAVES THE RÈGISTER ID TO ZTEMP
00000000                            zgetreg	macro reg, err
00000000                            	if strlen("\reg")=0
00000000                            		inform \err,"The register must not be empty!"
00000000                            		mexit
00000000                            	endif
00000000                            
00000000                            ztemp = instr("\z80regstr", "\reg")
00000000                            
00000000                            	if (ztemp<>0)&(ztemp<55)
00000000                            ztemp =		(z\reg)
00000000                            
00000000                            	elseif ztemp=56
00000000                            ztemp =		zbcr
00000000                            
00000000                            	elseif ztemp=61
00000000                            ztemp =		zder
00000000                            
00000000                            	elseif ztemp=66
00000000                            ztemp =		zhlr
00000000                            
00000000                            	elseif ztemp=71
00000000                            ztemp =		zspr
00000000                            
00000000                            	elseif ztemp=76
00000000                            ztemp =		zaf2
00000000                            
00000000                            	elseif ztemp=79
00000000                            ztemp =		zixr
00000000                            
00000000                            	elseif ztemp=85
00000000                            ztemp =		ziyr
00000000                            
00000000                            	else
00000000                            
00000000                            		if instr("\reg", "(ix+")<>0|instr("\reg", "(ix-")<>0
00000000                            ztemp =		zixp
00000000                            
00000000                            		elseif instr("\reg", "(iy+")<>0|instr("\reg", "(iy-")<>0
00000000                            ztemp =		ziyp
00000000                            
00000000                            		else
00000000                            ztemp =			-1
00000000                            
00000000                            			local a, cc, p
00000000                            a =			0
00000000                            p =			1
00000000                            d =			0
00000000                            			while a=0
00000000                            				if p>strlen("\reg")
00000000                            ztemp =					-2
00000000                            a =					1
00000000                            
00000000                            				else
00000000                            cc					substr p,p,"\reg"
00000000                            					if '\cc'='('
00000000                            d =						d+1
00000000                            
00000000                            					elseif '\cc'=')'
00000000                            d =						d-1
00000000                            
00000000                            					elseif ('\cc'<>' ')&('\cc'<>'	')
00000000                            						if d<1
00000000                            a =							1
00000000                            						endif
00000000                            					endif
00000000                            				endif
00000000                            p =				p+1
00000000                            			endw
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; PLACES THE SIGNED OFFSET INTO ROM, AND QUEUES A CHECK
00000000                            zindoff	macro reg, byte
00000000                            	local off
00000000                            off	substr 4, strlen("\reg")-1, "\reg"
00000000                            
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zjrfuture macro off, byte
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; QUEUES SIGNED VALUES TO BE FIXED
00000000                            zfuture	macro byte
00000000                            zfuturec =	zfuturec+1
00000000                            		local p,v
00000000                            p =		*-2
00000000                            v =		\byte
00000000                            		pushp "\#v"
00000000                            		pushp "\#p"
00000000                                endm
00000000                            
00000000                            ; Define equates for registers
00000000 =00000000                  zb = 	0
00000000 =00000001                  zc =	1
00000000 =00000002                  zd =	2
00000000 =00000003                  ze =	3
00000000 =00000004                  zh =	4
00000000 =00000005                  zl =	5
00000000 =00000007                  za =	7
00000000 =00000008                  zbc =	8
00000000 =00000009                  zde =	9
00000000 =0000000A                  zhl =	$A
00000000 =0000000B                  zsp =	$B
00000000 =00000018                  zbcr =	$18
00000000 =00000019                  zder =	$19
00000000 =0000001A                  zhlr =	$1A
00000000 =0000001B                  zspr =	$1B
00000000 =00000020                  zix =	$20
00000000 =00000021                  ziy =	$21
00000000 =00000022                  zixr =	$22
00000000 =00000023                  ziyr =	$23
00000000 =00000024                  zixp =	$24
00000000 =00000025                  ziyp =	$25
00000000 =00000028                  zixh =	$28
00000000 =00000029                  zixl =	$29
00000000 =0000002A                  ziyh =	$2A
00000000 =0000002B                  ziyl =	$2B
00000000 =00000030                  zaf =	$30
00000000 =00000031                  zaf2 =	$31
00000000 =00000038                  zi =	$38
00000000 =00000039                  zr =	$39
00000000                            
00000000                            
00000000                            ; Define instructions
00000000                            
00000000                            db	macro val
00000000                            	dc.b \_
00000000                                endm
00000000                            
00000000                            dsb	macro num, val
00000000                            	dcb.b \_
00000000                                endm
00000000                            
00000000                            dw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            dsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            rlc	macro reg, reg2
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $00+ztemp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $00+ztemp		; rlc a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $06			; rlc (hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rlc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rlc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rrc	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $08+ztemp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $08+ztemp		; rrc a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $0E			; rrc (hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rrc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rrc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $10+ztemp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $10+ztemp		; rl a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $16			; rl (hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rl (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rl (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rr	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $18+ztemp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $18+ztemp		; rr a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $1E			; rr (hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rr (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rr (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sla	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $20+ztemp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $20+ztemp		; sla a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $26			; sla (hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sla (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sla (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sra	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $28+ztemp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $28+ztemp		; sra a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $2E			; sra (hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sll	macro reg
00000000                            	if zundoc
00000000                            		inform 2,"Undocumented opcodes are not enabled."
00000000                            	endif
00000000                            
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if narg=2
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $30+ztemp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $30+ztemp		; sll a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $36			; sll (hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sll (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sll (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            srl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $38+ztemp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $38+ztemp		; sra a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $3E			; sra (hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            bit	macro bit, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $40+ztemp+(\bit*$08)	; bit 0-7,a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $46+(\bit*$08)	; bit 0-7,(hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; bit 0-7,(ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; bit 0-7,(iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            res	macro bit, reg, reg2
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $80+ztemp+(\bit*$08)	; res 0-7,a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $86+(\bit*$08)	; res 0-7,(hl)
00000000                            
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; res 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            
00000000                            		dc.b $80+(\bit*$08)+ztemp
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zset	macro bit, reg
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $C0+ztemp+(\bit*$08)	; set 0-7,a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $C6+(\bit*$08)	; set 0-7,(hl)
00000000                            
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; set 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            
00000000                            		dc.b $C0+(\bit*$08)+ztemp
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            im	macro im
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	if "\im"="0/1"
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $ED, $4E		; im 0/1
00000000                            
00000000                            	elseif (\im<0)|(\im>2)
00000000                            		inform 2,"Interrupt mode must only be 0, 1 or 2!"
00000000                            
00000000                            	elseif \im=2
00000000                            		dc.b $ED, $5E		; im 2
00000000                            	else
00000000                            		dc.b $ED, $46+(\im*$10); im 0 or 1
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rst	macro addr
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	if type(\addr)&1
00000000                            		if (\addr&7)=0
00000000                            			if \addr>$48|\addr<0
00000000                            				inform 2,"Invalid address! Must be at least 0 and at most $38!"
00000000                            			endif
00000000                            		else
00000000                            			inform 2,"Address must be aligned by $8!"
00000000                            		endif
00000000                            	endif
00000000                            		dc.b $C7+\addr	; RST *
00000000                                endm
00000000                            
00000000                            inc	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 2
00000000                            
00000000                            	if ztemp<=za
00000000                            		dc.b $04+(ztemp*$08)		; inc a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $34			; inc (hl)
00000000                            
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $03+((ztemp-zbc)*$10)	; inc bc, de, hl or sp
00000000                            
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $23			; inc ix
00000000                            
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $23			; inc iy
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; inc ix+
00000000                            		zindoff \reg, $34
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; inc iy+
00000000                            		zindoff \reg, $34
00000000                            
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((ztemp&$02)*$10), $24+((ztemp&$01)*$08); inc ixh, ixl, iyh, iyl
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            dec	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 2
00000000                            
00000000                            	if ztemp<=za
00000000                            		dc.b $05+(ztemp*$08)		; dec a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $35			; dec (hl)
00000000                            
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $0B+((ztemp-zbc)*$10)	; dec bc, de, hl or sp
00000000                            
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $2B			; dec ix
00000000                            
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $2B			; dec iy
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; dec ix+
00000000                            		zindoff \reg, $35
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; dec iy+
00000000                            		zindoff \reg, $35
00000000                            
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((ztemp&$02)*$10), $25+((ztemp&$01)*$08); dec ixh, ixl, iyh, iyl
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zsub	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if ztemp=-1
00000000                            		dc.b $D6			; sub a,*
00000000                            		dc.b \reg
00000000                            
00000000                            	elseif ztemp<=za
00000000                            		dc.b $90+ztemp			; sub a,a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $96			; sub a,(hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sub a,(ix+*)
00000000                            		zindoff \reg, $96
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sub a,(iy+*)
00000000                            		zindoff \reg, $96
00000000                            
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((ztemp&$02)*$10), $94+(ztemp&$01); sub a,ixh, ixl, iyh, iyl
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zand	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if ztemp=-1
00000000                            		dc.b $E6			; and a,*
00000000                            		dc.b \reg
00000000                            
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A0+ztemp			; and a,a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $A6			; and a,(hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; and a,(ix+*)
00000000                            		zindoff \reg, $A6
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; and a,(iy+*)
00000000                            		zindoff \reg, $A6
00000000                            
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((ztemp&$02)*$10), $A4+(ztemp&$01); and a,ixh, ixl, iyh, iyl
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if ztemp=-1
00000000                            		dc.b $F6			; or a,*
00000000                            		dc.b \reg
00000000                            
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B0+ztemp			; or a,a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; or a,(hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; or a,(ix+*)
00000000                            		zindoff \reg, $B6
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; or a,(iy+*)
00000000                            		zindoff \reg, $B6
00000000                            
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((ztemp&$02)*$10), $B4+(ztemp&$01); or a,ixh, ixl, iyh, iyl
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            xor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if ztemp=-1
00000000                            		dc.b $EE			; xor a,*
00000000                            		dc.b \reg
00000000                            
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A8+ztemp			; xor a,a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; xor a,(hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; xor a,(ix+*)
00000000                            		zindoff \reg, $AE
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; xor a,(iy+*)
00000000                            		zindoff \reg, $AE
00000000                            
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((ztemp&$02)*$10), $AC+(ztemp&$01); xor a,ixh, ixl, iyh, iyl
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            cp	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if ztemp=-1
00000000                            		dc.b $FE			; cp a,*
00000000                            		dc.b \reg
00000000                            
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B8+ztemp			; cp a,a, b, c, d, e, h or l
00000000                            
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $BE			; cp a,(hl)
00000000                            
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; cp a,(ix+*)
00000000                            		zindoff \reg, $BE
00000000                            
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; cp a,(iy+*)
00000000                            		zindoff \reg, $BE
00000000                            
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((ztemp&$02)*$10), $BC+(ztemp&$01); cp a,ixh, ixl, iyh, iyl
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zadd	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            
00000000                            			dc.b $DD		; add a,(ix+*)
00000000                            			zindoff \reg1, $86
00000000                            
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            
00000000                            			dc.b $FD		; add a,(iy+*)
00000000                            			zindoff \reg1, $86
00000000                            
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $86		; add a,(hl)
00000000                            
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            
00000000                            			dc.b $C6		; add a,*
00000000                            			dc.b \reg1
00000000                            
00000000                            		elseif ztemp<=za
00000000                            			dc.b $80+ztemp		; add a,a, b, c, d, e, h or l
00000000                            
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            
00000000                            			dc.b $DD+((ztemp&$02)*$10), $84+(ztemp&$01); add a,ixh, ixl, iyh, iyl
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $09+((ztemp-zbc)*$10)	; add hl,bc, de, hl or sp
00000000                            
00000000                            	elseif ztemp1=zix
00000000                            		dc.b $DD
00000000                            
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add ix,bc
00000000                            
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add ix,de
00000000                            
00000000                            		elseif ztemp=zix
00000000                            			dc.b $29		; add ix,ix
00000000                            
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add ix,sp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: ix, \reg2!"
00000000                            		endif
00000000                            
00000000                            	elseif ztemp1=ziy
00000000                            		dc.b $FD
00000000                            
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add iy,bc
00000000                            
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add iy,de
00000000                            
00000000                            		elseif ztemp=ziy
00000000                            			dc.b $29		; add iy,iy
00000000                            
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add iy,sp
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: iy, \reg2!"
00000000                            		endif
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            adc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            
00000000                            			dc.b $DD		; adc a,(ix+*)
00000000                            			zindoff \reg1, $8E
00000000                            
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            
00000000                            			dc.b $FD		; adc a,(iy+*)
00000000                            			zindoff \reg1, $8E
00000000                            
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $8E		; adc a,(hl)
00000000                            
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            
00000000                            			dc.b $CE		; adc a,*
00000000                            			dc.b \reg1
00000000                            
00000000                            		elseif ztemp<=za
00000000                            			dc.b $88+ztemp		; adc a,a, b, c, d, e, h or l
00000000                            
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            
00000000                            			dc.b $DD+((ztemp&$02)*$10), $8C+(ztemp&$01); adc a,ixh, ixl, iyh, iyl
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $4A+((ztemp-zbc)*$10)	; adc hl,bc, de, hl or sp
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sbc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            
00000000                            			dc.b $DD		; sbc a,(ix+*)
00000000                            			zindoff \reg1, $9E
00000000                            
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            
00000000                            			dc.b $FD		; sbc a,(iy+*)
00000000                            			zindoff \reg1, $9E
00000000                            
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $9E		; sbc a,(hl)
00000000                            
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            
00000000                            			dc.b $DE		; sbc a,*
00000000                            			dc.b \reg1
00000000                            
00000000                            		elseif ztemp<=za
00000000                            			dc.b $98+ztemp		; sbc a,a, b, c, d, e, h or l
00000000                            
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            
00000000                            			dc.b $DD+((ztemp&$02)*$10), $9C+(ztemp&$01); sbc a,ixh, ixl, iyh, iyl
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $42+((ztemp-zbc)*$10)	; sbc hl,bc, de, hl or sp
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpop	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 2
00000000                            
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C1+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F1		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E1		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E1		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpush	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 2
00000000                            
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C5+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F5		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E5		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E5		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ex	macro reg1, reg2
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            
00000000                            	if ((zreg1=zaf)|(zreg1=zaf2))&((ztemp=zaf)|(ztemp=zaf2))
00000000                            		dc.b $08			; ex af,af' & ex af',af & ex af,af
00000000                            
00000000                            	elseif ((zreg1=zde)|(zreg1=zhl))&((ztemp=zde)|(ztemp=zhl))
00000000                            		dc.b $EB			; ex de,hl & ex hl,de
00000000                            
00000000                            	elseif ((zreg1=zspr)|(zreg1=zhl))&((ztemp=zspr)|(ztemp=zhl))
00000000                            		dc.b $E3			; ex (sp),hl & ex hl,(sp)
00000000                            
00000000                            	elseif ((zreg1=zix)|(zreg1=zspr))&((ztemp=zix)|(ztemp=zspr))
00000000                            		dc.b $DD,$E3			; ex (sp),ix & ex ix,(sp)
00000000                            
00000000                            	elseif ((zreg1=ziy)|(zreg1=zspr))&((ztemp=ziy)|(ztemp=zspr))
00000000                            		dc.b $FD,$E3			; ex (sp),iy & ex iy,(sp)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            out	macro port, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if (ztemp=-1)&(instr("\port", "0")<>0)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            
00000000                            			dc.b $ED, $71		; out (c),0
00000000                            
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $41+(ztemp*$08)		; out (c),a, b, c, d, e, h or l
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; out (*),a
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            in	macro reg, port
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg, 0
00000000                            
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if narg=1
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            
00000000                            			dc.b $ED, $70		; in (c)
00000000                            
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $40+(ztemp*$08)		; in a, b, c, d, e, h or l,(c)
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; in a,(*)
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ld	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            zreg2 =	ztemp
00000000                            
00000000                            	if zreg1=-2
00000000                            		if zreg2=za
00000000                            			dc.b $32			; ld (**),a
00000000                            			z80word \reg1
00000000                            
00000000                            		elseif zreg2=zhl
00000000                            			dc.b $22			; ld (**),hl
00000000                            			z80word \reg1
00000000                            
00000000                            		elseif (zreg2>=zbc)&(zreg2<=zsp)
00000000                            			dc.b $ED, $43+((zreg2-zbc)*$10)	; ld (**),bc, de, sp
00000000                            			z80word \reg1
00000000                            
00000000                            		elseif zreg2=zix
00000000                            			dc.b $DD, $22			; ld (**),ix
00000000                            			z80word \reg1
00000000                            
00000000                            		elseif zreg2=ziy
00000000                            			dc.b $FD, $22			; ld (**),iy
00000000                            			z80word \reg1
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            	elseif zreg2=-1
00000000                            		if (zreg1<=za)
00000000                            			dc.b $06+(zreg1*$08), \reg2	; ld a, b, c, d, e, h or l,*
00000000                            
00000000                            		elseif zreg1=zhlr
00000000                            			dc.b $36, \reg2			; ld (hl),*
00000000                            
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $01+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,**
00000000                            			z80word \reg2
00000000                            
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $21			; ld ix,**
00000000                            			z80word \reg2
00000000                            
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $21			; ld iy,**
00000000                            			z80word \reg2
00000000                            
00000000                            		elseif zreg1=zixp
00000000                            			dc.b $DD			; ld (ix+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            
00000000                            		elseif zreg1=ziyp
00000000                            			dc.b $FD			; ld (iy+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            
00000000                            		elseif (zreg1>=zixh)&(zreg1<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            
00000000                            			dc.b $DD+((zreg1&$02)*$10), $26+((zreg1&$01)*$08), \reg2; ld ixh, ixl, iyh, iyl,*
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            	elseif zreg2=-2
00000000                            		if (zreg1=za)
00000000                            			dc.b $3A			; ld a,(**)
00000000                            			z80word \reg2
00000000                            
00000000                            		elseif zreg1=zhl
00000000                            			dc.b $2A			; ld hl,(**)
00000000                            			z80word \reg2
00000000                            
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $ED, $4B+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,(**)
00000000                            			z80word \reg2
00000000                            
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $2A			; ld ix,(**)
00000000                            			z80word \reg2
00000000                            
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $2A			; ld iy,(**)
00000000                            			z80word \reg2
00000000                            
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            
00000000                            	elseif (zreg1<=za)&(zreg2<=za)
00000000                            		dc.b $40+(zreg1*$08)+zreg2		; ld a, b, c, d, e, h or l,a, b, c, d, e, h or l
00000000                            
00000000                            	elseif (zreg1=za)&(zreg2=zbcr)
00000000                            		dc.b $0A				; ld a,(bc)
00000000                            
00000000                            	elseif (zreg1=za)&(zreg2=zder)
00000000                            		dc.b $1A				; ld a,(de)
00000000                            
00000000                            	elseif (zreg1<=za)&(zreg2=zhlr)
00000000                            		dc.b $46+(zreg1*$08)			; ld a, b, c, d, e, h or l,(hl)
00000000                            
00000000                            	elseif (zreg1=zhlr)&(zreg2<=za)
00000000                            		dc.b $70+zreg2				; ld (hl),a, b, c, d, e, h or l
00000000                            
00000000                            	elseif (zreg1<=za)&(zreg2=zixp)
00000000                            		dc.b $DD				; ld a, b, c, d, e, h or l,(ix+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            
00000000                            	elseif (zreg1<=za)&(zreg2=ziyp)
00000000                            		dc.b $FD				; ld a, b, c, d, e, h or l,(iy+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            
00000000                            	elseif (zreg2<=za)&(zreg1=zixp)
00000000                            		dc.b $DD				; ld (ix+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            
00000000                            	elseif (zreg2<=za)&(zreg1=ziyp)
00000000                            		dc.b $FD				; ld (iy+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            
00000000                            	elseif (zreg1=zbcr)&(zreg2=za)
00000000                            		dc.b $02				; ld (bc),a
00000000                            
00000000                            	elseif (zreg1=zder)&(zreg2=za)
00000000                            		dc.b $12				; ld (de),a
00000000                            
00000000                            	elseif (zreg1=zsp)&(zreg2=zhl)
00000000                            		dc.b $F9				; ld sp,hl
00000000                            
00000000                            	elseif (zreg1=zi)&(zreg2=za)
00000000                            		dc.b $ED, $47				; ld i,a
00000000                            
00000000                            	elseif (zreg2=zi)&(zreg1=za)
00000000                            		dc.b $ED, $57				; ld a,i
00000000                            
00000000                            	elseif (zreg1=zr)&(zreg2=za)
00000000                            		dc.b $ED, $4F				; ld r,a
00000000                            
00000000                            	elseif (zreg2=zr)&(zreg1=za)
00000000                            		dc.b $ED, $5F				; ld a,r
00000000                            
00000000                            	elseif (zreg1=zsp)&(zreg2=zix)
00000000                            		dc.b $DD, $F9				; ld sp, ix
00000000                            
00000000                            	elseif (zreg1=zsp)&(zreg2=ziy)
00000000                            		dc.b $FD, $F9				; ld sp, iy
00000000                            
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&((zreg2<=za)&(zreg2<>zh)&(zreg2<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+zreg2; ld ixh, ixl, iyh, iyl,a, b, c, d, e
00000000                            
00000000                            	elseif (zreg2>=zixh)&(zreg2<=ziyl)&((zreg1<=za)&(zreg1<>zh)&(zreg1<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((zreg2&$02)*$10), $44+(zreg2&$01)+(zreg1*$08); ld a, b, c, d, e,ixh, ixl, iyh, iyl
00000000                            
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&(zreg2>=zixh)&(zreg2>=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            
00000000                            		if ((zreg1&$02)<>(zreg2&$02))
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            			mexit
00000000                            		endif
00000000                            
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+(zreg2&$01); ld ixh, ixl, iyh, iyl,ixh, ixl, iyh, iyl
00000000                            
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            djnz	macro addr
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	zjrfuture \addr-*-2, $10
00000000                                endm
00000000                            
00000000                            jr	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	if narg=1
00000000                            		zjrfuture \cond-*-2, $18
00000000                            	else
00000000                            		jr\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jrnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	zjrfuture \off-*-2, $20
00000000                                endm
00000000                            
00000000                            jrnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	zjrfuture \off-*-2, $30
00000000                                endm
00000000                            
00000000                            jrz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	zjrfuture \off-*-2, $28
00000000                                endm
00000000                            
00000000                            jrc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	zjrfuture \off-*-2, $38
00000000                                endm
00000000                            
00000000                            jp	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	if narg=1
00000000                            		zgetreg \cond, 0
00000000                            
00000000                            		if ztemp=zhlr
00000000                            			dc.b $E9		; jp (hl)
00000000                            
00000000                            		elseif ztemp=zixr
00000000                            			dc.b $DD, $E9		; jp (ix)
00000000                            
00000000                            		elseif ztemp=ziyr
00000000                            			dc.b $FD, $E9		; jp (iy)
00000000                            
00000000                            		else
00000000                            			dc.b $C3		; jp **
00000000                            			z80word \cond
00000000                            		endif
00000000                            	else
00000000                            		jp\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jpnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $C2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $D2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $CA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpc	macro off
00000000                            	dc.b $DA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $E2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $F2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $EA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $FA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            call	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	if narg=1
00000000                            		dc.b $CD
00000000                            		z80word \cond
00000000                            	else
00000000                            		call\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            callnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $C4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $CC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $D4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $DC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $E4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $EC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $F4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            
00000000                            	dc.b $FC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            ret	macro cond
00000000                            	if narg=0
00000000                            		dc.b $C9
00000000                            	else
00000000                            		ret\cond
00000000                            	endif
00000000                                endm
00000000                            
00000000                            retnz	macro
00000000                            	dc.b $C0
00000000                                endm
00000000                            
00000000                            retz	macro
00000000                            	dc.b $C8
00000000                                endm
00000000                            
00000000                            retnc	macro
00000000                            	dc.b $D0
00000000                                endm
00000000                            
00000000                            retc	macro
00000000                            	dc.b $D8
00000000                                endm
00000000                            
00000000                            retpo	macro
00000000                            	dc.b $E0
00000000                                endm
00000000                            
00000000                            retpe	macro
00000000                            	dc.b $E8
00000000                                endm
00000000                            
00000000                            retp	macro
00000000                            	dc.b $F0
00000000                                endm
00000000                            
00000000                            retm	macro
00000000                            	dc.b $F8
00000000                                endm
00000000                            
00000000                            di	macro
00000000                            	if z80prg=0
00000000                            		move	#$2700,sr	; THIS IS HERE, IF YOU WANNA USE DI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $F3
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ei	macro
00000000                            	if z80prg=0
00000000                            		move	#$2300,sr	; THIS IS HERE, IF YOU WANNA USE EI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $FB
00000000                            	endif
00000000                                endm
00000000                            
00000000                            halt	macro
00000000                            	if z80prg=0
00000000                            		stop	#$2700		; THIS IS HERE, IF YOU WANNA USE HALT IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $76
00000000                            	endif
00000000                                endm
00000000                            
00000000                            znop	macro
00000000                            	dc.b $00
00000000                                endm
00000000                            
00000000                            rlca	macro
00000000                            	dc.b $07
00000000                                endm
00000000                            
00000000                            rla	macro
00000000                            	dc.b $17
00000000                                endm
00000000                            
00000000                            daa	macro
00000000                            	dc.b $27
00000000                                endm
00000000                            
00000000                            scf	macro
00000000                            	dc.b $37
00000000                                endm
00000000                            
00000000                            rrca	macro
00000000                            	dc.b $0F
00000000                                endm
00000000                            
00000000                            rra	macro
00000000                            	dc.b $1F
00000000                                endm
00000000                            
00000000                            cpl	macro
00000000                            	dc.b $2F
00000000                                endm
00000000                            
00000000                            ccf	macro
00000000                            	dc.b $3F
00000000                                endm
00000000                            
00000000                            exx	macro
00000000                            	dc.b $D9
00000000                                endm
00000000                            
00000000                            zneg	macro
00000000                            	dc.b $ED, $44
00000000                                endm
00000000                            
00000000                            retn	macro
00000000                            	dc.b $ED, $45
00000000                                endm
00000000                            
00000000                            reti	macro
00000000                            	dc.b $ED, $4D
00000000                                endm
00000000                            
00000000                            rrd	macro
00000000                            	dc.b $ED, $67
00000000                                endm
00000000                            
00000000                            rld	macro
00000000                            	dc.b $ED, $6F
00000000                                endm
00000000                            
00000000                            ldi	macro
00000000                            	dc.b $ED, $A0
00000000                                endm
00000000                            
00000000                            cpi	macro
00000000                            	dc.b $ED, $A1
00000000                                endm
00000000                            
00000000                            ini	macro
00000000                            	dc.b $ED, $A2
00000000                                endm
00000000                            
00000000                            outi	macro
00000000                            	dc.b $ED, $A3
00000000                                endm
00000000                            
00000000                            ldd	macro
00000000                            	dc.b $ED, $A8
00000000                                endm
00000000                            
00000000                            cpd	macro
00000000                            	dc.b $ED, $A9
00000000                                endm
00000000                            
00000000                            ind	macro
00000000                            	dc.b $ED, $AA
00000000                                endm
00000000                            
00000000                            outd	macro
00000000                            	dc.b $ED, $AB
00000000                                endm
00000000                            
00000000                            ldir	macro
00000000                            	dc.b $ED, $B0
00000000                                endm
00000000                            
00000000                            cpir	macro
00000000                            	dc.b $ED, $B1
00000000                                endm
00000000                            
00000000                            inir	macro
00000000                            	dc.b $ED, $B2
00000000                                endm
00000000                            
00000000                            otir	macro
00000000                            	dc.b $ED, $B3
00000000                                endm
00000000                            
00000000                            lddr	macro
00000000                            	dc.b $ED, $B8
00000000                                endm
00000000                            
00000000                            cpdr	macro
00000000                            	dc.b $ED, $B9
00000000                                endm
00000000                            
00000000                            indr	macro
00000000                            	dc.b $ED, $BA
00000000                                endm
00000000                            
00000000                            otdr	macro
00000000                            	dc.b $ED, $BB
00000000                                endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_ERROR_/debugger.asm"		; Debugger macro set
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000001                  isAMPS =		1		; Set to 1
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dem		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000DF                  fstr		equ		$DF				; flag to display as string (treat as offset, insert string from that offset)
00000000 =000000D0                  fasm		equ		$D0				; flag to display as code (treat as offset, decode from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            ;	* The "asm" flag will use "setpat" flag to switch text color, and will reset pattern to normal again.
00000000                            ;		you must reapply any pattern you used before yourself.
00000000                            ;	* The "asm" flag will overwrite $FF0000-$FF0080, so be careful when viewing RAM.
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  fsplit	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  fendl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  fpal0	equ		$E8				; use palette line #0
00000000 =000000EA                  fpal1	equ		$EA				; use palette line #1
00000000 =000000EC                  fpal2	equ		$EC				; use palette line #2
00000000 =000000EE                  fpal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            
00000000                            	pea		*(pc)
00000000                            	RaiseError2 \_
00000000                            	endm
00000000                            
00000000                            RaiseError2 &
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea	4*4(sp), a2
00000000                            		endc
00000000                            		lea	.str\@(pc), a1
00000000                            		jsr	ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea	__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	.instr_end\@
00000000                            	.str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	.instr_end\@:
00000000                            
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr	ErrorHandler.__extern__console_only
00000000                            		jsr	\1
00000000                            		if narg<=1		; HACK
00000000                            			bra.s	*
00000000                            		endif
00000000                            
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr	ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            
00000000                            	while (__pos)
00000000                            
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            
00000000                            	endm
00000000                            		include	"../amps/code/macro.asm"	; AMPS macros
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Various assembly flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            	opt ae+
00000000                            
00000000                            ; if safe mode is enabled (1), then the driver will attempt to find any issues.
00000000                            ; if Vladik's error debugger is installed, then the error will be displayed.
00000000                            ; else, the CPU is trapped.
00000000                            
00000000 =00000000                  safe =	DEBUG
00000000                            
00000000                            ; Select the tempo algorith.
00000000                            ; 0 = Overflow method.
00000000                            ; 1 = Counter method.
00000000                            
00000000 =00000000                  tempo =	0
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Channel configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cFlags		rs.b 1		; various channel flags, see below
00000000 =00000001                  cType		rs.b 1		; hardware type for the channel
00000000 =00000002                  cData		rs.l 1		; 68k tracker address for the channel
00000000 =00000006                  cPanning	rs.b 0		; channel panning and LFO. FM and DAC only
00000000 =00000006                  cEnvPos		rs.b 1		; volume envelope position. PSG only
00000000 =00000007                  cDetune		rs.b 1		; frequency detune (offset)
00000000 =00000008                  cPitch		rs.b 1		; pitch (transposition) offset
00000000 =00000009                  cVolume		rs.b 1		; channel volume
00000000 =0000000A                  cTick		rs.b 1		; channel tick multiplier
00000000 =0000000B                  cSample		rs.b 0		; channel sample ID, DAC only
00000000 =0000000B                  cVolEnv		rs.b 0		; volume envelope ID. PSG only
00000000 =0000000B                  cVoice		rs.b 1		; YM2612 voice ID. FM only
00000000 =0000000C                  cDuration	rs.b 1		; current note duration
00000000 =0000000D                  cLastDur	rs.b 1		; last note duration
00000000 =0000000E                  cFreq		rs.w 1		; channel base frequency
00000000 =00000010                  cModDelay	rs.b 0		; delay before modulation starts
00000000 =00000010                  cMod		rs.l 1		; modulation data address
00000000 =00000014                  cModFreq	rs.w 1		; modulation frequency offset
00000000 =00000016                  cModSpeed	rs.b 1		; number of frames til next modulation step
00000000 =00000017                  cModStep	rs.b 1		; modulation frequency offset per step
00000000 =00000018                  cModCount	rs.b 1		; number of modulation steps until reversal
00000000 =00000019                  cLoop		rs.b 3		; loop counter values
00000000 =0000001B                  cStatPSG4 =	__rs-1		; PSG4 type value. PSG3 only
00000000 =0000001A                  cPrio =		__rs-2		; sound effect channel priority. SFX only
00000000 =0000001C                  cSizeSFX	rs.w 0		; size of each SFX track
00000000                            
00000000 =0000001C                  cNoteTimeCur	rs.b 1		; frame counter to note off. Music only
00000000 =0000001D                  cNoteTimeMain	rs.b 1		; copy of frame counter to note off. Music only
00000000 =0000001E                  cStack		rs.b 1		; channel stack pointer. Music only
00000000                            		rs.b 1		; unused. Music only
00000000                            		rs.l 3		; channel stack data. Music only
00000000 =0000002C                  cSize		rs.w 0		; size of each music track
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for cFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cfbMode		rs.b 0		; set if in pitch mode, clear if in sample mode. DAC only
00000000 =00000000                  cfbRest		rs.b 1		; set if channel is resting. FM and PSG only
00000000 =00000001                  cfbInt		rs.b 1		; set if interrupted by SFX. Music only
00000000 =00000002                  cfbHold		rs.b 1		; set if playing notes does not trigger note-on's
00000000 =00000003                  cfbMod		rs.b 1		; set if modulation is enabled
00000000 =00000004                  cfbCond		rs.b 1		; set if ignoring many tracker commands
00000000 =00000005                  cfbVol		rs.b 1		; set if channel should update volume
00000000 =00000007                  cfbRun =	$07		; set if channel is running a tracker
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc variables for channel modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  ctbPt2 =	$02		; bit part 2 - FM 4-6
00000000 =00000000                  ctFM1 =		$00		; FM 1
00000000 =00000001                  ctFM2 =		$01		; FM 2
00000000 =00000002                  ctFM3 =		$02		; FM 3	- Valid for SFX
00000000 =00000004                  ctFM4 =		$04		; FM 4	- Valid for SFX
00000000 =00000005                  ctFM5 =		$05		; FM 5	- Valid for SFX
00000000                            
00000000 =00000003                  ctbDAC =	$03		; DAC bit
00000000 =0000000B                  ctDAC1 =	(1<<ctbDAC)|$03	; DAC 1	- Valid for SFX
00000000 =0000000E                  ctDAC2 =	(1<<ctbDAC)|$06	; DAC 2
00000000                            
00000000 =00000080                  ctPSG1 =	$80		; PSG 1	- Valid for SFX
00000000 =000000A0                  ctPSG2 =	$A0		; PSG 2	- Valid for SFX
00000000 =000000C0                  ctPSG3 =	$C0		; PSG 3	- Valid for SFX
00000000 =000000E0                  ctPSG4 =	$E0		; PSG 4
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  Mus_DAC =	2		; number of DAC channels
00000000 =00000005                  Mus_FM =	5		; number of FM channels
00000000 =00000003                  Mus_PSG =	3		; number of PSG channels
00000000 =0000000A                  Mus_Ch =	Mus_DAC+Mus_FM+Mus_PSG; total number of music channels
00000000 =00000001                  SFX_DAC =	1		; number of DAC SFX channels
00000000 =00000003                  SFX_FM =	3		; number of FM SFX channels
00000000 =00000003                  SFX_PSG =	3		; number of PSG SFX channels
00000000 =00000007                  SFX_Ch =	SFX_DAC+SFX_FM+SFX_PSG; total number of SFX channels
00000000                            
00000000 =0000001D                  VoiceRegs =	29		; total number of registers inside of a voice
00000000 =00000019                  VoiceTL =	VoiceRegs-4	; location of voice TL levels
00000000                            
00000000 =00001000                  MaxPitch =	$1000		; this is the maximum pitch Dual PCM is capable of processing
00000000 =00000018                  Z80E_Read =	$00018		; this is used by Dual PCM internally but we need this for macros
00000000                            
00000000                            ; NOTE: There is no magic trick to making Dual PCM play samples at higher rates.
00000000                            ; These values are only here to allow you to give lower pitch samples higher
00000000                            ; quality, and playing samples at higher rates than Dual PCM can process them
00000000                            ; may decrease the perceived quality by the end user. Use these equates only
00000000                            ; if you know what you are doing.
00000000                            
00000000 =00000140                  sr17 =		$0140		; 5 Quarter sample rate	17500 Hz
00000000 =00000120                  sr15 =		$0120		; 9 Eights sample rate	15750 Hz
00000000 =00000100                  sr14 =		$0100		; Default sample rate	14000 Hz
00000000 =000000E0                  sr12 =		$00E0		; 7 Eights sample rate	12250 Hz
00000000 =000000C0                  sr10 =		$00C0		; 3 Quarter sample rate	10500 Hz
00000000 =000000A0                  sr8 =		$00A0		; 5 Eights sample rate	8750 Hz
00000000 =00000080                  sr7 =		$0080		; Half sample rate	7000 HZ
00000000 =00000060                  sr5 =		$0060		; 3 Eights sample rate	5250 Hz
00000000 =00000040                  sr3 =		$0040		; 1 Quarter sample rate	3500 Hz
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound driver RAM configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00A00000                  dZ80 =		$A00000		; quick reference to Z80 RAM
00000000 =00C00011                  dPSG =		$C00011		; quick reference to PSG port
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for mFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  mfbRing		rs.b 1		; if set, change speaker (play different sfx)
00000000 =00000001                  mfbSpeed	rs.b 1		; if set, speed shoes are active
00000000 =00000002                  mfbWater	rs.b 1		; if set, underwater mode is active
00000000 =00000003                  mfbNoPAL	rs.b 1		; if set, play songs slowly in PAL region
00000000 =00000007                  mfbPaused =	$07		; if set, sound driver is paused
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound ID equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 1
00000000 =00000001                  Mus_Reset	rs.b 1		; reset underwater and speed shoes flags, update volume
00000000 =00000002                  Mus_FadeOut	rs.b 1		; initialize a music fade out
00000000 =00000003                  Mus_Stop	rs.b 1		; stop all music
00000000 =00000004                  Mus_ShoesOn	rs.b 1		; enable speed shoes mode
00000000 =00000005                  Mus_ShoesOff	rs.b 1		; disable speed shoes mode
00000000 =00000006                  Mus_ToWater	rs.b 1		; enable underwater mode
00000000 =00000007                  Mus_OutWater	rs.b 1		; disable underwater mode
00000000 =00000008                  Mus_Pause	rs.b 1		; pause the music
00000000 =00000009                  Mus_Unpause	rs.b 1		; unpause the music
00000000 =0000000A                  MusOff		rs.b 0		; first music ID
00000000                            
00000000 =00000078                  MusCount =	$78		; number of installed music tracks
00000000 =00000082                  SFXoff =	MusCount+MusOff	; first SFX ID
00000000 =00000078                  SFXcount =	$78		; number of intalled sound effects
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Condition modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  dcoT		rs.b 1		; condition T	; True
00000000 =00000001                  dcoF		rs.b 1		; condition F	; False
00000000 =00000002                  dcoHI		rs.b 1		; condition HI	; HIgher (unsigned)
00000000 =00000003                  dcoLS		rs.b 1		; condition LS	; Less or Same (unsigned)
00000000 =00000004                  dcoHS		rs.b 0		; condition HS	; Higher or Sane (unsigned)
00000000 =00000004                  dcoCC		rs.b 1		; condition CC	; Carry Clear (unsigned)
00000000 =00000005                  dcoLO		rs.b 0		; condition LO	; LOwer (unsigned)
00000000 =00000005                  dcoCS		rs.b 1		; condition CS	; Carry Set (unsigned)
00000000 =00000006                  dcoNE		rs.b 1		; condition NE	; Not Equal
00000000 =00000007                  dcoEQ		rs.b 1		; condition EQ	; EQual
00000000 =00000008                  dcoVC		rs.b 1		; condition VC	; oVerflow Clear (signed)
00000000 =00000009                  dcoVS		rs.b 1		; condition VS	; oVerflow Set (signed)
00000000 =0000000A                  dcoPL		rs.b 1		; condition PL	; Positive (PLus)
00000000 =0000000B                  dcoMI		rs.b 1		; condition MI	; Negamite (MInus)
00000000 =0000000C                  dcoGE		rs.b 1		; condition GE	; Greater or Equal (signed)
00000000 =0000000D                  dcoLT		rs.b 1		; condition LT	; Less Than (signed)
00000000 =0000000E                  dcoGT		rs.b 1		; condition GT	; GreaTer (signed)
00000000 =0000000F                  dcoLE		rs.b 1		; condition LE	; Less or Equal (signed)
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Emvelope commands equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  eReset		rs.w 1		; 80 - Restart from position 0
00000000 =00000082                  eHold		rs.w 1		; 82 - Hold volume at current level
00000000 =00000084                  eLoop		rs.w 1		; 84 - Jump back/forwards according to next byte
00000000 =00000086                  eStop		rs.w 1		; 86 - Stop current note and envelope
00000000 =00000088                  eLast		rs.w 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Fade out end commands
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  fEnd		rs.l 1		; 80 - Do nothing
00000000 =00000084                  fStop		rs.l 1		; 84 - Stop all music
00000000 =00000088                  fResVol		rs.l 1		; 88 - Reset volume and update
00000000 =0000008C                  fReset		rs.l 1		; 8C - Stop music playing and reset volume
00000000 =00000090                  fLast		rs.l 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Quickly read a word from odd address. 28 cycles
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dREAD_WORD	macro areg, dreg
00000000                            	move.b	(\areg)+,(sp)		; read the next byte into stack
00000000                            	move.w	(sp),\dreg		; get word back from stack (shift byte by 8 bits)
00000000                            	move.b	(\areg),\dreg		; get the next byte into register
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; used to calculate the address of the right FM voice
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dCALC_VOICE	macro off
00000000                            	lsl.w	#5,d0			; multiply voice ID by $20
00000000                            	if narg>0
00000000                            		add.w	#\off,d0	; if have had extra argument, add it to offset
00000000                            	endif
00000000                            
00000000                            	add.w	d0,a1			; add offset to voice table address
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to stop, and waits for it to finish stopping (acquire bus)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;stopZ80 	macro
00000000                            ;	move.w	#$100,$A11100		; stop the Z80
00000000                            ;.loop\@
00000000                            ;	btst	#0,$A11100
00000000                            ;	bne.s	.loop\@			; loop until it says it's stopped
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to start again
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;startZ80 	macro
00000000                            ;	move.w	#0,$A11100		; start the Z80
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for pausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSPAUSE	macro	; enable request pause and paused flags
00000000                            	move.b	#Mus_Pause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for unpausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSUNPAUSE	macro	; enable request unpause flag
00000000                            	move.b	#Mus_Unpause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for queueing sound
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            playSnd	macro id, queue	; queue sound
00000000                            	move.b	\id,(mQueue+((\queue\)-1)).w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create volume envelope table, and SMPS2ASM equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            volenv		macro name
00000000                            	rept narg			; repeate for all arguments
00000000                            v\name =	__venv			; create SMPS2ASM equate
00000000                            		dc.l vd\name		; create pointer
00000000                            __venv =	__venv+1		; increase ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates SFX pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrSFX		macro type, name
00000000                            .type =		\type<<24		; create equate for the type mask
00000000                            
00000000                            	rept narg-1			; repeat for all arguments
00000000                            		dc.l \name\|.type	; create pointer with specified type
00000000                            __sfx =		__sfx+1			; increase SFX ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates music pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrMusic	macro name, sptempo
00000000                            	rept narg/2			; repeat for half of the arguments
00000000                            		dc.l ((\sptempo)<<24)|\name\; create pointer with tempo
00000000                            __mus =		__mus+1			; increase music ID
00000000                            	shift				; shift next argument into view
00000000                            	shift				; ''
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Include PCM data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            incSWF		macro name, file
00000000                            SWF_\name\	incbin	\file		; include PCM data
00000000                            SWFR_\name\ 	dcb.b Z80E_Read*(MaxPitch/$100),$00; add end markers (for Dual PCM)
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create data for a sample
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            sample		macro freq, start, loop, name
00000000                            	if narg=4		; if we have 4 arguments, we'd like a custom name
00000000                            d\name =	__samp		; use the extra argument to create SMPS2ASM equate
00000000                            	else
00000000                            d\start =	__samp		; else, use the first one!
00000000                            	endif
00000000                            
00000000                            __samp =	__samp+1	; increase sample ID
00000000                            ; create offsets for the sample normal, reverse, loop normal, loop reverse.
00000000                            	dc.b SWF_\start&$FF,((SWF_\start>>$08)&$7F)|$80,(SWF_\start>>$0F)&$FF
00000000                            	dc.b (SWFR_\start-1)&$FF,(((SWFR_\start-1)>>$08)&$7F)|$80,((SWFR_\start-1)>>$0F)&$FF
00000000                            	dc.b SWF_\loop&$FF,((SWF_\loop>>$08)&$7F)|$80, (SWF_\loop>>$0F)&$FF
00000000                            	dc.b (SWFR_\loop-1)&$FF,(((SWFR_\loop-1)>>$08)&$7F)|$80,((SWFR_\loop-1)>>$0F)&$FF
00000000                            	dc.w \freq-$100		; sample frequency (actually offset, so we remove $100)
00000000                            	dc.w 0			; unused!
00000000                                endm
00000000                            ; ===========================================================================
00000000                            	opt ae-
00000000                            		include	"../amps/code/smps2asm.asm"	; AMPS SMPS2ASM
00000000                            ; ===============================================
00000000                            ; Based on Flamewing's SMPS2ASM, and S1SMPS2ASM by Marc (AKA Cinossu)
00000000                            ; Reworked and improved by Natsumi
00000000                            ; ===============================================
00000000                            ; this macro is created to emulate enum in AS
00000000                            enum	macro	num, lable
00000000                            ; copy initial number for referencing later
00000000                            .num	= num
00000000                            
00000000                            	rept narg-1
00000000                            \lable		set .num
00000000                            .num =	.num+1
00000000                            	shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Note Equates
00000000                            	enum $80+0, nRst
00000000 =00000080                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000080                M nrst	set	.num
00000000 =00000081                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nRst+1,nC0,nCs0,nD0,nEb0,nE0,nF0,nFs0,nG0,nAb0,nA0,nBb0,nB0
00000000 =00000081                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000081                M nc0	set	.num
00000000 =00000082                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000082                M ncs0	set	.num
00000000 =00000083                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000083                M nd0	set	.num
00000000 =00000084                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000084                M neb0	set	.num
00000000 =00000085                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000085                M ne0	set	.num
00000000 =00000086                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000086                M nf0	set	.num
00000000 =00000087                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000087                M nfs0	set	.num
00000000 =00000088                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000088                M ng0	set	.num
00000000 =00000089                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000089                M nab0	set	.num
00000000 =0000008A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008A                M na0	set	.num
00000000 =0000008B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008B                M nbb0	set	.num
00000000 =0000008C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008C                M nb0	set	.num
00000000 =0000008D                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB0+1, nC1,nCs1,nD1,nEb1,nE1,nF1,nFs1,nG1,nAb1,nA1,nBb1,nB1
00000000 =0000008D                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =0000008D                M nc1	set	.num
00000000 =0000008E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008E                M ncs1	set	.num
00000000 =0000008F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008F                M nd1	set	.num
00000000 =00000090                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000090                M neb1	set	.num
00000000 =00000091                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000091                M ne1	set	.num
00000000 =00000092                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000092                M nf1	set	.num
00000000 =00000093                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000093                M nfs1	set	.num
00000000 =00000094                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000094                M ng1	set	.num
00000000 =00000095                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000095                M nab1	set	.num
00000000 =00000096                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000096                M na1	set	.num
00000000 =00000097                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000097                M nbb1	set	.num
00000000 =00000098                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000098                M nb1	set	.num
00000000 =00000099                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB1+1, nC2,nCs2,nD2,nEb2,nE2,nF2,nFs2,nG2,nAb2,nA2,nBb2,nB2
00000000 =00000099                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000099                M nc2	set	.num
00000000 =0000009A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009A                M ncs2	set	.num
00000000 =0000009B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009B                M nd2	set	.num
00000000 =0000009C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009C                M neb2	set	.num
00000000 =0000009D                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009D                M ne2	set	.num
00000000 =0000009E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009E                M nf2	set	.num
00000000 =0000009F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009F                M nfs2	set	.num
00000000 =000000A0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A0                M ng2	set	.num
00000000 =000000A1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A1                M nab2	set	.num
00000000 =000000A2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A2                M na2	set	.num
00000000 =000000A3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A3                M nbb2	set	.num
00000000 =000000A4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A4                M nb2	set	.num
00000000 =000000A5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB2+1, nC3,nCs3,nD3,nEb3,nE3,nF3,nFs3,nG3,nAb3,nA3,nBb3,nB3
00000000 =000000A5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000A5                M nc3	set	.num
00000000 =000000A6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A6                M ncs3	set	.num
00000000 =000000A7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A7                M nd3	set	.num
00000000 =000000A8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A8                M neb3	set	.num
00000000 =000000A9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A9                M ne3	set	.num
00000000 =000000AA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AA                M nf3	set	.num
00000000 =000000AB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AB                M nfs3	set	.num
00000000 =000000AC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AC                M ng3	set	.num
00000000 =000000AD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AD                M nab3	set	.num
00000000 =000000AE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AE                M na3	set	.num
00000000 =000000AF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AF                M nbb3	set	.num
00000000 =000000B0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B0                M nb3	set	.num
00000000 =000000B1                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB3+1, nC4,nCs4,nD4,nEb4,nE4,nF4,nFs4,nG4,nAb4,nA4,nBb4,nB4
00000000 =000000B1                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000B1                M nc4	set	.num
00000000 =000000B2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B2                M ncs4	set	.num
00000000 =000000B3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B3                M nd4	set	.num
00000000 =000000B4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B4                M neb4	set	.num
00000000 =000000B5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B5                M ne4	set	.num
00000000 =000000B6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B6                M nf4	set	.num
00000000 =000000B7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B7                M nfs4	set	.num
00000000 =000000B8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B8                M ng4	set	.num
00000000 =000000B9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B9                M nab4	set	.num
00000000 =000000BA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BA                M na4	set	.num
00000000 =000000BB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BB                M nbb4	set	.num
00000000 =000000BC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BC                M nb4	set	.num
00000000 =000000BD                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB4+1, nC5,nCs5,nD5,nEb5,nE5,nF5,nFs5,nG5,nAb5,nA5,nBb5,nB5
00000000 =000000BD                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000BD                M nc5	set	.num
00000000 =000000BE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BE                M ncs5	set	.num
00000000 =000000BF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BF                M nd5	set	.num
00000000 =000000C0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C0                M neb5	set	.num
00000000 =000000C1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C1                M ne5	set	.num
00000000 =000000C2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C2                M nf5	set	.num
00000000 =000000C3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C3                M nfs5	set	.num
00000000 =000000C4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C4                M ng5	set	.num
00000000 =000000C5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C5                M nab5	set	.num
00000000 =000000C6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C6                M na5	set	.num
00000000 =000000C7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C7                M nbb5	set	.num
00000000 =000000C8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C8                M nb5	set	.num
00000000 =000000C9                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB5+1, nC6,nCs6,nD6,nEb6,nE6,nF6,nFs6,nG6,nAb6,nA6,nBb6,nB6
00000000 =000000C9                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000C9                M nc6	set	.num
00000000 =000000CA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CA                M ncs6	set	.num
00000000 =000000CB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CB                M nd6	set	.num
00000000 =000000CC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CC                M neb6	set	.num
00000000 =000000CD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CD                M ne6	set	.num
00000000 =000000CE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CE                M nf6	set	.num
00000000 =000000CF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CF                M nfs6	set	.num
00000000 =000000D0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D0                M ng6	set	.num
00000000 =000000D1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D1                M nab6	set	.num
00000000 =000000D2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D2                M na6	set	.num
00000000 =000000D3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D3                M nbb6	set	.num
00000000 =000000D4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D4                M nb6	set	.num
00000000 =000000D5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB6+1, nC7,nCs7,nD7,nEb7,nE7,nF7,nFs7,nG7,nAb7,nA7,nBb7
00000000 =000000D5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000D5                M nc7	set	.num
00000000 =000000D6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D6                M ncs7	set	.num
00000000 =000000D7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D7                M nd7	set	.num
00000000 =000000D8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D8                M neb7	set	.num
00000000 =000000D9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D9                M ne7	set	.num
00000000 =000000DA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DA                M nf7	set	.num
00000000 =000000DB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DB                M nfs7	set	.num
00000000 =000000DC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DC                M ng7	set	.num
00000000 =000000DD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DD                M nab7	set	.num
00000000 =000000DE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DE                M na7	set	.num
00000000 =000000DF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DF                M nbb7	set	.num
00000000 =000000E0                M .num	=	.num+1
00000000                          M 	shift
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; PSG volume envelope equates
00000000 =00000000                  v00 =	$00
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Header Macros
00000000                            sHeaderInit	macro
00000000                            sPointZero =	*
00000000                            sPatNum =	0
00000000                                endm
00000000                            
00000000                            ; Header - Set up Channel Usage
00000000                            sHeaderCh	macro fm,psg
00000000                            	dc.b \fm-1
00000000                            
00000000                            	if narg=2
00000000                            		if \fm>5
00000000                            			inform 2,"You sure there are \fm FM channels?"
00000000                            		endif
00000000                            
00000000                            		dc.b \psg-1
00000000                            		if \psg>3
00000000                            			inform 2,"You sure there are \psg PSG channels?"
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Convert S1 tempo to S3 tempo
00000000                            sConvS1Tempo	macro tempo
00000000                            s2tempo = ((((((((tempo=0)&1)<<8)|tempo)-1)<<8)+(((((tempo=0)&1)<<8)|tempo)>>1))/((((tempo=0)&1)<<8)|tempo))&$FF
00000000                            s3tempo = ($100-(((s2tempo=0)&1)|s2tempo))&$FF
00000000                                endm
00000000                            
00000000                            ; Header - Set up Tempo and Tick Multiplier
00000000                            sHeaderTempo	macro tmul,tempo
00000000                            	dc.b \tmul-1,\tempo
00000000                                endm
00000000                            
00000000                            sHeaderTempoS1	macro tmul,tempo
00000000                            	sConvS1Tempo \tempo
00000000                            	dc.b \tmul-1,s3tempo
00000000                                endm
00000000                            
00000000                            ; Header - Set priority leve
00000000                            sHeaderPrio	macro prio
00000000                            	dc.b \prio
00000000                                endm
00000000                            
00000000                            ; Header - Set up DAC Channel
00000000                            sHeaderDAC	macro loc,vol,samp
00000000                            	dc.w \loc-sPointZero
00000000                            
00000000                            	if narg>=2
00000000                            		dc.b \vol
00000000                            		if narg>=3
00000000                            			dc.b \samp
00000000                            		else
00000000                            			dc.b $00
00000000                            		endif
00000000                            	else
00000000                            		dc.w $00
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Header - Set up FM Channel
00000000                            sHeaderFM	macro loc,pitch,vol
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; Header - Set up PSG Channel
00000000                            sHeaderPSG	macro loc,pitch,vol,detune,volenv
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol,\detune,\volenv
00000000                                endm
00000000                            
00000000                            ; Header - Set up SFX Channel
00000000                            sHeaderSFX	macro flags,type,loc,pitch,vol
00000000                            	dc.b \flags,\type
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Command Flag Macros and Equates. Based on the original s1smps2asm, and Flamewing's smps2asm
00000000 =00000000                  spNone set $00
00000000 =00000040                  spRight set $40
00000000 =00000080                  spLeft set $80
00000000 =000000C0                  spCentre set $C0
00000000 =000000C0                  spCenter set $C0
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Macros for FM instruments
00000000                            ; Patches - Feedback
00000000                            
00000000                            ; Patches - Algorithm
00000000                            spAlgorithm macro val, name
00000000                            	if (sPatNum<>0)&(safe=0)
00000000                            		; align the patch
00000000                            		dc.b (*^(sPatNum*spTL4))&$FF
00000000                            		dc.b ((*>>8)+(spDe3*spDR3))&$FF
00000000                            		dc.b ((*>>16)-(spTL1*spRR3))&$FF
00000000                            	endif
00000000                            
00000000                            	if narg>1
00000000                            p\name =	sPatNum
00000000                            	endif
00000000                            
00000000                            sPatNum =	sPatNum+1
00000000                            spAl	= val
00000000                                endm
00000000                            
00000000                            spFeedback macro val
00000000                            spFe	= val
00000000                                endm
00000000                            
00000000                            ; Patches - Detune
00000000                            spDetune macro op1,op2,op3,op4
00000000                            spDe1	= op1
00000000                            spDe2	= op2
00000000                            spDe3	= op3
00000000                            spDe4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Multiple
00000000                            spMultiple macro op1,op2,op3,op4
00000000                            spMu1	= op1
00000000                            spMu2	= op2
00000000                            spMu3	= op3
00000000                            spMu4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Rate Scale
00000000                            spRateScale macro op1,op2,op3,op4
00000000                            spRS1	= op1
00000000                            spRS2	= op2
00000000                            spRS3	= op3
00000000                            spRS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Attack Rate
00000000                            spAttackRt macro op1,op2,op3,op4
00000000                            spAR1	= op1
00000000                            spAR2	= op2
00000000                            spAR3	= op3
00000000                            spAR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Amplitude Modulation
00000000                            spAmpMod macro op1,op2,op3,op4
00000000                            spAM1	= op1
00000000                            spAM2	= op2
00000000                            spAM3	= op3
00000000                            spAM4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Rate
00000000                            spSustainRt macro op1,op2,op3,op4
00000000                            spSR1	= op1		; Also known as decay 1 rate
00000000                            spSR2	= op2
00000000                            spSR3	= op3
00000000                            spSR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Level
00000000                            spSustainLv macro op1,op2,op3,op4
00000000                            spSL1	= op1		; also known as decay 1 level
00000000                            spSL2	= op2
00000000                            spSL3	= op3
00000000                            spSL4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Decay Rate
00000000                            spDecayRt macro op1,op2,op3,op4
00000000                            spDR1	= op1		; Also known as decay 2 rate
00000000                            spDR2	= op2
00000000                            spDR3	= op3
00000000                            spDR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Release Rate
00000000                            spReleaseRt macro op1,op2,op3,op4
00000000                            spRR1	= op1
00000000                            spRR2	= op2
00000000                            spRR3	= op3
00000000                            spRR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - SSG-EG
00000000                            spSSGEG macro op1,op2,op3,op4
00000000                            spSS1	= op1
00000000                            spSS2	= op2
00000000                            spSS3	= op3
00000000                            spSS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level
00000000                            spTotalLv macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            
00000000                            ; Construct the patch finally.
00000000                            	dc.b	(spFe<<3)+spAl
00000000                            ;   0     1     2     3     4     5     6     7
00000000                            ;%1000,%1000,%1000,%1000,%1010,%1110,%1110,%1111
00000000                            spTLMask4 set $80
00000000                            spTLMask2 set ((spAl>=5)<<7)
00000000                            spTLMask3 set ((spAl>=4)<<7)
00000000                            spTLMask1 set ((spAl=7)<<7)
00000000                            
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1|spTLMask1,  spTL3|spTLMask3,  spTL2|spTLMask2,  spTL4|spTLMask4
00000000                            
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level (for broken total level masks)
00000000                            spTotalLv2 macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            
00000000                            	dc.b (spFe<<3)+spAl
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1,	       spTL3,		 spTL2,		   spTL4
00000000                            
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; SMPS commands
00000000                            
00000000                            ; E0xx - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00000000                            sPan		macro pan, ams, fms
00000000                            	if narg=1
00000000                            		dc.b $E0, \pan
00000000                            
00000000                            	elseif narg=2
00000000                            		dc.b $E0, \pan|\ams
00000000                            	else
00000000                            		dc.b $E0, \pan|(\ams<<4)|\fms
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; E1xx - Set channel frequency displacement to xx (DETUNE_SET)
00000000                            ssDetune	macro val
00000000                            	dc.b $E1, \val
00000000                                endm
00000000                            
00000000                            ; E2xx - Add xx to channel frequency displacement (DETUNE)
00000000                            saDetune	macro val
00000000                            	dc.b $E2, \val
00000000                                endm
00000000                            
00000000                            ; E3xx - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00000000                            ssTranspose	macro val
00000000                            	dc.b $E3, \val
00000000                                endm
00000000                            
00000000                            ; E4xx - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00000000                            saTranspose	macro val
00000000                            	dc.b $E4, \val
00000000                                endm
00000000                            
00000000                            ; E5xx - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00000000                            ssTickMulCh	macro val
00000000                            	dc.b $E5, \val-1
00000000                                endm
00000000                            
00000000                            ; E6xx - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00000000                            ssTickMul	macro val
00000000                            	dc.b $E6, \val-1
00000000                                endm
00000000                            
00000000                            ; E7 - Do not attack of next note (HOLD)
00000000 =000000E7                  sHold =		$E7
00000000                            
00000000                            ; E8xx - Set patch/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00000000                            sVoice		macro val
00000000                            	dc.b $E8, \val
00000000                                endm
00000000                            
00000000                            ; E9xx - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00000000                            ssTempoShoes	macro val
00000000                            	dc.b $E9, \val
00000000                                endm
00000000                            
00000000                            ; EAxx - Set music tempo to xx (TEMPO - TEMPO_SET)
00000000                            ssTempo		macro val
00000000                            	dc.b $EA, \val
00000000                                endm
00000000                            ssTempoS1	macro val
00000000                            	sConvS1Tempo \val
00000000                            	dc.b $EA, s3tempo
00000000                                endm
00000000                            
00000000                            ; EB - Turn on Modulation (MOD_SET - MODS_ON)
00000000                            sModOn		macro
00000000                            	dc.b $EB
00000000                                endm
00000000                            
00000000                            ; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00000000                            sModOff		macro
00000000                            	dc.b $EC
00000000                                endm
00000000                            
00000000                            ; EDxx - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00000000                            saVol		macro vol
00000000                            	dc.b $ED, \vol
00000000                                endm
00000000                            
00000000                            ; EExx - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00000000                            ssVol		macro vol
00000000                            	dc.b $EE, \vol
00000000                                endm
00000000                            
00000000                            ; EFxxyy - Enable/Disable LFO (SET_LFO - LFO_AMSEN)
00000000                            ssLFO		macro reg, ams, fms, pan
00000000                            	if narg=2
00000000                            		dc.b $EF, \reg,\ams
00000000                            
00000000                            	elseif narg=3
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms
00000000                            
00000000                            	else
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms|\pan
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; F0wwxxyyzz - Modulation
00000000                            ;  ww: wait time
00000000                            ;  xx: modulation speed
00000000                            ;  yy: change per step
00000000                            ;  zz: number of steps
00000000                            ; (MOD_SETUP)
00000000                            ssMod68k	macro wait, speed, step, count
00000000                            	dc.b $F0, \wait,\speed,\step,\count
00000000                                endm
00000000                            
00000000                            ; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00000000                            sModeSampDAC	macro
00000000                            	dc.b $F1
00000000                                endm
00000000                            
00000000                            ; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00000000                            sModePitchDAC	macro
00000000                            	dc.b $F2
00000000                                endm
00000000                            
00000000                            ; F3xx - PSG4 noise mode xx (PSG_NOISE - PNOIS_AMPS)
00000000                            sNoisePSG	macro val
00000000                            	dc.b $F3, \val
00000000                                endm
00000000                            
00000000                            ; F4xxxx - Keep looping back to xxxx each time the SFX is being played (CONT_SFX)
00000000                            sCont		macro loc
00000000                            	dc.b $F4
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F5 - End of channel (TRK_END - TEND_STD)
00000000                            sStop		macro
00000000                            	dc.b $F5
00000000                                endm
00000000                            
00000000                            ; F6xxxx - Jump to xxxx (GOTO)
00000000                            ssJump		macro loc
00000000                            	dc.b $F6
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F7xxyyzzzz - Loop back to zzzz yy times, xx being the loop index for loop recursion fixing (LOOP)
00000000                            sLoop		macro index,loops,loc
00000000                            	dc.b $F7, \index
00000000                            	dc.w \loc-*-1
00000000                            	dc.b \loops
00000000                                endm
00000000                            
00000000                            ; F8xxxx - Call pattern at xxxx, saving return point (GOSUB)
00000000                            sCall		macro loc
00000000                            	dc.b $F8
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F9 - Return (RETURN)
00000000                            sRet		macro
00000000                            	dc.b $F9
00000000                                endm
00000000                            
00000000                            ; FAyyxx - Set communications byte yy to xx (SET_COMM - SPECIAL)
00000000                            sComm		macro num, val
00000000                            	dc.b $FA, \num,\val
00000000                                endm
00000000                            
00000000                            ; FBxyzz - Get communications byte y, and compare zz with it using condition x (COMM_CONDITION)
00000000                            sCond		macro num, cond, val
00000000                            	dc.b $FB, \num|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FC - Reset condition (COMM_RESET)
00000000                            sCondOff	macro
00000000                            	dc.b $FC
00000000                                endm
00000000                            
00000000                            ; FDxx - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL)
00000000                            sNoteTimeOut	macro val
00000000                            	dc.b $FD, \val
00000000                                endm
00000000                            
00000000                            ; FExxyy - YM command yy on register xx (YMCMD)
00000000                            sCmdYM		macro reg, val
00000000                            	dc.b $FE, \reg,\val
00000000                                endm
00000000                            
00000000                            ; FF00xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00000000                            sPlaySamp1	macro id
00000000                            	dc.b $FF,$00, \id
00000000                                endm
00000000                            
00000000                            ; FF01xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC2)
00000000                            sPlaySamp2	macro id
00000000                            	dc.b $FF,$01, \id
00000000                                endm
00000000                            
00000000                            ; FF02xxxx - Set channel frequency to xxxx (CHFREQ_SET)
00000000                            ssFreq		macro freq
00000000                            	dc.b $FF,$02
00000000                            	dc.w \freq
00000000                                endm
00000000                            
00000000                            ; FF03xx - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00000000                            ssFreqNote	macro note
00000000                            	dc.b $FF,$03, \note^$80
00000000                                endm
00000000                            
00000000                            ; FF04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00000000                            sSpinRev	macro
00000000                            	dc.b $FF,$04
00000000                                endm
00000000                            
00000000                            ; FF05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00000000                            sSpinReset	macro
00000000                            	dc.b $FF,$05
00000000                                endm
00000000                            
00000000                            ; FF06xx - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00000000                            saTempoSpeed	macro tempo
00000000                            	dc.b $FF,$06, \tempo
00000000                                endm
00000000                            
00000000                            ; FF07xx - Add xx to music tempo (TEMPO - TEMPO_ADD)
00000000                            saTempo		macro tempo
00000000                            	dc.b $FF,$07, \tempo
00000000                                endm
00000000                            
00000000                            ; FF08xyzz - Get RAM address pointer offset by y, compare zz with it using condition x (COMM_CONDITION - COMM_SPEC)
00000000                            sCondReg	macro off, cond, val
00000000                            	dc.b $FF,$08, \off|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FF09xx - Play another music/sfx (SND_CMD)
00000000                            sPlayMus	macro id
00000000                            	dc.b $FF,$09, \id
00000000                                endm
00000000                            
00000000                            ; FF0A - Enable raw frequency mode (RAW_FREQ)
00000000                            sFreqOn		macro freq
00000000                            	dc.b $FF,$0A
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00000000                            sFreqOff	macro freq
00000000                            	dc.b $FF,$0B
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0C - Enable FM3 special mode (SPC_FM3)
00000000                            sSpecFM3	macro freq
00000000                            	dc.b $FF,$0C
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0Dxx - Set DAC filter bank address (DAC_FILTER)
00000000                            ssFilter	macro bank
00000000                            	dc.b $FF,$0D, \bank
00000000                                endm
00000000                            
00000000                            ; FF0E - Freeze 68k. Debug flag (DEBUG_STOP_CPU)
00000000                            sFreeze		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0E
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; FF0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00000000                            sCheck		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0F
00000000                            	endif
00000000                                endm
00000000                            		include	"_INCLUDE_/Shared.asm"		; User includes
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User shared includes
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_INCLUDE_/Constants.asm"	; Constants
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Game mode IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  gTitle		rs.l	1				; Title screen game mode
00000000 =00000004                  gLevel		rs.l	1				; Level game mode
00000000 =00000008                  gEnd		rs.l	1				; Ending game mode
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; V-INT routine IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  vLag		rs.w	1				; Lag updates
00000000 =00000002                  vGeneral	rs.w	1				; General updates
00000000 =00000004                  vLevel		rs.w	1				; Level updates
00000000 =00000006                  vLvlLoad	rs.w	1				; Level load updates
00000000 =00000008                  vTitle		rs.w	1				; Title screen updates
00000000 =0000000A                  vFade		rs.w	1				; Fade updates
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  zWWZ		rs.b	1				; Wacky Workbench
00000000                            
00000000 =00000001                  ZONE_COUNT	equ	__rs				; Number of zones
00000000                            
00000000 =00000000                  lWWZ		equ	zWWZ<<8				; Wacky Workbench
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Music definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	MusOff
00000000 =0000000A                  mFirst		rs.b	0
00000000 =0000000A                  mSega		rs.b	1				; SEGA jingle
00000000 =0000000B                  mWWZ		rs.b	1				; Wacky Workbench music
00000000 =0000000C                  mBoss		rs.b	1				; Boss music
00000000 =0000000D                  mInvincible	rs.b	1				; Invincibility music
00000000 =0000000E                  mEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; SFX definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	SFXoff
00000000 =00000082                  sFirst		rs.b	0
00000000 =00000082                  sLeap		rs.b	1				; Jump sound
00000000 =00000083                  sSkid		rs.b	1				; Skid sound
00000000 =00000084                  sHurt		rs.b	0				; Hurt sound
00000000 =00000084                  sDeath		rs.b	1				; Death sound
00000000 =00000085                  sPush		rs.b	1				; Push sound
00000000 =00000086                  sBubble		rs.b	1				; Bubble sound
00000000 =00000087                  sDrown		rs.b	1				; Drowning sound
00000000 =00000088                  sDrownWarn	rs.b	1				; Drown warning sound
00000000 =00000089                  sDrownCount	rs.b	1				; Drown countdown sound
00000000 =0000008A                  sCheckpoint	rs.b	1				; Checkpoint sound
00000000 =0000008B                  sSpikeMove	rs.b	1				; Spike movement sound
00000000 =0000008C                  sRing		rs.b	1				; Ring sound
00000000 =0000008D                  sRingLoss	rs.b	1				; Ring loss sound
00000000 =0000008E                  sSpring		rs.b	1				; Spring sound
00000000 =0000008F                  sShield		rs.b	1				; Shield sound
00000000 =00000090                  sSplash		rs.b	1				; Water splash sound
00000000 =00000091                  sBumper		rs.b	1				; Bumper sound
00000000 =00000092                  sSwitch		rs.b	1				; Switch sound
00000000 =00000093                  sSignpost	rs.b	1				; Signpost sound
00000000 =00000094                  sCollapse	rs.b	1				; Collapse sound
00000000 =00000095                  sWallSmash	rs.b	1				; Wall smash sound
00000000 =00000096                  sRumble		rs.b	1				; Rumble sound
00000000 =00000097                  sWarp		rs.b	1				; Warp sound
00000000 =00000098                  sBossHit	rs.b	1				; Boss hit sound
00000000 =00000099                  sBomb		rs.b	1				; Bomb sound
00000000 =0000009A                  sBreakItem	rs.b	1				; Break item sound
00000000 =0000009B                  sFloorBounce	rs.b	1				; Floor bounce sound
00000000 =0000009C                  sCharge		rs.b	1				; Charge sound
00000000 =0000009D                  sChargeStop	rs.b	1				; Charge stop sound
00000000 =0000009E                  sChargeRelease	rs.b	1				; Charge release sound
00000000 =0000009F                  sDiamBreak	rs.b	1				; Diamond break sound
00000000 =000000A0                  sEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Object SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oPrevDPLC	rs.b	0				; Previous DPLC ID (only used by a few objects)
00000000 =00000000                  oAddr		rs.l	1				; Pointer to object code
00000000 =00000004                  oNext		rs.w	1				; Pointer to next object in the linked list
00000000 =00000006                  oPrev		rs.w	1				; Pointer to previous object in the linked list
00000000 =00000008                  oDrawNext	rs.w	1				; Pointer to next object to display
00000000 =0000000A                  oDrawPrev	rs.w	1				; Pointer to previous object to display
00000000 =0000000C                  oPtrsEnd	rs.b	0				; End of object structure's pointers (the following data can be safely cleared upon deletion)
00000000                            
00000000 =0000000C                  oFlags		rs.b	1				; Object flags
00000000 =0000000D                  oRender		rs.b	1				; Render flags
00000000 =0000000E                  oVRAM		rs.w	1				; Sprite tile properties
00000000 =00000010                  oFrame		rs.b	0				; Mapping frame ID (top byte of the following long)
00000000 =00000010                  oMap		rs.l	1				; Sprite mappings
00000000                            
00000000 =00000014                  oXPos		rs.l	1				; X position
00000000 =00000017                  oDrawW	=	__rs-1					; Sprite width
00000000 =00000018                  oYPos		rs.l	1				; Y position
00000000 =0000001B                  oDrawH	=	__rs-1					; Sprite height
00000000 =0000001C                  oXVel		rs.w	1				; X velocity
00000000 =0000001E                  oYVel		rs.w	1				; Y velocity
00000000                            
00000000 =00000020                  oAni		rs.b	1				; Animation ID
00000000 =00000021                  oPrevAni	rs.b	1				; Saved animation ID
00000000 =00000022                  oAniFrame	rs.b	1				; Animation script frame ID
00000000 =00000023                  oAniTimer	rs.b	1				; Animation timer
00000000                            
00000000 =00000024                  oSubtype	rs.b	1				; Subtype ID (top byte of the following long)
00000000 =00000025                  oRoutine	rs.b	1				; Routine ID
00000000 =00000026                  oRespawn	rs.w	1				; Respawn table entry pointer
00000000 =00000028                  oStatus		rs.b	1				; Status flags
00000000 =00000029                  oShield		rs.b	1				; Shield flags
00000000                            
00000000 =0000002A                  oDynSSTs	rs.b	$60-__rs			; Dynamic SSTs
00000000 =00000060                  oSize		rs.b	0				; Size of the SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Dynamic SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oDynSSTs
00000000 =0000002A                  oColType	rs.b	1				; Collision type
00000000 =0000002B                  oColStat	rs.b	1				; Collision status
00000000 =0000002B                  oHitCnt		equ	oColStat			; Boss hit count
00000000 =0000002C                  oColW		rs.b	1				; Collision width
00000000 =0000002D                  oColH		rs.b	1				; Collision height
00000000 =0000002E                  oNextTilt	rs.b	1				; Next tilt value
00000000 =0000002F                  oTilt		rs.b	1				; Tilt value
00000000 =00000030                  oLvlSSTs	rs.b	0				; Beginning of dynamic level SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sub sprite SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oSubXPos	rs.w	1				; Sub sprite X position
00000000 =00000002                  oSubYPos	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000 =00000005                  oSubFrame	rs.b	1				; Sub sprite mapping frame
00000000 =00000006                  oSubSize	rs.b	0				; Sub sprite SSTs size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oNextTilt			; Allow some reserved SSTs
00000000 =0000002E                  oSubSSTs	rs.b	0				; Start of sub sprite SSTs
00000000 =0000002E                  oSubCnt		rs.w	1				; Main sprite sub sprite count
00000000 =00000030                  oSubStart	rs.b	0				; Actual sub sprite SSTs start
00000000 =00000000                  ct		=	0
00000000                            	rept	8					; Allow 8 sub sprites per object
00000000                            oSub\$ct\X	rs.w	1				; Sub sprite X position
00000000                            oSub\$ct\Y	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000                            oSub\$ct\Frame	rs.b	1				; Sub sprite mapping frame position
00000000                            ct		=	ct+1
00000000                            	endr
00000000 =00000030                M osub0x	rs.w	1
00000000 =00000032                M osub0y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000035                M osub0frame	rs.b	1
00000000 =00000001                M ct	=	ct+1
00000000 =00000036                M osub1x	rs.w	1
00000000 =00000038                M osub1y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000003B                M osub1frame	rs.b	1
00000000 =00000002                M ct	=	ct+1
00000000 =0000003C                M osub2x	rs.w	1
00000000 =0000003E                M osub2y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000041                M osub2frame	rs.b	1
00000000 =00000003                M ct	=	ct+1
00000000 =00000042                M osub3x	rs.w	1
00000000 =00000044                M osub3y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000047                M osub3frame	rs.b	1
00000000 =00000004                M ct	=	ct+1
00000000 =00000048                M osub4x	rs.w	1
00000000 =0000004A                M osub4y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000004D                M osub4frame	rs.b	1
00000000 =00000005                M ct	=	ct+1
00000000 =0000004E                M osub5x	rs.w	1
00000000 =00000050                M osub5y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000053                M osub5frame	rs.b	1
00000000 =00000006                M ct	=	ct+1
00000000 =00000054                M osub6x	rs.w	1
00000000 =00000056                M osub6y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000059                M osub6frame	rs.b	1
00000000 =00000007                M ct	=	ct+1
00000000 =0000005A                M osub7x	rs.w	1
00000000 =0000005C                M osub7y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000005F                M osub7frame	rs.b	1
00000000 =00000008                M ct	=	ct+1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sprite drawing input list definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset oDrawPrev-6			; this awkward thing will make dPrev == oDrawPrev
00000000 =00000004                  dNext		rs.w 1					; pointer to first display object in linked list
00000000 =00000006                  dN2		rs.w 1					; must be 0
00000000 =00000008                  dN1		rs.w 1					; must be 0
00000000 =0000000A                  dPrev		rs.w 1					; pointer to last display object in linked list
00000000 =00000008                  dSize =		__rs-dNext				; size of display layer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Solid object collision bits
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000003                  cStandBit	equ	3
00000000 =00000008                  cStand		equ	1<<cStandBit
00000000                            
00000000 =00000002                  cPushDelta	equ	2
00000000                            
00000000 =00000005                  cPushBit	equ	cStandBit+cPushDelta
00000000 =00000020                  cPush		equ	1<<cPushBit
00000000                            
00000000 =00000000                  cTouchSideBit	equ	0
00000000 =00000001                  cTouchSide	equ	1<<cTouchSideBit
00000000                            
00000000 =00000002                  cTouchBtmBit	equ	cTouchSideBit+cPushDelta
00000000 =00000004                  cTouchBtm	equ	1<<cTouchBtmBit
00000000                            
00000000 =00000004                  cTouchTopBit	equ	cTouchBtmBit+cPushDelta
00000000 =00000010                  cTouchTop	equ	1<<cTouchTopBit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Macro to calculate the RAM space used by objects without going over the given max size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	size	- Max size for this object SST space
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  curobj		=	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            maxObjRAM	macro	size
00000000                            curobj_size	=	0
00000000                            		while curobj_size<(\size)
00000000                            rObj_\$curobj		rs.b	oSize
00000000                            curobj_size		=	curobj_size+oSize
00000000                            curobj			=	curobj+1
00000000                            		endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level drawing variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  cXPos		rs.l	1				; Plane X position
00000000 =00000004                  cXPrev		rs.w	1				; Plane previous X position
00000000 =00000006                  cXPrevR		rs.w	1				; Plane previous X position (rounded)
00000000 =00000008                  cYPos		rs.l	1				; Plane Y position
00000000 =0000000C                  cYPrev		rs.w	1				; Plane previous Y position
00000000 =0000000E                  cYPrevR		rs.w	1				; Plane previous Y position (rounded)
00000000 =00000010                  cRBlks		rs.b	1				; Number of blocks in the first set of tiles in a row
00000000 =00000011                  cCBlks		rs.b	1				; Number of blocks in the first set of tiles in a column
00000000 =00000012                  cVDP		rs.l	1				; VDP command
00000000 =00000016                  cLayout		rs.w	1				; Layout offset
00000000 =00000018                  cUpdate		rs.l	1				; Update routine
00000000 =0000001C                  cRedraw		rs.w	1				; Redraw flag
00000000 =0000001E                  cSize2		rs.b	0				; Variable list size
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_INCLUDE_/RAM.asm"		; RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Standard variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	RAM_START
00000000                            
00000000                            		; --- BUFFERS ---
00000000                            
00000000 =00FF0000                  rBuffer		rs.b	0				; General buffer
00000000 =00FF0000                  rChunks		rs.b	$8000				; Chunk table (uses same space as general buffer)
00000000 =00FF8000                  rBuffer_End	rs.b	0
00000000                            
00000000                            		rsset	$FF000000|(RAM_START+$8000)
00000000                            
00000000 =FFFF8000                  rKosPBuf	rs.b	$1000				; Kosinski decompression buffer
00000000                            
00000000 =FFFF9000                  rDMAQueue	rs.b	$FC				; DMA queue buffer
00000000 =FFFF90FC                  rDMASlot	rs.w	1				; DMA queue buffer slot
00000000                            
00000000 =FFFF90FE                  rHScroll	rs.b	$380				; HScroll table
00000000 =FFFF947E                  rHScroll_End	rs.b	0				; ''
00000000                            
00000000 =FFFF947E                  rVScroll	rs.b	$50				; VScroll table
00000000 =FFFF94CE                  rVScroll_End	rs.b	0				; ''
00000000 =FFFF947E                  rVScrollFG	EQU	rVScroll			; VScroll foreground value
00000000 =FFFF9480                  rVScrollBG	EQU	rVScroll+2			; VScroll background value
00000000                            
00000000 =FFFF94CE                  rSprites	rs.b	$280				; Sprite table
00000000 =FFFF974E                  rSprites_End	rs.b	0				; ''
00000000                            
00000000                            ; NTP: we won't be able to save ram like this until we switch to SWAP mappings (and we'll need per-piece limit checks on lest we overwrite the water palette)
00000000                            ;rDestWtrPal	equ	rSprites_End-$100		; Target water palette buffer
00000000                            ;rDestPal	equ	rSprites_End-$80		; Target palette buffer
00000000                            
00000000 =FFFF974E                  rDestWtrPal	rs.b	$80				; Target water palette buffer
00000000 =FFFF97CE                  rDestPal	rs.b	$80				; Target palette buffer
00000000 =FFFF984E                  rWaterPal	rs.b	$80				; Water palette buffer
00000000 =FFFF98CE                  rPalette	rs.b	$80				; Palette buffer
00000000                            
00000000 =FFFF994E                  rKosPVars	rs.b	0				; Kosinski decompression queue variables
00000000 =FFFF994E                  rKosPCnt	rs.w	1				; Kosinski decompression queue count
00000000 =FFFF9950                  rKosPRegs	rs.b	$1A				; Kosinski decompression stored registers
00000000 =FFFF996A                  rKosPSR		rs.w	1				; Kosinski decompression stored SR
00000000 =FFFF996C                  rKosPBookmark	rs.l	1				; Kosinski decompression bookmark
00000000 =FFFF9970                  rKosPList	rs.b	$20				; Kosinski decompression queue
00000000 =FFFF9970                  rKosPSrc	equ	rKosPList			; ''
00000000 =FFFF9974                  rKosPDest	equ	rKosPList+4			; ''
00000000 =FFFF9990                  rKosPList_End	rs.b	0				; ''
00000000 =FFFF9990                  rKosPMMods	rs.w	1				; Kosinski moduled decompression modules left
00000000 =FFFF9992                  rKosPMLastSz	rs.w	1				; Kosinski moduled decompression last module size
00000000 =FFFF9994                  rKosPMList	rs.b	$20*6				; Kosinski moduled decompression queue
00000000 =FFFF9994                  rKosPMSrc	equ	rKosPMList			; ''
00000000 =FFFF9998                  rKosPMDest	equ	rKosPMList+4			; ''
00000000 =FFFF9A54                  rKosPMList_End	rs.b	0				; ''
00000000 =FFFF9A54                  rKosPVars_End	rs.b	0				; End of Kosinski decompression queue variables
00000000                            
00000000 =FFFF9A54                  rObjects	rs.b	0				; Object SSTs
00000000                            		maxObjRAM $2400				; ''
00000000 =00000000                M curobj_size	=	0
00000000                          M 	while	curobj_size<($2400)
00000000 =FFFF9A54                M robj_0	rs.b	osize
00000000 =00000060                M curobj_size	=	curobj_size+osize
00000000 =00000001                M curobj	=	curobj+1
00000000 =FFFF9AB4                M robj_1	rs.b	osize
00000000 =000000C0                M curobj_size	=	curobj_size+osize
00000000 =00000002                M curobj	=	curobj+1
00000000 =FFFF9B14                M robj_2	rs.b	osize
00000000 =00000120                M curobj_size	=	curobj_size+osize
00000000 =00000003                M curobj	=	curobj+1
00000000 =FFFF9B74                M robj_3	rs.b	osize
00000000 =00000180                M curobj_size	=	curobj_size+osize
00000000 =00000004                M curobj	=	curobj+1
00000000 =FFFF9BD4                M robj_4	rs.b	osize
00000000 =000001E0                M curobj_size	=	curobj_size+osize
00000000 =00000005                M curobj	=	curobj+1
00000000 =FFFF9C34                M robj_5	rs.b	osize
00000000 =00000240                M curobj_size	=	curobj_size+osize
00000000 =00000006                M curobj	=	curobj+1
00000000 =FFFF9C94                M robj_6	rs.b	osize
00000000 =000002A0                M curobj_size	=	curobj_size+osize
00000000 =00000007                M curobj	=	curobj+1
00000000 =FFFF9CF4                M robj_7	rs.b	osize
00000000 =00000300                M curobj_size	=	curobj_size+osize
00000000 =00000008                M curobj	=	curobj+1
00000000 =FFFF9D54                M robj_8	rs.b	osize
00000000 =00000360                M curobj_size	=	curobj_size+osize
00000000 =00000009                M curobj	=	curobj+1
00000000 =FFFF9DB4                M robj_9	rs.b	osize
00000000 =000003C0                M curobj_size	=	curobj_size+osize
00000000 =0000000A                M curobj	=	curobj+1
00000000 =FFFF9E14                M robj_a	rs.b	osize
00000000 =00000420                M curobj_size	=	curobj_size+osize
00000000 =0000000B                M curobj	=	curobj+1
00000000 =FFFF9E74                M robj_b	rs.b	osize
00000000 =00000480                M curobj_size	=	curobj_size+osize
00000000 =0000000C                M curobj	=	curobj+1
00000000 =FFFF9ED4                M robj_c	rs.b	osize
00000000 =000004E0                M curobj_size	=	curobj_size+osize
00000000 =0000000D                M curobj	=	curobj+1
00000000 =FFFF9F34                M robj_d	rs.b	osize
00000000 =00000540                M curobj_size	=	curobj_size+osize
00000000 =0000000E                M curobj	=	curobj+1
00000000 =FFFF9F94                M robj_e	rs.b	osize
00000000 =000005A0                M curobj_size	=	curobj_size+osize
00000000 =0000000F                M curobj	=	curobj+1
00000000 =FFFF9FF4                M robj_f	rs.b	osize
00000000 =00000600                M curobj_size	=	curobj_size+osize
00000000 =00000010                M curobj	=	curobj+1
00000000 =FFFFA054                M robj_10	rs.b	osize
00000000 =00000660                M curobj_size	=	curobj_size+osize
00000000 =00000011                M curobj	=	curobj+1
00000000 =FFFFA0B4                M robj_11	rs.b	osize
00000000 =000006C0                M curobj_size	=	curobj_size+osize
00000000 =00000012                M curobj	=	curobj+1
00000000 =FFFFA114                M robj_12	rs.b	osize
00000000 =00000720                M curobj_size	=	curobj_size+osize
00000000 =00000013                M curobj	=	curobj+1
00000000 =FFFFA174                M robj_13	rs.b	osize
00000000 =00000780                M curobj_size	=	curobj_size+osize
00000000 =00000014                M curobj	=	curobj+1
00000000 =FFFFA1D4                M robj_14	rs.b	osize
00000000 =000007E0                M curobj_size	=	curobj_size+osize
00000000 =00000015                M curobj	=	curobj+1
00000000 =FFFFA234                M robj_15	rs.b	osize
00000000 =00000840                M curobj_size	=	curobj_size+osize
00000000 =00000016                M curobj	=	curobj+1
00000000 =FFFFA294                M robj_16	rs.b	osize
00000000 =000008A0                M curobj_size	=	curobj_size+osize
00000000 =00000017                M curobj	=	curobj+1
00000000 =FFFFA2F4                M robj_17	rs.b	osize
00000000 =00000900                M curobj_size	=	curobj_size+osize
00000000 =00000018                M curobj	=	curobj+1
00000000 =FFFFA354                M robj_18	rs.b	osize
00000000 =00000960                M curobj_size	=	curobj_size+osize
00000000 =00000019                M curobj	=	curobj+1
00000000 =FFFFA3B4                M robj_19	rs.b	osize
00000000 =000009C0                M curobj_size	=	curobj_size+osize
00000000 =0000001A                M curobj	=	curobj+1
00000000 =FFFFA414                M robj_1a	rs.b	osize
00000000 =00000A20                M curobj_size	=	curobj_size+osize
00000000 =0000001B                M curobj	=	curobj+1
00000000 =FFFFA474                M robj_1b	rs.b	osize
00000000 =00000A80                M curobj_size	=	curobj_size+osize
00000000 =0000001C                M curobj	=	curobj+1
00000000 =FFFFA4D4                M robj_1c	rs.b	osize
00000000 =00000AE0                M curobj_size	=	curobj_size+osize
00000000 =0000001D                M curobj	=	curobj+1
00000000 =FFFFA534                M robj_1d	rs.b	osize
00000000 =00000B40                M curobj_size	=	curobj_size+osize
00000000 =0000001E                M curobj	=	curobj+1
00000000 =FFFFA594                M robj_1e	rs.b	osize
00000000 =00000BA0                M curobj_size	=	curobj_size+osize
00000000 =0000001F                M curobj	=	curobj+1
00000000 =FFFFA5F4                M robj_1f	rs.b	osize
00000000 =00000C00                M curobj_size	=	curobj_size+osize
00000000 =00000020                M curobj	=	curobj+1
00000000 =FFFFA654                M robj_20	rs.b	osize
00000000 =00000C60                M curobj_size	=	curobj_size+osize
00000000 =00000021                M curobj	=	curobj+1
00000000 =FFFFA6B4                M robj_21	rs.b	osize
00000000 =00000CC0                M curobj_size	=	curobj_size+osize
00000000 =00000022                M curobj	=	curobj+1
00000000 =FFFFA714                M robj_22	rs.b	osize
00000000 =00000D20                M curobj_size	=	curobj_size+osize
00000000 =00000023                M curobj	=	curobj+1
00000000 =FFFFA774                M robj_23	rs.b	osize
00000000 =00000D80                M curobj_size	=	curobj_size+osize
00000000 =00000024                M curobj	=	curobj+1
00000000 =FFFFA7D4                M robj_24	rs.b	osize
00000000 =00000DE0                M curobj_size	=	curobj_size+osize
00000000 =00000025                M curobj	=	curobj+1
00000000 =FFFFA834                M robj_25	rs.b	osize
00000000 =00000E40                M curobj_size	=	curobj_size+osize
00000000 =00000026                M curobj	=	curobj+1
00000000 =FFFFA894                M robj_26	rs.b	osize
00000000 =00000EA0                M curobj_size	=	curobj_size+osize
00000000 =00000027                M curobj	=	curobj+1
00000000 =FFFFA8F4                M robj_27	rs.b	osize
00000000 =00000F00                M curobj_size	=	curobj_size+osize
00000000 =00000028                M curobj	=	curobj+1
00000000 =FFFFA954                M robj_28	rs.b	osize
00000000 =00000F60                M curobj_size	=	curobj_size+osize
00000000 =00000029                M curobj	=	curobj+1
00000000 =FFFFA9B4                M robj_29	rs.b	osize
00000000 =00000FC0                M curobj_size	=	curobj_size+osize
00000000 =0000002A                M curobj	=	curobj+1
00000000 =FFFFAA14                M robj_2a	rs.b	osize
00000000 =00001020                M curobj_size	=	curobj_size+osize
00000000 =0000002B                M curobj	=	curobj+1
00000000 =FFFFAA74                M robj_2b	rs.b	osize
00000000 =00001080                M curobj_size	=	curobj_size+osize
00000000 =0000002C                M curobj	=	curobj+1
00000000 =FFFFAAD4                M robj_2c	rs.b	osize
00000000 =000010E0                M curobj_size	=	curobj_size+osize
00000000 =0000002D                M curobj	=	curobj+1
00000000 =FFFFAB34                M robj_2d	rs.b	osize
00000000 =00001140                M curobj_size	=	curobj_size+osize
00000000 =0000002E                M curobj	=	curobj+1
00000000 =FFFFAB94                M robj_2e	rs.b	osize
00000000 =000011A0                M curobj_size	=	curobj_size+osize
00000000 =0000002F                M curobj	=	curobj+1
00000000 =FFFFABF4                M robj_2f	rs.b	osize
00000000 =00001200                M curobj_size	=	curobj_size+osize
00000000 =00000030                M curobj	=	curobj+1
00000000 =FFFFAC54                M robj_30	rs.b	osize
00000000 =00001260                M curobj_size	=	curobj_size+osize
00000000 =00000031                M curobj	=	curobj+1
00000000 =FFFFACB4                M robj_31	rs.b	osize
00000000 =000012C0                M curobj_size	=	curobj_size+osize
00000000 =00000032                M curobj	=	curobj+1
00000000 =FFFFAD14                M robj_32	rs.b	osize
00000000 =00001320                M curobj_size	=	curobj_size+osize
00000000 =00000033                M curobj	=	curobj+1
00000000 =FFFFAD74                M robj_33	rs.b	osize
00000000 =00001380                M curobj_size	=	curobj_size+osize
00000000 =00000034                M curobj	=	curobj+1
00000000 =FFFFADD4                M robj_34	rs.b	osize
00000000 =000013E0                M curobj_size	=	curobj_size+osize
00000000 =00000035                M curobj	=	curobj+1
00000000 =FFFFAE34                M robj_35	rs.b	osize
00000000 =00001440                M curobj_size	=	curobj_size+osize
00000000 =00000036                M curobj	=	curobj+1
00000000 =FFFFAE94                M robj_36	rs.b	osize
00000000 =000014A0                M curobj_size	=	curobj_size+osize
00000000 =00000037                M curobj	=	curobj+1
00000000 =FFFFAEF4                M robj_37	rs.b	osize
00000000 =00001500                M curobj_size	=	curobj_size+osize
00000000 =00000038                M curobj	=	curobj+1
00000000 =FFFFAF54                M robj_38	rs.b	osize
00000000 =00001560                M curobj_size	=	curobj_size+osize
00000000 =00000039                M curobj	=	curobj+1
00000000 =FFFFAFB4                M robj_39	rs.b	osize
00000000 =000015C0                M curobj_size	=	curobj_size+osize
00000000 =0000003A                M curobj	=	curobj+1
00000000 =FFFFB014                M robj_3a	rs.b	osize
00000000 =00001620                M curobj_size	=	curobj_size+osize
00000000 =0000003B                M curobj	=	curobj+1
00000000 =FFFFB074                M robj_3b	rs.b	osize
00000000 =00001680                M curobj_size	=	curobj_size+osize
00000000 =0000003C                M curobj	=	curobj+1
00000000 =FFFFB0D4                M robj_3c	rs.b	osize
00000000 =000016E0                M curobj_size	=	curobj_size+osize
00000000 =0000003D                M curobj	=	curobj+1
00000000 =FFFFB134                M robj_3d	rs.b	osize
00000000 =00001740                M curobj_size	=	curobj_size+osize
00000000 =0000003E                M curobj	=	curobj+1
00000000 =FFFFB194                M robj_3e	rs.b	osize
00000000 =000017A0                M curobj_size	=	curobj_size+osize
00000000 =0000003F                M curobj	=	curobj+1
00000000 =FFFFB1F4                M robj_3f	rs.b	osize
00000000 =00001800                M curobj_size	=	curobj_size+osize
00000000 =00000040                M curobj	=	curobj+1
00000000 =FFFFB254                M robj_40	rs.b	osize
00000000 =00001860                M curobj_size	=	curobj_size+osize
00000000 =00000041                M curobj	=	curobj+1
00000000 =FFFFB2B4                M robj_41	rs.b	osize
00000000 =000018C0                M curobj_size	=	curobj_size+osize
00000000 =00000042                M curobj	=	curobj+1
00000000 =FFFFB314                M robj_42	rs.b	osize
00000000 =00001920                M curobj_size	=	curobj_size+osize
00000000 =00000043                M curobj	=	curobj+1
00000000 =FFFFB374                M robj_43	rs.b	osize
00000000 =00001980                M curobj_size	=	curobj_size+osize
00000000 =00000044                M curobj	=	curobj+1
00000000 =FFFFB3D4                M robj_44	rs.b	osize
00000000 =000019E0                M curobj_size	=	curobj_size+osize
00000000 =00000045                M curobj	=	curobj+1
00000000 =FFFFB434                M robj_45	rs.b	osize
00000000 =00001A40                M curobj_size	=	curobj_size+osize
00000000 =00000046                M curobj	=	curobj+1
00000000 =FFFFB494                M robj_46	rs.b	osize
00000000 =00001AA0                M curobj_size	=	curobj_size+osize
00000000 =00000047                M curobj	=	curobj+1
00000000 =FFFFB4F4                M robj_47	rs.b	osize
00000000 =00001B00                M curobj_size	=	curobj_size+osize
00000000 =00000048                M curobj	=	curobj+1
00000000 =FFFFB554                M robj_48	rs.b	osize
00000000 =00001B60                M curobj_size	=	curobj_size+osize
00000000 =00000049                M curobj	=	curobj+1
00000000 =FFFFB5B4                M robj_49	rs.b	osize
00000000 =00001BC0                M curobj_size	=	curobj_size+osize
00000000 =0000004A                M curobj	=	curobj+1
00000000 =FFFFB614                M robj_4a	rs.b	osize
00000000 =00001C20                M curobj_size	=	curobj_size+osize
00000000 =0000004B                M curobj	=	curobj+1
00000000 =FFFFB674                M robj_4b	rs.b	osize
00000000 =00001C80                M curobj_size	=	curobj_size+osize
00000000 =0000004C                M curobj	=	curobj+1
00000000 =FFFFB6D4                M robj_4c	rs.b	osize
00000000 =00001CE0                M curobj_size	=	curobj_size+osize
00000000 =0000004D                M curobj	=	curobj+1
00000000 =FFFFB734                M robj_4d	rs.b	osize
00000000 =00001D40                M curobj_size	=	curobj_size+osize
00000000 =0000004E                M curobj	=	curobj+1
00000000 =FFFFB794                M robj_4e	rs.b	osize
00000000 =00001DA0                M curobj_size	=	curobj_size+osize
00000000 =0000004F                M curobj	=	curobj+1
00000000 =FFFFB7F4                M robj_4f	rs.b	osize
00000000 =00001E00                M curobj_size	=	curobj_size+osize
00000000 =00000050                M curobj	=	curobj+1
00000000 =FFFFB854                M robj_50	rs.b	osize
00000000 =00001E60                M curobj_size	=	curobj_size+osize
00000000 =00000051                M curobj	=	curobj+1
00000000 =FFFFB8B4                M robj_51	rs.b	osize
00000000 =00001EC0                M curobj_size	=	curobj_size+osize
00000000 =00000052                M curobj	=	curobj+1
00000000 =FFFFB914                M robj_52	rs.b	osize
00000000 =00001F20                M curobj_size	=	curobj_size+osize
00000000 =00000053                M curobj	=	curobj+1
00000000 =FFFFB974                M robj_53	rs.b	osize
00000000 =00001F80                M curobj_size	=	curobj_size+osize
00000000 =00000054                M curobj	=	curobj+1
00000000 =FFFFB9D4                M robj_54	rs.b	osize
00000000 =00001FE0                M curobj_size	=	curobj_size+osize
00000000 =00000055                M curobj	=	curobj+1
00000000 =FFFFBA34                M robj_55	rs.b	osize
00000000 =00002040                M curobj_size	=	curobj_size+osize
00000000 =00000056                M curobj	=	curobj+1
00000000 =FFFFBA94                M robj_56	rs.b	osize
00000000 =000020A0                M curobj_size	=	curobj_size+osize
00000000 =00000057                M curobj	=	curobj+1
00000000 =FFFFBAF4                M robj_57	rs.b	osize
00000000 =00002100                M curobj_size	=	curobj_size+osize
00000000 =00000058                M curobj	=	curobj+1
00000000 =FFFFBB54                M robj_58	rs.b	osize
00000000 =00002160                M curobj_size	=	curobj_size+osize
00000000 =00000059                M curobj	=	curobj+1
00000000 =FFFFBBB4                M robj_59	rs.b	osize
00000000 =000021C0                M curobj_size	=	curobj_size+osize
00000000 =0000005A                M curobj	=	curobj+1
00000000 =FFFFBC14                M robj_5a	rs.b	osize
00000000 =00002220                M curobj_size	=	curobj_size+osize
00000000 =0000005B                M curobj	=	curobj+1
00000000 =FFFFBC74                M robj_5b	rs.b	osize
00000000 =00002280                M curobj_size	=	curobj_size+osize
00000000 =0000005C                M curobj	=	curobj+1
00000000 =FFFFBCD4                M robj_5c	rs.b	osize
00000000 =000022E0                M curobj_size	=	curobj_size+osize
00000000 =0000005D                M curobj	=	curobj+1
00000000 =FFFFBD34                M robj_5d	rs.b	osize
00000000 =00002340                M curobj_size	=	curobj_size+osize
00000000 =0000005E                M curobj	=	curobj+1
00000000 =FFFFBD94                M robj_5e	rs.b	osize
00000000 =000023A0                M curobj_size	=	curobj_size+osize
00000000 =0000005F                M curobj	=	curobj+1
00000000 =FFFFBDF4                M robj_5f	rs.b	osize
00000000 =00002400                M curobj_size	=	curobj_size+osize
00000000 =00000060                M curobj	=	curobj+1
00000000 =FFFFBE54                  rObjects_End	rs.b	0
00000000                            
00000000 =00000060                  OBJECT_COUNT	equ	(rObjects_End-rObjects)/oSize
00000000                            
00000000 =FFFFBE54                  rTailAddr	rs.l	1				; pointer to tail object code
00000000 =FFFFBE58                  rTailNext	rs.w	1				; pointer to the first object in linked list
00000000 =FFFFBE5A                  rTailPrev	rs.w	1				; pointer to the last object in linked list
00000000 =FFFFBE5C                  rFreeHead	rs.w	1				; pointer to the first object that is not loaded
00000000                            
00000000 =FFFFBE5A                  rDispInput	equ __rs-dnext
00000000                            		rs.b	dSize*8				; Sprite display input list (8 priority levels)
00000000 =FFFFBE9E                  rDispInput_End	rs.b	0				; 
00000000                            
00000000 =FFFFBE9E                  rRespawns	rs.b	$300				; Object respawn table
00000000 =FFFFC19E                  rRespawns_End	rs.b	0				; ''
00000000                            
00000000 =FFFFC19E                  rFGRowBuf	rs.b	$102				; Foreground horizontal plane buffer
00000000 =FFFFC2A0                  rFGColBuf	rs.b	$82				; Foreground vertical plane buffer
00000000 =FFFFC322                  rBGRowBuf	rs.b	$102				; Background horizontal plane buffer
00000000 =FFFFC424                  rBGColBuf	rs.b	$82				; Background vertical plane buffer
00000000                            
00000000 =FFFFC4A6                  rAMPS		rs.b	0			; AMPS variables
00000000                            		include	"../amps/code/ram.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =FFFFC4A6                  mFlags		rs.b 1		; various driver flags, see below
00000000 =FFFFC4A7                  mCtrPal		rs.b 1		; frame counter fo 50hz fix
00000000 =FFFFC4A8                  mVctSFX		rs.l 1		; address of voice table for sfx
00000000 =FFFFC4AC                  mComm		rs.b 8		; communications bytes
00000000 =FFFFC4B4                  mMasterVolFM	rs.b 0		; master volume for FM channels
00000000 =FFFFC4B4                  mFadeAddr	rs.l 1		; fading program address
00000000 =FFFFC4B8                  mTempoMain	rs.b 1		; music normal tempo
00000000 =FFFFC4B9                  mTempoSpeed	rs.b 1		; music speed shoes tempo
00000000 =FFFFC4BA                  mTempo		rs.b 1		; current tempo we are using right now
00000000 =FFFFC4BB                  mTempoCur	rs.b 1		; tempo counter/accumulator
00000000 =FFFFC4BC                  mQueue		rs.b 3		; sound queue
00000000 =FFFFC4BF                  mMasterVolPSG	rs.b 1		; master volume for PSG channels
00000000 =FFFFC4C0                  mMasterVolDAC	rs.b 1		; master volume for DAC channels
00000000 =FFFFC4C1                  mSpindash	rs.b 1		; spindash rev counter
00000000 =FFFFC4C2                  mContCtr	rs.b 1		; continous sfx loop counter
00000000 =FFFFC4C3                  mContLast	rs.b 1		; last continous sfx played
00000000                            		rs.w 0		; align channel data
00000000                            
00000000 =FFFFC4C4                  mDAC1		rs.b cSize	; DAC 1 data
00000000 =FFFFC4F0                  mDAC2		rs.b cSize	; DAC 2 data
00000000 =FFFFC51C                  mFM1		rs.b cSize	; FM 1 data
00000000 =FFFFC548                  mFM2		rs.b cSize	; FM 2 data
00000000 =FFFFC574                  mFM3		rs.b cSize	; FM 3 data
00000000 =FFFFC5A0                  mFM4		rs.b cSize	; FM 4 data
00000000 =FFFFC5CC                  mFM5		rs.b cSize	; FM 5 data
00000000 =FFFFC5F8                  mPSG1		rs.b cSize	; PSG 1 data
00000000 =FFFFC624                  mPSG2		rs.b cSize	; PSG 2 data
00000000 =FFFFC650                  mPSG3		rs.b cSize	; PSG 3 data
00000000 =FFFFC67C                  mSFXDAC1	rs.b cSizeSFX	; SFX DAC 1 data
00000000 =FFFFC698                  mSFXFM3		rs.b cSizeSFX	; SFX FM 3 data
00000000 =FFFFC6B4                  mSFXFM4		rs.b cSizeSFX	; SFX FM 4 data
00000000 =FFFFC6D0                  mSFXFM5		rs.b cSizeSFX	; SFX FM 5 data
00000000 =FFFFC6EC                  mSFXPSG1	rs.b cSizeSFX	; SFX PSG 1 data
00000000 =FFFFC708                  mSFXPSG2	rs.b cSizeSFX	; SFX PSG 2 data
00000000 =FFFFC724                  mSFXPSG3	rs.b cSizeSFX	; SFX PSG 3 data
00000000                            
00000000                            		rsEven
00000000                          M 	rs.b	__rs&1
00000000 =FFFFC740                  mSize		rs.w 0		; end of the driver RAM
00000000                            ; ===========================================================================
00000000                            
00000000                            		; --- ENGINE VARIABLES ---
00000000                            
00000000 =FFFFC740                  rP1Data		rs.b	0				; Controller 1 data
00000000 =FFFFC740                  rP1Hold		rs.b	1				; Controller 1 held button data
00000000 =FFFFC741                  rP1Press	rs.b	1				; Controller 1 pressed button data
00000000 =FFFFC742                  rP2Data		rs.b	0				; Controller 2 data
00000000 =FFFFC742                  rP2Hold		rs.b	1				; Controller 2 held button data
00000000 =FFFFC743                  rP2Press	rs.b	1				; Controller 2 pressed button data
00000000                            
00000000 =FFFFC744                  rHWVersion	rs.b	1				; Hardware version
00000000 =FFFFC745                  rVINTFlag	rs.b	0				; V-INT flag
00000000 =FFFFC745                  rVINTRout	rs.b	1				; V-INT routine
00000000                            
00000000 =FFFFC746                  rPalFade	rs.b	0				; Palette fade properties
00000000 =FFFFC746                  rFadeStart	rs.b	1				; Palette fade start index
00000000 =FFFFC747                  rFadeLen	rs.b	1				; Palette fade size
00000000                            
00000000 =FFFFC748                  rLagCount	rs.b	1				; Lag frame counter
00000000                            
00000000 =FFFFC749                  rHIntFlag	rs.b	1				; H-INT run flag
00000000                            
00000000 =FFFFC74A                  rVIntJmp	rs.w	1				; Header will point here for V-INT
00000000 =FFFFC74C                  rVIntAddr	rs.l	1				; V-INT address
00000000 =FFFFC750                  rHIntJmp	rs.w	1				; Header will point here for H-INT
00000000 =FFFFC752                  rHIntAddr	rs.l	1				; H-INT address
00000000                            
00000000 =FFFFC756                  rFrameCnt	rs.l	1				; Frame counter
00000000                            
00000000 =FFFFC75A                  rGameMode	rs.b	1				; Game mode ID
00000000 =FFFFC75B                  rSprCount	rs.b	1				; Sprite count
00000000 =FFFFC75C                  rPauseFlag	rs.b	1				; Pause flag
00000000 =FFFFC75D                  rHIntUpdates	rs.b	1				; Level updates in H-INT flag
00000000                            
00000000 =FFFFC75E                  rHIntReg	rs.b	1				; H-INT counter register
00000000 =FFFFC75F                  rHIntCnt	rs.b	1				; H-INT counter value
00000000                            
00000000 =FFFFC760                  rRNGSeed	rs.l	1				; RNG seed
00000000                            
00000000 =FFFFC764                  rVDPReg1	rs.w	1				; VDP register 1 register ID and value
00000000 =FFFFC766                  rWindowY	rs.w	1				; Window Y position (VDP register)
00000000                            
00000000 =FFFFC768                  rMoveCheat	rs.b	1
00000000 =FFFFC769                  rArtCheat	rs.b	1
00000000                            
00000000 =FFFFC76A                  rOscNums	rs.b	0				; Oscillation numbers
00000000 =FFFFC76A                  rOscCtrl	rs.w	1				; Oscillation control
00000000 =FFFFC76C                  rOscData	rs.w	$20				; Oscialltion data
00000000 =FFFFC7AC                  rOscNums_End	rs.b	0				; ''
00000000                            
00000000                            		; --- GLOBAL VARIABLES ---
00000000                            
00000000 =FFFFC7AC                  rLevel		rs.b	0				; Level ID
00000000 =FFFFC7AC                  rZone		rs.b	1				; Zone ID
00000000 =FFFFC7AD                  rAct		rs.b	1				; Act ID
00000000                            
00000000 =FFFFC7AE                  rChkpoint	rs.b	0				; Checkpoint RAM
00000000 =FFFFC7AE                  rLastChkpoint	rs.b	1				; Last checkpoint hit
00000000                            		rs.b	1
00000000 =FFFFC7B0                  rSavedXPos	rs.w	1				; Saved player X position
00000000 =FFFFC7B2                  rSavedYPos	rs.w	1				; Saved player Y position
00000000 =FFFFC7B4                  rChkpoint_End	rs.b	0				; End of checkpoint RAM
00000000                            
00000000 =FFFFC7B4                  rObjPosAddr	rs.l	1				; Object position data pointer
00000000 =FFFFC7B8                  rObjManInit	rs.b	1				; Object manager initialized flag
00000000                            
00000000 =FFFFC7B9                  rStartFall	rs.b	1				; Start level by falling flag
00000000                            
00000000 =FFFFC7BA                  rObjLoadR	rs.l	1				; Object data address (for going right)
00000000 =FFFFC7BE                  rObjLoadL	rs.l	1				; Object data address (for going left)
00000000 =FFFFC7C2                  rObjRespL	rs.w	1				; Object respawn address (for going right)
00000000 =FFFFC7C4                  rObjRespR	rs.w	1				; Object respawn address (for going left)
00000000 =FFFFC7C6                  rObjXCoarse	rs.w	1				; Object manager's coarse X position
00000000 =FFFFC7C8                  rObjYCoarse	rs.w	1				; Object manager's coarse Y position
00000000 =FFFFC7CA                  rObjManX	rs.w	1				; Object manager's camera X position
00000000 =FFFFC7CC                  rObjManY	rs.w	1				; Object manager's camera Y position
00000000                            
00000000 =FFFFC7CE                  rPalCycTimer	rs.b	1				; Palette cycle timer
00000000 =FFFFC7CF                  rPalCycIndex	rs.b	1				; Palette cycle index
00000000                            
00000000                            		; --- LOCAL VARIABLES ---
00000000                            
00000000 =FFFFC7D0                  rGameVars	rs.b	0				; Start of local game variables
00000000                            		rs.b	((-__rs)&$FFFF)-$100		; You have the rest of RAM here for local variables
00000000 =FFFFFF00                  rGameVars_End	rs.b	0				; End of local game variables
00000000                            
00000000                            		; --- STACK SPACE ---
00000000                            
00000000 =FFFFFF00                  rStackSpace	rs.b	$100				; Stack space
00000000 =00000000                  rStackBase	rs.b	0				; ''
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Title screen variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000 =FFFFC7D0                  rBlocks		rs.b	$1800				; Block table
00000000                            
00000000 =FFFFDFD0                  rLayout		rs.b	$1000				; Level layout
00000000                            
00000000 =FFFFEFD0                  rScrlSecs	rs.b	$384				; Scroll sections
00000000 =FFFFF354                  rScrlSecs_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF354                  rColList	rs.b	$80				; Collision response list
00000000 =FFFFF3D4                  rColList_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF3D4                  rRings		rs.w	1				; Ring count
00000000                            
00000000 =FFFFF3D6                  rRingManRout	rs.b	1				; Ring manager routine
00000000 =FFFFF3D7                  rRingFrame	rs.b	1				; Ring animation frame
00000000                            
00000000 =FFFFF3D8                  rRingAniTime	rs.b	1				; Ring animation timer
00000000 =FFFFF3D9                  rRLossAniT	rs.b	1
00000000 =FFFFF3DA                  rRLossAniA	rs.w	1
00000000 =FFFFF3DC                  rRLossAniF	rs.b	1
00000000                            
00000000 =FFFFF3DD                  rBossDefeat	rs.b	1
00000000                            
00000000 =FFFFF3DE                  rRingStat	rs.b	$400				; Ring status table
00000000 =FFFFF7DE                  rRingStat_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF7DE                  rRingCol	rs.b	0				; Ring collection table
00000000 =FFFFF7DE                  rRingColCnt	rs.w	1				; Ring collection count
00000000 =FFFFF7E0                  rRingColList	rs.b	$7E				; Ring collection list
00000000 =FFFFF85E                  rRingCol_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF85E                  rRingPosAddr	rs.l	1				; Ring position data pointer
00000000 =FFFFF862                  rRingLoadL	rs.l	1				; Ring data address for the left side of the screen
00000000 =FFFFF866                  rRingLoadR	rs.l	1				; Ring data address for the right side of the screen
00000000 =FFFFF86A                  rRingStatPtr	rs.w	1				; Ring status address
00000000                            
00000000 =FFFFF86C                  rPlayer1Addr	rs.w	1				; Player 1 object address
00000000 =FFFFF86E                  rShield1Addr	rs.w	1				; Player 1 shield address
00000000 =FFFFF870                  rInvinc1Addr	rs.w	1				; Player 1 invincibility address
00000000 =FFFFF872                  rAftImg1Addr	rs.w	1				; Player 1 after image address
00000000                            
00000000 =FFFFF874                  rPlayer2Addr	rs.w	1				; Player 2 object address
00000000 =FFFFF876                  rShield2Addr	rs.w	1				; Player 2 shield address
00000000 =FFFFF878                  rInvinc2Addr	rs.w	1				; Player 2 invincibility address
00000000 =FFFFF87A                  rAftImg2Addr	rs.w	1				; Player 2 after image address
00000000                            
00000000 =FFFFF87C                  rWater1Addr	rs.w	1				; Water surface 1 address
00000000 =FFFFF87E                  rWater2Addr	rs.w	1				; Water surface 2 address
00000000                            
00000000 =FFFFF880                  rCamera		rs.b	0				; Camera RAM
00000000                            
00000000 =FFFFF880                  rFGCam		rs.b	cSize2				; Foreground variables
00000000 =FFFFF89E                  rBGCam		rs.b	cSize2				; Background variables
00000000                            
00000000 =FFFFF8BC                  rDestMaxCam	rs.b	0				; Target maximum camera positions
00000000 =FFFFF8BC                  rDestMaxX	rs.w	1				; Target maximum camera X position
00000000 =FFFFF8BE                  rDestMaxY	rs.w	1				; Target maximum camera Y position
00000000 =FFFFF8C0                  rMaxCam		rs.b	0				; Maximum camera positions
00000000 =FFFFF8C0                  rMaxCamX	rs.w	1				; Maximum camera X position
00000000 =FFFFF8C2                  rMaxCamY	rs.w	1				; Maximum camera Y position
00000000 =FFFFF8C4                  rDestMinCam	rs.b	0				; Target minimum camera positions
00000000 =FFFFF8C4                  rDestMinX	rs.w	1				; Target minimum camera X position
00000000 =FFFFF8C6                  rDestMinY	rs.w	1				; Target minimum camera Y position
00000000 =FFFFF8C8                  rMinCam		rs.b	0				; Minimum camera positions
00000000 =FFFFF8C8                  rMinCamX	rs.w	1				; Minimum camera X position
00000000 =FFFFF8CA                  rMinCamY	rs.w	1				; Minimum camera Y position
00000000 =FFFFF8CC                  rCamYPosDist	rs.w	1				; Distance from the player's Y position and the camera's
00000000 =FFFFF8CE                  rCamLocked	rs.b	0				; Camera locked flags
00000000 =FFFFF8CE                  rCamLockX	rs.b	1				; Camera locked horizontally flag
00000000 =FFFFF8CF                  rCamLockY	rs.b	1				; Camera locked vertically flag
00000000 =FFFFF8D0                  rCamMaxChg	rs.b	1				; Camera max Y position changing flag
00000000                            
00000000 =FFFFF8D1                  rCamera_End	rs.b	0				; End of camera RAM
00000000                            
00000000 =FFFFF8D1                  rDebugMode	rs.b	1				; Debug placement mode
00000000                            
00000000 =FFFFF8D2                  rCamXPosCenter	rs.w	1				; Camera X center
00000000                            
00000000 =FFFFF8D4                  rCtrl		rs.b	0				; Player control data
00000000 =FFFFF8D4                  rCtrlHold	rs.b	1				; Player control held button data
00000000 =FFFFF8D5                  rCtrlPress	rs.b	1				; Player control pressed button data
00000000                            
00000000 =FFFFF8D6                  rLevelMusic	rs.b	1				; Level music ID
00000000 =FFFFF8D7                  rBossMusic	rs.b	1				; Boss music ID
00000000                            
00000000 =FFFFF8D8                  r1stCol		rs.l	1				; Primary level collision data pointer
00000000 =FFFFF8DC                  r2ndCol		rs.l	1				; Secondary level collision data pointer
00000000                            
00000000 =FFFFF8E0                  rColAddr	rs.l	1				; Current collsion address
00000000                            
00000000 =FFFFF8E4                  rLayerPos	rs.w	1				; Fake layer position
00000000                            
00000000 =FFFFF8E6                  rAngleVals	rs.l	1				; Angle value array pointer
00000000 =FFFFF8EA                  rColArrayN	rs.l	1				; Normal height map array pointer
00000000 =FFFFF8EE                  rColArrayR	rs.l	1				; Rotated height map array pointer
00000000                            
00000000 =FFFFF8F2                  rNextLevel	rs.b	1				; Flag to go to the next level
00000000                            
00000000 =FFFFF8F3                  rUpdateRings	rs.b	1				; Update Ring counter in the HUD flag
00000000                            
00000000 =FFFFF8F4                  rWaterFlag	rs.b	1				; Water in level flag
00000000 =FFFFF8F5                  rWaterFullscr	rs.b	1				; Water fullscreen flag
00000000 =FFFFF8F6                  rWaterLvl	rs.w	1				; Water height
00000000 =FFFFF8F8                  rDestWtrLvl	rs.w	1				; Target water height
00000000                            
00000000 =FFFFF8FA                  rLvlFrames	rs.w	1				; Level frame counter
00000000 =FFFFF8FC                  rLvlReload	rs.b	1				; Level reload flag
00000000 =FFFFF8FD                  rTimeOver	rs.b	1				; Time over flag
00000000                            
00000000 =FFFFF8FE                  rDynEvRout	rs.b	1				; Dynamic event routine ID
00000000                            
00000000 =FFFFF8FF                  rFloorActive	rs.b	1				; Floor active flag
00000000 =FFFFF900                  rFloorTimer	rs.w	1				; Floor timer
00000000                            
00000000 =FFFFF902                  rAnimCnts	rs.b	$10				; Level art animation counters
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Camera variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFF880                  rCamXPos		equ	rFGCam+cXPos			; Camera X position
00000000 =FFFFF888                  rCamYPos		equ	rFGCam+cYPos			; Camera Y position
00000000 =FFFFF89E                  rCamBGXPos		equ	rBGCam+cXPos			; Background camera X position
00000000 =FFFFF8A6                  rCamBGYPos		equ	rBGCam+cYPos			; Background camera Y position
00000000 =FFFFF89C                  rFGRedraw	equ	rFGCam+cRedraw		; Foreground redraw flag
00000000 =FFFFF8BA                  rBGRedraw	equ	rBGCam+cRedraw		; Background redraw flag
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Variables for the vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFC74A                  vInterrupt	equ	rVIntJmp			; V-INT
00000000 =FFFFC750                  hInterrupt	equ	rHIntJmp			; H-INT
00000000                            ; =========================================================================================================================================================
00000000                            		include	"_INCLUDE_/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User Defined Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOn		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9193,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOff		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9100,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOff	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		andi.b	#%10111111,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOn	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		ori.b	#%01000000,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDDown	macros
00000000                            		move.l	#-$80000,rHUD_Accel.w		; Set to move HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDUp	macros
00000000                            		move.l	#$8000,rHUD_Accel.w		; Set to move HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Convert a string to the textbox's format and store as a line
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	str	- The string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLine		macro	str
00000000                            c		= 1
00000000                            		rept	strlen(\str)
00000000                            ochar			substr c, c, \str
00000000                            char			substr "\ochar"-$1F, "\ochar"-$1F, "skojh`aledisfsg\0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ABCDEFGHIJKLMNOPQRSTUVWXYZncmb"
00000000                            			dc.w	"\char"+$588
00000000                            c			= c+1
00000000                            		endr
00000000                            		dc.w	$FFFF
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a line break character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineBreak	macros
00000000                            		dc.w	$FFFF
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a message terminator character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineEnd	macros
00000000                            		dc.w	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an animation change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ani	- New animation script pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewAni	macro	ani
00000000                            		dc.w	$FFFE
00000000                            		dc.l	\ani
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an icon change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	icon	- New icon art pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewIcon	macro	icon
00000000                            		dc.w	$FFFD
00000000                            		dc.l	\icon
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a finished flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtEnd		macros
00000000                            		dc.w	$FFFC
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an entry to the level art animation script
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	duration	- Global duration
00000000                            ;	artaddr		- Source art
00000000                            ;	tileid		- Destination tile ID
00000000                            ;	numentries	- Number of entries
00000000                            ;	numvramtiles	- Number of tiles per entry
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lvlAniDat	macro	duration, artaddr, tileid, numentries, numvramtiles
00000000                            		dc.l	(\duration&$FF)<<24|\artaddr
00000000                            		dc.w	((\tileid&$7FF)<<5)
00000000                            		dc.b	\numentries, \numvramtiles
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Get a unique character set from a string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string		- String to go throuhg
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	unique_chars	- A string of unique characters found
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            getUniqueChars	macro	string
00000000                            unique_chars	substr 1,1,\string
00000000                            strpos		= 1
00000000                            
00000000                            		while strpos<strlen(\string)
00000000                            found			= 0
00000000                            pos			= 0
00000000                            char			substr strpos+1,strpos+1,\string
00000000                            
00000000                            			while (pos<strlen("\unique_chars"))&(found=0)
00000000                            uchar				substr pos+1,pos+1,"\unique_chars"
00000000                            				if strcmp("\uchar","\char")|strcmp("\char", " ")
00000000                            found					= 1
00000000                            				endif
00000000                            pos				= pos+1
00000000                            			endw
00000000                            
00000000                            			if found=0
00000000                            unique_chars			equs "\unique_chars\\char"
00000000                            			endif
00000000                            strpos			= strpos+1
00000000                            
00000000                            			endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Run objects macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            runObjects		macro
00000000                            		movea.w	rTailNext.w,a0				; load first object slot into a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jsr	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Next object macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            nextObject		macro
00000000                            		movea.w	oNext(a0),a0				; load the next object address to a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jmp	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	layer	- The destination display layer
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySprite		macro	layer, obj, fre, chk
00000000                            ;	if layer >= 8
00000000                            ;		inform 2,"Invalid display layer!"
00000000                            ;	endif
00000000                            
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            
00000000                            		move.w	#rDispInput+(\layer*dSize),oDrawNext(\obj)	; put end marker as the next pointer
00000000                            		move.w	rDispInput+dPrev+(\layer*dSize).w,\fre		; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,rDispInput+dPrev+(\layer*dSize).w		; copy the pointer from the end marker to dst register
00000000                            
00000000                            		cmp.w	#rDispInput+(\layer*dSize),rDispInput+dPrev+(\layer*dSize).w	; special case: points to itself
00000000                            		bne.s	.no\@								; if no, skip
00000000                            		move.w	\obj,rDispInput+dPrev+(\layer*dSize).w				; else, copy over
00000000                            
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list using an address register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg	- The address regsister containing target
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySpriteReg		macro	reg, obj, fre, chk
00000000                            	local layer
00000000                            layer EQUR	\reg							; convert register
00000000                            
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\reg)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            
00000000                            		move.w	layer,oDrawNext(\obj)				; put end marker as the next pointer
00000000                            		move.w	oDrawPrev(layer),\fre				; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,oDrawPrev(layer)				; copy the pointer from the end marker to dst register
00000000                            
00000000                            		cmp.w	oDrawPrev(layer),layer				; special case: points to itself
00000000                            		bne.s	.no\@						; if no, skip
00000000                            		move.w	\obj,oDrawPrev(layer)				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Remove a sprite from a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            removeSprite		macro	obj, fre, chk
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		beq.s	.yes\@						; if not, skip
00000000                            	endif
00000000                            
00000000                            		move.w	oDrawPrev(\obj),\fre				; load the prev pointer to dst
00000000                            		move.w	oDrawNext(\obj),oDrawNext(\fre)			; copy the next object pointer from src to dst
00000000                            		move.w	oDrawNext(\obj),\fre				; load the next pointer to dst
00000000                            		move.w	oDrawPrev(\obj),oDrawPrev(\fre)			; copy the prev object pointer from src to dst
00000000                            
00000000                            		cmp.w	oDrawPrev(\obj),\fre				; special case: last object
00000000                            		bne.s	.no\@						; if no, skip
00000000                            		move.w	\fre,oDrawNext(\fre)				; else, change to point to same address
00000000                            
00000000                            .no\@
00000000                            		clr.l	oDrawNext(\obj)
00000000                            .yes\@
00000000                            	endm
00000000                            ; =========================================================================================================================================================
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"_INCLUDE_/Header.asm"
00000000                            ; =========================================================================================================================================================
00000000                            ; Mighty The Armadillo in PRISM PARADISE
00000000                            ; By Nat The Porcupine 2021
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; MegaDrive Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Based on MarkeyJester's shortened header and initialization
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Store a string in memory with a character limit (also pads to that limit if it doesn't exceed it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string	- The string
00000000                            ;	limit	- Character limit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            headStr		macro	string, limit
00000000                            		local	p
00000000                            p =		*
00000000                            		dcb.b	\limit, " "
00000000                            		org	p
00000000                            		dc.b	\string
00000000                            		org	p+\limit
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		org	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 F0A1 000C                  		dc.l	($F0<<24)|PORT_C_CTRL-1		; Stack pointer (set like so for initialization routine) (also manufacture lineF exception)
00000004                            
00000004 0000 0000                  		dc.l	.PrgInit			; Entry pointer
00000008                            
00000008 0000 0000                  		dc.l	exBus				; Bus error
0000000C 0000 0000                  		dc.l	exAddr				; Address error
00000010 0000 0000                  		dc.l	exIll				; Illegal instruction error
00000014 0000 0000                  		dc.l	exDiv				; Division by zero error
00000018 0000 0000                  		dc.l	exChk				; CHK out of bounds error
0000001C 0000 0000                  		dc.l	Trapv				; TRAPV interrupt
00000020 0000 0000                  		dc.l	exPriv				; Privilege violation error
00000024 0000 0000                  		dc.l	exTrace				; TRACE interrupt
00000028 0000 0000                  		dc.l	exLineA				; Line A emulation
0000002C 0000 0000                  		dc.l	exLineF				; Line F emulation
00000030                            
00000030 0017                       .InitVals:	dc.w	$18-1				; Number of registers to set up
00000032 8004                       		dc.w	$8004				; VDP register base (preset for register 0 - H-INT disabled)
00000034 0100                       		dc.w	$100				; Register increment (also used for Z80 later)
00000036                            
00000036 34                         		dc.b	$34				; DMA enabled, V-INT enabled
00000037 30                         		dc.b	$C000/$400			; Plane A at $C000
00000038 34                         		dc.b	$D000/$400			; Plane W at $D000
00000039 07                         		dc.b	$E000/$2000			; Plane B at $E000
0000003A 7C                         		dc.b	$F800/$200			; Sprite table at $F800
0000003B 00                         		dc.b	$00				; Unused
0000003C 00                         		dc.b	$00				; BG color line 0 entry 0
0000003D 00                         		dc.b	$00				; Unused
0000003E 00                         		dc.b	$00				; Unused
0000003F FF                         		dc.b	$FF				; H-INT every 255th line
00000040 00                         		dc.b	$00				; EXT-INT off, VScroll by screen, HScroll by screen
00000041 81                         		dc.b	$81				; H40 width, interalce disabled, S/H disabled
00000042 3F                         		dc.b	$FC00/$400			; HScroll table at $FC00
00000043 00                         		dc.b	$00				; Unused
00000044 02                         		dc.b	$02				; Autoincrement by 2
00000045 01                         		dc.b	$01				; Plane size 64x32
00000046 00                         		dc.b	$00				; Disable window
00000047 00                         		dc.b	$00				; ''
00000048 FF                         		dc.b	$FF				; DMA length $FFFF
00000049 FF                         		dc.b	$FF				; ''
0000004A 00                         		dc.b	$00				; DMA source 0
0000004B 00                         		dc.b	$00				; ''
0000004C 80                         		dc.b	$80				; '' + VRAM fill mode
0000004D                            
0000004D 40                         		dc.b	$40				; Port initialization value
0000004E                            
0000004E                            		vdpCmd	dc.l,0,VRAM,DMA			; VDP DMA at $0000
0000004E 4000 0080                M 	dc.l	((((vram&dma)&3)<<30)|((0&$3fff)<<16)|(((vram&dma)&$fc)<<2)|((0&$c000)>>14))
00000052                            
00000052 000E 1FFD                  		dc.w	$E, $2000-2-1			; Checksum error color, amount of Z80 to clear
00000056 00A0 0000                  		dc.l	Z80_RAM				; Z80 RAM
0000005A 00A1 1100                  		dc.l	Z80_BUS_REQ			; Z80 bus request
0000005E 00A1 1200                  		dc.l	Z80_RESET			; Z80 reset
00000062                            
00000062                            		vdpCmd	dc.l,0,CRAM,WRITE		; CRAM WRITE at $0000
00000062 C000 0000                M 	dc.l	((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14))
00000066                            		vdpCmd	dc.l,0,VSRAM,WRITE		; VSRAM WRITE at $0000
00000066 4000 0010                M 	dc.l	((((vsram&write)&3)<<30)|((0&$3fff)<<16)|(((vsram&write)&$fc)<<2)|((0&$c000)>>14))
0000006A                            
0000006A 9FBF DFFF                  		dc.b	$9F, $BF, $DF, $FF		; PSG mute values
0000006E                            
0000006E F3C3                       		dc.b	$F3, $C3			; di and jp instructions for Z80
00000070                            
00000070 FFFF C750                  		dc.l	hInterrupt			; Horizontal interrupt
00000074 00C0 0000                  .VDPDPort:	dc.l	VDP_DATA			; Interrupt level 5
00000078 FFFF C74A                  		dc.l	vInterrupt			; Vertical interrupt
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ; Program initialization
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ICD_BLK		EQU	.PrgInit
0000007C                            .PrgInit:
0000007C                            		intsOff
0000007C 007C 0700                M 	ori	#$700,sr
00000080                            
00000080                            		; --- CHECK WARM BOOT ---
00000080                            
00000080 4A57                       		tst.w	(sp)				; Has port C been initialized already?
00000082 6600 0000                  		bne.w	.WarmBoot			; If so, branch
00000086                            
00000086 7800                       		moveq	#0,d4				; Register that holds 0
00000088 7C00                       		moveq	#0,d6				; Checksum value
0000008A                            
0000008A                            		; --- CHECK TMSS ---
0000008A                            
0000008A 162F FFF5                  		move.b	-$B(sp),d3			; Get hardware version
0000008E E903                       		asl.b	#4,d3				; ''
00000090 6700                       		beq.s	.NoTMSS				; If this is a non-TMSS system, branch
00000092 2F78 0100 3FF4             		move.l	$100.w,$3FF4(sp)		; Satisfy the TMSS
00000098                            
00000098                            .NoTMSS:
00000098                            
00000098                            		; --- SET UP VDP REGISTERS ---
00000098                            
00000098 2A78 0074                  		movea.l	.VDPDPort.w,a5			; VDP data port
0000009C 4DED 0004                  		lea	4(a5),a6			; VDP control port
000000A0                            
000000A0                            .WaitDMA:
000000A0 44D6                       		move.w	(a6),ccr			; Load status
000000A2 69FC                       		bvs.s	.WaitDMA			; If there's a DMA, wait
000000A4                            
000000A4 41F8 0030                  		lea	.InitVals.w,a0			; VDP registers
000000A8 4C98 0026                  		movem.w	(a0)+,d1/d2/d5			; Get number of entries, register base, and register increment
000000AC                            
000000AC                            .InitVDPRegs:
000000AC 3C82                       		move.w	d2,(a6)				; Set register data
000000AE D445                       		add.w	d5,d2				; Next register
000000B0 1418                       		move.b	(a0)+,d2			; Get register data
000000B2 51C9 FFF8                  		dbf	d1,.InitVDPRegs			; Loop
000000B6                            
000000B6                            		; --- CLEAR VRAM ---
000000B6                            
000000B6 2C98                       		move.l	(a0)+,(a6)			; Set DMA fill destination
000000B8 3C84                       		move.w	d4,(a6)				; Set DMA fill value
000000BA                            
000000BA                            		; --- CLEAR RAM ---
000000BA                            
000000BA 2444                       		movea.l	d4,a2				; End of RAM
000000BC 323C 3FFF                  		move.w	#(RAM_END-RAM_START)>>2-1,d1	; Longwords to clear
000000C0                            
000000C0                            .ClearRAM:
000000C0 2504                       		move.l	d4,-(a2)			; Clear RAM
000000C2 51C9 FFFC                  		dbf	d1,.ClearRAM			; Loop
000000C6                            
000000C6                            		; --- SET UP FOR Z80 ---
000000C6                            
000000C6 4CD8 1A01                  		movem.l	(a0)+,d0/a1/a3/a4		; Load Z80 addresses and values
000000CA 3685                       		move.w	d5,(a3)				; Request Z80 stop
000000CC                            
000000CC                            		; --- CLEAR CRAM AND VSRAM AND INITIALIZE JOYPADS ---
000000CC                            
000000CC 4441                       		neg.w	d1				; Run the next bit 2 times
000000CE                            
000000CE                            .InitVDPJoypads:
000000CE 2C98                       		move.l	(a0)+,(a6)			; Set VDP command
000000D0 761F                       		moveq	#$80>>2-1,d3			; Longwords to clear
000000D2                            
000000D2                            .ClearVDPMem:
000000D2 2A84                       		move.l	d4,(a5)				; Clear memory
000000D4 51CB FFFC                  		dbf	d3,.ClearVDPMem			; Loop
000000D8 3F02                       		move.w	d2,-(sp)			; Initialize port
000000DA 51C9 FFF2                  		dbf	d1,.InitVDPJoypads		; Loop
000000DE                            
000000DE 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
000000E0                            
000000E0                            		; --- MUTE PSG ---
000000E0                            
000000E0 7603                       		moveq	#4-1,d3				; Number of PSG channels
000000E2                            
000000E2                            .MutePSG:
000000E2 1D58 000D                  		move.b	(a0)+,$D(a6)			; Mute channel
000000E6 51CB FFFA                  		dbf	d3,.MutePSG			; Loop
000000EA                            
000000EA                            		; --- INITIALIZE Z80 ---
000000EA                            
000000EA 12D8                       		move.b	(a0)+,(a1)+			; Write di (disable Z80 interrupts)
000000EC 12D8                       		move.b	(a0)+,(a1)+			; Write jp (Will end up just looping forever at the beginning)
000000EE                            
000000EE                            .ClearZ80:
000000EE 12C4                       		move.b	d4,(a1)+			; Clear Z80
000000F0 51C8 FFFC                  		dbf	d0,.ClearZ80			; Loop
000000F4                            
000000F4 3884                       		move.w	d4,(a4)				; Reset the Z80
000000F6                            
000000F6                            		; --- CHECK THE CHECKSUM ---
000000F6                            
000000F6 41F8 0200                  		lea	$200.w,a0			; Start reading data at the end of the header
000000FA 2238 01A4                  		move.l	$1A4.w,d1			; Get ROM end address
000000FE                            
000000FE 6000                       		bra.s	.ChkChecksum			; Continue
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100                            ; Header
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100 5345 4741                  		dc.b	"SEGA"				; Hardware system ID
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            ; Program initialization (part 2)
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            .ChkChecksum:
00000104 DC58                       		add.w	(a0)+,d6			; Add ROM data to the checksum value
00000106 B288                       		cmp.l	a0,d1				; Are we at the end of the ROM?
00000108 64FA                       		bcc.s	.ChkChecksum			; If not, keep adding
0000010A BC78 018E                  		cmp.w	$18E.w,d6			; Is the checksum correct?
0000010E 6700                       		beq.s	.ChksumPassed			; If not, branch
00000110                            
00000110                            .ChksumError:
00000110                            		vdpCmd	move.l,0,CRAM,WRITE,(a6)	; Set background to red
00000110 2CBC C000 0000           M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),(a6)
00000116 2A80                       		move.l	d0,(a5)				; ''
00000118 60F6                       		bra.s	.ChksumError			; Loop here forever
0000011A                            
0000011A                            .ChksumPassed:
0000011A 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
0000011C 3684                       		move.w	d4,(a3)				; Start the Z80
0000011E                            
0000011E                            		; --- FINISH I/O INITIALIZATION ---
0000011E                            
0000011E 3F42 0004                  		move.w	d2,4(sp)			; Initialize port C
00000122                            
00000122                            .WarmBoot:
00000122 4FF8 0000                  		lea	rStackBase.w,sp		; Set the stack pointer
00000126 4CD4 7FFF                  		movem.l	(a4),d0-a6			; Clear registers
0000012A                            
0000012A 4EF9 0000 0000             		jmp	GameInit			; Go to the game initialization
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            ; Header (part 2)
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            		headStr	"\NOTES", $20			; Notes
00000130                          M 	local	p
00000130 =00000130                M p	=	*
00000130 2020 2020 2020 2020 2020+M 	dcb.b	$20," "
00000150                          M 	org	p
00000130                          M 	dc.b	""
00000130                          M 	org	p+$20
00000150                            		headStr	"\GAME_NAME", $30		; International game name
00000150                          M 	local	p
00000150 =00000150                M p	=	*
00000150 2020 2020 2020 2020 2020+M 	dcb.b	$30," "
00000180                          M 	org	p
00000150 4D69 6768 7479 2054 6865+M 	dc.b	"Mighty The Armadillo in -|=| PRISM PARADISE |=|-"
00000180                          M 	org	p+$30
00000180 474D 2030 3030 3030 3030+  		dc.b	"GM 00000000-00"		; Version
0000018E 0000                       		dc.w	0				; Checksum value (replaced by external program)
00000190                            		headStr	"\IO_SUPPORT", $10		; I/O support
00000190                          M 	local	p
00000190 =00000190                M p	=	*
00000190 2020 2020 2020 2020 2020+M 	dcb.b	$10," "
000001A0                          M 	org	p
00000190 4A                       M 	dc.b	"J"
00000191                          M 	org	p+$10
000001A0 0000 0000 003F FFFF        		dc.l	ROM_START, ROM_END-1		; ROM start and end addresses (replaced by external program)
000001A8 00FF 0000 00FF FFFF        		dc.l	RAM_START, RAM_END-1		; RAM start and end addresses
000001B0 2020 2020                  		dc.l	SRAM_SUPPORT			; SRAM support
000001B4 2020 2020 2020 2020        		dc.l	SRAM_START, SRAM_END		; SRAM start and end addresses
000001BC                            ; =========================================================================================================================================================
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Function libraries
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            		include	"_LIB_/VDP.asm"			; VDP functions
000001BC                            ; =========================================================================================================================================================
000001BC                            ; Mighty The Armadillo in PRISM PARADISE
000001BC                            ; By Nat The Porcupine 2021
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; VDP functions
000001BC                            ; =========================================================================================================================================================
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Initialize the VDP
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; PARAMETERS:
000001BC                            ;	Nothing
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; RETURNS:
000001BC                            ;	Nothing
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            InitVDP:
000001BC 31FC 8134 C764             		move.w	#$8134,rVDPReg1.w		; Save VDP register 1 in RAM
000001C2 31FC 8AFF C75E             		move.w	#$8AFF,rHIntReg.w		; Save H-INT counter register in RAM
000001C8                            
000001C8 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ; Clear the screen and other VDP data (64 tile width)
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ; PARAMETERS:
000001CC                            ;	Nothing
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ; RETURNS:
000001CC                            ;	Nothing
000001CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001CC                            ClearScreen:
000001CC 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
000001D2                            		dmaFill	0,$C000,$3000			; Clear planes
000001D2 3CBC 8F01                M 	move.w	#$8f01,(a6)
000001D6 2CBC 942F 93FF           M 	move.l	#$94009300|(((($3000)-1)&$ff00)<<8)|((($3000)-1)&$ff),(a6)
000001DC 3CBC 9780                M 	move.w	#$9780,(a6)
000001E0 2CBC 4000 0083           M 	move.l	#$40000080|((($c000)&$3fff)<<16)|((($c000)&$c000)>>14),(a6)
000001E6 3D7C 0000 FFFC           M 	move.w	#(0)<<8,-4(a6)
000001EC                          M 	waitdma	(a6)
000001EC                          M .wait_22:
000001EC 3216                     M 	move.w	(a6),d1
000001EE 0801 0001                M 	btst	#1,d1
000001F2 66F8                     M 	bne.s	.wait_22
000001F4 3CBC 8F02                M 	move.w	#$8f02,(a6)
000001F8                            
000001F8                            		clrRAM	rHScroll, rVScroll_End	; Clear scroll tables
000001F8                          M 	local	endaddr
000001F8                          M endaddr	equs	"rvscroll_end"
000001F8 7000                     M 	moveq	#0,d0
000001FA 43F8 90FE                M 	lea	(rhscroll).w,a1
000001FE 323C 00F3                M 	move.w	#(((rvscroll_end)-(rhscroll))-((rhscroll)&1))>>2-1,d1
00000202 22C0                     M .clear_23:	move.l	d0,(a1)+
00000204 51C9 FFFC                M 	dbf	d1,.clear_23
00000208                            		
00000208 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            ; Load a plane map
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            ; PARAMETERS:
0000020C                            ;	d0.l	- VDP command for writing the data to VRAM
0000020C                            ;	d1.w	- Width in tiles (minus 1)
0000020C                            ;	d2.w	- Height in tiles (minus 1)
0000020C                            ;	d3.w	- Base tile properties for each tile
0000020C                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
0000020C                            ;	a1.l	- Plane map address
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            ; RETURNS:
0000020C                            ;	Nothing
0000020C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000020C                            LoadPlaneMap:
0000020C                            LoadPlaneMap_H64:
0000020C 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
00000212 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000214                            
00000214                            LoadPlaneMap_H32:
00000214 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
0000021A 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
0000021C                            
0000021C                            LoadPlaneMap_H128:
0000021C 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
00000222                            
00000222                            LoadPlaneMap_Custom:
00000222                            .RowLoop:
00000222 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
00000228 3801                       		move.w	d1,d4				; Store width
0000022A                            
0000022A                            .TileLoop:
0000022A 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
0000022C DA43                       		add.w	d3,d5				; Add base tile properties
0000022E 33C5 00C0 0000             		move.w	d5,VDP_DATA			; Save in VRAM
00000234 51CC FFF4                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
00000238 D086                       		add.l	d6,d0				; Next row
0000023A 51CA FFE6                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
0000023E 4E75                       		rts
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            ; Load a plane map into RAM
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            ; PARAMETERS:
00000240                            ;	d1.w	- Width in tiles (minus 1)
00000240                            ;	d2.w	- Height in tiles (minus 1)
00000240                            ;	d3.w	- Base tile properties for each tile
00000240                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
00000240                            ;	a0.l	- Buffer to load into
00000240                            ;	a1.l	- Plane map address
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            ; RETURNS:
00000240                            ;	Nothing
00000240                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000240                            LoadPlaneMap_RAM:
00000240                            .RowLoop:
00000240 2448                       		movea.l	a0,a2				; Copy buffer address
00000242 3801                       		move.w	d1,d4				; Store width
00000244                            
00000244                            .TileLoop:
00000244 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
00000246 DA43                       		add.w	d3,d5				; Add base tile properties
00000248 34C5                       		move.w	d5,(a2)+			; Save in RAM
0000024A 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
0000024E D0FC 0080                  		adda.w	#$80,a0				; Next row
00000252 51CA FFEC                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000256 4E75                       		rts
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            ; Fill the plane map with a value in a specific region
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            ; PARAMETERS:
00000258                            ;	d0.l	- VDP command for writing the data to VRAM
00000258                            ;	d1.w	- Width in tiles (minus 1)
00000258                            ;	d2.w	- Height in tiles (minus 1)
00000258                            ;	d3.w	- Value to fill plane map with
00000258                            ;	d6.l	- Delta value for drawing to the next row
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            ; RETURNS:
00000258                            ;	Nothing
00000258                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000258                            FillPlaneMap:
00000258                            FillPlaneMap_H64:
00000258 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
0000025E 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
00000260                            
00000260                            FillPlaneMap_H32:
00000260 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
00000266 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
00000268                            
00000268                            FillPlaneMap_H128:
00000268 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
0000026E                            
0000026E                            FillPlaneMap_Custom:
0000026E                            .RowLoop:
0000026E 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
00000274 3801                       		move.w	d1,d4				; Store width
00000276                            
00000276                            .TileLoop:
00000276 33C3 00C0 0000             		move.w	d3,VDP_DATA			; Save value in VRAM
0000027C 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
00000280 D086                       		add.l	d6,d0				; Next row
00000282 51CA FFEA                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000286 4E75                       		rts
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Queue a VDP DMA command to VRAM, to be issued the next time ProcessDMAQueue is called. Can be called a maximum of 18 times before the queue needs
00000288                            ; to be cleared by issuing the commands (this checks for overflow)
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; PARAMETERS:
00000288                            ; 	d1.l	- Source address
00000288                            ; 	d2.w	- Destination address
00000288                            ; 	d3.w	- Transfer length
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; RETURNS:
00000288                            ;	Nothing
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is disabled by default because you can simply align the art in ROM
00000288                            ; and avoid the issue altogether. It is here so that you have a high-performance routine to do the job in situations where you can't align it in ROM.
00000288 =00000001                  Use128kbSafeDMA		= 1
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Option to mask interrupts while updating the DMA queue. This fixes many race conditions in the DMA funcion, but it costs 46(6/1) cycles. The
00000288                            ; better way to handle these race conditions would be to make unsafe callers (such as S3&K's KosM decoder) prevent these by masking off interrupts
00000288                            ; before calling and then restore interrupts after.
00000288 =00000000                  UseVIntSafeDMA		= 0
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Option to assume that transfer length is always less than $7FFF. Only makes sense if Use128kbSafeDMA is 1. Moreover, setting this to 1 will
00000288                            ; cause trouble on a 64kB DMA, so make sure you never do one if you set it to 1! Enabling this saves 4(1/0) cycles on the case where a DMA is
00000288                            ; broken in two and both transfers are properly queued, and nothing at all otherwise.
00000288 =00000000                  AssumeMax7FFFXfer	= 0&Use128kbSafeDMA
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Convenience macros, for increased maintainability of the code.
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Like vdpComm, but starting from an address contained in a register
00000288 =00000001                  vdpCommReg_defined = 1
00000288                            vdpCommReg	macro	reg, type, rwd, clr
00000288                            		local	cd
00000288                            cd		= \type&\rwd
00000288                            		lsl.l	#2,\reg				; Move high bits into (word-swapped) position, accidentally moving everything else
00000288                            		if ((cd)&3)<>0
00000288                            			addq.w	#((cd)&3),\reg		; Add upper access type bits
00000288                            		endif
00000288                            		ror.w	#2,\reg				; Put upper access type bits into place, also moving all other bits into their correct
00000288                            							; (word-swapped) places
00000288                            		swap	\reg				; Put all bits in proper places
00000288                            		if \clr<>0
00000288                            			andi.w	#3,\reg			; Strip whatever junk was in upper word of reg
00000288                            		endif
00000288                            		if ((cd)&$FC)=$20
00000288                            			tas.b	\reg			; Add in the DMA flag -- tas fails on memory, but works on registers
00000288                            		elseif ((cd)&$FC)<>0
00000288                            			ori.w	#(((cd)&$FC)*4),\reg	; Add in missing access type bits
00000288                            		endif
00000288                            		endm
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            QueueDMATransfer:
00000288                            
00000288 3278 90FC                  		movea.w	rDMASlot.w,a1
0000028C B2FC 90FC                  		cmpa.w	#rDMASlot,a1
00000290 6700                       		beq.s	.Done				; Return if there's no more room in the queue
00000292                            
00000292 E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00000294                            
00000294 3003                       			move.w  d3,d0			; d0 = length of transfer in words
00000296                            			; Compute position of last transferred word. This handles 2 cases:
00000296                            			; (1) zero length DMAs transfer length actually transfer $10000 words
00000296                            			; (2) (source+length)&$FFFF = 0
00000296 5340                       			subq.w  #1,d0
00000298 D041                       			add.w   d1,d0			; d0 = ((src_address >> 1) & $FFFF) + ((xferlen >> 1) - 1)
0000029A 6500                       			bcs.s   .DoubleTransfer		; Carry set = ($10000 << 1) = $20000, or new 128kB block
0000029C                            
0000029C                            		; Store VDP commands for specifying DMA into the queue
0000029C 4841                       		swap	d1				; Want the high byte first
0000029E 303C 977F                  		move.w	#$977F,d0			; Command to specify source address & $FE0000, plus bitmask for the given byte
000002A2 C001                       		and.b	d1,d0				; Mask in source address & $FE0000, stripping high bit in the process
000002A4 32C0                       		move.w	d0,(a1)+			; Store command
000002A6 3203                       		move.w	d3,d1				; Put length together with (source address & $01FFFE) >> 1...
000002A8 03C9 0001                  		movep.l	d1,1(a1)			; ... and stuff them all into RAM in their proper places (movep for the win)
000002AC 43E9 0008                  		lea	8(a1),a1			; Skip past all of these commands
000002B0                            
000002B0                            		vdpCommReg d2,VRAM,DMA,1		; Make DMA destination command
000002B0                          M 	local	cd
000002B0 =00000021                M cd	=	vram&dma
000002B0 E58A                     M 	lsl.l	#2,d2
000002B2 5242                     M 	addq.w	#((cd)&3),d2
000002B4 E45A                     M 	ror.w	#2,d2
000002B6 4842                     M 	swap	d2
000002B8 0242 0003                M 	andi.w	#3,d2
000002BC 4AC2                     M 	tas.b	d2
000002BE 22C2                       		move.l	d2,(a1)+			; Store command
000002C0                            
000002C0 4251                       		clr.w	(a1)				; Put a stop token at the end of the used part of the queue
000002C2 31C9 90FC                  		move.w	a1,rDMASlot.w			; Set the next free slot address, potentially undoing the above clr (this is intentional!)
000002C6                            
000002C6                            .Done:
000002C6 4E75                       		rts
000002C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002C8                            .DoubleTransfer:
000002C8                            			; Hand-coded version to break the DMA transfer into two smaller transfers
000002C8                            			; that do not cross a 128kB boundary. This is done much faster (at the cost
000002C8                            			; of space) than by the method of saving parameters and calling the normal
000002C8                            			; DMA function twice, as Sonic3_Complete does.
000002C8                            			; d0 is the number of words-1 that got over the end of the 128kB boundary
000002C8 5240                       			addq.w	#1,d0			; Make d0 the number of words past the 128kB boundary
000002CA 9640                       			sub.w	d0,d3			; First transfer will use only up to the end of the 128kB boundary
000002CC                            
000002CC                            			; Store VDP commands for specifying DMA into the queue
000002CC 4841                       			swap	d1			; Want the high byte first
000002CE                            
000002CE                            			; Sadly, all registers we can spare are in use right now, so we can't use
000002CE                            			; no-cost RAM source safety.
000002CE 0241 007F                  			andi.w	#$7F,d1			; Strip high bit
000002D2 0041 9700                  			ori.w	#$9700,d1		; Command to specify source address & $FE0000
000002D6 32C1                       			move.w	d1,(a1)+		; Store command
000002D8 5201                       			addq.b	#1,d1			; Advance to next 128kB boundary (**)
000002DA 3341 000C                  			move.w	d1,12(a1)		; Store it now (safe to do in all cases, as we will overwrite later if queue got filled) (**)
000002DE 3203                       			move.w	d3,d1			; Put length together with (source address & $01FFFE) >> 1...
000002E0 03C9 0001                  			movep.l	d1,1(a1)		; ... and stuff them all into RAM in their proper places (movep for the win)
000002E4 43E9 0008                  			lea	8(a1),a1		; Skip past all of these commands
000002E8                            
000002E8 3602                       			move.w	d2,d3			; Save for later
000002EA                            			vdpCommReg d2,VRAM,DMA,1	; Make DMA destination command
000002EA                          M 	local	cd
000002EA =00000021                M cd	=	vram&dma
000002EA E58A                     M 	lsl.l	#2,d2
000002EC 5242                     M 	addq.w	#((cd)&3),d2
000002EE E45A                     M 	ror.w	#2,d2
000002F0 4842                     M 	swap	d2
000002F2 0242 0003                M 	andi.w	#3,d2
000002F6 4AC2                     M 	tas.b	d2
000002F8 22C2                       			move.l	d2,(a1)+		; Store command
000002FA                            
000002FA B2FC 90FC                  			cmpa.w	#rDMASlot,a1		; Did this command fill the queue?
000002FE 6700                       			beq.s	.SkipSecondTransfer	; Branch if so
00000300                            
00000300                            			; Store VDP commands for specifying DMA into the queue
00000300                            			; The source address high byte was done above already in the comments marked
00000300                            			; with (**)
00000300 7400                       				moveq	#0,d2		; Need a zero for a 128kB block start
00000302 3400                       				move.w	d0,d2		; Copy number of words on this new block...
00000304 05C9 0003                  				movep.l	d2,3(a1)	; ... and stuff it all into RAM at the proper places (movep for the win)
00000308 43E9 000A                  			lea	10(a1),a1		; Skip past all of these commands
0000030C                            
0000030C                            			; d1 contains length up to the end of the 128kB boundary
0000030C D241                       			add.w	d1,d1			; Convert it into byte length...
0000030E D243                       			add.w	d3,d1			; ... and offset destination by the correct amount
00000310                            			vdpCommReg d1,VRAM,DMA,1	; Make DMA destination command
00000310                          M 	local	cd
00000310 =00000021                M cd	=	vram&dma
00000310 E589                     M 	lsl.l	#2,d1
00000312 5241                     M 	addq.w	#((cd)&3),d1
00000314 E459                     M 	ror.w	#2,d1
00000316 4841                     M 	swap	d1
00000318 0241 0003                M 	andi.w	#3,d1
0000031C 4AC1                     M 	tas.b	d1
0000031E 22C1                       			move.l	d1,(a1)+		; Store command
00000320                            
00000320 4251                       			clr.w	(a1)			; Put a stop token at the end of the used part of the queue
00000322 31C9 90FC                  			move.w	a1,rDMASlot.w		; Set the next free slot address, potentially undoing the above clr (this is intentional!)
00000326                            
00000326 4E75                       			rts
00000328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000328                            .SkipSecondTransfer:
00000328 3289                       			move.w	a1,(a1)			; Set the next free slot address, overwriting what the second (**) instruction did
0000032A                            	
0000032A 4E75                       			rts
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ; Issue all the queued VDP DMA commands from QueueDMATransfer, resets the queue when it's done
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ; PARAMETERS:
0000032C                            ;	a6.l	- VDP control port
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ; RETURNS:
0000032C                            ;	Nothing
0000032C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000032C                            ProcessDMAQueue:
0000032C 43F8 9000                  		lea	rDMAQueue.w,a1
00000330 31C9 90FC                  		move.w	a1,rDMASlot.w
00000334                            
00000334                            		rept (rDMASlot-rDMAQueue)/(7*2)
00000334                            			move.w	(a1)+,d0
00000334                            			beq.w	.Done			; Branch if we reached a stop token
00000334                            			
00000334                            			move.w	d0,(a6)			; Issue a set of VDP commands...
00000334                            			move.l	(a1)+,(a6)
00000334                            			move.l	(a1)+,(a6)
00000334                            			move.w	(a1)+,(a6)
00000334                            			move.w	(a1)+,(a6)
00000334                            		endr
00000334 3019                     M 	move.w	(a1)+,d0
00000336 6700 0000                M 	beq.w	.done
0000033A 3C80                     M 	move.w	d0,(a6)
0000033C 2C99                     M 	move.l	(a1)+,(a6)
0000033E 2C99                     M 	move.l	(a1)+,(a6)
00000340 3C99                     M 	move.w	(a1)+,(a6)
00000342 3C99                     M 	move.w	(a1)+,(a6)
00000344 3019                     M 	move.w	(a1)+,d0
00000346 6700 0000                M 	beq.w	.done
0000034A 3C80                     M 	move.w	d0,(a6)
0000034C 2C99                     M 	move.l	(a1)+,(a6)
0000034E 2C99                     M 	move.l	(a1)+,(a6)
00000350 3C99                     M 	move.w	(a1)+,(a6)
00000352 3C99                     M 	move.w	(a1)+,(a6)
00000354 3019                     M 	move.w	(a1)+,d0
00000356 6700 0000                M 	beq.w	.done
0000035A 3C80                     M 	move.w	d0,(a6)
0000035C 2C99                     M 	move.l	(a1)+,(a6)
0000035E 2C99                     M 	move.l	(a1)+,(a6)
00000360 3C99                     M 	move.w	(a1)+,(a6)
00000362 3C99                     M 	move.w	(a1)+,(a6)
00000364 3019                     M 	move.w	(a1)+,d0
00000366 6700 0000                M 	beq.w	.done
0000036A 3C80                     M 	move.w	d0,(a6)
0000036C 2C99                     M 	move.l	(a1)+,(a6)
0000036E 2C99                     M 	move.l	(a1)+,(a6)
00000370 3C99                     M 	move.w	(a1)+,(a6)
00000372 3C99                     M 	move.w	(a1)+,(a6)
00000374 3019                     M 	move.w	(a1)+,d0
00000376 6700 0000                M 	beq.w	.done
0000037A 3C80                     M 	move.w	d0,(a6)
0000037C 2C99                     M 	move.l	(a1)+,(a6)
0000037E 2C99                     M 	move.l	(a1)+,(a6)
00000380 3C99                     M 	move.w	(a1)+,(a6)
00000382 3C99                     M 	move.w	(a1)+,(a6)
00000384 3019                     M 	move.w	(a1)+,d0
00000386 6700 0000                M 	beq.w	.done
0000038A 3C80                     M 	move.w	d0,(a6)
0000038C 2C99                     M 	move.l	(a1)+,(a6)
0000038E 2C99                     M 	move.l	(a1)+,(a6)
00000390 3C99                     M 	move.w	(a1)+,(a6)
00000392 3C99                     M 	move.w	(a1)+,(a6)
00000394 3019                     M 	move.w	(a1)+,d0
00000396 6700 0000                M 	beq.w	.done
0000039A 3C80                     M 	move.w	d0,(a6)
0000039C 2C99                     M 	move.l	(a1)+,(a6)
0000039E 2C99                     M 	move.l	(a1)+,(a6)
000003A0 3C99                     M 	move.w	(a1)+,(a6)
000003A2 3C99                     M 	move.w	(a1)+,(a6)
000003A4 3019                     M 	move.w	(a1)+,d0
000003A6 6700 0000                M 	beq.w	.done
000003AA 3C80                     M 	move.w	d0,(a6)
000003AC 2C99                     M 	move.l	(a1)+,(a6)
000003AE 2C99                     M 	move.l	(a1)+,(a6)
000003B0 3C99                     M 	move.w	(a1)+,(a6)
000003B2 3C99                     M 	move.w	(a1)+,(a6)
000003B4 3019                     M 	move.w	(a1)+,d0
000003B6 6700 0000                M 	beq.w	.done
000003BA 3C80                     M 	move.w	d0,(a6)
000003BC 2C99                     M 	move.l	(a1)+,(a6)
000003BE 2C99                     M 	move.l	(a1)+,(a6)
000003C0 3C99                     M 	move.w	(a1)+,(a6)
000003C2 3C99                     M 	move.w	(a1)+,(a6)
000003C4 3019                     M 	move.w	(a1)+,d0
000003C6 6700 0000                M 	beq.w	.done
000003CA 3C80                     M 	move.w	d0,(a6)
000003CC 2C99                     M 	move.l	(a1)+,(a6)
000003CE 2C99                     M 	move.l	(a1)+,(a6)
000003D0 3C99                     M 	move.w	(a1)+,(a6)
000003D2 3C99                     M 	move.w	(a1)+,(a6)
000003D4 3019                     M 	move.w	(a1)+,d0
000003D6 6700 0000                M 	beq.w	.done
000003DA 3C80                     M 	move.w	d0,(a6)
000003DC 2C99                     M 	move.l	(a1)+,(a6)
000003DE 2C99                     M 	move.l	(a1)+,(a6)
000003E0 3C99                     M 	move.w	(a1)+,(a6)
000003E2 3C99                     M 	move.w	(a1)+,(a6)
000003E4 3019                     M 	move.w	(a1)+,d0
000003E6 6700 0000                M 	beq.w	.done
000003EA 3C80                     M 	move.w	d0,(a6)
000003EC 2C99                     M 	move.l	(a1)+,(a6)
000003EE 2C99                     M 	move.l	(a1)+,(a6)
000003F0 3C99                     M 	move.w	(a1)+,(a6)
000003F2 3C99                     M 	move.w	(a1)+,(a6)
000003F4 3019                     M 	move.w	(a1)+,d0
000003F6 6700 0000                M 	beq.w	.done
000003FA 3C80                     M 	move.w	d0,(a6)
000003FC 2C99                     M 	move.l	(a1)+,(a6)
000003FE 2C99                     M 	move.l	(a1)+,(a6)
00000400 3C99                     M 	move.w	(a1)+,(a6)
00000402 3C99                     M 	move.w	(a1)+,(a6)
00000404 3019                     M 	move.w	(a1)+,d0
00000406 6700 0000                M 	beq.w	.done
0000040A 3C80                     M 	move.w	d0,(a6)
0000040C 2C99                     M 	move.l	(a1)+,(a6)
0000040E 2C99                     M 	move.l	(a1)+,(a6)
00000410 3C99                     M 	move.w	(a1)+,(a6)
00000412 3C99                     M 	move.w	(a1)+,(a6)
00000414 3019                     M 	move.w	(a1)+,d0
00000416 6700 0000                M 	beq.w	.done
0000041A 3C80                     M 	move.w	d0,(a6)
0000041C 2C99                     M 	move.l	(a1)+,(a6)
0000041E 2C99                     M 	move.l	(a1)+,(a6)
00000420 3C99                     M 	move.w	(a1)+,(a6)
00000422 3C99                     M 	move.w	(a1)+,(a6)
00000424 3019                     M 	move.w	(a1)+,d0
00000426 6700 0000                M 	beq.w	.done
0000042A 3C80                     M 	move.w	d0,(a6)
0000042C 2C99                     M 	move.l	(a1)+,(a6)
0000042E 2C99                     M 	move.l	(a1)+,(a6)
00000430 3C99                     M 	move.w	(a1)+,(a6)
00000432 3C99                     M 	move.w	(a1)+,(a6)
00000434 3019                     M 	move.w	(a1)+,d0
00000436 6700 0000                M 	beq.w	.done
0000043A 3C80                     M 	move.w	d0,(a6)
0000043C 2C99                     M 	move.l	(a1)+,(a6)
0000043E 2C99                     M 	move.l	(a1)+,(a6)
00000440 3C99                     M 	move.w	(a1)+,(a6)
00000442 3C99                     M 	move.w	(a1)+,(a6)
00000444 3019                     M 	move.w	(a1)+,d0
00000446 6700 0000                M 	beq.w	.done
0000044A 3C80                     M 	move.w	d0,(a6)
0000044C 2C99                     M 	move.l	(a1)+,(a6)
0000044E 2C99                     M 	move.l	(a1)+,(a6)
00000450 3C99                     M 	move.w	(a1)+,(a6)
00000452 3C99                     M 	move.w	(a1)+,(a6)
00000454 7000                       		moveq	#0,d0
00000456                            
00000456                            .Done:
00000456 31C0 9000                  		move.w	d0,rDMAQueue.w
0000045A 4E75                       		rts
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            ; Initialize the DMA queue
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            ; PARAMETERS:
0000045C                            ;	Nothing
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            ; RETURNS:
0000045C                            ;	Nothing
0000045C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000045C                            InitDMAQueue:
0000045C 43F8 9000                  		lea	rDMAQueue.w,a1
00000460 32BC 0000                  		move.w	#0,(a1)
00000464 31C9 90FC                  		move.w	a1,rDMASlot.w
00000468 223C 9695 9493             		move.l	#$96959493,d1
0000046E =00000000                  c		= 0
0000046E                            		rept (rDMASlot-rDMAQueue)/(7*2)
0000046E                            			movep.l	d1,2+c(a1)
0000046E                            c			= c+14
0000046E                            		endr
0000046E 03C9 0002                M 	movep.l	d1,2+c(a1)
00000472 =0000000E                M c	=	c+14
00000472 03C9 0010                M 	movep.l	d1,2+c(a1)
00000476 =0000001C                M c	=	c+14
00000476 03C9 001E                M 	movep.l	d1,2+c(a1)
0000047A =0000002A                M c	=	c+14
0000047A 03C9 002C                M 	movep.l	d1,2+c(a1)
0000047E =00000038                M c	=	c+14
0000047E 03C9 003A                M 	movep.l	d1,2+c(a1)
00000482 =00000046                M c	=	c+14
00000482 03C9 0048                M 	movep.l	d1,2+c(a1)
00000486 =00000054                M c	=	c+14
00000486 03C9 0056                M 	movep.l	d1,2+c(a1)
0000048A =00000062                M c	=	c+14
0000048A 03C9 0064                M 	movep.l	d1,2+c(a1)
0000048E =00000070                M c	=	c+14
0000048E 03C9 0072                M 	movep.l	d1,2+c(a1)
00000492 =0000007E                M c	=	c+14
00000492 03C9 0080                M 	movep.l	d1,2+c(a1)
00000496 =0000008C                M c	=	c+14
00000496 03C9 008E                M 	movep.l	d1,2+c(a1)
0000049A =0000009A                M c	=	c+14
0000049A 03C9 009C                M 	movep.l	d1,2+c(a1)
0000049E =000000A8                M c	=	c+14
0000049E 03C9 00AA                M 	movep.l	d1,2+c(a1)
000004A2 =000000B6                M c	=	c+14
000004A2 03C9 00B8                M 	movep.l	d1,2+c(a1)
000004A6 =000000C4                M c	=	c+14
000004A6 03C9 00C6                M 	movep.l	d1,2+c(a1)
000004AA =000000D2                M c	=	c+14
000004AA 03C9 00D4                M 	movep.l	d1,2+c(a1)
000004AE =000000E0                M c	=	c+14
000004AE 03C9 00E2                M 	movep.l	d1,2+c(a1)
000004B2 =000000EE                M c	=	c+14
000004B2 03C9 00F0                M 	movep.l	d1,2+c(a1)
000004B6 =000000FC                M c	=	c+14
000004B6 4E75                       		rts
000004B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004B8                            ; Load a palette into the main palette buffer
000004B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004B8                            ; PARAMETERS:
000004B8                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004B8                            ;	a0.l	- Pointer to palette data
000004B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004B8                            LoadPalette:
000004B8 43F8 98CE                  		lea	rPalette.w,a1			; Main palette buffer
000004BC 6000                       		bra.s	LoadPalToBuf			; Load the palette
000004BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004BE                            ; Load a palette into the target palette buffer
000004BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004BE                            ; PARAMETERS:
000004BE                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004BE                            ;	a0.l	- Pointer to palette data
000004BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004BE                            LoadTargetPal:
000004BE 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
000004C2 6000                       		bra.s	LoadPalToBuf			; Load the palette
000004C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004C4                            ; Load a palette into the main water palette buffer
000004C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004C4                            ; PARAMETERS:
000004C4                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004C4                            ;	a0.l	- Pointer to palette data
000004C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004C4                            LoadWaterPal:
000004C4 43F8 984E                  		lea	rWaterPal.w,a1		; Main water palette buffer
000004C8 6000                       		bra.s	LoadPalToBuf			; Load the palette
000004CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CA                            ; Load a palette into the target water palette buffer
000004CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CA                            ; PARAMETERS:
000004CA                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004CA                            ;	a0.l	- Pointer to palette data
000004CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CA                            LoadTargetWaterPal:
000004CA 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000004CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CE                            ; Load a palette into a palette buffer
000004CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CE                            ; PARAMETERS:
000004CE                            ;	d0.w	- Size of palette (divided by 2 minus 1)
000004CE                            ;	a0.l	- Pointer to palette data
000004CE                            ;	a1.l	- Pointer to destination buffer
000004CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004CE                            LoadPalToBuf:
000004CE 32D8                       		move.w	(a0)+,(a1)+			; Copy palette data
000004D0 51C8 FFFC                  		dbf	d0,LoadPalToBuf			; Loop
000004D4 4E75                       		rts
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            ; Fade the palette to black
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            ; PARAMETERS:
000004D6                            ;	Nothing
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            ; RETURNS:
000004D6                            ;	Nothing
000004D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D6                            FadeToBlack:
000004D6 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000004DC                            
000004DC                            FadeToBlack_Custom:
000004DC 7807                       		moveq	#7,d4				; Set repeat times
000004DE                            		
000004DE                            .FadeLoop:
000004DE                            		rept	2
000004DE                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000004DE                            			bsr.w	VSync_Routine		; Do V-SYNC
000004DE                            		endr
000004DE 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000004E4 6100 0000                M 	bsr.w	vsync_routine
000004E8 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000004EE 6100 0000                M 	bsr.w	vsync_routine
000004F2 6100                       		bsr.s	FadeToBlack_Once		; Fade the colors once
000004F4 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
000004F8 4E75                       		rts
000004FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004FA                            FadeToBlack_Once:
000004FA 7000                       		moveq	#0,d0
000004FC 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000500 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000504 D0C0                       		adda.w	d0,a0				; ''
00000506 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000050A                            
0000050A                            .FadeLoop:
0000050A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000050C 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000510                            
00000510 7000                       		moveq	#0,d0
00000512 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000516 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000051A D0C0                       		adda.w	d0,a0				; ''
0000051C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000520                            
00000520                            .FadeLoopWater:
00000520 6100                       		bsr.s	.FadeColor			; Fade a color			
00000522 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000526 4E75                       		rts
00000528                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000528                            .FadeColor:
00000528 3A10                       		move.w	(a0),d5				; Load color
0000052A 6700                       		beq.s	.NoRed				; If the color is already black, branch
0000052C 3205                       		move.w	d5,d1				; Copy color
0000052E 1401                       		move.b	d1,d2				; Load green and red
00000530 1601                       		move.b	d1,d3				; Load only red
00000532                            
00000532 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
00000536 6700                       		beq.s	.NoBlue				; If blue is finished, branch
00000538 0445 0200                  		subi.w	#$200,d5			; Decrease blue
0000053C                            
0000053C                            .NoBlue:
0000053C 0202 00E0                  		andi.b	#$E0,d2				; Get only green
00000540 6700                       		beq.s	.NoGreen			; If green is finished, branch
00000542 0445 0020                  		subi.w	#$20,d5				; Decrease green
00000546                            
00000546                            .NoGreen:
00000546 0203 000E                  		andi.b	#$E,d3				; Get only red
0000054A 6700                       		beq.s	.NoRed				; If red is finished, branch
0000054C 5545                       		subq.w	#2,d5				; Decrease red
0000054E                            
0000054E                            .NoRed:
0000054E 30C5                       		move.w	d5,(a0)+			; Save the color
00000550 4E75                       		rts
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; Fade the palette from black to the target palette
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; PARAMETERS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; RETURNS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            FadeFromBlack:
00000552 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000558                            
00000558                            FadeFromBlack_Custom:
00000558 780E                       		moveq	#$E,d4				; Maximum color check
0000055A                            
0000055A                            .FadeLoop:
0000055A                            		rept	2
0000055A                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
0000055A                            			bsr.w	VSync_Routine		; Do V-SYNC
0000055A                            		endr
0000055A 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000560 6100 0000                M 	bsr.w	vsync_routine
00000564 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000056A 6100 0000                M 	bsr.w	vsync_routine
0000056E 6100                       		bsr.s	FadeFromBlack_Once		; Fade the colors once
00000570 5504                       		subq.b	#2,d4				; Decrement color check
00000572 66E6                       		bne.s	.FadeLoop			; If we are not done, branch
00000574                            
00000574 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
0000057A 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
0000057E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000057E                            FadeFromBlack_Once:
0000057E 7000                       		moveq	#0,d0
00000580 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000584 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000588 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000058C D0C0                       		adda.w	d0,a0				; ''
0000058E D2C0                       		adda.w	d0,a1				; ''
00000590 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000594                            
00000594                            .FadeLoop:
00000594 6100                       		bsr.s	.FadeColor			; Fade a color			
00000596 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000059A                            
0000059A 7000                       		moveq	#0,d0
0000059C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
000005A0 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000005A4 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000005A8 D0C0                       		adda.w	d0,a0				; ''
000005AA D2C0                       		adda.w	d0,a1				; ''
000005AC 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000005B0                            
000005B0                            .FadeLoopWater:
000005B0 6100                       		bsr.s	.FadeColor			; Fade a color			
000005B2 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000005B6 4E75                       		rts
000005B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005B8                            .FadeColor:
000005B8 1A11                       		move.b	(a1),d5				; Load blue
000005BA 3219                       		move.w	(a1)+,d1			; Load green and red
000005BC 1401                       		move.b	d1,d2				; Load red
000005BE E809                       		lsr.b	#4,d1				; Get only green
000005C0 0202 000E                  		andi.b	#$E,d2				; Get only red
000005C4                            
000005C4 3610                       		move.w	(a0),d3				; Load current color
000005C6 B805                       		cmp.b	d5,d4				; Should the blue fade?
000005C8 6200                       		bhi.s	.NoBlue				; If not, branch
000005CA 0643 0200                  		addi.w	#$200,d3			; Increase blue
000005CE                            
000005CE                            .NoBlue:
000005CE B801                       		cmp.b	d1,d4				; Should the green fade?
000005D0 6200                       		bhi.s	.NoGreen			; If not, branch
000005D2 0643 0020                  		addi.w	#$20,d3				; Increase green
000005D6                            
000005D6                            .NoGreen:
000005D6 B802                       		cmp.b	d2,d4				; Should the red fade?
000005D8 6200                       		bhi.s	.NoRed				; If not, branch
000005DA 5443                       		addq.w	#2,d3				; Increase red
000005DC                            
000005DC                            .NoRed:
000005DC 30C3                       		move.w	d3,(a0)+			; Save the color
000005DE 4E75                       		rts
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            ; Fade the palette to white
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            ; PARAMETERS:
000005E0                            ;	Nothing
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            ; RETURNS:
000005E0                            ;	Nothing
000005E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005E0                            FadeToWhite:
000005E0 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000005E6                            
000005E6                            FadeToWhite_Custom:
000005E6 7807                       		moveq	#7,d4				; Set repeat times
000005E8                            
000005E8                            .FadeLoop:
000005E8                            		rept	2
000005E8                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000005E8                            			bsr.w	VSync_Routine		; Do V-SYNC
000005E8                            		endr
000005E8 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005EE 6100 0000                M 	bsr.w	vsync_routine
000005F2 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005F8 6100 0000                M 	bsr.w	vsync_routine
000005FC 6100                       		bsr.s	FadeToWhite_Once		; Fade the colors once
000005FE 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
00000602 4E75                       		rts
00000604                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000604                            FadeToWhite_Once:
00000604 7000                       		moveq	#0,d0
00000606 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000060A 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000060E D0C0                       		adda.w	d0,a0				; ''
00000610 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000614                            
00000614                            .FadeLoop:
00000614 6100                       		bsr.s	.FadeColor			; Fade a color			
00000616 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000061A                            
0000061A 7000                       		moveq	#0,d0
0000061C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000620 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000624 D0C0                       		adda.w	d0,a0				; ''
00000626 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000062A                            
0000062A                            .FadeLoopWater:
0000062A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000062C 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000630 4E75                       		rts
00000632                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000632                            .FadeColor:
00000632 3A10                       		move.w	(a0),d5				; Load color
00000634 0C45 0EEE                  		cmpi.w	#$EEE,d5			; Is it already white?
00000638 6700                       		beq.s	.NoRed				; If so, branch
0000063A 3205                       		move.w	d5,d1				; Copy color
0000063C 1401                       		move.b	d1,d2				; Load green and red
0000063E 1601                       		move.b	d1,d3				; Load only red
00000640                            
00000640 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
00000644 0C41 0E00                  		cmpi.w	#$E00,d1			; Is blue finished?
00000648 6700                       		beq.s	.NoBlue				; If do, branch
0000064A 0645 0200                  		addi.w	#$200,d5			; Increase blue
0000064E                            
0000064E                            .NoBlue:
0000064E 0202 00E0                  		andi.b	#$E0,d2				; Get only green
00000652 0C02 00E0                  		cmpi.b	#$E0,d2				; Is green finished?
00000656 6700                       		beq.s	.NoGreen			; If so, branch
00000658 0645 0020                  		addi.w	#$20,d5				; Increase green
0000065C                            
0000065C                            .NoGreen:
0000065C 0203 000E                  		andi.b	#$E,d3				; Get only red
00000660 0C03 000E                  		cmpi.b	#$E,d3				; Is red finished?
00000664 6700                       		beq.s	.NoRed				; If so, branch
00000666 5445                       		addq.w	#2,d5				; Increase red
00000668                            
00000668                            .NoRed:
00000668 30C5                       		move.w	d5,(a0)+			; Save the color
0000066A 4E75                       		rts
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            ; Fade the palette from white to the target palette
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            ; PARAMETERS:
0000066C                            ;	Nothing
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            ; RETURNS:
0000066C                            ;	Nothing
0000066C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000066C                            FadeFromWhite:
0000066C 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000672                            
00000672                            FadeFromWhite_Custom:
00000672 7800                       		moveq	#0,d4				; Minimum color check
00000674                            		
00000674                            .FadeLoop:
00000674                            		rept	2
00000674                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
00000674                            			bsr.w	VSync_Routine		; Do V-SYNC
00000674                            		endr
00000674 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000067A 6100 0000                M 	bsr.w	vsync_routine
0000067E 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000684 6100 0000                M 	bsr.w	vsync_routine
00000688 6100                       		bsr.s	FadeFromWhite_Once		; Fade the colors once
0000068A 5404                       		addq.b	#2,d4				; Decrement color check
0000068C 0C04 000E                  		cmpi.b	#$E,d4				; Are we done?
00000690 66E2                       		bne.s	.FadeLoop			; If not, branch
00000692                            
00000692 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
00000698 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
0000069C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000069C                            FadeFromWhite_Once:
0000069C 7000                       		moveq	#0,d0
0000069E 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
000006A2 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
000006A6 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000006AA D0C0                       		adda.w	d0,a0				; ''
000006AC D2C0                       		adda.w	d0,a1				; ''
000006AE 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000006B2                            
000006B2                            .FadeLoop:
000006B2 6100                       		bsr.s	.FadeColor			; Fade a color			
000006B4 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
000006B8                            
000006B8 7000                       		moveq	#0,d0
000006BA 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
000006BE 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000006C2 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000006C6 D0C0                       		adda.w	d0,a0				; ''
000006C8 D2C0                       		adda.w	d0,a1				; ''
000006CA 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000006CE                            
000006CE                            .FadeLoopWater:
000006CE 6100                       		bsr.s	.FadeColor			; Fade a color			
000006D0 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000006D4 4E75                       		rts
000006D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006D6                            .FadeColor:
000006D6 1A11                       		move.b	(a1),d5				; Load blue
000006D8 3219                       		move.w	(a1)+,d1			; Load green and red
000006DA 1401                       		move.b	d1,d2				; Load red
000006DC E809                       		lsr.b	#4,d1				; Get only green
000006DE 0202 000E                  		andi.b	#$E,d2				; Get only red
000006E2                            
000006E2 3610                       		move.w	(a0),d3				; Load current color
000006E4 B805                       		cmp.b	d5,d4				; Should the blue fade?
000006E6 6500                       		bcs.s	.NoBlue				; If not, branch
000006E8 0443 0200                  		subi.w	#$200,d3			; Decrease blue
000006EC                            
000006EC                            .NoBlue:
000006EC B801                       		cmp.b	d1,d4				; Should the green fade?
000006EE 6500                       		bcs.s	.NoGreen			; If not, branch
000006F0 0443 0020                  		subi.w	#$20,d3				; Decrease green
000006F4                            
000006F4                            .NoGreen:
000006F4 B802                       		cmp.b	d2,d4				; Should the red fade?
000006F6 6500                       		bcs.s	.NoRed				; If not, branch
000006F8 5543                       		subq.w	#2,d3				; Decrease red
000006FA                            
000006FA                            .NoRed:
000006FA 30C3                       		move.w	d3,(a0)+			; Save the color
000006FC 4E75                       		rts
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            ; Fade the palette from the current palette to the target palette
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            ; PARAMETERS:
000006FE                            ;	Nothing
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            ; RETURNS:
000006FE                            ;	Nothing
000006FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006FE                            FadeToPalette:
000006FE 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000704                            
00000704                            FadeToPalette_Custom:
00000704 7000                       		moveq	#0,d0
00000706 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000070A 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000070E D0C0                       		adda.w	d0,a0				; ''
00000710                            
00000710 7807                       		moveq	#7,d4				; Set repeat times
00000712                            
00000712                            .FadeLoop:
00000712                            		rept	2
00000712                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
00000712                            			bsr.w	VSync_Routine		; Do V-SYNC
00000712                            		endr
00000712 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000718 6100 0000                M 	bsr.w	vsync_routine
0000071C 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000722 6100 0000                M 	bsr.w	vsync_routine
00000726 6100                       		bsr.s	FadeToPalette_Once		; Fade the colors once
00000728 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
0000072C 4E75                       		rts
0000072E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000072E                            FadeToPalette_Once:
0000072E 7000                       		moveq	#0,d0
00000730 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000734 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000738 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000073C D0C0                       		adda.w	d0,a0				; ''
0000073E D2C0                       		adda.w	d0,a1				; ''
00000740 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000744                            
00000744                            .FadeLoop:
00000744 6100                       		bsr.s	.FadeColor			; Fade a color			
00000746 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000074A                            
0000074A 7000                       		moveq	#0,d0
0000074C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000750 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
00000754 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000758 D0C0                       		adda.w	d0,a0				; ''
0000075A D2C0                       		adda.w	d0,a1				; ''
0000075C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000760                            
00000760                            .FadeLoopWater:
00000760 6100                       		bsr.s	.FadeColor			; Fade a color			
00000762 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000766 4E75                       		rts
00000768                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000768                            .FadeColor:
00000768 3610                       		move.w	(a0),d3				; Get color
0000076A B659                       		cmp.w	(a1)+,d3			; Has the color already reached the target color?
0000076C 6700                       		beq.s	.NoRed				; If so, branch
0000076E                            		
0000076E 3229 FFFE                  		move.w	-2(a1),d1			; Get green and red
00000772 1401                       		move.b	d1,d2				; Get red only
00000774 0202 000E                  		andi.b	#$E,d2				; ''
00000778 E809                       		lsr.b	#4,d1				; Get green only
0000077A                            
0000077A 1A29 FFFE                  		move.b	-2(a1),d5			; Get blue
0000077E BA10                       		cmp.b	(a0),d5				; Does blue need to fade?
00000780 6700                       		beq.s	.NoBlue				; If not, branch
00000782 6500                       		bcs.s	.DecBlue			; If it needs to be decreased, branch
00000784 0643 0200                  		addi.w	#$200,d3			; Increase blue
00000788 6000                       		bra.s	.NoBlue				; Continue
0000078A                            
0000078A                            .DecBlue:
0000078A 0443 0200                  		subi.w	#$200,d3			; Decrease blue
0000078E                            
0000078E                            .NoBlue:
0000078E 3A10                       		move.w	(a0),d5				; Get green
00000790 E80D                       		lsr.b	#4,d5				; ''
00000792 B205                       		cmp.b	d5,d1				; Does green need to fade?
00000794 6700                       		beq.s	.NoGreen			; If not, branch
00000796 6500                       		bcs.s	.DecGreen			; If it needs to be decreased, branch
00000798 0603 0020                  		addi.b	#$20,d3				; Increase green
0000079C 6000                       		bra.s	.NoGreen			; Continue
0000079E                            
0000079E                            .DecGreen:
0000079E 0403 0020                  		subi.b	#$20,d3				; Decrease green
000007A2                            
000007A2                            .NoGreen:
000007A2 3A10                       		move.w	(a0),d5				; Get red
000007A4 0205 000E                  		andi.b	#$E,d5				; ''
000007A8 B405                       		cmp.b	d5,d2				; Does red need to fade?
000007AA 6700                       		beq.s	.NoRed				; If not, branch
000007AC 6500                       		bcs.s	.DecRed				; If it needs to be decreased, branch
000007AE 5403                       		addq.b	#2,d3				; Increase red
000007B0 6000                       		bra.s	.NoRed				; Continue
000007B2                            
000007B2                            .DecRed:
000007B2 5503                       		subq.b	#2,d3				; Decrease red
000007B4                            
000007B4                            .NoRed:
000007B4 30C3                       		move.w	d3,(a0)+			; Save new color
000007B6 4E75                       		rts
000007B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007B8                            ; Initialize the sprite table
000007B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007B8                            InitSpriteTable:
000007B8 7000                       		moveq	#0,d0
000007BA 41F8 94CE                  		lea	rSprites.w,a0			; Sprite table buffer
000007BE 7201                       		moveq	#1,d1				; Link value
000007C0 7E4F                       		moveq	#($280/8)-1,d7			; Number of sprites
000007C2                            
000007C2                            .Loop:
000007C2 3080                       		move.w	d0,(a0)				; Move off screen
000007C4 1141 0003                  		move.b	d1,3(a0)			; Set link value
000007C8 5241                       		addq.w	#1,d1				; Increment link value
000007CA 5048                       		addq.w	#8,a0				; Next sprite
000007CC 51CF FFF4                  		dbf	d7,.Loop			; Loop
000007D0 1140 FFFB                  		move.b	d0,-5(a0)			; Set final link value to 0
000007D4 4E75                       		rts
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            ; Draw the sprites from mappings
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            ; PARAMETERS:
000007D6                            ;	d0.w	- X position
000007D6                            ;	d1.w	- Y position
000007D6                            ;	d4.w	- Number of sprites to draw
000007D6                            ;	d5.w	- Sprite tile properties
000007D6                            ;	d6.b	- Render flags
000007D6                            ;	d7.w	- Max number of sprites left to draw
000007D6                            ;	a1.l	- Mappings frame data
000007D6                            ;	a6.l	- Sprite table buffer
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            ; RETURNS:
000007D6                            ;	Nothing
000007D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007D6                            DrawSprite:
000007D6 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
000007D8 6500                       		bcs.s	DrawSprite_FlipX		; If so, branch
000007DA E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
000007DC 6500 0000                  		bcs.w	DrawSprite_FlipY		; If so, branch
000007E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E0                            ; Draw the sprites from mappings with no flip checks
000007E0                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000007E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E0                            DrawSprite_Loop:
000007E0 1419                       		move.b	(a1)+,d2			; Get Y offset
000007E2 4882                       		ext.w	d2				; ''
000007E4 D441                       		add.w	d1,d2				; Add onto Y position
000007E6 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000007E8 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
000007EA 524E                       		addq.w	#1,a6				; Skip link data
000007EC 3419                       		move.w	(a1)+,d2			; Get tile properties
000007EE D445                       		add.w	d5,d2				; Add base tile properties
000007F0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000007F2 3419                       		move.w	(a1)+,d2			; Get X offset
000007F4 D440                       		add.w	d0,d2				; Add onto X position
000007F6 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000007F8 5347                       		subq.w	#1,d7				; Decrement sprite count
000007FA 5BCC FFE4                  		dbmi	d4,DrawSprite_Loop		; Loop if there are still enough sprites left
000007FE                            		
000007FE                            DrawSprite_End:
000007FE 4E75                       		rts
00000800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000800                            ; Draw the sprites from mappings, horizontally flipped
00000800                            ; (Parameters inherited from DrawSprite)
00000800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000800                            DrawSprite_FlipX:
00000800 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
00000802 6500                       		bcs.s	DrawSprite_FlipXY		; If so, branch
00000804                            
00000804                            .Loop:
00000804 1419                       		move.b	(a1)+,d2			; Get Y offset
00000806 4882                       		ext.w	d2				; ''
00000808 D441                       		add.w	d1,d2				; Add onto Y position
0000080A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000080C 1C19                       		move.b	(a1)+,d6			; Get sprite size
0000080E 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000810 524E                       		addq.w	#1,a6				; Skip link data
00000812 3419                       		move.w	(a1)+,d2			; Get tile properties
00000814 D445                       		add.w	d5,d2				; Add base tile properties
00000816 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
0000081A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000081C 3419                       		move.w	(a1)+,d2			; Get X offset
0000081E 4442                       		neg.w	d2				; Negate it
00000820 1C3B 6000                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
00000824 9446                       		sub.w	d6,d2				; Subtract the new X offset
00000826 D440                       		add.w	d0,d2				; Add onto X position
00000828 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000082A 5347                       		subq.w	#1,d7				; Decrement sprite count
0000082C 5BCC FFD6                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
00000830 4E75                       		rts
00000832                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000832                            DrawSprite_XFlipOff:
00000832 0808 0808                  		dc.b	8, 8, 8, 8
00000836 1010 1010                  		dc.b	$10, $10, $10, $10
0000083A 1818 1818                  		dc.b	$18, $18, $18, $18
0000083E 2020 2020                  		dc.b	$20, $20, $20, $20
00000842                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000842                            ; Draw the sprites from mappings, horizontally and vertically flipped
00000842                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
00000842                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000842                            DrawSprite_FlipXY:
00000842 1419                       		move.b	(a1)+,d2			; Get Y offset
00000844 4882                       		ext.w	d2				; ''
00000846 4442                       		neg.w	d2				; Negate it
00000848 1C11                       		move.b	(a1),d6				; Get sprite sizes
0000084A 1C3B 6000                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
0000084E 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000850 D441                       		add.w	d1,d2				; Add onto Y position
00000852 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000854 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000856 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000858 524E                       		addq.w	#1,a6				; Skip link data
0000085A 3419                       		move.w	(a1)+,d2			; Get tile properties
0000085C D445                       		add.w	d5,d2				; Add base tile properties
0000085E 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
00000862 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000864 3419                       		move.w	(a1)+,d2			; Get X offset
00000866 4442                       		neg.w	d2				; Negate it
00000868 1C3B 60C8                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
0000086C 9446                       		sub.w	d6,d2				; Subtract the new X offset
0000086E D440                       		add.w	d0,d2				; Add onto X position
00000870 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000872 5347                       		subq.w	#1,d7				; Decrement sprite count
00000874 5BCC FFCC                  		dbmi	d4,DrawSprite_FlipXY		; Loop if there are still enough sprites left
00000878 4E75                       		rts
0000087A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087A                            DrawSprite_YFlipOff:
0000087A 0810 1820                  		dc.b	8, $10, $18, $20
0000087E 0810 1820                  		dc.b	8, $10, $18, $20
00000882 0810 1820                  		dc.b	8, $10, $18, $20
00000886 0810 1820                  		dc.b	8, $10, $18, $20
0000088A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000088A                            ; Draw the sprites from mappings, vertically flipped
0000088A                            ; (Parameters inherited from DrawSprite)
0000088A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000088A                            DrawSprite_FlipY:
0000088A 1419                       		move.b	(a1)+,d2			; Get Y offset
0000088C 4882                       		ext.w	d2				; ''
0000088E 4442                       		neg.w	d2				; Negate it
00000890 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
00000892 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000896 1C3B 60E2                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
0000089A 9446                       		sub.w	d6,d2				; Subtract from the Y offset
0000089C D441                       		add.w	d1,d2				; Add onto Y position
0000089E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008A0 544E                       		addq.w	#2,a6				; Skip link data
000008A2 3419                       		move.w	(a1)+,d2			; Get tile properties
000008A4 D445                       		add.w	d5,d2				; Add base tile properties
000008A6 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
000008AA 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008AC 3419                       		move.w	(a1)+,d2			; Get X offset
000008AE D440                       		add.w	d0,d2				; Add onto X position
000008B0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008B2 5347                       		subq.w	#1,d7				; Decrement sprite count
000008B4 5BCC FFD4                  		dbmi	d4,DrawSprite_FlipY		; Loop if there are still enough sprites left
000008B8 4E75                       		rts
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            ; Draw the sprites from mappings (with boundary checks)
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            ; PARAMETERS:
000008BA                            ;	d0.w	- X position
000008BA                            ;	d1.w	- Y position
000008BA                            ;	d4.w	- Number of sprites to draw
000008BA                            ;	d5.w	- Sprite tile properties
000008BA                            ;	d6.b	- Render flags
000008BA                            ;	d7.w	- Max number of sprites left to draw
000008BA                            ;	a1.l	- Mappings frame data
000008BA                            ;	a6.l	- Sprite table buffer
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            ; RETURNS:
000008BA                            ;	Nothing
000008BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BA                            DrawSprite_BoundChk:
000008BA E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
000008BC 6500                       		bcs.s	DrawSprite_BndChk_FlipX		; If so, branch
000008BE E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
000008C0 6500 0000                  		bcs.w	DrawSprite_BndChk_FlipY		; If so, branch
000008C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008C4                            ; Draw the sprites from mappings (with boundary checks) with no flip checks
000008C4                            ; (Parameters inherited from DrawSprite_BoundChk, minus d6, a.k.a. render flags)
000008C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008C4                            DrawSprBndChk_Loop:
000008C4 1419                       		move.b	(a1)+,d2			; Get Y offset
000008C6 4882                       		ext.w	d2				; ''
000008C8 D441                       		add.w	d1,d2				; Add onto Y position
000008CA 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
000008CE 6300                       		bls.s	.Next_YOffScr			; If so, branch
000008D0 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
000008D4 6400                       		bhs.s	.Next_YOffScr			; If so, branch
000008D6 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008D8 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
000008DA 524E                       		addq.w	#1,a6				; Skip link data
000008DC 3419                       		move.w	(a1)+,d2			; Get tile properties
000008DE D445                       		add.w	d5,d2				; Add base tile properties
000008E0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008E2 3419                       		move.w	(a1)+,d2			; Get X offset
000008E4 D440                       		add.w	d0,d2				; Add onto X position
000008E6 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000008EA 6300                       		bls.s	.Next_XOffScr			; If so, branch
000008EC 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000008F0 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000008F2 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008F4 5347                       		subq.w	#1,d7				; Decrement sprite count
000008F6 5BCC FFCC                  		dbmi	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
000008FA 4E75                       		rts
000008FC                            
000008FC                            .Next_XOffScr:
000008FC 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000008FE 51CC FFC4                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000902 4E75                       		rts
00000904                            
00000904                            .Next_YOffScr:
00000904 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings in the mappings
00000906 51CC FFBC                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
0000090A 4E75                       		rts
0000090C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000090C                            ; Draw the sprites from mappings (with boundary checks), horizontally flipped
0000090C                            ; (Parameters inherited from DrawSprite_BoundChk)
0000090C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000090C                            DrawSprite_BndChk_FlipX:
0000090C E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000090E 6500                       		bcs.s	DrawSprite_BndChk_FlipXY	; If so, branch
00000910                            
00000910                            .Loop:
00000910 1419                       		move.b	(a1)+,d2			; Get Y offset
00000912 4882                       		ext.w	d2				; ''
00000914 D441                       		add.w	d1,d2				; Add onto Y position
00000916 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000091A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000091C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000920 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000922 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000924 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000926 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000928 524E                       		addq.w	#1,a6				; Skip link data
0000092A 3419                       		move.w	(a1)+,d2			; Get tile properties
0000092C D445                       		add.w	d5,d2				; Add base tile properties
0000092E 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
00000932 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000934 3419                       		move.w	(a1)+,d2			; Get X offset
00000936 4442                       		neg.w	d2				; Negate it
00000938 1C3B 6000                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
0000093C 9446                       		sub.w	d6,d2				; Subtract the new X offset
0000093E D440                       		add.w	d0,d2				; Add onto X position
00000940 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000944 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000946 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
0000094A 6400                       		bhs.s	.Next_XOffScr			; If so, branch
0000094C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000094E 5347                       		subq.w	#1,d7				; Decrement sprite count
00000950 5BCC FFBE                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
00000954 4E75                       		rts
00000956                            
00000956                            .Next_XOffScr:
00000956 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000958 51CC FFB6                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
0000095C 4E75                       		rts
0000095E                            
0000095E                            .Next_YOffScr:
0000095E 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000960 51CC FFAE                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
00000964 4E75                       		rts
00000966                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000966                            DrwSprBndChk_XFlips:
00000966 0808 0808                  		dc.b	8, 8, 8, 8
0000096A 1010 1010                  		dc.b	$10, $10, $10, $10
0000096E 1818 1818                  		dc.b	$18, $18, $18, $18
00000972 2020 2020                  		dc.b	$20, $20, $20, $20
00000976                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000976                            ; Draw the sprites from mappings (with boundary checks), horizontally and vertically flipped
00000976                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
00000976                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000976                            DrawSprite_BndChk_FlipXY:
00000976 1419                       		move.b	(a1)+,d2			; Get Y offset
00000978 4882                       		ext.w	d2				; ''
0000097A 4442                       		neg.w	d2				; Negate it
0000097C 1C11                       		move.b	(a1),d6				; Get sprite sizes
0000097E 1C3B 6000                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
00000982 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000984 D441                       		add.w	d1,d2				; Add onto Y position
00000986 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000098A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000098C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000990 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000992 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000994 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000996 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000998 524E                       		addq.w	#1,a6				; Skip link data
0000099A 3419                       		move.w	(a1)+,d2			; Get tile properties
0000099C D445                       		add.w	d5,d2				; Add base tile properties
0000099E 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
000009A2 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009A4 3419                       		move.w	(a1)+,d2			; Get X offset
000009A6 4442                       		neg.w	d2				; Negate it
000009A8 1C3B 60BC                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
000009AC 9446                       		sub.w	d6,d2				; Subtract the new X offset
000009AE D440                       		add.w	d0,d2				; Add onto X position
000009B0 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000009B4 6300                       		bls.s	.Next_XOffScr			; If so, branch
000009B6 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000009BA 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000009BC 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009BE 5347                       		subq.w	#1,d7				; Decrement sprite count
000009C0 5BCC FFB4                  		dbmi	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
000009C4 4E75                       		rts
000009C6                            
000009C6                            .Next_XOffScr:
000009C6 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000009C8 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
000009CC 4E75                       		rts
000009CE                            
000009CE                            .Next_YOffScr:
000009CE 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
000009D0 51CC FFA4                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
000009D4 4E75                       		rts
000009D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009D6                            DrwSprBndChk_YFlips:
000009D6 0810 1820                  		dc.b	8, $10, $18, $20
000009DA 0810 1820                  		dc.b	8, $10, $18, $20
000009DE 0810 1820                  		dc.b	8, $10, $18, $20
000009E2 0810 1820                  		dc.b	8, $10, $18, $20
000009E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E6                            ; Draw the sprites from mappings (with boundary checks), vertically flipped
000009E6                            ; (Parameters inherited from DrawSprite_BoundChk)
000009E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E6                            DrawSprite_BndChk_FlipY:
000009E6 1419                       		move.b	(a1)+,d2			; Get Y offset
000009E8 4882                       		ext.w	d2				; ''
000009EA 4442                       		neg.w	d2				; Negate it
000009EC 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
000009EE 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
000009F2 1C3B 60E2                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
000009F6 9446                       		sub.w	d6,d2				; Subtract from the Y offset
000009F8 D441                       		add.w	d1,d2				; Add onto Y position
000009FA 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
000009FE 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A00 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A04 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A06 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A08 544E                       		addq.w	#2,a6				; Skip link data
00000A0A 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A0C D445                       		add.w	d5,d2				; Add base tile properties
00000A0E 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000A12 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A14 3419                       		move.w	(a1)+,d2			; Get X offset
00000A16 D440                       		add.w	d0,d2				; Add onto X position
00000A18 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A1C 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A1E 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A22 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000A24 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A26 5347                       		subq.w	#1,d7				; Decrement sprite count
00000A28 5BCC FFBC                  		dbmi	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000A2C 4E75                       		rts
00000A2E                            
00000A2E                            .Next_XOffScr:
00000A2E 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000A30 51CC FFB4                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000A34 4E75                       		rts
00000A36                            
00000A36                            .Next_YOffScr:
00000A36 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000A38 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000A3C 4E75                       		rts
00000A3E                            ; =========================================================================================================================================================
00000A3E                            		include	"_LIB_/Joypad.asm"		; Joypad functions
00000A3E                            ; =========================================================================================================================================================
00000A3E                            ; Mighty The Armadillo in PRISM PARADISE
00000A3E                            ; By Nat The Porcupine 2021
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; Joypad functions
00000A3E                            ; =========================================================================================================================================================
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; Read joypad input
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; PARAMETERS:
00000A3E                            ;	Nothing
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ; RETURNS:
00000A3E                            ;	Nothing
00000A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A3E                            ReadJoypads:
00000A3E 41F8 C740                  	lea	rP1Data.w,a0			; 8	; load RAM space for joypad data
00000A42 43F9 00A1 0002             	lea	PORT_A_DATA-1,a1		; 12	; load I/O data port A
00000A48 7000                       	moveq	#%00000000,d0			; 4	; prepare TH = 0 request value
00000A4A 7240                       	moveq	#%01000000,d1			; 4	; prepare TH = 1 request value
00000A4C                            
00000A4C                            	; Repeat the following twice to
00000A4C                            	; collect input from both pads
00000A4C                            	rept	2
00000A4C                            		move.w	d0,(a1)			; 8	; set TH = 0 (burn 8 cycles to wait for returned data by setting up bitmasks below)
00000A4C                            		moveq	#%00110000,d2		; 4	; button bitmask mask for TH = 0
00000A4C                            		moveq	#%00111111,d3		; 4	; button bitmask for TH = 1
00000A4C                            		and.w	(a1),d2			; 8	; collect current button data for TH = 0 (A and Start)
00000A4C                            		move.w	d1,(a1)			; 8	; set TH = 1 (burn 8 cycles again below to wait)
00000A4C                            		add.b	d2,d2			; 4	; shift TH = 0 button bits to the left by two
00000A4C                            		add.b	d2,d2			; 4	; (A and start will be bits $6 and $7 in saved data)
00000A4C                            		and.w	(a1)+,d3		; 8	; collect current button data for TH = 1 (Up, Down, Left, Right, B, and C)
00000A4C                            		or.b	d3,d2			; 4	; combine collected button bits
00000A4C                            		not.b	d2			; 4	; flip bits (now pressed = 1 and not pressed = 0)
00000A4C                            		move.b	(a0),d3			; 8	; d3 = last collected button data
00000A4C                            		eor.b	d2,d3			; 4	; remove any currently pressed buttons from d3
00000A4C                            		move.b	d2,(a0)+		; 8	; save d2 (current button presses) as current held buttons
00000A4C                            		and.b	d2,d3			; 4	; limit d3 (pressed buttons) to only include current buttons
00000A4C                            		move.b	d3,(a0)+		; 8	; save all pressed buttons for this frame
00000A4C                            	endr
00000A4C 3280                     M 	move.w	d0,(a1)
00000A4E 7430                     M 	moveq	#%00110000,d2
00000A50 763F                     M 	moveq	#%00111111,d3
00000A52 C451                     M 	and.w	(a1),d2
00000A54 3281                     M 	move.w	d1,(a1)
00000A56 D402                     M 	add.b	d2,d2
00000A58 D402                     M 	add.b	d2,d2
00000A5A C659                     M 	and.w	(a1)+,d3
00000A5C 8403                     M 	or.b	d3,d2
00000A5E 4602                     M 	not.b	d2
00000A60 1610                     M 	move.b	(a0),d3
00000A62 B503                     M 	eor.b	d2,d3
00000A64 10C2                     M 	move.b	d2,(a0)+
00000A66 C602                     M 	and.b	d2,d3
00000A68 10C3                     M 	move.b	d3,(a0)+
00000A6A 3280                     M 	move.w	d0,(a1)
00000A6C 7430                     M 	moveq	#%00110000,d2
00000A6E 763F                     M 	moveq	#%00111111,d3
00000A70 C451                     M 	and.w	(a1),d2
00000A72 3281                     M 	move.w	d1,(a1)
00000A74 D402                     M 	add.b	d2,d2
00000A76 D402                     M 	add.b	d2,d2
00000A78 C659                     M 	and.w	(a1)+,d3
00000A7A 8403                     M 	or.b	d3,d2
00000A7C 4602                     M 	not.b	d2
00000A7E 1610                     M 	move.b	(a0),d3
00000A80 B503                     M 	eor.b	d2,d3
00000A82 10C2                     M 	move.b	d2,(a0)+
00000A84 C602                     M 	and.b	d2,d3
00000A86 10C3                     M 	move.b	d3,(a0)+
00000A88                            
00000A88 4E75                       	rts					; 16	; return
00000A8A                            
00000A8A                            ; =========================================================================================================================================================
00000A8A                            		include	"_LIB_/Interrupt.asm"		; Interrupt functions
00000A8A                            ; =========================================================================================================================================================
00000A8A                            ; Mighty The Armadillo in PRISM PARADISE
00000A8A                            ; By Nat The Porcupine 2021
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            ; Interrupt functions
00000A8A                            ; =========================================================================================================================================================
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            ; Wait for the vertical interrupt to run and finish
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            ; PARAMETERS:
00000A8A                            ;	Nothing
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            ; RETURNS:
00000A8A                            ;	Nothing
00000A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A8A                            VSync:
00000A8A 50F8 C745                  		st	rVINTFlag.w			; Set V-INT flag
00000A8E                            
00000A8E                            VSync_Routine:
00000A8E                            		intsOn					; Enable interrupts
00000A8E 027C F8FF                M 	andi	#$f8ff,sr
00000A92                            		lagOff					; Turn off the lag-o-meter
00000A92                            
00000A92                            .Wait:
00000A92 4A38 C745                  		tst.b	rVINTFlag.w			; Has the V-INT run yet?
00000A96 66FA                       		bne.s	.Wait				; If not, wait some more
00000A98 4E75                       		rts
00000A9A                            ; =========================================================================================================================================================
00000A9A                            		include	"_LIB_/Decompression.asm"	; Decompression functions
00000A9A                            ; =========================================================================================================================================================
00000A9A                            ; Mighty The Armadillo in PRISM PARADISE
00000A9A                            ; By Nat The Porcupine 2021
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            ; Decompression functions
00000A9A                            ; =========================================================================================================================================================
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            ; Kosinski decompression (General purpose)
00000A9A                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            ; PARAMETERS:
00000A9A                            ;	a0.l	- Source address
00000A9A                            ;	a1.l	- Destination address
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            ; RETURNS:
00000A9A                            ;	a1.l	- End of decompressed data address
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A =00000001                  _Kos_UseLUT			equ	1
00000A9A =00000003                  _Kos_LoopUnroll			equ	3
00000A9A =00000001                  _Kos_ExtremeUnrolling		equ	1
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            _Kos_RunBitStream macro
00000A9A                            		dbra	d2,.skip\@
00000A9A                            		moveq	#7,d2				; Set repeat count to 8.
00000A9A                            		move.b	d1,d0				; Use the remaining 8 bits.
00000A9A                            		not.w	d3				; Have all 16 bits been used up?
00000A9A                            		bne.s	.skip\@				; Branch if not.
00000A9A                            		move.b	(a0)+,d0			; Get desc field low-byte.
00000A9A                            		move.b	(a0)+,d1			; Get desc field hi-byte.
00000A9A                            	if _Kos_UseLUT=1
00000A9A                            		move.b	(a4,d0.w),d0			; Invert bit order...
00000A9A                            		move.b	(a4,d1.w),d1			; ... for both bytes.
00000A9A                            	endif
00000A9A                            .skip\@:
00000A9A                            		endm
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            _Kos_ReadBit macro
00000A9A                            	if _Kos_UseLUT=1
00000A9A                            		add.b	d0,d0				; Get a bit from the bitstream.
00000A9A                            	else
00000A9A                            		lsr.b	#1,d0				; Get a bit from the bitstream.
00000A9A                            	endif
00000A9A                            		endm
00000A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A9A                            KosDec:
00000A9A 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00000A9C 7000                       		moveq	#0,d0
00000A9E 7200                       		moveq	#0,d1
00000AA0 49FA 0000                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00000AA4 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00000AA6 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
00000AA8 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
00000AAC 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00000AB0 7407                       		moveq	#7,d2				; Set repeat count to 8.
00000AB2 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00000AB4 6000                       		bra.s	.FetchNewCode
00000AB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000AB6                            .FetchCodeLoop:
00000AB6                            		; Code 1 (Uncompressed byte).
00000AB6                            		_Kos_RunBitStream
00000AB6 51CA 0000                M 	dbra	d2,.skip_30
00000ABA 7407                     M 	moveq	#7,d2
00000ABC 1001                     M 	move.b	d1,d0
00000ABE 4643                     M 	not.w	d3
00000AC0 6600                     M 	bne.s	.skip_30
00000AC2 1018                     M 	move.b	(a0)+,d0
00000AC4 1218                     M 	move.b	(a0)+,d1
00000AC6 1034 0000                M 	move.b	(a4,d0.w),d0
00000ACA 1234 1000                M 	move.b	(a4,d1.w),d1
00000ACE                          M .skip_30:
00000ACE 12D8                       		move.b	(a0)+,(a1)+
00000AD0                             
00000AD0                            .FetchNewCode:
00000AD0                            		_Kos_ReadBit
00000AD0 D000                     M 	add.b	d0,d0
00000AD2 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00000AD4                             
00000AD4                            		; Codes 00 and 01.
00000AD4 7AFF                       		moveq	#-1,d5
00000AD6 4BD1                       		lea	(a1),a5
00000AD8                            		_Kos_RunBitStream
00000AD8 51CA 0000                M 	dbra	d2,.skip_32
00000ADC 7407                     M 	moveq	#7,d2
00000ADE 1001                     M 	move.b	d1,d0
00000AE0 4643                     M 	not.w	d3
00000AE2 6600                     M 	bne.s	.skip_32
00000AE4 1018                     M 	move.b	(a0)+,d0
00000AE6 1218                     M 	move.b	(a0)+,d1
00000AE8 1034 0000                M 	move.b	(a4,d0.w),d0
00000AEC 1234 1000                M 	move.b	(a4,d1.w),d1
00000AF0                          M .skip_32:
00000AF0                            		_Kos_ReadBit
00000AF0 D000                     M 	add.b	d0,d0
00000AF2 6500 0000                  		bcs.w	.Code_01
00000AF6                             
00000AF6                            		; Code 00 (Dictionary ref. short).
00000AF6                            		_Kos_RunBitStream
00000AF6 51CA 0000                M 	dbra	d2,.skip_34
00000AFA 7407                     M 	moveq	#7,d2
00000AFC 1001                     M 	move.b	d1,d0
00000AFE 4643                     M 	not.w	d3
00000B00 6600                     M 	bne.s	.skip_34
00000B02 1018                     M 	move.b	(a0)+,d0
00000B04 1218                     M 	move.b	(a0)+,d1
00000B06 1034 0000                M 	move.b	(a4,d0.w),d0
00000B0A 1234 1000                M 	move.b	(a4,d1.w),d1
00000B0E                          M .skip_34:
00000B0E                            		_Kos_ReadBit
00000B0E D000                     M 	add.b	d0,d0
00000B10 6500                       		bcs.s	.Copy45
00000B12                            		_Kos_RunBitStream
00000B12 51CA 0000                M 	dbra	d2,.skip_36
00000B16 7407                     M 	moveq	#7,d2
00000B18 1001                     M 	move.b	d1,d0
00000B1A 4643                     M 	not.w	d3
00000B1C 6600                     M 	bne.s	.skip_36
00000B1E 1018                     M 	move.b	(a0)+,d0
00000B20 1218                     M 	move.b	(a0)+,d1
00000B22 1034 0000                M 	move.b	(a4,d0.w),d0
00000B26 1234 1000                M 	move.b	(a4,d1.w),d1
00000B2A                          M .skip_36:
00000B2A                            		_Kos_ReadBit
00000B2A D000                     M 	add.b	d0,d0
00000B2C 6500                       		bcs.s	.Copy3
00000B2E                            		_Kos_RunBitStream
00000B2E 51CA 0000                M 	dbra	d2,.skip_38
00000B32 7407                     M 	moveq	#7,d2
00000B34 1001                     M 	move.b	d1,d0
00000B36 4643                     M 	not.w	d3
00000B38 6600                     M 	bne.s	.skip_38
00000B3A 1018                     M 	move.b	(a0)+,d0
00000B3C 1218                     M 	move.b	(a0)+,d1
00000B3E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B42 1234 1000                M 	move.b	(a4,d1.w),d1
00000B46                          M .skip_38:
00000B46 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000B48 DAC5                       		adda.w	d5,a5
00000B4A 12DD                       		move.b	(a5)+,(a1)+
00000B4C 12DD                       		move.b	(a5)+,(a1)+
00000B4E 6080                       		bra.s	.FetchNewCode
00000B50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B50                            .Copy3:
00000B50                            		_Kos_RunBitStream
00000B50 51CA 0000                M 	dbra	d2,.skip_39
00000B54 7407                     M 	moveq	#7,d2
00000B56 1001                     M 	move.b	d1,d0
00000B58 4643                     M 	not.w	d3
00000B5A 6600                     M 	bne.s	.skip_39
00000B5C 1018                     M 	move.b	(a0)+,d0
00000B5E 1218                     M 	move.b	(a0)+,d1
00000B60 1034 0000                M 	move.b	(a4,d0.w),d0
00000B64 1234 1000                M 	move.b	(a4,d1.w),d1
00000B68                          M .skip_39:
00000B68 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000B6A DAC5                       		adda.w	d5,a5
00000B6C 12DD                       		move.b	(a5)+,(a1)+
00000B6E 12DD                       		move.b	(a5)+,(a1)+
00000B70 12DD                       		move.b	(a5)+,(a1)+
00000B72 6000 FF5C                  		bra.w	.FetchNewCode
00000B76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B76                            .Copy45:
00000B76                            		_Kos_RunBitStream
00000B76 51CA 0000                M 	dbra	d2,.skip_40
00000B7A 7407                     M 	moveq	#7,d2
00000B7C 1001                     M 	move.b	d1,d0
00000B7E 4643                     M 	not.w	d3
00000B80 6600                     M 	bne.s	.skip_40
00000B82 1018                     M 	move.b	(a0)+,d0
00000B84 1218                     M 	move.b	(a0)+,d1
00000B86 1034 0000                M 	move.b	(a4,d0.w),d0
00000B8A 1234 1000                M 	move.b	(a4,d1.w),d1
00000B8E                          M .skip_40:
00000B8E                            		_Kos_ReadBit
00000B8E D000                     M 	add.b	d0,d0
00000B90 6500                       		bcs.s	.Copy5
00000B92                            		_Kos_RunBitStream
00000B92 51CA 0000                M 	dbra	d2,.skip_42
00000B96 7407                     M 	moveq	#7,d2
00000B98 1001                     M 	move.b	d1,d0
00000B9A 4643                     M 	not.w	d3
00000B9C 6600                     M 	bne.s	.skip_42
00000B9E 1018                     M 	move.b	(a0)+,d0
00000BA0 1218                     M 	move.b	(a0)+,d1
00000BA2 1034 0000                M 	move.b	(a4,d0.w),d0
00000BA6 1234 1000                M 	move.b	(a4,d1.w),d1
00000BAA                          M .skip_42:
00000BAA 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BAC DAC5                       		adda.w	d5,a5
00000BAE 12DD                       		move.b	(a5)+,(a1)+
00000BB0 12DD                       		move.b	(a5)+,(a1)+
00000BB2 12DD                       		move.b	(a5)+,(a1)+
00000BB4 12DD                       		move.b	(a5)+,(a1)+
00000BB6 6000 FF18                  		bra.w	.FetchNewCode
00000BBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BBA                            .Copy5:
00000BBA                            		_Kos_RunBitStream
00000BBA 51CA 0000                M 	dbra	d2,.skip_43
00000BBE 7407                     M 	moveq	#7,d2
00000BC0 1001                     M 	move.b	d1,d0
00000BC2 4643                     M 	not.w	d3
00000BC4 6600                     M 	bne.s	.skip_43
00000BC6 1018                     M 	move.b	(a0)+,d0
00000BC8 1218                     M 	move.b	(a0)+,d1
00000BCA 1034 0000                M 	move.b	(a4,d0.w),d0
00000BCE 1234 1000                M 	move.b	(a4,d1.w),d1
00000BD2                          M .skip_43:
00000BD2 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BD4 DAC5                       		adda.w	d5,a5
00000BD6 12DD                       		move.b	(a5)+,(a1)+
00000BD8 12DD                       		move.b	(a5)+,(a1)+
00000BDA 12DD                       		move.b	(a5)+,(a1)+
00000BDC 12DD                       		move.b	(a5)+,(a1)+
00000BDE 12DD                       		move.b	(a5)+,(a1)+
00000BE0 6000 FEEE                  		bra.w	.FetchNewCode
00000BE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE4                            .Code_01:
00000BE4 7800                       		moveq	#0,d4				; d4 will contain copy count.
00000BE6                            		; Code 01 (Dictionary ref. long / special).
00000BE6                            		_Kos_RunBitStream
00000BE6 51CA 0000                M 	dbra	d2,.skip_44
00000BEA 7407                     M 	moveq	#7,d2
00000BEC 1001                     M 	move.b	d1,d0
00000BEE 4643                     M 	not.w	d3
00000BF0 6600                     M 	bne.s	.skip_44
00000BF2 1018                     M 	move.b	(a0)+,d0
00000BF4 1218                     M 	move.b	(a0)+,d1
00000BF6 1034 0000                M 	move.b	(a4,d0.w),d0
00000BFA 1234 1000                M 	move.b	(a4,d1.w),d1
00000BFE                          M .skip_44:
00000BFE 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00000C00 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00000C02 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00000C04 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00000C06 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
00000C08 C847                       		and.w	d7,d4				; d4 = %00000CCC.
00000C0A 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00000C0C                             
00000C0C                            		; special mode (extended counter)
00000C0C 1818                       		move.b	(a0)+,d4			; Read cnt
00000C0E 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00000C10 5304                       		subq.b	#1,d4
00000C12 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00000C16                             
00000C16 DAC5                       		adda.w	d5,a5
00000C18 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C1A 3C04                       		move.w	d4,d6
00000C1C 4646                       		not.w	d6
00000C1E CC47                       		and.w	d7,d6
00000C20 DC46                       		add.w	d6,d6
00000C22 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00000C24 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
00000C28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C28                            .LargeCopy:
00000C28                            	rept (1<<_Kos_LoopUnroll)
00000C28                            		move.b	(a5)+,(a1)+
00000C28                            	endr
00000C28 12DD                     M 	move.b	(a5)+,(a1)+
00000C2A 12DD                     M 	move.b	(a5)+,(a1)+
00000C2C 12DD                     M 	move.b	(a5)+,(a1)+
00000C2E 12DD                     M 	move.b	(a5)+,(a1)+
00000C30 12DD                     M 	move.b	(a5)+,(a1)+
00000C32 12DD                     M 	move.b	(a5)+,(a1)+
00000C34 12DD                     M 	move.b	(a5)+,(a1)+
00000C36 12DD                     M 	move.b	(a5)+,(a1)+
00000C38 51CC FFEE                  		dbra	d4,.LargeCopy
00000C3C 6000 FE92                  		bra.w	.FetchNewCode
00000C40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C40                            .StreamCopy:
00000C40 DAC5                       		adda.w	d5,a5
00000C42 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C44 BF44                       		eor.w	d7,d4
00000C46 D844                       		add.w	d4,d4
00000C48 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00000C4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C4C                            .MediumCopy:
00000C4C                            	rept 8
00000C4C                            		move.b	(a5)+,(a1)+
00000C4C                            	endr
00000C4C 12DD                     M 	move.b	(a5)+,(a1)+
00000C4E 12DD                     M 	move.b	(a5)+,(a1)+
00000C50 12DD                     M 	move.b	(a5)+,(a1)+
00000C52 12DD                     M 	move.b	(a5)+,(a1)+
00000C54 12DD                     M 	move.b	(a5)+,(a1)+
00000C56 12DD                     M 	move.b	(a5)+,(a1)+
00000C58 12DD                     M 	move.b	(a5)+,(a1)+
00000C5A 12DD                     M 	move.b	(a5)+,(a1)+
00000C5C 6000 FE72                  		bra.w	.FetchNewCode
00000C60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C60                            .Quit:
00000C60 4E75                       		rts
00000C62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C62                            KosDec_ByteMap:
00000C62 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00000C72 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00000C82 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00000C92 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
00000CA2 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
00000CB2 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
00000CC2 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
00000CD2 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
00000CE2 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
00000CF2 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00000D02 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00000D12 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00000D22 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00000D32 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00000D42 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00000D52 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00000D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D62                            ; Enigma decompression (Mainly for plane mappings)
00000D62                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D62                            ; PARAMETERS:
00000D62                            ;	d0.w	- Base tile properties (tile ID, flags, etc.)
00000D62                            ;	a0.l	- Source address
00000D62                            ;	a1.l	- Destination address
00000D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D62                            ; RETURNS:
00000D62                            ;	a1.l	- End of decompressed data address
00000D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000D62                            EniDec:
00000D62                            		push.l d0-d7/a1-a5
00000D62 48E7 FF7C                M 	movem.l	d0-d7/a1-a5,-(sp)
00000D66 3640                       		movea.w d0,a3				; Store base tile properties
00000D68 1018                       		move.b	(a0)+,d0
00000D6A 4880                       		ext.w	d0
00000D6C 3A40                       		movea.w d0,a5				; Store first byte, extended to word
00000D6E 1818                       		move.b	(a0)+,d4			; Store second byte
00000D70 E70C                       		lsl.b	#3,d4				; Multiply by 8
00000D72 3458                       		movea.w (a0)+,a2			; Store third and fourth byte
00000D74 D4CB                       		adda.w	a3,a2				; Add base tile properties
00000D76 3858                       		movea.w (a0)+,a4			; Store fifth and sixth byte
00000D78 D8CB                       		adda.w	a3,a4				; Add base tile properties
00000D7A 1A18                       		move.b	(a0)+,d5			; Store seventh byte
00000D7C E145                       		asl.w	#8,d5				; Shift up by a byte
00000D7E 1A18                       		move.b	(a0)+,d5			; Store eigth byte in lower register byte
00000D80 7C10                       		moveq	#$10,d6				; 16 bits = 2 bytes
00000D82                            
00000D82                            EniDec_Loop:
00000D82 7007                       		moveq	#7,d0				; Process 7 bits at a time
00000D84 3E06                       		move.w	d6,d7
00000D86 9E40                       		sub.w	d0,d7
00000D88 3205                       		move.w	d5,d1
00000D8A EE69                       		lsr.w	d7,d1
00000D8C 0241 007F                  		andi.w	#$7F,d1				; Keep only lower 7 bits
00000D90 3401                       		move.w	d1,d2
00000D92 0C41 0040                  		cmpi.w	#$40,d1				; Is Bit 6 set?
00000D96 6400                       		bcc.s	.getnext			; If so, branch
00000D98 7006                       		moveq	#6,d0				; If not, process 6 bits instead of 7
00000D9A E24A                       		lsr.w	#1,d2				; Bitfield now becomes TTSSSS isntead of TTTSSSS
00000D9C                            
00000D9C                            .getnext:
00000D9C 6100 0000                  		bsr.w	EniDec_ChkGetNextByte
00000DA0 0242 000F                  		andi.w	#$F,d2				; Keep only lower nibble
00000DA4 E849                       		lsr.w	#4,d1				; Store upper nibble (max value = 7)
00000DA6 D241                       		add.w	d1,d1
00000DA8 4EFB 1000                  		jmp	EniDec_JmpTable(pc,d1.w)
00000DAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DAC                            EniDec_Sub0:
00000DAC 32CA                       		move.w	a2,(a1)+			; Write to destination
00000DAE 524A                       		addq.w	#1,a2				; Increment
00000DB0 51CA FFFA                  		dbf	d2,EniDec_Sub0			; Repeat
00000DB4 60CC                       		bra.s	EniDec_Loop
00000DB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DB6                            EniDec_Sub4:
00000DB6 32CC                       		move.w	a4,(a1)+			; Write to destination
00000DB8 51CA FFFC                  		dbf	d2,EniDec_Sub4			; Repeat
00000DBC 60C4                       		bra.s	EniDec_Loop
00000DBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DBE                            EniDec_Sub8:
00000DBE 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DC2                            
00000DC2                            .loop1:
00000DC2 32C1                       		move.w	d1,(a1)+
00000DC4 51CA FFFC                  		dbf	d2,.loop1
00000DC8 60B8                       		bra.s	EniDec_Loop
00000DCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCA                            EniDec_SubA:
00000DCA 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DCE                            
00000DCE                            .loop2:
00000DCE 32C1                       		move.w	d1,(a1)+
00000DD0 5241                       		addq.w	#1,d1
00000DD2 51CA FFFA                  		dbf	d2,.loop2
00000DD6 60AA                       		bra.s	EniDec_Loop
00000DD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DD8                            EniDec_SubC:
00000DD8 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DDC                            
00000DDC                            .loop3:
00000DDC 32C1                       		move.w	d1,(a1)+
00000DDE 5341                       		subq.w	#1,d1
00000DE0 51CA FFFA                  		dbf	d2,.loop3
00000DE4 609C                       		bra.s	EniDec_Loop
00000DE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DE6                            EniDec_SubE:
00000DE6 0C42 000F                  		cmpi.w	#$F,d2
00000DEA 6700                       		beq.s	EniDec_End
00000DEC                            
00000DEC                            .loop4:
00000DEC 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000DF0 32C1                       		move.w	d1,(a1)+
00000DF2 51CA FFF8                  		dbf	d2,.loop4
00000DF6 608A                       		bra.s	EniDec_Loop
00000DF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DF8                            EniDec_JmpTable:
00000DF8 60B2                       		bra.s	EniDec_Sub0
00000DFA 60B0                       		bra.s	EniDec_Sub0
00000DFC 60B8                       		bra.s	EniDec_Sub4
00000DFE 60B6                       		bra.s	EniDec_Sub4
00000E00 60BC                       		bra.s	EniDec_Sub8
00000E02 60C6                       		bra.s	EniDec_SubA
00000E04 60D2                       		bra.s	EniDec_SubC
00000E06 60DE                       		bra.s	EniDec_SubE
00000E08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E08                            EniDec_End:
00000E08 5348                       		subq.w	#1,a0
00000E0A 0C46 0010                  		cmpi.w	#16,d6				; Were we going to start on a completely new byte?
00000E0E 6600                       		bne.s	.norollback			; If not, branch
00000E10 5348                       		subq.w	#1,a0
00000E12                            
00000E12                            .norollback:
00000E12 3008                       		move.w	a0,d0
00000E14 E248                       		lsr.w	#1,d0				; Are we on an odd byte?
00000E16 6400                       		bcc.s	.evendest			; If not, branch
00000E18 5248                       		addq.w	#1,a0				; Ensure we're on an even byte
00000E1A                            
00000E1A                            .evendest:
00000E1A                            		pop.l	d0-d7/a1-a5
00000E1A 4CDF 3EFF                M 	movem.l	(sp)+,d0-d7/a1-a5
00000E1E 4E75                       		rts
00000E20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E20                            EniDec_GetInlineCopyVal:
00000E20 360B                       		move.w	a3,d3				; Store base tile properties
00000E22 1204                       		move.b	d4,d1
00000E24 D201                       		add.b	d1,d1
00000E26 6400                       		bcc.s	.nopriority			; If d4 was < $80
00000E28 5346                       		subq.w	#1,d6				; Get next bit number
00000E2A 0D05                       		btst	d6,d5				; Is the bit set?
00000E2C 6700                       		beq.s	.nopriority			; If not, branch
00000E2E 0043 8000                  		ori.w	#(1<<15),d3			; Set high priority bit
00000E32                            
00000E32                            .nopriority:
00000E32 D201                       		add.b	d1,d1
00000E34 6400                       		bcc.s	.nopal1				; If d4 < $40
00000E36 5346                       		subq.w	#1,d6				; Get next bit number
00000E38 0D05                       		btst	d6,d5				; Is the bit set?
00000E3A 6700                       		beq.s	.nopal1				; If not, branch
00000E3C 0643 4000                  		addi.w	#(2<<13),d3			; Set the second palette bit
00000E40                            
00000E40                            .nopal1:
00000E40 D201                       		add.b	d1,d1
00000E42 6400                       		bcc.s	.nopal0				; If d4 was < $20
00000E44 5346                       		subq.w	#1,d6				; Get next bit number
00000E46 0D05                       		btst	d6,d5				; Is the bit set?
00000E48 6700                       		beq.s	.nopal0				; If not, branch
00000E4A 0643 2000                  		addi.w	#(1<<13),d3			; Set the first palette bit
00000E4E                            
00000E4E                            .nopal0:
00000E4E D201                       		add.b	d1,d1
00000E50 6400                       		bcc.s	.noyflip			; If d4 was < $10
00000E52 5346                       		subq.w	#1,d6				; Get next bit number
00000E54 0D05                       		btst	d6,d5				; Is the bit set?
00000E56 6700                       		beq.s	.noyflip			; If not, branch
00000E58 0043 1000                  		ori.w	#(1<<12),d3			; Set the Y flip bit
00000E5C                            
00000E5C                            .noyflip:
00000E5C D201                       		add.b	d1,d1
00000E5E 6400                       		bcc.s	.noxflip			; If d4 was < 8
00000E60 5346                       		subq.w	#1,d6				; Get next bit number
00000E62 0D05                       		btst	d6,d5				; Is the bit set?
00000E64 6700                       		beq.s	.noxflip			; If not, branch
00000E66 0043 0800                  		ori.w	#(1<<11),d3			; Set the X flip bit
00000E6A                            
00000E6A                            .noxflip:
00000E6A 3205                       		move.w	d5,d1
00000E6C 3E06                       		move.w	d6,d7				; Get remaining bits
00000E6E 9E4D                       		sub.w	a5,d7				; Subtract minimum bit number
00000E70 6400                       		bcc.s	.GotEnoughBits			; If we're beyond that, branch
00000E72 3C07                       		move.w	d7,d6
00000E74 0646 0010                  		addi.w	#16,d6				; 16 bits = 2 bytes
00000E78 4447                       		neg.w	d7				; Calculate bit deficit
00000E7A EF69                       		lsl.w	d7,d1				; Make space for this many bits
00000E7C 1A10                       		move.b	(a0),d5				; Get next byte
00000E7E EF3D                       		rol.b	d7,d5				; Make the upper X bits the lower X bits
00000E80 DE47                       		add.w	d7,d7
00000E82 CA7B 7000                  		and.w	EniDec_AndVals-2(pc,d7.w),d5	; Only keep X lower bits
00000E86 D245                       		add.w	d5,d1				; Compensate for the bit deficit
00000E88                            
00000E88                            .AddBits:
00000E88 300D                       		move.w	a5,d0
00000E8A D040                       		add.w	d0,d0
00000E8C C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000E90 D243                       		add.w	d3,d1				; Add base tile properties
00000E92 1A18                       		move.b	(a0)+,d5			; Get current byte, move onto next byte
00000E94 E14D                       		lsl.w	#8,d5				; Shift up by a byte
00000E96 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000E98 4E75                       		rts
00000E9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E9A                            .GotEnoughBits:
00000E9A 6700                       		beq.s	.GotExactCount			; If the exact number of bits are leftover, branch
00000E9C EE69                       		lsr.w	d7,d1				; Remove unneeded bits
00000E9E 300D                       		move.w	a5,d0
00000EA0 D040                       		add.w	d0,d0
00000EA2 C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000EA6 D243                       		add.w	d3,d1				; Add base tile properties
00000EA8 300D                       		move.w	a5,d0				; Store number of bits used up by inline copy
00000EAA 6000                       		bra.s	EniDec_ChkGetNextByte		; Move onto next byte
00000EAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EAC                            .GotExactCount:
00000EAC 7C10                       		moveq	#16,d6				; 16 bits = 2 bytes
00000EAE 60D8                       		bra.s	.AddBits
00000EB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EB0                            EniDec_AndVals:
00000EB0 0001 0003 0007 000F        		dc.w	1, 3, 7, $F
00000EB8 001F 003F 007F 00FF        		dc.w	$1F, $3F, $7F, $FF
00000EC0 01FF 03FF 07FF 0FFF        		dc.w	$1FF, $3FF, $7FF, $FFF
00000EC8 1FFF 3FFF 7FFF FFFF        		dc.w	$1FFF, $3FFF, $7FFF, $FFFF
00000ED0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ED0                            EniDec_ChkGetNextByte:
00000ED0 9C40                       		sub.w	d0,d6
00000ED2 0C46 0009                  		cmpi.w	#9,d6
00000ED6 6400                       		bcc.s	.Done
00000ED8 5046                       		addq.w	#8,d6				; 8 bits = 1 byte
00000EDA E145                       		asl.w	#8,d5				; Shift up by a byte
00000EDC 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000EDE                            
00000EDE                            .Done:
00000EDE 4E75                       		rts
00000EE0                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000EE0                            ; Load a Kosinski Moduled Queue
00000EE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EE0                            ; PARAMETERS:
00000EE0                            ;	a3.l	- Queue pointer
00000EE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EE0                            ; RETURNS:
00000EE0                            ;	Nothing
00000EE0                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000EE0                            LoadKosMQueue:
00000EE0 3C1B                       		move.w	(a3)+,d6			; Get number of entries
00000EE2 6B00                       		bmi.s	.End				; If it's negative, branch
00000EE4                            
00000EE4                            .Queue:
00000EE4 225B                       		movea.l	(a3)+,a1			; Get art pointer
00000EE6 341B                       		move.w	(a3)+,d2			; Get VRAM address
00000EE8 6100                       		bsr.s	QueueKosMData			; Queue
00000EEA 51CE FFF8                  		dbf	d6,.Queue			; Loop
00000EEE                            
00000EEE                            .End:
00000EEE 4E75                       		rts
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ; Adds a Kosinski Moduled archive to the module queue
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ; PARAMETERS:
00000EF0                            ;	d2.w	- Destination in VRAM
00000EF0                            ;	a1.l	- Address of the archive
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            ; RETURNS:
00000EF0                            ;	Nothing
00000EF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000EF0                            QueueKosMData:
00000EF0 45F8 9994                  		lea	rKosPMList.w,a2
00000EF4 4A92                       		tst.l	(a2)				; Is the first slot free?
00000EF6 6700                       		beq.s	ProcessKosM_Init		; If it is, branch
00000EF8                            		
00000EF8                            .FindFreeSlot:
00000EF8 5C4A                       		addq.w	#6,a2				; Otherwise, check next slot
00000EFA 4A92                       		tst.l	(a2)
00000EFC 66FA                       		bne.s	.FindFreeSlot
00000EFE 24C9                       		move.l	a1,(a2)+			; Store source address
00000F00 34C2                       		move.w	d2,(a2)+			; Store destination VRAM address
00000F02 4E75                       		rts
00000F04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F04                            ; Initializes processing of the first module on the queue
00000F04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F04                            ; PARAMETERS:
00000F04                            ;	Nothing
00000F04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F04                            ; RETURNS:
00000F04                            ;	Nothing
00000F04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F04                            ProcessKosM_Init:
00000F04 3619                       		move.w	(a1)+,d3			; Get uncompressed size
00000F06 0C43 A000                  		cmpi.w	#$A000,d3
00000F0A 6600                       		bne.s	.GotSize
00000F0C 363C 8000                  		move.w	#$8000,d3			; $A000 means $8000 for some reason
00000F10                            
00000F10                            .GotSize:
00000F10 E24B                       		lsr.w	#1,d3
00000F12 3003                       		move.w	d3,d0
00000F14 EB58                       		rol.w	#5,d0
00000F16 0240 001F                  		andi.w	#$1F,d0				; Get number of complete modules
00000F1A 11C0 9990                  		move.b	d0,rKosPMMods.w
00000F1E 0283 0000 07FF             		andi.l	#$7FF,d3			; Get size of last module in words
00000F24 6600                       		bne.s	.GotLeftover			; Branch if it's non-zero
00000F26 5338 9990                  		subq.b	#1,rKosPMMods.w		; Otherwise decrement the number of modules
00000F2A 263C 0000 0800             		move.l	#$800,d3			; And take the size of the last module to be $800 words
00000F30                            
00000F30                            .GotLeftover:
00000F30 31C3 9992                  		move.w	d3,rKosPMLastSz.w
00000F34 31C2 9998                  		move.w	d2,rKosPMDest.w
00000F38 21C9 9994                  		move.l	a1,rKosPMSrc.w
00000F3C 5238 9990                  		addq.b	#1,rKosPMMods.w		; Store total number of modules
00000F40 4E75                       		rts
00000F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F42                            ; Processes the first module on the queue
00000F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F42                            ; PARAMETERS:
00000F42                            ;	Nothing
00000F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F42                            ; RETURNS:
00000F42                            ;	Nothing
00000F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F42                            ProcessKosM:
00000F42 4A38 9990                  		tst.b	rKosPMMods.w
00000F46 6600                       		bne.s	.ModulesLeft
00000F48                            
00000F48                            .Done:
00000F48 4E75                       		rts
00000F4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4A                            .ModulesLeft:
00000F4A 6B00                       		bmi.s	.DecompressionStarted
00000F4C 0C78 0004 994E             		cmpi.w	#(rKosPList_End-rKosPList)/8,rKosPCnt.w
00000F52 64F4                       		bhs.s	.Done				; Branch if the Kosinski decompression queue is full
00000F54 2278 9994                  		movea.l	rKosPMList.w,a1
00000F58 45F8 8000                  		lea	rKosPBuf.w,a2
00000F5C 6100 0000                  		bsr.w	QueueKosData			; Add current module to decompression queue
00000F60 0038 0080 9990             		ori.b	#$80,rKosPMMods.w		; And set bit to signify decompression in progress
00000F66 4E75                       		rts
00000F68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F68                            .DecompressionStarted:
00000F68 4A78 994E                  		tst.w	rKosPCnt.w
00000F6C 66DA                       		bne.s	.Done				; Branch if the decompression isn't complete
00000F6E                            
00000F6E                            		; Otherwise, DMA the decompressed data to VRAM
00000F6E 0238 007F 9990             		andi.b	#$7F,rKosPMMods.w
00000F74 263C 0000 0800             		move.l	#$1000/2,d3
00000F7A 5338 9990                  		subq.b	#1,rKosPMMods.w
00000F7E 6600                       		bne.s	.Skip				; Branch if it isn't the last module
00000F80 3638 9992                  		move.w	rKosPMLastSz.w,d3
00000F84                            
00000F84                            .Skip:
00000F84 3438 9998                  		move.w	rKosPMDest.w,d2
00000F88 3002                       		move.w	d2,d0
00000F8A D043                       		add.w	d3,d0
00000F8C D043                       		add.w	d3,d0
00000F8E 31C0 9998                  		move.w	d0,rKosPMDest.w		; Set new destination
00000F92 2038 9994                  		move.l	rKosPMList.w,d0
00000F96 2238 9970                  		move.l	rKosPList.w,d1
00000F9A 9081                       		sub.l	d1,d0
00000F9C 0280 0000 000F             		andi.l	#$F,d0
00000FA2 D280                       		add.l	d0,d1				; Round to the nearest $10 boundary
00000FA4 21C1 9994                  		move.l	d1,rKosPMList.w		; And set new source
00000FA8 223C FFFF 8000             		move.l	#rKosPBuf,d1
00000FAE 6100 F2D8                  		bsr.w	QueueDMATransfer
00000FB2 4A38 9990                  		tst.b	rKosPMMods.w
00000FB6 6600 0000                  		bne.w	.Exit				; Return if this wasn't the last module
00000FBA 41F8 9994                  		lea	rKosPMList.w,a0
00000FBE 43F8 999A                  		lea	(rKosPMList+6).w,a1
00000FC2                            	rept (rKosPMList_End-rKosPMList)/6-1
00000FC2                            		move.l	(a1)+,(a0)+			; Otherwise, shift all entries up
00000FC2                            		move.w	(a1)+,(a0)+
00000FC2                            	endr
00000FC2 20D9                     M 	move.l	(a1)+,(a0)+
00000FC4 30D9                     M 	move.w	(a1)+,(a0)+
00000FC6 20D9                     M 	move.l	(a1)+,(a0)+
00000FC8 30D9                     M 	move.w	(a1)+,(a0)+
00000FCA 20D9                     M 	move.l	(a1)+,(a0)+
00000FCC 30D9                     M 	move.w	(a1)+,(a0)+
00000FCE 20D9                     M 	move.l	(a1)+,(a0)+
00000FD0 30D9                     M 	move.w	(a1)+,(a0)+
00000FD2 20D9                     M 	move.l	(a1)+,(a0)+
00000FD4 30D9                     M 	move.w	(a1)+,(a0)+
00000FD6 20D9                     M 	move.l	(a1)+,(a0)+
00000FD8 30D9                     M 	move.w	(a1)+,(a0)+
00000FDA 20D9                     M 	move.l	(a1)+,(a0)+
00000FDC 30D9                     M 	move.w	(a1)+,(a0)+
00000FDE 20D9                     M 	move.l	(a1)+,(a0)+
00000FE0 30D9                     M 	move.w	(a1)+,(a0)+
00000FE2 20D9                     M 	move.l	(a1)+,(a0)+
00000FE4 30D9                     M 	move.w	(a1)+,(a0)+
00000FE6 20D9                     M 	move.l	(a1)+,(a0)+
00000FE8 30D9                     M 	move.w	(a1)+,(a0)+
00000FEA 20D9                     M 	move.l	(a1)+,(a0)+
00000FEC 30D9                     M 	move.w	(a1)+,(a0)+
00000FEE 20D9                     M 	move.l	(a1)+,(a0)+
00000FF0 30D9                     M 	move.w	(a1)+,(a0)+
00000FF2 20D9                     M 	move.l	(a1)+,(a0)+
00000FF4 30D9                     M 	move.w	(a1)+,(a0)+
00000FF6 20D9                     M 	move.l	(a1)+,(a0)+
00000FF8 30D9                     M 	move.w	(a1)+,(a0)+
00000FFA 20D9                     M 	move.l	(a1)+,(a0)+
00000FFC 30D9                     M 	move.w	(a1)+,(a0)+
00000FFE 20D9                     M 	move.l	(a1)+,(a0)+
00001000 30D9                     M 	move.w	(a1)+,(a0)+
00001002 20D9                     M 	move.l	(a1)+,(a0)+
00001004 30D9                     M 	move.w	(a1)+,(a0)+
00001006 20D9                     M 	move.l	(a1)+,(a0)+
00001008 30D9                     M 	move.w	(a1)+,(a0)+
0000100A 20D9                     M 	move.l	(a1)+,(a0)+
0000100C 30D9                     M 	move.w	(a1)+,(a0)+
0000100E 20D9                     M 	move.l	(a1)+,(a0)+
00001010 30D9                     M 	move.w	(a1)+,(a0)+
00001012 20D9                     M 	move.l	(a1)+,(a0)+
00001014 30D9                     M 	move.w	(a1)+,(a0)+
00001016 20D9                     M 	move.l	(a1)+,(a0)+
00001018 30D9                     M 	move.w	(a1)+,(a0)+
0000101A 20D9                     M 	move.l	(a1)+,(a0)+
0000101C 30D9                     M 	move.w	(a1)+,(a0)+
0000101E 20D9                     M 	move.l	(a1)+,(a0)+
00001020 30D9                     M 	move.w	(a1)+,(a0)+
00001022 20D9                     M 	move.l	(a1)+,(a0)+
00001024 30D9                     M 	move.w	(a1)+,(a0)+
00001026 20D9                     M 	move.l	(a1)+,(a0)+
00001028 30D9                     M 	move.w	(a1)+,(a0)+
0000102A 20D9                     M 	move.l	(a1)+,(a0)+
0000102C 30D9                     M 	move.w	(a1)+,(a0)+
0000102E 20D9                     M 	move.l	(a1)+,(a0)+
00001030 30D9                     M 	move.w	(a1)+,(a0)+
00001032 20D9                     M 	move.l	(a1)+,(a0)+
00001034 30D9                     M 	move.w	(a1)+,(a0)+
00001036 20D9                     M 	move.l	(a1)+,(a0)+
00001038 30D9                     M 	move.w	(a1)+,(a0)+
0000103A 20D9                     M 	move.l	(a1)+,(a0)+
0000103C 30D9                     M 	move.w	(a1)+,(a0)+
0000103E 4298                       		clr.l	(a0)+				; And mark the last slot as free
00001040 4258                       		clr.w	(a0)+
00001042 2038 9994                  		move.l	rKosPMList.w,d0
00001046 6700                       		beq.s	.Exit				; Return if the queue is now empty
00001048 2240                       		movea.l	d0,a1
0000104A 3438 9998                  		move.w	rKosPMDest.w,d2
0000104E 6000 FEB4                  		bra.w	ProcessKosM_Init
00001052                            
00001052                            .Exit:
00001052 4E75                       		rts
00001054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001054                            ; Adds Kosinski-compressed data to the decompression queue
00001054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001054                            ; PARAMETERS:
00001054                            ;	a1.l	- Compressed data address
00001054                            ;	a2.l	- Decompression destination in RAM
00001054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001054                            ; RETURNS:
00001054                            ;	Nothing
00001054                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001054                            QueueKosData:
00001054 3038 994E                  		move.w	rKosPCnt.w,d0
00001058 E748                       		lsl.w	#3,d0
0000105A 47F8 9970                  		lea	rKosPList.w,a3
0000105E 2789 0000                  		move.l	a1,(a3,d0.w)			; Store source
00001062 278A 0004                  		move.l	a2,4(a3,d0.w)			; Store destination
00001066 5278 994E                  		addq.w	#1,rKosPCnt.w
0000106A 4E75                       		rts
0000106C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000106C                            ; Checks if V-INT occured in the middle of Kosinski queue processing and stores the location from which processing is to resume if it did
0000106C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000106C                            ; PARAMETERS:
0000106C                            ;	Nothing
0000106C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000106C                            ; RETURNS:
0000106C                            ;	Nothing
0000106C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000106C                            SetKosBookmark:
0000106C 4A78 994E                  		tst.w	rKosPCnt.w
00001070 6A00                       		bpl.s	.Done				; Branch if a decompression wasn't in progress
00001072 202F 0042                  		move.l	$42(sp),d0			; Check address V-INT is supposed to rte to
00001076 0C80 0000 0000             		cmpi.l	#ProcessKos_Main,d0
0000107C 6500                       		bcs.s	.Done
0000107E 0C80 0000 0000             		cmpi.l	#ProcessKos_Done,d0
00001084 6400                       		bcc.s	.Done
00001086 21EF 0042 996C             		move.l	$42(sp),rKosPBookmark.w
0000108C 2F7C 0000 0000 0042        		move.l	#BackupKosRegs,$42(sp)		; Force V-INT to rte here instead if needed
00001094                            
00001094                            .Done:
00001094 4E75                       		rts
00001096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001096                            ; Processes the first entry in the Kosinski decompression queue
00001096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001096                            ; PARAMETERS:
00001096                            ;	Nothing
00001096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001096                            ; RETURNS:
00001096                            ;	Nothing
00001096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001096                            ProcessKos:
00001096 4A78 994E                  		tst.w	rKosPCnt.w
0000109A 6700 0000                  		beq.w	ProcessKos_Done
0000109E 6B00 0000                  		bmi.w	RestoreKosBookmark		; Branch if a decompression was interrupted by V-int
000010A2                            
000010A2                            ProcessKos_Main:
000010A2 0078 8000 994E             		ori.w	#$8000,rKosPCnt.w	; Set sign bit to signify decompression in progress
000010A8 2078 9970                  		movea.l	rKosPList.w,a0
000010AC 2278 9974                  		movea.l	rKosPDest.w,a1
000010B0                            		
000010B0                            		; What follows is identical to the normal Kosinski decompressor
000010B0 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
000010B2 7000                       		moveq	#0,d0
000010B4 7200                       		moveq	#0,d1
000010B6 49FA FBAA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
000010BA 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
000010BC 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
000010BE 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
000010C2 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
000010C6 7407                       		moveq	#7,d2				; Set repeat count to 8.
000010C8 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
000010CA 6000                       		bra.s	.FetchNewCode
000010CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010CC                            .FetchCodeLoop:
000010CC                            		; Code 1 (Uncompressed byte).
000010CC                            		_Kos_RunBitStream
000010CC 51CA 0000                M 	dbra	d2,.skip_47
000010D0 7407                     M 	moveq	#7,d2
000010D2 1001                     M 	move.b	d1,d0
000010D4 4643                     M 	not.w	d3
000010D6 6600                     M 	bne.s	.skip_47
000010D8 1018                     M 	move.b	(a0)+,d0
000010DA 1218                     M 	move.b	(a0)+,d1
000010DC 1034 0000                M 	move.b	(a4,d0.w),d0
000010E0 1234 1000                M 	move.b	(a4,d1.w),d1
000010E4                          M .skip_47:
000010E4 12D8                       		move.b	(a0)+,(a1)+
000010E6                            
000010E6                            .FetchNewCode:
000010E6                            		_Kos_ReadBit
000010E6 D000                     M 	add.b	d0,d0
000010E8 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
000010EA                            
000010EA                            		; Codes 00 and 01.
000010EA 7AFF                       		moveq	#-1,d5
000010EC 4BD1                       		lea	(a1),a5
000010EE                            		_Kos_RunBitStream
000010EE 51CA 0000                M 	dbra	d2,.skip_49
000010F2 7407                     M 	moveq	#7,d2
000010F4 1001                     M 	move.b	d1,d0
000010F6 4643                     M 	not.w	d3
000010F8 6600                     M 	bne.s	.skip_49
000010FA 1018                     M 	move.b	(a0)+,d0
000010FC 1218                     M 	move.b	(a0)+,d1
000010FE 1034 0000                M 	move.b	(a4,d0.w),d0
00001102 1234 1000                M 	move.b	(a4,d1.w),d1
00001106                          M .skip_49:
00001106                            		_Kos_ReadBit
00001106 D000                     M 	add.b	d0,d0
00001108 6500 0000                  		bcs.w	.Code_01
0000110C                            
0000110C                            		; Code 00 (Dictionary ref. short).
0000110C                            		_Kos_RunBitStream
0000110C 51CA 0000                M 	dbra	d2,.skip_51
00001110 7407                     M 	moveq	#7,d2
00001112 1001                     M 	move.b	d1,d0
00001114 4643                     M 	not.w	d3
00001116 6600                     M 	bne.s	.skip_51
00001118 1018                     M 	move.b	(a0)+,d0
0000111A 1218                     M 	move.b	(a0)+,d1
0000111C 1034 0000                M 	move.b	(a4,d0.w),d0
00001120 1234 1000                M 	move.b	(a4,d1.w),d1
00001124                          M .skip_51:
00001124                            		_Kos_ReadBit
00001124 D000                     M 	add.b	d0,d0
00001126 6500                       		bcs.s	.Copy45
00001128                            		_Kos_RunBitStream
00001128 51CA 0000                M 	dbra	d2,.skip_53
0000112C 7407                     M 	moveq	#7,d2
0000112E 1001                     M 	move.b	d1,d0
00001130 4643                     M 	not.w	d3
00001132 6600                     M 	bne.s	.skip_53
00001134 1018                     M 	move.b	(a0)+,d0
00001136 1218                     M 	move.b	(a0)+,d1
00001138 1034 0000                M 	move.b	(a4,d0.w),d0
0000113C 1234 1000                M 	move.b	(a4,d1.w),d1
00001140                          M .skip_53:
00001140                            		_Kos_ReadBit
00001140 D000                     M 	add.b	d0,d0
00001142 6500                       		bcs.s	.Copy3
00001144                            		_Kos_RunBitStream
00001144 51CA 0000                M 	dbra	d2,.skip_55
00001148 7407                     M 	moveq	#7,d2
0000114A 1001                     M 	move.b	d1,d0
0000114C 4643                     M 	not.w	d3
0000114E 6600                     M 	bne.s	.skip_55
00001150 1018                     M 	move.b	(a0)+,d0
00001152 1218                     M 	move.b	(a0)+,d1
00001154 1034 0000                M 	move.b	(a4,d0.w),d0
00001158 1234 1000                M 	move.b	(a4,d1.w),d1
0000115C                          M .skip_55:
0000115C 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000115E DAC5                       		adda.w	d5,a5
00001160 12DD                       		move.b	(a5)+,(a1)+
00001162 12DD                       		move.b	(a5)+,(a1)+
00001164 6080                       		bra.s	.FetchNewCode
00001166                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001166                            .Copy3:
00001166                            		_Kos_RunBitStream
00001166 51CA 0000                M 	dbra	d2,.skip_56
0000116A 7407                     M 	moveq	#7,d2
0000116C 1001                     M 	move.b	d1,d0
0000116E 4643                     M 	not.w	d3
00001170 6600                     M 	bne.s	.skip_56
00001172 1018                     M 	move.b	(a0)+,d0
00001174 1218                     M 	move.b	(a0)+,d1
00001176 1034 0000                M 	move.b	(a4,d0.w),d0
0000117A 1234 1000                M 	move.b	(a4,d1.w),d1
0000117E                          M .skip_56:
0000117E 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00001180 DAC5                       		adda.w	d5,a5
00001182 12DD                       		move.b	(a5)+,(a1)+
00001184 12DD                       		move.b	(a5)+,(a1)+
00001186 12DD                       		move.b	(a5)+,(a1)+
00001188 6000 FF5C                  		bra.w	.FetchNewCode
0000118C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000118C                            .Copy45:
0000118C                            		_Kos_RunBitStream
0000118C 51CA 0000                M 	dbra	d2,.skip_57
00001190 7407                     M 	moveq	#7,d2
00001192 1001                     M 	move.b	d1,d0
00001194 4643                     M 	not.w	d3
00001196 6600                     M 	bne.s	.skip_57
00001198 1018                     M 	move.b	(a0)+,d0
0000119A 1218                     M 	move.b	(a0)+,d1
0000119C 1034 0000                M 	move.b	(a4,d0.w),d0
000011A0 1234 1000                M 	move.b	(a4,d1.w),d1
000011A4                          M .skip_57:
000011A4                            		_Kos_ReadBit
000011A4 D000                     M 	add.b	d0,d0
000011A6 6500                       		bcs.s	.Copy5
000011A8                            		_Kos_RunBitStream
000011A8 51CA 0000                M 	dbra	d2,.skip_59
000011AC 7407                     M 	moveq	#7,d2
000011AE 1001                     M 	move.b	d1,d0
000011B0 4643                     M 	not.w	d3
000011B2 6600                     M 	bne.s	.skip_59
000011B4 1018                     M 	move.b	(a0)+,d0
000011B6 1218                     M 	move.b	(a0)+,d1
000011B8 1034 0000                M 	move.b	(a4,d0.w),d0
000011BC 1234 1000                M 	move.b	(a4,d1.w),d1
000011C0                          M .skip_59:
000011C0 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011C2 DAC5                       		adda.w	d5,a5
000011C4 12DD                       		move.b	(a5)+,(a1)+
000011C6 12DD                       		move.b	(a5)+,(a1)+
000011C8 12DD                       		move.b	(a5)+,(a1)+
000011CA 12DD                       		move.b	(a5)+,(a1)+
000011CC 6000 FF18                  		bra.w	.FetchNewCode
000011D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011D0                            .Copy5:
000011D0                            		_Kos_RunBitStream
000011D0 51CA 0000                M 	dbra	d2,.skip_60
000011D4 7407                     M 	moveq	#7,d2
000011D6 1001                     M 	move.b	d1,d0
000011D8 4643                     M 	not.w	d3
000011DA 6600                     M 	bne.s	.skip_60
000011DC 1018                     M 	move.b	(a0)+,d0
000011DE 1218                     M 	move.b	(a0)+,d1
000011E0 1034 0000                M 	move.b	(a4,d0.w),d0
000011E4 1234 1000                M 	move.b	(a4,d1.w),d1
000011E8                          M .skip_60:
000011E8 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011EA DAC5                       		adda.w	d5,a5
000011EC 12DD                       		move.b	(a5)+,(a1)+
000011EE 12DD                       		move.b	(a5)+,(a1)+
000011F0 12DD                       		move.b	(a5)+,(a1)+
000011F2 12DD                       		move.b	(a5)+,(a1)+
000011F4 12DD                       		move.b	(a5)+,(a1)+
000011F6 6000 FEEE                  		bra.w	.FetchNewCode
000011FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011FA                            .Code_01:
000011FA 7800                       		moveq	#0,d4				; d4 will contain copy count.
000011FC                            		; Code 01 (Dictionary ref. long / special).
000011FC                            		_Kos_RunBitStream
000011FC 51CA 0000                M 	dbra	d2,.skip_61
00001200 7407                     M 	moveq	#7,d2
00001202 1001                     M 	move.b	d1,d0
00001204 4643                     M 	not.w	d3
00001206 6600                     M 	bne.s	.skip_61
00001208 1018                     M 	move.b	(a0)+,d0
0000120A 1218                     M 	move.b	(a0)+,d1
0000120C 1034 0000                M 	move.b	(a4,d0.w),d0
00001210 1234 1000                M 	move.b	(a4,d1.w),d1
00001214                          M .skip_61:
00001214 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001216 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001218 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
0000121A EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
0000121C 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000121E C847                       		and.w	d7,d4				; d4 = %00000CCC.
00001220 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00001222                            
00001222                            		; special mode (extended counter)
00001222 1818                       		move.b	(a0)+,d4			; Read cnt
00001224 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00001226 5304                       		subq.b	#1,d4
00001228 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
0000122C                            
0000122C DAC5                       		adda.w	d5,a5
0000122E 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00001230 3C04                       		move.w	d4,d6
00001232 4646                       		not.w	d6
00001234 CC47                       		and.w	d7,d6
00001236 DC46                       		add.w	d6,d6
00001238 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
0000123A 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
0000123E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000123E                            .LargeCopy:
0000123E                            	rept (1<<_Kos_LoopUnroll)
0000123E                            		move.b	(a5)+,(a1)+
0000123E                            	endr
0000123E 12DD                     M 	move.b	(a5)+,(a1)+
00001240 12DD                     M 	move.b	(a5)+,(a1)+
00001242 12DD                     M 	move.b	(a5)+,(a1)+
00001244 12DD                     M 	move.b	(a5)+,(a1)+
00001246 12DD                     M 	move.b	(a5)+,(a1)+
00001248 12DD                     M 	move.b	(a5)+,(a1)+
0000124A 12DD                     M 	move.b	(a5)+,(a1)+
0000124C 12DD                     M 	move.b	(a5)+,(a1)+
0000124E 51CC FFEE                  		dbra	d4,.LargeCopy
00001252 6000 FE92                  		bra.w	.FetchNewCode
00001256                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001256                            .StreamCopy:
00001256 DAC5                       		adda.w	d5,a5
00001258 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000125A BF44                       		eor.w	d7,d4
0000125C D844                       		add.w	d4,d4
0000125E 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00001262                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001262                            .MediumCopy:
00001262                            	rept 8
00001262                            		move.b	(a5)+,(a1)+
00001262                            	endr
00001262 12DD                     M 	move.b	(a5)+,(a1)+
00001264 12DD                     M 	move.b	(a5)+,(a1)+
00001266 12DD                     M 	move.b	(a5)+,(a1)+
00001268 12DD                     M 	move.b	(a5)+,(a1)+
0000126A 12DD                     M 	move.b	(a5)+,(a1)+
0000126C 12DD                     M 	move.b	(a5)+,(a1)+
0000126E 12DD                     M 	move.b	(a5)+,(a1)+
00001270 12DD                     M 	move.b	(a5)+,(a1)+
00001272 6000 FE72                  		bra.w	.FetchNewCode
00001276                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001276                            .Quit:	
00001276 21C8 9970                  		move.l	a0,rKosPList.w
0000127A 21C9 9974                  		move.l	a1,rKosPDest.w
0000127E 0278 7FFF 994E             		andi.w	#$7FFF,rKosPCnt.w		; Clear decompression in progress bit
00001284 5378 994E                  		subq.w	#1,rKosPCnt.w
00001288 6700                       		beq.s	ProcessKos_Done			; Branch if there aren't any entries remaining in the queue
0000128A 41F8 9970                  		lea	rKosPList.w,a0
0000128E 43F8 9978                  		lea	(rKosPList+8).w,a1		; Otherwise, shift all entries up
00001292                            	rept (rKosPList_End-rKosPList)/8-1
00001292                            		move.l	(a1)+,(a0)+
00001292                            		move.l	(a1)+,(a0)+
00001292                            	endr
00001292 20D9                     M 	move.l	(a1)+,(a0)+
00001294 20D9                     M 	move.l	(a1)+,(a0)+
00001296 20D9                     M 	move.l	(a1)+,(a0)+
00001298 20D9                     M 	move.l	(a1)+,(a0)+
0000129A 20D9                     M 	move.l	(a1)+,(a0)+
0000129C 20D9                     M 	move.l	(a1)+,(a0)+
0000129E                            
0000129E                            ProcessKos_Done:
0000129E 4E75                       		rts
000012A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012A0                            RestoreKosBookmark:
000012A0 4CB8 007F 9950             		movem.w	rKosPRegs.w,d0-d6
000012A6 4CF8 2300 995E             		movem.l	(rKosPRegs+2*7).w,a0-a1/a5
000012AC 2F38 996C                  		move.l	rKosPBookmark.w,-(sp)
000012B0 3F38 996A                  		move.w	rKosPSR.w,-(sp)
000012B4 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
000012B6 49FA F9AA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT poiner
000012BA 4E73                       		rte
000012BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012BC                            BackupKosRegs:
000012BC 40F8 996A                  		move	sr,rKosPSR.w
000012C0 48B8 007F 9950             		movem.w	d0-d6,rKosPRegs.w
000012C6 48F8 2300 995E             		movem.l	a0-a1/a5,(rKosPRegs+2*7).w
000012CC 4E75                       		rts
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; Load Kosinski compressed art into VRAM
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; PARAMETERS:
000012CE                            ;	a0.l	- Source address
000012CE                            ;	a1.l	- Destination address
000012CE                            ;	a2.w	- VRAM address
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            ; RETURNS:
000012CE                            ;	Nothing
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            LoadKosArt:
000012CE 2649                       		movea.l	a1,a3				; Save destination address
000012D0 6100 F7C8                  		bsr.w	KosDec				; Decompress the art
000012D4                            
000012D4 93CB                       		suba.l	a3,a1				; Get size of decompressed art
000012D6 3609                       		move.w	a1,d3				; ''
000012D8 E24B                       		lsr.w	#1,d3				; Divide by 2 for DMA
000012DA 220B                       		move.l	a3,d1				; Use destination address for DMA source
000012DC 340A                       		move.w	a2,d2				; Get destination VRAM address
000012DE 6000 EFA8                  		bra.w	QueueDMATransfer		; Queue a DMA transfer
000012E2                            ; =========================================================================================================================================================
000012E2                            		include	"_LIB_/Math.asm"		; Math functions
000012E2                            ; =========================================================================================================================================================
000012E2                            ; Mighty The Armadillo in PRISM PARADISE
000012E2                            ; By Nat The Porcupine 2021
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            ; Math functions
000012E2                            ; =========================================================================================================================================================
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            ; Get a pseudo random number
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            ; PARAMETERS:
000012E2                            ;	Nothing
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            ; RETURNS:
000012E2                            ;	d0.l	- Random number
000012E2                            ;	d1.l	- New seed
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            RandomNumber:
000012E2 2238 C760                  		move.l	rRNGSeed.w,d1			; Get seed
000012E6 6600                       		bne.s	.Generate			; If it's already initialized, branch
000012E8 223C 2A6D 365B             		move.l	#$2A6D365B,d1			; Initialize the seed
000012EE                            
000012EE                            .Generate:
000012EE 2001                       		move.l	d1,d0				; Do a bunch of calculations to get a "random" number
000012F0 E581                       		asl.l	#2,d1				; ''
000012F2 D280                       		add.l	d0,d1				; ''
000012F4 E781                       		asl.l	#3,d1				; ''
000012F6 D280                       		add.l	d0,d1				; ''
000012F8 3001                       		move.w	d1,d0				; ''
000012FA 4841                       		swap	d1				; ''
000012FC D041                       		add.w	d1,d0				; ''
000012FE 3200                       		move.w	d0,d1				; ''
00001300 4841                       		swap	d1				; ''
00001302 21C1 C760                  		move.l	d1,rRNGSeed.w			; Set new seed
00001306 4E75                       		rts
00001308                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001308                            ; Calculate the sine and cosine of an angle
00001308                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001308                            ; PARAMETERS:
00001308                            ;	d0.b	- Angle
00001308                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001308                            ; RETURNS:
00001308                            ;	d0.w	- Sine value
00001308                            ;	d1.w	- Cosine value	
00001308                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001308                            CalcSine:
00001308 0240 00FF                  		andi.w	#$FF,d0				; Only allow angles 0-$FF
0000130C 5040                       		addq.w	#8,d0				; Turn into offset
0000130E D040                       		add.w	d0,d0				; ''
00001310 323B 0000                  		move.w	SineTable-$10+$80(pc,d0.w),d1	; Get cosine value
00001314 303B 0000                  		move.w	SineTable-$10(pc,d0.w),d0	; Get sine value
00001318 4E75                       		rts
0000131A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000131A                            SineTable:
0000131A 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
0000133A 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
0000135A 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
0000137A 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
0000139A 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
000013BA 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
000013DA 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
000013FA 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
0000141A 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
0000143A FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
0000145A FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
0000147A FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
0000149A FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
000014BA FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
000014DA FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
000014FA FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
0000151A 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
0000153A 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
0000155A 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
0000157A 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
0000159A 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
000015BA 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
000015DA 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
000015FA 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
0000161A 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
0000163A FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
0000165A FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
0000167A FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
0000169A FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
000016BA FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
000016DA FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
000016FA FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
0000171A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000171A                            ; Calculate the arctangent of y/x
0000171A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000171A                            ; PARAMETERS:
0000171A                            ;	d1.w	- X position
0000171A                            ;	d2.w	- Y position
0000171A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000171A                            ; RETURNS:
0000171A                            ;	d0.w	- The angle
0000171A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000171A                            CalcArcTan:
0000171A                            		push.l	d3-d4
0000171A 48E7 1800                M 	movem.l	d3-d4,-(sp)
0000171E 7600                       		moveq	#0,d3
00001720 7800                       		moveq	#0,d4
00001722 3601                       		move.w	d1,d3
00001724 3802                       		move.w	d2,d4
00001726 8843                       		or.w	d3,d4
00001728 6700                       		beq.s	GetArcTan_Zero			; Special case when both x and y are zero
0000172A 3802                       		move.w	d2,d4
0000172C                            		
0000172C 4A43                       		tst.w	d3
0000172E 6A00                       		bpl.s	.NotNeg
00001730 4443                       		neg.w	d3
00001732                            
00001732                            .NotNeg:
00001732 4A44                       		tst.w	d4
00001734 6A00                       		bpl.s	.NotNeg2
00001736 4444                       		neg.w	d4
00001738                            
00001738                            .NotNeg2:
00001738 B843                       		cmp.w	d3,d4
0000173A 6400                       		bhs.s	.NotGreater			; If |y| >= |x|
0000173C E18C                       		lsl.l	#8,d4
0000173E 88C3                       		divu.w	d3,d4
00001740 7000                       		moveq	#0,d0
00001742 103B 4000                  		move.b	ArcTanTable(pc,d4.w),d0
00001746 6000                       		bra.s	.Skip
00001748                            
00001748                            .NotGreater:
00001748 E18B                       		lsl.l	#8,d3
0000174A 86C4                       		divu.w	d4,d3
0000174C 7040                       		moveq	#$40,d0
0000174E 903B 3000                  		sub.b	ArcTanTable(pc,d3.w),d0		; arctan(y/x) = 90 - arctan(x/y)
00001752                            
00001752                            .Skip:
00001752 4A41                       		tst.w	d1
00001754 6A00                       		bpl.s	.Skip2
00001756 4440                       		neg.w	d0
00001758 0640 0080                  		addi.w	#$80,d0				; Place angle in appropriate quadrant
0000175C                            
0000175C                            .Skip2:
0000175C 4A42                       		tst.w	d2
0000175E 6A00                       		bpl.s	.Skip3
00001760 4440                       		neg.w	d0
00001762 0640 0100                  		addi.w	#$100,d0			; Place angle in appropriate quadrant
00001766                            
00001766                            .Skip3:
00001766                            		pop.l	d3-d4
00001766 4CDF 0018                M 	movem.l	(sp)+,d3-d4
0000176A 4E75                       		rts
0000176C                            
0000176C                            GetArcTan_Zero:
0000176C 303C 0040                  		move.w	#$40,d0				; Angle = 90 degrees
00001770                            		pop.l	d3-d4
00001770 4CDF 0018                M 	movem.l	(sp)+,d3-d4
00001774 4E75                       		rts
00001776                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001776                            ArcTanTable:
00001776 0000 0000 0101             		dc.b	$00, $00, $00, $00, $01, $01
0000177C 0101 0101 0202             		dc.b	$01, $01, $01, $01, $02, $02
00001782 0202 0202 0303             		dc.b	$02, $02, $02, $02, $03, $03
00001788 0303 0303 0304             		dc.b	$03, $03, $03, $03, $03, $04
0000178E 0404 0404 0405             		dc.b	$04, $04, $04, $04, $04, $05
00001794 0505 0505 0506             		dc.b	$05, $05, $05, $05, $05, $06
0000179A 0606 0606 0606             		dc.b	$06, $06, $06, $06, $06, $06
000017A0 0707 0707 0707             		dc.b	$07, $07, $07, $07, $07, $07
000017A6 0808 0808 0808             		dc.b	$08, $08, $08, $08, $08, $08
000017AC 0809 0909 0909             		dc.b	$08, $09, $09, $09, $09, $09
000017B2 090A 0A0A 0A0A             		dc.b	$09, $0A, $0A, $0A, $0A, $0A
000017B8 0A0A 0B0B 0B0B             		dc.b	$0A, $0A, $0B, $0B, $0B, $0B
000017BE 0B0B 0B0C 0C0C             		dc.b	$0B, $0B, $0B, $0C, $0C, $0C
000017C4 0C0C 0C0C 0D0D             		dc.b	$0C, $0C, $0C, $0C, $0D, $0D
000017CA 0D0D 0D0D 0D0E             		dc.b	$0D, $0D, $0D, $0D, $0D, $0E
000017D0 0E0E 0E0E 0E0E             		dc.b	$0E, $0E, $0E, $0E, $0E, $0E
000017D6 0F0F 0F0F 0F0F             		dc.b	$0F, $0F, $0F, $0F, $0F, $0F
000017DC 0F10 1010 1010             		dc.b	$0F, $10, $10, $10, $10, $10
000017E2 1010 1111 1111             		dc.b	$10, $10, $11, $11, $11, $11
000017E8 1111 1111 1212             		dc.b	$11, $11, $11, $11, $12, $12
000017EE 1212 1212 1213             		dc.b	$12, $12, $12, $12, $12, $13
000017F4 1313 1313 1313             		dc.b	$13, $13, $13, $13, $13, $13
000017FA 1314 1414 1414             		dc.b	$13, $14, $14, $14, $14, $14
00001800 1414 1415 1515             		dc.b	$14, $14, $14, $15, $15, $15
00001806 1515 1515 1515             		dc.b	$15, $15, $15, $15, $15, $15
0000180C 1616 1616 1616             		dc.b	$16, $16, $16, $16, $16, $16
00001812 1616 1717 1717             		dc.b	$16, $16, $17, $17, $17, $17
00001818 1717 1717 1718             		dc.b	$17, $17, $17, $17, $17, $18
0000181E 1818 1818 1818             		dc.b	$18, $18, $18, $18, $18, $18
00001824 1818 1919 1919             		dc.b	$18, $18, $19, $19, $19, $19
0000182A 1919 1919 1919             		dc.b	$19, $19, $19, $19, $19, $19
00001830 1A1A 1A1A 1A1A             		dc.b	$1A, $1A, $1A, $1A, $1A, $1A
00001836 1A1A 1A1B 1B1B             		dc.b	$1A, $1A, $1A, $1B, $1B, $1B
0000183C 1B1B 1B1B 1B1B             		dc.b	$1B, $1B, $1B, $1B, $1B, $1B
00001842 1B1C 1C1C 1C1C             		dc.b	$1B, $1C, $1C, $1C, $1C, $1C
00001848 1C1C 1C1C 1C1C             		dc.b	$1C, $1C, $1C, $1C, $1C, $1C
0000184E 1D1D 1D1D 1D1D             		dc.b	$1D, $1D, $1D, $1D, $1D, $1D
00001854 1D1D 1D1D 1D1E             		dc.b	$1D, $1D, $1D, $1D, $1D, $1E
0000185A 1E1E 1E1E 1E1E             		dc.b	$1E, $1E, $1E, $1E, $1E, $1E
00001860 1E1E 1E1E 1F1F             		dc.b	$1E, $1E, $1E, $1E, $1F, $1F
00001866 1F1F 1F1F 1F1F             		dc.b	$1F, $1F, $1F, $1F, $1F, $1F
0000186C 1F1F 1F1F 2020             		dc.b	$1F, $1F, $1F, $1F, $20, $20
00001872 2020 2020 2000             		dc.b	$20, $20, $20, $20, $20, $00
00001878                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001878                            ; Initialize oscillation
00001878                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001878                            InitOscillation:
00001878 43F8 C76A                  		lea	rOscNums.w,a1
0000187C 45FA 0000                  		lea	OscInitData(pc),a2
00001880 7200                       		moveq	#(OscInitData_End-OscInitData)>>1-1,d1
00001882                            
00001882                            .LoadData:
00001882 32DA                       		move.w	(a2)+,(a1)+
00001884 51C9 FFFC                  		dbf	d1,.LoadData
00001888 4E75                       		rts
0000188A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000188A                            OscInitData:
0000188A 007D                       		dc.w	%0000000001111101
0000188C 0080 0000                  		dc.w	$0080, $0000
00001890 0080 0000                  		dc.w	$0080, $0000
00001894 0080 0000                  		dc.w	$0080, $0000
00001898 0080 0000                  		dc.w	$0080, $0000
0000189C 0080 0000                  		dc.w	$0080, $0000
000018A0 0080 0000                  		dc.w	$0080, $0000
000018A4 0080 0000                  		dc.w	$0080, $0000
000018A8 0080 0000                  		dc.w	$0080, $0000
000018AC 0080 0000                  		dc.w	$0080, $0000
000018B0 3848 00EE                  		dc.w	$3848, $00EE
000018B4 2080 00B4                  		dc.w	$2080, $00B4
000018B8 3080 010E                  		dc.w	$3080, $010E
000018BC 5080 01C2                  		dc.w	$5080, $01C2
000018C0 7080 0276                  		dc.w	$7080, $0276
000018C4 0080 0000                  		dc.w	$0080, $0000
000018C8 4000 00FE                  		dc.w	$4000, $00FE
000018CC                            OscInitData_End:
000018CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018CC                            ; Update oscillation
000018CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018CC                            UpdateOscillation:
000018CC 43F8 C76A                  		lea	rOscNums.w,a1
000018D0 45FA 0000                  		lea	OscUpdateData(pc),a2
000018D4 3619                       		move.w	(a1)+,d3
000018D6 7200                       		moveq	#(OscUpdateData_End-OscUpdateData)>>2-1,d1
000018D8                            
000018D8                            .OscLoop:
000018D8 341A                       		move.w	(a2)+,d2
000018DA 381A                       		move.w	(a2)+,d4
000018DC 0303                       		btst	d1,d3
000018DE 6600                       		bne.s	.Sub
000018E0 3029 0002                  		move.w	2(a1),d0
000018E4 D042                       		add.w	d2,d0
000018E6 3340 0002                  		move.w	d0,2(a1)
000018EA D151                       		add.w	d0,(a1)
000018EC B811                       		cmp.b	(a1),d4
000018EE 6200                       		bhi.s	.DoLoop
000018F0 03C3                       		bset	d1,d3
000018F2 6000                       		bra.s	.DoLoop
000018F4                            
000018F4                            .Sub:
000018F4 3029 0002                  		move.w	2(a1),d0
000018F8 9042                       		sub.w	d2,d0
000018FA 3340 0002                  		move.w	d0,2(a1)
000018FE D151                       		add.w	d0,(a1)
00001900 B811                       		cmp.b	(a1),d4
00001902 6300                       		bls.s	.DoLoop
00001904 0383                       		bclr	d1,d3
00001906                            
00001906                            .DoLoop:
00001906 5849                       		addq.w	#4,a1
00001908 51C9 FFCE                  		dbf	d1,.OscLoop
0000190C                            
0000190C 31C3 C76A                  		move.w	d3,rOscCtrl.w
00001910                            
00001910                            .End:
00001910 4E75                       		rts
00001912                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001912                            OscUpdateData:
00001912 0002 0010                  		dc.w	$02, $10
00001916 0002 0018                  		dc.w	$02, $18
0000191A 0002 0020                  		dc.w	$02, $20
0000191E 0002 0030                  		dc.w	$02, $30
00001922 0004 0020                  		dc.w	$04, $20
00001926 0008 0008                  		dc.w	$08, $08
0000192A 0008 0040                  		dc.w	$08, $40
0000192E 0004 0040                  		dc.w	$04, $40
00001932 0002 0038                  		dc.w	$02, $38
00001936 0002 0038                  		dc.w	$02, $38
0000193A 0002 0020                  		dc.w	$02, $20
0000193E 0003 0030                  		dc.w	$03, $30
00001942 0005 0050                  		dc.w	$05, $50
00001946 0007 0070                  		dc.w	$07, $70
0000194A 0002 0040                  		dc.w	$02, $40
0000194E 0002 0040                  		dc.w	$02, $40
00001952                            OscUpdateData_End:
00001952                            ; =========================================================================================================================================================
00001952                            		include	"_LIB_/Object.asm"		; Object functions
00001952                            ; =========================================================================================================================================================
00001952                            ; Mighty The Armadillo in PRISM PARADISE
00001952                            ; By Nat The Porcupine 2021
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            ; Object functions
00001952                            ; =========================================================================================================================================================
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            ; Initialize object lists
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            ; PARAMETERS:
00001952                            ;	Nothing
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            ; RETURNS:
00001952                            ;	Nothing
00001952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001952                            InitObjectList:
00001952                            		clrRAM	rRespawns			; Clear object respawn table
00001952                          M 	local	endaddr
00001952                          M endaddr	equs	"rrespawns_End"
00001952 7000                     M 	moveq	#0,d0
00001954 43F8 BE9E                M 	lea	(rrespawns).w,a1
00001958 323C 00BF                M 	move.w	#(((rrespawns_end)-(rrespawns))-((rrespawns)&1))>>2-1,d1
0000195C 22C0                     M .clear_65:	move.l	d0,(a1)+
0000195E 51C9 FFFC                M 	dbf	d1,.clear_65
00001962                            
00001962                            	; setup tail object
00001962 31FC BE54 BE58             		move.w	#rTailAddr,rTailNext.w		; set the first object as the tail object
00001968 31FC BE54 BE5A             		move.w	#rTailAddr,rTailPrev.w		; set the last object as the tail object
0000196E 21FC 0000 0000 BE54        		move.l	#.rts,rTailAddr.w		; set the next rts as the tail object pointer
00001976                            
00001976                            	; setup free object list
00001976 41F8 9A54                  		lea	rObjects.w,a0			; load the objects list into a0
0000197A 31C8 BE5C                  		move.w	a0,rFreeHead.w			; set the first object as the first free object
0000197E 705E                       		moveq	#OBJECT_COUNT-2,d0		; load object count to d0
00001980 7260                       		moveq	#oSize,d1			; load object size to d1
00001982                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001982                            
00001982                            .load
00001982 D0C1                       		add.w	d1,a0				; go to the next object now
00001984 3148 FFA6                  		move.w	a0,oPrev-oSize(a0)		; save new previous pointer
00001988 42A8 0008                  		clr.l	oDrawNext(a0)			; clear the display link values
0000198C 51C8 FFF4                  		dbf	d0,.load			; loop for every object
00001990                            
00001990 4268 0006                  		clr.w	oPrev(a0)			; set the last previous pointer to 0
00001994                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001994                            
00001994                            	; reset display table
00001994 43F8 BE56                  		lea	rDispInput-dNext.w,a1		; get display table address to a1
00001998 7207                       		moveq	#8-1,d1				; loop for all the layers
0000199A                            
0000199A                            .dsp
0000199A 3349 000E                  		move.w	a1,dPrev+dNext(a1)		; update prev pointer
0000199E 5849                       		addq.w	#dNext,a1			; advance to the actual address
000019A0 3349 0004                  		move.w	a1,dNext(a1)			; update next pointer
000019A4                            
000019A4 42A9 0006                  		clr.l	dN2(a1)				; clear the list end pointers
000019A8 5849                       		addq.w	#dSize-dNext,a1			; go to the next layer
000019AA 51C9 FFEE                  		dbf	d1,.dsp				; loop for all layers
000019AE                            
000019AE                            .rts
000019AE 4E75                       		rts
000019B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019B0                            ; Find the first free object space available
000019B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019B0                            ; PARAMETERS:
000019B0                            ;	Nothing
000019B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019B0                            ; RETURNS:
000019B0                            ;	a1.l	- Pointer to the SST space in the free object space
000019B0                            ;	a2.l	- Trashed
000019B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019B0                            FindFreeObj:
000019B0 3038 BE5C                  		move.w	rFreeHead.w,d0			; get pointer to the next free object
000019B4 6700                       		beq.s	.rts				; if it's a null pointer (z=1), return
000019B6 3240                       		movea.w	d0,a1				; load to a1
000019B8 31E9 0006 BE5C             		move.w	oPrev(a1),rFreeHead.w		; copy the next free object pointer to list start
000019BE                            
000019BE 3478 BE5A                  		move.w	rTailPrev.w,a2			; load last object to a2
000019C2 31C9 BE5A                  		move.w	a1,rTailPrev.w			; save as the new last object
000019C6 336A 0004 0004             		move.w	oNext(a2),oNext(a1)		; copy the next pointer from old tail to new object
000019CC 3549 0004                  		move.w	a1,oNext(a2)			; save new object as next pointer for old tail
000019D0 334A 0006                  		move.w	a2,oPrev(a1)			; save old tail as prev pointer for new object
000019D4                            
000019D4                            .rts:
000019D4 4E75                       		rts
000019D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019D6                            ; Delete an object
000019D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019D6                            ; PARAMETERS:
000019D6                            ;	a1.l	- Pointer to object space to clear
000019D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019D6                            ; RETURNS:
000019D6                            ;	a1.l	- Trashed
000019D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019D6                            DeleteOtherObj:
000019D6 4850                       		pea	(a0)
000019D8 2049                       		move.l	a1,a0
000019DA 6100                       		bsr.s	DeleteObject
000019DC                            		pop.l	a0
000019DC 205F                     M 	move.l	(sp)+,a0
000019DE 4E75                       		rts
000019E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019E0                            ; Delete the current object
000019E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019E0                            ; PARAMETERS:
000019E0                            ;	Nothing
000019E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019E0                            ; RETURNS:
000019E0                            ;	a1.l	- Trashed
000019E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019E0                            DeleteObject:
000019E0                            	removeSprite	a0, a1, 1			; remove object display
000019E0 4A68 0008                M 	tst.w	odrawnext(a0)
000019E4 6700                     M 	beq.s	.yes_67
000019E6 3268 000A                M 	move.w	odrawprev(a0),a1
000019EA 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
000019F0 3268 0008                M 	move.w	odrawnext(a0),a1
000019F4 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
000019FA B2E8 000A                M 	cmp.w	odrawprev(a0),a1
000019FE 6600                     M 	bne.s	.no_67
00001A00 3349 0008                M 	move.w	a1,odrawnext(a1)
00001A04                          M .no_67
00001A04 42A8 0008                M 	clr.l	odrawnext(a0)
00001A08                          M .yes_67
00001A08 3268 0006                  		move.w	oPrev(a0),a1			; copy previous pointer to a1
00001A0C 3368 0004 0004             		move.w	oNext(a0),oNext(a1)		; copy next pointer to previous object
00001A12 3268 0004                  		move.w	oNext(a0),a1			; get next object to a1
00001A16 3368 0006 0006             		move.w	oPrev(a0),oPrev(a1)		; copy previous pointer
00001A1C                            
00001A1C 3178 BE5C 0006             		move.w	rFreeHead.w,oPrev(a0)		; get the head of the free list to previous pointer of this object
00001A22 31C8 BE5C                  		move.w	a0,rFreeHead.w			; save as the new head of free list
00001A26                            
00001A26                            		; clear object memory
00001A26 7000                       		moveq	#0,d0				; clear d0
00001A28 4852                       		pea	(a2)
00001A2A 45E8 000A                  		lea	oDrawPrev(a0),a2		; load the first byte to clear to a2
00001A2E 34C0                       		move.w	d0,(a2)+			; clear a word of data
00001A30                            
00001A30                            	rept (oSize-oDrawPrev) / 4			; repeat for every object property
00001A30                            		move.l	d0,(a2)+			; clear a longword of data
00001A30                            	endr
00001A30 24C0                     M 	move.l	d0,(a2)+
00001A32 24C0                     M 	move.l	d0,(a2)+
00001A34 24C0                     M 	move.l	d0,(a2)+
00001A36 24C0                     M 	move.l	d0,(a2)+
00001A38 24C0                     M 	move.l	d0,(a2)+
00001A3A 24C0                     M 	move.l	d0,(a2)+
00001A3C 24C0                     M 	move.l	d0,(a2)+
00001A3E 24C0                     M 	move.l	d0,(a2)+
00001A40 24C0                     M 	move.l	d0,(a2)+
00001A42 24C0                     M 	move.l	d0,(a2)+
00001A44 24C0                     M 	move.l	d0,(a2)+
00001A46 24C0                     M 	move.l	d0,(a2)+
00001A48 24C0                     M 	move.l	d0,(a2)+
00001A4A 24C0                     M 	move.l	d0,(a2)+
00001A4C 24C0                     M 	move.l	d0,(a2)+
00001A4E 24C0                     M 	move.l	d0,(a2)+
00001A50 24C0                     M 	move.l	d0,(a2)+
00001A52 24C0                     M 	move.l	d0,(a2)+
00001A54 24C0                     M 	move.l	d0,(a2)+
00001A56 24C0                     M 	move.l	d0,(a2)+
00001A58 24C0                     M 	move.l	d0,(a2)+
00001A5A                            		pop.l	a2
00001A5A 245F                     M 	move.l	(sp)+,a2
00001A5C                            
00001A5C 4E75                       		rts
00001A5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A5E                            ; Render object sprites
00001A5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A5E                            ; PARAMETERS:
00001A5E                            ;	Nothing
00001A5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A5E                            ; RETURNS:
00001A5E                            ;	Nothing
00001A5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A5E                            RenderObjects:
00001A5E 7E4F                       		moveq	#($280/8)-1,d7			; Max sprite count
00001A60 7C00                       		moveq	#0,d6				; Render flags
00001A62                            
00001A62 47F8 F880                  		lea	rFGCam.w,a3			; Foreground camera variables
00001A66 4BF8 BE5E                  		lea	rDispInput+dNext.w,a5	; Sprite input table
00001A6A 4DF8 94CE                  		lea	rSprites.w,a6			; Sprite table buffer
00001A6E                            
00001A6E 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Are we in level mode?
00001A74 6600                       		bne.s	.PrioLvlLoop			; If not, branch
00001A76 4EB9 0000 0000             		jsr	Level_RenderHUDAndRings		; Render the HUD & Rings (in that order)
00001A7C                            
00001A7C                            .PrioLvlLoop:
00001A7C 3055                       		move.w	(a5),a0				; Load priority level address to a0
00001A7E 504D                       		add.w	#dSize,a5			; Skip bunch of shit
00001A80 4A68 0008                  		tst.w	oDrawNext(a0)			; Is the next pointer for a valid object?
00001A84 6700 0000                  		beq.w	.NextPrioLvl			; If not, branch
00001A88                            
00001A88                            .ObjectLoop:
00001A88                            	;	movea.w	(a4)+,a0			; Get object SST address
00001A88 4A90                       		tst.l	oAddr(a0)			; Is this object slot used?
00001A8A 6700 0000                  		beq.w	.NextObject			; If not, branch
00001A8E                            
00001A8E 0228 007F 000D             		andi.b	#$7F,oRender(a0)		; Clear on-screen flag
00001A94 1C28 000D                  		move.b	oRender(a0),d6			; Store render flags
00001A98 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00001A9C 3228 0018                  		move.w	oYPos(a0),d1			; Get Y position
00001AA0                            
00001AA0 0806 0006                  		btst	#6,d6				; Is the multi sprite flag set?
00001AA4 6600 0000                  		bne.w	.MultiDraw			; If so, branch
00001AA8 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001AAC 6700                       		beq.s	.Render				; If not, branch
00001AAE                            
00001AAE 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001AB0 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001AB4                            
00001AB4                            .Render:
00001AB4 7400                       		moveq	#0,d2
00001AB6 1428 0017                  		move.b	oDrawW(a0),d2			; Get sprite width
00001ABA 3600                       		move.w	d0,d3				; Get sprite X position
00001ABC D642                       		add.w	d2,d3				; Add width
00001ABE 6B00                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001AC0 3600                       		move.w	d0,d3				; Get sprite X position
00001AC2 9642                       		sub.w	d2,d3				; Subtract width
00001AC4 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001AC8 6C00                       		bge.s	.NextObject			; If so, branch
00001ACA 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001ACE                            
00001ACE 7400                       		moveq	#0,d2
00001AD0 1428 001B                  		move.b	oDrawH(a0),d2			; Get sprite height
00001AD4 3601                       		move.w	d1,d3				; Get sprite Y position
00001AD6 D642                       		add.w	d2,d3				; Add height
00001AD8 6B00                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001ADA 3601                       		move.w	d1,d3				; Get sprite Y position
00001ADC 9642                       		sub.w	d2,d3				; Subtract height
00001ADE 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001AE2 6C00                       		bge.s	.NextObject			; If so, branch
00001AE4 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001AE8                            
00001AE8 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001AEE 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001AF0 6B00                       		bmi.s	.NextObject			; If not, branch
00001AF2                            
00001AF2 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001AF6 6700                       		beq.s	.NextObject			; If blank, branch
00001AF8 2244                       		movea.l	d4,a1				; Store it
00001AFA 7800                       		moveq	#0,d4
00001AFC 0806 0005                  		btst	#5,d6				; Is the static sprite flag set
00001B00 6600                       		bne.s	.Static				; If so, branch
00001B02 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001B06 D844                       		add.w	d4,d4				; Turn into offset
00001B08 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001B0C 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001B0E 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001B10 6B00                       		bmi.s	.NextObject			; If there are no sprites to draw, branch
00001B12                            
00001B12                            .Static:
00001B12 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001B16 6100 ECBE                  		bsr.w	DrawSprite			; Draw the sprites
00001B1A                            
00001B1A                            .NextObject:	
00001B1A 3068 0008                  		move.w	oDrawNext(a0),a0		; Load next object to a0
00001B1E 4A68 0008                  		tst.w	oDrawNext(a0)			; Check the next pointer for valid object
00001B22 6600 FF64                  		bne.w	.ObjectLoop			; If there are still some sprites to draw in this priority level, branch
00001B26                            
00001B26                            .NextPrioLvl:
00001B26 BAFC BE9E                  		cmpa.w	#rDispInput_End,a5		; Are we at the end of the input table?
00001B2A 6500 FF50                  		blo.w	.PrioLvlLoop			; If not, branch
00001B2E                            
00001B2E 3C07                       		move.w	d7,d6				; Get remaining sprite count
00001B30 6B00                       		bmi.s	.SetDrawnSprites		; If we have filled the entire sprite table, branch
00001B32 7000                       		moveq	#0,d0
00001B34                            
00001B34                            .FillRest:
00001B34 3C80                       		move.w	d0,(a6)				; Move sprite off screen
00001B36 504E                       		addq.w	#8,a6				; Next sprite
00001B38 51CF FFFA                  		dbf	d7,.FillRest			; Loop
00001B3C                            
00001B3C                            .SetDrawnSprites:
00001B3C 0446 004F                  		subi.w	#($280/8)-1,d6			; Get number of sprites drawn
00001B40 4446                       		neg.w	d6				; ''
00001B42 11C6 C75B                  		move.b	d6,rSprCount.w		; Store it
00001B46                            
00001B46 4E75                       		rts
00001B48                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001B48                            .MultiDraw:
00001B48 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001B4C 6700                       		beq.s	.RenderMain			; If not, branch
00001B4E                            
00001B4E 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001B50 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001B54                            
00001B54                            .RenderMain:
00001B54 7400                       		moveq	#0,d2
00001B56 1428 0017                  		move.b	oDrawW(a0),d2			; Get main sprite width
00001B5A 3600                       		move.w	d0,d3				; Get main sprite X position
00001B5C D642                       		add.w	d2,d3				; Add width
00001B5E 6BBA                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001B60 3600                       		move.w	d0,d3				; Get main sprite X position
00001B62 9642                       		sub.w	d2,d3				; Subtract width
00001B64 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001B68 6CB0                       		bge.s	.NextObject			; If so, branch
00001B6A 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001B6E                            
00001B6E 1428 001B                  		move.b	oDrawH(a0),d2			; Get main sprite height
00001B72 3601                       		move.w	d1,d3				; Get main sprite Y position
00001B74 D642                       		add.w	d2,d3				; Add height
00001B76 6BA2                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001B78 3601                       		move.w	d1,d3				; Get main sprite Y position
00001B7A 9642                       		sub.w	d2,d3				; Subtract height
00001B7C 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001B80 6C98                       		bge.s	.NextObject			; If so, branch
00001B82 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001B86                            
00001B86 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001B8C 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B8E 6B00 FF8A                  		bmi.w	.NextObject			; If not, branch
00001B92                            
00001B92 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001B96 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001B9A 6700 FF7E                  		beq.w	.NextObject			; If blank, branch
00001B9E 2444                       		movea.l	d4,a2				; Store it
00001BA0 7800                       		moveq	#0,d4
00001BA2 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001BA6 D844                       		add.w	d4,d4				; Turn into offset
00001BA8 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001BAA D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001BAE 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001BB0 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001BB2 6B00                       		bmi.s	.RenderSubSprites		; If there are no sprites to draw, branch
00001BB4 3606                       		move.w	d6,d3				; Store render flags
00001BB6 6100 ED02                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001BBA 3C03                       		move.w	d3,d6				; Restore render flags
00001BBC                            
00001BBC 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BBE 6B00 FF5A                  		bmi.w	.NextObject			; If not, branch
00001BC2                            
00001BC2                            .RenderSubSprites:
00001BC2 3628 002E                  		move.w	oSubCnt(a0),d3			; Get sub sprite count
00001BC6 5343                       		subq.w	#1,d3				; Subtract 1
00001BC8 6B00 FF50                  		bmi.w	.NextObject			; If there are no sprites to draw, branch
00001BCC 41E8 0030                  		lea	oSubStart(a0),a0		; Get sub sprite SSTs start
00001BD0                            
00001BD0                            .RenderSubSprs_Loop:
00001BD0 3018                       		move.w	(a0)+,d0			; Get X position
00001BD2 0640 0080                  		addi.w	#128,d0				; Move on screen
00001BD6 3218                       		move.w	(a0)+,d1			; Get Y position
00001BD8 0641 0080                  		addi.w	#128,d1				; Move on screen
00001BDC                            
00001BDC 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001BE0 6700                       		beq.s	.RenderSub			; If not, branch
00001BE2                            
00001BE2 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001BE4 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001BE8                            
00001BE8                            .RenderSub:
00001BE8 3818                       		move.w	(a0)+,d4			; Get mapping frame
00001BEA D844                       		add.w	d4,d4				; Turn into offset
00001BEC 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001BEE D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001BF2 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001BF4 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001BF6 6B00                       		bmi.s	.RenderSubSprs_ChkLoop		; If there are no sprites to draw, branch
00001BF8                            		push.w	d6				; Store render flags
00001BF8 3F06                     M 	move.w	d6,-(sp)
00001BFA 6100 ECBE                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001BFE                            		pop.w	d6				; Restore render flags
00001BFE 3C1F                     M 	move.w	(sp)+,d6
00001C00                            
00001C00                            .RenderSubSprs_ChkLoop:
00001C00 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001C02 5BCB FFCC                  		dbmi	d3,.RenderSubSprs_Loop		; If so, loop
00001C06 6000 FF12                  		bra.w	.NextObject			; Continue on rendering other sprites
00001C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C0A                            ; Animate an object's sprite
00001C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C0A                            ; PARAMETERS:
00001C0A                            ;	a0.l	- Object space pointer
00001C0A                            ;	a1.l	- Animation script pointer
00001C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C0A                            ; RETURNS:
00001C0A                            ;	Nothing
00001C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C0A                            AnimateObject:
00001C0A 7000                       		moveq	#0,d0
00001C0C 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
00001C10 B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
00001C14 6700                       		beq.s	.Run				; If not, branch
00001C16 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
00001C1A 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001C1E 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001C22                            
00001C22                            .Run:
00001C22 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00001C26 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00001C28 D040                       		add.w	d0,d0				; Turn ID into offset
00001C2A D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00001C2E 1151 0023                  		move.b	(a1),oAniTimer(a0)		; Set new animation timer
00001C32                            
00001C32 7200                       		moveq	#0,d1
00001C34 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
00001C38 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00001C3C 0C00 00FA                  		cmpi.b	#$FA,d0				; Is it a command value?
00001C40 6400                       		bhs.s	.CmdReset			; If so, branch
00001C42                            
00001C42                            .Next:
00001C42 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
00001C46 1028 0028                  		move.b	oStatus(a0),d0			; Get status
00001C4A 0200 0003                  		andi.b	#3,d0				; Only get flip bits
00001C4E 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
00001C54 8128 000D                  		or.b	d0,oRender(a0)			; Set flip bits
00001C58 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
00001C5C                            
00001C5C                            .Wait:
00001C5C 4E75                       		rts
00001C5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C5E                            .CmdReset:
00001C5E 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00001C60 6600                       		bne.s	.CmdJump			; If not, branch
00001C62 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001C66 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00001C6A 60D6                       		bra.s	.Next				; Continue
00001C6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C6C                            .CmdJump:
00001C6C 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00001C6E 6600                       		bne.s	.CmdSetAnim			; If not, branch
00001C70 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00001C74 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
00001C78 9200                       		sub.b	d0,d1				; ''
00001C7A 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00001C7E 60C2                       		bra.s	.Next				; Continue
00001C80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C80                            .CmdSetAnim:
00001C80 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00001C82 6600                       		bne.s	.CmdNextRout			; If not, branch
00001C84 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
00001C8A 4E75                       		rts
00001C8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C8C                            .CmdNextRout:
00001C8C 5200                       		addq.b	#1,d0				; Is this flag $FC (next routine)?
00001C8E 6600                       		bne.s	.CmdReset2ndRout		; If not, branch
00001C90 5428 0025                  		addq.b	#2,oRoutine(a0)			; Next routine
00001C94 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001C98 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next animation frame
00001C9C 4E75                       		rts
00001C9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C9E                            .CmdReset2ndRout:
00001C9E 5200                       		addq.b	#1,d0				; Is this flag $FB (reset secondary routine)?
00001CA0 6600                       		bne.s	.CmdNext2ndRout			; If not, branch
00001CA2 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001CA6                            ;		clr.b	oWFZRout(a0)			; Reset routine
00001CA6 4E75                       		rts
00001CA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CA8                            .CmdNext2ndRout:
00001CA8 5200                       		addq.b	#1,d0				; Is this flag $FA (next secondary routine)?
00001CAA 6600                       		bne.s	.CmdEnd				; If not, branch
00001CAC                            ;		addq.b	#2,oWFZRout(a0)			; Next routine
00001CAC 4E75                       		rts
00001CAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CAE                            .CmdEnd:
00001CAE 4E75                       		rts
00001CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CB0                            ; Load object DPLCs
00001CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CB0                            ; PARAMETERS:
00001CB0                            ;	d4.w	- Target VRAM address
00001CB0                            ;	d6.l	- Pointer to uncompressed art
00001CB0                            ;	a2.l	- Pointer to DPLCs
00001CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CB0                            ; RETURNS:
00001CB0                            ;	Nothing
00001CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CB0                            LoadObjDPLCs:
00001CB0 7000                       		moveq	#0,d0
00001CB2 1028 0010                  		move.b	oFrame(a0),d0			; Get mapping frame
00001CB6 B010                       		cmp.b	oPrevDPLC(a0),d0		; Do we need to update the art?
00001CB8 6700                       		beq.s	.End				; If not, branch
00001CBA 1080                       		move.b	d0,oPrevDPLC(a0)		; Save the frame ID so we don't constantly load the art
00001CBC D040                       		add.w	d0,d0				; Turn ID into offset
00001CBE D4F2 0000                  		adda.w	(a2,d0.w),a2			; Get pointer to DPLC data for the frame
00001CC2 3A1A                       		move.w	(a2)+,d5			; Get DPLC entry count
00001CC4 5345                       		subq.w	#1,d5				; Subtract 1
00001CC6 6B00                       		bmi.s	.End				; If there are no more entires left, branch
00001CC8                            
00001CC8                            .ReadEntries:
00001CC8 7200                       		moveq	#0,d1
00001CCA 321A                       		move.w	(a2)+,d1			; Get DPLC entry data
00001CCC 3601                       		move.w	d1,d3				; Copy that
00001CCE E04B                       		lsr.w	#8,d3				; Get tile count
00001CD0 0243 00F0                  		andi.w	#$F0,d3				; ''
00001CD4 0643 0010                  		addi.w	#$10,d3				; ''
00001CD8 0241 0FFF                  		andi.w	#$FFF,d1			; Get offset in art data
00001CDC EB89                       		lsl.l	#5,d1				; ''
00001CDE D286                       		add.l	d6,d1				; Get pointer in art data
00001CE0 3404                       		move.w	d4,d2				; Copy VRAM address
00001CE2 D843                       		add.w	d3,d4				; Add tile count to VRAM address
00001CE4 D843                       		add.w	d3,d4				; ''
00001CE6 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue the art
00001CEA 51CD FFDC                  		dbf	d5,.ReadEntries			; Loop
00001CEE                            
00001CEE                            .End:
00001CEE 4E75                       		rts
00001CF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CF0                            ; Move an object by it's velocity values
00001CF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CF0                            ; PARAMETERS:
00001CF0                            ;	a0.l	- Object space pointer
00001CF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CF0                            ; RETURNS:
00001CF0                            ;	Nothing
00001CF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CF0                            ObjectMove:
00001CF0 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001CF4 48C0                       		ext.l	d0				; ''
00001CF6 E188                       		lsl.l	#8,d0				; Shift
00001CF8 D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001CFC 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001D00 48C0                       		ext.l	d0				; ''
00001D02 E188                       		lsl.l	#8,d0				; Shift
00001D04 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001D08 4E75                       		rts
00001D0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0A                            ; Move an object by it's velocity values (with gravity)
00001D0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0A                            ; PARAMETERS:
00001D0A                            ;	a0.l	- Object space pointer
00001D0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0A                            ; RETURNS:
00001D0A                            ;	Nothing
00001D0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0A                            ObjectMoveAndFall:
00001D0A 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001D0E 48C0                       		ext.l	d0				; ''
00001D10 E188                       		lsl.l	#8,d0				; Shift
00001D12 D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001D16 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001D1A 0668 0038 001E             		addi.w	#$38,oYVel(a0)			; Apply gravity
00001D20 48C0                       		ext.l	d0				; ''
00001D22 E188                       		lsl.l	#8,d0				; Shift
00001D24 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001D28 4E75                       		rts
00001D2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D2A                            ; Check if a specific object is nearby
00001D2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D2A                            ; PARAMETERS:
00001D2A                            ;	a0.l	- Current object space pointer
00001D2A                            ;	a1.l	- Range data pointer
00001D2A                            ;	a2.l	- Object to check's space pointer
00001D2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D2A                            ; RETURNS:
00001D2A                            ;	d0.w	- Return status (0 if not in range, other object's space pointer if in range)
00001D2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D2A                            CheckObjInRange:
00001D2A 7000                       		moveq	#0,d0
00001D2C 322A 0014                  		move.w	oXPos(a2),d1			; Get other object's position
00001D30 342A 0018                  		move.w	oYPos(a2),d2			; ''
00001D34 3628 0014                  		move.w	oXPos(a0),d3			; Get current object's position
00001D38 3828 0018                  		move.w	oYPos(a0),d4			; ''
00001D3C D659                       		add.w	(a1)+,d3			; Get left boundary
00001D3E 3A03                       		move.w	d3,d5				; Copy
00001D40 DA59                       		add.w	(a1)+,d5			; Get right boundary
00001D42 D859                       		add.w	(a1)+,d4			; Get top boundary
00001D44 3C04                       		move.w	d4,d6				; Copy
00001D46 DC59                       		add.w	(a1)+,d6			; Get bottom boundary
00001D48 B243                       		cmp.w	d3,d1				; Is the object past the left boundary?
00001D4A 6500                       		blo.s	.End				; If not, branch
00001D4C B245                       		cmp.w	d5,d1				; Is the object within the horizontal range?
00001D4E 6400                       		bhs.s	.End				; If not, branch
00001D50 B444                       		cmp.w	d4,d2				; Is the object past the top boundary?
00001D52 6500                       		blo.s	.End				; If not, branch
00001D54 B446                       		cmp.w	d6,d2				; Is the object within the vertical range?
00001D56 6400                       		bhs.s	.End				; If not, branch
00001D58 300A                       		move.w	a2,d0				; Copy other object's RAM space pointer as the return status
00001D5A                            
00001D5A                            .End:
00001D5A 4E75                       		rts
00001D5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D5C                            ; Object manager
00001D5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D5C                            ObjectManager:
00001D5C 4A38 C7B8                  		tst.b	rObjManInit.w
00001D60 6600                       		bne.s	ObjectManagerMain
00001D62                            
00001D62                            ObjectManagerInit:
00001D62 50F8 C7B8                  		st	rObjManInit.w			; Set the init flag
00001D66                            
00001D66 2078 C7B4                  		movea.l	rObjPosAddr.w,a0		; Get object data pointer
00001D6A 21C8 C7BA                  		move.l	a0,rObjLoadR.w
00001D6E 21C8 C7BE                  		move.l	a0,rObjLoadL.w			; Store address of object layout
00001D72                            
00001D72 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001D76                            
00001D76 3C38 F880                  		move.w	rCamXPos.w,d6			; Camera's X position
00001D7A 0446 0080                  		subi.w	#$80,d6				; Subtract 128
00001D7E 6400                       		bhs.s	.NoReset			; Branch if it doesn't go past the left boundary
00001D80 7C00                       		moveq	#0,d6				; Cap at left boundary
00001D82                            
00001D82                            .NoReset:
00001D82 0246 FF80                  		andi.w	#$FF80,d6			; Keep in chunks of 128 pixels
00001D86                            
00001D86 2078 C7BA                  		movea.l	rObjLoadR.w,a0			; Get address of the object loader for the right side of the screen
00001D8A                            
00001D8A                            .ChkObjsLeft:
00001D8A BC50                       		cmp.w	(a0),d6				; Compare object position
00001D8C 6300                       		bls.s	.ChkDone			; If higher than d6, branch
00001D8E 5C48                       		addq.w	#6,a0				; Next object
00001D90 524B                       		addq.w	#1,a3				; Next respawn table index
00001D92 60F6                       		bra.s	.ChkObjsLeft			; Loop
00001D94                            
00001D94                            .ChkDone:
00001D94 21C8 C7BA                  		move.l	a0,rObjLoadR.w			; Store new addresses
00001D98 31CB C7C4                  		move.w	a3,rObjRespR.w			; ''
00001D9C                            
00001D9C 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001DA0                            
00001DA0 2078 C7BE                  		movea.l	rObjLoadL.w,a0
00001DA4 0446 0080                  		subi.w	#$80,d6				; Subtract from camera's X position again
00001DA8 6500                       		bcs.s	.ChkDone2			; But is done to account for the object loader later on
00001DAA                            
00001DAA                            .ChkObjsRight:
00001DAA BC50                       		cmp.w	(a0),d6				; Compate object position
00001DAC 6300                       		bls.s	.ChkDone2			; If higher than d6, branch
00001DAE 5C48                       		addq.w	#6,a0				; Next object
00001DB0 524B                       		addq.w	#1,a3				; Next respawn table index
00001DB2 60F6                       		bra.s	.ChkObjsRight			; Loop
00001DB4                            
00001DB4                            .ChkDone2:
00001DB4 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001DB8 31CB C7C2                  		move.w	a3,rObjRespL.w		; ''
00001DBC                            
00001DBC 31FC FFFF C7CA             		move.w	#-1,rObjManX.w		; Reset manager's camera X position
00001DC2 3038 F888                  		move.w	rCamYPos.w,d0			; Get camera's Y position
00001DC6 0240 FF80                  		andi.w	#$FF80,d0			; Keep in range
00001DCA 31C0 C7CC                  		move.w	d0,rObjManY.w		; Store it so unnecessary Y checks shouldn't be done
00001DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001DCE                            ObjectManagerMain:
00001DCE 3238 F888                  		move.w	rCamYPos.w,d1			; Get camera's Y position
00001DD2 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001DD6 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001DDA 31C1 C7C8                  		move.w	d1,rObjYCoarse.w		; Store this
00001DDE                            
00001DDE 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera's X position
00001DE2 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001DE6 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001DEA 31C1 C7C6                  		move.w	d1,rObjXCoarse.w		; Store this
00001DEE                            		
00001DEE 49F9 0000 0000             		lea	Level_ObjIndex,a4		; Level object index
00001DF4                            
00001DF4 3638 F888                  		move.w	rCamYPos.w,d3			; Get camera's Y position
00001DF8 0243 FF80                  		andi.w	#$FF80,d3			; Keep in range
00001DFC 3803                       		move.w	d3,d4				; Copy
00001DFE 0644 0200                  		addi.w	#$200,d4			; Lower Y boundary
00001E02 0443 0080                  		subi.w	#$80,d3				; Upper Y boundary
00001E06 6A00                       		bpl.s	.SetNoWrap			; If still positive, branch
00001E08 7600                       		moveq	#0,d3				; Cap at upper level boundary
00001E0A                            
00001E0A                            .SetNoWrap:
00001E0A 3A3C 0FFF                  		move.w	#$FFF,d5
00001E0E 3C38 F880                  		move.w	rCamXPos.w,d6			; Get camera's X position
00001E12 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001E16 BC78 C7CA                  		cmp.w	rObjManX.w,d6		; Check against last range
00001E1A 6700 0000                  		beq.w	Level_LoadObjs_SameXRange	; Branch if they are the same
00001E1E 6C00                       		bge.s	Level_LoadObjs_Forward		; If new range is greater than the last, branch
00001E20                            
00001E20 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001E24                            
00001E24 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001E28 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001E2C                            
00001E2C 0446 0080                  		subi.w	#$80,d6				; Subtract 128 from the X position
00001E30 6500                       		blo.s	.EndLoad			; If outside of the level boundary, branch
00001E32                            
00001E32 4EB8 19B0                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E36 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E38                            
00001E38                            .LoadLoop:
00001E38 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is in range
00001E3C 6C00                       		bge.s	.EndLoadRst			; If not, branch
00001E3E 5D88                       		subq.l	#6,a0				; Get actual object address
00001E40 534B                       		subq.w	#1,a3				; Get acutal respawn table address
00001E42                            
00001E42 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E46 6700                       		beq.s	.LoadFail			; Branch if it could not be loaded
00001E48 5D88                       		subq.l	#6,a0
00001E4A 60EC                       		bra.s	.LoadLoop			; Attempt to load another object
00001E4C                            
00001E4C                            .LoadFail:
00001E4C 5C88                       		addq.l	#6,a0				; Undo object loading
00001E4E 524B                       		addq.w	#1,a3
00001E50 6000                       		bra.s	.EndLoad
00001E52                            .EndLoadRst:
00001E52 4EB8 19D6                  		jsr	DeleteOtherObj.w
00001E56                            
00001E56                            .EndLoad:
00001E56 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001E5A 31CB C7C2                  		move.w	a3,rObjRespL.w
00001E5E                            
00001E5E 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001E62 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001E66                            
00001E66 0646 0300                  		addi.w	#$300,d6			; Load 2 chunks forward
00001E6A                            
00001E6A                            .ChkLoop:
00001E6A BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is out of range
00001E6E 6E00                       		bgt.s	.ChkDone			; If so, branch
00001E70 5D88                       		subq.l	#6,a0				; Get the object before this
00001E72 534B                       		subq.w	#1,a3				; And its respawn index
00001E74 60F4                       		bra.s	.ChkLoop			; Check next object
00001E76                            
00001E76                            .ChkDone:
00001E76 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001E7A 31CB C7C4                  		move.w	a3,rObjRespR.w
00001E7E 6000                       		bra.s	Level_LoadObjs_SameXRange	; Continue
00001E80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001E80                            Level_LoadObjs_Forward:
00001E80 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001E84                            
00001E84 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001E88 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001E8C                            
00001E8C 0646 0280                  		addi.w	#$280,d6			; Load 2 chunks forward
00001E90                            
00001E90 4EB8 19B0                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E94 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E96                            
00001E96                            .LoadLoop:
00001E96 BC50                       		cmp.w	(a0),d6				; Check if the last obhect is in range
00001E98 6300                       		bls.s	.EndLoadRst			; If not, branch
00001E9A 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E9E 6700                       		beq.s	.EndLoad			; If it failed to, branch
00001EA0 524B                       		addq.w	#1,a3				; Get acutal respawn table address
00001EA2 60F2                       		bra.s	.LoadLoop
00001EA4                            
00001EA4                            .EndLoadRst:
00001EA4 4EB8 19D6                  		jsr	DeleteOtherObj.w
00001EA8                            
00001EA8                            .EndLoad:
00001EA8 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001EAC 31CB C7C4                  		move.w	a3,rObjRespR.w
00001EB0                            
00001EB0 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001EB4 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001EB8                            
00001EB8 0446 0300                  		subi.w	#$300,d6			; Check 1 chunk backwards
00001EBC 6500                       		blo.s	.ChkDone			; If outside of level, branch
00001EBE                            
00001EBE                            .ChkLoop:
00001EBE BC50                       		cmp.w	(a0),d6				; Check if the last object is out of range
00001EC0 6300                       		bls.s	.ChkDone			; If so, branch
00001EC2 5C88                       		addq.l	#6,a0				; Get the object before this
00001EC4 524B                       		addq.w	#1,a3				; And its respawn index
00001EC6 60F6                       		bra.s	.ChkLoop			; Check next object
00001EC8                            
00001EC8                            .ChkDone:
00001EC8 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001ECC 31CB C7C2                  		move.w	a3,rObjRespL.w
00001ED0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001ED0                            Level_LoadObjs_SameXRange:
00001ED0 3C38 F888                  		move.w	rCamYPos.w,d6			; Get camera's X position
00001ED4 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001ED8 3606                       		move.w	d6,d3				; Copy
00001EDA BC78 C7CC                  		cmp.w	rObjManY.w,d6		; Check against last range
00001EDE 6700 0000                  		beq.w	.LoadEnd			; Branch if they are the same
00001EE2 6C00                       		bge.s	.MovingDown			; If the new raqnge is greater than the last, branch
00001EE4                            
00001EE4 0443 0080                  		subi.w	#$80,d3				; Loop 1 chunk up
00001EE8 6B00 0000                  		bmi.w	.LoadEnd
00001EEC 6000                       		bra.s	.YCheck
00001EEE                            
00001EEE                            .MovingDown:
00001EEE 0643 0180                  		addi.w	#$180,d3			; Look 1 chunk down
00001EF2                            
00001EF2                            .YCheck:
00001EF2 4EB8 19B0                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001EF6 6700                       		beq.s	.LoadEnd			; If failed, branch
00001EF8                            		
00001EF8 3803                       		move.w	d3,d4				; Copy Y position
00001EFA 0644 0080                  		addi.w	#$80,d4				; Look one chunk down
00001EFE 3A3C 0FFF                  		move.w	#$FFF,d5
00001F02                            
00001F02 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001F06 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001F0A 2E38 C7BA                  		move.l	rObjLoadR.w,d7		; Get current objects on the right side of the screen
00001F0E 9E88                       		sub.l	a0,d7				; Subtract the left position from the right
00001F10 6700                       		beq.s	.LoadEndRst			; Branch if no objects
00001F12 5488                       		addq.l	#2,a0				; Align to object's Y position
00001F14                            
00001F14                            .LoadNext:
00001F14 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F16 6B00                       		bmi.s	.LoadFail			; If so, branch
00001F18                            
00001F18 3210                       		move.w	(a0),d1				; Get object's Y position
00001F1A C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F1C B243                       		cmp.w	d3,d1
00001F1E 6500                       		blo.s	.LoadFail			; Branch if out of range in the top
00001F20 B244                       		cmp.w	d4,d1
00001F22 6200                       		bhi.s	.LoadFail			; Branch if out of range in the botoom
00001F24                            
00001F24 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F28 3368 FFFE 0014             		move.w	-2(a0),oXPos(a1)			; Set X position
00001F2E 3210                       		move.w	(a0),d1				; Get object's Y position
00001F30 3401                       		move.w	d1,d2				; Copy it
00001F32 C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F34 3341 0018                  		move.w	d1,oYPos(a1)			; Set Y position
00001F38                            
00001F38 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F3A 0242 0003                  		andi.w	#3,d2				; ''
00001F3E 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
00001F42 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
00001F46                            
00001F46 1428 0002                  		move.b	2(a0),d2			; Get ID
00001F4A D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001F4C D442                       		add.w	d2,d2
00001F4E 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00001F52                            
00001F52 1368 0003 0024             		move.b	3(a0),oSubtype(a1)		; Set subtype
00001F58 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00001F5C                            
00001F5C 4EB8 19B0                  		jsr	FindFreeObj.w			; Find a free object slot
00001F60 6700                       		beq.s	.LoadEnd			; If none could be loaded, branch
00001F62                            
00001F62                            .LoadFail:
00001F62 5C88                       		addq.l	#6,a0				; Next object
00001F64 524B                       		addq.w	#1,a3				; ''
00001F66 5D87                       		subq.l	#6,d7				; Subtract the size of the entry
00001F68 66AA                       		bne.s	.LoadNext			; If there are some objects remaining, branch
00001F6A                            
00001F6A                            .LoadEndRst:
00001F6A 4EB8 19D6                  		jsr	DeleteOtherObj.w
00001F6E                            
00001F6E                            .LoadEnd:
00001F6E 31C6 C7CC                  		move.w	d6,rObjManY.w		; Store manager's camera Y position
00001F72 4E75                       		rts
00001F74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F74                            ; Load an object from the object layout
00001F74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F74                            ; PARAMETERS:
00001F74                            ;	d3.w	- Upper boundary
00001F74                            ;	d4.w	- Lower boundary
00001F74                            ;	d5.w	- Y position limit
00001F74                            ;	a0.l	- Index of object layout
00001F74                            ;	a1.l	- Target object
00001F74                            ;	a3.l	- Respawn table address
00001F74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F74                            Level_LoadObject:
00001F74 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F76 6A00                       		bpl.s	.NotLoaded			; If not, branch
00001F78 5C88                       		addq.l	#6,a0				; Next object
00001F7A 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001F7C 4E75                       		rts
00001F7E                            
00001F7E                            .NotLoaded:
00001F7E 3E18                       		move.w	(a0)+,d7			; X position
00001F80 3218                       		move.w	(a0)+,d1			; Y position
00001F82 3401                       		move.w	d1,d2				; Copy
00001F84 6B00                       		bmi.s	.LoadNoY			; If the object is set to ignore Y checks, branch
00001F86 C245                       		and.w	d5,d1				; Keey Y in range
00001F88 B243                       		cmp.w	d3,d1
00001F8A 6500                       		bcs.s	.End				; Branch if in range
00001F8C B244                       		cmp.w	d4,d1
00001F8E 6300                       		bls.s	.Spawn				; Branch if in range
00001F90                            
00001F90                            .End:
00001F90 5448                       		addq.w	#2,a0				; Next objeect
00001F92 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001F94 4E75                       		rts
00001F96                            
00001F96                            .LoadNoY:
00001F96 C245                       		and.w	d5,d1				; Keey Y in range
00001F98                            
00001F98                            .Spawn:
00001F98 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F9C 3347 0014                  		move.w	d7,oXPos(a1)			; Store X position
00001FA0 3341 0018                  		move.w	d1,oYPos(a1)			; Store Y position
00001FA4                            
00001FA4 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001FA6 0242 0003                  		andi.w	#3,d2				; ''
00001FAA 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
00001FAE 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
00001FB2                            
00001FB2 1418                       		move.b	(a0)+,d2			; Get ID
00001FB4 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001FB6 D442                       		add.w	d2,d2
00001FB8 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00001FBC                            
00001FBC 1358 0024                  		move.b	(a0)+,oSubtype(a1)		; Set subtype
00001FC0 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00001FC4                            		
00001FC4 6000 F9EA                  		bra.w	FindFreeObj			; Find a free object slot
00001FC8                            		
00001FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FC8                            ; Check if the object is in range on the camera. If it isn't, delete it
00001FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FC8                            ; PARAMETERS:
00001FC8                            ;	a0.l	- Object space pointer
00001FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FC8                            ; RETURNS:
00001FC8                            ;	Nothing
00001FC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FC8                            CheckObjActive:
00001FC8 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00001FCC                            
00001FCC                            CheckObjActive2:
00001FCC 0240 FF80                  		andi.w	#$FF80,d0			; Only allow multiples of $80
00001FD0 9078 C7C6                  		sub.w	rObjXCoarse.w,d0		; Subtract the camera's coarse X position
00001FD4 0C40 0280                  		cmpi.w	#$280,d0			; Has it gone offscreen?
00001FD8 6200                       		bhi.s	.Delete				; If so, branch
00001FDA 4E75                       		rts
00001FDC                            
00001FDC                            .Delete:
00001FDC 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table entry address
00001FE0 6700                       		beq.s	.DoDelete			; If 0, branch
00001FE2 3440                       		movea.w	d0,a2
00001FE4 0892 0007                  		bclr	#7,(a2)				; Mark as gone
00001FE8                            
00001FE8                            .DoDelete:
00001FE8 4EF8 19E0                  		jmp	DeleteObject.w			; Delete the object
00001FEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FEC                            ; Get orientation to player
00001FEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FEC                            ; PARAMETERS:
00001FEC                            ;	a0.l	- Object space pointer
00001FEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FEC                            ; RETURNS:
00001FEC                            ;	a1.l	- Player object
00001FEC                            ;	d0.w	- 0 if player is left from object, 2 if right
00001FEC                            ;	d1.w	- 0 if player is above object, 2 if below
00001FEC                            ;	d2.w	- Player's horizontal distance to object
00001FEC                            ;	d3.w	- Player's vertical distance to object
00001FEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FEC                            GetOrientToPlayer:
00001FEC 7000                       		moveq	#0,d0
00001FEE 7200                       		moveq	#0,d1
00001FF0                            
00001FF0 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get player object
00001FF4                            
00001FF4 3428 0014                  		move.w	oXPos(a0),d2			; Get horizonal distance
00001FF8 9469 0014                  		sub.w	oXPos(a1),d2			; ''
00001FFC 6A00                       		bpl.s	.GetY				; Branch if the player is left from the object
00001FFE 5440                       		addq.w	#2,d0				; Set flag to indicate that the player is right from the object
00002000                            
00002000                            .GetY:
00002000 3628 0018                  		move.w	oYPos(a0),d3			; Get vertical distance
00002004 9669 0018                  		sub.w	oYPos(a1),d3			; ''
00002008 6400                       		bhs.s	.End				; Branch if the player is above the object
0000200A 5441                       		addq.w	#2,d1				; Set flag to indicate that the player is below the object
0000200C                            
0000200C                            .End:
0000200C 4E75                       		rts
0000200E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000200E                            ; Cap an object's speed
0000200E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000200E                            ; PARAMETERS:
0000200E                            ;	a0.l	- Object space pointer
0000200E                            ;	d0.w	- Max X speed
0000200E                            ;	d1.w	- Max Y speed
0000200E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000200E                            ; RETURNS:
0000200E                            ;	Nothing
0000200E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000200E                            CapObjSpeed:
0000200E 3428 001C                  		move.w	oXVel(a0),d2			; Get X velocity
00002012 6A00                       		bpl.s	.ChkRight			; If we are going right, branch
00002014 4440                       		neg.w	d0				; Get absolute speed
00002016 B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002018 6400                       		bhs.s	.ChkUp				; If not, branch
0000201A 3400                       		move.w	d0,d2				; Cap the speed
0000201C 6000                       		bra.s	.ChkUp				; Continue
0000201E                            
0000201E                            .ChkRight:
0000201E B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002020 6300                       		bls.s	.ChkUp				; If not, branch
00002022 3400                       		move.w	d0,d2				; Cap the speed
00002024                            
00002024                            .ChkUp:
00002024 3628 001E                  		move.w	oYVel(a0),d3			; Get Y velocity
00002028 6A00                       		bpl.s	.ChkDown			; If we are going right, branch
0000202A 4441                       		neg.w	d1				; Get absolute speed
0000202C B641                       		cmp.w	d1,d3				; Has it gone over the limit?
0000202E 6400                       		bhs.s	.UpdateVel			; If not, branch
00002030 3601                       		move.w	d1,d3				; Cap the speed
00002032 6000                       		bra.s	.UpdateVel			; Continue
00002034                            
00002034                            .ChkDown:
00002034 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
00002036 6300                       		bls.s	.UpdateVel			; If not, branch
00002038 3601                       		move.w	d1,d3				; Cap the speed
0000203A                            
0000203A                            .UpdateVel:
0000203A 3142 001C                  		move.w	d2,oXVel(a0)			; Set X velocity
0000203E 3142 001E                  		move.w	d2,oYVel(a0)			; Set Y velocity
00002042 4E75                       		rts
00002044                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002044                            ; Load a child object	NTP: no idea wtf to do about this one. do we even need it since all objects are kinda linked anyway? we'll have to see
00002044                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002044                            ; PARAMETERS:
00002044                            ;	a2.l	- Object data
00002044                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002044                            ; RETURNS:
00002044                            ;	Nothing
00002044                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002044                            ; LoadChildObject:
00002044 6100 F96A                  		bsr.w	FindFreeObj			; Find a free object slot
00002048 6600                       		bne.s	.End				; If there is non, branch
0000204A 301A                       		move.w	(a2)+,d0			; Get parent object SST
0000204C 3388 0000                  		move.w	a0,(a1,d0.w)			; Store parent object
00002050 301A                       		move.w	(a2)+,d0			; Get child object SST
00002052 3189 0000                  		move.w	a1,(a0,d0.w)			; Store child object
00002056 229A                       		move.l	(a2)+,oAddr(a1)			; Set object pointer
00002058 135A 0024                  		move.b	(a2)+,oSubtype(a1)		; Set subtype
0000205C 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)			; Set X
00002062 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)			; Set Y
00002068                            
00002068                            .End:
00002068 4E75                       		rts
0000206A                            ; =========================================================================================================================================================
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            ; Entry point
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            GameInit:
0000206A                            		intsOff						; Disable interrupts
0000206A 007C 0700                M 	ori	#$700,sr
0000206E                            		
0000206E                            		clrRAM	RAM_START, RAM_END			; Clear RAM
0000206E                          M 	local	endaddr
0000206E                          M endaddr	equs	"ram_end"
0000206E 7000                     M 	moveq	#0,d0
00002070 43F9 00FF 0000           M 	lea	ram_start,a1
00002076 323C 3FFF                M 	move.w	#(((ram_end)-(ram_start))-((ram_start)&1))>>2-1,d1
0000207A 22C0                     M .clear_72:	move.l	d0,(a1)+
0000207C 51C9 FFFC                M 	dbf	d1,.clear_72
00002080                            		
00002080 6100 E3DA                  		bsr.w	InitDMAQueue				; Initialize the DMA queue
00002084 6100 E136                  		bsr.w	InitVDP					; Initialize the VDP
00002088 4EB9 0000 0000             		jsr	LoadDualPCM				; Load Dual PCM
0000208E                            		
0000208E 1039 00A1 0001             		move.b	HW_VERSION,d0				; Get hardware version
00002094 0200 00C0                  		andi.b	#$C0,d0					; Just get region bits
00002098 11C0 C744                  		move.b	d0,rHWVersion.w				; Store in RAM
0000209C                            
0000209C 303C 4EF9                  		move.w	#$4EF9,d0				; JMP opcode
000020A0 31C0 C74A                  		move.w	d0,rVIntJmp.w				; Set the "JMP" command for V-INT
000020A4 31C0 C750                  		move.w	d0,rHIntJmp.w				; Set the "JMP" command for H-INT
000020A8 21FC 0000 0000 C74C        		move.l	#VInt_Standard,rVIntAddr.w		; Set the V-INT pointer to the standard V-INT routine
000020B0 21FC 0000 0000 C752        		move.l	#HInt_Water,rHIntAddr.w			; Set the H-INT pointer to the standard V-INT routine
000020B8                            
000020B8 4278 9000                  		clr.w	rDMAQueue.w				; Set stop token at the beginning of the DMA queue
000020BC 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w			; Reset the DMA queue slot
000020C2                            
000020C2 11FC 0004 C75A             		move.b	#gLevel,rGameMode.w			; Set game mode to "title"
000020C8 4EF9 0000 0000             		jmp	Level					; Go to the title screen
000020CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020CE                            ; Go to the correct game mode
000020CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020CE                            GotoGameMode:
000020CE 7000                       		moveq	#0,d0
000020D0 1038 C75A                  		move.b	rGameMode.w,d0				; Get game mode ID
000020D4 207B 0000                  		movea.l	.GameModes(pc,d0.w),a0			; Get pointer
000020D8 4ED0                       		jmp	(a0)					; Jump to it
000020DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020DA                            .GameModes:
000020DA 0000 0000                  		dc.l	TitleScreen				; Title screen
000020DE 0000 0000                  		dc.l	Level					; Level mode
000020E2 0000 0000                  		dc.l	Ending					; Ending
000020E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020E6                            ; Check for pausing
000020E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020E6                            CheckPause:
000020E6 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game already paused?
000020EA 6600                       		bne.s	.SetPause			; If so, branch
000020EC 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
000020F2 6700                       		beq.s	.End				; If not, branch
000020F4                            
000020F4                            .SetPause:
000020F4 50F8 C75C                  		st	rPauseFlag.w			; Pause the game
000020F8                            		AMPS_MUSPAUSE				; Pause the music
000020F8 11FC 0008 C4BE           M 	move.b	#mus_pause,mqueue+2.w
000020FE                            
000020FE                            .PauseLoop:
000020FE 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; General V-INT routine
00002104 6100 E988                  		bsr.w	VSync_Routine			; V-SYNC
00002108 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
0000210E 67EE                       		beq.s	.PauseLoop			; If not, branch
00002110                            
00002110                            		AMPS_MUSUNPAUSE				; Unpause the music
00002110 11FC 0009 C4BE           M 	move.b	#mus_unpause,mqueue+2.w
00002116 4238 C75C                  		clr.b	rPauseFlag.w			; Unpause the game
0000211A                            
0000211A                            .End:
0000211A 4E75                       		rts
0000211C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000211C                            ; Interrupts
0000211C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000211C                            VInt_Standard:
0000211C                            		intsOff					; Turn interrupts off
0000211C 007C 0700                M 	ori	#$700,sr
00002120                            		push.l	d0-a6				; Save registers
00002120 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002124                            		
00002124 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0000212A 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
0000212E                            
0000212E                            .WaitForVBLANK:
0000212E 3016                       		move.w	(a6),d0				; Get VDP status
00002130 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
00002134 67F8                       		beq.s	.WaitForVBLANK			; If not, wait
00002136                            
00002136 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
0000213C 6700                       		beq.s	.SetVScroll			; If not, branch
0000213E 303C 0700                  		move.w	#$700,d0			; Do a delay
00002142 51C8 FFFE                  		dbf	d0,*				; ''
00002146                            
00002146                            .SetVScroll:
00002146                            		dma68k	rVScroll,0,$50,VSRAM		; Load VScroll buffer into VSRAM
00002146 2CBC 9400 9328           M 	move.l	#$94009300|(((($50)/2)&$ff00)<<8)|((($50)/2)&$ff),(a6)
0000214C 2CBC 96CA 953F           M 	move.l	#$96009500|((((rvscroll)/2)&$ff00)<<8)|(((rvscroll)/2)&$ff),(a6)
00002152 3CBC 977F                M 	move.w	#$9700|(((rvscroll)>>17)&$7f),(a6)
00002156                          M 	vdpcmd	move.w,0,vsram,dma,>>16,(a6)
00002156 3CBC 4000                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000215A                          M 	vdpcmd	move.w,0,vsram,dma,&$ffff,-(sp)
0000215A 3F3C 0090                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000215E 3C9F                     M 	move.w	(sp)+,(a6)
00002160                            
00002160 4A38 C745                  		tst.b	rVINTRout.w			; Is the game lagging?
00002164 6700 0000                  		beq.w	VInt_Lag_Main			; If so, branch
00002168 4238 C748                  		clr.b	rLagCount.w			; Clear lag frame counter
0000216C                            
0000216C 7000                       		moveq	#0,d0
0000216E 1038 C745                  		move.b	rVINTRout.w,d0		; Get V-INT routine ID
00002172 4238 C745                  		clr.b	rVINTRout.w			; Clear V-INT routine ID
00002176 50F8 C749                  		st	rHIntFlag.w			; Allow the H-INT to run
0000217A 303B 0000                  		move.w	VInt_Routines(pc,d0.w),d0	; Get V-INT routine offset
0000217E 4EBB 0000                  		jsr	VInt_Routines(pc,d0.w)		; Jump to the routine
00002182                            
00002182                            VInt_FinishUpdates:
00002182 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002188                            
00002188                            VInt_End:
00002188 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
0000218C 6100 F154                  		bsr.w	RandomNumber			; Generate a random number
00002190                            		
00002190                            		pop.l	d0-a6				; Restore registers
00002190 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
00002194                            		intsOn					; Turn interrupts on
00002194 027C F8FF                M 	andi	#$f8ff,sr
00002198                            		lagOn					; Turn on the lag-o-meter
00002198 4E73                       		rte
0000219A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000219A                            ; V-INT routines
0000219A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000219A                            VInt_Routines:
0000219A 0000                       		dc.w	VInt_Lag-VInt_Routines		; Lag routine
0000219C 0000                       		dc.w	VInt_General-VInt_Routines	; General routine
0000219E 0000                       		dc.w	VInt_Level-VInt_Routines	; Level routine
000021A0 0000                       		dc.w	VInt_LevelLoad-VInt_Routines	; Level load routine
000021A2 0000                       		dc.w	VInt_Title-VInt_Routines	; Title screen routine
000021A4 0000                       		dc.w	VInt_Fade-VInt_Routines		; Fade routine
000021A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021A6                            ; V-INT lag routine
000021A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021A6                            VInt_Lag:
000021A6 584F                       		addq.w	#4,sp				; Don't return to caller
000021A8                            
000021A8                            VInt_Lag_Main:
000021A8 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
000021AC 6600                       		bne.s	.WaterPal			; If so, branch
000021AE                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
000021AE 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021B4 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
000021BA 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
000021BE                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021BE 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021C2                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021C2 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021C6 3C9F                     M 	move.w	(sp)+,(a6)
000021C8 6000                       		bra.s	.Cont				; Continue
000021CA                            
000021CA                            .WaterPal:
000021CA                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
000021CA 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021D0 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
000021D6 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
000021DA                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021DA 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021DE                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021DE 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021E2 3C9F                     M 	move.w	(sp)+,(a6)
000021E4                            
000021E4                            .Cont:	
000021E4 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
000021E8                            
000021E8 5238 C748                  		addq.b	#1,rLagCount.w		; Increment lag counter
000021EC 6000 FF94                  		bra.w	VInt_FinishUpdates		; Go update SMPS
000021F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021F0                            ; V-INT general routine
000021F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021F0                            VInt_General:
000021F0 6100 0000                  		bsr.w	VInt_Update			; Do updates
000021F4 6000 EE76                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000021F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021F8                            ; V-INT level load routine
000021F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021F8                            VInt_LevelLoad:
000021F8 6100 E844                  		bsr.w	ReadJoypads			; Read joypads
000021FC                            
000021FC 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
00002200 6600                       		bne.s	.WaterPal			; If so, branch
00002202                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
00002202 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002208 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
0000220E 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
00002212                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002212 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002216                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002216 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000221A 3C9F                     M 	move.w	(sp)+,(a6)
0000221C 6000                       		bra.s	.Cont				; Continue
0000221E                            
0000221E                            .WaterPal:
0000221E                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
0000221E 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002224 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
0000222A 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
0000222E                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000222E 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002232                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002232 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002236 3C9F                     M 	move.w	(sp)+,(a6)
00002238                            
00002238                            .Cont:
00002238 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
0000223C                            		
0000223C                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
0000223C 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
00002242 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
00002248 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
0000224C                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
0000224C 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
00002250                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
00002250 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
00002254 3C9F                     M 	move.w	(sp)+,(a6)
00002256                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002256 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
0000225C 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
00002262 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
00002266                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002266 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
0000226A                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
0000226A 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
0000226E 3C9F                     M 	move.w	(sp)+,(a6)
00002270 6100 E0BA                  		bsr.w	ProcessDMAQueue			; Process DMA queue
00002274                            		
00002274 6000 EDF6                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
00002278                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002278                            ; V-INT level routine
00002278                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002278                            VInt_Level:
00002278 43F8 F880                  		lea	rFGCam.w,a1			; Foreground level drawing variables
0000227C 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Foreground column plane buffer
00002280 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Foreground row plane buffer
00002284 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the foreground plane
0000228A 43F8 F89E                  		lea	rBGCam.w,a1			; Background level drawing variables
0000228E 47F8 C424                  		lea	rBGColBuf.w,a3		; Background column plane buffer
00002292 49F8 C322                  		lea	rBGRowBuf.w,a4		; Background row plane buffer
00002296 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the background plane
0000229C                            
0000229C 6100 E7A0                  		bsr.w	ReadJoypads			; Read joypads
000022A0                            
000022A0 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
000022A4 6600                       		bne.s	.WaterPal			; If so, branch
000022A6                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
000022A6 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000022AC 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
000022B2 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
000022B6                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000022B6 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000022BA                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000022BA 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000022BE 3C9F                     M 	move.w	(sp)+,(a6)
000022C0 6000                       		bra.s	.Cont				; Continue
000022C2                            
000022C2                            .WaterPal:
000022C2                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
000022C2 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000022C8 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
000022CE 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
000022D2                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000022D2 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000022D6                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000022D6 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000022DA 3C9F                     M 	move.w	(sp)+,(a6)
000022DC                            
000022DC                            .Cont:
000022DC 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
000022E0                            
000022E0                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
000022E0 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000022E6 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
000022EC 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
000022F0                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000022F0 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000022F4                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000022F4 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022F8 3C9F                     M 	move.w	(sp)+,(a6)
000022FA                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
000022FA 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002300 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
00002306 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
0000230A                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
0000230A 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
0000230E                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
0000230E 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002312 3C9F                     M 	move.w	(sp)+,(a6)
00002314 6100 E016                  		bsr.w	ProcessDMAQueue			; Process DMA queue
00002318                            		
00002318 0C38 005C C75F             		cmpi.b	#92,rHIntCnt.w		; Would V-INT be unable to do updates in the next frame?
0000231E 6400                       		bhs.s	.DoUpdates			; If not, branch
00002320 50F8 C75D                  		st	rHIntUpdates.W		; Set updates in H-INT flag
00002324 584F                       		addq.w	#4,sp				; Skip SMPS update routine afterwards
00002326 6100 ED44                  		bsr.w	SetKosBookmark			; Set Kosinski decompression bookmark
0000232A 6000 FE5C                  		bra.w	VInt_End			; Continue
0000232E                            
0000232E                            .DoUpdates:
0000232E 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
00002334 6000 ED36                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
00002338                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002338                            ; V-INT title screen update routine
00002338                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002338                            VInt_Title:
00002338 4E75                       		rts
0000233A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233A                            ;		bsr.w	ReadJoypads			; Read joypads
0000233A                            ;
0000233A                            ;		move.l	#$C0000000,VDP_CTRL		; Write palette to CRAM
0000233A                            ;		lea	rPalette.w,a0			; ''
0000233A                            ;		moveq	#$80>>2-1,d0			; ''
0000233A                            ;
0000233A                            ;.WritePal:
0000233A                            ;		move.l	(a0)+,VDP_DATA			; ''
0000233A                            ;		dbf	d0,.WritePal			; ''
0000233A                            ;
0000233A                            ;		move.l	#$78000003,VDP_CTRL		; Write sprite data to VRAM
0000233A                            ;		lea	rSprites.w,a0			; ''
0000233A                            ;		move.w	#$280>>2-1,d0			; ''
0000233A                            ;
0000233A                            ;.WriteSprs:
0000233A                            ;		move.l	(a0)+,VDP_DATA			; ''
0000233A                            ;		dbf	d0,.WriteSprs			; ''
0000233A                            ;
0000233A                            ;		move.l	#$7C000003,VDP_CTRL		; Write HScroll table to VRAM
0000233A                            ;		lea	rHScroll.w,a0			; ''
0000233A                            ;		move.w	#$380>>2-1,d0			; ''
0000233A                            ;
0000233A                            ;.WriteHScrl:
0000233A                            ;		move.l	(a0)+,VDP_DATA			; ''
0000233A                            ;		dbf	d0,.WriteHScrl			; ''
0000233A                            ;		rts
0000233A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233A                            ; Do standard updates in V-INT
0000233A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233A                            VInt_Update:
0000233A                            	; NTP: We don't want to update sprites during a fade, thus it's not shared with the below interrupt routine
0000233A                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
0000233A 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
00002340 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
00002346 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
0000234A                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
0000234A 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000234E                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000234E 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
00002352 3C9F                     M 	move.w	(sp)+,(a6)
00002354                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002354                            ; V-INT fade routine
00002354                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002354                            VInt_Fade:
00002354 6100 E6E8                  		bsr.w	ReadJoypads			; Read joypads
00002358                            
00002358 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
0000235C 6600                       		bne.s	.WaterPal			; If so, branch
0000235E                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
0000235E 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002364 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
0000236A 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
0000236E                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000236E 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002372                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002372 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002376 3C9F                     M 	move.w	(sp)+,(a6)
00002378 6000                       		bra.s	.Cont				; Continue
0000237A                            
0000237A                            .WaterPal:
0000237A                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
0000237A 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002380 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002386 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
0000238A                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000238A 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000238E                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000238E 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002392 3C9F                     M 	move.w	(sp)+,(a6)
00002394                            
00002394                            .Cont:
00002394 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
00002398                            
00002398                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002398 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
0000239E 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
000023A4 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
000023A8                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
000023A8 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
000023AC                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
000023AC 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
000023B0 3C9F                     M 	move.w	(sp)+,(a6)
000023B2 6000 DF78                  		bra.w	ProcessDMAQueue			; Process DMA queue
000023B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023B6                            ; V-INT routine that only runs the SMPS driver
000023B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023B6                            VInt_RunSMPS:
000023B6                            		push.l	d0-a6				; Save registers
000023B6 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000023BA                            		
000023BA                            .WaitForVBLANK:
000023BA 3039 00C0 0004             		move.w	VDP_CTRL,d0			; Get VDP status
000023C0 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
000023C4 67F4                       		beq.s	.WaitForVBLANK			; If not, wait
000023C6                            
000023C6 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
000023CC 6700                       		beq.s	.UpdateSMPS			; If not, branch
000023CE 303C 0700                  		move.w	#$700,d0			; Do a delay
000023D2 51C8 FFFE                  		dbf	d0,*				; ''
000023D6                            
000023D6                            .UpdateSMPS:
000023D6 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
000023DC                            
000023DC 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
000023E0 6100 EF00                  		bsr.w	RandomNumber			; Generate a random number
000023E4                            		
000023E4                            		pop.l	d0-a6				; Restore registers
000023E4 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
000023E8 4E73                       		rte
000023EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EA                            ; Title screen
000023EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EA                            		include	"Title Screen/Main.asm"
000023EA                            ; =========================================================================================================================================================
000023EA                            ; Mighty The Armadillo in PRISM PARADISE
000023EA                            ; By Nat The Porcupine 2021
000023EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EA                            ; Title splash screen
000023EA                            ; =========================================================================================================================================================
000023EA                            
000023EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EA                            TitleScreen:
000023EA 60FE                       		bra.s	TitleScreen
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
000023EC                            ;		playSnd	#Mus_Stop, 1			; Stop sound
000023EC                            ;
000023EC                            ;		bsr.w	FadeToBlack			; Fade to black
000023EC                            ;
000023EC                            ;		intsOff					; Disable interrupts
000023EC                            ;		clrRAM	rKosPVars
000023EC                            ;		clrRAM	rChkpoint
000023EC                            ;		clrRAM	rGameVars
000023EC                            ;		clrRAM	rObjects
000023EC                            ;
000023EC                            ;		lea	VDP_CTRL,a5
000023EC                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
000023EC                            ;		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
000023EC                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
000023EC                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
000023EC                            ;		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
000023EC                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
000023EC                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
000023EC                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
000023EC                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
000023EC                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
000023EC                            ;
000023EC                            ;		bsr.w	ClearScreen			; Clear screen
000023EC                            ;
000023EC                            ;		lea	rDestPal.w,a0			; Fade target palette
000023EC                            ;		moveq	#$80>>2-1,d0			; Size
000023EC                            ;
000023EC                            ;.FillPal:
000023EC                            ;		move.l	#$0EEE0EEE,(a0)+		; Fill palette with white
000023EC                            ;		dbf	d0,.FillPal			; Loop
000023EC                            ;
000023EC                            ;		bsr.w	FadeFromBlack			; Fade from black
000023EC                            ;		
000023EC                            ;		bsr.w	SEGA_FMV			; Run SEGA FMV
000023EC                            ;
000023EC                            ;TitleScreen2:
000023EC                            ;		intsOff
000023EC                            ;
000023EC                            ;		clr.b	rArtCheat.w
000023EC                            ;		clrRAM	rGameVars
000023EC                            ;		clrRAM	rObjects
000023EC                            ;
000023EC                            ;		move.w	#$8200|($C000/$400),VDP_CTRL	; Reset plane A address
000023EC                            ;		bsr.w	FadeToWhite			; Fade to white
000023EC                            ;
000023EC                            ;		intsOff
000023EC                            ;		bsr.w	ClearScreen			; Clear screen
000023EC                            ;
000023EC                            ;		lea	MapEni_TitleBG,a0		; Decompress background mappings
000023EC                            ;		lea	rBuffer,a1			; Decompress into RAM
000023EC                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
000023EC                            ;		bsr.w	EniDec				; Decompress!
000023EC                            ;
000023EC                            ;		lea	rBuffer,a1			; Load mappings
000023EC                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
000023EC                            ;		moveq	#$27,d1				; $28x$1C tiles
000023EC                            ;		moveq	#$1B,d2				; ''
000023EC                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000023EC                            ;		bsr.w	LoadPlaneMap			; Load the map
000023EC                            ;
000023EC                            ;		lea	MapEni_TitleLogo,a0		; Decompress logo mappings
000023EC                            ;		lea	rBuffer,a1			; Decompress into RAM
000023EC                            ;		move.w	#$8370,d0			; Base tile properties: Tile ID 1, no flags
000023EC                            ;		bsr.w	EniDec				; Decompress!
000023EC                            ;
000023EC                            ;		lea	rBuffer,a1			; Load mappings
000023EC                            ;		move.l	#$41040003,d0			; At (0, 0) on plane A
000023EC                            ;		moveq	#$E,d1				; $28x$1C tiles
000023EC                            ;		moveq	#$C,d2				; ''
000023EC                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000023EC                            ;		bsr.w	LoadPlaneMap			; Load the map
000023EC                            ;
000023EC                            ;		lea	Pal_Title,a0			; Load palette to target buffer
000023EC                            ;		move.w	#(Pal_Title_End-Pal_Title)>>1-1,d0
000023EC                            ;		bsr.w	LoadTargetPal			; ''
000023EC                            ;
000023EC                            ;		lea	ArtKosM_TitleBG,a1		; Load background art
000023EC                            ;		move.w	#$20,d2				; ''
000023EC                            ;		bsr.w	QueueKosMData			; ''
000023EC                            ;
000023EC                            ;		lea	ArtKosM_TitleLogo,a1		; Load logo art
000023EC                            ;		move.w	#$6E00,d2			; ''
000023EC                            ;		bsr.w	QueueKosMData			; ''
000023EC                            ;
000023EC                            ;		lea	ArtKosM_TtlSonic,a1		; Load Sonic art
000023EC                            ;		move.w	#$4000,d2			; ''
000023EC                            ;		bsr.w	QueueKosMData			; ''
000023EC                            ;
000023EC                            ;		lea	ArtKosM_TtlBird,a1		; Load bird art
000023EC                            ;		move.w	#$8400,d2			; ''
000023EC                            ;		bsr.w	QueueKosMData			; ''
000023EC                            ;
000023EC                            ;		lea	ArtKosM_TtlGlove,a1		; Load glove art
000023EC                            ;		move.w	#$8600,d2			; ''
000023EC                            ;		bsr.w	QueueKosMData			; ''
000023EC                            ;
000023EC                            ;.WaitPLCs:
000023EC                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023EC                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000023EC                            ;		jsr	VSync_Routine.w			; V-SYNC
000023EC                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000023EC                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
000023EC                            ;		bne.s	.WaitPLCs			; If so, branch
000023EC                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023EC                            ;		jsr	VSync_Routine.w			; V-SYNC
000023EC                            ;		
000023EC                            ;		move.l	#ObjTtlSonic,rObj_0.w		; Load the Sonic object
000023EC                            ;		move.w	#320+96,(rObj_0+oX).w		; Set X
000023EC                            ;		move.w	#128,(rObj_0+oY).w		; Set Y
000023EC                            ;
000023EC                            ;		move.l	#ObjTtlBird,rObj_1.w		; Load the bird object
000023EC                            ;		move.w	#-64,(rObj_1+oX).w		; Set X
000023EC                            ;		move.w	#64,(rObj_1+oY).w		; Set Y
000023EC                            ;
000023EC                            ;		move.l	#ObjTtlGlove,rObj_2.w		; Load the glove object
000023EC                            ;		move.w	#224,(rObj_2+oX).w		; Set X
000023EC                            ;		move.w	#320,(rObj_2+oY).w		; Set Y
000023EC                            ;
000023EC                            ;		jsr	RunObjects.w			; Run objects
000023EC                            ;		jsr	RenderObjects.w			; Render objects
000023EC                            ;
000023EC                            ;		clr.w	rPalCycTimer.w		; Reset palette cycle
000023EC                            ;
000023EC                            ;		bsr.w	FadeFromWhite			; Fade from white
000023EC                            ;
000023EC                            ;		lea	SampleList+$C0,a3		; Play title screen music
000023EC                            ;		jsr	PlayDAC1			; ''
000023EC                            ;
000023EC                            ;.Loop:
000023EC                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
000023EC                            ;		bsr.w	VSync_Routine			; ''
000023EC                            ;
000023EC                            ;		bsr.s	Title_Updates			; Do updates
000023EC                            ;		
000023EC                            ;		jsr	RunObjects.w			; Run objects
000023EC                            ;		jsr	RenderObjects.w			; Render objects
000023EC                            ;
000023EC                            ;		lea	FreeMove_Cheat(pc),a0
000023EC                            ;		lea	rMoveCheat.w,a1
000023EC                            ;		lea	rCheatEntry.w,a2
000023EC                            ;		bsr.w	Title_ChkCheats
000023EC                            ;		lea	Art_Cheat(pc),a0
000023EC                            ;		lea	rArtCheat.w,a1
000023EC                            ;		lea	rCheatEntry2.w,a2
000023EC                            ;		bsr.w	Title_ChkCheats
000023EC                            ;
000023EC                            ;		tst.b	rArtCheat.w
000023EC                            ;		bne.w	BinbowieArt
000023EC                            ;
000023EC                            ;		tst.b	rP1Press.w			; Has start been pressed
000023EC                            ;		bpl.s	.Loop				; If so, branch
000023EC                            ;
000023EC                            ;		st	(rObj_2+oGloveFlag).w		; Set the punch flag
000023EC                            ;
000023EC                            ;		lea	SampleList+$E0,a3		; Punch
000023EC                            ;		jsr	PlayDAC1			; ''
000023EC                            ;
000023EC                            ;.PunchLoop:
000023EC                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
000023EC                            ;		bsr.w	VSync_Routine			; ''
000023EC                            ;
000023EC                            ;		bsr.s	Title_Updates			; Do updates
000023EC                            ;
000023EC                            ;		jsr	RunObjects.w			; Run objects
000023EC                            ;		jsr	RenderObjects.w			; Render objects
000023EC                            ;		
000023EC                            ;		tst.b	(rObj_2+oGloveTime).w		; Has the timer run out?
000023EC                            ;		bpl.s	.PunchLoop			; If not, loop
000023EC                            ;		
000023EC                            ;		st	rStartFall.w			; Set flag to start the level by falling
000023EC                            ;
000023EC                            ;		move.b	#gLevel,rGameMode.w		; Set game mode to "level"
000023EC                            ;		jmp	Level				; Go to level
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; Palette cycle
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;Title_Updates:
000023EC                            ;		move.b	rLogoAngle.w,d0		; Get logo hover angle
000023EC                            ;		addq.b	#4,rLogoAngle.w		; Increment angle
000023EC                            ;		jsr	CalcSine.w			; Get sine
000023EC                            ;		asr.w	#5,d0				; ''
000023EC                            ;		move.w	d0,rVScrollFG.w		; Set logo's Y position
000023EC                            ;
000023EC                            ;		subq.b	#1,rPalCycTimer.w		; Decrement timer
000023EC                            ;		bpl.s	.End				; If it hasn't run out, branch
000023EC                            ;		move.b	#6,rPalCycTimer.w		; Reset timer
000023EC                            ;		
000023EC                            ;		moveq	#0,d0
000023EC                            ;		move.b	rPalCycIndex.w,d0		; Get index
000023EC                            ;		mulu.w	#$C,d0				; Turn into offset
000023EC                            ;		lea	PalCyc_Title(pc,d0.w),a0	; Get pointer to palette data
000023EC                            ;		lea	(rPalette+$14).w,a1		; Palette
000023EC                            ;		move.w	(a0)+,(a1)+			; Load palette
000023EC                            ;		move.w	(a0)+,(a1)+			; ''
000023EC                            ;		move.w	(a0)+,(a1)+			; ''
000023EC                            ;		move.w	(a0)+,(a1)+			; ''
000023EC                            ;		move.w	(a0)+,(a1)+			; ''
000023EC                            ;		move.w	(a0)+,(a1)+			; ''
000023EC                            ;		
000023EC                            ;		addq.b	#1,rPalCycIndex.w		; Increment index
000023EC                            ;		cmpi.b	#6,rPalCycIndex.w		; Has it reached the end?
000023EC                            ;		bcs.s	.End				; If not, branch
000023EC                            ;		clr.b	rPalCycIndex.w		; Reset index
000023EC                            
000023EC                            ;.End:
000023EC                            ;		rts
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;PalCyc_Title:
000023EC                            ;		dc.w	$00E, $08E, $0EE, $0E0, $E00, $808
000023EC                            ;		dc.w	$08E, $0EE, $0E0, $E00, $808, $00E
000023EC                            ;		dc.w	$0EE, $0E0, $E00, $808, $00E, $08E
000023EC                            ;		dc.w	$0E0, $E00, $808, $00E, $08E, $0EE
000023EC                            ;		dc.w	$E00, $808, $00E, $08E, $0EE, $0E0
000023EC                            ;		dc.w	$808, $00E, $08E, $0EE, $0E0, $E00
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; Check for cheats
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;Title_ChkCheats:
000023EC                            ;		tst.b	(a1)
000023EC                            ;		bne.s	.End
000023EC                            ;		move.w	(a2),d0
000023EC                            ;		adda.w	d0,a0
000023EC                            ;		move.b	rP1Press.w,d0
000023EC                            ;		cmp.b	(a0),d0
000023EC                            ;		bne.s	.ResetCheat
000023EC                            ;		addq.w	#1,(a2)
000023EC                            ;		tst.b	d0
000023EC                            ;		bne.s	.End
000023EC                            ;		st	(a1)
000023EC                            ;		playSnd	#sRing, 2
000023EC                            ;		rts
000023EC                            ;
000023EC                            ;.ResetCheat:
000023EC                            ;		tst.b	d0
000023EC                            ;		beq.s	.End
000023EC                            ;		clr.w	(a2)
000023EC                            ;
000023EC                            ;.End:
000023EC                            ;		rts
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;FreeMove_Cheat:
000023EC                            ;		dc.b	1, 2, 4, 8, 0, $FF
000023EC                            ;		even
000023EC                            ;Art_Cheat:
000023EC                            ;		dc.b	1, 1, 2, 2, 4, 8, 4, 8, $40, $10, $40, $10, 0, $FF
000023EC                            ;		even
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; BinBowie's art
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;BinbowieArt:
000023EC                            ;		bsr.w	FadeToWhite			; Fade to white
000023EC                            ;		
000023EC                            ;		lea	SampleList,a3
000023EC                            ;		jsr	PlayDAC1
000023EC                            ;
000023EC                            ;		intsOff
000023EC                            ;
000023EC                            ;		jsr	ClearScreen.w
000023EC                            ;
000023EC                            ;		lea	MapEni_BinBowieArt(pc),a0	; Decompress mappings
000023EC                            ;		lea	rBuffer,a1			; Decompress into RAM
000023EC                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
000023EC                            ;		bsr.w	EniDec				; Decompress!
000023EC                            ;
000023EC                            ;		lea	rBuffer,a1			; Load mappings
000023EC                            ;		move.l	#$40000003,d0			; At (0, 0) on plane A
000023EC                            ;		moveq	#$27,d1				; $28x$1C tiles
000023EC                            ;		moveq	#$1B,d2				; ''
000023EC                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000023EC                            ;		bsr.w	LoadPlaneMap			; Load the map
000023EC                            ;
000023EC                            ;		lea	Pal_BinBowieArt,a0		; Load palette to target buffer
000023EC                            ;		move.w	#(Pal_BinBowieArt_End-Pal_BinBowieArt)>>1-1,d0
000023EC                            ;		bsr.w	LoadTargetPal			; ''
000023EC                            ;
000023EC                            ;		lea	ArtKosM_BinBowieArt,a1		; Load art
000023EC                            ;		move.w	#$20,d2				; ''
000023EC                            ;		bsr.w	QueueKosMData			; ''
000023EC                            ;
000023EC                            ;.WaitPLCs:
000023EC                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023EC                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000023EC                            ;		jsr	VSync_Routine.w			; V-SYNC
000023EC                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000023EC                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
000023EC                            ;		bne.s	.WaitPLCs			; If so, branch
000023EC                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000023EC                            ;		jsr	VSync_Routine.w			; V-SYNC
000023EC                            ;
000023EC                            ;		jsr	FadeFromWhite.w
000023EC                            ;
000023EC                            ;		lea	SampleList+$100,a3
000023EC                            ;		jsr	PlayDAC1
000023EC                            ;
000023EC                            ;.Loop:
000023EC                            ;		move.b	#vTitle,rVINTRout.w		; Level load V-INT routine
000023EC                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000023EC                            ;		move.b	rP1Press.w,d0
000023EC                            ;		andi.b	#%10010000,d0
000023EC                            ;		beq.s	.Loop
000023EC                            ;
000023EC                            ;		jmp	TitleScreen2
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; Objects
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;		include	"Title Screen/Objects/Sonic/Code.asm"
000023EC                            ;		include	"Title Screen/Objects/Bird/Code.asm"
000023EC                            ;		include	"Title Screen/Objects/Glove/Code.asm"
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; Art
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;ArtKosM_TitleBG:
000023EC                            ;		incbin	"Title Screen/Data/Art - Background.kosm.bin"
000023EC                            ;		even
000023EC                            ;ArtKosM_TitleLogo:
000023EC                            ;		incbin	"Title Screen/Data/Art - Logo.kosm.bin"
000023EC                            ;		even
000023EC                            ;ArtKosM_BinBowieArt:
000023EC                            ;		incbin	"Title Screen/Data/Art - BinBowie.kosm.bin"
000023EC                            ;		even
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; Plane mappings
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;MapEni_TitleBG:
000023EC                            ;		incbin	"Title Screen/Data/Map - Background.eni.bin"
000023EC                            ;		even
000023EC                            ;MapEni_TitleLogo:
000023EC                            ;		incbin	"Title Screen/Data/Map - Logo.eni.bin"
000023EC                            ;		even
000023EC                            ;MapEni_BinBowieArt:
000023EC                            ;		incbin	"Title Screen/Data/Map - BinBowie.eni.bin"
000023EC                            ;		even
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; Palette
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;Pal_Title:
000023EC                            ;		incbin	"Title Screen/Data/Palette.pal.bin"
000023EC                            ;Pal_Title_End:
000023EC                            ;		even
000023EC                            ;Pal_BinBowieArt:
000023EC                            ;		incbin	"Title Screen/Data/BinBowie Palette.pal.bin"
000023EC                            ;Pal_BinBowieArt_End:
000023EC                            ;		even
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; SEGA FMV
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ;		include	"Title Screen/SEGA FMV/FMV.asm"
000023EC                            ; =========================================================================================================================================================
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; Level
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            		include	"Level/Main.asm"
000023EC                            ; =========================================================================================================================================================
000023EC                            ; Mighty The Armadillo in PRISM PARADISE
000023EC                            ; By Nat The Porcupine 2021
000023EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023EC                            ; Level
000023EC                            ; =========================================================================================================================================================
000023EC                            Level:
000023EC                            		playSnd	#Mus_FadeOut, 1			; Fade out sound
000023EC 11FC 0002 C4BC           M 	move.b	#mus_fadeout,(mqueue+((1)-1)).w
000023F2                            
000023F2 4EB8 04D6                  		jsr	FadeToBlack			; Fade to black
000023F6                            
000023F6                            Level_NoFade:
000023F6                            		; --- Set up the VDP ---
000023F6                            
000023F6                            		intsOff					; Disable interrupts
000023F6 007C 0700                M 	ori	#$700,sr
000023FA                            		displayOff				; Disable display
000023FA 3038 C764                M 	move.w	rvdpreg1.w,d0
000023FE 0200 00BF                M 	andi.b	#%10111111,d0
00002402 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
00002408                            
00002408 4BF9 00C0 0004             		lea	VDP_CTRL,a5			; VDP control port
0000240E 3ABC 8004                  		move.w	#$8004,(a5)			; Disable H-INT
00002412 3ABC 8230                  		move.w	#$8230,(a5)			; Plane A at $C000
00002416 3ABC 8407                  		move.w	#$8407,(a5)			; Plane B at $E000
0000241A 3ABC 8720                  		move.w	#$8720,(a5)			; Set background color to palette line 2, entry 0
0000241E 3ABC 8B03                  		move.w	#$8B03,(a5)			; V-Scroll by screen, H-Scroll by scanline
00002422 3ABC 9001                  		move.w	#$9001,(a5)			; 64x32 cell plane area
00002426 303C 9200                  		move.w	#$9200,d0			; Make the window invisible
0000242A 31C0 C766                  		move.w	d0,rWindowY.w			; ''
0000242E 3A80                       		move.w	d0,(a5)				; ''
00002430 4278 9000                  		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
00002434 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
0000243A                            
0000243A 4EB8 01CC                  		jsr	ClearScreen.w			; Clear the screen
0000243E                            
0000243E                            		; --- Clear some RAM ---
0000243E                            
0000243E                            		clrRAM	rKosPVars			; Clear Kosinski queue variables
0000243E                          M 	local	endaddr
0000243E                          M endaddr	equs	"rkospvars_End"
0000243E 7000                     M 	moveq	#0,d0
00002440 43F8 994E                M 	lea	(rkospvars).w,a1
00002444 323C 0040                M 	move.w	#(((rkospvars_end)-(rkospvars))-((rkospvars)&1))>>2-1,d1
00002448 22C0                     M .clear_130:	move.l	d0,(a1)+
0000244A 51C9 FFFC                M 	dbf	d1,.clear_130
0000244E 32C0                     M 	move.w	d0,(a1)+
00002450                            		clrRAM	rGameVars			; Clear variables
00002450                          M 	local	endaddr
00002450                          M endaddr	equs	"rgamevars_End"
00002450 7000                     M 	moveq	#0,d0
00002452 43F8 C7D0                M 	lea	(rgamevars).w,a1
00002456 323C 0DCB                M 	move.w	#(((rgamevars_end)-(rgamevars))-((rgamevars)&1))>>2-1,d1
0000245A 22C0                     M .clear_131:	move.l	d0,(a1)+
0000245C 51C9 FFFC                M 	dbf	d1,.clear_131
00002460                            		clrRAM	rOscNums			; Clear oscillation data
00002460                          M 	local	endaddr
00002460                          M endaddr	equs	"roscnums_End"
00002460 7000                     M 	moveq	#0,d0
00002462 43F8 C76A                M 	lea	(roscnums).w,a1
00002466 323C 000F                M 	move.w	#(((roscnums_end)-(roscnums))-((roscnums)&1))>>2-1,d1
0000246A 22C0                     M .clear_132:	move.l	d0,(a1)+
0000246C 51C9 FFFC                M 	dbf	d1,.clear_132
00002470 32C0                     M 	move.w	d0,(a1)+
00002472                            
00002472                            		; --- Do some final initializing and play the level music ---
00002472                            
00002472 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Set ring animation timer
00002478 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set floor timer
0000247E 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset palette cycle
00002482                            
00002482 41FA 0000                  		lea	Level_MusicIDs(pc),a0		; Music ID list
00002486 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
0000248A E218                       		ror.b	#1,d0				; Turn into offset
0000248C EE48                       		lsr.w	#7,d0				; ''
0000248E 1030 0000                  		move.b	(a0,d0.w),d0			; Get music ID
00002492 11C0 F8D6                  		move.b	d0,rLevelMusic.w		; Store it
00002496                            		playSnd	d0, 1				; Play it
00002496 11C0 C4BC                M 	move.b	d0,(mqueue+((1)-1)).w
0000249A                            
0000249A                            		intsOn					; Enable interrupts
0000249A 027C F8FF                M 	andi	#$f8ff,sr
0000249E                            
0000249E                            		; --- Load level data ---
0000249E                            
0000249E 47F9 0000 0000             		lea	PLC_LevelMain,a3		; Load main level PLCs
000024A4 4EB8 0EE0                  		jsr	LoadKosMQueue.w			; ''
000024A8                            
000024A8 4EB8 1952                  		jsr	InitObjectList.w
000024AC                            
000024AC 4EB8 19B0                  		jsr	FindFreeObj.w
000024B0 22BC 0000 0000             		move.l	#ObjMighty,oAddr(a1)		; Load Mighty object
000024B6 31C9 F86C                  		move.w	a1,rPlayer1Addr.w		; Store the address
000024BA                            
000024BA 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
000024BE 6700                       		beq.s	.NoSurface			; If not, branch
000024C0                            
000024C0                            							; Load water surfaces
000024C0 4EB8 19B0                  		jsr	FindFreeObj.w
000024C4 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
000024CA 337C 0060 0014             		move.w	#$60,oXPos(a1)
000024D0 31C9 F87C                  		move.w	a1,rWater1Addr.w		; Store the address
000024D4                            
000024D4 4EB8 19B0                  		jsr	FindFreeObj.w
000024D8 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
000024DE 337C 0120 0014             		move.w	#$120,oXPos(a1)
000024E4 31C9 F87E                  		move.w	a1,rWater2Addr.w		; Store the address
000024E8                            
000024E8                            .NoSurface:
000024E8 6100 0000                  		bsr.w	Level_LoadData			; Load level data
000024EC                            
000024EC                            .WaitPLCs:
000024EC 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
000024F2 4EB8 1096                  		jsr	ProcessKos.w			; Process Kosinski queue
000024F6 4EB8 0A8E                  		jsr	VSync_Routine.w			; V-SYNC
000024FA 4EB8 0F42                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000024FE 4A38 9990                  		tst.b	rKosPMMods.w			; Are there still modules left?
00002502 66E8                       		bne.s	.WaitPLCs			; If so, branch
00002504                            
00002504 4238 F8F4                  		clr.b	rWaterFlag.w			; Clear the water flag
00002508                            
00002508 41FA 0000                  		lea	Level_WaterLevels(pc),a0	; Water heights
0000250C 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00002510 E218                       		ror.b	#1,d0				; Turn into offset
00002512 EC48                       		lsr.w	#6,d0				; ''
00002514 3030 0000                  		move.w	(a0,d0.w),d0			; Get water height
00002518 6B00                       		bmi.s	.NoWater			; If it's negative, branch
0000251A 31C0 F8F6                  		move.w	d0,rWaterLvl.w		; Set the water height
0000251E 31C0 F8F8                  		move.w	d0,rDestWtrLvl.w
00002522                            
00002522 50F8 F8F4                  		st	rWaterFlag.w			; Set the water flag
00002526 33FC 8014 00C0 0004        		move.w	#$8014,VDP_CTRL			; Enable H-INT
0000252E 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
00002532 33F8 C75E 00C0 0004        		move.w	rHIntReg.w,VDP_CTRL		; Set H-INT counter
0000253A                            
0000253A                            .NoWater:
0000253A 31FC 00A0 F8D2             		move.w	#320/2,rCamXPosCenter.w		; Set camera X center
00002540                            
00002540 4EB8 1878                  		jsr	InitOscillation.w		; Initialize oscillation
00002544                            
00002544 6100 0000                  		bsr.w	Level_HandleCamera		; Initialize the camera
00002548 6100 0000                  		bsr.w	Level_InitHUD			; Initialize the HUD
0000254C 6100 0000                  		bsr.w	Level_WaterHeight		; Initialize water height
00002550                            
00002550 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
00002554                            
00002554                            		; --- Load the planes ---
00002554                            
00002554                            		intsOff					; Disable interrupts
00002554 007C 0700                M 	ori	#$700,sr
00002558 21FC 0000 23B6 C74C        		move.l	#VInt_RunSMPS,rVIntAddr.w	; Swap V-INT
00002560                            		intsOn					; Enable interrupts
00002560 027C F8FF                M 	andi	#$f8ff,sr
00002564 6100 0000                  		bsr.w	Level_InitPlanes		; Initialize the planes
00002568                            		intsOff					; Disable interrupts
00002568 007C 0700                M 	ori	#$700,sr
0000256C 21FC 0000 211C C74C        		move.l	#VInt_Standard,rVIntAddr.w	; Swap V-INT
00002574                            		intsOn					; Enable interrupts
00002574 027C F8FF                M 	andi	#$f8ff,sr
00002578 11FC 0006 C745             		move.b	#vLvlLoad,rVINTRout.w		; Level load V-INT routine
0000257E 4EB8 0A8E                  		jsr	VSync_Routine.w			; V-SYNC
00002582                            
00002582                            		; --- Load the level objects and rings ---
00002582                            
00002582 51F8 C7B8                  		sf	rObjManInit.w			; Reset object manager routine
00002586 6100 0000                  		bsr.w	Level_RingsManager		; Initialize the ring manager
0000258A 4EB8 1D5C                  		jsr	ObjectManager.w			; Run the object manager
0000258E                            	runObjects
0000258E 3078 BE58                M 	movea.w	rtailnext.w,a0
00002592 2250                     M 	move.l	oaddr(a0),a1
00002594 4E91                     M 	jsr	(a1)
00002596 4EB8 1A5E                  		jsr	RenderObjects.w			; Render objects
0000259A                            
0000259A 4238 F8FC                  		clr.b	rLvlReload.w			; Clear the level reload flag
0000259E                            
0000259E                            		displayOn				; Enable display
0000259E 3038 C764                M 	move.w	rvdpreg1.w,d0
000025A2 0000 0040                M 	ori.b	#%01000000,d0
000025A6 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
000025AC 4EB8 0552                  		jsr	FadeFromBlack.w			; Fade from black
000025B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000025B0                            ; Main loop
000025B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000025B0                            .Loop:
000025B0 11FC 0004 C745             		move.b	#vLevel,rVINTRout.w		; Level V-INT routine
000025B6 4EB8 1096                  		jsr	ProcessKos.w			; Process Kosinski queue
000025BA 4EB8 0A8E                  		jsr	VSync_Routine.w			; V-SYNC
000025BE                            
000025BE 4EB8 20E6                  		jsr	CheckPause.w			; Check for pausing
000025C2 5278 F8FA                  		addq.w	#1,rLvlFrames.w			; Increment frame counter
000025C6                            
000025C6 4EB8 18CC                  		jsr	UpdateOscillation.w		; Update oscillation
000025CA                            
000025CA 6100 0000                  		bsr.w	Level_RingsManager		; Run the ring manager
000025CE 4EB8 1D5C                  		jsr	ObjectManager.w			; Run the object manager
000025D2                            
000025D2                            	runObjects
000025D2 3078 BE58                M 	movea.w	rtailnext.w,a0
000025D6 2250                     M 	move.l	oaddr(a0),a1
000025D8 4E91                     M 	jsr	(a1)
000025DA                            
000025DA 4A38 F8FC                  		tst.b	rLvlReload.w			; Does the level need to be reloaded?
000025DE 6600 FE0C                  		bne.w	Level				; If so, branch
000025E2                            
000025E2 6100 0000                  		bsr.w	Level_HandleCamera		; Handle the camera
000025E6 6100 0000                  		bsr.w	Level_UpdatePlanes		; Update the planes (draw new tiles and scroll)
000025EA 6100 0000                  		bsr.w	Level_UpdateWaterSurface	; Update the water surface
000025EE                            
000025EE 4EB8 1A5E                  		jsr	RenderObjects.w			; Render objects
000025F2                            
000025F2 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
000025F6 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
000025FA 6100 0000                  		bsr.w	Level_PalCycle			; Do palette cycling
000025FE 6100 0000                  		bsr.w	Level_DynEvents			; Run dynamic events
00002602                            
00002602 5338 F3D8                  		subq.b	#1,rRingAniTime.w		; Decrement ring animation timer
00002606 6A00                       		bpl.s	.NoRingAni			; If it hasn't run out, branch
00002608 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Reset animation timer
0000260E 5238 F3D7                  		addq.b	#1,rRingFrame.w			; Next ring frame
00002612 0238 0007 F3D7             		andi.b	#7,rRingFrame.w			; Limit it
00002618                            
00002618 7000                       		moveq	#0,d0
0000261A 1038 F3D7                  		move.b	rRingFrame.w,d0			; Get ring frame
0000261E EF48                       		lsl.w	#7,d0				; Convert to offset
00002620 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002626 D280                       		add.l	d0,d1				; ''
00002628 343C D780                  		move.w	#$D780,d2			; VRAM address
0000262C 363C 0040                  		move.w	#$80/2,d3			; Size
00002630 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002634                            
00002634                            .NoRingAni:
00002634 4A38 F3D9                  		tst.b	rRLossAniT.w
00002638 6700                       		beq.s	.NoRingLossAni
0000263A 7000                       		moveq	#0,d0
0000263C 1038 F3D9                  		move.b	rRLossAniT.w,d0
00002640 D078 F3DA                  		add.w	rRLossAniA.w,d0
00002644 31C0 F3DA                  		move.w	d0,rRLossAniA.w
00002648 E158                       		rol.w	#8,d0
0000264A 0240 0007                  		andi.w	#7,d0
0000264E 11C0 F3DC                  		move.b	d0,rRLossAniF.w
00002652 5338 F3D9                  		subq.b	#1,rRLossAniT.w
00002656                            
00002656 7000                       		moveq	#0,d0
00002658 1038 F3DC                  		move.b	rRLossAniF.w,d0		; Get ring frame
0000265C EF48                       		lsl.w	#7,d0				; Convert to offset
0000265E 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002664 D280                       		add.l	d0,d1				; ''
00002666 343C D680                  		move.w	#$D680,d2			; VRAM address
0000266A 363C 0040                  		move.w	#$80/2,d3			; Size
0000266E 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002672                            
00002672                            .NoRingLossAni:
00002672 4EB8 0F42                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002676                            
00002676 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Is the game mode level?
0000267C 6700 FF32                  		beq.w	.Loop				; If so, branch
00002680 4EF8 20CE                  		jmp	GotoGameMode.w			; Go to the correct game mode
00002684                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002684                            ; Level functions
00002684                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002684                            		include	"Level/Level Drawing.asm"
00002684                            ; =========================================================================================================================================================
00002684                            ; Mighty The Armadillo in PRISM PARADISE
00002684                            ; By Nat The Porcupine 2021
00002684                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002684                            ; Level drawing functions (Based on Sonic Crackers' and S3K's level drawing engine)
00002684                            ; =========================================================================================================================================================
00002684                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002684                            ; Initialize the planes
00002684                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002684                            ; PARAMETERS:
00002684                            ;	Nothing
00002684                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002684                            ; RETURNS:
00002684                            ;	Nothing
00002684                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002684                            Level_InitPlanes:
00002684 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
00002688 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
0000268C 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
00002690                            
00002690 237C 4000 0003 0012        		move.l	#$40000003,cVDP(a1)		; Set the base VDP command for drawing tiles
00002698 4269 0016                  		clr.w	cLayout(a1)			; Set the offset for the level layout (foreground)
0000269C                            		
0000269C 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
000026A0 E218                       		ror.b	#1,d0				; Turn into offset
000026A2 E648                       		lsr.w	#3,d0				; ''
000026A4 41F9 0000 0000             		lea	Level_RenderRouts,a0		; Get initialization routine list
000026AA 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
000026B0 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
000026B4 4E90                       		jsr	(a0)				; Jump to it
000026B6                            
000026B6 31E9 0008 947E             		move.w	cYPos(a1),rVScrollFG.w		; Set the V-Scroll value for the foreground
000026BC                            
000026BC 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
000026C0 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
000026C4 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
000026C8                            		
000026C8 237C 6000 0003 0012        		move.l	#$60000003,cVDP(a1)		; Set the base VDP command for drawing tils
000026D0 337C 0080 0016             		move.w	#$80,cLayout(a1)		; Set the offset for the level layout (background)
000026D6                            		
000026D6 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
000026DA E218                       		ror.b	#1,d0				; Turn into offset
000026DC E648                       		lsr.w	#3,d0				; ''
000026DE 41F9 0000 0000             		lea	Level_RenderRouts+4,a0		; Get initialization routine list
000026E4 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
000026EA 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
000026EE 4E90                       		jsr	(a0)				; Jump to it
000026F0                            
000026F0 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
000026F6 4E75                       		rts
000026F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026F8                            ; Update the planes
000026F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026F8                            Level_UpdatePlanes:
000026F8 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
000026FC 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
00002700 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
00002704                            		
00002704 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
00002708 4E90                       		jsr	(a0)				; Jump to it
0000270A                            		
0000270A 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
0000270E 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
00002712 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
00002716                            
00002716 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
0000271A 4E90                       		jsr	(a0)				; Jump to it
0000271C                            
0000271C 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
00002720 3552 0004                  		move.w	cXPos(a2),cXPrev(a2)		; Update the previous X position for the foreground
00002724 356A 0008 000C             		move.w	cYPos(a2),cYPrev(a2)		; Update the previous Y position for the foreground
0000272A 31EA 0008 947E             		move.w	cYPos(a2),rVScrollFG.w		; Set the V-Scroll value for the foreground
00002730 3351 0004                  		move.w	cXPos(a1),cXPrev(a1)		; Update the previous X position for the background
00002734 3369 0008 000C             		move.w	cYPos(a1),cYPrev(a1)		; Update the previous Y position for the background
0000273A 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
00002740                            
00002740 4E75                       		rts
00002742                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002742                            ; General foreground initialization
00002742                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002742                            General_InitFG:
00002742 6000 0000                  		bra.w	Level_RefreshPlane		; Refresh the plane
00002746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002746                            ; General background initialization
00002746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002746                            General_InitBG:
00002746 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
0000274A 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
0000274C E240                       		asr.w	#1,d0				; Divide by 2
0000274E 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002750 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002754 E240                       		asr.w	#1,d0				; Divide by 2
00002756 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
0000275A                            
0000275A 6100 0000                  		bsr.w	Level_RefreshPlane		; Refresh the plane
0000275E                            		
0000275E 6000 0000                  		bra.w	ScrollStaticBG			; Set up the scroll offsets
00002762                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002762                            ; General foreground update
00002762                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002762                            General_UpdateFG:
00002762 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002766                            		
00002766 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002768 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
0000276A 6000 0000                  		bra.w	Level_UpdatePlane		; Update the plane
0000276E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000276E                            ; General background update
0000276E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000276E                            General_UpdateBG:
0000276E 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
00002772 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002774 E240                       		asr.w	#1,d0				; Divide by 2
00002776 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002778 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
0000277C E240                       		asr.w	#1,d0				; Divide by 2
0000277E 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002782                            
00002782 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002786 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002788 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
0000278A 6100 0000                  		bsr.w	Level_UpdatePlane		; Update the plane
0000278E                            		
0000278E 6000 0000                  		bra.w	ScrollStaticBG			; Scroll the planes
00002792                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002792                            ; Draw new tiles in the level
00002792                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002792                            ; PARAMETERS:
00002792                            ;	a1.l	- Camera RAM
00002792                            ;	a2.l	- Plane buffer for columns
00002792                            ;	a3.l	- Plane buffer for rows
00002792                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002792                            ; RETURNS:
00002792                            ;	Nothing
00002792                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002792                            VInt_DrawLevel:
00002792 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002796 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
0000279A                            
0000279A 3013                       		move.w	(a3),d0				; Get high VDP command word
0000279C 6700 0000                  		beq.w	VInt_DrawLvlRows2		; If it's 0, branch
000027A0 425B                       		clr.w	(a3)+				; Reset high VDP command word in buffer
000027A2 3CBC 8F80                  		move.w	#$8F80,(a6)			; Set auto-increment to $80
000027A6                            
000027A6                            		; --- DRAW THE FIRST HALF OF THE COLUMN ---
000027A6                            
000027A6 3200                       		move.w	d0,d1				; Save high VDP command
000027A8 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
000027AA 7C00                       		moveq	#0,d6
000027AC 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
000027B0 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000027B2                            
000027B2 3C80                       		move.w	d0,(a6)				; Set VDP command
000027B4 3C84                       		move.w	d4,(a6)				; ''
000027B6 6000                       		bra.s	.DrawCol1_1_Start		; Start
000027B8                            
000027B8                            .DrawCol1_1_Loop:
000027B8 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027BA                            
000027BA                            .DrawCol1_1_Start:
000027BA 51CE FFFC                  		dbf	d6,.DrawCol1_1_Loop		; Loop
000027BE                            
000027BE 3403                       		move.w	d3,d2				; Wrap to the top of the plane
000027C0 0642 007C                  		addi.w	#$7C,d2				; ''
000027C4 C042                       		and.w	d2,d0				; ''
000027C6                            
000027C6 3C80                       		move.w	d0,(a6)				; Set VDP command
000027C8 3C84                       		move.w	d4,(a6)				; ''
000027CA                            
000027CA                            .DrawCol1_2_Loop:
000027CA 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027CC 51CF FFFC                  		dbf	d7,.DrawCol1_2_Loop		; Loop
000027D0                            
000027D0                            		; --- DRAW THE SECOND HALF OF THE COLUMN ---
000027D0                            
000027D0 5441                       		addq.w	#2,d1				; Move over to the right
000027D2 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
000027D4 7C00                       		moveq	#0,d6
000027D6 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
000027DA 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000027DC                            
000027DC 3C81                       		move.w	d1,(a6)				; Set VDP command
000027DE 3C84                       		move.w	d4,(a6)				; ''
000027E0 6000                       		bra.s	.DrawCol2_1_Start		; Start
000027E2                            
000027E2                            .DrawCol2_1_Loop:
000027E2 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027E4                            
000027E4                            .DrawCol2_1_Start:
000027E4 51CE FFFC                  		dbf	d6,.DrawCol2_1_Loop		; Loop
000027E8                            
000027E8 3403                       		move.w	d3,d2				; Wrap to the top of the plane
000027EA 0642 007E                  		addi.w	#$7E,d2				; ''
000027EE C242                       		and.w	d2,d1				; ''
000027F0                            
000027F0 3C81                       		move.w	d1,(a6)				; Set VDP command
000027F2 3C84                       		move.w	d4,(a6)				; ''
000027F4                            
000027F4                            .DrawCol2_2_Loop:
000027F4 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
000027F6 51CF FFFC                  		dbf	d7,.DrawCol2_2_Loop		; Loop
000027FA                            
000027FA 3CBC 8F02                  		move.w	#$8F02,(a6)			; Autoincrement by 2
000027FE 6000                       		bra.s	VInt_DrawLvlRows2		; Continue
00002800                            
00002800                            VInt_DrawLvlRows:
00002800 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002804 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002808                            
00002808                            VInt_DrawLvlRows2:
00002808 3014                       		move.w	(a4),d0				; Get high VDP command
0000280A 6700 0000                  		beq.w	.End				; If it's 0, branch
0000280E 425C                       		clr.w	(a4)+				; Don't run this again unless necessary
00002810                            		
00002810                            		; --- DRAW THE FIRST HALF OF THE ROW ---
00002810                            
00002810 3200                       		move.w	d0,d1				; Save high VDP command
00002812 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002814 7C00                       		moveq	#0,d6
00002816 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
0000281A 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
0000281C                            
0000281C 3C80                       		move.w	d0,(a6)				; Set VDP command
0000281E 3C84                       		move.w	d4,(a6)				; ''
00002820 6000                       		bra.s	.DrawRow1_1_Start		; Start
00002822                            
00002822                            .DrawRow1_1_Loop:
00002822 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002824                            
00002824                            .DrawRow1_1_Start:
00002824 51CE FFFC                  		dbf	d6,.DrawRow1_1_Loop		; Loop
00002828                            
00002828 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
0000282A 0642 0F00                  		addi.w	#$F00,d2			; ''
0000282E C042                       		and.w	d2,d0				; ''
00002830                            
00002830 3C80                       		move.w	d0,(a6)				; Set VDP command
00002832 3C84                       		move.w	d4,(a6)				; ''
00002834                            
00002834                            .DrawRow1_2_Loop:
00002834 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002836 51CF FFFC                  		dbf	d7,.DrawRow1_2_Loop		; Loop
0000283A                            
0000283A                            		; --- DRAW THE SECOND HALF OF THE ROW ---
0000283A                            
0000283A 0641 0080                  		addi.w	#$80,d1				; Move over down
0000283E 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002840 7C00                       		moveq	#0,d6
00002842 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002846 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002848                            
00002848 3C81                       		move.w	d1,(a6)				; Set VDP command
0000284A 3C84                       		move.w	d4,(a6)				; ''
0000284C 6000                       		bra.s	.DrawRow2_1_Start		; Start
0000284E                            
0000284E                            .DrawRow2_1_Loop:
0000284E 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002850                            
00002850                            .DrawRow2_1_Start:
00002850 51CE FFFC                  		dbf	d6,.DrawRow2_1_Loop		; Loop
00002854                            
00002854 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002856 0642 0F80                  		addi.w	#$F80,d2			; ''
0000285A C242                       		and.w	d2,d1				; ''
0000285C                            
0000285C 3C81                       		move.w	d1,(a6)				; Set VDP command
0000285E 3C84                       		move.w	d4,(a6)				; ''
00002860                            
00002860                            .DrawRow2_2_Loop:
00002860 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002862 51CF FFFC                  		dbf	d7,.DrawRow2_2_Loop		; Loop
00002866                            
00002866                            .End:
00002866 4E75                       		rts
00002868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002868                            ; Handle plane drawing
00002868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002868                            ; PARAMETERS:
00002868                            ;	d4.w	- Number of blocks per column
00002868                            ;	d5.w	- Number of blocks per row
00002868                            ;	a1.l	- Camera variables
00002868                            ;	a2.l	- Layout pointer
00002868                            ;	a3.l	- Column plane buffer
00002868                            ;	a4.l	- Row plane buffer
00002868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002868                            ; RETURNS:
00002868                            ;	Nothing
00002868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002868                            Level_UpdatePlane:
00002868                            		push.l	d5/a4				; Push row plane buffer address
00002868 48E7 0408                M 	movem.l	d5/a4,-(sp)
0000286C 6100                       		bsr.s	Level_UpdatePlaneX		; Handle horizontal plane updating
0000286E                            		pop.l	d5/a4				; Restore row plane buffer address
0000286E 4CDF 1020                M 	movem.l	(sp)+,d5/a4
00002872 3805                       		move.w	d5,d4				; Number of blocks per column
00002874                            		; Continue to update the plane vertically
00002874                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002874                            ; Handle plane drawing (vertical redrawing only)
00002874                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002874                            ; PARAMETERS:
00002874                            ;	d4.w	- Number of blocks per row
00002874                            ;	a1.l	- Camera variables
00002874                            ;	a4.l	- Row plane buffer
00002874                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002874                            ; RETURNS:
00002874                            ;	Nothing
00002874                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002874                            Level_UpdatePlaneY:
00002874 3029 0008                  		move.w	cYPos(a1),d0			; Get Y
00002878 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
0000287C 3229 000E                  		move.w	cYPrevR(a1),d1			; Get previous y (rounded)
00002880 3340 000E                  		move.w	d0,cYPrevR(a1)			; Save new rounded y
00002884                            		
00002884 9240                       		sub.w	d0,d1				; Get distance travelled
00002886 6700                       		beq.s	.End				; If a new row doesn't need to be drawn, branch
00002888 6B00                       		bmi.s	.DrawDown			; If a new column needs to be drawn on the bottom of the screen, branch
0000288A                            		
0000288A                            .DrawUp:
0000288A 3011                       		move.w	cXPos(a1),d0			; Get X
0000288C 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002890 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002894                            
00002894                            .DrawDown:
00002894 3011                       		move.w	cXPos(a1),d0			; Get X
00002896 3229 000C                  		move.w	cYPrev(a1),d1			; Get Y
0000289A 0641 00F0                  		addi.w	#224+16,d1			; Go to the bottom of the screen
0000289E 6000 0000                  		bra.w	Level_GetRow			; Draw a row
000028A2                            
000028A2                            .End:
000028A2 4E75                       		rts
000028A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028A4                            ; Handle plane drawing (horizontal redrawing only)
000028A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028A4                            ; PARAMETERS:
000028A4                            ;	d4.w	- Number of blocks per column
000028A4                            ;	a1.l	- Camera variables
000028A4                            ;	a3.l	- Column plane buffer
000028A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028A4                            ; RETURNS:
000028A4                            ;	Nothing
000028A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028A4                            Level_UpdatePlaneX:
000028A4 3011                       		move.w	cXPos(a1),d0			; Get X
000028A6 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
000028AA 3229 0006                  		move.w	cXPrevR(a1),d1			; Get previous X (rounded)
000028AE 3340 0006                  		move.w	d0,cXPrevR(a1)			; Save new rounded X
000028B2                            		
000028B2 9240                       		sub.w	d0,d1				; Get distance travelled
000028B4 6700                       		beq.s	.End				; If a new column doesn't need to be drawn, branch
000028B6 6B00                       		bmi.s	.DrawRight			; If a new column needs to be drawn on the right side of the screen, branch
000028B8                            		
000028B8                            .DrawLeft:
000028B8 3011                       		move.w	cXPos(a1),d0			; Get X
000028BA 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
000028BE 6000 0000                  		bra.w	Level_GetCol			; Draw a column
000028C2                            		
000028C2                            .DrawRight:
000028C2 3029 0004                  		move.w	cXPrev(a1),d0			; Get previous X
000028C6 0640 0150                  		addi.w	#320+16,d0			; Go to the right side of the screen
000028CA 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
000028CE 6000 0000                  		bra.w	Level_GetCol			; Draw a column
000028D2                            
000028D2                            .End:
000028D2 4E75                       		rts
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            ; Macro to calculate the high VDP command word for the plane buffer
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            ; PARAMETERS:
000028D4                            ;	a1.l	- Camera variables
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            ; RETURNS:
000028D4                            ;	d2.w	- The high VDP command word
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            calcHiVDP	macro
000028D4                            		move.w	d0,d2				; Copy X
000028D4                            		move.w	d1,d3				; Copy Y
000028D4                            		lsl.w	#4,d3				; Multiply Y by $10
000028D4                            		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
000028D4                            		lsr.w	#2,d2				; Divide X by 4
000028D4                            		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
000028D4                            		add.w	d3,d2				; Add Y onto X
000028D4                            		or.w	cVDP(a1),d2			; Combine with high VDP command word
000028D4                            		endm
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            ; Macro to get an address in chunk data relative to a position
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            ; PARAMETERS:
000028D4                            ;	d1.l	- $FFFFXXXX
000028D4                            ;	a2.l	- Layout data
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            ; RETURNS:
000028D4                            ;	a6.l	- Pointer in chunk data to the correct block
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            getChunk	macro
000028D4                            		move.b	(a2,d0.w),d1			; Get chunk ID
000028D4                            		andi.w	#$FF,d1				; ''
000028D4                            		lsl.w	#7,d1				; Turn into offset
000028D4                            		movea.l	d1,a6				; Store into a6
000028D4                            		endm
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            ; Get a block row and store it in a plane buffer
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            ; PARAMETERS:
000028D4                            ;	d0.w	- X position
000028D4                            ;	d1.w	- Y position
000028D4                            ;	d4.w	- Number of blocks to draw (minus 1)
000028D4                            ;	a1.l	- Camera variables
000028D4                            ;	a4.l	- Row plane buffer
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            ; RETURNS:
000028D4                            ;	Nothing
000028D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028D4                            Level_GetRow:
000028D4 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
000028D8 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
000028DC 47F8 C7D0                  		lea	rBlocks.w,a3			; Get block table address
000028E0 4BEC 0082                  		lea	$82(a4),a5			; Store plane buffer address for the bottom tiles in the row
000028E4                            
000028E4                            		calcHiVDP				; Get high VDP command word
000028E4 3400                     M 	move.w	d0,d2
000028E6 3601                     M 	move.w	d1,d3
000028E8 E94B                     M 	lsl.w	#4,d3
000028EA 0243 0F00                M 	andi.w	#$f00,d3
000028EE E44A                     M 	lsr.w	#2,d2
000028F0 0242 007C                M 	andi.w	#$7c,d2
000028F4 D443                     M 	add.w	d3,d2
000028F6 8469 0012                M 	or.w	cvdp(a1),d2
000028FA 38C2                       		move.w	d2,(a4)+			; Store it
000028FC                            
000028FC 3400                       		move.w	d0,d2				; Get X
000028FE E44A                       		lsr.w	#2,d2				; Divide X by 4
00002900 0242 007C                  		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
00002904 3A3C 0080                  		move.w	#512/4,d5			; Get max row size in pixels divided by 4
00002908 9A42                       		sub.w	d2,d5				; Get number of pixels (divided by 4) that the first set of tiles for a row takes up
0000290A 0245 007C                  		andi.w	#$7C,d5				; Only allow 0-$7C with multiples of 4
0000290E E44D                       		lsr.w	#2,d5				; Divide by 4
00002910 1345 0010                  		move.b	d5,cRBlks(a1)			; Set tile count for the first set of tiles for a row
00002914                            		
00002914 E648                       		lsr.w	#3,d0				; Get X within chunk data
00002916 3400                       		move.w	d0,d2				; ''
00002918 0242 000E                  		andi.w	#$E,d2				; ''
0000291C E848                       		lsr.w	#4,d0				; Get X within layout data
0000291E 0240 007F                  		andi.w	#$7F,d0				;''
00002922 3601                       		move.w	d1,d3				; Get Y within chunk data
00002924 0243 0070                  		andi.w	#$70,d3				; ''
00002928 D443                       		add.w	d3,d2				; Combine X and Y to get chunk offset
0000292A                            
0000292A 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
0000292E D241                       		add.w	d1,d1				; ''
00002930 D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
00002932                            
00002932 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
00002934                            		getChunk				; Get chunk pointer at current location
00002934 1232 0000                M 	move.b	(a2,d0.w),d1
00002938 0241 00FF                M 	andi.w	#$ff,d1
0000293C EF49                     M 	lsl.w	#7,d1
0000293E 2C41                     M 	movea.l	d1,a6
00002940                            
00002940                            .DrawBlock_Loop:
00002940 3A36 2000                  		move.w	(a6,d2.w),d5			; Get block properties
00002944 3C05                       		move.w	d5,d6				; ''
00002946 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
0000294A E74D                       		lsl.w	#3,d5				; Get offset in block data
0000294C                            		
0000294C 2E33 5000                  		move.l	(a3,d5.w),d7			; Get block tiles
00002950 2A33 5004                  		move.l	4(a3,d5.w),d5			; ''
00002954                            
00002954 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002958 6700                       		beq.s	.ChkYFlip			; If not, branch
0000295A 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002960 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002966 4847                       		swap	d7				; ''
00002968 4845                       		swap	d5				; ''
0000296A                            
0000296A                            .ChkYFlip:
0000296A 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
0000296E 6700                       		beq.s	.DrawBlock			; If not, branch
00002970 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002976 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
0000297C CB47                       		exg.l	d7,d5				; ''
0000297E                            
0000297E                            .DrawBlock:
0000297E 28C7                       		move.l	d7,(a4)+			; Save the tiles in the plane buffers
00002980 2AC5                       		move.l	d5,(a5)+			; ''
00002982                            
00002982 5442                       		addq.w	#2,d2				; Go to the next block
00002984 0242 000E                  		andi.w	#$E,d2				; Have we gone outside of the chunk?
00002988 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
0000298A 5240                       		addq.w	#1,d0				; Next chunk
0000298C                            		getChunk				; ''
0000298C 1232 0000                M 	move.b	(a2,d0.w),d1
00002990 0241 00FF                M 	andi.w	#$ff,d1
00002994 EF49                     M 	lsl.w	#7,d1
00002996 2C41                     M 	movea.l	d1,a6
00002998                            
00002998                            .DrawBlock_Cont:
00002998 D443                       		add.w	d3,d2				; Recombine X and Y to get chunk offset
0000299A 51CC FFA4                  		dbf	d4,.DrawBlock_Loop		; Loop
0000299E                            
0000299E 4E75                       		rts
000029A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000029A0                            ; Get a block column and store it in a plane buffer
000029A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000029A0                            ; PARAMETERS:
000029A0                            ;	d0.w	- X position
000029A0                            ;	d1.w	- Y position
000029A0                            ;	d4.w	- Number of blocks to draw (minus 1)
000029A0                            ;	a1.l	- Camera RAM
000029A0                            ;	a3.l	- Column plane buffer
000029A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000029A0                            ; RETURNS:
000029A0                            ;	Nothing
000029A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000029A0                            Level_GetCol:
000029A0 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
000029A4 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
000029A8 49F8 C7D0                  		lea	rBlocks.w,a4			; Get block table address
000029AC 4BEB 0042                  		lea	$42(a3),a5			; Store plane buffer address for the right tiles in the column
000029B0                            		
000029B0                            		calcHiVDP				; Get high VDP command word
000029B0 3400                     M 	move.w	d0,d2
000029B2 3601                     M 	move.w	d1,d3
000029B4 E94B                     M 	lsl.w	#4,d3
000029B6 0243 0F00                M 	andi.w	#$f00,d3
000029BA E44A                     M 	lsr.w	#2,d2
000029BC 0242 007C                M 	andi.w	#$7c,d2
000029C0 D443                     M 	add.w	d3,d2
000029C2 8469 0012                M 	or.w	cvdp(a1),d2
000029C6 36C2                       		move.w	d2,(a3)+			; Store it
000029C8                            
000029C8 3601                       		move.w	d1,d3				; Get Y
000029CA E94B                       		lsl.w	#4,d3				; Multiply by $10
000029CC 0243 0F00                  		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
000029D0 3A3C 1000                  		move.w	#256*16,d5			; Get max column size in pixels times 16
000029D4 9A43                       		sub.w	d3,d5				; Get number of pixels (times 16) that the first set of tiles for a column takes up
000029D6 0245 0F00                  		andi.w	#$F00,d5			; Only allow 0-$F00 with multiples of $100
000029DA E04D                       		lsr.w	#8,d5				; Divide by $100
000029DC 1345 0011                  		move.b	d5,cCBlks(a1)			; Set tile count for the first set of tiles for a column
000029E0                            
000029E0 E648                       		lsr.w	#3,d0				; Get X within chunk data
000029E2 3400                       		move.w	d0,d2				; ''
000029E4 0242 000E                  		andi.w	#$E,d2				; ''
000029E8 E848                       		lsr.w	#4,d0				; Get X within layout data
000029EA 0240 007F                  		andi.w	#$7F,d0				;''
000029EE 3601                       		move.w	d1,d3				; Get Y within chunk data
000029F0 0243 0070                  		andi.w	#$70,d3				; ''
000029F4 D642                       		add.w	d2,d3				; Combine X and Y to get chunk offset
000029F6                            
000029F6 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
000029FA D241                       		add.w	d1,d1				; ''
000029FC D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
000029FE                            
000029FE 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
00002A00                            		getChunk				; Get chunk pointer at current location
00002A00 1232 0000                M 	move.b	(a2,d0.w),d1
00002A04 0241 00FF                M 	andi.w	#$ff,d1
00002A08 EF49                     M 	lsl.w	#7,d1
00002A0A 2C41                     M 	movea.l	d1,a6
00002A0C                            
00002A0C                            .DrawBlock_Loop:
00002A0C 3A36 3000                  		move.w	(a6,d3.w),d5			; Get block properties
00002A10 3C05                       		move.w	d5,d6				; ''
00002A12 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002A16 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002A18                            		
00002A18 3E05                       		move.w	d5,d7				; Get block tiles
00002A1A 2A34 7002                  		move.l	2(a4,d7.w),d5			; ''
00002A1E 3A07                       		move.w	d7,d5				; ''
00002A20 2E34 5000                  		move.l	(a4,d5.w),d7			; ''
00002A24 3E34 5004                  		move.w	4(a4,d5.w),d7			; ''
00002A28 3A34 5006                  		move.w	6(a4,d5.w),d5			; ''
00002A2C                            
00002A2C 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002A30 6700                       		beq.s	.ChkYFlip			; If not, branch
00002A32 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002A38 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002A3E CB47                       		exg.l	d7,d5				; ''
00002A40                            
00002A40                            .ChkYFlip:
00002A40 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002A44 6700                       		beq.s	.DrawBlock			; If not, branch
00002A46 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002A4C 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002A52 4847                       		swap	d7				; ''
00002A54 4845                       		swap	d5				; ''
00002A56                            
00002A56                            .DrawBlock:
00002A56 26C7                       		move.l	d7,(a3)+			; Save the tiles in the plane buffers
00002A58 2AC5                       		move.l	d5,(a5)+			; ''
00002A5A                            
00002A5A 0643 0010                  		addi.w	#$10,d3				; Go to the next block
00002A5E 0243 0070                  		andi.w	#$70,d3				; Have we gone outside of the chunk?
00002A62 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002A64 0640 0100                  		addi.w	#$100,d0			; Next chunk
00002A68                            		getChunk				; ''
00002A68 1232 0000                M 	move.b	(a2,d0.w),d1
00002A6C 0241 00FF                M 	andi.w	#$ff,d1
00002A70 EF49                     M 	lsl.w	#7,d1
00002A72 2C41                     M 	movea.l	d1,a6
00002A74                            
00002A74                            .DrawBlock_Cont:
00002A74 D642                       		add.w	d2,d3				; Recombine X and Y to get chunk offset
00002A76 51CC FF94                  		dbf	d4,.DrawBlock_Loop		; Loop
00002A7A                            
00002A7A 4E75                       		rts
00002A7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A7C                            ; Refresh a plane
00002A7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A7C                            ; PARAMETERS:
00002A7C                            ;	a1.l	- Camera variables
00002A7C                            ;	a4.l	- Row plane buffer
00002A7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A7C                            ; RETURNS:
00002A7C                            ;	Nothing
00002A7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A7C                            Level_RefreshPlane:
00002A7C 3011                       		move.w	cXPos(a1),d0			; Get X position
00002A7E 3340 0004                  		move.w	d0,cXPrev(a1)			; Store as previous X position
00002A82 0240 FFF0                  		andi.w	#$FFF0,d0			; Only get multiples of $10
00002A86 3340 0006                  		move.w	d0,cXPrevR(a1)			; Store as previous X position (rounded)
00002A8A                            		
00002A8A 3229 0008                  		move.w	cYPos(a1),d1			; Get Y position
00002A8E 3341 000C                  		move.w	d1,cYPrev(a1)			; Store as previous Y position
00002A92 0241 FFF0                  		andi.w	#$FFF0,d1			; Only get multiples of $10
00002A96 3341 000E                  		move.w	d1,cYPrevR(a1)			; Store as previous Y position (rounded)
00002A9A                            		
00002A9A 781F                       		moveq	#(512/16)-1,d4			; Number of rows to draw
00002A9C 7C0F                       		moveq	#(256/16)-1,d6			; Number of blocks per row
00002A9E                            		
00002A9E                            		push.l	a4				; Save plane buffer address
00002A9E 2F0C                     M 	move.l	a4,-(sp)
00002AA0                            		
00002AA0                            .DrawRows:
00002AA0                            		push.w	d0/d1/d4/d6			; Save registers
00002AA0 48A7 CA00                M 	movem.w	d0/d1/d4/d6,-(sp)
00002AA4 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002AA8 6100 FE2A                  		bsr.w	Level_GetRow			; Transfer the row to the plane buffer
00002AAC 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002AB0 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002AB6 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002ABA 6100 FD44                  		bsr.w	VInt_DrawLvlRows		; Draw the new row
00002ABE                            		pop.w	d0/d1/d4/d6			; Restore registers
00002ABE 4C9F 0053                M 	movem.w	(sp)+,d0/d1/d4/d6
00002AC2                            		
00002AC2 0641 0010                  		addi.w	#$10,d1				; Increment Y
00002AC6 51CE FFD8                  		dbf	d6,.DrawRows			; Loop
00002ACA                            		
00002ACA                            		pop.l	a4				; Restore a3
00002ACA 285F                     M 	move.l	(sp)+,a4
00002ACC 4E75                       		rts
00002ACE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACE                            ; Check if the plane needs to be redrawn
00002ACE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACE                            ; PARAMETERS:
00002ACE                            ;	a1.l	- Camera RAM
00002ACE                            ;	a3.l	- Row plane buffer
00002ACE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACE                            ; RETURNS:
00002ACE                            ;	Nothing
00002ACE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACE                            Level_ChkRedrawPlane:
00002ACE 4A29 001C                  		tst.b	cRedraw(a1)			; Does this plane need to be redrawn?
00002AD2                            		; Comment out the following line to disable blast processing :^)
00002AD2 6700                       		beq.s	.End				; If not, branch
00002AD4 4229 001C                  		clr.b	cRedraw(a1)			; Clear the redraw flag
00002AD8 60A2                       		bra.s	Level_RefreshPlane		; Redraw the plane
00002ADA                            
00002ADA                            .End:
00002ADA 4E75                       		rts
00002ADC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ADC                            ; Scroll sections macro
00002ADC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ADC =00008000                  SCROLL_AUTOMATIC	EQU	$8000			; Automatic scroll flag
00002ADC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ADC                            scrollInit	macro	label
00002ADC                            SCROLL_LABEL	equs	"\label"
00002ADC                            \label\:	dc.w	((\label\_End-\label\-2)/6)-1	; Number of sections
00002ADC                            		endm
00002ADC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ADC                            scrollEnd	macro
00002ADC                            \SCROLL_LABEL\_End:					; End label
00002ADC                            		endm
00002ADC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ADC                            scrollSection	macro
00002ADC                            	if narg<3
00002ADC                            		dc.w	\2, 0, \1			; Speed, 0, Size
00002ADC                            	else
00002ADC                            		dc.w	\2, \3, \1			; Speed, Flags, Size
00002ADC                            	endif
00002ADC                            		endm
00002ADC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ADC                            ; Do section scrolling
00002ADC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ADC                            ; PARAMERERS:
00002ADC                            ;	a1.l	- Background camera RAM
00002ADC                            ;	a3.l	- Scroll section data
00002ADC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ADC                            ; RETURNS:
00002ADC                            ;	Nothing
00002ADC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ADC                            ScrollSections:
00002ADC 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing variables
00002AE0 49F8 EFD0                  		lea	rScrlSecs.w,a4		; Deformation offset buffer
00002AE4 4BF8 90FE                  		lea	rHScroll.w,a5			; Horizontal scroll buffer
00002AE8                            
00002AE8 301B                       		move.w	(a3)+,d0			; Get the total number of scroll sections
00002AEA                            
00002AEA 3812                       		move.w	cXPos(a2),d4			; Get camera speed
00002AEC 986A 0004                  		sub.w	cXPrev(a2),d4			; ''
00002AF0 48C4                       		ext.l	d4				; ''
00002AF2 E184                       		asl.l	#8,d4				; Shift over to use for calculation speeds
00002AF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002AF4                            		; Update each section offset
00002AF4                            		push.w	d0/a4				; Save registers
00002AF4 48A7 8008                M 	movem.w	d0/a4,-(sp)
00002AF8                            
00002AF8                            .ScrollSects:
00002AF8 361B                       		move.w	(a3)+,d3			; Get section speed
00002AFA 48C3                       		ext.l	d3				; ''
00002AFC                            
00002AFC 4A5B                       		tst.w	(a3)+				; Is this section set to scroll automatically?
00002AFE 6A00                       		bpl.s	.NotAuto			; If not, branch
00002B00 3C04                       		move.w	d4,d6				; Get camera speed
00002B02 CDC3                       		muls.w	d3,d6				; Multiply by section speed
00002B04 E183                       		asl.l	#8,d3				; Shift section speed
00002B06 D686                       		add.l	d6,d3				; Add camera speed to section speed
00002B08 6000                       		bra.s	.ApplySpeed			; Apply that speed
00002B0A                            
00002B0A                            .NotAuto:
00002B0A C7C4                       		muls.w	d4,d3				; Multiply the the background's X scroll offset with the speed
00002B0C                            
00002B0C                            .ApplySpeed:
00002B0C D79C                       		add.l	d3,(a4)+			; Set the new section offset
00002B0E 38DB                       		move.w	(a3)+,(a4)+			; Save the section size for later
00002B10 51C8 FFE6                  		dbf	d0,.ScrollSects			; If there are still sections to check, loop
00002B14                            
00002B14                            		pop.w	d0/a4				; Restore registers
00002B14 4C9F 1001                M 	movem.w	(sp)+,d0/a4
00002B18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B18                            		; Set the scroll offsets on screen
00002B18 3A3C 00E0                  		move.w	#224,d5				; Scanline counter
00002B1C 3C29 0008                  		move.w	cYPos(a1),d6			; Get the background's Y position
00002B20                            		
00002B20                            .FindStart:
00002B20 221C                       		move.l	(a4)+,d1			; Get section offset
00002B22 9C5C                       		sub.w	(a4)+,d6			; Subtract the size of the section
00002B24 6B00                       		bmi.s	.FoundStart			; If the current section is on screen, branch
00002B26 51C8 FFF8                  		dbf	d0,.FindStart			; If not, continue the search
00002B2A 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002B2C 4441                       		neg.w	d1				; Make it scroll the right direction
00002B2E 4841                       		swap	d1				; Fix which planes the scroll values go to
00002B30 4441                       		neg.w	d1				; Make the background scroll the right direction
00002B32 6000                       		bra.s	.LastSection			; If there are no more sections to go through, branch
00002B34                            
00002B34                            .FoundStart:
00002B34 4446                       		neg.w	d6				; Get remaining size of the section
00002B36 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002B38 4441                       		neg.w	d1				; Make it scroll the right direction
00002B3A 4841                       		swap	d1				; Fix which planes the scroll values go to
00002B3C 4441                       		neg.w	d1				; Make the background scroll the right direction
00002B3E 6000                       		bra.s	.CheckScroll			; Go set some scroll offsets
00002B40                            
00002B40                            .NextSection:
00002B40 321C                       		move.w	(a4)+,d1			; Set scroll offset
00002B42 4441                       		neg.w	d1				; Make the section scroll the correct way
00002B44 2C1C                       		move.l	(a4)+,d6			; Get section size
00002B46                            		
00002B46                            .CheckScroll:
00002B46 9A46                       		sub.w	d6,d5				; Subtract that from the scanline count
00002B48 6B00                       		bmi.s	.EndSection			; If there is still screen space to cover, loop
00002B4A 5346                       		subq.w	#1,d6				; Convert for use with dbf
00002B4C                            
00002B4C                            .Scroll:
00002B4C 2AC1                       		move.l	d1,(a5)+			; Scroll the section
00002B4E 51CE FFFC                  		dbf	d6,.Scroll			; Repeat
00002B52 51C8 FFEC                  		dbf	d0,.NextSection			; If there are any sections left, branch
00002B56 5245                       		addq.w	#1,d5				; Add 1 so that the foreground can still scroll properly
00002B58                            		
00002B58                            .EndSection:
00002B58 DA46                       		add.w	d6,d5				; Get remaining screen space
00002B5A                            		
00002B5A                            .LastSection:
00002B5A 5345                       		subq.w	#1,d5				; Convert to use with dbf
00002B5C 6B00                       		bmi.s	.End				; If there are none, exit
00002B5E                            
00002B5E                            .FillScroll:
00002B5E 2AC1                       		move.l	d1,(a5)+			; Set previous scroll values
00002B60 51CD FFFC                  		dbf	d5,.FillScroll			; Repeat
00002B64                            
00002B64                            .End:
00002B64 4E75                       		rts
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; Static background scrolling (no parallax)
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; PARAMERERS:
00002B66                            ;	a1.l	- Background camera RAM
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; RETURNS:
00002B66                            ;	Nothing
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ScrollStaticBG:
00002B66 45F8 F880                  		lea	rFGCam.w,a2		; Get foreground level drawing variables
00002B6A 4BF8 90FE                  		lea	rHScroll.w,a5		; Horizontal scroll buffer
00002B6E                            		
00002B6E 2212                       		move.l	cXPos(a2),d1			; Get foreground X position
00002B70 4481                       		neg.l	d1				; Negate it so it scrolls properly
00002B72 3211                       		move.w	cXPos(a1),d1			; Get background X position
00002B74 4441                       		neg.w	d1				; Negate it so it scrolls properly
00002B76                            
00002B76 303C 00DF                  		move.w	#224-1,d0			; Number of scanlines to scroll
00002B7A                            
00002B7A                            .Scroll:
00002B7A 2AC1                       		move.l	d1,(a5)+			; Set the scroll offsets
00002B7C 51C8 FFFC                  		dbf	d0,.Scroll			; Repeat
00002B80 4E75                       		rts
00002B82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B82                            ; Generate fake layer art
00002B82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B82                            ; PARAMETERS:
00002B82                            ;	a0.l	- Layer art data pointer
00002B82                            ;	a1.l	- Layer tile ID mappings pointer
00002B82                            ;	d0.w	- Layer offset
00002B82                            ;	d1.l	- Buffer pointer
00002B82                            ;	d2.w	- VRAM destination address
00002B82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B82                            Level_UpdateLayer:
00002B82                            		; Prepare for transfer
00002B82 3619                       		move.w	(a1)+,d3			; Get number of tiles to copy
00002B84 2441                       		movea.l	d1,a2				; Copy layer buffer pointer
00002B86                            		
00002B86                            		; Queue a DMA transfer for later
00002B86                            		push.l	d0/d3/a1			; Save registers
00002B86 48E7 9040                M 	movem.l	d0/d3/a1,-(sp)
00002B8A 5243                       		addq.w	#1,d3				; Get size of transfer
00002B8C E94B                       		lsl.w	#4,d3				; ''
00002B8E 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue the transfer
00002B92                            		pop.l	d0/d3/a1			; Restore registers
00002B92 4CDF 0209                M 	movem.l	(sp)+,d0/d3/a1
00002B96                            
00002B96                            		; Copy the tiles for the layer
00002B96 D040                       		add.w	d0,d0				; Double it
00002B98 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to layer data for the offset
00002B9C                            		
00002B9C                            .CopyTiles:
00002B9C 3219                       		move.w	(a1)+,d1			; Get tile offset
00002B9E 47F0 1000                  		lea	(a0,d1.w),a3			; Get pointer to tile data
00002BA2 24DB                       		move.l	(a3)+,(a2)+			; Copy tile data
00002BA4 24DB                       		move.l	(a3)+,(a2)+			; ''
00002BA6 24DB                       		move.l	(a3)+,(a2)+			; ''
00002BA8 24DB                       		move.l	(a3)+,(a2)+			; ''
00002BAA 24DB                       		move.l	(a3)+,(a2)+			; ''
00002BAC 24DB                       		move.l	(a3)+,(a2)+			; ''
00002BAE 24DB                       		move.l	(a3)+,(a2)+			; ''
00002BB0 24DB                       		move.l	(a3)+,(a2)+			; ''
00002BB2 51CB FFE8                  		dbf	d3,.CopyTiles			; Loop
00002BB6                            
00002BB6                            .End
00002BB6 4E75                       		rts
00002BB8                            ; =========================================================================================================================================================
00002BB8                            		include	"Level/Level Collision.asm"
00002BB8                            ; =========================================================================================================================================================
00002BB8                            ; Mighty The Armadillo in PRISM PARADISE
00002BB8                            ; By Nat The Porcupine 2021
00002BB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BB8                            ; Level collision functions
00002BB8                            ; =========================================================================================================================================================
00002BB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BB8                            ; Check if a player object has touched any level collision
00002BB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BB8                            PlayerChkCollision:
00002BB8 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002BBE 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002BC4 6700                       		beq.s	.NotPrimary			; If not, branch
00002BC6 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002BCC                            
00002BCC                            .NotPrimary:
00002BCC 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002BD0                            		
00002BD0 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002BD4 3428 001E                  		move.w	oYVel(a0),d2			; Get Y velocity
00002BD8 4EB8 171A                  		jsr	CalcArcTan.w			; Get the angle
00002BDC 0400 0020                  		subi.b	#$20,d0				; Shift it over
00002BE0 0200 00C0                  		andi.b	#$C0,d0				; Get the quadrant
00002BE4 0C00 0040                  		cmpi.b	#$40,d0				; Are we hitting a left wall?
00002BE8 6700 0000                  		beq.w	PlayerHitLWall			; If so, branch
00002BEC 0C00 0080                  		cmpi.b	#$80,d0				; Are we hitting a ceiling?
00002BF0 6700 0000                  		beq.w	PlayerHitCeilAndWalls		; If so, branch
00002BF4 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we hitting a right wall?
00002BF8 6700 0000                  		beq.w	PlayerHitRWall			; If so, branch
00002BFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BFC                            PlayerHitFloorAndWalls:
00002BFC 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002C00 4A41                       		tst.w	d1				; Have we hit the wall?
00002C02 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002C04 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002C08 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002C0C                            
00002C0C                            .NoLeftHit:
00002C0C 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002C10 4A41                       		tst.w	d1				; Have we hit the wall?
00002C12 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002C14 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002C18 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002C1C                            
00002C1C                            .NoRightHit:
00002C1C 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002C20 4A41                       		tst.w	d1				; Have we hit the floor?
00002C22 6A00                       		bpl.s	.End				; If not, branch
00002C24                            
00002C24 1428 001E                  		move.b	oYVel(a0),d2			; Get the integer part of the Y velocity
00002C28 5002                       		addq.b	#8,d2				; Get the max distance we have to have from the floor in order to collide with it
00002C2A 4402                       		neg.b	d2				; Negate it since we are in the floor
00002C2C B202                       		cmp.b	d2,d1				; Is the chosen primary distance small enough?
00002C2E 6C00                       		bge.s	.TouchFloor			; If so, branch
00002C30 B002                       		cmp.b	d2,d0				; What about the other angle that was found?
00002C32 6D00                       		blt.s	.End				; If not, branch
00002C34                            
00002C34                            .TouchFloor:
00002C34 1143 0000                  		move.b	d3,oAngle(a0)			; Set the angle
00002C38 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the floor
00002C3C 1003                       		move.b	d3,d0				; Copy angle
00002C3E 0600 0020                  		addi.b	#$20,d0				; Shift it
00002C42 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002C46 6600                       		bne.s	.HitWall			; If so, branch
00002C48 1003                       		move.b	d3,d0				; Copy angle
00002C4A 0600 0010                  		addi.b	#$10,d0				; Shift it
00002C4E 0200 0020                  		andi.b	#$20,d0				; Are we on a slope?
00002C52 6700                       		beq.s	.HitFloor			; If not, branch
00002C54 E0E8 001E                  		asr	oYVel(a0)			; Divide the Y velocity by 2
00002C58 6000                       		bra.s	.HitSlope			; Continue
00002C5A                            
00002C5A                            .HitFloor:
00002C5A 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002C5E 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002C64 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002C68                            
00002C68                            .HitWall:
00002C68 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
00002C6C 0C68 0FC0 001E             		cmpi.w	#$FC0,oYVel(a0)			; Cap the Y velocity at $FC0
00002C72 6F00                       		ble.s	.HitSlope			; ''
00002C74 317C 0FC0 001E             		move.w	#$FC0,oYVel(a0)			; ''
00002C7A                            
00002C7A                            .HitSlope:
00002C7A 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002C7E 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002C84 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002C86 6A00                       		bpl.s	.End				; If so, branch
00002C88 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002C8C                            
00002C8C                            .End:
00002C8C 4E75                       		rts
00002C8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C8E                            PlayerHitLWall:
00002C8E 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002C92 4A41                       		tst.w	d1				; Have we hit the wall?
00002C94 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002C96 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002C9A 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002C9E 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002CA4                            
00002CA4                            .ChkCeil:
00002CA4 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002CA8 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002CAA 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002CAC 4441                       		neg.w	d1				; Get the distance inside the ceiling
00002CAE 0C41 0014                  		cmpi.w	#$14,d1				; Are we too far into the ceiling?
00002CB2 6400                       		bhs.s	.ChkRightWall			; If so, branch
00002CB4 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002CB8 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002CBC 6A00                       		bpl.s	.End				; If not, branch
00002CBE 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002CC2                            
00002CC2                            .End:
00002CC2 4E75                       		rts
00002CC4                            
00002CC4                            .ChkRightWall:
00002CC4 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002CC8 4A41                       		tst.w	d1				; Have we hit the wall?
00002CCA 6A00                       		bpl.s	.End2				; If not, branch
00002CCC D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002CD0 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002CD4                            		
00002CD4                            .End2:
00002CD4 4E75                       		rts
00002CD6                            
00002CD6                            .ChkFloor:
00002CD6 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002CDA 6B00                       		bmi.s	.End3				; If so, branch
00002CDC 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002CE0 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002CE2 6A00                       		bpl.s	.End3				; If not, branch
00002CE4 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002CE8 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002CEC 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002CF0 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002CF6 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002CFA                            		
00002CFA                            .End3:
00002CFA 4E75                       		rts
00002CFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CFC                            PlayerHitCeilAndWalls:
00002CFC 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002D00 4A41                       		tst.w	d1				; Have we hit the wall?
00002D02 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002D04 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002D08 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D0C                            
00002D0C                            .NoLeftHit:
00002D0C 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002D10 4A41                       		tst.w	d1				; Have we hit the wall?
00002D12 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002D14 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002D18 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D1C                            
00002D1C                            .NoRightHit:
00002D1C 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002D20 4A41                       		tst.w	d1				; Have we hit the floor?
00002D22 6A00                       		bpl.s	.End				; If not, branch
00002D24 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of ceiling
00002D28 1003                       		move.b	d3,d0				; Get angle
00002D2A 0600 0020                  		addi.b	#$20,d0				; Shift it
00002D2E 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002D32 6600                       		bne.s	.HitWall			; If so, branch
00002D34 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D38 4E75                       		rts
00002D3A                            
00002D3A                            .HitWall:
00002D3A 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002D3E 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002D42 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D48 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002D4A 6A00                       		bpl.s	.End				; If so, branch
00002D4C 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002D50                            
00002D50                            .End:
00002D50 4E75                       		rts
00002D52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D52                            PlayerHitRWall:
00002D52 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002D56 4A41                       		tst.w	d1				; Have we hit the wall?
00002D58 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002D5A D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002D5E 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D62 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D68                            
00002D68                            .ChkCeil:
00002D68 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002D6C 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D6E 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002D70 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of the ceiling
00002D74 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D78 6A00                       		bpl.s	.End				; If not, branch
00002D7A 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D7E                            
00002D7E                            .End:
00002D7E 4E75                       		rts
00002D80                            
00002D80                            .ChkFloor:
00002D80 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D84 6B00                       		bmi.s	.End2				; If so, branch
00002D86 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002D8A 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D8C 6A00                       		bpl.s	.End2				; If not, branch
00002D8E D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002D92 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002D96 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D9A 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002DA0 6000                       		bra.s	PlayerResetOnFloor		; Reset status on floor
00002DA2                            		
00002DA2                            .End2:
00002DA2 4E75                       		rts
00002DA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DA4                            ; Reset a player object's status on the floor
00002DA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DA4                            PlayerResetOnFloor:
00002DA4 4A28 0000                  		tst.b	oBallMode(a0)			; Are we in ball mode?
00002DA8 6600                       		bne.s	PlayerResetOnFloorPart3	; If so, branch
00002DAA 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002DAE                            		
00002DAE                            PlayerResetOnFloorPart2:
00002DAE 0828 0002 0028             		btst	#2,oStatus(a0)			; Was Sonic rolling?
00002DB4 6700                       		beq.s	PlayerResetOnFloorPart3	; If so, branch
00002DB6 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
00002DBC 1168 0000 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
00002DC2 1168 0000 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
00002DC8 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002DCC 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align with floor
00002DD0                            
00002DD0                            PlayerResetOnFloorPart3:
00002DD0 0228 00DD 0028             		andi.b	#$DD,oStatus(a0)		; Clear "pushing", and "jumping" flag
00002DD6 4228 0000                  		clr.b	oJumping(a0)			; Clear jumping flag
00002DDA 4228 0000                  		clr.b	oFlipAngle(a0)			; Reset flip angle
00002DDE 4228 0000                  		clr.b	oFlipTurned(a0)			; Reset flip inverted flag
00002DE2 4228 0000                  		clr.b	oFlipRemain(a0)			; Reset flips remaining
00002DE6 4E75                       		rts
00002DE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DE8                            ; Calculate the room in front of a player object
00002DE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DE8                            PlayerCalcRoomInFront:
00002DE8 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002DEE 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002DF4 6700                       		beq.s	.NotPrimary			; If not, branch
00002DF6 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002DFC                            
00002DFC                            .NotPrimary:
00002DFC 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002E00                            		
00002E00 2628 0014                  		move.l	oXPos(a0),d3			; Get X position
00002E04 2428 0018                  		move.l	oYPos(a0),d2			; Get Y position
00002E08 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002E0C 48C1                       		ext.l	d1				; ''
00002E0E E181                       		asl.l	#8,d1				; Shift it
00002E10 D681                       		add.l	d1,d3				; Add onto X position
00002E12 3228 001E                  		move.w	oYVel(a0),d1			; Get Y velocity
00002E16 48C1                       		ext.l	d1				; ''
00002E18 E181                       		asl.l	#8,d1				; Shift it
00002E1A D481                       		add.l	d1,d2				; Add onto Y position
00002E1C 4842                       		swap	d2				; Get actual Y
00002E1E 4843                       		swap	d3				; Get actual X
00002E20 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002E24 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002E28 1200                       		move.b	d0,d1				; Copy angle
00002E2A 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00002E2E 6700                       		beq.s	.DownUp				; If not, branch
00002E30 5200                       		addq.b	#1,d0				; Shift the angle
00002E32                            
00002E32                            .DownUp:
00002E32 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
00002E36 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002E3A 6700 0000                  		beq.w	PlayerChkFloorDist_Part2	; If quadrant 0, get the floor distance
00002E3E 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002E42 6700 0000                  		beq.w	PlayerChkCeilingDist_Part2	; If so, branch
00002E46 0201 0038                  		andi.b	#$38,d1				; Are we on a flat enough surface?
00002E4A 6600                       		bne.s	.ChkWall			; If not, branch
00002E4C 5042                       		addq.w	#8,d2				; Add 8 to the Y position
00002E4E                            
00002E4E                            .ChkWall:
00002E4E 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002E52 6700 0000                  		beq.w	PlayerChkLeftWallDist_Part2	; If so, branch
00002E56 6000 0000                  		bra.w	PlayerChkRightWallDist_Part2	; Get the right wall distance
00002E5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E5A                            ; Calculate the room over a player object
00002E5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E5A                            PlayerCalcRoomOverHead:
00002E5A 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002E60 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002E66 6700                       		beq.s	.NotPrimary			; If not, branch
00002E68 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002E6E                            
00002E6E                            .NotPrimary:
00002E6E 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002E72 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002E76 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002E7A                            		
00002E7A 0600 0020                  		addi.b	#$20,d0				; Shift the angle
00002E7E 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002E82 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002E86 6700 0000                  		beq.w	PlayerChkLeftCeilDist		; If so, branch
00002E8A 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002E8E 6700 0000                  		beq.w	PlayerChkCeiling		; If so, branch
00002E92 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0?
00002E96 6700 0000                  		beq.w	PlayerChkRightCeilDist		; If so, branch
00002E9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E9A                            ; Get the distance between the floor and a player object (with primary and secondary angles)
00002E9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E9A                            PlayerChkFloor:
00002E9A 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002EA0 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002EA6 6700                       		beq.s	.NotPrimary			; If not, branch
00002EA8 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002EAE                            
00002EAE                            .NotPrimary:
00002EAE 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
00002EB2                            		
00002EB2                            		; Get the angle on the bottom right sensor
00002EB2 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002EB6 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002EBA 7000                       		moveq	#0,d0
00002EBC 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002EC0 4880                       		ext.w	d0				; ''
00002EC2 D440                       		add.w	d0,d2				; Add onto Y position
00002EC4 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002EC8 4880                       		ext.w	d0				; ''
00002ECA D640                       		add.w	d0,d3				; Add onto X position
00002ECC 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00002ED0 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002ED4 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002ED6 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002EDA                            		push.w	d1				; Save the primary floor distance
00002EDA 3F01                     M 	move.w	d1,-(sp)
00002EDC                            
00002EDC                            		; Get the angle on the bottom left sensor
00002EDC 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002EE0 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002EE4 7000                       		moveq	#0,d0
00002EE6 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002EEA 4880                       		ext.w	d0				; ''
00002EEC D440                       		add.w	d0,d2				; Add onto Y position
00002EEE 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002EF2 4880                       		ext.w	d0				; ''
00002EF4 9640                       		sub.w	d0,d3				; Subtract from X position
00002EF6 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00002EFA 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002EFE 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002F00 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F04                            		
00002F04                            		; Update the object's angle
00002F04                            		pop.w	d0				; Restore the primary floor distance
00002F04 301F                     M 	move.w	(sp)+,d0
00002F06 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002F08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F08                            PlayerPickAngle:
00002F08 1628 002F                  		move.b	oTilt(a0),d3			; Get secondary angle
00002F0C B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00002F0E 6F00                       		ble.s	.ChkSetAngle			; If not, branch
00002F10 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F14 C141                       		exg.l	d0,d1				; Switch floor distance values
00002F16                            		
00002F16                            .ChkSetAngle:
00002F16 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002F1A 6700                       		beq.s	.End				; If not, branch
00002F1C 1602                       		move.b	d2,d3				; Set the new angle value
00002F1E                            		
00002F1E                            .End:
00002F1E 4E75                       		rts
00002F20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F20                            ; Get the distance between the floor and the player object
00002F20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F20                            PlayerChkFloorDist:
00002F20 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F24 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F28                            
00002F28                            PlayerChkFloorDist_Part2:
00002F28 0642 000A                  		addi.w	#10,d2				; Check 10 pixels down
00002F2C 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002F30 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F34 4246                       		clr.w	d6				; No flip bits
00002F36 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F3A 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F3C                            PlayerGetPrimaryAngle:
00002F3C 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F40 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002F44 6700                       		beq.s	.End				; If not, branch
00002F46 1602                       		move.b	d2,d3				; Set the new angle value
00002F48                            		
00002F48                            .End:
00002F48 4E75                       		rts
00002F4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F4A                            sub_F846:
00002F4A 3628 0014                  		move.w	oXPos(a0),d3
00002F4E 3428 0018                  		move.w	oYPos(a0),d2
00002F52 5942                       		subq.w	#4,d2
00002F54 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002F5A 0C28 000D 0000             		cmpi.b	#$D,oLRBSolid(a0)		; Are we on the primary path?
00002F60 6700                       		beq.s	.NotPrimary			; If not, branch
00002F62 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002F68                            
00002F68                            .NotPrimary:
00002F68 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002F6C 4214                       		clr.b	(a4)				; Clear it
00002F6E 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F72 4246                       		clr.w	d6				; No flip bits
00002F74 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Solidity bits
00002F78 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F7C 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F80 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00002F84 6700                       		beq.s	.End				; If not, branch
00002F86 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00002F88                            
00002F88                            .End:
00002F88 4E75                       		rts
00002F8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F8A                            ; Check for the edge of a floor
00002F8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F8A                            PlayerChkFloorEdge:
00002F8A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F8E                            
00002F8E                            PlayerChkFloorEdge_Part2:
00002F8E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F92 7000                       		moveq	#0,d0
00002F94 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002F98 4880                       		ext.w	d0				; ''
00002F9A D440                       		add.w	d0,d2				; Add onto Y position
00002F9C                            
00002F9C                            PlayerChkFloorEdge_Part3:
00002F9C 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002FA2 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002FA8 6700                       		beq.s	.NotPrimary			; If not, branch
00002FAA 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002FB0                            
00002FB0                            .NotPrimary:
00002FB0 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002FB4 4214                       		clr.b	(a4)				; Clear it
00002FB6 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FBA 4246                       		clr.w	d6				; No flip bits
00002FBC 1A28 0000                  		move.b	oTopSolid(a0),d5		; Solidity bits
00002FC0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FC4 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002FC8 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00002FCC 6700                       		beq.s	.End				; If not, branch
00002FCE 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00002FD0                            
00002FD0                            .End:
00002FD0 4E75                       		rts
00002FD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD2                            ; Get the distance between the floor and an object
00002FD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD2                            ObjCheckFloorDist:
00002FD2 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002FD6                            		
00002FD6                            ObjCheckFloorDist_Part2:
00002FD6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002FDA                            
00002FDA                            ObjCheckFloorDist_Part3:
00002FDA 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002FDE 4880                       		ext.w	d0				; ''
00002FE0 D440                       		add.w	d0,d2				; Add onto Y position
00002FE2 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002FE6 4214                       		clr.b	(a4)				; Clear it
00002FE8 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FEC 4246                       		clr.w	d6				; No flip bits
00002FEE 7A0C                       		moveq	#$C,d5				; Solidity bits
00002FF0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FF4 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002FF8 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00002FFC 6700                       		beq.s	.End				; If not, branch
00002FFE 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00003000                            
00003000                            .End:
00003000 4E75                       		rts
00003002                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003002                            ; Get the distance between a right ceiling and a player object
00003002                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003002                            PlayerChkRightCeilDist:
00003002                            		; Get the angle on the bottom right (rotated) sensor
00003002 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003006 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000300A 7000                       		moveq	#0,d0
0000300C 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
00003010 4880                       		ext.w	d0				; ''
00003012 9440                       		sub.w	d0,d2				; Subtract from Y position
00003014 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
00003018 4880                       		ext.w	d0				; ''
0000301A D640                       		add.w	d0,d3				; Add onto X position
0000301C 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003020 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003024 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003026 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000302A                            		push.w	d1				; Save the primary floor distance
0000302A 3F01                     M 	move.w	d1,-(sp)
0000302C                            
0000302C                            		; Get the angle on the bottom left (rotated) sensor
0000302C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003030 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003034 7000                       		moveq	#0,d0
00003036 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
0000303A 4880                       		ext.w	d0				; ''
0000303C D440                       		add.w	d0,d2				; Add onto Y position
0000303E 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
00003042 4880                       		ext.w	d0				; ''
00003044 D640                       		add.w	d0,d3				; Add onto X position
00003046 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
0000304A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000304E 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003050 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003054                            
00003054                            		; Update the object's angle
00003054                            		pop.w	d0				; Restore the primary floor distance
00003054 301F                     M 	move.w	(sp)+,d0
00003056 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
0000305A 6000 FEAC                  		bra.w	PlayerPickAngle		; Get the angle
0000305E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000305E                            ; Get the distance between a right wall and a player object
0000305E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000305E                            PlayerChkRightWallDist:
0000305E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003062 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003066                            
00003066                            PlayerChkRightWallDist_Part2:
00003066 0643 000A                  		addi.w	#10,d3				; Check 10 pixels to the right
0000306A 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
0000306E 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003072 4246                       		clr.w	d6				; No flip bits
00003074 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003078 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
0000307C 6000 FEBE                  		bra.w	PlayerGetPrimaryAngle		; Get angle
00003080                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003080                            ; Get the distance between a right wall and an object
00003080                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003080                            ObjCheckRightWallDist:
00003080 D668 0014                  		add.w	oXPos(a0),d3			; Add X position
00003084 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003088 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
0000308C 4214                       		clr.b	(a4)				; Clear it
0000308E 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003092 4246                       		clr.w	d6				; No flip bits
00003094 7A0D                       		moveq	#$D,d5				; Solidity bits
00003096 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000309A 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
0000309E 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000030A2 6700                       		beq.s	.End				; If not, branch
000030A4 163C 00C0                  		move.b	#-$40,d3			; Angle value for when the object touched an odd angle (usually $FF)
000030A8                            
000030A8                            .End:
000030A8 4E75                       		rts
000030AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030AA                            ; Get the distance between a ceiling and a player object (with primary and secondary angles)
000030AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030AA                            PlayerChkCeiling:
000030AA                            		; Get the angle on the bottom right sensor
000030AA 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000030AE 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030B2 7000                       		moveq	#0,d0
000030B4 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000030B8 4880                       		ext.w	d0				; ''
000030BA 9440                       		sub.w	d0,d2				; Subtract from Y position
000030BC 0A42 000F                  		eori.w	#$F,d2				; Flip it
000030C0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000030C4 4880                       		ext.w	d0				; ''
000030C6 D640                       		add.w	d0,d3				; Add onto X position
000030C8 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000030CC 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000030D0 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000030D4 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000030D8                            		push.w	d1				; Save the primary floor distance
000030D8 3F01                     M 	move.w	d1,-(sp)
000030DA                            
000030DA                            		; Get the angle on the bottom left sensor
000030DA 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000030DE 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030E2 7000                       		moveq	#0,d0
000030E4 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000030E8 4880                       		ext.w	d0				; ''
000030EA 9440                       		sub.w	d0,d2				; Subtract from Y position
000030EC 0A42 000F                  		eori.w	#$F,d2				; Flip it
000030F0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000030F4 4880                       		ext.w	d0				; ''
000030F6 9640                       		sub.w	d0,d3				; Subtract from X position
000030F8 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000030FC 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003100 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003104 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003108                            		
00003108                            		; Update the object's angle
00003108                            		pop.w	d0				; Restore the primary floor distance
00003108 301F                     M 	move.w	(sp)+,d0
0000310A 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
0000310E 6000 FDF8                  		bra.w	PlayerPickAngle		; Get the angle
00003112                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003112                            ; Get the distance between a ceiling and a player object
00003112                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003112                            PlayerChkCeilingDist:
00003112 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003116 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000311A                            
0000311A                            PlayerChkCeilingDist_Part2:
0000311A 0442 000A                  		subi.w	#10,d2				; Check 10 pixels up
0000311E 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003122 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003126 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000312A 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000312E 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003132 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003136 6000 FE04                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000313A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000313A                            ; Get the distance between a ceiling and an object
0000313A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000313A                            ObjCheckCeilingDist:
0000313A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000313E 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003142 7000                       		moveq	#0,d0
00003144 1028 002D                  		move.b	oColH(a0),d0		; Get collision height
00003148 4880                       		ext.w	d0				; ''
0000314A 9440                       		sub.w	d0,d2				; Subtract it from Y position
0000314C 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003150 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003154 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003158 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000315C 7A0D                       		moveq	#$D,d5				; Solidity bits
0000315E 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003162 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003166 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000316A 6700                       		beq.s	.End				; If not, branch
0000316C 163C 0080                  		move.b	#$80,d3				; Angle value for when the object touched an odd angle (usually $FF)
00003170                            
00003170                            .End:
00003170 4E75                       		rts
00003172                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003172                            ; Get the distance between a left ceiling and a player object
00003172                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003172                            PlayerChkLeftCeilDist:
00003172                            		; Get the angle on the bottom right (rotated) sensor
00003172 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003176 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000317A 7000                       		moveq	#0,d0
0000317C 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003180 4880                       		ext.w	d0				; ''
00003182 9440                       		sub.w	d0,d2				; Subtract from Y position
00003184 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003188 4880                       		ext.w	d0				; ''
0000318A 9640                       		sub.w	d0,d3				; Subtract from X position
0000318C 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003190 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003194 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003198 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000319C 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031A0                            		push.w	d1				; Save the primary floor distance
000031A0 3F01                     M 	move.w	d1,-(sp)
000031A2                            
000031A2                            		; Get the angle on the bottom left (rotated) sensor
000031A2 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031A6 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000031AA 7000                       		moveq	#0,d0
000031AC 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000031B0 4880                       		ext.w	d0				; ''
000031B2 D440                       		add.w	d0,d2				; Add onto Y position
000031B4 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000031B8 4880                       		ext.w	d0				; ''
000031BA 9640                       		sub.w	d0,d3				; Subtract from X position
000031BC 0A43 000F                  		eori.w	#$F,d3				; Flip it
000031C0 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000031C4 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031C8 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000031CC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031D0                            
000031D0                            		; Update the object's angle
000031D0                            		pop.w	d0				; Restore the primary floor distance
000031D0 301F                     M 	move.w	(sp)+,d0
000031D2 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000031D6 6000 FD30                  		bra.w	PlayerPickAngle		; Get the angle
000031DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031DA                            ; Get the distance between a left wall and a player object
000031DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031DA                            PlayerChkLeftWallDist:
000031DA 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031DE 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000031E2                            
000031E2                            PlayerChkLeftWallDist_Part2:
000031E2 0443 000A                  		subi.w	#10,d3				; Check 10 pixels to the left
000031E6 0A43 000F                  		eori.w	#$F,d3				; Flip it
000031EA 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000031EE 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031F2 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000031F6 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031FA 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
000031FE 6000 FD3C                  		bra.w	PlayerGetPrimaryAngle		; Get angle
00003202                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003202                            ; Get the distance between a left wall and an object
00003202                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003202                            ObjCheckLeftWallDist:
00003202 D668 0014                  		add.w	oXPos(a0),d3			; Add X position
00003206 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000320A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000320E 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003212 4214                       		clr.b	(a4)				; Clear it
00003214 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003218 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000321C 7A0D                       		moveq	#$D,d5				; Solidity bits
0000321E 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003222 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003226 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000322A 6700                       		beq.s	.End				; If not, branch
0000322C 163C 0040                  		move.b	#$40,d3				; Angle value for when the object touched an odd angle (usually $FF)
00003230                            
00003230                            .End:
00003230 4E75                       		rts
00003232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003232                            ; Move a player object along on the ground
00003232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003232                            PlayerAnglePos:
00003232 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00003238 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
0000323E 6700                       		beq.s	.NotPrimary			; If not, branch
00003240 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00003246                            
00003246                            .NotPrimary:
00003246 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
0000324A 0828 0003 0028             		btst	#3,oStatus(a0)			; Are we standing on a player object?
00003250 6700                       		beq.s	.NotOnObj			; If not, branch
00003252 4268 002E                  		clr.w	oNextTilt(a0)			; Set the angles to 0
00003256 4E75                       		rts
00003258                            
00003258                            .NotOnObj:
00003258 317C 0303 002E             		move.w	#$0303,oNextTilt(a0)		; Set the angles to 3
0000325E                            		
0000325E                            		; Get which quadrant the object is in on the ground
0000325E                            		; This makes it so that angles:
0000325E                            		; 	$E0-$20 = Quadrant 0 (floor)
0000325E                            		;	$1F-$5F = Quadrant $40 (left wall)
0000325E                            		;	$60-$A0 = Quadrant $80 (ceiling)
0000325E                            		;	$A1-$DF = Quadrant $C0 (right wall)
0000325E 1028 0000                  		move.b	oAngle(a0),d0			; Get the angle
00003262 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00003266 6700                       		beq.s	.DownUp				; If not, branch
00003268 5200                       		addq.b	#1,d0				; Shift the angle
0000326A                            
0000326A                            .DownUp:
0000326A 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
0000326E 0200 00C0                  		andi.b	#$C0,d0				; Get which quadrant we are in (use $E0 instaead of $C0 for 8 directions)
00003272 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40 (left wall)?
00003276 6700 0000                  		beq.w	PlayerMoveLWall		; If so, branch
0000327A 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80 (ceiling)?
0000327E 6700 0000                  		beq.w	PlayerMoveCeiling		; Is so, branch
00003282 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0 (right wall)?
00003286 6700 0000                  		beq.w	PlayerMoveRWall		; If so, branch
0000328A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000328A                            ; Move the object along the floor
0000328A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000328A                            PlayerMoveFloor:
0000328A                            		; Get the angle on the bottom right sensor
0000328A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000328E 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003292 7000                       		moveq	#0,d0
00003294 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003298 4880                       		ext.w	d0				; ''
0000329A D440                       		add.w	d0,d2				; Add onto Y position
0000329C 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000032A0 4880                       		ext.w	d0				; ''
000032A2 D640                       		add.w	d0,d3				; Add onto X position
000032A4 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000032A8 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000032AC 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000032AE 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000032B2                            		push.w	d1				; Save the primary floor distance
000032B2 3F01                     M 	move.w	d1,-(sp)
000032B4                            
000032B4                            		; Get the angle on the bottom left sensor
000032B4 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000032B8 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000032BC 7000                       		moveq	#0,d0
000032BE 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000032C2 4880                       		ext.w	d0				; ''
000032C4 D440                       		add.w	d0,d2				; Add onto Y position
000032C6 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000032CA 4880                       		ext.w	d0				; ''
000032CC 9640                       		sub.w	d0,d3				; Add onto X position
000032CE 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000032D2 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000032D6 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000032D8 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000032DC                            		
000032DC                            		; Update the object's angle
000032DC                            		pop.w	d0				; Restore the primary floor distance
000032DC 301F                     M 	move.w	(sp)+,d0
000032DE 6100 0000                  		bsr.w	PlayerSetAngle			; Set the new angle
000032E2                            		
000032E2                            		; Check if the object has hit a wall or is about to fall
000032E2 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000032E4 6700                       		beq.s	.End				; If so, branch
000032E6 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000032E8 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000032EC 6D00                       		blt.s	.End				; If so, branch
000032EE D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
000032F2                            
000032F2                            .End:
000032F2 4E75                       		rts
000032F4                            
000032F4                            .ChkFall:
000032F4 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
000032F8 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000032FA 4400                       		neg.b	d0				; Force it to be positive
000032FC                            
000032FC                            .GetMinDist:
000032FC 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
000032FE 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003302 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003304 103C 000E                  		move.b	#$E,d0				; ''
00003308                            
00003308                            .ChkDist:
00003308 B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000330A 6E00                       		bgt.s	.SetAir				; If so, branch
0000330C D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
00003310 4E75                       		rts
00003312                            
00003312                            .SetAir:
00003312 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00003318 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000331E 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00003324 4E75                       		rts
00003326                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003326                            ; Set the objects's angle
00003326                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003326                            PlayerSetAngle:
00003326 1428 002F                  		move.b	oTilt(a0),d2			; Get secondary angle
0000332A B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
0000332C 6F00                       		ble.s	.ChkSetAngle			; If not, branch
0000332E 1428 002E                  		move.b	oNextTilt(a0),d2		; Get primary angle
00003332 3200                       		move.w	d0,d1				; Get primary floor distance
00003334                            		
00003334                            .ChkSetAngle:
00003334 0802 0000                  		btst	#0,d2				; Is this an odd angle (usually $FF)?
00003338 6600                       		bne.s	.LatchOnFlat			; If so, branch
0000333A 1002                       		move.b	d2,d0				; Get angle change
0000333C 9028 0000                  		sub.b	oAngle(a0),d0			; ''
00003340 6A00                       		bpl.s	.ChkDist			; ''
00003342 4400                       		neg.b	d0				; ''
00003344                            
00003344                            .ChkDist:
00003344 0C00 0020                  		cmpi.b	#$20,d0				; Has the player moved $20 degrees or more?
00003348 6400                       		bhs.s	.LatchOnFlat			; If so, branch
0000334A 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
0000334E 4E75                       		rts
00003350                            
00003350                            .LatchOnFlat:
00003350 1428 0000                  		move.b	oAngle(a0),d2			; Get old angle value
00003354 0602 0020                  		addi.b	#$20,d2				; Shift the angle
00003358 0202 00C0                  		andi.b	#$C0,d2				; Flatten the angle
0000335C 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
00003360 4E75                       		rts
00003362                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003362                            ; Move the object along the right wall
00003362                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003362                            PlayerMoveRWall:
00003362                            		; Get the angle on the bottom right (rotated) sensor
00003362 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003366 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000336A 7000                       		moveq	#0,d0
0000336C 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003370 4880                       		ext.w	d0				; ''
00003372 9440                       		sub.w	d0,d2				; Add onto Y position
00003374 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003378 4880                       		ext.w	d0				; ''
0000337A D640                       		add.w	d0,d3				; Add onto X position
0000337C 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003380 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003384 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003386 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000338A                            		push.w	d1				; Save the primary floor distance
0000338A 3F01                     M 	move.w	d1,-(sp)
0000338C                            
0000338C                            		; Get the angle on the bottom left (rotated) sensor
0000338C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003390 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003394 7000                       		moveq	#0,d0
00003396 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000339A 4880                       		ext.w	d0				; ''
0000339C D440                       		add.w	d0,d2				; Add onto Y position
0000339E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000033A2 4880                       		ext.w	d0				; ''
000033A4 D640                       		add.w	d0,d3				; Add onto X position
000033A6 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000033AA 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000033AE 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000033B0 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000033B4                            		
000033B4                            		; Update the object's angle
000033B4                            		pop.w	d0				; Restore the primary floor distance
000033B4 301F                     M 	move.w	(sp)+,d0
000033B6 6100 FF6E                  		bsr.w	PlayerSetAngle			; Set the new angle
000033BA                            
000033BA                            		; Check if the object has hit a wall or is about to fall
000033BA 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000033BC 6700                       		beq.s	.End				; If so, branch
000033BE 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000033C0 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000033C4 6D00                       		blt.s	.End				; If so, branch
000033C6 D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
000033CA                            
000033CA                            .End:
000033CA 4E75                       		rts
000033CC                            
000033CC                            .ChkFall:
000033CC 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
000033D0 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000033D2 4400                       		neg.b	d0				; Force it to be positive
000033D4                            
000033D4                            .GetMinDist:
000033D4 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
000033D6 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000033DA 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000033DC 103C 000E                  		move.b	#$E,d0				; ''
000033E0                            
000033E0                            .ChkDist:
000033E0 B200                       		cmp.b	d0,d1				; Are we about to fall off?
000033E2 6E00                       		bgt.s	.SetAir				; If so, branch
000033E4 D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
000033E8 4E75                       		rts
000033EA                            
000033EA                            .SetAir:
000033EA 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
000033F0 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
000033F6 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
000033FC 4E75                       		rts
000033FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033FE                            ; Move the object along the ceiling
000033FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033FE                            PlayerMoveCeiling:
000033FE                            		; Get the angle on the bottom right (rotated) sensor
000033FE 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003402 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003406 7000                       		moveq	#0,d0
00003408 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
0000340C 4880                       		ext.w	d0				; ''
0000340E 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003410 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003414 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003418 4880                       		ext.w	d0				; ''
0000341A D640                       		add.w	d0,d3				; Add onto X position
0000341C 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003420 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003424 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003428 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000342C                            		push.w	d1				; Save the primary floor distance
0000342C 3F01                     M 	move.w	d1,-(sp)
0000342E                            
0000342E                            		; Get the angle on the bottom left (rotated) sensor
0000342E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003432 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003436 7000                       		moveq	#0,d0
00003438 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
0000343C 4880                       		ext.w	d0				; ''
0000343E 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003440 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003444 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003448 4880                       		ext.w	d0				; ''
0000344A 9640                       		sub.w	d0,d3				; Subtract from the X position
0000344C 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003450 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003454 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003458 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000345C                            		
0000345C                            		; Update the object's angle
0000345C                            		pop.w	d0				; Restore the primary floor distance
0000345C 301F                     M 	move.w	(sp)+,d0
0000345E 6100 FEC6                  		bsr.w	PlayerSetAngle			; Set the new angle
00003462                            		
00003462                            		; Check if the object has hit a wall or is about to fall
00003462 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003464 6700                       		beq.s	.End				; If so, branch
00003466 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003468 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
0000346C 6D00                       		blt.s	.End				; If so, branch
0000346E 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
00003472                            
00003472                            .End:
00003472 4E75                       		rts
00003474                            
00003474                            .ChkFall:
00003474 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
00003478 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
0000347A 4400                       		neg.b	d0				; Force it to be positive
0000347C                            
0000347C                            .GetMinDist:
0000347C 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
0000347E 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003482 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003484 103C 000E                  		move.b	#$E,d0				; ''
00003488                            
00003488                            .ChkDist:
00003488 B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000348A 6E00                       		bgt.s	.SetAir				; If so, branch
0000348C 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
00003490 4E75                       		rts
00003492                            
00003492                            .SetAir:
00003492 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00003498 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000349E 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
000034A4 4E75                       		rts
000034A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034A6                            ; Move the object along the left wall
000034A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034A6                            PlayerMoveLWall:
000034A6                            		; Get the angle on the bottom right (rotated) sensor
000034A6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000034AA 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000034AE 7000                       		moveq	#0,d0
000034B0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000034B4 4880                       		ext.w	d0				; ''
000034B6 9440                       		sub.w	d0,d2				; Subtract from the Y position
000034B8 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000034BC 4880                       		ext.w	d0				; ''
000034BE 9640                       		sub.w	d0,d3				; Subtract from X position
000034C0 0A43 000F                  		eori.w	#$F,d3				; Flip it
000034C4 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000034C8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034CC 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000034D0 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000034D4                            		push.w	d1				; Save the primary floor distance
000034D4 3F01                     M 	move.w	d1,-(sp)
000034D6                            
000034D6                            		; Get the angle on the bottom left (rotated) sensor
000034D6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000034DA 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000034DE 7000                       		moveq	#0,d0
000034E0 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000034E4 4880                       		ext.w	d0				; ''
000034E6 D440                       		add.w	d0,d2				; Add onto Y position
000034E8 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000034EC 4880                       		ext.w	d0				; ''
000034EE 9640                       		sub.w	d0,d3				; Subtract from X position
000034F0 0A43 000F                  		eori.w	#$F,d3				; Flip it
000034F4 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000034F8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034FC 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003500 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003504                            		
00003504                            		; Update the object's angle
00003504                            		pop.w	d0				; Restore the primary floor distance
00003504 301F                     M 	move.w	(sp)+,d0
00003506 6100 FE1E                  		bsr.w	PlayerSetAngle			; Set the new angle
0000350A                            		
0000350A                            		; Check if the object has hit a wall or is about to fall
0000350A 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
0000350C 6700                       		beq.s	.End				; If so, branch
0000350E 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003510 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003514 6D00                       		blt.s	.End				; If so, branch
00003516 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
0000351A                            
0000351A                            .End:
0000351A 4E75                       		rts
0000351C                            
0000351C                            .ChkFall:
0000351C 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
00003520 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003522 4400                       		neg.b	d0				; Force it to be positive
00003524                            
00003524                            .GetMinDist:
00003524 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
00003526 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000352A 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
0000352C 103C 000E                  		move.b	#$E,d0				; ''
00003530                            
00003530                            .ChkDist:
00003530 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003532 6E00                       		bgt.s	.SetAir				; If so, branch
00003534 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
00003538 4E75                       		rts
0000353A                            
0000353A                            .SetAir:
0000353A 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00003540 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
00003546 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000354C 4E75                       		rts
0000354E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000354E                            ; Find the nearest floor from the object's position
0000354E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000354E                            ; PARAMETERS:
0000354E                            ;	d2.w	- Y position of the object's bottom sensor
0000354E                            ;	d3.w	- X position of the object's bottom sensor
0000354E                            ;	d5.w	- Bit to chect for solidity
0000354E                            ;	d6.w	- Flip bits (for walls and ceilings)
0000354E                            ;	a3.w	- Distance in pixels to check for blocks above or below the sensor
0000354E                            ;	a4.w	- Pointer to where the angle value will be stored
0000354E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000354E                            ; RETURNS:
0000354E                            ;	d1.w	- The distance from the object to the floor
0000354E                            ;	(a1).w	- The block ID in the chunk where the object is standing
0000354E                            ;	(a4).w	- The floor angle
0000354E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000354E                            Level_FindFloor:
0000354E 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003552 3011                       		move.w	(a1),d0				; Get block ID
00003554 3800                       		move.w	d0,d4				; Copy that
00003556 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
0000355A 6700                       		beq.s	.IsBlank			; If it's blank, branch
0000355C 0B04                       		btst	d5,d4				; Is the block solid?
0000355E 6600                       		bne.s	.IsSolid			; If so, branch
00003560                            
00003560                            .IsBlank:
00003560 D44B                       		add.w	a3,d2				; Check below the sensor
00003562 6100 0000                  		bsr.w	Level_FindFloor2		; Try to find a solid block there
00003566 944B                       		sub.w	a3,d2				; Restore Y position of sensor
00003568 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
0000356C 4E75                       		rts
0000356E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000356E                            .IsSolid:
0000356E 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
00003572 D040                       		add.w	d0,d0				; Turn ID into offset
00003574 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003578 0240 00FF                  		andi.w	#$FF,d0				; ''
0000357C 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
0000357E                            
0000357E 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003582 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003586 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003588                            
00003588 3203                       		move.w	d3,d1				; Get the object's X position
0000358A 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
0000358E 6700                       		beq.s	.NoXFlip			; If not, branch
00003590 4641                       		not.w	d1				; Flip the X position
00003592 4414                       		neg.b	(a4)				; Flip the angle
00003594                            		
00003594                            .NoXFlip:
00003594 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003598 6700                       		beq.s	.NoYFlip			; If not, branch
0000359A 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
0000359E 4414                       		neg.b	(a4)				; ''
000035A0 0414 0040                  		subi.b	#$40,(a4)			; ''
000035A4                            
000035A4                            .NoYFlip:
000035A4 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
000035A8 D240                       		add.w	d0,d1				; Add the collision block's offset
000035AA                            
000035AA 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
000035AE 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
000035B2 4880                       		ext.w	d0				; ''
000035B4 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
000035B6 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000035BA 6700                       		beq.s	.NoYFlip2			; If not, branch
000035BC 4440                       		neg.w	d0				; Flip the height
000035BE                            
000035BE                            .NoYFlip2:
000035BE 4A40                       		tst.w	d0				; Check the height
000035C0 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000035C2 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000035C4 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
000035C8 6700                       		beq.s	.MaxFloor			; If so, branch
000035CA 3202                       		move.w	d2,d1				; Get the object's Y position
000035CC 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000035D0 D041                       		add.w	d1,d0				; Add onto the height
000035D2 323C 000F                  		move.w	#$F,d1				; Get actual distance
000035D6 9240                       		sub.w	d0,d1				; ''
000035D8 4E75                       		rts
000035DA                            
000035DA                            .NegHeight:
000035DA 3202                       		move.w	d2,d1				; Get the object's Y position
000035DC 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000035E0 D041                       		add.w	d1,d0				; Add onto the height
000035E2 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000035E6                            
000035E6                            .MaxFloor:
000035E6 944B                       		sub.w	a3,d2				; Check above the sensor
000035E8 6100                       		bsr.s	Level_FindFloor2		; Try to find a solid block there
000035EA D44B                       		add.w	a3,d2				; Restore Y position of sensor
000035EC 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
000035F0 4E75                       		rts
000035F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035F2                            Level_FindFloor2:
000035F2 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
000035F6 3011                       		move.w	(a1),d0				; Get block ID
000035F8 3800                       		move.w	d0,d4				; Copy that
000035FA 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
000035FE 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003600 0B04                       		btst	d5,d4				; Is the block solid?
00003602 6600                       		bne.s	.IsSolid			; If so, branch
00003604                            
00003604                            .IsBlank:
00003604 323C 000F                  		move.w	#$F,d1				; Get max distance
00003608 3002                       		move.w	d2,d0				; Get the object's Y position
0000360A 0240 000F                  		andi.w	#$F,d0				; Get the Y offset in the height
0000360E 9240                       		sub.w	d0,d1				; Get actual distance
00003610 4E75                       		rts
00003612                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003612                            .IsSolid:
00003612 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
00003616 D040                       		add.w	d0,d0				; Turn ID into offset
00003618 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
0000361C 0240 00FF                  		andi.w	#$FF,d0				; ''
00003620 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003622                            
00003622 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003626 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
0000362A E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
0000362C                            
0000362C 3203                       		move.w	d3,d1				; Get the object's X position
0000362E 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003632 6700                       		beq.s	.NoXFlip			; If not, branch
00003634 4641                       		not.w	d1				; Flip the X position
00003636 4414                       		neg.b	(a4)				; Flip the angle
00003638                            
00003638                            .NoXFlip:
00003638 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000363C 6700                       		beq.s	.NoYFlip			; If not, branch
0000363E 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003642 4414                       		neg.b	(a4)				; ''
00003644 0414 0040                  		subi.b	#$40,(a4)			; ''
00003648                            
00003648                            .NoYFlip:
00003648 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
0000364C D240                       		add.w	d0,d1				; Add the collision block's offset
0000364E                            
0000364E 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
00003652 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003656 4880                       		ext.w	d0				; ''
00003658 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
0000365A 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000365E 6700                       		beq.s	.NoYFlip2			; If not, branch
00003660 4440                       		neg.w	d0				; Flip the height
00003662                            
00003662                            .NoYFlip2:
00003662 4A40                       		tst.w	d0				; Check the height
00003664 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003666 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003668 3202                       		move.w	d2,d1				; Get the object's Y position
0000366A 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000366E D041                       		add.w	d1,d0				; Add onto the height
00003670 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003674 9240                       		sub.w	d0,d1				; ''
00003676 4E75                       		rts
00003678                            
00003678                            .NegHeight:
00003678 3202                       		move.w	d2,d1				; Get the object's Y position
0000367A 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000367E D041                       		add.w	d1,d0				; Add onto the height
00003680 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003684 4641                       		not.w	d1				; Flip the height
00003686 4E75                       		rts
00003688                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003688                            ; Find the nearest wall from the object's position
00003688                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003688                            ; PARAMETERS:
00003688                            ;	d2.w	- Y position of the object's bottom sensor
00003688                            ;	d3.w	- X position of the object's bottom sensor
00003688                            ;	d5.w	- Bit to chect for solidity
00003688                            ;	d6.w	- Flip bits (for walls and ceilings)
00003688                            ;	a3.w	- Distance in pixels to check for blocks left of or right of the sensor
00003688                            ;	a4.w	- Pointer to where the angle value will be stored
00003688                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003688                            ; RETURNS:
00003688                            ;	d1.w	- The distance from the object to the floor
00003688                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003688                            ;	(a4).w	- The floor angle
00003688                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003688                            Level_FindWall:
00003688 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
0000368C 3011                       		move.w	(a1),d0				; Get block ID
0000368E 3800                       		move.w	d0,d4				; Copy that
00003690 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003694 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003696 0B04                       		btst	d5,d4				; Is the block solid?
00003698 6600                       		bne.s	.IsSolid			; If so, branch
0000369A                            
0000369A                            .IsBlank:
0000369A D64B                       		add.w	a3,d3				; Check right to the sensor
0000369C 6100 0000                  		bsr.w	Level_FindWall2			; Try to find a solid block there
000036A0 964B                       		sub.w	a3,d3				; Restore X position of sensor
000036A2 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
000036A6 4E75                       		rts
000036A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036A8                            .IsSolid:
000036A8 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
000036AC D040                       		add.w	d0,d0				; Turn ID into offset
000036AE 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000036B2 0240 00FF                  		andi.w	#$FF,d0				; ''
000036B6 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
000036B8                            
000036B8 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
000036BC 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
000036C0 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
000036C2                            
000036C2 3202                       		move.w	d2,d1				; Get the object's Y position
000036C4 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000036C8 6700                       		beq.s	.NoYFlip			; If not, branch
000036CA 4641                       		not.w	d1				; Flip the Y position
000036CC 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
000036D0 4414                       		neg.b	(a4)				; ''
000036D2 0414 0040                  		subi.b	#$40,(a4)			; ''
000036D6                            
000036D6                            .NoYFlip:
000036D6 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
000036DA 6700                       		beq.s	.NoXFlip			; If not, branch
000036DC 4414                       		neg.b	(a4)				; Flip the angle
000036DE                            
000036DE                            .NoXFlip:
000036DE 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
000036E2 D240                       		add.w	d0,d1				; Add the collision block's offset
000036E4                            
000036E4 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
000036E8 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
000036EC 4880                       		ext.w	d0				; ''
000036EE BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
000036F0 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
000036F4 6700                       		beq.s	.NoYFlip2			; If not, branch
000036F6 4440                       		neg.w	d0				; Flip the height
000036F8                            
000036F8                            .NoYFlip2:
000036F8 4A40                       		tst.w	d0				; Check the height
000036FA 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000036FC 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000036FE 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
00003702 6700                       		beq.s	.MaxFloor			; If so, branch
00003704 3203                       		move.w	d3,d1				; Get the object's X position
00003706 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
0000370A D041                       		add.w	d1,d0				; Add onto the height
0000370C 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003710 9240                       		sub.w	d0,d1				; ''
00003712 4E75                       		rts
00003714                            
00003714                            .NegHeight:
00003714 3203                       		move.w	d3,d1				; Get the object's X position
00003716 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
0000371A D041                       		add.w	d1,d0				; Add onto the height
0000371C 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003720                            
00003720                            .MaxFloor:
00003720 964B                       		sub.w	a3,d3				; Check left to the sensor
00003722 6100                       		bsr.s	Level_FindWall2			; Try to find a solid block there
00003724 D64B                       		add.w	a3,d3				; Restore X position of sensor
00003726 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
0000372A 4E75                       		rts
0000372C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000372C                            Level_FindWall2:
0000372C 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003730 3011                       		move.w	(a1),d0				; Get block ID
00003732 3800                       		move.w	d0,d4				; Copy that
00003734 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003738 6700                       		beq.s	.IsBlank			; If it's blank, branch
0000373A 0B04                       		btst	d5,d4				; Is the block solid?
0000373C 6600                       		bne.s	.IsSolid			; If so, branch
0000373E                            
0000373E                            .IsBlank:
0000373E 323C 000F                  		move.w	#$F,d1				; Get max distance
00003742 3003                       		move.w	d3,d0				; Get the object's X position
00003744 0240 000F                  		andi.w	#$F,d0				; Get the X offset in the height
00003748 9240                       		sub.w	d0,d1				; Get actual distance
0000374A 4E75                       		rts
0000374C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000374C                            .IsSolid:
0000374C 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
00003750 D040                       		add.w	d0,d0				; Turn ID into offset
00003752 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003756 0240 00FF                  		andi.w	#$FF,d0				; ''
0000375A 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
0000375C                            
0000375C 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003760 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003764 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003766                            
00003766 3202                       		move.w	d2,d1				; Get the object's Y position
00003768 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
0000376C 6700                       		beq.s	.NoYFlip			; If not, branch
0000376E 4641                       		not.w	d1				; Flip the Y position
00003770 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003774 4414                       		neg.b	(a4)				; ''
00003776 0414 0040                  		subi.b	#$40,(a4)			; ''
0000377A                            
0000377A                            .NoYFlip:
0000377A 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
0000377E 6700                       		beq.s	.NoXFlip			; If not, branch
00003780 4414                       		neg.b	(a4)				; Flip the angle
00003782                            
00003782                            .NoXFlip:
00003782 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003786 D240                       		add.w	d0,d1				; Add the collision block's offset
00003788                            
00003788 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
0000378C 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003790 4880                       		ext.w	d0				; ''
00003792 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003794 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003798 6700                       		beq.s	.NoYFlip2			; If not, branch
0000379A 4440                       		neg.w	d0				; Flip the height
0000379C                            
0000379C                            .NoYFlip2:
0000379C 4A40                       		tst.w	d0				; Check the height
0000379E 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000037A0 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000037A2 3203                       		move.w	d3,d1				; Get the object's X position
000037A4 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000037A8 D041                       		add.w	d1,d0				; Add onto the height
000037AA 323C 000F                  		move.w	#$F,d1				; Get actual distance
000037AE 9240                       		sub.w	d0,d1				; ''
000037B0 4E75                       		rts
000037B2                            
000037B2                            .NegHeight:
000037B2 3203                       		move.w	d3,d1				; Get the object's X position
000037B4 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000037B8 D041                       		add.w	d1,d0				; Add onto the height
000037BA 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000037BE 4641                       		not.w	d1				; Flip the height
000037C0 4E75                       		rts
000037C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037C2                            ; Find the nearest block in the level from the player
000037C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037C2                            ; PARAMETERS:
000037C2                            ;	d2.w	- Y position of the object's sensor
000037C2                            ;	d3.w	- X position of the object's sensor
000037C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037C2                            ; RETURNS:
000037C2                            ;	(a1).w	- The block ID in the chunk where the object is standing
000037C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037C2                            Level_FindBlock:
000037C2 3002                       		move.w	d2,d0				; Get the object's Y position
000037C4 D040                       		add.w	d0,d0				; Double it
000037C6 0240 0F00                  		andi.w	#$F00,d0			; Get chunk row offset
000037CA 3203                       		move.w	d3,d1				; Get the object's X position
000037CC E649                       		lsr.w	#3,d1				; Divide by 8
000037CE 3801                       		move.w	d1,d4				; Save for later
000037D0 E849                       		lsr.w	#4,d1				; Divide by 16 to get the offset of the chunk in the chunk row
000037D2 0241 007F                  		andi.w	#$7F,d1				; Only 128 chunks per row
000037D6 D041                       		add.w	d1,d0				; Get offset in the level layout
000037D8 72FF                       		moveq	#-1,d1				; Prepare the chunk table pointer
000037DA 4241                       		clr.w	d1				; ''
000037DC 43F8 DFD0                  		lea	rLayout.w,a1			; Get layout pointer
000037E0 1231 0000                  		move.b	(a1,d0.w),d1			; Get chunk ID
000037E4 D241                       		add.w	d1,d1				; Turn into offset
000037E6 323B 1000                  		move.w	.ChunkOffsets(pc,d1.w),d1	; Get offset in chunk table
000037EA 3002                       		move.w	d2,d0				; Get the object's Y position
000037EC 0240 0070                  		andi.w	#$70,d0				; Get Y position within chunk
000037F0 D240                       		add.w	d0,d1				; Add onto the offset
000037F2 0244 000E                  		andi.w	#$E,d4				; Get the previously saved X position divided by 8 (for the row offset)
000037F6 D244                       		add.w	d4,d1				; Add onto the offset
000037F8 2241                       		movea.l	d1,a1				; Get pointer in chunk table
000037FA 4E75                       		rts
000037FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037FC                            .ChunkOffsets:
000037FC =00000000                  c		= 0
000037FC                            		rept	256
000037FC                            			dc.w	c
000037FC                            c			= c+$80
000037FC                            		endr
000037FC 0000                     M 	dc.w	c
000037FE =00000080                M c	=	c+$80
000037FE 0080                     M 	dc.w	c
00003800 =00000100                M c	=	c+$80
00003800 0100                     M 	dc.w	c
00003802 =00000180                M c	=	c+$80
00003802 0180                     M 	dc.w	c
00003804 =00000200                M c	=	c+$80
00003804 0200                     M 	dc.w	c
00003806 =00000280                M c	=	c+$80
00003806 0280                     M 	dc.w	c
00003808 =00000300                M c	=	c+$80
00003808 0300                     M 	dc.w	c
0000380A =00000380                M c	=	c+$80
0000380A 0380                     M 	dc.w	c
0000380C =00000400                M c	=	c+$80
0000380C 0400                     M 	dc.w	c
0000380E =00000480                M c	=	c+$80
0000380E 0480                     M 	dc.w	c
00003810 =00000500                M c	=	c+$80
00003810 0500                     M 	dc.w	c
00003812 =00000580                M c	=	c+$80
00003812 0580                     M 	dc.w	c
00003814 =00000600                M c	=	c+$80
00003814 0600                     M 	dc.w	c
00003816 =00000680                M c	=	c+$80
00003816 0680                     M 	dc.w	c
00003818 =00000700                M c	=	c+$80
00003818 0700                     M 	dc.w	c
0000381A =00000780                M c	=	c+$80
0000381A 0780                     M 	dc.w	c
0000381C =00000800                M c	=	c+$80
0000381C 0800                     M 	dc.w	c
0000381E =00000880                M c	=	c+$80
0000381E 0880                     M 	dc.w	c
00003820 =00000900                M c	=	c+$80
00003820 0900                     M 	dc.w	c
00003822 =00000980                M c	=	c+$80
00003822 0980                     M 	dc.w	c
00003824 =00000A00                M c	=	c+$80
00003824 0A00                     M 	dc.w	c
00003826 =00000A80                M c	=	c+$80
00003826 0A80                     M 	dc.w	c
00003828 =00000B00                M c	=	c+$80
00003828 0B00                     M 	dc.w	c
0000382A =00000B80                M c	=	c+$80
0000382A 0B80                     M 	dc.w	c
0000382C =00000C00                M c	=	c+$80
0000382C 0C00                     M 	dc.w	c
0000382E =00000C80                M c	=	c+$80
0000382E 0C80                     M 	dc.w	c
00003830 =00000D00                M c	=	c+$80
00003830 0D00                     M 	dc.w	c
00003832 =00000D80                M c	=	c+$80
00003832 0D80                     M 	dc.w	c
00003834 =00000E00                M c	=	c+$80
00003834 0E00                     M 	dc.w	c
00003836 =00000E80                M c	=	c+$80
00003836 0E80                     M 	dc.w	c
00003838 =00000F00                M c	=	c+$80
00003838 0F00                     M 	dc.w	c
0000383A =00000F80                M c	=	c+$80
0000383A 0F80                     M 	dc.w	c
0000383C =00001000                M c	=	c+$80
0000383C 1000                     M 	dc.w	c
0000383E =00001080                M c	=	c+$80
0000383E 1080                     M 	dc.w	c
00003840 =00001100                M c	=	c+$80
00003840 1100                     M 	dc.w	c
00003842 =00001180                M c	=	c+$80
00003842 1180                     M 	dc.w	c
00003844 =00001200                M c	=	c+$80
00003844 1200                     M 	dc.w	c
00003846 =00001280                M c	=	c+$80
00003846 1280                     M 	dc.w	c
00003848 =00001300                M c	=	c+$80
00003848 1300                     M 	dc.w	c
0000384A =00001380                M c	=	c+$80
0000384A 1380                     M 	dc.w	c
0000384C =00001400                M c	=	c+$80
0000384C 1400                     M 	dc.w	c
0000384E =00001480                M c	=	c+$80
0000384E 1480                     M 	dc.w	c
00003850 =00001500                M c	=	c+$80
00003850 1500                     M 	dc.w	c
00003852 =00001580                M c	=	c+$80
00003852 1580                     M 	dc.w	c
00003854 =00001600                M c	=	c+$80
00003854 1600                     M 	dc.w	c
00003856 =00001680                M c	=	c+$80
00003856 1680                     M 	dc.w	c
00003858 =00001700                M c	=	c+$80
00003858 1700                     M 	dc.w	c
0000385A =00001780                M c	=	c+$80
0000385A 1780                     M 	dc.w	c
0000385C =00001800                M c	=	c+$80
0000385C 1800                     M 	dc.w	c
0000385E =00001880                M c	=	c+$80
0000385E 1880                     M 	dc.w	c
00003860 =00001900                M c	=	c+$80
00003860 1900                     M 	dc.w	c
00003862 =00001980                M c	=	c+$80
00003862 1980                     M 	dc.w	c
00003864 =00001A00                M c	=	c+$80
00003864 1A00                     M 	dc.w	c
00003866 =00001A80                M c	=	c+$80
00003866 1A80                     M 	dc.w	c
00003868 =00001B00                M c	=	c+$80
00003868 1B00                     M 	dc.w	c
0000386A =00001B80                M c	=	c+$80
0000386A 1B80                     M 	dc.w	c
0000386C =00001C00                M c	=	c+$80
0000386C 1C00                     M 	dc.w	c
0000386E =00001C80                M c	=	c+$80
0000386E 1C80                     M 	dc.w	c
00003870 =00001D00                M c	=	c+$80
00003870 1D00                     M 	dc.w	c
00003872 =00001D80                M c	=	c+$80
00003872 1D80                     M 	dc.w	c
00003874 =00001E00                M c	=	c+$80
00003874 1E00                     M 	dc.w	c
00003876 =00001E80                M c	=	c+$80
00003876 1E80                     M 	dc.w	c
00003878 =00001F00                M c	=	c+$80
00003878 1F00                     M 	dc.w	c
0000387A =00001F80                M c	=	c+$80
0000387A 1F80                     M 	dc.w	c
0000387C =00002000                M c	=	c+$80
0000387C 2000                     M 	dc.w	c
0000387E =00002080                M c	=	c+$80
0000387E 2080                     M 	dc.w	c
00003880 =00002100                M c	=	c+$80
00003880 2100                     M 	dc.w	c
00003882 =00002180                M c	=	c+$80
00003882 2180                     M 	dc.w	c
00003884 =00002200                M c	=	c+$80
00003884 2200                     M 	dc.w	c
00003886 =00002280                M c	=	c+$80
00003886 2280                     M 	dc.w	c
00003888 =00002300                M c	=	c+$80
00003888 2300                     M 	dc.w	c
0000388A =00002380                M c	=	c+$80
0000388A 2380                     M 	dc.w	c
0000388C =00002400                M c	=	c+$80
0000388C 2400                     M 	dc.w	c
0000388E =00002480                M c	=	c+$80
0000388E 2480                     M 	dc.w	c
00003890 =00002500                M c	=	c+$80
00003890 2500                     M 	dc.w	c
00003892 =00002580                M c	=	c+$80
00003892 2580                     M 	dc.w	c
00003894 =00002600                M c	=	c+$80
00003894 2600                     M 	dc.w	c
00003896 =00002680                M c	=	c+$80
00003896 2680                     M 	dc.w	c
00003898 =00002700                M c	=	c+$80
00003898 2700                     M 	dc.w	c
0000389A =00002780                M c	=	c+$80
0000389A 2780                     M 	dc.w	c
0000389C =00002800                M c	=	c+$80
0000389C 2800                     M 	dc.w	c
0000389E =00002880                M c	=	c+$80
0000389E 2880                     M 	dc.w	c
000038A0 =00002900                M c	=	c+$80
000038A0 2900                     M 	dc.w	c
000038A2 =00002980                M c	=	c+$80
000038A2 2980                     M 	dc.w	c
000038A4 =00002A00                M c	=	c+$80
000038A4 2A00                     M 	dc.w	c
000038A6 =00002A80                M c	=	c+$80
000038A6 2A80                     M 	dc.w	c
000038A8 =00002B00                M c	=	c+$80
000038A8 2B00                     M 	dc.w	c
000038AA =00002B80                M c	=	c+$80
000038AA 2B80                     M 	dc.w	c
000038AC =00002C00                M c	=	c+$80
000038AC 2C00                     M 	dc.w	c
000038AE =00002C80                M c	=	c+$80
000038AE 2C80                     M 	dc.w	c
000038B0 =00002D00                M c	=	c+$80
000038B0 2D00                     M 	dc.w	c
000038B2 =00002D80                M c	=	c+$80
000038B2 2D80                     M 	dc.w	c
000038B4 =00002E00                M c	=	c+$80
000038B4 2E00                     M 	dc.w	c
000038B6 =00002E80                M c	=	c+$80
000038B6 2E80                     M 	dc.w	c
000038B8 =00002F00                M c	=	c+$80
000038B8 2F00                     M 	dc.w	c
000038BA =00002F80                M c	=	c+$80
000038BA 2F80                     M 	dc.w	c
000038BC =00003000                M c	=	c+$80
000038BC 3000                     M 	dc.w	c
000038BE =00003080                M c	=	c+$80
000038BE 3080                     M 	dc.w	c
000038C0 =00003100                M c	=	c+$80
000038C0 3100                     M 	dc.w	c
000038C2 =00003180                M c	=	c+$80
000038C2 3180                     M 	dc.w	c
000038C4 =00003200                M c	=	c+$80
000038C4 3200                     M 	dc.w	c
000038C6 =00003280                M c	=	c+$80
000038C6 3280                     M 	dc.w	c
000038C8 =00003300                M c	=	c+$80
000038C8 3300                     M 	dc.w	c
000038CA =00003380                M c	=	c+$80
000038CA 3380                     M 	dc.w	c
000038CC =00003400                M c	=	c+$80
000038CC 3400                     M 	dc.w	c
000038CE =00003480                M c	=	c+$80
000038CE 3480                     M 	dc.w	c
000038D0 =00003500                M c	=	c+$80
000038D0 3500                     M 	dc.w	c
000038D2 =00003580                M c	=	c+$80
000038D2 3580                     M 	dc.w	c
000038D4 =00003600                M c	=	c+$80
000038D4 3600                     M 	dc.w	c
000038D6 =00003680                M c	=	c+$80
000038D6 3680                     M 	dc.w	c
000038D8 =00003700                M c	=	c+$80
000038D8 3700                     M 	dc.w	c
000038DA =00003780                M c	=	c+$80
000038DA 3780                     M 	dc.w	c
000038DC =00003800                M c	=	c+$80
000038DC 3800                     M 	dc.w	c
000038DE =00003880                M c	=	c+$80
000038DE 3880                     M 	dc.w	c
000038E0 =00003900                M c	=	c+$80
000038E0 3900                     M 	dc.w	c
000038E2 =00003980                M c	=	c+$80
000038E2 3980                     M 	dc.w	c
000038E4 =00003A00                M c	=	c+$80
000038E4 3A00                     M 	dc.w	c
000038E6 =00003A80                M c	=	c+$80
000038E6 3A80                     M 	dc.w	c
000038E8 =00003B00                M c	=	c+$80
000038E8 3B00                     M 	dc.w	c
000038EA =00003B80                M c	=	c+$80
000038EA 3B80                     M 	dc.w	c
000038EC =00003C00                M c	=	c+$80
000038EC 3C00                     M 	dc.w	c
000038EE =00003C80                M c	=	c+$80
000038EE 3C80                     M 	dc.w	c
000038F0 =00003D00                M c	=	c+$80
000038F0 3D00                     M 	dc.w	c
000038F2 =00003D80                M c	=	c+$80
000038F2 3D80                     M 	dc.w	c
000038F4 =00003E00                M c	=	c+$80
000038F4 3E00                     M 	dc.w	c
000038F6 =00003E80                M c	=	c+$80
000038F6 3E80                     M 	dc.w	c
000038F8 =00003F00                M c	=	c+$80
000038F8 3F00                     M 	dc.w	c
000038FA =00003F80                M c	=	c+$80
000038FA 3F80                     M 	dc.w	c
000038FC =00004000                M c	=	c+$80
000038FC 4000                     M 	dc.w	c
000038FE =00004080                M c	=	c+$80
000038FE 4080                     M 	dc.w	c
00003900 =00004100                M c	=	c+$80
00003900 4100                     M 	dc.w	c
00003902 =00004180                M c	=	c+$80
00003902 4180                     M 	dc.w	c
00003904 =00004200                M c	=	c+$80
00003904 4200                     M 	dc.w	c
00003906 =00004280                M c	=	c+$80
00003906 4280                     M 	dc.w	c
00003908 =00004300                M c	=	c+$80
00003908 4300                     M 	dc.w	c
0000390A =00004380                M c	=	c+$80
0000390A 4380                     M 	dc.w	c
0000390C =00004400                M c	=	c+$80
0000390C 4400                     M 	dc.w	c
0000390E =00004480                M c	=	c+$80
0000390E 4480                     M 	dc.w	c
00003910 =00004500                M c	=	c+$80
00003910 4500                     M 	dc.w	c
00003912 =00004580                M c	=	c+$80
00003912 4580                     M 	dc.w	c
00003914 =00004600                M c	=	c+$80
00003914 4600                     M 	dc.w	c
00003916 =00004680                M c	=	c+$80
00003916 4680                     M 	dc.w	c
00003918 =00004700                M c	=	c+$80
00003918 4700                     M 	dc.w	c
0000391A =00004780                M c	=	c+$80
0000391A 4780                     M 	dc.w	c
0000391C =00004800                M c	=	c+$80
0000391C 4800                     M 	dc.w	c
0000391E =00004880                M c	=	c+$80
0000391E 4880                     M 	dc.w	c
00003920 =00004900                M c	=	c+$80
00003920 4900                     M 	dc.w	c
00003922 =00004980                M c	=	c+$80
00003922 4980                     M 	dc.w	c
00003924 =00004A00                M c	=	c+$80
00003924 4A00                     M 	dc.w	c
00003926 =00004A80                M c	=	c+$80
00003926 4A80                     M 	dc.w	c
00003928 =00004B00                M c	=	c+$80
00003928 4B00                     M 	dc.w	c
0000392A =00004B80                M c	=	c+$80
0000392A 4B80                     M 	dc.w	c
0000392C =00004C00                M c	=	c+$80
0000392C 4C00                     M 	dc.w	c
0000392E =00004C80                M c	=	c+$80
0000392E 4C80                     M 	dc.w	c
00003930 =00004D00                M c	=	c+$80
00003930 4D00                     M 	dc.w	c
00003932 =00004D80                M c	=	c+$80
00003932 4D80                     M 	dc.w	c
00003934 =00004E00                M c	=	c+$80
00003934 4E00                     M 	dc.w	c
00003936 =00004E80                M c	=	c+$80
00003936 4E80                     M 	dc.w	c
00003938 =00004F00                M c	=	c+$80
00003938 4F00                     M 	dc.w	c
0000393A =00004F80                M c	=	c+$80
0000393A 4F80                     M 	dc.w	c
0000393C =00005000                M c	=	c+$80
0000393C 5000                     M 	dc.w	c
0000393E =00005080                M c	=	c+$80
0000393E 5080                     M 	dc.w	c
00003940 =00005100                M c	=	c+$80
00003940 5100                     M 	dc.w	c
00003942 =00005180                M c	=	c+$80
00003942 5180                     M 	dc.w	c
00003944 =00005200                M c	=	c+$80
00003944 5200                     M 	dc.w	c
00003946 =00005280                M c	=	c+$80
00003946 5280                     M 	dc.w	c
00003948 =00005300                M c	=	c+$80
00003948 5300                     M 	dc.w	c
0000394A =00005380                M c	=	c+$80
0000394A 5380                     M 	dc.w	c
0000394C =00005400                M c	=	c+$80
0000394C 5400                     M 	dc.w	c
0000394E =00005480                M c	=	c+$80
0000394E 5480                     M 	dc.w	c
00003950 =00005500                M c	=	c+$80
00003950 5500                     M 	dc.w	c
00003952 =00005580                M c	=	c+$80
00003952 5580                     M 	dc.w	c
00003954 =00005600                M c	=	c+$80
00003954 5600                     M 	dc.w	c
00003956 =00005680                M c	=	c+$80
00003956 5680                     M 	dc.w	c
00003958 =00005700                M c	=	c+$80
00003958 5700                     M 	dc.w	c
0000395A =00005780                M c	=	c+$80
0000395A 5780                     M 	dc.w	c
0000395C =00005800                M c	=	c+$80
0000395C 5800                     M 	dc.w	c
0000395E =00005880                M c	=	c+$80
0000395E 5880                     M 	dc.w	c
00003960 =00005900                M c	=	c+$80
00003960 5900                     M 	dc.w	c
00003962 =00005980                M c	=	c+$80
00003962 5980                     M 	dc.w	c
00003964 =00005A00                M c	=	c+$80
00003964 5A00                     M 	dc.w	c
00003966 =00005A80                M c	=	c+$80
00003966 5A80                     M 	dc.w	c
00003968 =00005B00                M c	=	c+$80
00003968 5B00                     M 	dc.w	c
0000396A =00005B80                M c	=	c+$80
0000396A 5B80                     M 	dc.w	c
0000396C =00005C00                M c	=	c+$80
0000396C 5C00                     M 	dc.w	c
0000396E =00005C80                M c	=	c+$80
0000396E 5C80                     M 	dc.w	c
00003970 =00005D00                M c	=	c+$80
00003970 5D00                     M 	dc.w	c
00003972 =00005D80                M c	=	c+$80
00003972 5D80                     M 	dc.w	c
00003974 =00005E00                M c	=	c+$80
00003974 5E00                     M 	dc.w	c
00003976 =00005E80                M c	=	c+$80
00003976 5E80                     M 	dc.w	c
00003978 =00005F00                M c	=	c+$80
00003978 5F00                     M 	dc.w	c
0000397A =00005F80                M c	=	c+$80
0000397A 5F80                     M 	dc.w	c
0000397C =00006000                M c	=	c+$80
0000397C 6000                     M 	dc.w	c
0000397E =00006080                M c	=	c+$80
0000397E 6080                     M 	dc.w	c
00003980 =00006100                M c	=	c+$80
00003980 6100                     M 	dc.w	c
00003982 =00006180                M c	=	c+$80
00003982 6180                     M 	dc.w	c
00003984 =00006200                M c	=	c+$80
00003984 6200                     M 	dc.w	c
00003986 =00006280                M c	=	c+$80
00003986 6280                     M 	dc.w	c
00003988 =00006300                M c	=	c+$80
00003988 6300                     M 	dc.w	c
0000398A =00006380                M c	=	c+$80
0000398A 6380                     M 	dc.w	c
0000398C =00006400                M c	=	c+$80
0000398C 6400                     M 	dc.w	c
0000398E =00006480                M c	=	c+$80
0000398E 6480                     M 	dc.w	c
00003990 =00006500                M c	=	c+$80
00003990 6500                     M 	dc.w	c
00003992 =00006580                M c	=	c+$80
00003992 6580                     M 	dc.w	c
00003994 =00006600                M c	=	c+$80
00003994 6600                     M 	dc.w	c
00003996 =00006680                M c	=	c+$80
00003996 6680                     M 	dc.w	c
00003998 =00006700                M c	=	c+$80
00003998 6700                     M 	dc.w	c
0000399A =00006780                M c	=	c+$80
0000399A 6780                     M 	dc.w	c
0000399C =00006800                M c	=	c+$80
0000399C 6800                     M 	dc.w	c
0000399E =00006880                M c	=	c+$80
0000399E 6880                     M 	dc.w	c
000039A0 =00006900                M c	=	c+$80
000039A0 6900                     M 	dc.w	c
000039A2 =00006980                M c	=	c+$80
000039A2 6980                     M 	dc.w	c
000039A4 =00006A00                M c	=	c+$80
000039A4 6A00                     M 	dc.w	c
000039A6 =00006A80                M c	=	c+$80
000039A6 6A80                     M 	dc.w	c
000039A8 =00006B00                M c	=	c+$80
000039A8 6B00                     M 	dc.w	c
000039AA =00006B80                M c	=	c+$80
000039AA 6B80                     M 	dc.w	c
000039AC =00006C00                M c	=	c+$80
000039AC 6C00                     M 	dc.w	c
000039AE =00006C80                M c	=	c+$80
000039AE 6C80                     M 	dc.w	c
000039B0 =00006D00                M c	=	c+$80
000039B0 6D00                     M 	dc.w	c
000039B2 =00006D80                M c	=	c+$80
000039B2 6D80                     M 	dc.w	c
000039B4 =00006E00                M c	=	c+$80
000039B4 6E00                     M 	dc.w	c
000039B6 =00006E80                M c	=	c+$80
000039B6 6E80                     M 	dc.w	c
000039B8 =00006F00                M c	=	c+$80
000039B8 6F00                     M 	dc.w	c
000039BA =00006F80                M c	=	c+$80
000039BA 6F80                     M 	dc.w	c
000039BC =00007000                M c	=	c+$80
000039BC 7000                     M 	dc.w	c
000039BE =00007080                M c	=	c+$80
000039BE 7080                     M 	dc.w	c
000039C0 =00007100                M c	=	c+$80
000039C0 7100                     M 	dc.w	c
000039C2 =00007180                M c	=	c+$80
000039C2 7180                     M 	dc.w	c
000039C4 =00007200                M c	=	c+$80
000039C4 7200                     M 	dc.w	c
000039C6 =00007280                M c	=	c+$80
000039C6 7280                     M 	dc.w	c
000039C8 =00007300                M c	=	c+$80
000039C8 7300                     M 	dc.w	c
000039CA =00007380                M c	=	c+$80
000039CA 7380                     M 	dc.w	c
000039CC =00007400                M c	=	c+$80
000039CC 7400                     M 	dc.w	c
000039CE =00007480                M c	=	c+$80
000039CE 7480                     M 	dc.w	c
000039D0 =00007500                M c	=	c+$80
000039D0 7500                     M 	dc.w	c
000039D2 =00007580                M c	=	c+$80
000039D2 7580                     M 	dc.w	c
000039D4 =00007600                M c	=	c+$80
000039D4 7600                     M 	dc.w	c
000039D6 =00007680                M c	=	c+$80
000039D6 7680                     M 	dc.w	c
000039D8 =00007700                M c	=	c+$80
000039D8 7700                     M 	dc.w	c
000039DA =00007780                M c	=	c+$80
000039DA 7780                     M 	dc.w	c
000039DC =00007800                M c	=	c+$80
000039DC 7800                     M 	dc.w	c
000039DE =00007880                M c	=	c+$80
000039DE 7880                     M 	dc.w	c
000039E0 =00007900                M c	=	c+$80
000039E0 7900                     M 	dc.w	c
000039E2 =00007980                M c	=	c+$80
000039E2 7980                     M 	dc.w	c
000039E4 =00007A00                M c	=	c+$80
000039E4 7A00                     M 	dc.w	c
000039E6 =00007A80                M c	=	c+$80
000039E6 7A80                     M 	dc.w	c
000039E8 =00007B00                M c	=	c+$80
000039E8 7B00                     M 	dc.w	c
000039EA =00007B80                M c	=	c+$80
000039EA 7B80                     M 	dc.w	c
000039EC =00007C00                M c	=	c+$80
000039EC 7C00                     M 	dc.w	c
000039EE =00007C80                M c	=	c+$80
000039EE 7C80                     M 	dc.w	c
000039F0 =00007D00                M c	=	c+$80
000039F0 7D00                     M 	dc.w	c
000039F2 =00007D80                M c	=	c+$80
000039F2 7D80                     M 	dc.w	c
000039F4 =00007E00                M c	=	c+$80
000039F4 7E00                     M 	dc.w	c
000039F6 =00007E80                M c	=	c+$80
000039F6 7E80                     M 	dc.w	c
000039F8 =00007F00                M c	=	c+$80
000039F8 7F00                     M 	dc.w	c
000039FA =00007F80                M c	=	c+$80
000039FA 7F80                     M 	dc.w	c
000039FC =00008000                M c	=	c+$80
000039FC                            ; =========================================================================================================================================================
000039FC                            		include	"Level/Level Functions.asm"
000039FC                            ; =========================================================================================================================================================
000039FC                            ; Mighty The Armadillo in PRISM PARADISE
000039FC                            ; By Nat The Porcupine 2021
000039FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039FC                            ; General level functions
000039FC                            ; =========================================================================================================================================================
000039FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039FC                            ; Load level data
000039FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039FC                            Level_LoadData:
000039FC                            		; --- Initialize the start position and camera ---
000039FC                            
000039FC 47F9 0000 0000             		lea	Level_SizeStartPos,a3		; Get size and start position data
00003A02 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003A06 E218                       		ror.b	#1,d0				; Turn into offset
00003A08 E848                       		lsr.w	#4,d0				; ''
00003A0A 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003A0E                            
00003A0E 42B8 F8C4                  		clr.l	rDestMinCam.w		; Set target minimum camera values
00003A12 42B8 F8C8                  		clr.l	rMinCam.w			; Set minimum camera values
00003A16 21D3 F8BC                  		move.l	(a3),rDestMaxCam.w		; Set target maximum camera values
00003A1A 21DB F8C0                  		move.l	(a3)+,rMaxCam.w		; Set maximum camera values
00003A1E                            
00003A1E 31FC 0060 F8CC             		move.w	#(224/2)-16,rCamYPosDist.w	; Set camera Y distance
00003A24                            
00003A24 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Player object
00003A28 321B                       		move.w	(a3)+,d1			; Get starting X position
00003A2A 3141 0014                  		move.w	d1,oXPos(a0)			; Set the player's X position
00003A2E 3013                       		move.w	(a3),d0				; Get starting Y position
00003A30 3140 0018                  		move.w	d0,oYPos(a0)			; Set the player's Y position
00003A34                            
00003A34 4A38 C7B9                  		tst.b	rStartFall.w			; Should we start the level by falling?
00003A38 6700                       		beq.s	.InitCam			; If not, branch
00003A3A 08E8 0002 000C             		bset	#2,oFlags(a0)
00003A40 7272                       		moveq	#$72,d1				; Reset Sonic's X position
00003A42 3141 0014                  		move.w	d1,oXPos(a0)			; ''
00003A46 70E0                       		moveq	#-32,d0				; Reset Sonic's Y position
00003A48 3140 0018                  		move.w	d0,oYPos(a0)			; ''
00003A4C                            
00003A4C                            .InitCam:
00003A4C 4A38 C7AE                  		tst.b	rLastChkpoint.w		; Has a checkpoint been hit?
00003A50 6700                       		beq.s	.SetCam				; If not, branch
00003A52 6100 0000                  		bsr.w	Level_LoadSavedInfo		; Load data
00003A56 3228 0014                  		move.w	oXPos(a0),d1			; Get X position
00003A5A 3028 0018                  		move.w	oYPos(a0),d0			; Get Y position
00003A5E                            
00003A5E                            .SetCam:
00003A5E 0441 00A0                  		subi.w	#320/2,d1			; Get camera's X position
00003A62 6C00                       		bge.s	.ChkMaxX			; If it doesn't go beyond the left boundary, branch
00003A64 7200                       		moveq	#0,d1				; Cap it
00003A66                            
00003A66                            .ChkMaxX:
00003A66 3438 F8C0                  		move.w	rMaxCamX.w,d2		; Get max camera X position
00003A6A B242                       		cmp.w	d2,d1				; Have we gone beyond it?
00003A6C 6500                       		bcs.s	.SetCamX			; If not, branch
00003A6E 3202                       		move.w	d2,d1				; Cap it
00003A70                            
00003A70                            .SetCamX:	
00003A70 31C1 F880                  		move.w	d1,rCamXPos.w			; Set the camera's X position
00003A74                            
00003A74 0440 0060                  		subi.w	#(224/2)-16,d0			; Get camera's Y position
00003A78 6C00                       		bge.s	.ChkMaxY			; If it doesn't go beyond the upper boundary, branch
00003A7A 7000                       		moveq	#0,d0				; Cap it
00003A7C                            
00003A7C                            .ChkMaxY:
00003A7C 3438 F8C2                  		move.w	rMaxCamY.w,d2		; Get max camera Y position
00003A80 B042                       		cmp.w	d2,d0				; Have we gone beyond it?
00003A82 6D00                       		blt.s	.SetCamY			; If not, branch
00003A84 3002                       		move.w	d2,d0				; Cap it
00003A86                            
00003A86                            .SetCamY:	
00003A86 31C0 F888                  		move.w	d0,rCamYPos.w			; Set the camera's Y position
00003A8A                            
00003A8A                            		; --- Load level data ---
00003A8A                            
00003A8A 47F9 0000 0000             		lea	Level_DataPointers,a3		; Level data pointers
00003A90 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003A94 E218                       		ror.b	#1,d0				; Turn into offset
00003A96 E448                       		lsr.w	#2,d0				; ''
00003A98 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003A9C                            
00003A9C 205B                       		movea.l	(a3)+,a0			; Get chunk data pointer
00003A9E 43F9 00FF 0000             		lea	rChunks,a1			; Decompress into chunk table
00003AA4 4EB8 0A9A                  		jsr	KosDec.w			; ''
00003AA8                            
00003AA8 205B                       		movea.l	(a3)+,a0			; Get block data pointer
00003AAA 43F8 C7D0                  		lea	rBlocks.w,a1			; Decompress into block table
00003AAE 4EB8 0A9A                  		jsr	KosDec.w			; ''
00003AB2                            
00003AB2 225B                       		movea.l	(a3)+,a1			; Get tile data pointer
00003AB4 7400                       		moveq	#0,d2				; Store in the beginning of VRAM
00003AB6 4EB8 0EF0                  		jsr	QueueKosMData.w			; Queue for decompression
00003ABA                            
00003ABA 205B                       		movea.l	(a3)+,a0			; Get palette data pointer
00003ABC 3018                       		move.w	(a0)+,d0			; Size of palette data
00003ABE 4EB8 04BE                  		jsr	LoadTargetPal.w			; Load the palette
00003AC2                            
00003AC2 205B                       		movea.l	(a3)+,a0			; Get layout pointer
00003AC4 43F8 DFD0                  		lea	rLayout.w,a1			; Decompress into layout buffer
00003AC8 4EB8 0A9A                  		jsr	KosDec.w			; ''
00003ACC                            
00003ACC 21DB C7B4                  		move.l	(a3)+,rObjPosAddr.w		; Set object position data pointer
00003AD0 21DB F85E                  		move.l	(a3)+,rRingPosAddr.w		; Set ring position data pointer
00003AD4 265B                       		movea.l	(a3)+,a3			; Get collision data pointers
00003AD6 201B                       		move.l	(a3)+,d0			; Get collision data address
00003AD8 21C0 F8E0                  		move.l	d0,rColAddr.w			; Set collision address to primary
00003ADC 21C0 F8D8                  		move.l	d0,r1stCol.w			; Set primary collision data pointer
00003AE0 5280                       		addq.l	#1,d0				; Increment address for secondary collision
00003AE2 21C0 F8DC                  		move.l	d0,r2ndCol.w			; Set secondary collision data pointer
00003AE6 43F8 F8E6                  		lea	rAngleVals.w,a1		; Collision pointers
00003AEA 22DB                       		move.l	(a3)+,(a1)+			; Set angle value array pointer
00003AEC 22DB                       		move.l	(a3)+,(a1)+			; Set normal hiehgt map array pointer
00003AEE 229B                       		move.l	(a3)+,(a1)			; Set rotated hiehgt map array pointer
00003AF0                            
00003AF0 47F9 0000 0000             		lea	Level_PLCs,a3			; Get PLC list pointer
00003AF6 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003AFA E218                       		ror.b	#1,d0				; Turn into offset
00003AFC EA48                       		lsr.w	#5,d0				; ''
00003AFE 2673 0000                  		movea.l	(a3,d0.w),a3			; Get pointer to the correct pointers
00003B02 4EF8 0EE0                  		jmp	LoadKosMQueue.w			; Load the PLCs
00003B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B06                            ; Update the water surface
00003B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B06                            Level_UpdateWaterSurface:
00003B06 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003B0A 6700                       		beq.s	.End				; If not, branch
00003B0C 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera X position
00003B10 0838 0000 F8FB             		btst	#0,(rLvlFrames+1).w		; Are we on an odd frame?
00003B16 6700                       		beq.s	.SetXPos			; If not, branch
00003B18 0641 0020                  		addi.w	#$20,d1				; Shift X position
00003B1C                            
00003B1C                            .SetXPos:
00003B1C 3001                       		move.w	d1,d0				; Copy X postion
00003B1E 0640 0060                  		addi.w	#$60,d0				; Add surface #1's X position
00003B22 3078 F87C                  		movea.w	rWater1Addr.w,a0
00003B26 3140 0014                  		move.w	d0,oXPos(a0)			; Set it
00003B2A 0641 0120                  		addi.w	#$120,d1			; Add surface #2's X position
00003B2E 3078 F87E                  		movea.w	rWater2Addr.w,a0
00003B32 3141 0014                  		move.w	d1,oXPos(a0)			; Set it
00003B36                            
00003B36                            .End:
00003B36 4E75                       		rts
00003B38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B38                            ; Handle water height
00003B38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B38                            Level_WaterHeight:
00003B38 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003B3C 6700                       		beq.s	.End				; If not, branch
00003B3E 6100 0000                  		bsr.w	Level_MoveWater			; Move the water when appropriate
00003B42 4238 F8F5                  		clr.b	rWaterFullscr.w		; Clear water fullscreen flag
00003B46                            
00003B46 7201                       		moveq	#1,d1				; Water movement speed
00003B48 3038 F8F8                  		move.w	rDestWtrLvl.w,d0		; Get destination water level
00003B4C 9078 F8F6                  		sub.w	rWaterLvl.w,d0		; Is the current water level at that destination?
00003B50 6700                       		beq.s	.ChkOnScr			; If so, branch
00003B52 6400                       		bcc.s	.MoveDown			; If it needs to go down, branch
00003B54 4441                       		neg.w	d1				; Go up
00003B56                            
00003B56                            .MoveDown:
00003B56 D378 F8F6                  		add.w	d1,rWaterLvl.w		; Move water
00003B5A                            
00003B5A                            .ChkOnScr:
00003B5A 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
00003B5E 9078 F888                  		sub.w	rCamYPos.w,d0			; Get camera's Y position
00003B62 6700                       		beq.s	.Fullscreen			; If they are the same, branch
00003B64 6400                       		bcc.s	.ChkBottom			; If the water height is below the top of the camera, branch
00003B66                            		
00003B66                            .Fullscreen:
00003B66 50F8 F8F5                  		st	rWaterFullscr.w		; Set water fullscreen flag
00003B6A 50F8 C75F                  		st	rHIntCnt.w			; Set H-INT counter to be offscreen
00003B6E 4E75                       		rts
00003B70                            
00003B70                            .ChkBottom:
00003B70 0C40 00DF                  		cmpi.w	#224-1,d0			; Is the water below the camera?
00003B74 6500                       		blo.s	.SetCounter			; If not, branch
00003B76 70FF                       		moveq	#-1,d0				; Set H-INT counter to be offscreen
00003B78                            
00003B78                            .SetCounter:
00003B78 11C0 C75F                  		move.b	d0,rHIntCnt.w			; Set H-INT counter
00003B7C                            
00003B7C                            .End:
00003B7C 4E75                       		rts
00003B7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B7E                            Level_MoveWater:
00003B7E 4E75                       		rts
00003B80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B80                            ; Do level palette cycling
00003B80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B80                            Level_PalCycle:
00003B80 41F9 0000 0000             		lea	Level_PalCycRouts,a0		; Palette cycle routines
00003B86 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B8A E218                       		ror.b	#1,d0				; Turn into offset
00003B8C EA48                       		lsr.w	#5,d0				; ''
00003B8E 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003B92 4ED0                       		jmp	(a0)				; Jump to it
00003B94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B94                            ; Do level art animation
00003B94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B94                            Level_AnimateArt:
00003B94 41F9 0000 0000             		lea	Level_AniArtRouts,a0		; Animated art routines
00003B9A 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B9E E218                       		ror.b	#1,d0				; Turn into offset
00003BA0 EA48                       		lsr.w	#5,d0				; ''
00003BA2 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003BA6 4ED0                       		jmp	(a0)				; Jump to it
00003BA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BA8                            ; Do dynamic events
00003BA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BA8                            Level_DynEvents:
00003BA8 41F9 0000 0000             		lea	Level_DynEvenRouts,a0		; Dynamic events routines
00003BAE 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003BB2 E218                       		ror.b	#1,d0				; Turn into offset
00003BB4 EA48                       		lsr.w	#5,d0				; ''
00003BB6 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003BBA 4ED0                       		jmp	(a0)				; Jump to it
00003BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BBC                            ; Handle the camera
00003BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BBC                            Level_HandleCamera:
00003BBC 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Get player object
00003BC0                            		
00003BC0 4A38 F8CE                  		tst.b	rCamLockX.w			; Is the camera locked horizontally?
00003BC4 6600                       		bne.s	.ChkY				; If so, branch
00003BC6 43F8 F880                  		lea	rCamXPos.w,a1			; Get foreground level variables
00003BCA 6100                       		bsr.s	Level_MoveCameraX		; Move the camera horiozntally
00003BCC                            		
00003BCC                            .ChkY:
00003BCC 4A38 F8CF                  		tst.b	rCamLockY.w			; Is the camera locked vertically?
00003BD0 6600                       		bne.s	.ChkMaxY			; If not, branch
00003BD2 43F8 F888                  		lea	rCamYPos.w,a1			; Get foreground level variables
00003BD6 3638 F8CC                  		move.w	rCamYPosDist.w,d3		; Get camera Y distance
00003BDA 6100 0000                  		bsr.w	Level_MoveCameraY		; Move the camera vertically
00003BDE                            
00003BDE                            .ChkMaxY:
00003BDE 7202                       		moveq	#2,d1				; Target camera scroll speed
00003BE0 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get distance between target and actual target max camera Y position
00003BE4 9078 F8C2                  		sub.w	rMaxCamY.w,d0		; ''
00003BE8 6700                       		beq.s	.End				; If it's 0, branch
00003BEA 6400                       		bcc.s	.MoveDown			; If it's positive, branch
00003BEC 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003BF0 B078 F8BE                  		cmp.w	rDestMaxY.w,d0		; Is it past the boundary?
00003BF4 6300                       		bls.s	.ScrollUp			; If not, branch
00003BF6 31C0 F8C2                  		move.w	d0,rMaxCamY.w		; Set max camera Y position
00003BFA 0278 FFFE F8C2             		andi.w	#$FFFE,rMaxCamY.w		; Keep it a multiple of 2
00003C00                            
00003C00                            .ScrollUp:
00003C00 9378 F8C2                  		sub.w	d1,rMaxCamY.w		; Scroll up
00003C04 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003C08                            
00003C08                            
00003C08                            .End:
00003C08 4E75                       		rts
00003C0A                            
00003C0A                            .MoveDown:
00003C0A 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003C0E 5040                       		addq.w	#8,d0				; ''
00003C10 B078 F8C2                  		cmp.w	rMaxCamY.w,d0		; Is it past the boundary?
00003C14 6500                       		bcs.s	.ScrollDown			; If not, branch
00003C16 0828 0001 0028             		btst	#1,oStatus(a0)		; Is the player in the air?
00003C1C 6700                       		beq.s	.ScrollDown			; If not, branch
00003C1E D241                       		add.w	d1,d1				; Scroll down faster
00003C20 D241                       		add.w	d1,d1				; ''
00003C22                            
00003C22                            .ScrollDown:
00003C22 D378 F8C2                  		add.w	d1,rMaxCamY.w		; Scroll down
00003C26 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003C2A 4E75                       		rts
00003C2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C2C                            Level_MoveCameraX:
00003C2C 3028 0014                  		move.w	oXPos(a0),d0			; Get the player's X position
00003C30 9051                       		sub.w	(a1),d0				; Get distance from the camera's X position
00003C32 9078 F8D2                  		sub.w	rCamXPosCenter.w,d0		; Subtract center
00003C36 6D00                       		blt.s	.MoveLeft			; If we are going left, branch
00003C38 6C00                       		bge.s	.MoveRight			; If we are going right, branch
00003C3A 4E75                       		rts
00003C3C                            
00003C3C                            .MoveLeft:
00003C3C 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the camera moving more than 16 pixels per frame?
00003C40 6E00                       		bgt.s	.ChkLeftBound			; If not, branch
00003C42 303C FFF0                  		move.w	#-16,d0				; Keep the camera from moving too fast
00003C46                            
00003C46                            .ChkLeftBound:
00003C46 D051                       		add.w	(a1),d0				; Add back the camera's X position
00003C48 B078 F8C8                  		cmp.w	rMinCamX.w,d0		; Have we gone past the left boundary?
00003C4C 6E00                       		bgt.s	.SetCamX			; If not, branch
00003C4E 3038 F8C8                  		move.w	rMinCamX.w,d0		; Cap at the left boundary
00003C52 6000                       		bra.s	.SetCamX			; Continue
00003C54                            
00003C54                            .MoveRight:
00003C54 0C40 0010                  		cmpi.w	#16,d0				; Is the camera moving more than 16 pixels per frame?
00003C58 6500                       		blo.s	.ChkRightBound			; If not, branch
00003C5A 303C 0010                  		move.w	#16,d0				; Keep the camera from moving too fast
00003C5E                            
00003C5E                            .ChkRightBound:
00003C5E D051                       		add.w	(a1),d0				; Add back the camera's X position
00003C60 B078 F8C0                  		cmp.w	rMaxCamX.w,d0		; Has the camera gone beyond the right boundary?
00003C64 6D00                       		blt.s	.SetCamX			; If not, branch
00003C66 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Cap at the right boundary
00003C6A                            
00003C6A                            .SetCamX:
00003C6A 3280                       		move.w	d0,(a1)				; Set the new camera X position
00003C6C 4E75                       		rts
00003C6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C6E                            Level_MoveCameraY:
00003C6E 7200                       		moveq	#0,d1
00003C70 3028 0018                  		move.w	oYPos(a0),d0			; Get the player's Y position
00003C74 9051                       		sub.w	(a1),d0				; Get distance from the camera's Y position
00003C76                            
00003C76 0828 0002 0028             		btst	#2,oStatus(a0)			; Is the player rolling?
00003C7C 6700                       		beq.s	.NoRoll				; If not, branch
00003C7E 5B40                       		subq.w	#5,d0				; Move up some
00003C80                            
00003C80                            .NoRoll:
00003C80 0828 0001 0028             		btst	#1,oStatus(a0)			; Is the player in the air?
00003C86 6700                       		beq.s	.ChkBoundCross_Ground		; If not, branch
00003C88                            
00003C88                            .ChkBoundCross_Air:
00003C88 0640 0020                  		addi.w	#$20,d0				; You have 32 pixels above and below to move without disturbing the camera
00003C8C 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003C8E 6500                       		bcs.s	.ScrollFast			; If the player is above the boundary, branch
00003C90 0440 0040                  		subi.w	#$40,d0				; Subtract 64
00003C94 6400                       		bcc.s	.ScrollFast			; If the player is below the boundary, branch
00003C96                            
00003C96 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003C9A 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003C9C 6000                       		bra.s	.NoScroll			; Continue
00003C9E                            
00003C9E                            .ChkBoundCross_Ground:
00003C9E 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003CA0 6600                       		bne.s	.DecideScrollType		; If the player moved, branch
00003CA2 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003CA6 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003CA8                            
00003CA8                            .NoScroll:
00003CA8 4E75                       		rts		
00003CAA                            
00003CAA                            .DecideScrollType:
00003CAA 0C43 0060                  		cmpi.w	#(224/2)-16,d3			; Is the camera Y distance normal?
00003CAE 6600                       		bne.s	.ScrollSlow			; If not, branch
00003CB0                            
00003CB0 3228 0000                  		move.w	oGVel(a0),d1			; Get the players' ground velocity
00003CB4 6A00                       		bpl.s	.Positive			; If it's positive, branch
00003CB6 4441                       		neg.w	d1				; Force it to be positive
00003CB8                            
00003CB8                            .Positive:
00003CB8 0C41 0800                  		cmpi.w	#$800,d1			; Is the player travelling very fast?
00003CBC 6400                       		bhs.s	.ScrollFast			; If so, branch
00003CBE                            
00003CBE                            .ScrollMedium:
00003CBE 323C 0600                  		move.w	#6<<8,d1			; Cap camera movement at 6 if going too fast
00003CC2 0C40 0006                  		cmpi.w	#6,d0				; Is the player going down too fast?
00003CC6 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003CC8 0C40 FFFA                  		cmpi.w	#-6,d0				; Is the player going up too fast?
00003CCC 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003CCE 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003CD0                            
00003CD0                            .ScrollSlow:
00003CD0 323C 0200                  		move.w	#2<<8,d1			; Cap camera movement at 2 if going too fast
00003CD4 0C40 0002                  		cmpi.w	#2,d0				; Is the player going down too fast?
00003CD8 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003CDA 0C40 FFFE                  		cmpi.w	#-2,d0				; Is the player going up too fast?
00003CDE 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003CE0 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003CE2                            
00003CE2                            .ScrollFast:
00003CE2 323C 1000                  		move.w	#16<<8,d1			; Cap camera movement at 16 if going too fast
00003CE6 0C40 0010                  		cmpi.w	#16,d0				; Is the player going down too fast?
00003CEA 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003CEC 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the player going up too fast?
00003CF0 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003CF2 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003CF4                            
00003CF4                            .ScrollMaxYChange:
00003CF4 7000                       		moveq	#0,d0				; Distance for the camera to move = 0
00003CF6 11C0 F8D0                  		move.b	d0,rCamMaxChg.w		; Clear the max Y boundary changing flag
00003CFA                            		
00003CFA                            .ScrollUpOrDown:
00003CFA 7200                       		moveq	#0,d1
00003CFC 3200                       		move.w	d0,d1				; Get position difference
00003CFE D251                       		add.w	(a1),d1				; Add old camera Y position
00003D00 4A40                       		tst.w	d0				; Is the camera to scroll down?
00003D02 6A00                       		bpl.s	.ScrollDown			; If so, branch
00003D04 6000 0000                  		bra.w	.ScrollUp			; Scroll up
00003D08                            
00003D08                            .ScrollUpMax:
00003D08 4441                       		neg.w	d1				; Make the value negative, since we are going up
00003D0A 48C1                       		ext.l	d1
00003D0C E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003D0E D291                       		add.l	(a1),d1				; Add the camera's Y position
00003D10 4841                       		swap	d1				; Get the actual Y position
00003D12                            
00003D12                            .ScrollUp:
00003D12 B278 F8CA                  		cmp.w	rMinCamY.w,d1		; Has the camera gone beyond the upper boundary?
00003D16 6E00                       		bgt.s	.DoScroll			; If not, branch
00003D18 3238 F8CA                  		move.w	rMinCamY.w,d1		; Cap at upper boundary
00003D1C 6000                       		bra.s	.DoScroll			; Continue
00003D1E                            
00003D1E                            .ScrollDownMax:
00003D1E 48C1                       		ext.l	d1
00003D20 E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003D22 D291                       		add.l	(a1),d1				; Add the camera's Y position
00003D24 4841                       		swap	d1				; Get the actual Y position
00003D26                            
00003D26                            .ScrollDown:
00003D26 B278 F8C2                  		cmp.w	rMaxCamY.w,d1		; Has the camera gone beyond the lower boundary?
00003D2A 6D00                       		blt.s	.DoScroll			; If not, branch
00003D2C 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Cap at lower boundary
00003D30                            
00003D30                            .DoScroll:
00003D30 4841                       		swap	d1				; Put Y coordinate in the higher word
00003D32 2281                       		move.l	d1,(a1)				; Set Y position
00003D34 4E75                       		rts
00003D36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D36                            ; Level ring manager
00003D36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D36                            Level_RingsManager:
00003D36 7000                       		moveq	#0,d0
00003D38 1038 F3D6                  		move.b	rRingManRout.w,d0		; Get routine
00003D3C 303B 0000                  		move.w	.Routines(pc,d0.w),d0		; Get offset
00003D40 4EFB 0000                  		jmp	.Routines(pc,d0.w)		; Jump to the right routine
00003D44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D44                            .Routines:
00003D44 0000                       		dc.w	Level_RingsManagerInit-.Routines
00003D46 0000                       		dc.w	Level_RingsManagerMain-.Routines
00003D48                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D48                            ; Ring manager initialization
00003D48                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D48                            Level_RingsManagerInit:
00003D48 5438 F3D6                  		addq.b	#2,rRingManRout.w		; The next time the manager is run, only go to the main routine
00003D4C                            		
00003D4C 6100 0000                  		bsr.w	Level_RingsManagerSetup	; Prepare the tables and load the ring data
00003D50                            
00003D50                            		; Set up the addresses to use in the current location of the level
00003D50                            
00003D50                            		; Start at the left side of the screen
00003D50                            		; We get the location of the first ring that shows up at the left side of the screen in the data and store that
00003D50                            
00003D50 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get current ring data address for the left side of the screen
00003D54 45F8 F3DE                  		lea	rRingStat.w,a2		; Ring status table
00003D58 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003D5C 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003D5E 6200                       		bhi.s	.CheckLeftSide			; Branch if not beyond 0
00003D60 7801                       		moveq	#1,d4				; Cap left side to 1
00003D62 6000                       		bra.s	.CheckLeftSide			; Start checking
00003D64                            
00003D64                            .NextLeftRing:
00003D64 5849                       		addq.w	#4,a1				; Next ring in ring data
00003D66 544A                       		addq.w	#2,a2				; Next ring in status table
00003D68                            
00003D68                            .CheckLeftSide:
00003D68 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003D6A 62F8                       		bhi.s	.NextLeftRing			; If not, get the next ring
00003D6C 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003D70 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003D74                            
00003D74                            		; Now the right side of the screen
00003D74                            		; We get the location of the first ring that goes beyond the right side of the screen in the data and store that
00003D74                            
00003D74 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003D78 6000                       		bra.s	.CheckRightSide			; Start checking
00003D7A                            
00003D7A                            .NextRightRing:
00003D7A 5849                       		addq.w	#4,a1				; Next ring in ring data
00003D7C                            
00003D7C                            .CheckRightSide:
00003D7C B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003D7E 62FA                       		bhi.s	.NextRightRing			; If not, get the next ring
00003D80 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003D84 4E75                       		rts
00003D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D86                            ; Ring manager main routine
00003D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003D86                            Level_RingsManagerMain:
00003D86 6100 0000                  		bsr.w	Level_RingsManagerDoCollect	; Handle ring collection
00003D8A                            
00003D8A 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get the current starting address for the ring data
00003D8E 3478 F86A                  		movea.w	rRingStatPtr.w,a2		; Get the current starting address for the status table
00003D92                            		
00003D92                            		; Get the new starting addresses for ring data
00003D92                            		; This is done by getting to a point from the current starting address where there's a ring onscreen
00003D92                            		; and then going back to get the very first ring that's on screen
00003D92                            
00003D92 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003D96 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003D98 6200                       		bhi.s	.CheckNewLeftSide		; Branch if not beyond 0
00003D9A 7801                       		moveq	#1,d4				; Cap left side to 1
00003D9C 6000                       		bra.s	.CheckNewLeftSide		; Start checking
00003D9E                            
00003D9E                            .NextNewLeftRing:
00003D9E 5849                       		addq.w	#4,a1				; Next ring in ring data
00003DA0 544A                       		addq.w	#2,a2				; Next ring in status table
00003DA2                            
00003DA2                            .CheckNewLeftSide:
00003DA2 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003DA4 62F8                       		bhi.s	.NextNewLeftRing		; If not, get the next ring
00003DA6 6000                       		bra.s	.CheckNewLeftSide2		; Start checking
00003DA8                            
00003DA8                            .NextNewLeftRing2:
00003DA8 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003DAA 554A                       		subq.w	#2,a2				; Previous ring in status table
00003DAC                            
00003DAC                            .CheckNewLeftSide2:
00003DAC B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the left boundary?
00003DB0 63F6                       		bls.s	.NextNewLeftRing2		; If not, get the next ring
00003DB2 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003DB6 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003DBA                            
00003DBA                            		; Now get the new ending addresses for ring data
00003DBA                            		; This is done by getting to a point from the current starting address where there's a ring at the right of the left boundary
00003DBA                            		; and then going back to get the very first ring that's on screen on the left side
00003DBA                            
00003DBA 2278 F866                  		movea.l	rRingLoadR.w,a1		; Get the current ending address for the ring data
00003DBE                            
00003DBE 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003DC2 6000                       		bra.s	.CheckNewRightSide		; Start checking
00003DC4                            
00003DC4                            .NextNewRightRing:
00003DC4 5849                       		addq.w	#4,a1				; Next ring in ring data
00003DC6                            
00003DC6                            .CheckNewRightSide:
00003DC6 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003DC8 62FA                       		bhi.s	.NextNewRightRing		; If not, get the next ring
00003DCA 6000                       		bra.s	.CheckNewRightSide2		; Start checking
00003DCC                            
00003DCC                            .NextNewRightRing2:
00003DCC 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003DCE                            
00003DCE                            .CheckNewRightSide2:
00003DCE B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the right boundary?
00003DD2 63F8                       		bls.s	.NextNewRightRing2		; If not, get the next ring
00003DD4 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003DD8 4E75                       		rts
00003DDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DDA                            ; Handle ring collection
00003DDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DDA                            Level_RingsManagerDoCollect:
00003DDA 45F8 F7DE                  		lea	rRingCol.w,a2			; Ring collection table
00003DDE 321A                       		move.w	(a2)+,d1			; Get consumed ring count
00003DE0 5341                       		subq.w	#1,d1				; Sutbract 1
00003DE2 6500                       		bcs.s	.End				; If there are no consumed rings to handle, branch
00003DE4                            
00003DE4                            .Loop:
00003DE4 301A                       		move.w	(a2)+,d0			; Get ring status address
00003DE6 67FC                       		beq.s	.Loop				; If 0, get the next ring
00003DE8 3240                       		movea.w	d0,a1				; Save in a1
00003DEA 5311                       		subq.b	#1,(a1)				; Decrement timer
00003DEC 6600                       		bne.s	.Next				; If nonzero, branch
00003DEE 12BC 0006                  		move.b	#6,(a1)				; Reset timer
00003DF2 5229 0001                  		addq.b	#1,1(a1)			; Increment frame
00003DF6                            							; Is it the last frame?
00003DF6 0C29 0000 0001             		cmpi.b	#(CMap_Ring_Sparkle_Last-CMap_Ring)/8,1(a1)
00003DFC 6600                       		bne.s	.Next				; If not, branch
00003DFE 32BC FFFF                  		move.w	#-1,(a1)			; Set timer and frame to -1
00003E02 426A FFFE                  		clr.w	-2(a2)				; Set address in collection table to 0
00003E06 5378 F7DE                  		subq.w	#1,rRingColCnt.w		; Decrement collection table count
00003E0A                            
00003E0A                            .Next:
00003E0A 51C9 FFD8                  		dbf	d1,.Loop			; Loop
00003E0E                            
00003E0E                            .End:
00003E0E 4E75                       		rts
00003E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E10                            ; Set up the tables and load ring data
00003E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E10                            Level_RingsManagerSetup:
00003E10                            		; Clear tables
00003E10                            		clrRAM	rRingStat
00003E10                          M 	local	endaddr
00003E10                          M endaddr	equs	"rringstat_End"
00003E10 7000                     M 	moveq	#0,d0
00003E12 43F8 F3DE                M 	lea	(rringstat).w,a1
00003E16 323C 00FF                M 	move.w	#(((rringstat_end)-(rringstat))-((rringstat)&1))>>2-1,d1
00003E1A 22C0                     M .clear_174:	move.l	d0,(a1)+
00003E1C 51C9 FFFC                M 	dbf	d1,.clear_174
00003E20                            		clrRAM	rRingCol
00003E20                          M 	local	endaddr
00003E20                          M endaddr	equs	"rringcol_End"
00003E20 7000                     M 	moveq	#0,d0
00003E22 43F8 F7DE                M 	lea	(rringcol).w,a1
00003E26 323C 001F                M 	move.w	#(((rringcol_end)-(rringcol))-((rringcol)&1))>>2-1,d1
00003E2A 22C0                     M .clear_175:	move.l	d0,(a1)+
00003E2C 51C9 FFFC                M 	dbf	d1,.clear_175
00003E30                            
00003E30 2278 F85E                  		movea.l	rRingPosAddr.w,a1		; Get ring data pointer
00003E34 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store address
00003E38 5849                       		addq.w	#4,a1				; Increment address by 4
00003E3A 7A00                       		moveq	#0,d5				; Initialize the ring counter
00003E3C 303C 01FE                  		move.w	#$1FE,d0			; Max number of ring
00003E40                            
00003E40                            .GetRingCount:
00003E40 4A99                       		tst.l	(a1)+				; Have all the ring been counted?
00003E42 6B00                       		bmi.s	.Exit				; If so, branch
00003E44 5245                       		addq.w	#1,d5				; Increment ring counter
00003E46 51C8 FFF8                  		dbf	d0,.GetRingCount		; Loop
00003E4A                            
00003E4A                            .Exit:
00003E4A 4E75                       		rts
00003E4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E4C                            ; Do ring collision for the player
00003E4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E4C                            PlayerRingCollision:
00003E4C 0C28 0069 0000             		cmpi.b	#105,oInvulTime(a0)		; Is the player able to collect rings while hurt?
00003E52 6400 0000                  		bhs.w	.End				; If it hasn't been long enough, branch
00003E56 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get starting address of ring data
00003E5A 2478 F866                  		movea.l	rRingLoadR.w,a2		; Get starting address of status table
00003E5E B5C9                       		cmpa.l	a1,a2				; Are there any rings to test collision with?
00003E60 6700 0000                  		beq.w	.End				; If not, branch
00003E64 3878 F86A                  		movea.w	rRingStatPtr.w,a4
00003E68 3428 0014                  		move.w	oXPos(a0),d2			; Player's X position
00003E6C 3628 0018                  		move.w	oYPos(a0),d3			; Player's Y position
00003E70 5142                       		subq.w	#8,d2				; Subtract 8 from X
00003E72 7A00                       		moveq	#0,d5
00003E74 1A28 002D                  		move.b	oColH(a0),d5			; Player's collision height
00003E78 5705                       		subq.b	#3,d5				; Subtract 3 from collision height
00003E7A 9645                       		sub.w	d5,d3				; Subtract from Y
00003E7C 323C 0006                  		move.w	#6,d1
00003E80 3C3C 000C                  		move.w	#$C,d6
00003E84 383C 0010                  		move.w	#$10,d4				; Width
00003E88 DA45                       		add.w	d5,d5				; Double the height
00003E8A                            
00003E8A                            .NextRing:
00003E8A 4A54                       		tst.w	(a4)				; Is the current ring already consumed?
00003E8C 6600                       		bne.s	.GetNext			; If so, get the next ring
00003E8E 3011                       		move.w	(a1),d0				; Get ring's X position
00003E90 9041                       		sub.w	d1,d0				; Subtract the player's X from the ring's X
00003E92 9042                       		sub.w	d2,d0				; Check collision
00003E94 6400                       		bcc.s	.ChkCol
00003E96 D046                       		add.w	d6,d0
00003E98 6500                       		bcs.s	.ChkCol2
00003E9A 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003E9E                            
00003E9E                            .ChkCol:
00003E9E B044                       		cmp.w	d4,d0				; Check collision
00003EA0 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003EA4                            
00003EA4                            .ChkCol2:
00003EA4 3029 0002                  		move.w	2(a1),d0			; Do Y collision check
00003EA8 9041                       		sub.w	d1,d0
00003EAA 9043                       		sub.w	d3,d0
00003EAC 6400                       		bcc.s	.ChkCol3
00003EAE D046                       		add.w	d6,d0
00003EB0 6500                       		bcs.s	.Collect
00003EB2 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003EB6                            
00003EB6                            .ChkCol3:
00003EB6 B045                       		cmp.w	d5,d0
00003EB8 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003EBC                            
00003EBC                            .Collect:
00003EBC                            							; Consume the ring
00003EBC 38BC 0000                  		move.w	#(6<<8)|((CMap_Ring_Sparkle-CMap_Ring)/8),(a4)
00003EC0 6100                       		bsr.s	CollectRing			; Collect it
00003EC2 47F8 F7E0                  		lea	rRingColList.w,a3		; Get collection list
00003EC6                            
00003EC6                            .Consume:
00003EC6 4A5B                       		tst.w	(a3)+				; Has this slot been used up?
00003EC8 66FC                       		bne.s	.Consume			; If not, get the next one
00003ECA 370C                       		move.w	a4,-(a3)			; Save the status table RAM address for the current ring
00003ECC 5278 F7DE                  		addq.w	#1,rRingColCnt.w		; Add to the number of rings consumed
00003ED0                            
00003ED0                            .GetNext:
00003ED0 5849                       		addq.w	#4,a1				; Next ring in ring data
00003ED2 544C                       		addq.w	#2,a4				; Next ring in status table
00003ED4 B5C9                       		cmpa.l	a1,a2				; Have we reached the end?
00003ED6 6600 FFB2                  		bne.w	.NextRing			; If not, loop
00003EDA                            
00003EDA                            .End:
00003EDA 4E75                       		rts
00003EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EDC                            ; Collect a ring
00003EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EDC                            CollectRing:
00003EDC 5278 F3D4                  		addq.w	#1,rRings.w			; Incremment ring count
00003EE0 50F8 F8F3                  		st	rUpdateRings.w			; Update ring counter in HUD
00003EE4                            		playSnd	#sRing, 2			; Play ring sound
00003EE4 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00003EEA 4E75                       		rts
00003EEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EEC                            ; Render the HUD
00003EEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003EEC                            Level_RenderHUDAndRings:
00003EEC 7C00                       		moveq	#0,d6				; Clear render flags
00003EEE 7802                       		moveq	#1*2,d4				; Standard frame
00003EF0 4A78 F3D4                  		tst.w	rRings.w			; Do we have 0 rings?
00003EF4 6600                       		bne.s	.Not0Rings			; If not, branch
00003EF6 0838 0003 F8FB             		btst	#3,(rLvlFrames+1).w		; Can the timer blink?
00003EFC 6600                       		bne.s	.Not0Rings			; If not, branch
00003EFE 7800                       		moveq	#0*2,d4				; Set frame to blink the timer
00003F00                            
00003F00                            .Not0Rings:
00003F00 3A3C 8680                  		move.w	#$8680,d5			; Tile properties
00003F04                            		
00003F04 303C 0090                  		move.w	#16+128,d0			; X position
00003F08 323C 0088                  		move.w	#8+128,d1			; Y position
00003F0C 43FA 0000                  		lea	Map_HUD(pc),a1			; Mappings
00003F10 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get address of frame
00003F14 3819                       		move.w	(a1)+,d4			; Get number of sprites in the frame
00003F16 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00003F18 4EB8 07D6                  		jsr	DrawSprite.w			; Draw the HUD frame
00003F1C                            
00003F1C                            .RenderRings:
00003F1C 2078 F862                  		movea.l	rRingLoadL.w,a0			; Get starting address of ring data
00003F20 2438 F866                  		move.l	rRingLoadR.w,d2			; Get ending address of ring data
00003F24 9488                       		sub.l	a0,d2				; Get length of the data to read
00003F26 6700                       		beq.s	.End				; If zero length, branch
00003F28 3878 F86A                  		movea.w	rRingStatPtr.w,a4		; Get starting address of status table
00003F2C 43FA 0000                  		lea	CMap_Ring(pc),a1		; Get mappings pointer
00003F30 3A3C 00F0                  		move.w	#224+16,d5			; Get bottom screen boundary
00003F34                            		
00003F34                            .Loop:
00003F34 4A5C                       		tst.w	(a4)+				; Is this ring collected?
00003F36 6B00                       		bmi.s	.Next				; If so, branch
00003F38 3228 0002                  		move.w	2(a0),d1			; Get Y position
00003F3C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract camera's Y position to get screen position
00003F40 5041                       		addq.w	#8,d1				; Add 8
00003F42 B245                       		cmp.w	d5,d1				; Is it below the bottom of the screen?
00003F44 6400                       		bhs.s	.Next				; If so, branch
00003F46 0641 0078                  		addi.w	#120,d1				; Add 120 to move it within screen space
00003F4A 3010                       		move.w	(a0),d0				; Get X position
00003F4C 9053                       		sub.w	cXPos(a3),d0			; Subtract camera's X position to get screen position
00003F4E 0640 0080                  		addi.w	#128,d0				; Add 128 to move it within screen space
00003F52 7C00                       		moveq	#0,d6
00003F54 1C2C FFFF                  		move.b	-1(a4),d6			; Get frame
00003F58                            
00003F58                            .Draw:
00003F58 E74E                       		lsl.w	#3,d6				; Turn frame ID into offset
00003F5A 45F1 6000                  		lea	(a1,d6.w),a2			; Get address of frame map data
00003F5E D25A                       		add.w	(a2)+,d1			; Add Y offset
00003F60 3CC1                       		move.w	d1,(a6)+			; Save Y position
00003F62 3C1A                       		move.w	(a2)+,d6			; Get sprite size
00003F64 1C86                       		move.b	d6,(a6)				; Save it
00003F66 544E                       		addq.w	#2,a6				; Skip link value
00003F68 3CDA                       		move.w	(a2)+,(a6)+			; Save base tile ID and properites
00003F6A D05A                       		add.w	(a2)+,d0			; Add X offset
00003F6C 3CC0                       		move.w	d0,(a6)+			; Save X position
00003F6E 5347                       		subq.w	#1,d7				; Decrement the number of sprites left available
00003F70                            
00003F70                            .Next:
00003F70 5848                       		addq.w	#4,a0				; Next ring in ring data
00003F72 5942                       		subq.w	#4,d2				; Decrement the ring count
00003F74 66BE                       		bne.s	.Loop				; If there are still rings to check, loop
00003F76                            
00003F76                            .End:
00003F76 4E75                       		rts
00003F78                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F78                            ; Custom mappings format.
00003F78                            ; Differences include...
00003F78                            ;	No offset table (each sprite assumed to be 8 bytes)
00003F78                            ;	No 'sprite pieces per frame' value (hardcoded to 1)
00003F78                            ;	Sign-extended Y-pos value
00003F78                            ;	Sign-extended sprite size value
00003F78                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F78                            CMap_Ring:
00003F78                            		; Main ring frame
00003F78 FFF8                       		dc.w	$FFF8
00003F7A 0005                       		dc.w	$0005
00003F7C 26BC                       		dc.w	$0000+$26BC
00003F7E FFF8                       		dc.w	$FFF8
00003F80                            
00003F80                            CMap_Ring_Sparkle:
00003F80                            		; Ring sparkle frame 1
00003F80 FFF8                       		dc.w	$FFF8
00003F82 0005                       		dc.w	$0005
00003F84 26B8                       		dc.w	$0000+$26B8
00003F86 FFF8                       		dc.w	$FFF8
00003F88                            		; Ring sparkle frame 2
00003F88 FFF8                       		dc.w	$FFF8
00003F8A 0005                       		dc.w	$0005
00003F8C 3EB8                       		dc.w	($0000+$26B8)|$1800
00003F8E FFF8                       		dc.w	$FFF8
00003F90                            		; Ring sparkle frame 3
00003F90 FFF8                       		dc.w	$FFF8
00003F92 0005                       		dc.w	$0005
00003F94 2EB8                       		dc.w	($0000+$26B8)|$800
00003F96 FFF8                       		dc.w	$FFF8
00003F98                            		; Ring sparkle frame 4
00003F98 FFF8                       		dc.w	$FFF8
00003F9A 0005                       		dc.w	$0005
00003F9C 36B8                       		dc.w	($0000+$26B8)|$1000
00003F9E FFF8                       		dc.w	$FFF8
00003FA0                            CMap_Ring_Sparkle_Last:
00003FA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FA0                            ; HUD mappings
00003FA0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FA0                            Map_HUD:	include	"Level/Objects/HUD/Mappings.asm"
00003FA0                            ; --------------------------------------------------------------------------------
00003FA0                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00003FA0                            ; --------------------------------------------------------------------------------
00003FA0                            
00003FA0                            SME_dLu6r:	
00003FA0 0000 0000                  		dc.w SME_dLu6r4-SME_dLu6r, SME_dLu6r18-SME_dLu6r	
00003FA4 0003                       SME_dLu6r4:	dc.b 0, 3	
00003FA6 000D 0002 0000             		dc.b 0, $D, 0, 2, 0, 0	
00003FAC 0001 0000 0020             		dc.b 0, 1, 0, 0, 0, $20	
00003FB2 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00003FB8 0003                       SME_dLu6r18:	dc.b 0, 3	
00003FBA 000D 2002 0000             		dc.b 0, $D, $20, 2, 0, 0	
00003FC0 0001 2000 0020             		dc.b 0, 1, $20, 0, 0, $20	
00003FC6 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00003FCC                            		even
00003FCC                            		even
00003FCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FCC                            ; Update the HUD
00003FCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FCC                            ; PARAMETERS:
00003FCC                            ;	a5.l	- VDP data port
00003FCC                            ;	a6.l	- VDP control port
00003FCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FCC                            ; RETURNS:
00003FCC                            ;	Nothing
00003FCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FCC                            Level_UpdateHUD:
00003FCC 4A38 F8F3                  		tst.b	rUpdateRings.w		; Does the ring counter need to be updated?
00003FD0 6700                       		beq.s	.End				; If not, branch
00003FD2 6B00                       		bmi.s	.DontZero			; If the flag is negative, branch
00003FD4 6100 0000                  		bsr.w	Level_HUDResetRings		; Reset the ring counter
00003FD8                            
00003FD8                            .DontZero:
00003FD8 4238 F8F3                  		clr.b	rUpdateRings.w		; Clear update value
00003FDC                            		vdpCmd	move.l,$D140,VRAM,WRITE,d0	; Set VDP command
00003FDC 203C 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),d0
00003FE2 7200                       		moveq	#0,d1
00003FE4 3238 F3D4                  		move.w	rRings.w,d1			; Ring count
00003FE8 6000                       		bra.s	.UpdateRings			; Update the rings counter
00003FEA                            
00003FEA                            .End
00003FEA 4E75                       		rts
00003FEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FEC                            .UpdateRings:
00003FEC 7800                       		moveq	#0,d4				; Reset the "draw digit" flag
00003FEE 45F9 0000 0000             		lea	HUDMod_100,a2			; Start with the 100s digit
00003FF4 7C02                       		moveq	#3-1,d6				; Number of digits to draw
00003FF6 43FA 0000                  		lea	ArtUnc_HUDNumbers(pc),a1	; HUD numbers
00003FFA                            		
00003FFA                            .LoadDigit_Loop:
00003FFA 7400                       		moveq	#0,d2				; Reset the digit
00003FFC 261A                       		move.l	(a2)+,d3			; Get the number that's used to calculute what the current digit is
00003FFE                            		
00003FFE                            .GetDigit:
00003FFE 9283                       		sub.l	d3,d1				; Subtract
00004000 6500                       		bcs.s	.InitDrawDigit			; If it's gone below 0, branch
00004002 5242                       		addq.w	#1,d2				; Increment digit
00004004 60F8                       		bra.s	.GetDigit			; Loop until the digit is corret
00004006                            
00004006                            .InitDrawDigit:
00004006 D283                       		add.l	d3,d1				; Add back
00004008 4A42                       		tst.w	d2				; Is the digit 0?
0000400A 6700                       		beq.s	.DrawDigit			; If so, branch
0000400C 50C4                       		st	d4				; Set the "draw digit" flag
0000400E                            
0000400E                            .DrawDigit:
0000400E 4A04                       		tst.b	d4				; Should we draw the digit?
00004010 6700                       		beq.s	.NextDigit			; If not, branch
00004012 ED4A                       		lsl.w	#6,d2				; Multiply the digit by $40
00004014 2C80                       		move.l	d0,(a6)				; Set the VDP command
00004016 47F1 2000                  		lea	(a1,d2.w),a3			; Get address of the digit art
0000401A                            		rept	16
0000401A                            			move.l	(a3)+,(a5)		; Load the digit art
0000401A                            		endr
0000401A 2A9B                     M 	move.l	(a3)+,(a5)
0000401C 2A9B                     M 	move.l	(a3)+,(a5)
0000401E 2A9B                     M 	move.l	(a3)+,(a5)
00004020 2A9B                     M 	move.l	(a3)+,(a5)
00004022 2A9B                     M 	move.l	(a3)+,(a5)
00004024 2A9B                     M 	move.l	(a3)+,(a5)
00004026 2A9B                     M 	move.l	(a3)+,(a5)
00004028 2A9B                     M 	move.l	(a3)+,(a5)
0000402A 2A9B                     M 	move.l	(a3)+,(a5)
0000402C 2A9B                     M 	move.l	(a3)+,(a5)
0000402E 2A9B                     M 	move.l	(a3)+,(a5)
00004030 2A9B                     M 	move.l	(a3)+,(a5)
00004032 2A9B                     M 	move.l	(a3)+,(a5)
00004034 2A9B                     M 	move.l	(a3)+,(a5)
00004036 2A9B                     M 	move.l	(a3)+,(a5)
00004038 2A9B                     M 	move.l	(a3)+,(a5)
0000403A                            		
0000403A                            .NextDigit:
0000403A 0680 0040 0000             		addi.l	#$400000,d0			; Next digit
00004040 51CE FFB8                  		dbf	d6,.LoadDigit_Loop		; Loop
00004044 4E75                       		rts
00004046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004046 0000 0064                  HUDMod_100:	dc.l	100
0000404A 0000 000A                  HUDMod_10:	dc.l	10
0000404E 0000 0001                  HUDMod_1:	dc.l	1
00004052                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004052                            ; Initialize the HUD
00004052                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004052                            Level_InitHUD:
00004052 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP data port
00004058 4BEE FFFC                  		lea	-4(a6),a5			; VDP control port
0000405C                            		
0000405C                            Level_HUDResetRings:
0000405C                            		vdpCmd	move.l,$D140,VRAM,WRITE,(a6)	; Set VDP command
0000405C 2CBC 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),(a6)
00004062 45FA 0000                  		lea	HUD_RingsBase(pc),a2		; Tile base
00004066 343C 0002                  		move.w	#3-1,d2				; Length
0000406A                            
0000406A 43FA 0000                  		lea	ArtUnc_HUDNumbers(pc),a1	; HUD numbers art
0000406E                            
0000406E                            .LoadTiles:
0000406E 101A                       		move.b	(a2)+,d0			; Get digit
00004070 4880                       		ext.w	d0
00004072 ED48                       		lsl.w	#6,d0				; Turn into offset
00004074 47F1 0000                  		lea	(a1,d0.w),a3			; Get address of digit art
00004078                            
00004078                            		rept	8*2
00004078                            			move.l	(a3)+,(a5)		; Load art
00004078                            		endr
00004078 2A9B                     M 	move.l	(a3)+,(a5)
0000407A 2A9B                     M 	move.l	(a3)+,(a5)
0000407C 2A9B                     M 	move.l	(a3)+,(a5)
0000407E 2A9B                     M 	move.l	(a3)+,(a5)
00004080 2A9B                     M 	move.l	(a3)+,(a5)
00004082 2A9B                     M 	move.l	(a3)+,(a5)
00004084 2A9B                     M 	move.l	(a3)+,(a5)
00004086 2A9B                     M 	move.l	(a3)+,(a5)
00004088 2A9B                     M 	move.l	(a3)+,(a5)
0000408A 2A9B                     M 	move.l	(a3)+,(a5)
0000408C 2A9B                     M 	move.l	(a3)+,(a5)
0000408E 2A9B                     M 	move.l	(a3)+,(a5)
00004090 2A9B                     M 	move.l	(a3)+,(a5)
00004092 2A9B                     M 	move.l	(a3)+,(a5)
00004094 2A9B                     M 	move.l	(a3)+,(a5)
00004096 2A9B                     M 	move.l	(a3)+,(a5)
00004098                            
00004098 51CA FFD4                  		dbf	d2,.LoadTiles			; Loop
0000409C                            
0000409C 4E75                       		rts
0000409E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000409E                            HUD_RingsBase:
0000409E 0A0A 00                    		dc.b	$A, $A, 0			; Ring count
000040A2 00                         		even
000040A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040A2                            ; HUD art
000040A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040A2                            ArtUnc_HUDNumbers:
000040A2                            		incbin	"Level/Objects/HUD/Art - HUD Numbers.unc.bin"
00004322 0000 0000 0000 0000 0000+  		dcb.l	16, 0
00004362                            		even
00004362                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004362                            ; Animate the level art
00004362                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004362                            ; LEVEL ANIMATION SCRIPTS
00004362                            ;
00004362                            ; The AniArt_DoAnimate subroutine uses these scripts to reload certain tiles,
00004362                            ; thus animating them. All the relevant art must be uncompressed, because
00004362                            ; otherwise the subroutine would spend so much time waiting for the art to be
00004362                            ; decompressed that the VBLANK window would close before all the animating was done.
00004362                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004362                            ;	zoneanimdecl -1, ArtUnc_Flowers1, ArtTile_ArtUnc_Flowers1, 6, 2
00004362                            ;		-1			Global frame duration. If -1, then each frame will use its own duration, instead
00004362                            ;		ArtUnc_Flowers1		Source address
00004362                            ;		ArtTile_ArtUnc_Flowers1	Destination VRAM address
00004362                            ;		6			Number of frames
00004362                            ;		2			Number of tiles to load into VRAM for each frame
00004362                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004362                            ;	dc.b   0,$7F			Start of the script proper
00004362                            ;		0			Tile ID of first tile in ArtUnc_Flowers1 to transfer
00004362                            ;		$7F			Frame duration. Only here if global duration is -1
00004362                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004362                            AniArt_DoAnimate:
00004362 47F8 F902                  		lea	rAnimCnts.w,a3		; Level art animation counters
00004366 3C1A                       		move.w	(a2)+,d6			; Get number of scripts in list
00004368 6A00                       		bpl.s	.ListNotEmpty			; If there are any, continue
0000436A 4E75                       		rts
0000436C                            
0000436C                            .ListNotEmpty:
0000436C                            .Loop:
0000436C 5313                       		subq.b	#1,(a3)				; Tick down frame duration
0000436E 6400                       		bcc.s	.NextScript			; If frame isn't over, move on to next script
00004370                            
00004370                            .NextFrame:
00004370 7000                       		moveq	#0,d0
00004372 102B 0001                  		move.b	1(a3),d0			; Get current frame
00004376 B02A 0006                  		cmp.b	6(a2),d0			; Have we processed the last frame in the script?
0000437A 6500                       		blo.s	.NotLastFrame			; If not, branch
0000437C 7000                       		moveq	#0,d0				; If so, reset to first frame
0000437E 1740 0001                  		move.b	d0,1(a3)			; ''
00004382                            
00004382                            .NotLastFrame:
00004382 522B 0001                  		addq.b	#1,1(a3)			; Consider this frame processed; set counter to next frame
00004386 1692                       		move.b	(a2),(a3)			; Set frame duration to global duration value
00004388 6A00                       		bpl.s	.GlobalDuration
0000438A D040                       		add.w	d0,d0				; If script uses per-frame durations, use those instead
0000438C 16B2 0009                  		move.b	9(a2,d0.w),(a3)			; Set frame duration to current frame's duration value
00004390                            
00004390                            .GlobalDuration:
00004390 1032 0008                  		move.b	8(a2,d0.w),d0			; Get tile ID
00004394 EB48                       		lsl.w	#5,d0				; Turn it into an offset
00004396 342A 0004                  		move.w	4(a2),d2			; Get VRAM destination address
0000439A 2212                       		move.l	(a2),d1				; Get ROM source address
0000439C 0281 00FF FFFF             		andi.l	#$FFFFFF,d1			; ''
000043A2 D280                       		add.l	d0,d1				; Offset into art, to get the address of new frame
000043A4 7600                       		moveq	#0,d3
000043A6 162A 0007                  		move.b	7(a2),d3			; Get size of art to be transferred 
000043AA E94B                       		lsl.w	#4,d3				; Turn it into actual size (in words)
000043AC 4EB8 0288                  		jsr	QueueDMATransfer.w		; Queue a DMA transfer
000043B0                            
000043B0                            .NextScript:
000043B0 102A 0006                  		move.b	6(a2),d0			; Get total size of frame data
000043B4 4A12                       		tst.b	(a2)				; Is per-frame duration data present?
000043B6 6A00                       		bpl.s	.GlobalDuration2		; If not, keep the current size; it's correct
000043B8 D000                       		add.b	d0,d0				; Double size to account for the additional frame duration data
000043BA                            
000043BA                            .GlobalDuration2:
000043BA 5200                       		addq.b	#1,d0
000043BC 0240 00FE                  		andi.w	#$FE,d0				; Round to next even address, if it isn't already
000043C0 45F2 0008                  		lea	8(a2,d0.w),a2			; Advance to next script in list
000043C4 544B                       		addq.w	#2,a3				; Advance to next script's slot in a3 (usually Anim_Counters)
000043C6 51CE FFA4                  		dbf	d6,.Loop			; Loop
000043CA 4E75                       		rts
000043CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043CC                            ; Set an object as solid and check for collision
000043CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043CC                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For oStatus):
000043CC                            ;	XXPXSXAX
000043CC                            ;	X	- Unused
000043CC                            ;	P	- Pushing flag
000043CC                            ;	S	- Standing on flag
000043CC                            ;	A	- In air flag (for the player)
000043CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043CC                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For d6):
000043CC                            ;	XXXTXBXS
000043CC                            ;	X	- Unused
000043CC                            ;	T	- Touch top flag
000043CC                            ;	B	- Touch bottom flag
000043CC                            ;	S	- Touch side flag
000043CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043CC                            ; PARAMETERS:
000043CC                            ;	d1.w	- Object width
000043CC                            ;	d2.w	- Object height / 2 (when jumping)
000043CC                            ;	d3.w	- Object height / 2 (when walking)
000043CC                            ;	d4.w	- Object x-axis position
000043CC                            ;	a0.l	- Object space pointer
000043CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043CC                            ; RETURNS:
000043CC                            ;	See object collision return values above
000043CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043CC                            SolidObject:
000043CC 7C00                       		moveq	#0,d6				; Clear collision flag register
000043CE 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
000043D2 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
000043D8 6700 0000                  		beq.w	SolidObject_ChkColOnScr		; If not, branch
000043DC 3401                       		move.w	d1,d2				; Copy object width
000043DE D442                       		add.w	d2,d2				; Double it
000043E0 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000043E6 6600                       		bne.s	.NotOnTop			; If so, branch
000043E8 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000043EC 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
000043F0 D041                       		add.w	d1,d0				; Add width
000043F2 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000043F4 B042                       		cmp.w	d2,d0				; Compare with the width
000043F6 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000043F8                            
000043F8                            .NotOnTop:
000043F8 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
000043FE 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
00004404 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
0000440A 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000440E 7800                       		moveq	#0,d4				; Set collision status to 0
00004410 4E75                       		rts
00004412                            
00004412                            .IsOnTop:
00004412 3404                       		move.w	d4,d2				; Copy X position to d2
00004414 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
00004418 7800                       		moveq	#0,d4				; Set collision status to 0
0000441A 4E75                       		rts
0000441C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000441C                            ; Set an object as solid and check for collision (even if off screen)
0000441C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000441C                            ; PARAMETERS:
0000441C                            ;	d1.w	- Object width
0000441C                            ;	d2.w	- Object height / 2 (when jumping)
0000441C                            ;	d3.w	- Object height / 2 (when walking)
0000441C                            ;	d4.w	- Object x-axis position
0000441C                            ;	a0.l	- Object space pointer
0000441C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000441C                            ; RETURNS:
0000441C                            ;	See object collision return values above
0000441C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000441C                            SolidObject_Always:
0000441C 7C00                       		moveq	#0,d6				; Clear collision flag register
0000441E 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
00004422 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
00004428 6700 0000                  		beq.w	SolidObject_ChkCollision	; If not, branch
0000442C 3401                       		move.w	d1,d2				; Copy object width
0000442E D442                       		add.w	d2,d2				; Double it
00004430 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004436 6600                       		bne.s	.NotOnTop			; If so, branch
00004438 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0000443C 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004440 D041                       		add.w	d1,d0				; Add width
00004442 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004444 B042                       		cmp.w	d2,d0				; Compare with the width
00004446 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004448                            
00004448                            .NotOnTop:
00004448 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
0000444E 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
00004454 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
0000445A 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000445E 7800                       		moveq	#0,d4				; Set collision status to 0
00004460 4E75                       		rts
00004462                            
00004462                            .IsOnTop:
00004462 3404                       		move.w	d4,d2				; Copy X position to d2
00004464 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
00004468 7800                       		moveq	#0,d4				; Set collision status to 0
0000446A 4E75                       		rts
0000446C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000446C                            ; Set an object as a solid slope and check for collision
0000446C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000446C                            ; PARAMETERS:
0000446C                            ;	d1.w	- Object width
0000446C                            ;	d2.w	- Object height / 2 (when jumping)
0000446C                            ;	d3.w	- Object height / 2 (when walking)
0000446C                            ;	d4.w	- Object x-axis position
0000446C                            ;	a0.l	- Object space pointer
0000446C                            ;	a2.l	- Slope height data pointer
0000446C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000446C                            ; RETURNS:
0000446C                            ;	See object collision return values above
0000446C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000446C                            SlopedSolid:
0000446C 7C00                       		moveq	#0,d6				; Clear collision flag register
0000446E 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
00004472 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
00004478 6700 0000                  		beq.w	SlopedSolid_ChkCollision	; If not, branch
0000447C 3401                       		move.w	d1,d2				; Copy object width
0000447E D442                       		add.w	d2,d2				; Double it
00004480 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004486 6600                       		bne.s	.NotOnTop			; If so, branch
00004488 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0000448C 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004490 D041                       		add.w	d1,d0				; Add width
00004492 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004494 B042                       		cmp.w	d2,d0				; Compare with the width
00004496 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004498                            
00004498                            .NotOnTop:
00004498 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
0000449E 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000044A4 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000044AA 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000044AE 7800                       		moveq	#0,d4				; Set collision status to 0
000044B0 4E75                       		rts
000044B2                            
000044B2                            .IsOnTop:
000044B2 3404                       		move.w	d4,d2				; Copy X position to d2
000044B4 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Move the player on top of the current object
000044B8 7800                       		moveq	#0,d4				; Set collision status to 0
000044BA 4E75                       		rts
000044BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044BC                            SlopedSolid_ChkCollision:
000044BC 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000044C0 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract current object's X position
000044C4 D041                       		add.w	d1,d0				; Add width to it
000044C6 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
000044CA 3601                       		move.w	d1,d3				; Copy width to d3
000044CC D643                       		add.w	d3,d3				; Double it
000044CE B043                       		cmp.w	d3,d0				; Compare to the X position
000044D0 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
000044D4 3A00                       		move.w	d0,d5				; Copy the X position to d5
000044D6 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X-flipped?
000044DC 6700                       		beq.s	.NoFlip				; If not, branch
000044DE 4645                       		not.w	d5				; Logical notation on d5
000044E0 DA43                       		add.w	d3,d5				; Add width
000044E2                            
000044E2                            .NoFlip:
000044E2 E24D                       		lsr.w	#1,d5				; Divide by 2
000044E4 1632 5000                  		move.b	(a2,d5.w),d3			; Get height of this segment
000044E8 9612                       		sub.b	(a2),d3				; Subtract first bytes from the value
000044EA 4883                       		ext.w	d3				; Sign extend to word
000044EC 3A28 0018                  		move.w	oYPos(a0),d5			; Get the current object's Y position
000044F0 9A43                       		sub.w	d3,d5				; Subtract the height from the Y position
000044F2 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
000044F6 4883                       		ext.w	d3				; Sign extend to word
000044F8 D443                       		add.w	d3,d2				; Add collision height to the object height
000044FA 3629 0018                  		move.w	oYPos(a1),d3			; Get the player's Y position
000044FE 9645                       		sub.w	d5,d3				; Subtract d5
00004500 5843                       		addq.w	#4,d3				; Add 4
00004502 D642                       		add.w	d2,d3				; Add height and collision height
00004504 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
00004508 3802                       		move.w	d2,d4				; Copy height and collision height
0000450A D844                       		add.w	d4,d4				; Double it
0000450C B644                       		cmp.w	d4,d3				; Compare to Y position
0000450E 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
00004512 6000 0000                  		bra.w	SolidObject_ChkBounds		; If anything else, we are colliding
00004516                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004516                            SolidObject_ChkColOnScr:
00004516 4A28 000D                  		tst.b	oRender(a0)			; Is the object on screen?
0000451A 6A00 0000                  		bpl.w	SolidObject_TestClearPush	; If not, branch
0000451E                            
0000451E                            SolidObject_ChkCollision:
0000451E 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
00004522 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004526 D041                       		add.w	d1,d0				; Add width
00004528 3601                       		move.w	d1,d3				; Copy width
0000452A D643                       		add.w	d3,d3				; Double it
0000452C B043                       		cmp.w	d3,d0				; Compare with the X position
0000452E 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
00004532                            		
00004532 1829 0000                  		move.b	oInitColH(a1),d4		; Get the player's default collision height
00004536 4884                       		ext.w	d4				; Sign extend to word
00004538 D842                       		add.w	d2,d4				; Add height
0000453A 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
0000453E 4883                       		ext.w	d3				; Sign extend to word
00004540 D443                       		add.w	d3,d2				; Add to height
00004542 3629 0018                  		move.w	oYPos(a1),d3			; Get player's Y position
00004546 9668 0018                  		sub.w	oYPos(a0),d3			; Subtract the current object's Y position
0000454A 5843                       		addq.w	#4,d3				; Add 4
0000454C D642                       		add.w	d2,d3				; Add height
0000454E 0243 0FFF                  		andi.w	#$FFF,d3			; Keep in range
00004552 D842                       		add.w	d2,d4				; Add height
00004554 B644                       		cmp.w	d4,d3				; Compare with the Y position
00004556 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
0000455A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000455A                            SolidObject_ChkBounds:
0000455A 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
0000455E 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If so, branch
00004562 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
00004568 6400 0000                  		bcc.w	SolidObject_End			; If so, branch
0000456C 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
00004570 6600 0000                  		bne.w	SolidObject_End			; If so, branch
00004574                            
00004574 3A00                       		move.w	d0,d5				; Copy X offset
00004576 B240                       		cmp.w	d0,d1				; Check against the "middle" of the object
00004578 6400                       		bcc.s	.IsLeft				; If the player is left of the middle, branch
0000457A D241                       		add.w	d1,d1				; Double collision width
0000457C 9041                       		sub.w	d1,d0				; Subtract from X offset
0000457E 3A00                       		move.w	d0,d5				; Copy X offset
00004580 4445                       		neg.w	d5				; Negate offset
00004582                            
00004582                            .IsLeft:
00004582 3203                       		move.w	d3,d1				; Copy Y offset
00004584 B443                       		cmp.w	d3,d2				; Check against the "middle" of the object
00004586 6400                       		bcc.s	.IsAbove			; If the player is above of the middle, branch
00004588 5943                       		subq.w	#4,d3				; Subtract 4 from the collision height
0000458A 9644                       		sub.w	d4,d3				; Subtract height from the collision height
0000458C 3203                       		move.w	d3,d1				; Copy Y offset
0000458E 4441                       		neg.w	d1				; Negate offset
00004590                            
00004590                            .IsAbove:
00004590 BA41                       		cmp.w	d1,d5
00004592 6200 0000                  		bhi.w	SolidObject_UpDown		; Branch if we are in the object less vertically than horizontally(?)
00004596 0C41 0004                  		cmpi.w	#4,d1
0000459A 6300 0000                  		bls.w	SolidObject_UpDown		; I assume this ensures the corners are not solid until some point
0000459E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000459E                            SolidObject_Sides:
0000459E 4A40                       		tst.w	d0
000045A0 6700                       		beq.s	.AlignPlayer			; Branch if we are in the middle of the object?
000045A2 6B00                       		bmi.s	.ChkRight			; Branch if we are right of the object
000045A4 4A69 001C                  		tst.w	oXVel(a1)			; Is the player moving left?
000045A8 6B00                       		bmi.s	.AlignPlayer			; If so, branch
000045AA 6000                       		bra.s	.ClearGroundVel			; If else player is moving right, branch
000045AC                            
000045AC                            .ChkRight:
000045AC 4A69 001C                  		tst.w	oXVel(a1)
000045B0 6A00                       		bpl.s	.AlignPlayer			; Branch if player is moving right
000045B2                            
000045B2                            .ClearGroundVel:
000045B2 4269 0000                  		clr.w	oGVel(a1)			; Stop the player from moving
000045B6 4269 001C                  		clr.w	oXVel(a1)			; Clear the player's X velocity
000045BA                            
000045BA                            .AlignPlayer:
000045BA 9169 0014                  		sub.w	d0,oXPos(a1)			; Align player to the side of the object
000045BE 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000045C4 6600                       		bne.s	.InAir				; If so, branch
000045C6 08E8 0005 0028             		bset	#cPushBit,oStatus(a0)		; Set the pushing bit
000045CC 08E9 0005 0028             		bset	#cPushBit,oStatus(a1)		; Set the player's pushing bit
000045D2 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
000045D6 7801                       		moveq	#1,d4				; Set collision status to 1
000045D8 4E75                       		rts
000045DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045DA                            .InAir:
000045DA 6100                       		bsr.s	SolidObject_ClearPush		; Clear pushing bits
000045DC 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
000045E0 7801                       		moveq	#1,d4				; Set collision status to 1
000045E2 4E75                       		rts
000045E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045E4                            SolidObject_TestClearPush:
000045E4 0828 0005 0028             		btst	#cPushBit,oStatus(a0)		; Is the player pushing this object?
000045EA 6700                       		beq.s	SolidObject_End			; If not, branch
000045EC 0C29 0002 0020             		cmpi.b	#2,oAni(a1)			; Is the player jumping/rolling?
000045F2 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000045F4 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)			; Is the player in using the drowning animation
000045FA 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000045FC 0C29 001A 0020             		cmpi.b	#$1A,oAni(a1)			; Is the player in using the hurt animation
00004602 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
00004604 337C 0001 0020             		move.w	#1,oAni(a1)			; Make the player use the walking animation
0000460A                            
0000460A                            SolidObject_ClearPush:
0000460A 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear the pushing bit
00004610 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; Clear the player's pushing bit
00004616                            
00004616                            SolidObject_End:
00004616 7800                       		moveq	#0,d4				; Set collision status to 0
00004618 4E75                       		rts
0000461A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000461A                            SolidObject_UpDown:
0000461A 4A43                       		tst.w	d3				; Is the player below the middle of the object?
0000461C 6B00                       		bmi.s	SolidObject_Below		; If so, branch
0000461E 0C43 0010                  		cmpi.w	#$10,d3				; Is the player 16 pixels or less above the middle of the object?
00004622 6500                       		bcs.s	SolidObject_Above		; If so, branch
00004624 60BE                       		bra.s	SolidObject_TestClearPush	; If not, the player is not colliding
00004626                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004626                            SolidObject_Below:
00004626 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving vertically?
0000462A 6700                       		beq.s	.CheckCrush			; If so, branch
0000462C 6A00                       		bpl.s	.SetY				; If the player's moving down, branch
0000462E 4A43                       		tst.w	d3				; Is the player above the middle of the object?
00004630 6A00                       		bpl.s	.SetY				; If so, branch
00004632 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
00004636                            
00004636                            .SetY:
00004636 9769 0018                  		sub.w	d3,oYPos(a1)			; Push the player below the object
0000463A 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
0000463E 78FE                       		moveq	#-2,d4				; Set the collision status to -2
00004640 4E75                       		rts
00004642                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004642                            .CheckCrush:
00004642 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004648 66EC                       		bne.s	.SetY				; If so, branch
0000464A 3800                       		move.w	d0,d4				; Get x offset
0000464C 6A00                       		bpl.s	.NoNeg				; If it's positive branch
0000464E 4444                       		neg.w	d4				; Negate it (absolute value)
00004650                            
00004650                            .NoNeg:
00004650 0C44 0010                  		cmpi.w	#$10,d4				; Is the player near the edge of object collision?
00004654 6500 FF48                  		blo.w	SolidObject_Sides		; If so, branch
00004658                            		
00004658                            		push.l	a0				; Store the current object's address
00004658 2F08                     M 	move.l	a0,-(sp)
0000465A 2049                       		movea.l	a1,a0				; Replace with the player's address
0000465C 4EB9 0000 0000             		jsr	ObjMighty_GetKilled		; Kill the player
00004662                            		pop.l	a0				; Restore the current object's address
00004662 205F                     M 	move.l	(sp)+,a0
00004664 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
00004668 78FE                       		moveq	#-2,d4				; Set collision status to -2
0000466A 4E75                       		rts
0000466C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000466C                            SolidObject_Above:
0000466C 5943                       		subq.w	#4,d3				; Get the sub Y offset
0000466E                            		
0000466E                            		; This next bit ensures the player does not collide with the top when next to the walls
0000466E                            		; recalculates object width.
0000466E                            
0000466E 7200                       		moveq	#0,d1
00004670 1228 002C                  		move.b	oColW(a0),d1			; Get the current object's width
00004674 3401                       		move.w	d1,d2				; Copy it
00004676 D442                       		add.w	d2,d2				; Double it
00004678                            		
00004678 D269 0014                  		add.w	oXPos(a1),d1			; Add the player's X position
0000467C 9268 0014                  		sub.w	oXPos(a0),d1			; Subtract the current object's X position
00004680 6B00                       		bmi.s	.NoCollision			; If the player is not colliding, branch
00004682                            		
00004682 B242                       		cmp.w	d2,d1				; Is the plauer colliding from the right?
00004684 6400                       		bcc.s	.NoCollision			; If the player is not colliding, branch
00004686                            		
00004686 5369 0018                  		subq.w	#1,oYPos(a1)			; Subtract 1 from the player's Y position
0000468A 9769 0018                  		sub.w	d3,oYPos(a1)			; Move the player above the object
0000468E 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
00004692 6B00                       		bmi.s	.NoCollision			; If so, branch
00004694 6100 0000                  		bsr.w	RideObject_SetRide		; Allow the player to stand on top (and set the "ride" bit)
00004698 08C6 0004                  		bset	#cTouchTopBit,d6		; Set "touch top" flag
0000469C 78FF                       		moveq	#-1,d4				; Set collision status to -1
0000469E 4E75                       		rts
000046A0                            
000046A0                            .NoCollision:
000046A0 7800                       		moveq	#0,d4				; Set collision status to 0
000046A2 4E75                       		rts
000046A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046A4                            ; Set an object as a platform and check for collision
000046A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046A4                            ; PARAMETERS:
000046A4                            ;	d1.w	- Object's width
000046A4                            ;	d2.w	- Object's width*2 (only for Platform_ChkBridgeCol)
000046A4                            ;	d3.w	- Object's height
000046A4                            ;	d4.w	- Object x-axis position
000046A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046A4                            ; RETURNS:
000046A4                            ;	See object collision return values above (side and bottom collision doesn't apply here)
000046A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046A4                            PlatformObject:
000046A4 7C00                       		moveq	#0,d6				; Clear collision flag register
000046A6 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
000046AA 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
000046B0 6700 0000                  		beq.w	Platform_ChkCollision		; If not, branch
000046B4 3401                       		move.w	d1,d2				; Copy the object's width
000046B6 D442                       		add.w	d2,d2				; Double it
000046B8 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000046BE 6600                       		bne.s	.NotOnTop			; If so, branch
000046C0 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000046C4 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000046C8 D041                       		add.w	d1,d0				; Add width
000046CA 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
000046CC B042                       		cmp.w	d2,d0				; Compare with the width
000046CE 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
000046D0                            
000046D0                            .NotOnTop:
000046D0 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
000046D6 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000046DC 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000046E2 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000046E6 7800                       		moveq	#0,d4				; Set the collision status to 0
000046E8 4E75                       		rts
000046EA                            
000046EA                            .OnTop:
000046EA 3404                       		move.w	d4,d2				; Copy X position
000046EC 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Make the player stand on top of this object
000046F0 7800                       		moveq	#0,d4				; Set the collision status to 0
000046F2 4E75                       		rts
000046F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046F4                            Platform_ChkBridgeCol:
000046F4 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
000046F8 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000046FC 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
00004700 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
00004704 D041                       		add.w	d1,d0				; Add width
00004706 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
0000470A B042                       		cmp.w	d2,d0				; Compare with width
0000470C 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004710 6000                       		bra.s	Platform_ChkCol_Cont		; Continue
00004712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004712                            Platform_ChkCollision:
00004712 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
00004716 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
0000471A 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
0000471E 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
00004722 D041                       		add.w	d1,d0				; Add width
00004724 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004728 D241                       		add.w	d1,d1				; Double width
0000472A B041                       		cmp.w	d1,d0				; Compare with width
0000472C 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004730                            
00004730                            Platform_ChkCol_Cont:
00004730 3028 0018                  		move.w	oYPos(a0),d0			; Get the object's Y position
00004734 9043                       		sub.w	d3,d0				; Subtract the height from it
00004736                            
00004736                            PlatformObject_ChkYRange:
00004736 3429 0018                  		move.w	oYPos(a1),d2			; Get the player's Y position
0000473A 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
0000473E 4881                       		ext.w	d1				; Sign extend it
00004740 D242                       		add.w	d2,d1				; Add the Y position to the collision height
00004742 5841                       		addq.w	#4,d1				; Add 4
00004744 9041                       		sub.w	d1,d0				; Subract the result from the Y position
00004746 6200 0000                  		bhi.w	PlatformObject_End		; If it's greater than 0, branch
0000474A 0C40 FFF0                  		cmpi.w	#-$10,d0			; Is the result less than -16?
0000474E 6500 0000                  		bcs.w	PlatformObject_End		; If so, branch
00004752 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
00004756 6600 0000                  		bne.w	PlatformObject_End		; If so, branch
0000475A 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
0000475E 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
00004762 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)		; Is the player dead?
00004768 6400 0000                  		bcc.w	PlatformObject_End		; If so, branch
0000476C D440                       		add.w	d0,d2				; Add the previous result to the Y position
0000476E 5642                       		addq.w	#3,d2				; Add 3
00004770 3342 0018                  		move.w	d2,oYPos(a1)			; Add to the player's Y position
00004774                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004774                            ; Set the player on top of the object
00004774                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004774                            ; PARAMETERS:
00004774                            ;	a0.l	- Object space pointer
00004774                            ;	a1.l	- Player object space pointer
00004774                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004774                            ; RETURNS:
00004774                            ;	Nothing
00004774                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004774                            RideObject_SetRide:
00004774 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
0000477A 6700                       		beq.s	.IsStanding			; If not, branch
0000477C 3669 0000                  		movea.w	oInteract(a1),a3		; Get the object the player is standing on
00004780 08AB 0003 0028             		bclr	#cStandBit,oStatus(a3)		; Clear its standing on object bit
00004786 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000478A                            
0000478A                            .IsStanding:
0000478A 3348 0000                  		move.w	a0,oInteract(a1)		; Set it as the object the player is standing on
0000478E 4229 0000                  		clr.b	oAngle(a1)			; Clear the player's angle
00004792 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
00004796 3369 001C 0000             		move.w	oXVel(a1),oGVel(a1)		; Set the player's X velocity as its ground velocity
0000479C 08E9 0003 0028             		bset	#cStandBit,oStatus(a1)		; Set the player's standing on object bit
000047A2 08E8 0003 0028             		bset	#cStandBit,oStatus(a0)		; Set the player standing on this object bir
000047A8 08A9 0001 0028             		bclr	#1,oStatus(a1)			; Clear the player's in midair bit
000047AE 6700                       		beq.s	PlatformObject_End		; If it was already clear, branch
000047B0 2F08                       		move.l	a0,-(sp)			; Store the current object's address
000047B2 2049                       		movea.l	a1,a0				; Replace it with the player's address
000047B4 6100 E5EE                  		bsr.w	PlayerResetOnFloor		; Reset the player's variables to make it touch the floor
000047B8 205F                       		movea.l	(sp)+,a0			; Restore the current object's address
000047BA                            
000047BA                            PlatformObject_End:
000047BA 4E75                       		rts
000047BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047BC                            ; Set an object as a solid slope and check for collision
000047BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047BC                            ; PARAMETERS:
000047BC                            ;	d1.w	- Object width
000047BC                            ;	d3.w	- Object height
000047BC                            ;	d4.w	- Object x-axis position
000047BC                            ;	a0.l	- Object space pointer
000047BC                            ;	a2.l	- Slope height data pointer
000047BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047BC                            ; RETURNS:
000047BC                            ;	See object collision return values above (side and bottom collision doesn't apply here)
000047BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047BC                            SlopedPlatform:
000047BC 7C00                       		moveq	#0,d6				; Clear collision flag register
000047BE 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
000047C2 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
000047C8 6700 0000                  		beq.w	SlopedPlarform_ChkCol		; If not branch
000047CC 3401                       		move.w	d1,d2				; Copy the object's width
000047CE D442                       		add.w	d2,d2				; Double it
000047D0 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000047D6 6600                       		bne.s	.NotOnTop			; If so, branch
000047D8 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000047DC 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000047E0 D041                       		add.w	d1,d0				; Add width
000047E2 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
000047E4 B042                       		cmp.w	d2,d0				; Compare with the width
000047E6 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
000047E8                            
000047E8                            .NotOnTop:
000047E8 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
000047EE 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000047F4 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000047FA 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000047FE 7800                       		moveq	#0,d4				; Set the collision status to 0
00004800 4E75                       		rts
00004802                            
00004802                            .OnTop:
00004802 3404                       		move.w	d4,d2				; Copy X position
00004804 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Make the player stand on top of this object
00004808 7800                       		moveq	#0,d4				; Set the collision status to 0
0000480A 4E75                       		rts
0000480C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000480C                            SlopedPlarform_ChkCol:
0000480C 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
00004810 6B00 FFA8                  		bmi.w	PlatformObject_End		; If so, branch
00004814 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
00004818 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
0000481C D041                       		add.w	d1,d0				; Add width
0000481E 6B00 FF9A                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004822 D241                       		add.w	d1,d1				; Double width
00004824 B041                       		cmp.w	d1,d0				; Compare with width
00004826 6400 FF92                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
0000482A 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
00004830 6700                       		beq.s	.NoXFlip			; If not, skip
00004832 4640                       		not.w	d0				; Logical notation
00004834 D041                       		add.w	d1,d0				; Add width
00004836                            
00004836                            .NoXFlip:
00004836 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004838 1632 0000                  		move.b	(a2,d0.w),d3			; Get height of the next segment
0000483C 4883                       		ext.w	d3				; Sign extend to word
0000483E 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
00004842 9043                       		sub.w	d3,d0				; Subtract the height from the Y position
00004844 6000 FEF0                  		bra.w	PlatformObject_ChkYRange	; Check the Y range
00004848                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004848                            ; Move the player along a platform/solid object
00004848                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004848                            ; PARAMETERS:
00004848                            ;	d2.w	- X position of the platform
00004848                            ;	d3.w	- Height of the platform
00004848                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004848                            ; RETURNS:
00004848                            ;	Nothing
00004848                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004848                            PlayerMoveOnPtfm:
00004848 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
0000484C 9043                       		sub.w	d3,d0				; Subtract height
0000484E 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
00004852 6B00                       		bmi.s	.End				; If so, branch
00004854 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
0000485A 6400                       		bcc.s	.End				; If so, branch
0000485C 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
00004860 6600                       		bne.s	.End				; If so, branch
00004862 7200                       		moveq	#0,d1
00004864 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
00004868 9041                       		sub.w	d1,d0				; Subtract from the Y position
0000486A 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
0000486E 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004872 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
00004876                            		;tst.b	(Shield_Flag).w			; Does the player have a shield?
00004876                            		;beq.s	.End				; If not branch
00004876                            		;move.w	d0,(Object_Space_7+oY).w	; Apply to the shield's Y position
00004876                            		;sub.w	d2,(Object_Space_7+oX).w	; Apply to the shield's X position
00004876                            
00004876                            .End:
00004876 4E75                       		rts
00004878                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004878                            ; Move the player along a sloped platform/solid object
00004878                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004878                            ; PARAMETERS:
00004878                            ;	d3.w	- Height of the platform
00004878                            ;	d4.w	- X position of the platform
00004878                            ;	a2.l	- Slope height data pointer
00004878                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004878                            ; RETURNS:
00004878                            ;	Nothing
00004878                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004878                            PlayerMoveOnSlope:
00004878 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
0000487E 6700                       		beq.s	.End				; If not, branch
00004880 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
00004884 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004888 D041                       		add.w	d1,d0				; Add width
0000488A E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
0000488C 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
00004892 6700                       		beq.s	.NoXFlip			; If not, branch
00004894 4640                       		not.w	d0				; Logical notation on d0
00004896 D041                       		add.w	d1,d0				; Add width
00004898                            
00004898                            .NoXFlip:
00004898 1232 0000                  		move.b	(a2,d0.w),d1			; Get Y offset
0000489C 4881                       		ext.w	d1				; Sign extend to word
0000489E 3028 0018                  		move.w	oYPos(a0),d0			; Get current object's Y position
000048A2 9041                       		sub.w	d1,d0				; Subtract the Y offset
000048A4 7200                       		moveq	#0,d1
000048A6 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
000048AA 9041                       		sub.w	d1,d0				; Subtract from the Y position
000048AC 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
000048B0 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
000048B4 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
000048B8                            
000048B8                            .End:
000048B8 4E75                       		rts
000048BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048BA                            ; Do object collision for the player object
000048BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048BA                            PlayerDoObjCollision:
000048BA 4EB8 3E4C                  		jsr	PlayerRingCollision		; Do ring collision
000048BE                            		
000048BE 3428 0014                  		move.w	oXPos(a0),d2			; Get X position
000048C2 3628 0018                  		move.w	oYPos(a0),d3			; Get Y position
000048C6 5142                       		subq.w	#8,d2				; Get left sensor X
000048C8 7A00                       		moveq	#0,d5
000048CA 1A28 002D                  		move.b	oColH(a0),d5			; Get collision height
000048CE 5705                       		subq.b	#3,d5				; Subtract 3
000048D0 9645                       		sub.w	d5,d3				; Get left sensor Y
000048D2 383C 0010                  		move.w	#$10,d4				; Get right sensor delta X
000048D6 DA45                       		add.w	d5,d5				; Get right sensor delta Y
000048D8                            
000048D8 49F8 F354                  		lea	rColList.w,a4			; Get collision response list
000048DC 3C1C                       		move.w	(a4)+,d6			; Get count
000048DE 6700                       		beq.s	.End				; If there are no objects to test, branch
000048E0                            
000048E0                            .ObjLoop:
000048E0 325C                       		movea.w	(a4)+,a1			; Get object
000048E2 1029 002A                  		move.b	oColType(a1),d0			; Does touching it do anything?
000048E6 6600                       		bne.s	.ChkPosition			; If so, branch
000048E8                            
000048E8                            .NextObj:
000048E8 5546                       		subq.w	#2,d6				; Decrement count
000048EA 66F4                       		bne.s	.ObjLoop			; Branch if there are still objects to check
000048EC 7000                       		moveq	#0,d0				; Reset d0
000048EE                            
000048EE                            .End:
000048EE 4278 F354                  		clr.w	rColList.w			; Clear the collision response list count
000048F2 4E75                       		rts
000048F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048F4                            .ChkPosition:
000048F4 7200                       		moveq	#0,d1
000048F6 1229 002C                  		move.b	oColW(a1),d1			; Get object width
000048FA 3029 0014                  		move.w	oXPos(a1),d0			; Get object X position
000048FE 9041                       		sub.w	d1,d0				; Get left side of object
00004900 9042                       		sub.w	d2,d0				; Is the player right of the left side of the object?
00004902 6400                       		bcc.s	.ChkRightSide			; If so, branch
00004904 D241                       		add.w	d1,d1				; Get right side delta X
00004906 D041                       		add.w	d1,d0				; Is the player right of the right side of the object?
00004908 6500                       		bcs.s	.ChkHeight			; If not, branch
0000490A 60DC                       		bra.s	.NextObj			; The player isn't touching the object horizontally; check the next object
0000490C                            
0000490C                            .ChkRightSide:
0000490C B044                       		cmp.w	d4,d0				; Is the player inside the object horizontally?
0000490E 62D8                       		bhi.s	.NextObj			; If not, branch
00004910                            
00004910                            .ChkHeight:
00004910 7200                       		moveq	#0,d1
00004912 1229 002D                  		move.b	oColH(a1),d1			; Get object height
00004916 3029 0018                  		move.w	oYPos(a1),d0			; Get object Y position
0000491A 9041                       		sub.w	d1,d0				; Get top of object
0000491C 9043                       		sub.w	d3,d0				; Is the player below the top of the object?
0000491E 6400                       		bcc.s	.ChkBottom			; If so, branch
00004920 D241                       		add.w	d1,d1				; Get bottom delta Y
00004922 D240                       		add.w	d0,d1				; Is the player below the bottom of the object?
00004924 6500                       		bcs.s	.ChkType			; If not, branch
00004926 60C0                       		bra.s	.NextObj			; The player isn't touching the object vertically; check the next object
00004928                            
00004928                            .ChkBottom:
00004928 B045                       		cmp.w	d5,d0				; Is the player inside the object vertically?
0000492A 62BC                       		bhi.s	.NextObj			; If not, branch
0000492C                            
0000492C                            .ChkType:
0000492C 7000                       		moveq	#0,d0
0000492E 1029 002A                  		move.b	oColType(a1),d0			; Get collision type
00004932 4EFB 0000                  		jmp	.CollisionTypes-2(pc,d0.w)	; Go to the appropriate routine
00004936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004936                            .CollisionTypes:
00004936 6000                       		bra.s	.Enemy				; Enemy
00004938 6000                       		bra.s	.Indestructable			; Indestructable
0000493A 6000                       		bra.s	.Monitor			; Monitor
0000493C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000493C                            .Enemy:
0000493C 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
00004942 6600 0000                  		bne.w	.ChkHurt			; If not, branch
00004946                            
00004946                            .ChkBoss:
00004946 4A29 002B                  		tst.b	oHitCnt(a1)			; Do we have a hit count?
0000494A 6700                       		beq.s	.Kill				; If not, branch
0000494C 4468 001C                  		neg.w	oXVel(a0)			; Bounce backwards
00004950 4468 001E                  		neg.w	oYVel(a0)			; ''
00004954 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
00004958 5329 002B                  		subq.b	#1,oHitCnt(a1)			; Decrement hit count
0000495C 6600                       		bne.s	.BossEnd			; If it hasn't reached 0, branch
0000495E 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
00004964                            
00004964                            .BossEnd:
00004964 4E75                       		rts
00004966                            
00004966                            .Kill:
00004966 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
0000496C 22BC 0000 0000             		move.l	#ObjExplosion,oAddr(a1)		; Change into an explosion
00004972 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
00004976 4229 0025                  		clr.b	oRoutine(a1)			; Reset the routine ID
0000497A 4A68 001E                  		tst.w	oYVel(a0)			; Are we going up?
0000497E 6B00                       		bmi.s	.MoveDown			; If so, branch
00004980 3028 0018                  		move.w	oYPos(a0),d0			; Are we below the object?
00004984 B069 0018                  		cmp.w	oYPos(a1),d0			; ''
00004988 6400                       		bhs.s	.MoveUp				; If so, branch
0000498A 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
0000498E 4E75                       		rts
00004990                            
00004990                            .MoveDown:
00004990 0668 0100 001E             		addi.w	#$100,oYVel(a0)			; Move down
00004996 4E75                       		rts
00004998                            
00004998                            .MoveUp:
00004998 0468 0100 001E             		subi.w	#$100,oYVel(a0)			; Move up
0000499E 4E75                       		rts
000049A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049A0                            .Indestructable:
000049A0 6000                       		bra.s	.ChkHurt			; Get hurt
000049A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049A2                            .Monitor:
000049A2 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
000049A6 6A00                       		bpl.s	.ChkDestroy			; If it's falling or staying still, branch
000049A8 3028 0018                  		move.w	oYPos(a0),d0			; Get player's Y position
000049AC 0440 0010                  		subi.w	#$10,d0				; Subtract 16
000049B0 B069 0018                  		cmp.w	oYPos(a1),d0			; Is the plyaer hitting the bottom of the object?
000049B4 6500                       		blo.s	.MonitorEnd			; If not, branch
000049B6 337C FE80 001E             		move.w	#-$180,oYVel(a1)		; Bounce the monitor up
000049BC 4A29 0000                  		tst.b	oMonFall(a1)			; Is it already falling?
000049C0 6600                       		bne.s	.MonitorEnd			; If so, branch
000049C2 50E9 0000                  		st	oMonFall(a1)			; Set the fall flag
000049C6 4E75                       		rts
000049C8                            
000049C8                            .ChkDestroy:
000049C8 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
000049CE 6600                       		bne.s	.MonitorEnd			; If not, branch
000049D0 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
000049D4 22BC 0000 0000             		move.l	#ObjMonitorBreakOpen,oAddr(a1)	; Set to destroyed routine
000049DA                            		
000049DA                            .MonitorEnd:
000049DA 4E75                       		rts
000049DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049DC                            .ChkHurt:
000049DC 4A68 0000                  		tst.w	oInvulTime(a0)			; Are we invulnerable?
000049E0 6600                       		bne.s	.NoHurt				; If so, branch
000049E2 2449                       		movea.l	a1,a2				; Copy harmful object's pointer
000049E4 4EF9 0000 0000             		jmp	ObjMighty_GetHurt		; Get hurts
000049EA                            
000049EA                            .NoHurt:
000049EA 4E75                       		rts
000049EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EC                            ; Add a new entry to the collision response list
000049EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EC                            AddToColResponse:
000049EC 43F8 F354                  		lea	rColList.w,a1			; Get collision response list
000049F0 0C51 007E                  		cmpi.w	#$7E,(a1)			; Is it full?
000049F4 6400                       		bhs.s	.End				; If so, branch
000049F6 5451                       		addq.w	#2,(a1)				; Add a new entry
000049F8 D2D1                       		adda.w	(a1),a1				; Get entry pointer
000049FA 3288                       		move.w	a0,(a1)				; Store entry
000049FC                            
000049FC                            .End:
000049FC 4E75                       		rts
000049FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FE                            ; Save some info in a level (mainly for checkpoints)
000049FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FE                            ; PARAMETERS:
000049FE                            ;	a0.l	- Object space pointer
000049FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FE                            ; RETURNS:
000049FE                            ;	Nothing
000049FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049FE                            Level_SaveInfo:
000049FE 31E8 0014 C7B0             		move.w	oXPos(a0),rSavedXPos.w		; Save X position
00004A04 31E8 0018 C7B2             		move.w	oYPos(a0),rSavedYPos.w		; Save Y position
00004A0A 4E75                       		rts
00004A0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A0C                            ; Load some info in a level (mainly for checkpoints)
00004A0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A0C                            ; PARAMETERS:
00004A0C                            ;	a0.l	- Object space pointer
00004A0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A0C                            ; RETURNS:
00004A0C                            ;	Nothing
00004A0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A0C                            Level_LoadSavedInfo:
00004A0C 3178 C7B0 0014             		move.w	rSavedXPos.w,oXPos(a0)		; Load X position
00004A12 3178 C7B2 0018             		move.w	rSavedYPos.w,oYPos(a0)		; Load Y position
00004A18 4E75                       		rts
00004A1A                            ; =========================================================================================================================================================
00004A1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A1A                            ; Music IDs
00004A1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A1A                            Level_MusicIDs:
00004A1A 0B0B                       		dc.b	mWWZ, mWWZ
00004A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A1C                            ; Level water heights (-1 for no water)
00004A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A1C                            Level_WaterLevels:
00004A1C                            		;dc.w	$490, -1			; Wacky Workbench
00004A1C FFFF FFFF                  		dc.w	-1, -1
00004A20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A20                            ; Level data pointers
00004A20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A20                            ; FORMAT:
00004A20                            ;	dc.l	CHUNKS, BLOCKS, TILES, PALETTE
00004A20                            ;	dc.l	LAYOUT, OBJECTS, RINGS, COLLISION
00004A20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A20                            Level_DataPointers:
00004A20 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
00004A30 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
00004A40 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
00004A50 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
00004A60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A60                            ; Size and start position data
00004A60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A60                            Level_SizeStartPos:
00004A60 3000 0580                  		dc.w	$3000, $580
00004A64                            		incbin	"Level/Level Data/Wacky Workbench/Start Position.bin"
00004A68 3000 0580                  		dc.w	$3000, $580
00004A6C                            		incbin	"Level/Level Data/Wacky Workbench/Start Position.bin"
00004A70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A70                            ; Dynamic events routines
00004A70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A70                            Level_DynEvenRouts:
00004A70 0000 0000                  		dc.l	DynEv_WWZ			; Wacky Workbench
00004A74 0000 0000                  		dc.l	DynEv_WWZ
00004A78                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A78                            ; Wacky Workbench dynamic events routine
00004A78                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A78                            DynEv_WWZ:
00004A78 7000                       		moveq	#0,d0
00004A7A 1038 F8FE                  		move.b	rDynEvRout.w,d0
00004A7E 303B 0000                  		move.w	.Index(pc,d0.w),d0
00004A82 4EFB 0000                  		jmp	.Index(pc,d0.w)
00004A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A86                            .Index:
00004A86 0000                       		dc.w	.WaitBoss-.Index
00004A88 0000                       		dc.w	.Done-.Index
00004A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A8A                            .WaitBoss:
00004A8A 0C78 2EE0 F880             		cmpi.w	#$2EE0,rCamXPos.w
00004A90 6D00                       		blt.s	.Done
00004A92 31FC 0340 F8CA             		move.w	#$340,rMinCamY.w
00004A98 31FC 0340 F8BE             		move.w	#$340,rDestMaxY.w
00004A9E 31FC 2EE0 F8C8             		move.w	#$2EE0,rMinCamX.w
00004AA4 31FC 2EE0 F8C0             		move.w	#$2EE0,rMaxCamX.w
00004AAA 5438 F8FE                  		addq.b	#2,rDynEvRout.w
00004AAE                            
00004AAE                            .Done:
00004AAE 4E75                       		rts
00004AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AB0                            ; Palette cycle routines
00004AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AB0                            Level_PalCycRouts:
00004AB0 0000 0000                  		dc.l	PalCycle_WWZ			; Wacky Workbench
00004AB4 0000 0000                  		dc.l	PalCycle_WWZ
00004AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AB8                            ; Wacky Workbench palette cycle routine
00004AB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AB8                            PalCycle_WWZ:
00004AB8 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
00004ABC 6600                       		bne.s	.Flash				; If so, branch
00004ABE                            
00004ABE 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004AC2 6A00                       		bpl.s	.ResetPal			; If it hasn't run out, branch
00004AC4 50F8 F8FF                  		st	rFloorActive.w		; Set the floor active flag
00004AC8 31FC 00B4 F900             		move.w	#180,rFloorTimer.w		; Set the floor timer
00004ACE                            
00004ACE                            .ResetPal:
00004ACE 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset the palette cycle
00004AD2 31FC 0C28 9930             		move.w	#$C28,(rPalette+$62).w		; Set the floor color to be deactivated
00004AD8 31FC 0E48 98B0             		move.w	#$E48,(rWaterPal+$62).w	; ''
00004ADE 4E75                       		rts
00004AE0                            
00004AE0                            .Flash:
00004AE0 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004AE4 6A00                       		bpl.s	.UpdatePal			; If it hasn't run out, branch
00004AE6 4238 F8FF                  		clr.b	rFloorActive.w		; Clear the floor active flag
00004AEA 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set the floor timer
00004AF0                            
00004AF0                            .UpdatePal:
00004AF0 5338 C7CE                  		subq.b	#1,rPalCycTimer.w		; Decrement the palette cycle timer
00004AF4 6A00                       		bpl.s	.End				; If it hasn't run out, branch
00004AF6 11FC 0001 C7CE             		move.b	#1,rPalCycTimer.w		; Reset the palette cycle timer
00004AFC                            
00004AFC 7000                       		moveq	#0,d0
00004AFE 1038 C7CF                  		move.b	rPalCycIndex.w,d0		; Get the palette cycle index
00004B02 D040                       		add.w	d0,d0				; Turn into offset
00004B04                            							; Set the floor color
00004B04 31FB 0000 9930             		move.w	PalCyc_WWZFloor(pc,d0.w),(rPalette+$62).w
00004B0A 31FB 0000 98B0             		move.w	PalCyc_WWZFloorUW(pc,d0.w),(rWaterPal+$62).w
00004B10                            
00004B10 5238 C7CF                  		addq.b	#1,rPalCycIndex.w		; Increment the palette cycle index
00004B14 0C38 0005 C7CF             		cmpi.b	#5,rPalCycIndex.w		; Has it reached the end of the cycle?
00004B1A 6500                       		bcs.s	.End				; If not, branch
00004B1C 4238 C7CF                  		clr.b	rPalCycIndex.w		; Reset the palette cycle index
00004B20                            
00004B20                            .End:
00004B20 4E75                       		rts
00004B22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B22                            PalCyc_WWZFloor:
00004B22 0C28 0000 00EE 0000 0EEE   		dc.w	$C28, $000, $0EE, $000, $EEE
00004B2C                            PalCyc_WWZFloorUW:
00004B2C 0E48 0220 02EE 0220 0EEE   		dc.w	$E48, $220, $2EE, $220, $EEE
00004B36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B36                            ; Animated art routines
00004B36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B36                            Level_AniArtRouts:
00004B36 0000 0000                  		dc.l	AniArt_WWZ			; Wacky Workbench
00004B3A 0000 0000                  		dc.l	AniArt_WWZ
00004B3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B3E                            ; Wacky Workbench animated art routine
00004B3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B3E                            AniArt_WWZ:
00004B3E 45FA 0000                  		lea	.AniData(pc),a2			; Tutorial animated art data
00004B42 6000 F81E                  		bra.w	AniArt_DoAnimate		; Handle animations
00004B46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B46                            .AniData:
00004B46 0002                       		dc.w	2
00004B48                            
00004B48                            		lvlAniDat 3, ArtUnc_Electricity, $162, 4, 8
00004B48 0000 0000                M 	dc.l	(3&$ff)<<24|artunc_electricity
00004B4C 2C40                     M 	dc.w	(($162&$7ff)<<5)
00004B4E 0408                     M 	dc.b	4,8
00004B50 0008 1018                  		dc.b	0, 8, $10, $18
00004B54                            
00004B54                            		lvlAniDat 1, ArtUnc_ElectricOrbs, $15E, $E, 4
00004B54 0000 0000                M 	dc.l	(1&$ff)<<24|artunc_electricorbs
00004B58 2BC0                     M 	dc.w	(($15e&$7ff)<<5)
00004B5A 0E04                     M 	dc.b	$e,4
00004B5C 0004 0400 0404 0804 0408+  		dc.b	0, 4, 4, 0, 4, 4, 8, 4, 4, 8, $C, 4, 4, $C
00004B6A                            
00004B6A                            		lvlAniDat 4, ArtUnc_Sirens, $A8, 8, 4
00004B6A 0000 0000                M 	dc.l	(4&$ff)<<24|artunc_sirens
00004B6E 1500                     M 	dc.w	(($a8&$7ff)<<5)
00004B70 0804                     M 	dc.b	8,4
00004B72 0004 0408 0C0C 0C0C        		dc.b	0, 4, 4, 8, $C, $C, $C, $C
00004B7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B7A                            ; Level drawing initialization and update routines
00004B7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B7A                            ; PARAMETERS:
00004B7A                            ;	a1.l	- Camera RAM
00004B7A                            ;	a3.l	- Row plane buffer
00004B7A                            ;	a4.l	- Column plane buffer
00004B7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B7A                            ; RETURNS:
00004B7A                            ;	Nothing
00004B7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B7A                            Level_RenderRouts:
00004B7A 0000 2742                  		dc.l	General_InitFG			; Wacky Workbench
00004B7E 0000 0000                  		dc.l	WWZ_InitBG
00004B82 0000 2762                  		dc.l	General_UpdateFG
00004B86 0000 0000                  		dc.l	WWZ_UpdateBG
00004B8A 0000 2742                  		dc.l	General_InitFG
00004B8E 0000 0000                  		dc.l	WWZ_InitBG
00004B92 0000 2762                  		dc.l	General_UpdateFG
00004B96 0000 0000                  		dc.l	WWZ_UpdateBG
00004B9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B9A                            ; Wacky Workbench background initialization
00004B9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B9A                            WWZ_InitBG:
00004B9A 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
00004B9E 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004BA2 E440                       		asr.w	#2,d0				; Divide by $20
00004BA4 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004BA8                            
00004BA8 6100 DED2                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00004BAC                            
00004BAC 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004BB0 6000 DF2A                  		bra.w	ScrollSections			; Scroll the planes
00004BB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BB4                            ; Wacky Workbench background update
00004BB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BB4                            WWZ_UpdateBG:
00004BB4 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
00004BB8 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004BBC E440                       		asr.w	#2,d0				; Divide by $20
00004BBE 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004BC2                            
00004BC2 6100 DF0A                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00004BC6 781F                       		moveq	#(512/16)-1,d4			; Number of blocks per column
00004BC8 6100 DCAA                  		bsr.w	Level_UpdatePlaney		; Update the plane
00004BCC                            
00004BCC 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004BD0 6000 DF0A                  		bra.w	ScrollSections			; Scroll the planes
00004BD4                            ; --------------------------------------------------------------------------------------------------------------------------------------
00004BD4                            		scrollInit WWZ_Scroll
00004BD4                          M scroll_label	equs	"wwz_scroll"
00004BD4 0000                     M wwz_scroll:	dc.w	((wwz_scroll_end-wwz_scroll-2)/6)-1
00004BD6                            
00004BD6                            		; CEILING LIGHTS
00004BD6                            		scrollSection	 48, $80
00004BD6 0080 0000 0030           M 	dc.w	$80,0,48
00004BDC                            		scrollSection	 32, $60
00004BDC 0060 0000 0020           M 	dc.w	$60,0,32
00004BE2                            		scrollSection	 32, $50
00004BE2 0050 0000 0020           M 	dc.w	$50,0,32
00004BE8                            		scrollSection	 24, $40
00004BE8 0040 0000 0018           M 	dc.w	$40,0,24
00004BEE                            		scrollSection	 24, $38
00004BEE 0038 0000 0018           M 	dc.w	$38,0,24
00004BF4                            		scrollSection	 16, $30
00004BF4 0030 0000 0010           M 	dc.w	$30,0,16
00004BFA                            		scrollSection	 16, $2C
00004BFA 002C 0000 0010           M 	dc.w	$2c,0,16
00004C00                            		scrollSection	 16, $28
00004C00 0028 0000 0010           M 	dc.w	$28,0,16
00004C06                            		scrollSection	 16, $24
00004C06 0024 0000 0010           M 	dc.w	$24,0,16
00004C0C                            		scrollSection	 16, $20
00004C0C 0020 0000 0010           M 	dc.w	$20,0,16
00004C12                            
00004C12                            		; BACK WALL
00004C12                            		scrollSection	160, $40
00004C12 0040 0000 00A0           M 	dc.w	$40,0,160
00004C18                            
00004C18                            		; FRONT WALL
00004C18                            		scrollSection	368, $80
00004C18 0080 0000 0170           M 	dc.w	$80,0,368
00004C1E                            
00004C1E                            		scrollEnd
00004C1E                          M wwz_scroll_end:
00004C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C1E                            ; Wacky Workbench level data
00004C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C1E                            WWZ_Layout:
00004C1E                            		incbin	"Level/Level Data/Wacky Workbench/Layout.bin"
00004DFC                            		even
00004DFC                            WWZ_Chunks:
00004DFC                            		incbin	"Level/Level Data/Wacky Workbench/Chunks.bin"
0000584C                            		even
0000584C                            WWZ_Blocks:
0000584C                            		incbin	"Level/Level Data/Wacky Workbench/Blocks.bin"
00005F12                            		even
00005F12                            WWZ_Tiles:
00005F12                            		incbin	"Level/Level Data/Wacky Workbench/Tiles.kosm.bin"
00007640                            		even
00007640 FFFF 0000 0000             		dc.w	$FFFF, 0, 0
00007646                            WWZ_Objects:
00007646                            		incbin	"Level/Level Data/Wacky Workbench/Objects.bin"
00007802                            		even
00007802                            WWZ_Rings:
00007802                            		incbin	"Level/Level Data/Wacky Workbench/Rings.bin"
00007AD2                            		even
00007AD2                            WWZ_Pal:
00007AD2 007F                       		dc.w	$100>>1-1
00007AD4                            		incbin	"Level/Level Data/Wacky Workbench/Palette.pal.bin"
00007B54                            		incbin	"Level/Level Data/Wacky Workbench/Palette (Water).pal.bin"
00007BD4                            		even
00007BD4                            WWZ_Collision:
00007BD4 0000 0000 0000 0000 0000+  		dc.l	.ColData, .Angles, .Heights, .HeightsR
00007BE4                            .ColData:
00007BE4                            		incbin	"Level/Level Data/Wacky Workbench/Collision.bin"
000081E4                            		even
000081E4                            .Angles:
000081E4                            		incbin	"Level/Level Data/Wacky Workbench/Angle Values.bin"
000082E4                            		even
000082E4                            .Heights:
000082E4                            		incbin	"Level/Level Data/Wacky Workbench/Height Values.bin"
000092E4                            		even
000092E4                            .HeightsR:
000092E4                            		incbin	"Level/Level Data/Wacky Workbench/Height Values (Rotated).bin"
0000A2E4                            		even
0000A2E4                            ArtUnc_Electricity:
0000A2E4                            		incbin	"Level/Level Data/Wacky Workbench/Electricity.bin"
0000A6E4                            		even
0000A6E4                            ArtUnc_ElectricOrbs:
0000A6E4                            		incbin	"Level/Level Data/Wacky Workbench/Electric Orbs.bin"
0000A8E4                            		even
0000A8E4                            ArtUnc_Sirens:
0000A8E4                            		incbin	"Level/Level Data/Wacky Workbench/Sirens.bin"
0000AAE4                            		even
0000AAE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AAE4                            ; Main level PLCs
0000AAE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AAE4                            PLC_LevelMain:
0000AAE4 000A                       		dc.w	$A
0000AAE6 0000 0000                  		dc.l	ArtKosM_Chkpoint
0000AAEA AFC0                       		dc.w	$AFC0
0000AAEC 0000 0000                  		dc.l	ArtKosM_Monitor
0000AAF0 B100                       		dc.w	$B100
0000AAF2 0000 0000                  		dc.l	ArtKosM_SpringH
0000AAF6 B740                       		dc.w	$B740
0000AAF8 0000 0000                  		dc.l	ArtKosM_SpringV
0000AAFC B940                       		dc.w	$B940
0000AAFE 0000 0000                  		dc.l	ArtKosM_SpringD
0000AB02 BB20                       		dc.w	$BB20
0000AB04 0000 0000                  		dc.l	ArtKosM_HUD
0000AB08 D000                       		dc.w	$D000
0000AB0A 0000 0000                  		dc.l	ArtKosM_WaterSurface
0000AB0E D200                       		dc.w	$D200
0000AB10 0000 0000                  		dc.l	ArtKosM_SpikesN
0000AB14 D500                       		dc.w	$D500
0000AB16 0000 0000                  		dc.l	ArtKosM_SpikesS
0000AB1A D580                       		dc.w	$D580
0000AB1C 0000 0000                  		dc.l	ArtKosM_RingSparkle
0000AB20 D700                       		dc.w	$D700
0000AB22 0000 0000                  		dc.l	ArtKosM_Explosion
0000AB26 D800                       		dc.w	$D800
0000AB28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB28                            ; Level PLCs
0000AB28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB28                            Level_PLCs:
0000AB28 0000 0000                  		dc.l	PLC_WWZ
0000AB2C 0000 0000                  		dc.l	PLC_WWZ
0000AB30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB30                            ; Wacky Workbench PLCs
0000AB30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB30                            PLC_WWZ:
0000AB30 0000                       		dc.w	0
0000AB32 0000 0000                  		dc.l	ArtKosM_Bumper
0000AB36 6B60                       		dc.w	$6B60
0000AB38                            	;	dc.l	ArtKosM_Orbinaut
0000AB38                            	;	dc.w	$71A0
0000AB38                            	;	dc.l	ArtKosM_Diamond
0000AB38                            	;	dc.w	$7580
0000AB38                            	;	dc.l	ArtKosM_CNZBarrel
0000AB38                            	;	dc.w	$7A00
0000AB38                            	;	dc.l	ArtKosM_Slicer
0000AB38                            	;	dc.w	$8000
0000AB38                            	;	dc.l	ArtKosM_ShlCrker
0000AB38                            	;	dc.w	$8400
0000AB38                            	;	dc.l	ArtKosM_Asteron
0000AB38                            	;	dc.w	$8880
0000AB38                            	;	dc.l	ArtKosM_Harpoon
0000AB38                            	;	dc.w	$8A60
0000AB38                            	;	dc.l	ArtKosM_WFZBoss
0000AB38                            	;	dc.w	$9000
0000AB38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB38                            ; Art
0000AB38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AB38                            ArtKosM_HUD:
0000AB38                            		incbin	"Level/Objects/HUD/Art - HUD Base.kosm.bin"
0000ABAE                            		even
0000ABAE                            ArtKosM_RingSparkle:
0000ABAE                            		incbin	"Level/Objects/Ring/Art - Sparkle.kosm.bin"
0000ABFA 00                         		even
0000ABFA                            ArtUnc_Ring:
0000ABFA                            		incbin	"Level/Objects/Ring/Art - Ring.unc.bin"
0000AFFA                            		even
0000AFFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AFFA                            ; Object index
0000AFFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000AFFA                            Level_ObjIndex:
0000AFFA 0000 0000                  		dc.l	ObjMonitor
0000AFFE 0000 0000                  		dc.l	ObjSpike
0000B002 0000 0000                  		dc.l	ObjSpring
0000B006 0000 0000                  		dc.l	ObjCheckpoint
0000B00A 0000 0000                  		dc.l	ObjNull			;ObjSlicer
0000B00E 0000 0000                  		dc.l	ObjNull			;ObjShlCrker
0000B012 0000 0000                  		dc.l	ObjNull			;ObjAsteron
0000B016 0000 0000                  		dc.l	ObjNull			;ObjWFZBoss
0000B01A 0000 0000                  		dc.l	ObjWallSpring
0000B01E 0000 0000                  		dc.l	ObjNull			;ObjHarpoon
0000B022 0000 0000                  		dc.l	ObjBallMode
0000B026 0000 0000                  		dc.l	ObjBumper
0000B02A 0000 0000                  		dc.l	ObjNull			;ObjCNZBarrel
0000B02E 0000 0000                  		dc.l	ObjNull			;ObjDiamond
0000B032 0000 0000                  		dc.l	ObjNull			;ObjOrbinaut
0000B036                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B036                            ; Objects
0000B036                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B036                            ObjNull:
0000B036 4EF8 19E0                  		jmp	DeleteObject
0000B03A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B03A                            		include	"Level/Objects/Mighty/Code.asm"		; Mighty object
0000B03A                            ; =========================================================================================================================================================
0000B03A                            ; Mighty The Armadillo in PRISM PARADISE
0000B03A                            ; By Nat The Porcupine 2021
0000B03A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B03A                            ; Sonic object
0000B03A                            ; =========================================================================================================================================================
0000B03A =00000600                  TOP_SPD		EQU	$600				; Top speed
0000B03A =0000000C                  ACC_SPD		EQU	$C				; Acceleration
0000B03A =00000080                  DEC_SPD		EQU	$80				; Deceleration
0000B03A =00000680                  JUMP_HEIGHT	EQU	$680				; Jump height
0000B03A =00000400                  MIN_JMP_HEIGHT	EQU	$400				; Minimum jump height
0000B03A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B03A                            		rsset	oLvlSSTs
0000B03A =00000030                  oInitColH	rs.b	1				; Initial collision height
0000B03A =00000031                  oInitColW	rs.b	1				; Initial collision width
0000B03A =00000032                  oTopSolid	rs.b	1				; Top solid bit
0000B03A =00000033                  oLRBSolid	rs.b	1				; LRB solid bit
0000B03A =00000034                  oTopSpd		rs.w	1				; Top speed
0000B03A =00000036                  oAcc		rs.w	1				; Acceleration
0000B03A =00000038                  oDec		rs.w	1				; Deceleration
0000B03A =0000003A                  oFlipDir	rs.w	0				; Flip direction
0000B03A =0000003A                  oGVel		rs.w	1				; Ground velocity
0000B03A =0000003C                  oInteract	rs.w	1				; Interacted object space pointer
0000B03A =0000003E                  oAirTimer	rs.b	1				; Air timer
0000B03A =0000003F                  oMoveLock	rs.b	1				; Move lock timer
0000B03A =00000040                  oJumping	rs.b	1				; Jumping flag
0000B03A =00000041                  oAngle		rs.b	1				; Angle
0000B03A =00000042                  oInvulTime	rs.b	1				; Invulnerability timer
0000B03A =00000043                  oDeathTimer	rs.b	1				; Death timer
0000B03A =00000044                  oScrlDelay	rs.b	1				; Look up and down scroll delay counter
0000B03A =00000045                  oDashFlag	rs.b	1				; Dash flags
0000B03A =00000046                  oDashTimer	rs.b	1				; Dash timer
0000B03A =00000047                  oFlipAngle	rs.b	1				; Flip angle about the X axis
0000B03A =00000048                  oFlipTurned	rs.b	1				; Inverted flip flag
0000B03A =00000049                  oFlipRemain	rs.b	1				; Remaining flips to do
0000B03A =0000004A                  oFlipSpeed	rs.b	1				; Flip speed
0000B03A =0000004B                  oBallMode	rs.b	1				; Ball mode flag
0000B03A =0000004C                  oHangAniTime	rs.b	1				; Hang animation timer
0000B03A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B03A                            ObjMighty:
0000B03A 7000                       		moveq	#0,d0
0000B03C 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
0000B040 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
0000B044                            	nextObject
0000B044 3068 0004                M 	movea.w	onext(a0),a0
0000B048 2250                     M 	move.l	oaddr(a0),a1
0000B04A 4ED1                     M 	jmp	(a1)
0000B04C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B04C                            .Index:
0000B04C 6000 0000                  		bra.w	ObjMighty_Init			; Initialization(00)
0000B050 6000 0000                  		bra.w	ObjMighty_Main			; Main		(04)
0000B054 6000 0000                  		bra.w	ObjMighty_Hurt			; Hurt		(08)
0000B058 6000 0000                  		bra.w	ObjMighty_Dead			; Dead		(0C)
0000B05C 6000 0000                  		bra.w	ObjMighty_Gone			; Gone		(10)
0000B060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B060                            ; Initialization routine
0000B060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B060                            ObjMighty_Init:
0000B060 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
0000B064                            
0000B064 117C 0009 002C             		move.b	#9,oColW(a0)			; Collision width
0000B06A 117C 0013 002D             		move.b	#$13,oColH(a0)			; Collision height
0000B070 1168 002C 0031             		move.b	oColW(a0),oInitColW(a0)		; Set initial collision width
0000B076 1168 002D 0030             		move.b	oColH(a0),oInitColH(a0)		; Set initial collision height
0000B07C 217C 0000 0000 0010        		move.l	#Map_ObjMighty,oMap(a0)		; Mappings
0000B084 317C 0780 000E             		move.w	#$780,oVRAM(a0)			; Sprite tile properties
0000B08A                            	displaySprite	2,a0,a1,0			; Priority
0000B08A 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000B090 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000B094 3149 000A                M 	move.w	a1,odrawprev(a0)
0000B098 3348 0008                M 	move.w	a0,odrawnext(a1)
0000B09C 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000B0A0 0C78 BE6A BE74           M 	cmp.w	#rdispinput+(2*dsize),rdispinput+dprev+(2*dsize).w
0000B0A6 6600                     M 	bne.s	.no_199
0000B0A8 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000B0AC                          M .no_199
0000B0AC 117C 0018 0017             		move.b	#$18,oDrawW(a0)			; Sprite width
0000B0B2 117C 0018 001B             		move.b	#$18,oDrawH(a0)			; Sprite height
0000B0B8 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0000B0BE                            
0000B0BE 117C 000C 0032             		move.b	#$C,oTopSolid(a0)		; Top solid bit
0000B0C4 117C 000D 0033             		move.b	#$D,oLRBSolid(a0)		; LRB solid bit
0000B0CA 117C 001E 003E             		move.b	#$1E,oAirTimer(a0)		; Set air timer
0000B0D0 50D0                       		st	oPrevDPLC(a0)			; Reset saved DPLC frame
0000B0D2 4228 0049                  		clr.b	oFlipRemain(a0)			; No flips remaining
0000B0D6 117C 0004 004A             		move.b	#4,oFlipSpeed(a0)		; Flip speed
0000B0DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0DC                            ; Main routine
0000B0DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B0DC                            ObjMighty_Main:
0000B0DC 4A38 C768                  		tst.b	rMoveCheat.w
0000B0E0 6700                       		beq.s	.NoPlacementEnter
0000B0E2 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000B0E8 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000B0EA 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000B0F0 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000B0F6 4E75                       		rts
0000B0F8                            
0000B0F8                            .NoPlacementEnter:
0000B0F8 0828 0002 000C             		btst	#2,oFlags(a0)			; Are the controls locked?
0000B0FE 6600                       		bne.s	.Update				; If so, branch
0000B100 31F8 C740 F8D4             		move.w	rP1Data.w,rCtrl.w		; Set the player's control data
0000B106                            
0000B106                            .Update:
0000B106                            	;	btst	#1,oStatus(a0)
0000B106                            	;	bne.s	.NotOnGround
0000B106                            
0000B106                            ;.NotOnGround:
0000B106 6100 0000                  		bsr.w	ObjMighty_Water			; Handle Sonic in water
0000B10A 6100 0000                  		bsr.w	ObjMighty_GetPhysics		; Update Sonic's physics
0000B10E 6100 0000                  		bsr.w	ObjMighty_DoModes		; Do modes
0000B112 6100 0000                  		bsr.w	ObjMighty_LvlBound		; Handle level boundaries
0000B116 4EB8 48BA                  		jsr	PlayerDoObjCollision		; Do object collision
0000B11A                            
0000B11A 6100 0000                  		bsr.w	ObjMighty_Animate		; Animate sprite
0000B11E 6100 0000                  		bsr.w	ObjMighty_Display		; Display sprite
0000B122 6000 0000                  		bra.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000B126                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B126                            ; Handle the extended camera
0000B126                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B126                            ObjMighty_ExtendedCam:
0000B126 3238 F8D2                  		move.w	rCamXPosCenter.w,d1		; Get camera X center
0000B12A 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B12E 6A00                       		bpl.s	.PosGVel			; Get absolute value
0000B130 4440                       		neg.w	d0				; ''
0000B132                            
0000B132                            .PosGVel:
0000B132 0C40 0600                  		cmpi.w	#$600,d0			; Is Sonic going at 6 pixels/frame?
0000B136 6500                       		bcs.s	.ResetXShift			; If not, branch
0000B138 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
0000B13C 6A00                       		bpl.s	.MoveRight			; If so, branch
0000B13E 5441                       		addq.w	#2,d1				; Move right
0000B140 0C41 00E0                  		cmpi.w	#$E0,d1				; Cap it
0000B144 6500                       		bcs.s	.SetShift			; ''
0000B146 323C 00E0                  		move.w	#$E0,d1				; ''
0000B14A 6000                       		bra.s	.SetShift			; Continue
0000B14C                            
0000B14C                            .MoveRight:
0000B14C 5541                       		subq.w	#2,d1				; Move left
0000B14E 0C41 0060                  		cmpi.w	#$60,d1				; Cap it
0000B152 6400                       		bcc.s	.SetShift			; ''
0000B154 323C 0060                  		move.w	#$60,d1				; ''
0000B158 6000                       		bra.s	.SetShift			; Continue
0000B15A                            
0000B15A                            .ResetXShift:
0000B15A 0C41 00A0                  		cmpi.w	#$A0,d1				; Are we already back at the center?
0000B15E 6700                       		beq.s	.SetShift			; If so, branch
0000B160 6400                       		bcc.s	.ReduceShift			; If we have to go back left, branch
0000B162 5441                       		addq.w	#2,d1				; Move back right
0000B164 6000                       		bra.s	.SetShift			; Continue
0000B166                            
0000B166                            .ReduceShift:
0000B166 5541                       		subq.w	#2,d1				; Move back left
0000B168                            
0000B168                            .SetShift:
0000B168 31C1 F8D2                  		move.w	d1,rCamXPosCenter.w		; Set camera X center
0000B16C 4E75                       		rts
0000B16E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B16E                            ; Update Sonic's physics
0000B16E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B16E                            ObjMighty_GetPhysics:
0000B16E 7000                       		moveq	#0,d0
0000B170 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000B176 6700                       		beq.s	.GetOffset			; If not, branch
0000B178 7008                       		moveq	#8,d0				; Set the underwater bit
0000B17A                            
0000B17A                            .GetOffset:
0000B17A 43FB 0000                  		lea	ObjMighty_Physics(pc,d0.w),a1	; Get pointer to correct physics values
0000B17E 2159 0034                  		move.l	(a1)+,oTopSpd(a0)		; Set top speed and acceleration
0000B182 3151 0038                  		move.w	(a1),oDec(a0)			; Set deceleration
0000B186 4E75                       		rts
0000B188                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B188                            ; Physics values
0000B188                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B188                            ; FORMAT:
0000B188                            ;	dc.w	TOP SPEED, ACCELERATION, DECELERATION, 0
0000B188                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B188                            ObjMighty_Physics:
0000B188 0600 000C 0080 0000        		dc.w	TOP_SPD,     ACC_SPD,     DEC_SPD,     0; Normal
0000B190 0300 0006 0040 0000        		dc.w	TOP_SPD/2,   ACC_SPD/2,   DEC_SPD/2,   0; Underwater
0000B198                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B198                            ; Handle Sonic in the water
0000B198                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B198                            ObjMighty_Water:
0000B198 4A38 F8F4                  	tst.b	rWaterFlag.w			; Is there water in the level?
0000B19C 6600                       	bne.s	.HandleWater			; If so, branch
0000B19E                            
0000B19E                            .End:
0000B19E 4E75                       	rts
0000B1A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1A0                            .HandleWater:
0000B1A0 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
0000B1A4 B068 0018                  		cmp.w	oYPos(a0),d0			; Is Lover in the water?
0000B1A8 6C00                       		bge.s	.NotInWater			; If not, branch
0000B1AA                            
0000B1AA 08E8 0006 0028             		bset	#6,oStatus(a0)			; Set the "in water" flag
0000B1B0 66EC                       		bne.s	.End				; If Lover is already in the water, branch
0000B1B2                            
0000B1B2 E0E8 001C                  		asr.w	oXVel(a0)			; Make Lover move slower
0000B1B6 E0E8 001E                  		asr.w	oYVel(a0)
0000B1BA E0E8 001E                  		asr.w	oYVel(a0)
0000B1BE 67DE                       		beq.s	.End				; If a splash doesn't need to be created, branch
0000B1C0                            
0000B1C0                            		playSnd	#sSplash, 2			; Play splash sound
0000B1C0 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
0000B1C6 4E75                       		rts
0000B1C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1C8                            .NotInWater:
0000B1C8 08A8 0006 0028             		bclr	#6,oStatus(a0)			; Clear "in water" flag
0000B1CE 67CE                       		beq.s	.End				; If Lover was already out of the water, branch
0000B1D0                            
0000B1D0 0C28 0010 0025             		cmpi.b	#$10,oRoutine(a0)			; Is Lover falling back from getting hurt?
0000B1D6 6700                       		beq.s	.ChkSplash			; If so, branch
0000B1D8 E1E8 001E                  		asl	oYVel(a0)			; Make Lover move faster vertically
0000B1DC                            
0000B1DC                            .ChkSplash:
0000B1DC 4A68 001E                  		tst.w	oYVel(a0)			; Does a splash need to be created?
0000B1E0 67BC                       		beq.s	.End				; If not, branch
0000B1E2                            
0000B1E2 0C68 F000 001E             		cmpi.w	#-$1000,oYVel(a0)		; Is Lover moving more than -$10 pixels per frame?
0000B1E8 6E00                       		bgt.s	.PlaySplashSnd			; If not, branch
0000B1EA 317C F000 001E             		move.w	#-$1000,oYVel(a0)		; Cap the speed
0000B1F0                            
0000B1F0                            .PlaySplashSnd:
0000B1F0                            		playSnd	#sSplash, 2			; Play splash sound
0000B1F0 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
0000B1F6 4E75                       		rts
0000B1F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1F8                            ; Do Sonic's modes
0000B1F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B1F8                            ObjMighty_DoModes:
0000B1F8 0828 0000 000C             		btst	#0,oFlags(a0)			; Is running Sonic's mode disabled?
0000B1FE 6600                       		bne.s	.NoMode				; If so, branch
0000B200                            
0000B200 7000                       		moveq	#0,d0
0000B202 1028 0028                  		move.b	oStatus(a0),d0			; Get status
0000B206 0240 0006                  		andi.w	#6,d0				; Only get mode bits
0000B20A D040                       		add.w	d0,d0
0000B20C 4EBB 0000                  		jsr	ObjMighty_Modes(pc,d0.w)	; Jump to the right routine
0000B210                            
0000B210 6100 FF14                  		bsr.w	ObjMighty_ExtendedCam		; Handle extended camera
0000B214 6100 0000                  		bsr.w	ObjMighty_ChkBounce		; Check for bouncy floor collision
0000B218 6100 0000                  		bsr.w	ObjMighty_ChkHang		; Check for hanging
0000B21C 6000 0000                  		bra.w	ObjMighty_ChkElectric		; Check for electricity
0000B220                            
0000B220                            .NoMode:
0000B220 4E75                       		rts
0000B222                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B222                            ; Sonic's modes
0000B222                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B222                            ObjMighty_Modes:
0000B222 6000 0000                  		bra.w	ObjMighty_MdGround		; Ground
0000B226 6000 0000                  		bra.w	ObjMighty_MdAir			; Air
0000B22A 6000 0000                  		bra.w	ObjMighty_MdRoll		; Roll
0000B22E 6000 0000                  		bra.w	ObjMighty_MdJump		; Jumping
0000B232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B232                            ; Ground mode
0000B232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B232                            ObjMighty_MdGround:
0000B232 6100 0000                  		bsr.w	ObjMighty_Peelout		; Handle the peelout
0000B236 6100 0000                  		bsr.w	ObjMighty_Spindash		; Handle the spindash
0000B23A 6100 0000                  		bsr.w	ObjMighty_ChkJump		; Check for jumping
0000B23E 6100 0000                  		bsr.w	ObjMighty_ChkRoll		; Check for rolling
0000B242 6100 0000                  		bsr.w	ObjMighty_MoveGround		; Do movement on the ground
0000B246 4EB8 1CF0                  		jsr	ObjectMove.w			; Allow movement
0000B24A 4EB8 3232                  		jsr	PlayerAnglePos			; Update position and angle along the ground
0000B24E                            
0000B24E 6100 0000                  		bsr.w	ObjMighty_SlopePush		; Affect Sonic's speed on a slope
0000B252 6100 0000                  		bsr.w	ObjMighty_FallOffSlope		; Check if Sonic is going to fall off the slope
0000B256                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B256                            ; Misc. updates
0000B256                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B256                            ObjMighty_MiscUpdates:
0000B256 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer finished?
0000B25A 6700                       		beq.s	.NoMoveLock			; If so, branch
0000B25C 5328 003F                  		subq.b	#1,oMoveLock(a0)		; Decrement the timer
0000B260                            
0000B260                            .NoMoveLock:
0000B260 4EB8 2F4A                  		jsr	sub_F846
0000B264 4A41                       		tst.w	d1
0000B266 6B00 0000                  		bmi.w	ObjMighty_GetKilled
0000B26A 4EB8 31DA                  		jsr	PlayerChkLeftWallDist		; Check for left wall collision
0000B26E 4A41                       		tst.w	d1				; Has Sonic entered the wall?
0000B270 6A00                       		bpl.s	.ChkRight			; If not, branch
0000B272 9368 0014                  		sub.w	d1,oXPos(a0)			; Fix Sonic's X position
0000B276                            
0000B276                            .ChkRight:
0000B276 4EB8 305E                  		jsr	PlayerChkRightWallDist		; Check for right wall collision
0000B27A 4A41                       		tst.w	d1				; Has Sonic entered the wall?
0000B27C 6A00                       		bpl.s	.End				; If not, branch
0000B27E D368 0014                  		add.w	d1,oXPos(a0)			; Fix Sonic's X position
0000B282                            
0000B282                            .End:
0000B282 4E75                       		rts
0000B284                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B284                            ; Air and jump modes
0000B284                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B284                            ObjMighty_MdJump:
0000B284                            ObjMighty_MdAir:
0000B284 4268 003C                  		clr.w	oInteract(a0)			; Sonic cannot be interacting with objects while in midair
0000B288 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; ''
0000B28E                            
0000B28E 0828 0003 000C             		btst	#3,oFlags(a0)			; Is Sonic hanging?
0000B294 6700                       		beq.s	.DoModes			; If not, branch
0000B296 6100 0000                  		bsr.w	ObjMighty_Hang			; Hang
0000B29A 6000                       		bra.s	.DoCol				; Continue
0000B29C                            
0000B29C                            .DoModes:
0000B29C 6100 0000                  		bsr.w	ObjMighty_JumpHeight		; Handle jump height
0000B2A0 6100 0000                  		bsr.w	ObjMighty_MoveAir		; Do movement
0000B2A4 4EB8 1D0A                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000B2A8 0C68 1000 001E             		cmpi.w	#$1000,oYVel(a0)		; Is Sonic moving down too fasr?
0000B2AE 6F00                       		ble.s	.NoCap				; If not, branch
0000B2B0 317C 1000 001E             		move.w	#$1000,oYVel(a0)		; Cap the downward speed
0000B2B6                            
0000B2B6                            .NoCap:
0000B2B6 6100 0000                  		bsr.w	ObjMighty_JumpAngle		; Reset Sonic's angle in mid air
0000B2BA                            
0000B2BA                            .DoCol:
0000B2BA 0828 0006 0028             		btst	#6,oStatus(a0)
0000B2C0 6700                       		beq.s	.NoWater
0000B2C2 0468 0028 001E             		subi.w	#$28,oYVel(a0)
0000B2C8                            
0000B2C8                            .NoWater:
0000B2C8 4EB8 2BB8                  		jsr	PlayerChkCollision		; Check for level collision
0000B2CC 6088                       		bra.s	ObjMighty_MiscUpdates
0000B2CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2CE                            ; Roll mode
0000B2CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2CE                            ObjMighty_MdRoll:
0000B2CE 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000B2D2 6600                       		bne.s	.NoJump				; If so, branch
0000B2D4 6100 0000                  		bsr.w	ObjMighty_ChkJump		; Check for jumping
0000B2D8                            
0000B2D8                            .NoJump:
0000B2D8 6100 0000                  		bsr.w	ObjMighty_RollSlopePush		; Push Sonic on a slope while rolling
0000B2DC 6100 0000                  		bsr.w	ObjMighty_MoveRoll		; Do movement
0000B2E0 4EB8 1CF0                  		jsr	ObjectMove.w			; Allow movement
0000B2E4 4EB8 3232                  		jsr	PlayerAnglePos			; Update position and angle along the ground
0000B2E8                            
0000B2E8 6100 0000                  		bsr.w	ObjMighty_FallOffSlope		; Check if Sonic is going to fall off the slope
0000B2EC 6000 FF68                  		bra.w	ObjMighty_MiscUpdates		; Do misc. updates
0000B2F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2F0                            ; Do movement on the ground
0000B2F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B2F0                            ObjMighty_MoveGround:
0000B2F0 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B2F4 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
0000B2F8 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
0000B2FC                            
0000B2FC 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
0000B300 6600 0000                  		bne.w	.ResetScr			; If so, branch
0000B304                            
0000B304 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left held?
0000B30A 6700                       		beq.s	.NotLeft			; If so, branch
0000B30C 6100 0000                  		bsr.w	ObjMighty_MoveLeft		; Move left
0000B310                            
0000B310                            .NotLeft:
0000B310 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right held?
0000B316 6700                       		beq.s	.NotRight			; If so, branch
0000B318 6100 0000                  		bsr.w	ObjMighty_MoveRight		; Move right
0000B31C                            
0000B31C                            .NotRight:
0000B31C 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B320 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B324 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000B328 6600 0000                  		bne.w	.ResetScr			; If Sonic is not on the floor, branch
0000B32C 4A68 003A                  		tst.w	oGVel(a0)			; Has Sonic already been halted?
0000B330 6600 0000                  		bne.w	.ResetScr			; If not, branch
0000B334                            
0000B334 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B33A 117C 0005 0020             		move.b	#5,oAni(a0)			; Set to ducking animation
0000B340                            
0000B340 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is Sonic standing on an object?
0000B346 6700 0000                  		beq.w	.ChkBalance			; If not, branch
0000B34A 3268 003C                  		movea.w	oInteract(a0),a1		; Get interacted object
0000B34E 4A29 0028                  		tst.b	oStatus(a1)			; Is Sonic standing on it?
0000B352 6B00                       		bmi.s	.ChkLookUp			; If not, branch
0000B354 7200                       		moveq	#0,d1
0000B356 1229 002C                  		move.b	oColW(a1),d1			; Get width of object
0000B35A 3401                       		move.w	d1,d2				; Copy it
0000B35C D442                       		add.w	d2,d2				; Double the copy
0000B35E 5942                       		subq.w	#4,d2				; Subtract 4 from the copy
0000B360 D268 0014                  		add.w	oXPos(a0),d1			; Add Sonic's X position
0000B364 9269 0014                  		sub.w	oXPos(a1),d1			; Subtract the object's X position
0000B368 0C41 0004                  		cmpi.w	#4,d1				; Is Sonic balancing on the left side of it?
0000B36C 6D00                       		blt.s	.BalanceOnObjLeft		; If so, branch
0000B36E B242                       		cmp.w	d2,d1				; Is Sonic balacning on the right side of it?
0000B370 6C00                       		bge.s	.BalanceOnObjRight		; If so, branch
0000B372 6000                       		bra.s	.ChkLookUp			; Continue
0000B374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B374                            .ChkBalance:
0000B374 4EB8 2F20                  		jsr	PlayerChkFloorDist		; Get floor distance
0000B378 0C41 000C                  		cmpi.w	#$C,d1				; Is Sonic balancing?
0000B37C 6D00                       		blt.s	.ChkLookUp			; If not, branch
0000B37E 0C28 0003 002E             		cmpi.b	#3,oNextTilt(a0)		; Is Sonic balancing on the right side?
0000B384 6600                       		bne.s	.ChkLeftBalance			; If not, branch
0000B386                            
0000B386                            .BalanceOnObjRight:
0000B386 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B38C 6000                       		bra.s	.SetBalanceAnim			; Set the animation
0000B38E                            
0000B38E                            .ChkLeftBalance:
0000B38E 0C28 0003 002F             		cmpi.b	#3,oTilt(a0)			; Is Sonic balancing on the left side?
0000B394 6600                       		bne.s	.ChkLookUp			; If not, branch
0000B396                            
0000B396                            .BalanceOnObjLeft:
0000B396 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B39C                            
0000B39C                            .SetBalanceAnim:
0000B39C 117C 0006 0020             		move.b	#6,oAni(a0)			; Set balancing animation
0000B3A2 6000                       		bra.s	.ResetScr			; Continue
0000B3A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B3A4                            .ChkLookUp:
0000B3A4 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is the up button being held?
0000B3AA 6700                       		beq.s	.ChkDown			; If not, branch
0000B3AC 117C 0007 0020             		move.b	#7,oAni(a0)			; Set to looking up animation
0000B3B2                            
0000B3B2 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
0000B3B6 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
0000B3BC 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000B3BE 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
0000B3C4 0C78 00C8 F8CC             		cmpi.w	#200,rCamYPosDist.w		; Has the camera finished scrolling?
0000B3CA 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B3CC 5478 F8CC                  		addq.w	#2,rCamYPosDist.w		; Scroll the camera
0000B3D0 6000                       		bra.s	.UpdateSpdOnGround		; Continue
0000B3D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B3D2                            .ChkDown:
0000B3D2 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is the down button being held?
0000B3D8 6700                       		beq.s	.ResetScr			; If not, branch
0000B3DA 117C 0008 0020             		move.b	#8,oAni(a0)			; Set to ducking animation
0000B3E0                            
0000B3E0 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
0000B3E4 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
0000B3EA 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000B3EC 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
0000B3F2 0C78 0008 F8CC             		cmpi.w	#8,rCamYPosDist.w		; Has the camera finished scrolling?
0000B3F8 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B3FA 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera
0000B3FE 6000                       		bra.s	.UpdateSpdOnGround		; Continue
0000B400                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B400                            .ResetScr:
0000B400 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000B404                            
0000B404                            .ResetScrPart2:
0000B404 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B40A 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000B40C 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B40E 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B412                            
0000B412                            .ScrollUp:
0000B412 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B416                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B416                            .UpdateSpdOnGround:
0000B416 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000B41A 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000B41E 6600                       		bne.s	.ApplySpeed			; If so, branch
0000B420                            
0000B420 3028 003A                  		move.w	oGVel(a0),d0			; Get current ground velocity
0000B424 6700                       		beq.s	.ApplySpeed			; If it's already 0, branch
0000B426 6B00                       		bmi.s	.SettleLeft			; Settle left if going left
0000B428                            
0000B428                            .SettleRight:
0000B428 9045                       		sub.w	d5,d0				; Slow down
0000B42A 6A00                       		bpl.s	.SetSpeed			; If it's not done, branch
0000B42C 7000                       		moveq	#0,d0				; Stop the movement
0000B42E 6000                       		bra.s	.SetSpeed			; Continue
0000B430                            
0000B430                            .SettleLeft:
0000B430 D045                       		add.w	d5,d0				; Slow down
0000B432 6B00                       		bmi.s	.SetSpeed			; If it's not done, branch
0000B434 7000                       		moveq	#0,d0				; Stop the movement
0000B436                            
0000B436                            .SetSpeed:
0000B436 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B43A                            
0000B43A                            .ApplySpeed:
0000B43A 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B43E 4EB8 1308                  		jsr	CalcSine.w			; Get the sine and cosine
0000B442 C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
0000B446 C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
0000B44A E081                       		asr.l	#8,d1				; Shift the values over
0000B44C E080                       		asr.l	#8,d0				; ''
0000B44E 3141 001C                  		move.w	d1,oXVel(a0)			; Set the X velocity
0000B452 3140 001E                  		move.w	d0,oYVel(a0)			; Set the Y velocity
0000B456                            
0000B456                            ObjMighty_CheckWalls:
0000B456 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B45A 0200 003F                  		andi.b	#$3F,d0				; Is Sonic on an angle?
0000B45E 6700                       		beq.s	.Skip				; If not, branch
0000B460 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B464 0600 0040                  		addi.b	#$40,d0				; Is Sonic on an upwards wall or ceiling?
0000B468 6B00                       		bmi.s	.End				; If so, branch
0000B46A                            
0000B46A                            .Skip:
0000B46A 7240                       		moveq	#$40,d1				; If going left, make the modifier $40
0000B46C 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
0000B470 6700                       		beq.s	.End				; Branch if not moving
0000B472 6B00                       		bmi.s	.CheckPush			; Branch if going left
0000B474 4441                       		neg.w	d1				; Negate the modifier
0000B476                            
0000B476                            .CheckPush:
0000B476 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B47A D001                       		add.b	d1,d0				; Add modifier
0000B47C                            		push.w	d0				; Save it
0000B47C 3F00                     M 	move.w	d0,-(sp)
0000B47E 4EB8 2DE8                  		jsr	PlayerCalcRoomInFront		; Calculate the distance in front of Sonic
0000B482                            		pop.w	d0				; Restore angle
0000B482 301F                     M 	move.w	(sp)+,d0
0000B484 4A41                       		tst.w	d1				; Is Sonic pushing into anything?
0000B486 6A00                       		bpl.s	.End				; If not, branch
0000B488 E141                       		asl.w	#8,d1				; Shift distance inside the collision
0000B48A 0600 0020                  		addi.b	#$20,d0				; Add $20 to the angle
0000B48E 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic pushing on a ceiling?
0000B492 6700                       		beq.s	.PushCeiling			; If so, branch
0000B494 0C00 0040                  		cmpi.b	#$40,d0				; Is Sonic pushing on a right wall?
0000B498 6700                       		beq.s	.PushRightWall			; If so, branch
0000B49A 0C00 0080                  		cmpi.b	#$80,d0				; Is Sonic pushing on a floor?
0000B49E 6700                       		beq.s	.PushFloor			; If so, branch
0000B4A0 D368 001C                  		add.w	d1,oXVel(a0)			; Push out to the right
0000B4A4 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
0000B4A8 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing right?
0000B4AE 6600                       		bne.s	.End				; If not, branch
0000B4B0 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
0000B4B6 4E75                       		rts
0000B4B8                            
0000B4B8                            .PushFloor:
0000B4B8 9368 001E                  		sub.w	d1,oYVel(a0)			; Push out upwards
0000B4BC 4E75                       		rts
0000B4BE                            
0000B4BE                            .PushRightWall:
0000B4BE 9368 001C                  		sub.w	d1,oXVel(a0)			; Push out to the left
0000B4C2 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
0000B4C6 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B4CC 6700                       		beq.s	.End				; If not, branch
0000B4CE 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
0000B4D4 4E75                       		rts
0000B4D6                            
0000B4D6                            .PushCeiling:
0000B4D6 D368 001E                  		add.w	d1,oYVel(a0)			; Push out downwards
0000B4DA                            
0000B4DA                            .End:
0000B4DA 4E75                       		rts
0000B4DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B4DC                            ; Move left on the ground
0000B4DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B4DC                            ObjMighty_MoveLeft:
0000B4DC 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
0000B4E0 6700                       		beq.s	.SetFlip			; If not moving yet, branch
0000B4E2 6A00                       		bpl.s	.Skid				; If moving right, check for skidding
0000B4E4                            
0000B4E4                            .SetFlip:
0000B4E4 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
0000B4EA 6600                       		bne.s	.MoveLeft			; If it was already set, branch
0000B4EC 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B4F2 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000B4F8                            
0000B4F8                            .MoveLeft:
0000B4F8 9045                       		sub.w	d5,d0				; Subtract acceleration
0000B4FA 3206                       		move.w	d6,d1				; Get top speed
0000B4FC 4441                       		neg.w	d1				; Negate it
0000B4FE B041                       		cmp.w	d1,d0				; Is Sonic moving faster than the top speed?
0000B500 6E00                       		bgt.s	.SetSpeed			; If not, branch
0000B502 D045                       		add.w	d5,d0				; Add acceleration back
0000B504 B041                       		cmp.w	d1,d0				; Is Sonic still moving faster than the top speed?
0000B506 6F00                       		ble.s	.SetSpeed			; If not, branch
0000B508 3001                       		move.w	d1,d0				; Cap at the top speed
0000B50A                            
0000B50A                            .SetSpeed:
0000B50A 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B50E 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
0000B512                            
0000B512                            .End:
0000B512 4E75                       		rts
0000B514                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B514                            .Skid:
0000B514 9044                       		sub.w	d4,d0				; Subtract deceleration
0000B516 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
0000B518                            
0000B518                            .Compare:
0000B518 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000B51A 6C00                       		bge.s	.SetSkidSpeed			; If not branch
0000B51C 7080                       		moveq	#-$80,d0			; Set speed to -$80
0000B51E                            
0000B51E                            .SetSkidSpeed:
0000B51E 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B522 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B526 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B52A 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
0000B52E 66E2                       		bne.s	.End				; If so, branch
0000B530 0C40 0400                  		cmpi.w	#$400,d0			; Is Sonic's speed at least 4 pixels per frame?
0000B534 6DDC                       		blt.s	.End				; If not, branch
0000B536 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
0000B53C 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
0000B542                            		playSnd	#sSkid, 2			; Play skid sound
0000B542 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
0000B548 4E75                       		rts
0000B54A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B54A                            ; Move right on the ground
0000B54A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B54A                            ObjMighty_MoveRight:
0000B54A 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
0000B54E 6B00                       		bmi.s	.Skid				; If it's negative, skid
0000B550 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
0000B556 6700                       		beq.s	.MoveRight			; Branch if it was already cleared
0000B558 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
0000B55E 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000B564                            
0000B564                            .MoveRight:
0000B564 D045                       		add.w	d5,d0				; Add acceleration
0000B566 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
0000B568 6D00                       		blt.s	.SetSpeed			; If not, branch
0000B56A 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000B56C B046                       		cmp.w	d6,d0				; Is Sonic still going at the top speed?
0000B56E 6C00                       		bge.s	.SetSpeed			; If not, branch
0000B570 3006                       		move.w	d6,d0				; Cap at top speed
0000B572                            
0000B572                            .SetSpeed:
0000B572 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B576 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
0000B57A                            
0000B57A                            .End:
0000B57A 4E75                       		rts
0000B57C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B57C                            .Skid:
0000B57C D044                       		add.w	d4,d0				; Add deceleration
0000B57E 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
0000B580                            
0000B580                            .Compare:
0000B580 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000B582 6F00                       		ble.s	.SetSkidSpeed			; If not, branch
0000B584 303C 0080                  		move.w	#$80,d0				; Set speed to $80
0000B588                            
0000B588                            .SetSkidSpeed:
0000B588 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
0000B58C 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B590 0600 0020                  		addi.b	#$20,d0				; Shift it
0000B594 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
0000B598 66E0                       		bne.s	.End				; If so, branch
0000B59A 0C40 FC00                  		cmpi.w	#-$400,d0			; Is Sonic's speed at least -4 pixels per frame?
0000B59E 6EDA                       		bgt.s	.End				; If not, branch
0000B5A0 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
0000B5A6 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
0000B5AC                            		playSnd	#sSkid, 2			; Play skid sound
0000B5AC 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
0000B5B2 4E75                       		rts
0000B5B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B5B4                            ; Do movement while rolling
0000B5B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B5B4                            ObjMighty_MoveRoll:
0000B5B4 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B5B8 E346                       		asl.w	#1,d6				; ''
0000B5BA 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
0000B5BE E245                       		asr.w	#1,d5				; ''
0000B5C0 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
0000B5C4 E444                       		asr.w	#2,d4				; ''
0000B5C6                            
0000B5C6 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
0000B5CA 6600 0000                  		bne.w	.UpdateSpd			; If so, branch
0000B5CE                            
0000B5CE 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
0000B5D4 6700                       		beq.s	.ChkRight			; If not, branch
0000B5D6 6100 0000                  		bsr.w	ObjMighty_RollLeft		; Handle left movement
0000B5DA                            
0000B5DA                            .ChkRight:
0000B5DA 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000B5E0 6700                       		beq.s	.Decelerate			; If not, branch
0000B5E2 6100 0000                  		bsr.w	ObjMighty_RollRight		; Handle right movement
0000B5E6                            
0000B5E6                            .Decelerate:
0000B5E6 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B5EA 6700                       		beq.s	.ChkStop			; If Sonic isn't moving, branch
0000B5EC 6B00                       		bmi.s	.DecLeft			; If Sonic is moving left, branch
0000B5EE                            
0000B5EE 9045                       		sub.w	d5,d0				; Decelerate
0000B5F0 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B5F2 7000                       		moveq	#0,d0				; Cap at 0
0000B5F4                            
0000B5F4                            .SetGVel:
0000B5F4 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B5F8 6000                       		bra.s	.ChkStop			; Continue
0000B5FA                            
0000B5FA                            .DecLeft:
0000B5FA D045                       		add.w	d5,d0				; Decelerate
0000B5FC 6400                       		bcc.s	.SetGVel2			; If Sonic hasn't stopped yet, branch
0000B5FE 7000                       		moveq	#0,d0				; Cap at 0
0000B600                            
0000B600                            .SetGVel2:
0000B600 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B604                            
0000B604                            .ChkStop:
0000B604 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic still moving?
0000B608 6600                       		bne.s	.UpdateSpd			; If so, branch
0000B60A                            
0000B60A 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000B60E 6600                       		bne.s	.KeepRoll			; If so, branch
0000B610 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Stop rolling
0000B616 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000B61C 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000B622 117C 0005 0020             		move.b	#5,oAni(a0)			; Use standing animation
0000B628 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
0000B62C 6000                       		bra.s	.UpdateSpd			; Continue
0000B62E                            
0000B62E                            .KeepRoll:
0000B62E 317C 0400 003A             		move.w	#$400,oGVel(a0)			; Speed up again
0000B634 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing right?
0000B63A 6700                       		beq.s	.UpdateSpd			; If so, branch
0000B63C 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B640                            
0000B640                            .UpdateSpd:
0000B640 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B644 4EB8 1308                  		jsr	CalcSine.w			; Get sine and cosine
0000B648 C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
0000B64C E080                       		asr.l	#8,d0				; Shift over
0000B64E 3140 001E                  		move.w	d0,oYVel(a0)			; Set Y velocity
0000B652 C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
0000B656 E081                       		asr.l	#8,d1				; Shift over
0000B658                            
0000B658 0C41 1000                  		cmpi.w	#$1000,d1			; Is the speed > $10 pixels per frame?
0000B65C 6F00                       		ble.s	.ChkLeftSpd			; If not, branch
0000B65E 323C 1000                  		move.w	#$1000,d1			; Cap the speed
0000B662                            
0000B662                            .ChkLeftSpd:
0000B662 0C41 F000                  		cmpi.w	#-$1000,d1			; Is the speed < -$10 pixels per frame?
0000B666 6C00                       		bge.s	.SetXVel			; If not, branch
0000B668 323C F000                  		move.w	#-$1000,d1			; Cap the speed
0000B66C                            
0000B66C                            .SetXVel:
0000B66C 3141 001C                  		move.w	d1,oXVel(a0)			; Set X velocity
0000B670 6000 FDE4                  		bra.w	ObjMighty_CheckWalls		; Check wall collision
0000B674                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B674                            ; Handle left movement for rolling
0000B674                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B674                            ObjMighty_RollLeft:
0000B674 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B678 6700                       		beq.s	.SetLeft			; If Sonic isn't moving, branch
0000B67A 6A00                       		bpl.s	.Dec				; If Sonic is moving right, branch
0000B67C                            
0000B67C                            .SetLeft:
0000B67C 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B682 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
0000B688 4E75                       		rts
0000B68A                            
0000B68A                            .Dec:
0000B68A 9044                       		sub.w	d4,d0				; Decelerate
0000B68C 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B68E 303C FF80                  		move.w	#-$80,d0			; Set new speed
0000B692                            
0000B692                            .SetGVel:
0000B692 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B696 4E75                       		rts
0000B698                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B698                            ; Handle left movement for rolling
0000B698                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B698                            ObjMighty_RollRight:
0000B698 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000B69C 6B00                       		bmi.s	.Dec				; If Sonic is moving left, branch
0000B69E 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B6A4 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
0000B6AA 4E75                       		rts
0000B6AC                            
0000B6AC                            .Dec:
0000B6AC D044                       		add.w	d4,d0				; Decelerate
0000B6AE 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000B6B0 303C 0080                  		move.w	#$80,d0				; Set new speed
0000B6B4                            
0000B6B4                            .SetGVel:
0000B6B4 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
0000B6B8 4E75                       		rts
0000B6BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B6BA                            ; Do movement in the air
0000B6BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B6BA                            ObjMighty_MoveAir:
0000B6BA 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
0000B6BE 3A28 0036                  		move.w	oAcc(a0),d5			; Get accleration
0000B6C2 DA45                       		add.w	d5,d5				; Double it
0000B6C4 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B6C8                            
0000B6C8 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
0000B6CE 6700                       		beq.s	.NotLeft			; If not, branch
0000B6D0 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
0000B6D6 9045                       		sub.w	d5,d0				; Subtract acceleration
0000B6D8 3206                       		move.w	d6,d1				; Get top speed
0000B6DA 4441                       		neg.w	d1				; Negate it
0000B6DC B041                       		cmp.w	d1,d0				; Has Sonic reached the top speed?
0000B6DE 6E00                       		bgt.s	.NotLeft			; If not, branch
0000B6E0 D045                       		add.w	d5,d0				; Add acceleration back
0000B6E2 B041                       		cmp.w	d1,d0				; Is Sonic still at top speed?
0000B6E4 6F00                       		ble.s	.NotLeft			; If not, branch
0000B6E6 3001                       		move.w	d1,d0				; Cap at top speed
0000B6E8                            
0000B6E8                            .NotLeft:
0000B6E8 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000B6EE 6700                       		beq.s	.NotRight			; If not, branch
0000B6F0 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
0000B6F6 D045                       		add.w	d5,d0				; Add acceleration
0000B6F8 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
0000B6FA 6D00                       		blt.s	.NotRight			; If not, branch
0000B6FC 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000B6FE B046                       		cmp.w	d6,d0				; Is Sonic still at top speed?
0000B700 6C00                       		bge.s	.NotRight			; If not, branch
0000B702 3006                       		move.w	d6,d0				; Cap at top speed
0000B704                            
0000B704                            .NotRight:
0000B704 3140 001C                  		move.w	d0,oXVel(a0)			; Set X velocity
0000B708                            
0000B708                            .ResetScr
0000B708 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B70E 6700                       		beq.s	.DecelerateAtPeak		; If so, branch
0000B710 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B712 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B716                            
0000B716                            .ScrollUp:
0000B716 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B71A                            
0000B71A                            .DecelerateAtPeak:
0000B71A 0C68 FC00 001E             		cmpi.w	#-$400,oYVel(a0)		; Is Sonic at least going -4 pixels per frame up?
0000B720 6500                       		bcs.s	.End				; If not, branch
0000B722 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B726 3200                       		move.w	d0,d1				; Save it
0000B728 EA41                       		asr.w	#5,d1				; Turn it into the acceleration
0000B72A 6700                       		beq.s	.End				; If it's 0, branch
0000B72C 6B00                       		bmi.s	.DecLeft			; If it's negative, branch
0000B72E                            
0000B72E                            .DecRight:
0000B72E 9041                       		sub.w	d1,d0				; Subtract accleration
0000B730 6400                       		bcc.s	.DecSetSpeed			; If it's not negative, branch
0000B732 7000                       		moveq	#0,d0				; Cap at 0
0000B734 6000                       		bra.s	.DecSetSpeed			; Continue
0000B736                            
0000B736                            .DecLeft:
0000B736 9041                       		sub.w	d1,d0				; Subtract acceleration
0000B738 6500                       		bcs.s	.DecSetSpeed			; If it's not positive, branch
0000B73A 7000                       		moveq	#0,d0				; Cap at 0
0000B73C                            
0000B73C                            .DecSetSpeed:
0000B73C 3140 001C                  		move.w	d0,oXVel(a0)			; Set thhe X velocity
0000B740                            
0000B740                            .End:
0000B740 4E75                       		rts
0000B742                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B742                            ; Handle level boundaries
0000B742                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B742                            ObjMighty_LvlBound:
0000B742 4A68 001E                  		tst.w	oYVel(a0)
0000B746 6A00                       		bpl.s	.XBound
0000B748 3228 0018                  		move.w	oYPos(a0),d1
0000B74C 0641 0010                  		addi.w	#$10,d1
0000B750 3038 F8CA                  		move.w	rMinCamY.w,d0		; Get upper boundary position
0000B754 B041                       		cmp.w	d1,d0				; Has Sonic touched the upper boundary?
0000B756 6F00                       		ble.s	.XBound				; If so, branch
0000B758 3140 0018                  		move.w	d0,oYPos(a0)
0000B75C 4268 001E                  		clr.w	oYVel(a0)
0000B760 4268 003A                  		clr.w	oGVel(a0)
0000B764                            
0000B764                            .XBound:
0000B764 2228 0014                  		move.l	oXPos(a0),d1			; Get X position
0000B768 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
0000B76C 48C0                       		ext.l	d0
0000B76E E180                       		asl.l	#8,d0				; Shift it
0000B770 D280                       		add.l	d0,d1				; Add to X position
0000B772 4841                       		swap	d1				; Get actual X position
0000B774 3038 F8C8                  		move.w	rMinCamX.w,d0		; Get left boundary position
0000B778 0640 0010                  		addi.w	#$10,d0				; ''
0000B77C B041                       		cmp.w	d1,d0				; Has Sonic touched the left boundary?
0000B77E 6E00                       		bgt.s	.TouchedSide			; If so, branch
0000B780 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Get max camera X position
0000B784 0640 0128                  		addi.w	#320-24,d0			; Get right boundary position
0000B788 B041                       		cmp.w	d1,d0				; Has Sonic touched the right boundary?
0000B78A 6F00                       		ble.s	.TouchedSide			; If so, branch
0000B78C                            
0000B78C                            .ChkBottom:
0000B78C 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
0000B790 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
0000B794 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic touched the bottom boundary?
0000B798 6D00                       		blt.s	.TouchedBottom			; If so, branch
0000B79A 4E75                       		rts
0000B79C                            
0000B79C                            .TouchedBottom:
0000B79C 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get target max camera Y position
0000B7A0 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Get current max camera Y position
0000B7A4 B240                       		cmp.w	d0,d1				; Are they the same?
0000B7A6 6D00                       		blt.s	.NoKill				; If not, branch
0000B7A8 6000 0000                  		bra.w	ObjMighty_GetKilled		; Get Sonic killed
0000B7AC                            
0000B7AC                            .NoKill:
0000B7AC 4E75                       		rts
0000B7AE                            
0000B7AE                            .TouchedSide:
0000B7AE 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
0000B7B2 3140 0014                  		move.w	d0,oXPos(a0)			; Move Sonic out of the boundary
0000B7B6 4228 0016                  		clr.b	oXPos+2(a0)			; Clear the subpixel of the X position
0000B7BA 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B7BE 60CC                       		bra.s	.ChkBottom			; Continue
0000B7C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B7C0                            ; Handle peelout
0000B7C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B7C0                            ObjMighty_Peelout:
0000B7C0 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the peelout?
0000B7C4 6700                       		beq.s	.ChkUp				; If not, branch
0000B7C6 6B00                       		bmi.s	.ChkLaunch			; If so, branch
0000B7C8 4E75                       		rts
0000B7CA                            
0000B7CA                            .ChkUp:
0000B7CA 0C28 0007 0020             		cmpi.b	#7,oAni(a0)			; Is Sonic looking up?
0000B7D0 6600 0000                  		bne.w	.End				; If not, branch
0000B7D4 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
0000B7D8 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B7DC 6700 0000                  		beq.w	.End				; If not, branch
0000B7E0                            
0000B7E0 4228 0020                  		clr.b	oAni(a0)			; Set to peelout charge animation
0000B7E4 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
0000B7E8 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
0000B7EE 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B7F4 6700                       		beq.s	.SetAni				; If so, branch
0000B7F6 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B7FA                            
0000B7FA                            .SetAni:
0000B7FA                            		playSnd	#sCharge, 2			; Play charge sound
0000B7FA 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000B800                            
0000B800 588F                       		addq.l	#4,sp				; Don't return to caller
0000B802 50E8 0045                  		st	oDashFlag(a0)			; Set the peelout flag
0000B806 4EF8 3232                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B80A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B80A                            .ChkLaunch:
0000B80A 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is up being held?
0000B810 6600 0000                  		bne.w	.Charge				; If so, branch
0000B814 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
0000B818                            
0000B818 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged up enough?
0000B81E 6600                       		bne.s	.StopSound			; If not, branch
0000B820                            
0000B820 4228 0020                  		clr.b	oAni(a0)			; Reset animation
0000B824 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
0000B82A 0828 0006 0028             		btst	#6,oStatus(a0)
0000B830 6700                       		beq.s	.NoWater
0000B832 E2E8 003A                  		lsr.w	oGVel(a0)
0000B836                            
0000B836                            .NoWater:
0000B836 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B83C 6700                       		beq.s	.FinishDash			; If not, branch
0000B83E 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B842                            
0000B842                            .FinishDash:
0000B842                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000B842 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000B848                            
0000B848 6000                       		bra.s	.DoUpdates			; Continue
0000B84A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B84A                            .Charge:
0000B84A 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged enough?
0000B850 6700                       		beq.s	.DoUpdates			; If so, branch
0000B852 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
0000B856 0668 0066 003A             		addi.w	#$66,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000B85C 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B862 6700                       		beq.s	.DoUpdates			; If so, branch
0000B864 0468 00CC 003A             		subi.w	#$66*2,oGVel(a0)		; Go the other way
0000B86A 6000                       		bra.s	.DoUpdates			; Continue
0000B86C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B86C                            .StopSound:
0000B86C 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B870                            
0000B870                            		playSnd	#sChargeStop, 2			; Play charge stop sound
0000B870 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
0000B876                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B876                            .DoUpdates:
0000B876 588F                       		addq.l	#4,sp				; Don't return to caller
0000B878 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B87E 6700                       		beq.s	.FinishUpdates			; If so, branch
0000B880 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B882 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B886                            
0000B886                            .ScrollUp:
0000B886 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B88A                            
0000B88A                            .FinishUpdates:
0000B88A 4EF8 3232                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B88E                            
0000B88E                            .End:
0000B88E 4E75                       		rts
0000B890                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B890                            ; Handle spindash
0000B890                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B890                            ObjMighty_Spindash:
0000B890 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the spindash?
0000B894 6700                       		beq.s	.ChkDown			; If not, branch
0000B896 6A00                       		bpl.s	.ChkLaunch			; If so, branch
0000B898 4E75                       		rts
0000B89A                            
0000B89A                            .ChkDown:
0000B89A 0C28 0008 0020             		cmpi.b	#8,oAni(a0)			; Is Sonic ducking?
0000B8A0 6600 0000                  		bne.w	.End				; If not, branch
0000B8A4 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
0000B8A8 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B8AC 6700 0000                  		beq.w	.End				; If not, branch
0000B8B0                            
0000B8B0 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
0000B8B4 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
0000B8BA 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B8C0 6700                       		beq.s	.SetAni				; If so, branch
0000B8C2 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B8C6                            
0000B8C6                            .SetAni:
0000B8C6 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000B8CC 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000B8D2 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000B8D6 117C 0002 0020             		move.b	#2,oAni(a0)			; Set to spin animation
0000B8DC                            
0000B8DC                            		playSnd	#sCharge, 2			; Play charge sound
0000B8DC 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000B8E2                            
0000B8E2 588F                       		addq.l	#4,sp				; Don't return to caller
0000B8E4 117C 0001 0045             		move.b	#1,oDashFlag(a0)		; Set the spindash flag
0000B8EA 4EF8 3232                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B8EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B8EE                            .ChkLaunch:
0000B8EE 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
0000B8F4 6600 0000                  		bne.w	.Charge				; If so, branch
0000B8F8 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
0000B8FC                            
0000B8FC 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged up enough?
0000B902 6600                       		bne.s	.StopSound			; If not, branch
0000B904                            
0000B904 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set the roll flag
0000B90A 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
0000B910 0828 0006 0028             		btst	#6,oStatus(a0)
0000B916 6700                       		beq.s	.NoWater
0000B918 E2E8 003A                  		lsr.w	oGVel(a0)
0000B91C                            
0000B91C                            .NoWater:
0000B91C 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B922 6700                       		beq.s	.FinishDash			; If not, branch
0000B924 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000B928                            
0000B928                            .FinishDash:
0000B928                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000B928 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000B92E                            
0000B92E 6000                       		bra.s	.DoUpdates			; Continue
0000B930                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B930                            .Charge:
0000B930 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged enough?
0000B936 6700                       		beq.s	.DoUpdates			; If so, branch
0000B938 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
0000B93C 0668 0046 003A             		addi.w	#$46,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000B942 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000B948 6700                       		beq.s	.DoUpdates			; If so, branch
0000B94A 0468 008C 003A             		subi.w	#$46*2,oGVel(a0)		; Go the other way
0000B950 6000                       		bra.s	.DoUpdates			; Continue
0000B952                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B952                            .StopSound:
0000B952 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
0000B956 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000B95C 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000B962 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
0000B966                            
0000B966                            		playSnd	#sChargeStop, 2			; Play charge stop sound
0000B966 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
0000B96C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B96C                            .DoUpdates:
0000B96C 588F                       		addq.l	#4,sp				; Don't return to caller
0000B96E 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000B974 6700                       		beq.s	.FinishUpdates			; If so, branch
0000B976 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000B978 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000B97C                            
0000B97C                            .ScrollUp:
0000B97C 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000B980                            
0000B980                            .FinishUpdates:
0000B980 4EF8 3232                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000B984                            
0000B984                            .End:
0000B984 4E75                       		rts
0000B986                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B986                            ; Check for jumping
0000B986                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000B986                            ObjMighty_ChkJump:
0000B986 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get pressed buttons
0000B98A 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000B98E 4A38 C768                  		tst.b	rMoveCheat.w
0000B992 6700                       		beq.s	.NoDebug
0000B994 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
0000B998                            
0000B998                            .NoDebug:
0000B998 4A00                       		tst.b	d0
0000B99A 6700 0000                  		beq.w	.End				; If not, branch
0000B99E                            
0000B99E 7000                       		moveq	#0,d0
0000B9A0 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B9A4 0600 0080                  		addi.b	#$80,d0				; Shift it to check the ceiling
0000B9A8 4EB8 2E5A                  		jsr	PlayerCalcRoomOverHead		; Get room over Sonic's head
0000B9AC 0C41 0006                  		cmpi.w	#6,d1				; Is it at least 6 pixels?
0000B9B0 6D00 0000                  		blt.w	.End				; If not, branch
0000B9B4                            
0000B9B4 343C 0680                  		move.w	#JUMP_HEIGHT,d2			; Standard jump height
0000B9B8 0828 0006 0028             		btst	#6,oStatus(a0)
0000B9BE 6700                       		beq.s	.NoWater
0000B9C0 0442 0300                  		subi.w	#$300,d2
0000B9C4                            
0000B9C4                            .NoWater:
0000B9C4 7000                       		moveq	#0,d0
0000B9C6 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000B9CA 0400 0040                  		subi.b	#$40,d0				; Shift it
0000B9CE 4EB8 1308                  		jsr	CalcSine.w			; Get the sine and cosine
0000B9D2 C3C2                       		muls.w	d2,d1				; Mutliply cosine with jump height
0000B9D4 C1C2                       		muls.w	d2,d0				; Mutliply sine with jump height
0000B9D6 E081                       		asr.l	#8,d1				; Shift the values over
0000B9D8 E080                       		asr.l	#8,d0				; ''
0000B9DA D368 001C                  		add.w	d1,oXVel(a0)			; Add to X velocity
0000B9DE D168 001E                  		add.w	d0,oYVel(a0)			; Add to Y velocity
0000B9E2 0028 0006 0028             		ori.b	#6,oStatus(a0)			; Set "in air" and roll flags
0000B9E8 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000B9EE 584F                       		addq.w	#4,sp				; Do not return to collaer
0000B9F0 50E8 0040                  		st	oJumping(a0)			; Set the jumping flag
0000B9F4                            		playSnd	#sLeap, 2			; Play jump sound
0000B9F4 11FC 0082 C4BD           M 	move.b	#sleap,(mqueue+((2)-1)).w
0000B9FA 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BA00 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BA06 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BA0A 117C 0002 0020             		move.b	#2,oAni(a0)			; Set jumping animation
0000BA10                            
0000BA10                            .End:
0000BA10 4E75                       		rts
0000BA12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA12                            ; Handle variable jumping
0000BA12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA12                            ObjMighty_JumpHeight:
0000BA12 4A28 0040                  		tst.b	oJumping(a0)			; Is Sonic jumping?
0000BA16 6700                       		beq.s	.UpVelCap			; If not, branch
0000BA18                            
0000BA18 323C FC00                  		move.w	#-MIN_JMP_HEIGHT,d1		; Standard minimum height
0000BA1C B268 001E                  		cmp.w	oYVel(a0),d1			; Is Sonic jumping at least hte minimum height?
0000BA20 6F00                       		ble.s	.End				; If not, branch
0000BA22 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000BA26 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000BA2A 4A38 C768                  		tst.b	rMoveCheat.w
0000BA2E 6700                       		beq.s	.NoDebug
0000BA30 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
0000BA34                            
0000BA34                            .NoDebug:
0000BA34 4A00                       		tst.b	d0
0000BA36 6600                       		bne.s	.End				; If not, branch
0000BA38 3141 001E                  		move.w	d1,oYVel(a0)			; Set to minimum height
0000BA3C                            
0000BA3C                            .End:
0000BA3C 4E75                       		rts
0000BA3E                            
0000BA3E                            .UpVelCap:
0000BA3E 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000BA42 66F8                       		bne.s	.End				; If so, branch
0000BA44 0C68 F040 001E             		cmpi.w	#-$FC0,oYVel(a0)		; Cap Y velocity at -$FC0 when going up
0000BA4A 6CF0                       		bge.s	.End				; ''
0000BA4C 317C F040 001E             		move.w	#-$FC0,oYVel(a0)		; ''
0000BA52 4E75                       		rts
0000BA54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA54                            ; Gradually reset Sonic's angle in mid air
0000BA54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA54                            ObjMighty_JumpAngle:
0000BA54 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BA58 6700                       		beq.s	ObjMighty_JumpFlip		; If it's already reset, branch
0000BA5A 6A00                       		bpl.s	.Decrease			; If it's positive, branch
0000BA5C                            
0000BA5C                            .Increase:
0000BA5C 5400                       		addq.b	#2,d0				; Increase angle
0000BA5E 6B00                       		bmi.s	.SetAngle			; If it's not reset, branch
0000BA60 7000                       		moveq	#0,d0				; Reset the angle
0000BA62 6000                       		bra.s	.SetAngle
0000BA64                            
0000BA64                            .Decrease:
0000BA64 5500                       		subq.b	#2,d0				; Decrease angle
0000BA66 6A00                       		bpl.s	.SetAngle			; If it's not reset, branch
0000BA68 7000                       		moveq	#0,d0				; Reset the angle
0000BA6A                            
0000BA6A                            .SetAngle:
0000BA6A 1140 0041                  		move.b	d0,oAngle(a0)			; Set the new angle
0000BA6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA6E                            ; Update Sonic's angle while he's tumbling in the air
0000BA6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BA6E                            ObjMighty_JumpFlip:
0000BA6E 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
0000BA72 6700                       		beq.s	.End				; If it's 0, branch
0000BA74 4A68 003A                  		tst.w	oFlipDir(a0)			; Is Sonic flipping left?
0000BA78 6B00                       		bmi.s	.FlipLeft			; IF so, branch
0000BA7A                            
0000BA7A                            .FlipRight:
0000BA7A 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
0000BA7E D001                       		add.b	d1,d0				; Add to angle
0000BA80 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
0000BA82 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
0000BA86 6400                       		bcc.s	.FlipSet			; If there are still some left
0000BA88 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
0000BA8C 7000                       		moveq	#0,d0				; Reset angle
0000BA8E 6000                       		bra.s	.FlipSet			; Continue
0000BA90                            
0000BA90                            .FlipLeft:
0000BA90 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is the flipping inverted?
0000BA94 66E4                       		bne.s	.FlipRight			; If so, branch
0000BA96 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
0000BA9A 9001                       		sub.b	d1,d0				; Subtract from angle
0000BA9C 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
0000BA9E 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
0000BAA2 6400                       		bcc.s	.FlipSet			; If there are still some left
0000BAA4 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
0000BAA8 7000                       		moveq	#0,d0				; Reset angle
0000BAAA                            
0000BAAA                            .FlipSet:
0000BAAA 1140 0047                  		move.b	d0,oFlipAngle(a0)		; Update the angle
0000BAAE                            
0000BAAE                            .End:
0000BAAE 4E75                       		rts
0000BAB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAB0                            ; Check for rolling
0000BAB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAB0                            ObjMighty_ChkRoll:
0000BAB0 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
0000BAB4 6A00                       		bpl.s	.ChkSpd				; Get absolute value
0000BAB6 4440                       		neg.w	d0				; ''
0000BAB8                            
0000BAB8                            .ChkSpd:
0000BAB8 0C40 0080                  		cmpi.w	#$80,d0				; Is Sonic going fast enough?
0000BABC 6500                       		bcs.s	.NoRoll				; If not, branch
0000BABE 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
0000BAC2 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000BAC6 6600                       		bne.s	.NoRoll				; If not, branch
0000BAC8 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
0000BACE 6600                       		bne.s	ObjMighty_DoRoll			; If so, branch
0000BAD0                            
0000BAD0                            .NoRoll:
0000BAD0 4E75                       		rts
0000BAD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAD2                            ; Make Sonic roll
0000BAD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BAD2                            ObjMighty_DoRoll:
0000BAD2 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BAD8 6600                       		bne.s	.End				; If so, branch
0000BADA 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BAE0                            
0000BAE0 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BAE6 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BAEC 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BAF0 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BAF6                            
0000BAF6 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving already?
0000BAFA 6600                       		bne.s	.End				; IF not, branch
0000BAFC 317C 0200 003A             		move.w	#$200,oGVel(a0)			; Set speed
0000BB02                            
0000BB02                            .End:
0000BB02 4E75                       		rts
0000BB04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB04                            ; Slow Sonic down as he goes up a slope or speed him up when he does down one
0000BB04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB04                            ObjMighty_SlopePush:
0000BB04 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB08 0600 0060                  		addi.b	#$60,d0				; Shift it
0000BB0C 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep slope or ceiling?
0000BB10 6400                       		bcc.s	.End				; If not, branch
0000BB12 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB16 4EB8 1308                  		jsr	CalcSine.w			; Get the sine of it
0000BB1A C1FC 0020                  		muls.w	#$20,d0				; Multiple it by $20
0000BB1E E080                       		asr.l	#8,d0				; Shift it
0000BB20 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
0000BB24 6700                       		beq.s	.End				; If Sonic is not moving, branch
0000BB26 D168 003A                  		add.w	d0,oGVel(a0)			; Add to ground velocity
0000BB2A                            
0000BB2A                            .End:
0000BB2A 4E75                       		rts
0000BB2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB2C                            ; Check if Sonic is to fall off a slope
0000BB2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB2C                            ObjMighty_FallOffSlope:
0000BB2C 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer, active?
0000BB30 6600                       		bne.s	.End				; If so, branch
0000BB32 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB36 0600 0020                  		addi.b	#$20,d0				; Shift it
0000BB3A 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000BB3E 6700                       		beq.s	.End				; If Sonic is on the floor, branch
0000BB40 3028 003A                  		move.w	oGVel(a0),d0			; Get speed
0000BB44 6A00                       		bpl.s	.ChkSpeed			; If it's already positive, branch
0000BB46 4440                       		neg.w	d0				; Force it to be positive
0000BB48                            
0000BB48                            .ChkSpeed:
0000BB48 0C40 0280                  		cmpi.w	#$280,d0			; Is Sonic going at least 2.5 pixels per frame?
0000BB4C 6400                       		bcc.s	.End				; If so, branch
0000BB4E 4268 003A                  		clr.w	oGVel(a0)			; Stop movement
0000BB52 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000BB58 117C 001E 003F             		move.b	#$1E,oMoveLock(a0)		; Set move lock timer
0000BB5E                            
0000BB5E                            .End:
0000BB5E 4E75                       		rts
0000BB60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB60                            ; Affect Sonic's speed on slopes while rolling
0000BB60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB60                            ObjMighty_RollSlopePush:
0000BB60 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB64 0600 0060                  		addi.b	#$60,d0				; ''
0000BB68 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep enough slope?
0000BB6C 6400                       		bcc.s	.End				; If not, branch
0000BB6E                            
0000BB6E 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000BB72 4EB8 1308                  		jsr	CalcSine.w			; Get sine
0000BB76 C1FC 0050                  		muls.w	#$50,d0				; Multiply sine by $50
0000BB7A E080                       		asr.l	#8,d0				; Shift over
0000BB7C                            
0000BB7C 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
0000BB80 6B00                       		bmi.s	.PushLeft			; If not, branch
0000BB82 4A40                       		tst.w	d0				; Is the push speed positive?
0000BB84 6A00                       		bpl.s	.Push				; If so, branch
0000BB86 E480                       		asr.l	#2,d0				; Shift over more
0000BB88                            
0000BB88                            .Push:
0000BB88 D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
0000BB8C 4E75                       		rts
0000BB8E                            
0000BB8E                            .PushLeft:
0000BB8E 4A40                       		tst.w	d0				; Is the push speed negative?
0000BB90 6B00                       		bmi.s	.Push2				; If so, branch
0000BB92 E480                       		asr.l	#2,d0				; Shift over more
0000BB94                            
0000BB94                            .Push2:
0000BB94 D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
0000BB98                            
0000BB98                            .End:
0000BB98 4E75                       		rts
0000BB9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB9A                            ; Check for bouncy floor collision
0000BB9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BB9A                            ObjMighty_ChkBounce:
0000BB9A 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
0000BB9E 6700 0000                  		beq.w	.End				; If so, branch
0000BBA2                            
0000BBA2 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic in the air?
0000BBA8 6700                       		beq.s	.ChkDown			; If not, branch
0000BBAA                            
0000BBAA 4A68 001E                  		tst.w	oYVel(a0)			; Is Sonic falling?
0000BBAE 6700 0000                  		beq.w	.ChkBounceUp			; If not, branch
0000BBB2 6B00 0000                  		bmi.w	.ChkBounceUp			; ''
0000BBB6                            
0000BBB6                            .ChkDown:
0000BBB6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
0000BBBA 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BBBE 4880                       		ext.w	d0				; ''
0000BBC0 D440                       		add.w	d0,d2				; ''
0000BBC2 5442                       		addq.w	#2,d2				; ''
0000BBC4 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
0000BBC8 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BBCC 4880                       		ext.w	d0				; ''
0000BBCE 9640                       		sub.w	d0,d3				; ''
0000BBD0 4EB8 37C2                  		jsr	Level_FindBlock			; Get the block located there
0000BBD4 3011                       		move.w	(a1),d0				; ''
0000BBD6 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BBDA 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BBDE 6700                       		beq.s	.Bounce				; If so, branch
0000BBE0                            
0000BBE0 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
0000BBE4 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BBE8 4880                       		ext.w	d0				; ''
0000BBEA D440                       		add.w	d0,d2				; ''
0000BBEC 5442                       		addq.w	#2,d2				; ''
0000BBEE 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
0000BBF2 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BBF6 4880                       		ext.w	d0				; ''
0000BBF8 D640                       		add.w	d0,d3				; ''
0000BBFA 4EB8 37C2                  		jsr	Level_FindBlock			; Get the block located there
0000BBFE 3011                       		move.w	(a1),d0				; ''
0000BC00 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BC04 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BC08 6600                       		bne.s	.End				; If not, branch
0000BC0A                            
0000BC0A                            .Bounce:
0000BC0A 317C EA00 001E             		move.w	#-$1600,oYVel(a0)		; Bounce Sonic up
0000BC10 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
0000BC16 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
0000BC1A 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
0000BC1E 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
0000BC22                            
0000BC22                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000BC22 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
0000BC28                            
0000BC28 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BC2E 6600                       		bne.s	.End				; If so, branch
0000BC30 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BC36 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BC3C 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BC42 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BC46 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BC4C                            
0000BC4C                            .End:
0000BC4C 4E75                       		rts
0000BC4E                            
0000BC4E                            .ChkBounceUp:
0000BC4E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
0000BC52 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BC56 4880                       		ext.w	d0				; ''
0000BC58 9440                       		sub.w	d0,d2				; ''
0000BC5A 5542                       		subq.w	#2,d2				; ''
0000BC5C 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
0000BC60 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BC64 4880                       		ext.w	d0				; ''
0000BC66 9640                       		sub.w	d0,d3				; ''
0000BC68 4EB8 37C2                  		jsr	Level_FindBlock			; Get the block located there
0000BC6C 3011                       		move.w	(a1),d0				; ''
0000BC6E 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BC72 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BC76 6700                       		beq.s	.BounceUp			; If so, branch
0000BC78                            
0000BC78 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
0000BC7C 1028 002D                  		move.b	oColH(a0),d0			; ''
0000BC80 4880                       		ext.w	d0				; ''
0000BC82 9440                       		sub.w	d0,d2				; ''
0000BC84 5542                       		subq.w	#2,d2				; ''
0000BC86 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
0000BC8A 1028 002C                  		move.b	oColW(a0),d0			; ''
0000BC8E 4880                       		ext.w	d0				; ''
0000BC90 D640                       		add.w	d0,d3				; ''
0000BC92 4EB8 37C2                  		jsr	Level_FindBlock			; Get the block located there
0000BC96 3011                       		move.w	(a1),d0				; ''
0000BC98 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BC9C 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000BCA0 66AA                       		bne.s	.End				; If not, branch
0000BCA2                            
0000BCA2                            .BounceUp:
0000BCA2 588F                       		addq.l	#4,sp				; Don't return to caller
0000BCA4                            
0000BCA4 317C 1600 001E             		move.w	#$1600,oYVel(a0)		; Bounce Sonic up
0000BCAA 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
0000BCB0 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
0000BCB4 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
0000BCB8 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
0000BCBC                            
0000BCBC                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000BCBC 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
0000BCC2                            
0000BCC2 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000BCC8 6600                       		bne.s	.End2				; If so, branch
0000BCCA 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000BCD0 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000BCD6 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000BCDC 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000BCE0 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
0000BCE6                            
0000BCE6                            .End2:
0000BCE6 4E75                       		rts
0000BCE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BCE8                            ; Check for bars to hang on to
0000BCE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BCE8                            ObjMighty_ChkHang:
0000BCE8 0828 0003 000C             		btst	#3,oFlags(a0)			; Are we already hanging?
0000BCEE 6600                       		bne.s	.End				; If so, branch
0000BCF0                            
0000BCF0 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BCF4 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BCF8 0442 0018                  		subi.w	#$18,d2				; ''
0000BCFC 4EB8 37C2                  		jsr	Level_FindBlock			; Get the block located there
0000BD00 3011                       		move.w	(a1),d0				; ''
0000BD02 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BD06 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
0000BD0A 6600                       		bne.s	.End				; If not, branch
0000BD0C                            
0000BD0C 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
0000BD12 42A8 001C                  		clr.l	oXVel(a0)			; Stop movement
0000BD16 4268 003A                  		clr.w	oGVel(a0)			; ''
0000BD1A 08E8 0003 000C             		bset	#3,oFlags(a0)			; Set hanging flag
0000BD20 117C 000A 0020             		move.b	#$A,oAni(a0)			; Set hanging animation
0000BD26 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Animation timer
0000BD2C 3028 0018                  		move.w	oYPos(a0),d0			; Align with bar
0000BD30 0440 0018                  		subi.w	#$18,d0				; ''
0000BD34 0240 FFF0                  		andi.w	#$FFF0,d0			; ''
0000BD38 0640 0018                  		addi.w	#$18,d0				; ''
0000BD3C 3140 0018                  		move.w	d0,oYPos(a0)			; ''
0000BD40 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
0000BD44 08A8 0001 000D             		bclr	#1,oRender(a0)			; ''
0000BD4A                            
0000BD4A                            .End:
0000BD4A 4E75                       		rts
0000BD4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BD4C                            ; Hang onto the bars
0000BD4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BD4C                            ObjMighty_Hang:
0000BD4C 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BD50 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BD54 0442 0018                  		subi.w	#$18,d2				; ''
0000BD58 4EB8 37C2                  		jsr	Level_FindBlock			; Get the block located there
0000BD5C 3011                       		move.w	(a1),d0				; ''
0000BD5E 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BD62 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
0000BD66 6600                       		bne.s	.FallOff			; If not, branch
0000BD68 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get control press bits
0000BD6C 0200 0070                  		andi.b	#$70,d0				; Are we jumping off?
0000BD70 6700                       		beq.s	.MoveX				; If not, branch
0000BD72                            
0000BD72                            .FallOff:
0000BD72 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
0000BD78 0668 0010 0018             		addi.w	#$10,oYPos(a0)			; Fall off
0000BD7E 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000BD84 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000BD8A 4E75                       		rts
0000BD8C                            
0000BD8C                            .MoveX:
0000BD8C 7002                       		moveq	#2,d0				; X speed
0000BD8E 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Are we going left?
0000BD94 6700                       		beq.s	.ChkRight			; If not, branch
0000BD96 4440                       		neg.w	d0				; Go the other way
0000BD98 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face to the left
0000BD9E 08E8 0000 000D             		bset	#0,oRender(a0)			; ''
0000BDA4 6000                       		bra.s	.DoMove				; Continue
0000BDA6                            
0000BDA6                            .ChkRight:
0000BDA6 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Are we going left?
0000BDAC 6700                       		beq.s	.ResetScr			; If not, branch
0000BDAE 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face to the right
0000BDB4 08A8 0000 000D             		bclr	#0,oRender(a0)			; ''
0000BDBA                            
0000BDBA                            .DoMove:
0000BDBA D168 0014                  		add.w	d0,oXPos(a0)			; Move
0000BDBE 5328 004C                  		subq.b	#1,oHangAniTime(a0)		; Decrement animation timer
0000BDC2 6A00                       		bpl.s	.ResetScr			; If it hasn't run out, branch
0000BDC4 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Reset timer
0000BDCA 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Increment animation frame
0000BDCE 0C28 0004 0022             		cmpi.b	#4,oAniFrame(a0)		; Have we reached the last one?
0000BDD4 6500                       		bcs.s	.ResetScr			; If not, branch
0000BDD6 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation frame
0000BDDA                            
0000BDDA                            .ResetScr:
0000BDDA 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BDDE 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000BDE4 6700                       		beq.s	.End				; If so, branch
0000BDE6 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000BDE8 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000BDEC                            
0000BDEC                            .ScrollUp:
0000BDEC 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000BDF0                            
0000BDF0                            .End:
0000BDF0 4E75                       		rts
0000BDF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDF2                            ; Check for electricity
0000BDF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BDF2                            ObjMighty_ChkElectric:
0000BDF2 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000BDF6 3428 0018                  		move.w	oYPos(a0),d2			; Y position
0000BDFA 4EB8 37C2                  		jsr	Level_FindBlock			; Get the block located there
0000BDFE 3011                       		move.w	(a1),d0				; ''
0000BE00 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000BE04                            
0000BE04 43FA 0000                  		lea	.Blocks(pc),a1			; BLocks to check
0000BE08 7C02                       		moveq	#2,d6				; ''
0000BE0A                            
0000BE0A                            .ChkBlocks:
0000BE0A B059                       		cmp.w	(a1)+,d0			; have we touched this block?
0000BE0C 6700                       		beq.s	ObjMighty_GetHurt		; If so, branch
0000BE0E 51CE FFFA                  		dbf	d6,.ChkBlocks			; Loop
0000BE12 4E75                       		rts
0000BE14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE14 0082 0083 0084             .Blocks:	dc.w	$82, $83, $84
0000BE1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE1A                            ; Get Sonic hurt
0000BE1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BE1A                            ObjMighty_GetHurt:
0000BE1A                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
0000BE1A 4A68 0008                M 	tst.w	odrawnext(a0)
0000BE1E 6600                     M 	bne.s	.no_215
0000BE20 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000BE26 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000BE2A 3149 000A                M 	move.w	a1,odrawprev(a0)
0000BE2E 3348 0008                M 	move.w	a0,odrawnext(a1)
0000BE32 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BE36 0C78 BE6A BE74           M 	cmp.w	#rdispinput+(2*dsize),rdispinput+dprev+(2*dsize).w
0000BE3C 6600                     M 	bne.s	.no_215
0000BE3E 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BE42                          M .no_215
0000BE42 4A28 0042                  		tst.b	oInvulTime(a0)			; Are we invulnerable?
0000BE46 6600 0000                  		bne.w	.End				; If so, branch
0000BE4A 4A78 F3D4                  		tst.w	rRings.w			; Does Sonic have any rings?
0000BE4E 6700 0000                  		beq.w	ObjMighty_GetKilled		; If not, branch
0000BE52 4EB8 19B0                  		jsr	FindFreeObj.w
0000BE56 6700                       		beq.s	.Hurt
0000BE58 22BC 0000 0000             		move.l	#ObjRingLoss,oAddr(a1)
0000BE5E 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
0000BE64 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
0000BE6A                            
0000BE6A                            .Hurt:
0000BE6A 117C 0008 0025             		move.b	#8,oRoutine(a0)			; Set to hurt routine
0000BE70 4EB8 2DAE                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
0000BE74 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BE78 08A8 0000 000C             		bclr	#0,oFlags(a0)			; Allow modes
0000BE7E 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
0000BE84 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
0000BE8A 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Set to hurt animation
0000BE90 117C 0078 0042             		move.b	#$78,oInvulTime(a0)		; Set invulnerable timer
0000BE96                            
0000BE96 317C FC00 001E             		move.w	#-$400,oYVel(a0)		; Make Sonic bounce away
0000BE9C 317C FE00 001C             		move.w	#-$200,oXVel(a0)		; ''
0000BEA2 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000BEA8 6700                       		beq.s	.ChkReverse			; If not, branch
0000BEAA 317C FE00 001E             		move.w	#-$200,oYVel(a0)		; Make Sonic bounce away slower
0000BEB0 317C FF00 001C             		move.w	#-$100,oXVel(a0)
0000BEB6                            
0000BEB6                            .ChkReverse:
0000BEB6 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
0000BEBA B06A 0014                  		cmp.w	oXPos(a2),d0			; Is Sonic left of the object that hurt him?
0000BEBE 6500                       		bcs.s	.ChkSnd				; If so, branch
0000BEC0 4468 001C                  		neg.w	oXVel(a0)			; Make Sonic bounce the other way if on the right side
0000BEC4                            
0000BEC4                            .ChkSnd:
0000BEC4 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
0000BEC8                            
0000BEC8                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
0000BEC8                            	;	beq.s	.End				; If not, branch
0000BEC8                            		playSnd	#sHurt, 2			; Play hurt sound
0000BEC8 11FC 0084 C4BD           M 	move.b	#shurt,(mqueue+((2)-1)).w
0000BECE                            
0000BECE                            .End:
0000BECE 70FF                       		moveq	#-1,d0				; Set return status
0000BED0 4E75                       		rts
0000BED2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BED2                            ; Hurt routine
0000BED2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BED2                            ObjMighty_Hurt:
0000BED2 4A38 C768                  		tst.b	rMoveCheat.w
0000BED6 6700                       		beq.s	.NoPlacementEnter
0000BED8 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000BEDE 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000BEE0 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000BEE6 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000BEEC 4E75                       		rts
0000BEEE                            
0000BEEE                            .NoPlacementEnter:
0000BEEE 4EB8 1CF0                  		jsr	ObjectMove.w			; Allow movement
0000BEF2 0668 0030 001E             		addi.w	#$30,oYVel(a0)			; Apply gravity
0000BEF8 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000BEFE 6700                       		beq.s	.NotWater			; If not, branch
0000BF00 0468 0020 001E             		subi.w	#$20,oYVel(a0)			; Reduce gravity underwater
0000BF06                            
0000BF06                            .NotWater:
0000BF06 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Force the hurt animation
0000BF0C 6100                       		bsr.s	.ChkStop			; Check if Sonic has hit the ground or the bottom boundary
0000BF0E                            
0000BF0E 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000BF14 6700                       		beq.s	.Cont				; If so, branch
0000BF16 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000BF18 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000BF1C                            
0000BF1C                            .ScrollUp:
0000BF1C 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000BF20                            
0000BF20                            .Cont:
0000BF20 6100 F820                  		bsr.w	ObjMighty_LvlBound		; Handle level boundaries
0000BF24 6100 0000                  		bsr.w	ObjMighty_Animate		; Animate sprite
0000BF28 6000 0000                  		bra.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000BF2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF2C                            .ChkStop:
0000BF2C 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
0000BF30 0640 00E0                  		addi.w	#224,d0				; ''
0000BF34 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
0000BF38 6D00                       		blt.s	ObjMighty_GetKilled		; If so, branch
0000BF3A                            
0000BF3A 4EB8 2BB8                  		jsr	PlayerChkCollision		; Check for level collision
0000BF3E 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic still in midair?
0000BF44 6600                       		bne.s	.End				; If so, branch
0000BF46                            
0000BF46 7000                       		moveq	#0,d0
0000BF48 3140 001E                  		move.w	d0,oYVel(a0)			; Stop Sonic's movement
0000BF4C 3140 001C                  		move.w	d0,oXVel(a0)			; ''
0000BF50 3140 003A                  		move.w	d0,oGVel(a0)			; ''
0000BF54 1140 000C                  		move.b	d0,oFlags(a0)			; Allow Sonic to move
0000BF58 1140 0020                  		move.b	d0,oAni(a0)			; Reset animation
0000BF5C 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set back to main routine
0000BF62                            
0000BF62                            .End:
0000BF62 4E75                       		rts
0000BF64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF64                            ; Get Sonic killed
0000BF64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BF64                            ObjMighty_GetKilled:
0000BF64                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
0000BF64 4A68 0008                M 	tst.w	odrawnext(a0)
0000BF68 6600                     M 	bne.s	.no_217
0000BF6A 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000BF70 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000BF74 3149 000A                M 	move.w	a1,odrawprev(a0)
0000BF78 3348 0008                M 	move.w	a0,odrawnext(a1)
0000BF7C 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BF80 0C78 BE6A BE74           M 	cmp.w	#rdispinput+(2*dsize),rdispinput+dprev+(2*dsize).w
0000BF86 6600                     M 	bne.s	.no_217
0000BF88 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000BF8C                          M .no_217
0000BF8C 117C 000C 0025             		move.b	#$C,oRoutine(a0)			; Set to the death routine
0000BF92 4EB8 2DAE                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
0000BF96 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000BF9A 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
0000BFA0 117C 0018 0020             		move.b	#$18,oAni(a0)			; Set to death animation
0000BFA6                            
0000BFA6 317C F900 001E             		move.w	#-$700,oYVel(a0)		; Make Sonic bounce up
0000BFAC 4268 001C                  		clr.w	oXVel(a0)			; Lock Sonic horizontally
0000BFB0 4268 003A                  		clr.w	oGVel(a0)			; ''
0000BFB4 31FC FFFF F8CE             		move.w	#$FFFF,rCamLocked.w		; Lock the camera
0000BFBA                            
0000BFBA                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
0000BFBA                            	;	beq.s	.End				; If not, branch
0000BFBA                            		playSnd	#sDeath,2			; Play death sound
0000BFBA 11FC 0084 C4BD           M 	move.b	#sdeath,(mqueue+((2)-1)).w
0000BFC0                            
0000BFC0                            .End:
0000BFC0 70FF                       		moveq	#-1,d0				; Set return status
0000BFC2 4E75                       		rts
0000BFC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFC4                            ; Death routine
0000BFC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFC4                            ObjMighty_Dead:
0000BFC4 4A38 C768                  		tst.b	rMoveCheat.w
0000BFC8 6700                       		beq.s	.NoPlacementEnter
0000BFCA 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000BFD0 6700                       		beq.s	.NoPlacementEnter		; If not, branch
0000BFD2 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
0000BFD8 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000BFDE 4E75                       		rts
0000BFE0                            
0000BFE0                            .NoPlacementEnter:
0000BFE0 117C 0018 0020             		move.b	#$18,oAni(a0)			; Force the death animation
0000BFE6 0068 8000 000E             		ori.w	#$8000,oVRAM(a0)		; Force high priority
0000BFEC 6100                       		bsr.s	ObjMighty_ChkBound		; Check for when Sonic goes off screen
0000BFEE 4EB8 1D0A                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000BFF2 6100 0000                  		bsr.w	ObjMighty_Animate		; Animate sprite
0000BFF6 6000 0000                  		bra.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000BFFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000BFFA                            ObjMighty_ChkBound:
0000BFFA 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
0000BFFE 0640 0100                  		addi.w	#$100,d0			; ''
0000C002 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
0000C006 6C00                       		bge.s	.End				; If not, branch
0000C008                            
0000C008 117C 0010 0025             		move.b	#$10,oRoutine(a0)			; Go to gone routine
0000C00E 117C 003C 0043             		move.b	#60,oDeathTimer(a0)		; Set death timer to 1 second
0000C014                            
0000C014                            .End:
0000C014 4E75                       		rts
0000C016                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C016                            ; Wait for level reload or game/time over
0000C016                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C016                            ObjMighty_Gone:
0000C016 4A28 0043                  		tst.b	oDeathTimer(a0)
0000C01A 6700                       		beq.s	.End
0000C01C 5328 0043                  		subq.b	#1,oDeathTimer(a0)		; Decrement the death counter
0000C020 6600                       		bne.s	.End				; If it hasn't run out, branch
0000C022 50F8 F8FC                  		st	rLvlReload.w			; Reload the level
0000C026                            
0000C026                            .End:
0000C026 4E75                       		rts
0000C028                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C028                            ; Display Sonic's sprite
0000C028                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C028                            ObjMighty_Display:
0000C028 1028 0042                  		move.b	oInvulTime(a0),d0		; Get invulnerability timer
0000C02C 6700                       		beq.s	.Display			; If it's 0, branch
0000C02E 5328 0042                  		subq.b	#1,oInvulTime(a0)		; Decrement invulnerability timer
0000C032 E648                       		lsr.w	#3,d0				; Can Sonic's sprite be displayed?
0000C034 6500                       		bcs.s	.Display			; If so, branch
0000C036                            	removeSprite	a0,a1,1				; Remove sprite if displayed
0000C036 4A68 0008                M 	tst.w	odrawnext(a0)
0000C03A 6700                     M 	beq.s	.yes_219
0000C03C 3268 000A                M 	move.w	odrawprev(a0),a1
0000C040 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
0000C046 3268 0008                M 	move.w	odrawnext(a0),a1
0000C04A 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
0000C050 B2E8 000A                M 	cmp.w	odrawprev(a0),a1
0000C054 6600                     M 	bne.s	.no_219
0000C056 3349 0008                M 	move.w	a1,odrawnext(a1)
0000C05A                          M .no_219
0000C05A 42A8 0008                M 	clr.l	odrawnext(a0)
0000C05E                          M .yes_219
0000C05E 4E75                       		rts
0000C060                            
0000C060                            .Display:
0000C060                            	displaySprite	2,a0,a1,1			; Add sprite if not already being displayed
0000C060 4A68 0008                M 	tst.w	odrawnext(a0)
0000C064 6600                     M 	bne.s	.no_220
0000C066 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000C06C 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
0000C070 3149 000A                M 	move.w	a1,odrawprev(a0)
0000C074 3348 0008                M 	move.w	a0,odrawnext(a1)
0000C078 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C07C 0C78 BE6A BE74           M 	cmp.w	#rdispinput+(2*dsize),rdispinput+dprev+(2*dsize).w
0000C082 6600                     M 	bne.s	.no_220
0000C084 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C088                          M .no_220
0000C088 4E75                       		rts
0000C08A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C08A                            ; Load Sonic's DPLCs
0000C08A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C08A                            ObjMighty_LoadDPLCs:
0000C08A 45F9 0000 0000             		lea	DPLC_ObjMighty,a2		; DPLCs
0000C090 383C F000                  		move.w	#$F000,d4			; VRAM location
0000C094 2C3C 0000 0000             		move.l	#ArtUnc_Sonic,d6		; Art
0000C09A 4EF8 1CB0                  		jmp	LoadObjDPLCs.w			; Load DPLCs
0000C09E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C09E                            ; Animate Sonic's sprite
0000C09E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C09E                            ObjMighty_Animate:
0000C09E 43F9 0000 0000             		lea	Ani_ObjMighty,a1			; Animation script
0000C0A4 7000                       		moveq	#0,d0
0000C0A6 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
0000C0AA B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
0000C0AE 6700                       		beq.s	.Run				; If not, branch
0000C0B0 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
0000C0B4 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
0000C0B8 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C0BC 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000C0C2                            
0000C0C2                            .Run:
0000C0C2 D040                       		add.w	d0,d0				; Turn ID into offset
0000C0C4 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
0000C0C8 1011                       		move.b	(a1),d0				; Get first byte
0000C0CA 6B00                       		bmi.s	.WalkRunAnim			; If this is a special animation, branch
0000C0CC 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0000C0D0 0201 0001                  		andi.b	#1,d1				; Only get horizontal flip bit
0000C0D4 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
0000C0DA 8328 000D                  		or.b	d1,oRender(a0)			; Set flip bits
0000C0DE 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
0000C0E2 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
0000C0E4 1140 0023                  		move.b	d0,oAniTimer(a0)		; Set new animation timer
0000C0E8                            
0000C0E8                            .GetFrame:
0000C0E8 7200                       		moveq	#0,d1
0000C0EA 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
0000C0EE 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
0000C0F2 0C00 00FD                  		cmpi.b	#$FD,d0				; Is it a command value?
0000C0F6 6400                       		bhs.s	.CmdReset			; If so, branch
0000C0F8                            
0000C0F8                            .Next:
0000C0F8 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
0000C0FC 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
0000C100                            
0000C100                            .Wait:
0000C100 4E75                       		rts
0000C102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C102                            .CmdReset:
0000C102 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
0000C104 6600                       		bne.s	.CmdJump			; If not, branch
0000C106 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
0000C10A 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
0000C10E 60E8                       		bra.s	.Next				; Continue
0000C110                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C110                            .CmdJump:
0000C110 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
0000C112 6600                       		bne.s	.CmdSetAnim			; If not, branch
0000C114 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
0000C118 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
0000C11C 9200                       		sub.b	d0,d1				; ''
0000C11E 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
0000C122 60D4                       		bra.s	.Next				; Continue
0000C124                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C124                            .CmdSetAnim:
0000C124 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
0000C126 6600                       		bne.s	.CmdEnd				; If not, branch
0000C128 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
0000C12E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C12E                            .CmdEnd:
0000C12E 4E75                       		rts
0000C130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C130                            .WalkRunAnim:
0000C130 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
0000C134 6ACA                       		bpl.s	.Wait				; If it hasn't run out, branch
0000C136 5200                       		addq.b	#1,d0				; Is the animation walking/running?
0000C138 6600 0000                  		bne.w	.RollAnim			; If not, branch
0000C13C                            
0000C13C 7000                       		moveq	#0,d0
0000C13E 1028 0047                  		move.b	oFlipAngle(a0),d0		; Is Sonic tumbling in the air?
0000C142 6600 0000                  		bne.w	.TumbleAnim			; If so, branch
0000C146                            
0000C146 7200                       		moveq	#0,d1				; Intial flip bits
0000C148 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0000C14C 6B00                       		bmi.s	.ChkStatus			; If it's negative, branch
0000C14E 6700                       		beq.s	.ChkStatus			; If it's zero, branch
0000C150 5300                       		subq.b	#1,d0				; Decrement angle if it's positive
0000C152                            
0000C152                            .ChkStatus:
0000C152 1428 0028                  		move.b	oStatus(a0),d2			; Get status
0000C156 0202 0001                  		andi.b	#1,d2				; Is Sonic mirrored horizontally?
0000C15A 6600                       		bne.s	.ChkFlip			; If so, branch
0000C15C 4600                       		not.b	d0				; Reverse angle
0000C15E                            
0000C15E                            .ChkFlip:
0000C15E 0600 0010                  		addi.b	#$10,d0				; Shift angle
0000C162 6A00                       		bpl.s	.SetFlags			; If it's positive, branch
0000C164 7203                       		moveq	#3,d1				; Flags to flip Sonic's sprite
0000C166                            
0000C166                            .SetFlags:
0000C166 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits
0000C16C B302                       		eor.b	d1,d2				; Flip
0000C16E 8528 000D                  		or.b	d2,oRender(a0)			; Set in render flags
0000C172                            
0000C172 0828 0005 0028             		btst	#5,oStatus(a0)			; Is Sonic pushing?
0000C178 6600 0000                  		bne.w	.DoPushAnim			; If so, branch
0000C17C                            
0000C17C E808                       		lsr.b	#4,d0				; Divide angle by $10
0000C17E 0200 0006                  		andi.b	#6,d0				; Get angle section
0000C182                            
0000C182 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C186 6A00                       		bpl.s	.GetAnim			; If it's already positive, branch
0000C188 4442                       		neg.w	d2				; Force it to be positive
0000C18A                            
0000C18A                            .GetAnim:
0000C18A 43F9 0000 0000             		lea	SonicAni_Sprint,a1		; Sprinting animation
0000C190 4A00                       		tst.b	d0
0000C192 6600                       		bne.s	.ChkRun
0000C194 0C42 0C00                  		cmpi.w	#$C00,d2			; Is Sonic sprinting?
0000C198 6400                       		bcc.s	.SkipWalk			; If so, branch
0000C19A                            
0000C19A                            .ChkRun:
0000C19A 43F9 0000 0000             		lea	SonicAni_Run,a1			; Running animation
0000C1A0 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic running?
0000C1A4 6400                       		bcc.s	.SkipWalk			; If so, branch
0000C1A6 43F9 0000 0000             		lea	SonicAni_Walk,a1		; Walking animation
0000C1AC 1200                       		move.b	d0,d1				; Multiply angle section ID by 3
0000C1AE E209                       		lsr.b	#1,d1				; ''
0000C1B0 D001                       		add.b	d1,d0				; ''
0000C1B2                            
0000C1B2                            .SkipWalk:
0000C1B2 D000                       		add.b	d0,d0				; Double the offset
0000C1B4 1600                       		move.b	d0,d3				; Copy the oofset
0000C1B6 4442                       		neg.w	d2				; Get animation speed
0000C1B8 0642 0800                  		addi.w	#$800,d2			; ''
0000C1BC 6A00                       		bpl.s	.SetTimer			; ''
0000C1BE 7400                       		moveq	#0,d2				; ''
0000C1C0                            
0000C1C0                            .SetTimer:
0000C1C0 E04A                       		lsr.w	#8,d2				; ''
0000C1C2 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C1C6 6100 FF20                  		bsr.w	.GetFrame			; Get the next frame
0000C1CA D728 0010                  		add.b	d3,oFrame(a0)			; Add angle offset
0000C1CE 4E75                       		rts
0000C1D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C1D0                            .TumbleAnim:
0000C1D0 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
0000C1D4 7200                       		moveq	#0,d1
0000C1D6 1428 0028                  		move.b	oStatus(a0),d2			; Get status
0000C1DA 0202 0001                  		andi.b	#1,d2				; Are we are facing left?
0000C1DE 6600                       		bne.s	.TumbleLeft			; If so, branch
0000C1E0                            
0000C1E0 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
0000C1E6 0600 000B                  		addi.b	#$B,d0				; Get map frame
0000C1EA 80FC 0016                  		divu.w	#$16,d0				; ''
0000C1EE 0600 0068                  		addi.b	#$68,d0				; ''
0000C1F2 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0000C1F6 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C1FA 4E75                       		rts
0000C1FC                            
0000C1FC                            .TumbleLeft:
0000C1FC 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
0000C202 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is flipping inverted?
0000C206 6700                       		beq.s	.NotInverted			; If not, branch
0000C208 0028 0001 000D             		ori.b	#1,oRender(a0)			; Face left
0000C20E 0600 000B                  		addi.b	#$B,d0				; Get map frame
0000C212 6000                       		bra.s	.SetLeftFrame			; Continue
0000C214                            
0000C214                            .NotInverted:
0000C214 0028 0003 000D             		ori.b	#3,oRender(a0)			; Face left and be upside down
0000C21A 4400                       		neg.b	d0				; Get map frame
0000C21C 0600 008F                  		addi.b	#$8F,d0				; ''
0000C220                            
0000C220                            .SetLeftFrame:
0000C220 80FC 0016                  		divu.w	#$16,d0				; Continue getting map frame
0000C224 0600 0068                  		addi.b	#$68,d0				; ''
0000C228 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0000C22C 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
0000C230 4E75                       		rts
0000C232                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C232                            .RollAnim:
0000C232 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000C234 6600                       		bne.s	.PushAnim			; If not, branch
0000C236                            
0000C236 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C23A 6A00                       		bpl.s	.GetAnim2			; If it's already negative, branch
0000C23C 4442                       		neg.w	d2				; Force it to be negative
0000C23E                            
0000C23E                            .GetAnim2:
0000C23E 43F9 0000 0000             		lea	SonicAni_Roll2,a1		; Use fast animation
0000C244 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic rolling fast enough?
0000C248 6400                       		bcc.s	.PrepareTimer			; If so, branch
0000C24A 43F9 0000 0000             		lea	SonicAni_Roll,a1		; Use slower animation
0000C250                            
0000C250                            .PrepareTimer:
0000C250 4442                       		neg.w	d2				; Get animation speed
0000C252 0642 0400                  		addi.w	#$400,d2			; ''
0000C256 6A00                       		bpl.s	.SetTimer2			; ''
0000C258 7400                       		moveq	#0,d2				; ''
0000C25A                            
0000C25A                            .SetTimer2:
0000C25A E04A                       		lsr.w	#8,d2				; ''
0000C25C 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C260                            
0000C260 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0000C264 0201 0001                  		andi.b	#1,d1				; Get horizontal flip flag only
0000C268 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits in render flags
0000C26E 8328 000D                  		or.b	d1,oRender(a0)			; Set new flip bits
0000C272                            
0000C272 6000 FE74                  		bra.w	.GetFrame			; Get the next frame
0000C276                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C276                            .PushAnim:
0000C276 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000C278 6600                       		bne.s	.HangAnim			; If not, branch
0000C27A                            
0000C27A                            .DoPushAnim:
0000C27A 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
0000C27E 6B00                       		bmi.s	.GetAnim3			; If it's already negative, branch
0000C280 4442                       		neg.w	d2				; Force it to be negative
0000C282                            
0000C282                            .GetAnim3:
0000C282 0642 0800                  		addi.w	#$800,d2			; Get animation speed
0000C286 6A00                       		bpl.s	.SetTimer3			; ''
0000C288 7400                       		moveq	#0,d2				; ''
0000C28A                            
0000C28A                            .SetTimer3:
0000C28A EC4A                       		lsr.w	#6,d2				; ''
0000C28C 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
0000C290 43F9 0000 0000             		lea	SonicAni_Push,a1		; Pushing animation
0000C296 6000 FE50                  		bra.w	.GetFrame			; Get the next frame
0000C29A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C29A                            .HangAnim:
0000C29A 7200                       		moveq	#0,d1
0000C29C 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation frame
0000C2A0 1171 1001 0010             		move.b	1(a1,d1.w),oFrame(a0)		; Set map frame
0000C2A6 4228 0023                  		clr.b	oAniTimer(a0)			; Clear animation timer
0000C2AA 4E75                       		rts
0000C2AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2AC                            ; Handle debug placement mode
0000C2AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2AC                            DebugPlacement:
0000C2AC 7000                       		moveq	#0,d0
0000C2AE 1038 F8D1                  		move.b	rDebugMode.w,d0		; Get debug placement mode routine
0000C2B2 0240 0002                  		andi.w	#2,d0				; Only allow 0, 2, 4, and 6
0000C2B6 D040                       		add.w	d0,d0				; Double it
0000C2B8 4EBB 0000                  		jsr	.Routines(pc,d0.w)		; Go to the correct routine
0000C2BC                            	nextObject
0000C2BC 3068 0004                M 	movea.w	onext(a0),a0
0000C2C0 2250                     M 	move.l	oaddr(a0),a1
0000C2C2 4ED1                     M 	jmp	(a1)
0000C2C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2C4                            .Routines:
0000C2C4 6000 0000                  		bra.w	Debug_Init			; Initialization(00*2)
0000C2C8 6000 0000                  		bra.w	Debug_Main			; Main		(02*2)
0000C2CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C2CC                            Debug_Init:
0000C2CC 5438 F8D1                  		addq.b	#2,rDebugMode.w		; Next routine
0000C2D0 4228 0010                  		clr.b	oFrame(a0)			; Reset mapping frame
0000C2D4 4228 0020                  		clr.b	oAni(a0)			; Reset animation
0000C2D8 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
0000C2DC 4278 F8CE                  		clr.w	rCamLocked.w			; Unlock the camera
0000C2E0 4228 004B                  		clr.b	oBallMode(a0)			; Reset ball mode
0000C2E4 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
0000C2E8 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set routine to main
0000C2EE                            
0000C2EE 3028 003C                  		move.w	oInteract(a0),d0		; Get object interacted with last
0000C2F2 6700                       		beq.s	.NoInteract			; If there is none, branch
0000C2F4 3240                       		movea.w	d0,a1
0000C2F6 08A9 0003 0028             		bclr	#3,oStatus(a1)			; Clear flags
0000C2FC 08A9 0005 0028             		bclr	#5,oStatus(a1)			; ''
0000C302 4268 003C                  		clr.w	oInteract(a0)			; No more interaction
0000C306                            
0000C306                            .NoInteract:
0000C306 4228 000C                  		clr.b	oFlags(a0)			; Reset flags
0000C30A 4228 0028                  		clr.b	oStatus(a0)			; Reset status
0000C30E 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
0000C314 117C 0001 0010             		move.b	#1,oFrame(a0)			; Display the standing frame
0000C31A 6100 FD6E                  		bsr.w	ObjMighty_LoadDPLCs		; Load DPLCs
0000C31E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C31E                            Debug_Main:
0000C31E 6100 EE06                  		bsr.w	ObjMighty_ExtendedCam		; Handle extended camera
0000C322 6100                       		bsr.s	Debug_Control			; Control
0000C324                            	displaySprite	2,a0,a2,1
0000C324 4A68 0008                M 	tst.w	odrawnext(a0)
0000C328 6600                     M 	bne.s	.no_222
0000C32A 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
0000C330 3478 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a2
0000C334 314A 000A                M 	move.w	a2,odrawprev(a0)
0000C338 3548 0008                M 	move.w	a0,odrawnext(a2)
0000C33C 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C340 0C78 BE6A BE74           M 	cmp.w	#rdispinput+(2*dsize),rdispinput+dprev+(2*dsize).w
0000C346 6600                     M 	bne.s	.no_222
0000C348 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
0000C34C                          M .no_222
0000C34C 4E75                       		rts
0000C34E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C34E                            Debug_Control:
0000C34E 7006                       		moveq	#6,d0				; Speed
0000C350 0838 0000 C740             		btst	#0,rP1Hold.w			; Is up being held?
0000C356 6700                       		beq.s	.NoUp				; If not, branch
0000C358 9168 0018                  		sub.w	d0,oYPos(a0)			; Move up
0000C35C                            
0000C35C                            .NoUp:
0000C35C 0838 0001 C740             		btst	#1,rP1Hold.w			; Is down being held?
0000C362 6700                       		beq.s	.NoDown				; If not, branch
0000C364 D168 0018                  		add.w	d0,oYPos(a0)			; Move down
0000C368                            
0000C368                            .NoDown:
0000C368 0838 0002 C740             		btst	#2,rP1Hold.w			; Is left being held?
0000C36E 6700                       		beq.s	.NoLeft				; If not, branch
0000C370 9168 0014                  		sub.w	d0,oXPos(a0)			; Move left
0000C374                            
0000C374                            .NoLeft:
0000C374 0838 0003 C740             		btst	#3,rP1Hold.w			; Is right being held?
0000C37A 6700                       		beq.s	.NoRight			; If not, branch
0000C37C D168 0014                  		add.w	d0,oXPos(a0)			; Move right
0000C380                            
0000C380                            .NoRight:
0000C380 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000C386 6700                       		beq.s	.ChkWrap			; If not, branch
0000C388 7000                       		moveq	#0,d0
0000C38A 11C0 F8D1                  		move.b	d0,rDebugMode.w		; Disable debug placement mode
0000C38E 1140 0016                  		move.b	d0,oXPos+2(a0)			; Reset X subpixel
0000C392 1140 001A                  		move.b	d0,oYPos+2(a0)			; Reset Y subpixel
0000C396 3140 001C                  		move.w	d0,oXVel(a0)			; Reset X velocity
0000C39A 3140 001E                  		move.w	d0,oYVel(a0)			; Reset Y velocity
0000C39E 3140 003A                  		move.w	d0,oGVel(a0)			; Reset ground velocity
0000C3A2 0228 0001 0028             		andi.b	#1,oStatus(a0)			; Reset status
0000C3A8 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000C3AE 20BC 0000 B03A             		move.l	#ObjMighty,oAddr(a0)		; Use normal Sonic object
0000C3B4 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
0000C3BA 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000C3C0                            
0000C3C0                            .ChkWrap:
0000C3C0 4E75                       		rts
0000C3C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C3C2                            ; Data
0000C3C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000C3C2                            ArtUnc_Sonic:
0000C3C2                            		incbin	"Level/Objects/Mighty/Art.unc.bin"
00017E82                            		even
00017E82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00017E82                            Map_ObjMighty:
00017E82                            		include	"Level/Objects/Mighty/Mappings.asm"
00017E82                            ; --------------------------------------------------------------------------------
00017E82                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00017E82                            ; --------------------------------------------------------------------------------
00017E82                            
00017E82                            SME_lde97:	
00017E82 0000 0000                  		dc.w SME_lde97_FC-SME_lde97, SME_lde97_FE-SME_lde97	
00017E86 0000 0000                  		dc.w SME_lde97_118-SME_lde97, SME_lde97_12C-SME_lde97	
00017E8A 0000 0000                  		dc.w SME_lde97_140-SME_lde97, SME_lde97_154-SME_lde97	
00017E8E 0000 0000                  		dc.w SME_lde97_168-SME_lde97, SME_lde97_182-SME_lde97	
00017E92 0000 0000                  		dc.w SME_lde97_190-SME_lde97, SME_lde97_19E-SME_lde97	
00017E96 0000 0000                  		dc.w SME_lde97_1B8-SME_lde97, SME_lde97_1C6-SME_lde97	
00017E9A 0000 0000                  		dc.w SME_lde97_1DA-SME_lde97, SME_lde97_1FA-SME_lde97	
00017E9E 0000 0000                  		dc.w SME_lde97_220-SME_lde97, SME_lde97_23A-SME_lde97	
00017EA2 0000 0000                  		dc.w SME_lde97_25A-SME_lde97, SME_lde97_274-SME_lde97	
00017EA6 0000 0000                  		dc.w SME_lde97_294-SME_lde97, SME_lde97_2AE-SME_lde97	
00017EAA 0000 0000                  		dc.w SME_lde97_2BC-SME_lde97, SME_lde97_2CA-SME_lde97	
00017EAE 0000 0000                  		dc.w SME_lde97_2E4-SME_lde97, SME_lde97_2F2-SME_lde97	
00017EB2 0000 0000                  		dc.w SME_lde97_306-SME_lde97, SME_lde97_32C-SME_lde97	
00017EB6 0000 0000                  		dc.w SME_lde97_352-SME_lde97, SME_lde97_36C-SME_lde97	
00017EBA 0000 0000                  		dc.w SME_lde97_38C-SME_lde97, SME_lde97_3A6-SME_lde97	
00017EBE 0000 0000                  		dc.w SME_lde97_3C6-SME_lde97, SME_lde97_3D4-SME_lde97	
00017EC2 0000 0000                  		dc.w SME_lde97_3E2-SME_lde97, SME_lde97_3F0-SME_lde97	
00017EC6 0000 0000                  		dc.w SME_lde97_3FE-SME_lde97, SME_lde97_418-SME_lde97	
00017ECA 0000 0000                  		dc.w SME_lde97_42C-SME_lde97, SME_lde97_446-SME_lde97	
00017ECE 0000 0000                  		dc.w SME_lde97_45A-SME_lde97, SME_lde97_468-SME_lde97	
00017ED2 0000 0000                  		dc.w SME_lde97_476-SME_lde97, SME_lde97_484-SME_lde97	
00017ED6 0000 0000                  		dc.w SME_lde97_492-SME_lde97, SME_lde97_4AC-SME_lde97	
00017EDA 0000 0000                  		dc.w SME_lde97_4BA-SME_lde97, SME_lde97_4D4-SME_lde97	
00017EDE 0000 0000                  		dc.w SME_lde97_4E2-SME_lde97, SME_lde97_4EA-SME_lde97	
00017EE2 0000 0000                  		dc.w SME_lde97_4F2-SME_lde97, SME_lde97_4FA-SME_lde97	
00017EE6 0000 0000                  		dc.w SME_lde97_502-SME_lde97, SME_lde97_50A-SME_lde97	
00017EEA 0000 0000                  		dc.w SME_lde97_50C-SME_lde97, SME_lde97_50E-SME_lde97	
00017EEE 0000 0000                  		dc.w SME_lde97_510-SME_lde97, SME_lde97_512-SME_lde97	
00017EF2 0000 0000                  		dc.w SME_lde97_520-SME_lde97, SME_lde97_53A-SME_lde97	
00017EF6 0000 0000                  		dc.w SME_lde97_554-SME_lde97, SME_lde97_568-SME_lde97	
00017EFA 0000 0000                  		dc.w SME_lde97_57C-SME_lde97, SME_lde97_590-SME_lde97	
00017EFE 0000 0000                  		dc.w SME_lde97_59E-SME_lde97, SME_lde97_5B2-SME_lde97	
00017F02 0000 0000                  		dc.w SME_lde97_5C6-SME_lde97, SME_lde97_5DA-SME_lde97	
00017F06 0000 0000                  		dc.w SME_lde97_5F4-SME_lde97, SME_lde97_60E-SME_lde97	
00017F0A 0000 0000                  		dc.w SME_lde97_610-SME_lde97, SME_lde97_612-SME_lde97	
00017F0E 0000 0000                  		dc.w SME_lde97_620-SME_lde97, SME_lde97_634-SME_lde97	
00017F12 0000 0000                  		dc.w SME_lde97_642-SME_lde97, SME_lde97_656-SME_lde97	
00017F16 0000 0000                  		dc.w SME_lde97_658-SME_lde97, SME_lde97_65A-SME_lde97	
00017F1A 0000 0000                  		dc.w SME_lde97_65C-SME_lde97, SME_lde97_67C-SME_lde97	
00017F1E 0000 0000                  		dc.w SME_lde97_69C-SME_lde97, SME_lde97_69E-SME_lde97	
00017F22 0000 0000                  		dc.w SME_lde97_6A0-SME_lde97, SME_lde97_6A2-SME_lde97	
00017F26 0000 0000                  		dc.w SME_lde97_6A4-SME_lde97, SME_lde97_6A6-SME_lde97	
00017F2A 0000 0000                  		dc.w SME_lde97_6BA-SME_lde97, SME_lde97_6CE-SME_lde97	
00017F2E 0000 0000                  		dc.w SME_lde97_6E2-SME_lde97, SME_lde97_6F6-SME_lde97	
00017F32 0000 0000                  		dc.w SME_lde97_704-SME_lde97, SME_lde97_712-SME_lde97	
00017F36 0000 0000                  		dc.w SME_lde97_720-SME_lde97, SME_lde97_72E-SME_lde97	
00017F3A 0000 0000                  		dc.w SME_lde97_73C-SME_lde97, SME_lde97_73E-SME_lde97	
00017F3E 0000 0000                  		dc.w SME_lde97_740-SME_lde97, SME_lde97_742-SME_lde97	
00017F42 0000 0000                  		dc.w SME_lde97_744-SME_lde97, SME_lde97_746-SME_lde97	
00017F46 0000 0000                  		dc.w SME_lde97_748-SME_lde97, SME_lde97_74A-SME_lde97	
00017F4A 0000 0000                  		dc.w SME_lde97_74C-SME_lde97, SME_lde97_74E-SME_lde97	
00017F4E 0000 0000                  		dc.w SME_lde97_750-SME_lde97, SME_lde97_752-SME_lde97	
00017F52 0000 0000                  		dc.w SME_lde97_754-SME_lde97, SME_lde97_768-SME_lde97	
00017F56 0000 0000                  		dc.w SME_lde97_77C-SME_lde97, SME_lde97_78A-SME_lde97	
00017F5A 0000 0000                  		dc.w SME_lde97_792-SME_lde97, SME_lde97_7A0-SME_lde97	
00017F5E 0000 0000                  		dc.w SME_lde97_7B4-SME_lde97, SME_lde97_7C8-SME_lde97	
00017F62 0000 0000                  		dc.w SME_lde97_7DC-SME_lde97, SME_lde97_7EA-SME_lde97	
00017F66 0000 0000                  		dc.w SME_lde97_7F8-SME_lde97, SME_lde97_80C-SME_lde97	
00017F6A 0000 0000                  		dc.w SME_lde97_81A-SME_lde97, SME_lde97_828-SME_lde97	
00017F6E 0000 0000                  		dc.w SME_lde97_836-SME_lde97, SME_lde97_844-SME_lde97	
00017F72 0000 0000                  		dc.w SME_lde97_858-SME_lde97, SME_lde97_86C-SME_lde97	
00017F76 0000 0000                  		dc.w SME_lde97_880-SME_lde97, SME_lde97_89A-SME_lde97	
00017F7A 0000 0000                  		dc.w SME_lde97_8B4-SME_lde97, SME_lde97_8CE-SME_lde97	
00017F7E 0000                       SME_lde97_FC:	dc.b 0, 0	
00017F80 0004                       SME_lde97_FE:	dc.b 0, 4	
00017F82 EC08 0000 FFF0             		dc.b $EC, 8, 0, 0, $FF, $F0	
00017F88 F40D 0003 FFF0             		dc.b $F4, $D, 0, 3, $FF, $F0	
00017F8E 0408 000B FFF0             		dc.b 4, 8, 0, $B, $FF, $F0	
00017F94 0C08 000E FFF8             		dc.b $C, 8, 0, $E, $FF, $F8	
00017F9A 0003                       SME_lde97_118:	dc.b 0, 3	
00017F9C EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017FA2 FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017FA8 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017FAE 0003                       SME_lde97_12C:	dc.b 0, 3	
00017FB0 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017FB6 FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017FBC 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017FC2 0003                       SME_lde97_140:	dc.b 0, 3	
00017FC4 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00017FCA FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00017FD0 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017FD6 0003                       SME_lde97_154:	dc.b 0, 3	
00017FD8 EC0A 0000 FFF0             		dc.b $EC, $A, 0, 0, $FF, $F0	
00017FDE 0408 0009 FFF0             		dc.b 4, 8, 0, 9, $FF, $F0	
00017FE4 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00017FEA 0004                       SME_lde97_168:	dc.b 0, 4	
00017FEC EB0D 0000 FFEC             		dc.b $EB, $D, 0, 0, $FF, $EC	
00017FF2 FB09 0008 FFEC             		dc.b $FB, 9, 0, 8, $FF, $EC	
00017FF8 FB06 000E 0004             		dc.b $FB, 6, 0, $E, 0, 4	
00017FFE 0B04 0014 FFEC             		dc.b $B, 4, 0, $14, $FF, $EC	
00018004 0002                       SME_lde97_182:	dc.b 0, 2	
00018006 EC0D 0000 FFED             		dc.b $EC, $D, 0, 0, $FF, $ED	
0001800C FC0E 0008 FFF5             		dc.b $FC, $E, 0, 8, $FF, $F5	
00018012 0002                       SME_lde97_190:	dc.b 0, 2	
00018014 ED09 0000 FFF3             		dc.b $ED, 9, 0, 0, $FF, $F3	
0001801A FD0A 0006 FFF3             		dc.b $FD, $A, 0, 6, $FF, $F3	
00018020 0004                       SME_lde97_19E:	dc.b 0, 4	
00018022 EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
00018028 FB09 0006 FFEC             		dc.b $FB, 9, 0, 6, $FF, $EC	
0001802E FB06 000C 0004             		dc.b $FB, 6, 0, $C, 0, 4	
00018034 0B04 0012 FFEC             		dc.b $B, 4, 0, $12, $FF, $EC	
0001803A 0002                       SME_lde97_1B8:	dc.b 0, 2	
0001803C EC09 0000 FFF3             		dc.b $EC, 9, 0, 0, $FF, $F3	
00018042 FC0E 0006 FFEB             		dc.b $FC, $E, 0, 6, $FF, $EB	
00018048 0003                       SME_lde97_1C6:	dc.b 0, 3	
0001804A ED0D 0000 FFEC             		dc.b $ED, $D, 0, 0, $FF, $EC	
00018050 FD0C 0008 FFF4             		dc.b $FD, $C, 0, 8, $FF, $F4	
00018056 0509 000C FFF4             		dc.b 5, 9, 0, $C, $FF, $F4	
0001805C 0005                       SME_lde97_1DA:	dc.b 0, 5	
0001805E EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
00018064 EB06 0006 0003             		dc.b $EB, 6, 0, 6, 0, 3	
0001806A FB08 000C FFEB             		dc.b $FB, 8, 0, $C, $FF, $EB	
00018070 0309 000F FFF3             		dc.b 3, 9, 0, $F, $FF, $F3	
00018076 1300 0015 FFFB             		dc.b $13, 0, 0, $15, $FF, $FB	
0001807C 0006                       SME_lde97_1FA:	dc.b 0, 6	
0001807E EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
00018084 EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
0001808A FC0C 0008 FFEC             		dc.b $FC, $C, 0, 8, $FF, $EC	
00018090 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
00018096 FC05 0012 000C             		dc.b $FC, 5, 0, $12, 0, $C	
0001809C F400 0016 0014             		dc.b $F4, 0, 0, $16, 0, $14	
000180A2 0004                       SME_lde97_220:	dc.b 0, 4	
000180A4 ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
000180AA ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
000180B0 FD0D 0008 FFF5             		dc.b $FD, $D, 0, 8, $FF, $F5	
000180B6 0D08 0010 FFFD             		dc.b $D, 8, 0, $10, $FF, $FD	
000180BC 0005                       SME_lde97_23A:	dc.b 0, 5	
000180BE EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
000180C4 EB05 0006 0003             		dc.b $EB, 5, 0, 6, 0, 3	
000180CA FB0D 000A FFF3             		dc.b $FB, $D, 0, $A, $FF, $F3	
000180D0 0B08 0012 FFF3             		dc.b $B, 8, 0, $12, $FF, $F3	
000180D6 1304 0015 FFFB             		dc.b $13, 4, 0, $15, $FF, $FB	
000180DC 0004                       SME_lde97_25A:	dc.b 0, 4	
000180DE EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
000180E4 EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
000180EA FC0D 0008 FFF4             		dc.b $FC, $D, 0, 8, $FF, $F4	
000180F0 0C08 0010 FFFC             		dc.b $C, 8, 0, $10, $FF, $FC	
000180F6 0005                       SME_lde97_274:	dc.b 0, 5	
000180F8 ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
000180FE ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
00018104 FD00 0008 FFED             		dc.b $FD, 0, 0, 8, $FF, $ED	
0001810A FD0D 0009 FFF5             		dc.b $FD, $D, 0, 9, $FF, $F5	
00018110 0D08 0011 FFFD             		dc.b $D, 8, 0, $11, $FF, $FD	
00018116 0004                       SME_lde97_294:	dc.b 0, 4	
00018118 F407 0000 FFEB             		dc.b $F4, 7, 0, 0, $FF, $EB	
0001811E EC09 0008 FFFB             		dc.b $EC, 9, 0, 8, $FF, $FB	
00018124 FC04 000E FFFB             		dc.b $FC, 4, 0, $E, $FF, $FB	
0001812A 0409 0010 FFFB             		dc.b 4, 9, 0, $10, $FF, $FB	
00018130 0002                       SME_lde97_2AE:	dc.b 0, 2	
00018132 F407 0000 FFEC             		dc.b $F4, 7, 0, 0, $FF, $EC	
00018138 EC0B 0008 FFFC             		dc.b $EC, $B, 0, 8, $FF, $FC	
0001813E 0002                       SME_lde97_2BC:	dc.b 0, 2	
00018140 F406 0000 FFED             		dc.b $F4, 6, 0, 0, $FF, $ED	
00018146 F40A 0006 FFFD             		dc.b $F4, $A, 0, 6, $FF, $FD	
0001814C 0004                       SME_lde97_2CA:	dc.b 0, 4	
0001814E F406 0000 FFEB             		dc.b $F4, 6, 0, 0, $FF, $EB	
00018154 EC09 0006 FFFB             		dc.b $EC, 9, 0, 6, $FF, $FB	
0001815A FC04 000C FFFB             		dc.b $FC, 4, 0, $C, $FF, $FB	
00018160 0409 000E FFFB             		dc.b 4, 9, 0, $E, $FF, $FB	
00018166 0002                       SME_lde97_2E4:	dc.b 0, 2	
00018168 F406 0000 FFEC             		dc.b $F4, 6, 0, 0, $FF, $EC	
0001816E F40B 0006 FFFC             		dc.b $F4, $B, 0, 6, $FF, $FC	
00018174 0003                       SME_lde97_2F2:	dc.b 0, 3	
00018176 F407 0000 FFED             		dc.b $F4, 7, 0, 0, $FF, $ED	
0001817C EC00 0008 FFFD             		dc.b $EC, 0, 0, 8, $FF, $FD	
00018182 F40A 0009 FFFD             		dc.b $F4, $A, 0, 9, $FF, $FD	
00018188 0006                       SME_lde97_306:	dc.b 0, 6	
0001818A FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
00018190 ED04 0006 FFF3             		dc.b $ED, 4, 0, 6, $FF, $F3	
00018196 F504 0008 FFEB             		dc.b $F5, 4, 0, 8, $FF, $EB	
0001819C F50A 000A FFFB             		dc.b $F5, $A, 0, $A, $FF, $FB	
000181A2 0D00 0013 FFFB             		dc.b $D, 0, 0, $13, $FF, $FB	
000181A8 FD00 0014 0013             		dc.b $FD, 0, 0, $14, 0, $13	
000181AE 0006                       SME_lde97_32C:	dc.b 0, 6	
000181B0 FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
000181B6 E408 0006 FFF4             		dc.b $E4, 8, 0, 6, $FF, $F4	
000181BC EC04 0009 FFFC             		dc.b $EC, 4, 0, 9, $FF, $FC	
000181C2 F404 000B FFEC             		dc.b $F4, 4, 0, $B, $FF, $EC	
000181C8 F40A 000D FFFC             		dc.b $F4, $A, 0, $D, $FF, $FC	
000181CE 0C00 0016 FFFC             		dc.b $C, 0, 0, $16, $FF, $FC	
000181D4 0004                       SME_lde97_352:	dc.b 0, 4	
000181D6 FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
000181DC F304 0006 FFED             		dc.b $F3, 4, 0, 6, $FF, $ED	
000181E2 EB0A 0008 FFFD             		dc.b $EB, $A, 0, 8, $FF, $FD	
000181E8 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
000181EE 0005                       SME_lde97_36C:	dc.b 0, 5	
000181F0 FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
000181F6 ED08 0006 FFF3             		dc.b $ED, 8, 0, 6, $FF, $F3	
000181FC F504 0009 FFEB             		dc.b $F5, 4, 0, 9, $FF, $EB	
00018202 F50D 000B FFFB             		dc.b $F5, $D, 0, $B, $FF, $FB	
00018208 0508 0013 FFFB             		dc.b 5, 8, 0, $13, $FF, $FB	
0001820E 0004                       SME_lde97_38C:	dc.b 0, 4	
00018210 FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
00018216 F404 0006 FFEC             		dc.b $F4, 4, 0, 6, $FF, $EC	
0001821C EC0A 0008 FFFC             		dc.b $EC, $A, 0, 8, $FF, $FC	
00018222 0404 0011 FFFC             		dc.b 4, 4, 0, $11, $FF, $FC	
00018228 0005                       SME_lde97_3A6:	dc.b 0, 5	
0001822A FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
00018230 EB0A 0006 FFFD             		dc.b $EB, $A, 0, 6, $FF, $FD	
00018236 F304 000F FFED             		dc.b $F3, 4, 0, $F, $FF, $ED	
0001823C 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
00018242 0B00 0013 FFFD             		dc.b $B, 0, 0, $13, $FF, $FD	
00018248 0002                       SME_lde97_3C6:	dc.b 0, 2	
0001824A EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
00018250 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
00018256 0002                       SME_lde97_3D4:	dc.b 0, 2	
00018258 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
0001825E FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
00018264 0002                       SME_lde97_3E2:	dc.b 0, 2	
00018266 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
0001826C FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
00018272 0002                       SME_lde97_3F0:	dc.b 0, 2	
00018274 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
0001827A FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
00018280 0004                       SME_lde97_3FE:	dc.b 0, 4	
00018282 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
00018288 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
0001828E FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
00018294 FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
0001829A 0003                       SME_lde97_418:	dc.b 0, 3	
0001829C EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
000182A2 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
000182A8 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
000182AE 0004                       SME_lde97_42C:	dc.b 0, 4	
000182B0 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
000182B6 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
000182BC FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
000182C2 FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
000182C8 0003                       SME_lde97_446:	dc.b 0, 3	
000182CA EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
000182D0 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
000182D6 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
000182DC 0002                       SME_lde97_45A:	dc.b 0, 2	
000182DE F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
000182E4 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
000182EA 0002                       SME_lde97_468:	dc.b 0, 2	
000182EC F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
000182F2 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
000182F8 0002                       SME_lde97_476:	dc.b 0, 2	
000182FA F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00018300 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
00018306 0002                       SME_lde97_484:	dc.b 0, 2	
00018308 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
0001830E F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
00018314 0004                       SME_lde97_492:	dc.b 0, 4	
00018316 FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
0001831C F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
00018322 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
00018328 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
0001832E 0002                       SME_lde97_4AC:	dc.b 0, 2	
00018330 F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
00018336 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
0001833C 0004                       SME_lde97_4BA:	dc.b 0, 4	
0001833E FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
00018344 F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
0001834A EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
00018350 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
00018356 0002                       SME_lde97_4D4:	dc.b 0, 2	
00018358 F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
0001835E EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
00018364 0001                       SME_lde97_4E2:	dc.b 0, 1	
00018366 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001836C 0001                       SME_lde97_4EA:	dc.b 0, 1	
0001836E F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
00018374 0001                       SME_lde97_4F2:	dc.b 0, 1	
00018376 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001837C 0001                       SME_lde97_4FA:	dc.b 0, 1	
0001837E F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
00018384 0001                       SME_lde97_502:	dc.b 0, 1	
00018386 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001838C 0000                       SME_lde97_50A:	dc.b 0, 0	
0001838E 0000                       SME_lde97_50C:	dc.b 0, 0	
00018390 0000                       SME_lde97_50E:	dc.b 0, 0	
00018392 0000                       SME_lde97_510:	dc.b 0, 0	
00018394 0002                       SME_lde97_512:	dc.b 0, 2	
00018396 ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
0001839C FD0E 0006 FFF0             		dc.b $FD, $E, 0, 6, $FF, $F0	
000183A2 0004                       SME_lde97_520:	dc.b 0, 4	
000183A4 ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
000183AA FD0D 0006 FFF0             		dc.b $FD, $D, 0, 6, $FF, $F0	
000183B0 0D04 000E 0000             		dc.b $D, 4, 0, $E, 0, 0	
000183B6 0500 0010 FFE8             		dc.b 5, 0, 0, $10, $FF, $E8	
000183BC 0004                       SME_lde97_53A:	dc.b 0, 4	
000183BE F404 0000 FFFC             		dc.b $F4, 4, 0, 0, $FF, $FC	
000183C4 FC0D 0002 FFF4             		dc.b $FC, $D, 0, 2, $FF, $F4	
000183CA 0C08 000A FFF4             		dc.b $C, 8, 0, $A, $FF, $F4	
000183D0 0400 000D FFEC             		dc.b 4, 0, 0, $D, $FF, $EC	
000183D6 0003                       SME_lde97_554:	dc.b 0, 3	
000183D8 EC08 0800 FFE8             		dc.b $EC, 8, 8, 0, $FF, $E8	
000183DE F402 0803 0000             		dc.b $F4, 2, 8, 3, 0, 0	
000183E4 F40F 0806 FFE0             		dc.b $F4, $F, 8, 6, $FF, $E0	
000183EA 0003                       SME_lde97_568:	dc.b 0, 3	
000183EC EC0E 0800 FFE8             		dc.b $EC, $E, 8, 0, $FF, $E8	
000183F2 040D 080C FFE0             		dc.b 4, $D, 8, $C, $FF, $E0	
000183F8 0C00 1814 0000             		dc.b $C, 0, $18, $14, 0, 0	
000183FE 0003                       SME_lde97_57C:	dc.b 0, 3	
00018400 F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
00018406 FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
0001840C 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
00018412 0002                       SME_lde97_590:	dc.b 0, 2	
00018414 F40A 0000 FFE8             		dc.b $F4, $A, 0, 0, $FF, $E8	
0001841A F40A 0800 0000             		dc.b $F4, $A, 8, 0, 0, 0	
00018420 0003                       SME_lde97_59E:	dc.b 0, 3	
00018422 F40D 0000 FFE4             		dc.b $F4, $D, 0, 0, $FF, $E4	
00018428 FC00 0008 0004             		dc.b $FC, 0, 0, 8, 0, 4	
0001842E 040C 0009 FFEC             		dc.b 4, $C, 0, 9, $FF, $EC	
00018434 0003                       SME_lde97_5B2:	dc.b 0, 3	
00018436 F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
0001843C FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
00018442 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
00018448 0003                       SME_lde97_5C6:	dc.b 0, 3	
0001844A E80B 0000 FFF0             		dc.b $E8, $B, 0, 0, $FF, $F0	
00018450 0804 000C FFF8             		dc.b 8, 4, 0, $C, $FF, $F8	
00018456 1000 000E FFF8             		dc.b $10, 0, 0, $E, $FF, $F8	
0001845C 0004                       SME_lde97_5DA:	dc.b 0, 4	
0001845E F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
00018464 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
0001846A F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
00018470 F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
00018476 0004                       SME_lde97_5F4:	dc.b 0, 4	
00018478 F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
0001847E 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
00018484 F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
0001848A F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
00018490 0000                       SME_lde97_60E:	dc.b 0, 0	
00018492 0000                       SME_lde97_610:	dc.b 0, 0	
00018494 0002                       SME_lde97_612:	dc.b 0, 2	
00018496 ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
0001849C 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
000184A2 0003                       SME_lde97_620:	dc.b 0, 3	
000184A4 EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
000184AA 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
000184B0 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
000184B6 0002                       SME_lde97_634:	dc.b 0, 2	
000184B8 ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
000184BE 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
000184C4 0003                       SME_lde97_642:	dc.b 0, 3	
000184C6 EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
000184CC 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
000184D2 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
000184D8 0000                       SME_lde97_656:	dc.b 0, 0	
000184DA 0000                       SME_lde97_658:	dc.b 0, 0	
000184DC 0000                       SME_lde97_65A:	dc.b 0, 0	
000184DE 0005                       SME_lde97_65C:	dc.b 0, 5	
000184E0 E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
000184E6 E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
000184EC F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
000184F2 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
000184F8 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
000184FE 0005                       SME_lde97_67C:	dc.b 0, 5	
00018500 E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
00018506 E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
0001850C F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
00018512 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
00018518 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
0001851E 0000                       SME_lde97_69C:	dc.b 0, 0	
00018520 0000                       SME_lde97_69E:	dc.b 0, 0	
00018522 0000                       SME_lde97_6A0:	dc.b 0, 0	
00018524 0000                       SME_lde97_6A2:	dc.b 0, 0	
00018526 0000                       SME_lde97_6A4:	dc.b 0, 0	
00018528 0003                       SME_lde97_6A6:	dc.b 0, 3	
0001852A F40D 0800 FFE4             		dc.b $F4, $D, 8, 0, $FF, $E4	
00018530 FC05 0808 0004             		dc.b $FC, 5, 8, 8, 0, 4	
00018536 0408 080C FFEC             		dc.b 4, 8, 8, $C, $FF, $EC	
0001853C 0003                       SME_lde97_6BA:	dc.b 0, 3	
0001853E F40D 0800 FFFC             		dc.b $F4, $D, 8, 0, $FF, $FC	
00018544 FC00 0808 FFF4             		dc.b $FC, 0, 8, 8, $FF, $F4	
0001854A 040C 0809 FFF4             		dc.b 4, $C, 8, 9, $FF, $F4	
00018550 0003                       SME_lde97_6CE:	dc.b 0, 3	
00018552 F00E 0000 FFEC             		dc.b $F0, $E, 0, 0, $FF, $EC	
00018558 F801 000C 000C             		dc.b $F8, 1, 0, $C, 0, $C	
0001855E 080C 000E FFF4             		dc.b 8, $C, 0, $E, $FF, $F4	
00018564 0003                       SME_lde97_6E2:	dc.b 0, 3	
00018566 EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
0001856C FB0E 0006 FFEC             		dc.b $FB, $E, 0, 6, $FF, $EC	
00018572 0301 0012 000C             		dc.b 3, 1, 0, $12, 0, $C	
00018578 0002                       SME_lde97_6F6:	dc.b 0, 2	
0001857A F00F 0000 FFEC             		dc.b $F0, $F, 0, 0, $FF, $EC	
00018580 F802 0010 000C             		dc.b $F8, 2, 0, $10, 0, $C	
00018586 0002                       SME_lde97_704:	dc.b 0, 2	
00018588 F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
0001858E FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
00018594 0002                       SME_lde97_712:	dc.b 0, 2	
00018596 F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
0001859C FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
000185A2 0002                       SME_lde97_720:	dc.b 0, 2	
000185A4 F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
000185AA FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
000185B0 0002                       SME_lde97_72E:	dc.b 0, 2	
000185B2 F40F 0000 FFF5             		dc.b $F4, $F, 0, 0, $FF, $F5	
000185B8 FC01 0010 FFED             		dc.b $FC, 1, 0, $10, $FF, $ED	
000185BE 0000                       SME_lde97_73C:	dc.b 0, 0	
000185C0 0000                       SME_lde97_73E:	dc.b 0, 0	
000185C2 0000                       SME_lde97_740:	dc.b 0, 0	
000185C4 0000                       SME_lde97_742:	dc.b 0, 0	
000185C6 0000                       SME_lde97_744:	dc.b 0, 0	
000185C8 0000                       SME_lde97_746:	dc.b 0, 0	
000185CA 0000                       SME_lde97_748:	dc.b 0, 0	
000185CC 0000                       SME_lde97_74A:	dc.b 0, 0	
000185CE 0000                       SME_lde97_74C:	dc.b 0, 0	
000185D0 0000                       SME_lde97_74E:	dc.b 0, 0	
000185D2 0000                       SME_lde97_750:	dc.b 0, 0	
000185D4 0000                       SME_lde97_752:	dc.b 0, 0	
000185D6 0003                       SME_lde97_754:	dc.b 0, 3	
000185D8 E409 0000 FFF0             		dc.b $E4, 9, 0, 0, $FF, $F0	
000185DE F40B 0006 FFF0             		dc.b $F4, $B, 0, 6, $FF, $F0	
000185E4 F401 0012 0008             		dc.b $F4, 1, 0, $12, 0, 8	
000185EA 0003                       SME_lde97_768:	dc.b 0, 3	
000185EC E50B 0000 FFF0             		dc.b $E5, $B, 0, 0, $FF, $F0	
000185F2 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
000185F8 0505 000E FFF8             		dc.b 5, 5, 0, $E, $FF, $F8	
000185FE 0002                       SME_lde97_77C:	dc.b 0, 2	
00018600 EC0B 0000 FFF1             		dc.b $EC, $B, 0, 0, $FF, $F1	
00018606 FC01 000C 0009             		dc.b $FC, 1, 0, $C, 0, 9	
0001860C 0001                       SME_lde97_78A:	dc.b 0, 1	
0001860E EE0F 0000 FFF0             		dc.b $EE, $F, 0, 0, $FF, $F0	
00018614 0002                       SME_lde97_792:	dc.b 0, 2	
00018616 F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
0001861C FA01 000C 0008             		dc.b $FA, 1, 0, $C, 0, 8	
00018622 0003                       SME_lde97_7A0:	dc.b 0, 3	
00018624 F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
0001862A E401 000C 0000             		dc.b $E4, 1, 0, $C, 0, 0	
00018630 F401 000E 0008             		dc.b $F4, 1, 0, $E, 0, 8	
00018636 0003                       SME_lde97_7B4:	dc.b 0, 3	
00018638 E509 0000 FFF0             		dc.b $E5, 9, 0, 0, $FF, $F0	
0001863E F50B 0006 FFF0             		dc.b $F5, $B, 0, 6, $FF, $F0	
00018644 ED03 0012 0008             		dc.b $ED, 3, 0, $12, 0, 8	
0001864A 0003                       SME_lde97_7C8:	dc.b 0, 3	
0001864C F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
00018652 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
00018658 E405 000E FFF8             		dc.b $E4, 5, 0, $E, $FF, $F8	
0001865E 0002                       SME_lde97_7DC:	dc.b 0, 2	
00018660 ED0B 0000 FFF0             		dc.b $ED, $B, 0, 0, $FF, $F0	
00018666 F501 000C 0008             		dc.b $F5, 1, 0, $C, 0, 8	
0001866C 0002                       SME_lde97_7EA:	dc.b 0, 2	
0001866E F10B 0000 FFF8             		dc.b $F1, $B, 0, 0, $FF, $F8	
00018674 F401 000C FFF0             		dc.b $F4, 1, 0, $C, $FF, $F0	
0001867A 0003                       SME_lde97_7F8:	dc.b 0, 3	
0001867C F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
00018682 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
00018688 E405 000E FFF1             		dc.b $E4, 5, 0, $E, $FF, $F1	
0001868E 0002                       SME_lde97_80C:	dc.b 0, 2	
00018690 F10F 0000 FFF0             		dc.b $F1, $F, 0, 0, $FF, $F0	
00018696 E105 0010 FFF0             		dc.b $E1, 5, 0, $10, $FF, $F0	
0001869C 0002                       SME_lde97_81A:	dc.b 0, 2	
0001869E EC0E 0000 FFEC             		dc.b $EC, $E, 0, 0, $FF, $EC	
000186A4 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
000186AA 0002                       SME_lde97_828:	dc.b 0, 2	
000186AC EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
000186B2 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
000186B8 0002                       SME_lde97_836:	dc.b 0, 2	
000186BA EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
000186C0 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
000186C6 0003                       SME_lde97_844:	dc.b 0, 3	
000186C8 E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
000186CE 0008 000C FFF0             		dc.b 0, 8, 0, $C, $FF, $F0	
000186D4 0809 000F FFF8             		dc.b 8, 9, 0, $F, $FF, $F8	
000186DA 0003                       SME_lde97_858:	dc.b 0, 3	
000186DC E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
000186E2 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
000186E8 100C 0012 FFF0             		dc.b $10, $C, 0, $12, $FF, $F0	
000186EE 0003                       SME_lde97_86C:	dc.b 0, 3	
000186F0 E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
000186F6 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
000186FC 1004 0012 FFF0             		dc.b $10, 4, 0, $12, $FF, $F0	
00018702 0004                       SME_lde97_880:	dc.b 0, 4	
00018704 EC0E 0800 FFF0             		dc.b $EC, $E, 8, 0, $FF, $F0	
0001870A FC01 080C 0010             		dc.b $FC, 1, 8, $C, 0, $10	
00018710 0408 080E FFF8             		dc.b 4, 8, 8, $E, $FF, $F8	
00018716 0C04 0811 0000             		dc.b $C, 4, 8, $11, 0, 0	
0001871C 0004                       SME_lde97_89A:	dc.b 0, 4	
0001871E EC0E 0000 FFF8             		dc.b $EC, $E, 0, 0, $FF, $F8	
00018724 FC01 000C FFF0             		dc.b $FC, 1, 0, $C, $FF, $F0	
0001872A 0408 000E FFF8             		dc.b 4, 8, 0, $E, $FF, $F8	
00018730 0C04 0011 FFF8             		dc.b $C, 4, 0, $11, $FF, $F8	
00018736 0004                       SME_lde97_8B4:	dc.b 0, 4	
00018738 FC0E 1000 FFF8             		dc.b $FC, $E, $10, 0, $FF, $F8	
0001873E F401 100C FFF0             		dc.b $F4, 1, $10, $C, $FF, $F0	
00018744 F408 100E FFF8             		dc.b $F4, 8, $10, $E, $FF, $F8	
0001874A EC04 1011 FFF8             		dc.b $EC, 4, $10, $11, $FF, $F8	
00018750 0004                       SME_lde97_8CE:	dc.b 0, 4	
00018752 FC0E 1800 FFF0             		dc.b $FC, $E, $18, 0, $FF, $F0	
00018758 F401 180C 0010             		dc.b $F4, 1, $18, $C, 0, $10	
0001875E F408 180E FFF8             		dc.b $F4, 8, $18, $E, $FF, $F8	
00018764 EC04 1811 0000             		dc.b $EC, 4, $18, $11, 0, 0	
0001876A                            		even
0001876A                            		even
0001876A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001876A                            DPLC_ObjMighty:
0001876A                            		include	"Level/Objects/Mighty/DPLCs.asm"
0001876A                            ; --------------------------------------------------------------------------------
0001876A                            ; Dynamic Pattern Loading Cues - output from SonMapEd - Sonic 3 & Knuckles format; --------------------------------------------------------------------------------
0001876A                            
0001876A                            SME_CfLJT:	
0001876A 0000 0000                  		dc.w SME_CfLJT_FC-SME_CfLJT, SME_CfLJT_FE-SME_CfLJT	
0001876E 0000 0000                  		dc.w SME_CfLJT_108-SME_CfLJT, SME_CfLJT_110-SME_CfLJT	
00018772 0000 0000                  		dc.w SME_CfLJT_118-SME_CfLJT, SME_CfLJT_120-SME_CfLJT	
00018776 0000 0000                  		dc.w SME_CfLJT_128-SME_CfLJT, SME_CfLJT_132-SME_CfLJT	
0001877A 0000 0000                  		dc.w SME_CfLJT_138-SME_CfLJT, SME_CfLJT_13E-SME_CfLJT	
0001877E 0000 0000                  		dc.w SME_CfLJT_148-SME_CfLJT, SME_CfLJT_14E-SME_CfLJT	
00018782 0000 0000                  		dc.w SME_CfLJT_156-SME_CfLJT, SME_CfLJT_162-SME_CfLJT	
00018786 0000 0000                  		dc.w SME_CfLJT_170-SME_CfLJT, SME_CfLJT_17A-SME_CfLJT	
0001878A 0000 0000                  		dc.w SME_CfLJT_186-SME_CfLJT, SME_CfLJT_190-SME_CfLJT	
0001878E 0000 0000                  		dc.w SME_CfLJT_19C-SME_CfLJT, SME_CfLJT_1A6-SME_CfLJT	
00018792 0000 0000                  		dc.w SME_CfLJT_1AC-SME_CfLJT, SME_CfLJT_1B2-SME_CfLJT	
00018796 0000 0000                  		dc.w SME_CfLJT_1BC-SME_CfLJT, SME_CfLJT_1C2-SME_CfLJT	
0001879A 0000 0000                  		dc.w SME_CfLJT_1CA-SME_CfLJT, SME_CfLJT_1D8-SME_CfLJT	
0001879E 0000 0000                  		dc.w SME_CfLJT_1E6-SME_CfLJT, SME_CfLJT_1F0-SME_CfLJT	
000187A2 0000 0000                  		dc.w SME_CfLJT_1FC-SME_CfLJT, SME_CfLJT_206-SME_CfLJT	
000187A6 0000 0000                  		dc.w SME_CfLJT_212-SME_CfLJT, SME_CfLJT_218-SME_CfLJT	
000187AA 0000 0000                  		dc.w SME_CfLJT_21E-SME_CfLJT, SME_CfLJT_224-SME_CfLJT	
000187AE 0000 0000                  		dc.w SME_CfLJT_22A-SME_CfLJT, SME_CfLJT_234-SME_CfLJT	
000187B2 0000 0000                  		dc.w SME_CfLJT_23C-SME_CfLJT, SME_CfLJT_246-SME_CfLJT	
000187B6 0000 0000                  		dc.w SME_CfLJT_24E-SME_CfLJT, SME_CfLJT_254-SME_CfLJT	
000187BA 0000 0000                  		dc.w SME_CfLJT_25A-SME_CfLJT, SME_CfLJT_260-SME_CfLJT	
000187BE 0000 0000                  		dc.w SME_CfLJT_266-SME_CfLJT, SME_CfLJT_270-SME_CfLJT	
000187C2 0000 0000                  		dc.w SME_CfLJT_276-SME_CfLJT, SME_CfLJT_280-SME_CfLJT	
000187C6 0000 0000                  		dc.w SME_CfLJT_286-SME_CfLJT, SME_CfLJT_28A-SME_CfLJT	
000187CA 0000 0000                  		dc.w SME_CfLJT_28E-SME_CfLJT, SME_CfLJT_292-SME_CfLJT	
000187CE 0000 0000                  		dc.w SME_CfLJT_296-SME_CfLJT, SME_CfLJT_29A-SME_CfLJT	
000187D2 0000 0000                  		dc.w SME_CfLJT_29C-SME_CfLJT, SME_CfLJT_29E-SME_CfLJT	
000187D6 0000 0000                  		dc.w SME_CfLJT_2A0-SME_CfLJT, SME_CfLJT_2A2-SME_CfLJT	
000187DA 0000 0000                  		dc.w SME_CfLJT_2A8-SME_CfLJT, SME_CfLJT_2B2-SME_CfLJT	
000187DE 0000 0000                  		dc.w SME_CfLJT_2BC-SME_CfLJT, SME_CfLJT_2C4-SME_CfLJT	
000187E2 0000 0000                  		dc.w SME_CfLJT_2CC-SME_CfLJT, SME_CfLJT_2D4-SME_CfLJT	
000187E6 0000 0000                  		dc.w SME_CfLJT_2D8-SME_CfLJT, SME_CfLJT_2E0-SME_CfLJT	
000187EA 0000 0000                  		dc.w SME_CfLJT_2E8-SME_CfLJT, SME_CfLJT_2F0-SME_CfLJT	
000187EE 0000 0000                  		dc.w SME_CfLJT_2FA-SME_CfLJT, SME_CfLJT_304-SME_CfLJT	
000187F2 0000 0000                  		dc.w SME_CfLJT_306-SME_CfLJT, SME_CfLJT_308-SME_CfLJT	
000187F6 0000 0000                  		dc.w SME_CfLJT_30E-SME_CfLJT, SME_CfLJT_316-SME_CfLJT	
000187FA 0000 0000                  		dc.w SME_CfLJT_31C-SME_CfLJT, SME_CfLJT_324-SME_CfLJT	
000187FE 0000 0000                  		dc.w SME_CfLJT_326-SME_CfLJT, SME_CfLJT_328-SME_CfLJT	
00018802 0000 0000                  		dc.w SME_CfLJT_32A-SME_CfLJT, SME_CfLJT_336-SME_CfLJT	
00018806 0000 0000                  		dc.w SME_CfLJT_342-SME_CfLJT, SME_CfLJT_344-SME_CfLJT	
0001880A 0000 0000                  		dc.w SME_CfLJT_346-SME_CfLJT, SME_CfLJT_348-SME_CfLJT	
0001880E 0000 0000                  		dc.w SME_CfLJT_34A-SME_CfLJT, SME_CfLJT_34C-SME_CfLJT	
00018812 0000 0000                  		dc.w SME_CfLJT_354-SME_CfLJT, SME_CfLJT_35C-SME_CfLJT	
00018816 0000 0000                  		dc.w SME_CfLJT_364-SME_CfLJT, SME_CfLJT_36C-SME_CfLJT	
0001881A 0000 0000                  		dc.w SME_CfLJT_372-SME_CfLJT, SME_CfLJT_378-SME_CfLJT	
0001881E 0000 0000                  		dc.w SME_CfLJT_37E-SME_CfLJT, SME_CfLJT_384-SME_CfLJT	
00018822 0000 0000                  		dc.w SME_CfLJT_38A-SME_CfLJT, SME_CfLJT_38C-SME_CfLJT	
00018826 0000 0000                  		dc.w SME_CfLJT_38E-SME_CfLJT, SME_CfLJT_390-SME_CfLJT	
0001882A 0000 0000                  		dc.w SME_CfLJT_392-SME_CfLJT, SME_CfLJT_394-SME_CfLJT	
0001882E 0000 0000                  		dc.w SME_CfLJT_396-SME_CfLJT, SME_CfLJT_398-SME_CfLJT	
00018832 0000 0000                  		dc.w SME_CfLJT_39A-SME_CfLJT, SME_CfLJT_39C-SME_CfLJT	
00018836 0000 0000                  		dc.w SME_CfLJT_39E-SME_CfLJT, SME_CfLJT_3A0-SME_CfLJT	
0001883A 0000 0000                  		dc.w SME_CfLJT_3A2-SME_CfLJT, SME_CfLJT_3AA-SME_CfLJT	
0001883E 0000 0000                  		dc.w SME_CfLJT_3B2-SME_CfLJT, SME_CfLJT_3B8-SME_CfLJT	
00018842 0000 0000                  		dc.w SME_CfLJT_3BC-SME_CfLJT, SME_CfLJT_3C2-SME_CfLJT	
00018846 0000 0000                  		dc.w SME_CfLJT_3CA-SME_CfLJT, SME_CfLJT_3D2-SME_CfLJT	
0001884A 0000 0000                  		dc.w SME_CfLJT_3DA-SME_CfLJT, SME_CfLJT_3E0-SME_CfLJT	
0001884E 0000 0000                  		dc.w SME_CfLJT_3E6-SME_CfLJT, SME_CfLJT_3EE-SME_CfLJT	
00018852 0000 0000                  		dc.w SME_CfLJT_3F4-SME_CfLJT, SME_CfLJT_3FA-SME_CfLJT	
00018856 0000 0000                  		dc.w SME_CfLJT_400-SME_CfLJT, SME_CfLJT_406-SME_CfLJT	
0001885A 0000 0000                  		dc.w SME_CfLJT_40E-SME_CfLJT, SME_CfLJT_416-SME_CfLJT	
0001885E 0000 0000                  		dc.w SME_CfLJT_41E-SME_CfLJT, SME_CfLJT_428-SME_CfLJT	
00018862 0000 0000                  		dc.w SME_CfLJT_432-SME_CfLJT, SME_CfLJT_43C-SME_CfLJT	
00018866 0000                       SME_CfLJT_FC:	dc.b 0, 0	
00018868 0004 2000 7003 200B 200E   SME_CfLJT_FE:	dc.b 0, 4, $20, 0, $70, 3, $20, $B, $20, $E	
00018872 0003 5011 5017 201D        SME_CfLJT_108:	dc.b 0, 3, $50, $11, $50, $17, $20, $1D	
0001887A 0003 5020 5017 201D        SME_CfLJT_110:	dc.b 0, 3, $50, $20, $50, $17, $20, $1D	
00018882 0003 5020 5017 2026        SME_CfLJT_118:	dc.b 0, 3, $50, $20, $50, $17, $20, $26	
0001888A 0003 8029 200B 200E        SME_CfLJT_120:	dc.b 0, 3, $80, $29, $20, $B, $20, $E	
00018892 0004 7032 503A 5040 1046   SME_CfLJT_128:	dc.b 0, 4, $70, $32, $50, $3A, $50, $40, $10, $46	
0001889C 0002 7032 B048             SME_CfLJT_132:	dc.b 0, 2, $70, $32, $B0, $48	
000188A2 0002 5054 805A             SME_CfLJT_138:	dc.b 0, 2, $50, $54, $80, $5A	
000188A8 0004 5054 5063 5069 106F   SME_CfLJT_13E:	dc.b 0, 4, $50, $54, $50, $63, $50, $69, $10, $6F	
000188B2 0002 5054 B071             SME_CfLJT_148:	dc.b 0, 2, $50, $54, $B0, $71	
000188B8 0003 7032 307D 5081        SME_CfLJT_14E:	dc.b 0, 3, $70, $32, $30, $7D, $50, $81	
000188C0 0005 5087 508D 2093 5096+  SME_CfLJT_156:	dc.b 0, 5, $50, $87, $50, $8D, $20, $93, $50, $96, 0, $9C	
000188CC 0006 5087 109D 309F 50A3+  SME_CfLJT_162:	dc.b 0, 6, $50, $87, $10, $9D, $30, $9F, $50, $A3, $30, $A9, 0, $AD	
000188DA 0004 50AE 10B4 70B6 20BE   SME_CfLJT_170:	dc.b 0, 4, $50, $AE, $10, $B4, $70, $B6, $20, $BE	
000188E4 0005 50C1 30C7 70CB 20D3+  SME_CfLJT_17A:	dc.b 0, 5, $50, $C1, $30, $C7, $70, $CB, $20, $D3, $10, $D6	
000188F0 0004 50C1 10D8 70DA 20E2   SME_CfLJT_186:	dc.b 0, 4, $50, $C1, $10, $D8, $70, $DA, $20, $E2	
000188FA 0005 5087 109D 0093 70E5+  SME_CfLJT_190:	dc.b 0, 5, $50, $87, $10, $9D, 0, $93, $70, $E5, $20, $ED	
00018906 0004 70F0 50F8 10FE 5100   SME_CfLJT_19C:	dc.b 0, 4, $70, $F0, $50, $F8, $10, $FE, $51, 0	
00018910 0002 70F0 B106             SME_CfLJT_1A6:	dc.b 0, 2, $70, $F0, $B1, 6	
00018916 0002 5112 8118             SME_CfLJT_1AC:	dc.b 0, 2, $51, $12, $81, $18	
0001891C 0004 5112 5121 1127 5129   SME_CfLJT_1B2:	dc.b 0, 4, $51, $12, $51, $21, $11, $27, $51, $29	
00018926 0002 5112 B12F             SME_CfLJT_1BC:	dc.b 0, 2, $51, $12, $B1, $2F	
0001892C 0003 70F0 0106 813B        SME_CfLJT_1C2:	dc.b 0, 3, $70, $F0, 1, 6, $81, $3B	
00018934 0006 5144 114A 114C 814E+  SME_CfLJT_1CA:	dc.b 0, 6, $51, $44, $11, $4A, $11, $4C, $81, $4E, 1, $57, 1, $58	
00018942 0006 5144 2159 115C 115E+  SME_CfLJT_1D8:	dc.b 0, 6, $51, $44, $21, $59, $11, $5C, $11, $5E, $81, $60, 1, $57	
00018950 0004 5169 116F 8171 117A   SME_CfLJT_1E6:	dc.b 0, 4, $51, $69, $11, $6F, $81, $71, $11, $7A	
0001895A 0005 517C 2182 1185 7187+  SME_CfLJT_1F0:	dc.b 0, 5, $51, $7C, $21, $82, $11, $85, $71, $87, $21, $8F	
00018966 0004 517C 1192 8194 119D   SME_CfLJT_1FC:	dc.b 0, 4, $51, $7C, $11, $92, $81, $94, $11, $9D	
00018970 0005 5144 819F 115E 11A8+  SME_CfLJT_206:	dc.b 0, 5, $51, $44, $81, $9F, $11, $5E, $11, $A8, 1, $57	
0001897C 0002 51AA B1B0             SME_CfLJT_212:	dc.b 0, 2, $51, $AA, $B1, $B0	
00018982 0002 5054 B1BC             SME_CfLJT_218:	dc.b 0, 2, $50, $54, $B1, $BC	
00018988 0002 51AA B1C8             SME_CfLJT_21E:	dc.b 0, 2, $51, $AA, $B1, $C8	
0001898E 0002 5054 B1D4             SME_CfLJT_224:	dc.b 0, 2, $50, $54, $B1, $D4	
00018994 0004 51E0 11E6 B1E8 01F4   SME_CfLJT_22A:	dc.b 0, 4, $51, $E0, $11, $E6, $B1, $E8, 1, $F4	
0001899E 0003 51F5 11FB B1FD        SME_CfLJT_234:	dc.b 0, 3, $51, $F5, $11, $FB, $B1, $FD	
000189A6 0004 51E0 1209 B20B 01F4   SME_CfLJT_23C:	dc.b 0, 4, $51, $E0, $12, 9, $B2, $B, 1, $F4	
000189B0 0003 51F5 11FB B217        SME_CfLJT_246:	dc.b 0, 3, $51, $F5, $11, $FB, $B2, $17	
000189B8 0002 5223 B229             SME_CfLJT_24E:	dc.b 0, 2, $52, $23, $B2, $29	
000189BE 0002 5112 B235             SME_CfLJT_254:	dc.b 0, 2, $51, $12, $B2, $35	
000189C4 0002 5223 B241             SME_CfLJT_25A:	dc.b 0, 2, $52, $23, $B2, $41	
000189CA 0002 5112 B24D             SME_CfLJT_260:	dc.b 0, 2, $51, $12, $B2, $4D	
000189D0 0004 5259 125F B261 026D   SME_CfLJT_266:	dc.b 0, 4, $52, $59, $12, $5F, $B2, $61, 2, $6D	
000189DA 0002 726E B276             SME_CfLJT_270:	dc.b 0, 2, $72, $6E, $B2, $76	
000189E0 0004 5259 1282 B284 026D   SME_CfLJT_276:	dc.b 0, 4, $52, $59, $12, $82, $B2, $84, 2, $6D	
000189EA 0002 726E B290             SME_CfLJT_280:	dc.b 0, 2, $72, $6E, $B2, $90	
000189F0 0001 F29C                  SME_CfLJT_286:	dc.b 0, 1, $F2, $9C	
000189F4 0001 F2AC                  SME_CfLJT_28A:	dc.b 0, 1, $F2, $AC	
000189F8 0001 F2BC                  SME_CfLJT_28E:	dc.b 0, 1, $F2, $BC	
000189FC 0001 F2CC                  SME_CfLJT_292:	dc.b 0, 1, $F2, $CC	
00018A00 0001 F2DC                  SME_CfLJT_296:	dc.b 0, 1, $F2, $DC	
00018A04 0000                       SME_CfLJT_29A:	dc.b 0, 0	
00018A06 0000                       SME_CfLJT_29C:	dc.b 0, 0	
00018A08 0000                       SME_CfLJT_29E:	dc.b 0, 0	
00018A0A 0000                       SME_CfLJT_2A0:	dc.b 0, 0	
00018A0C 0002 52EC B2F2             SME_CfLJT_2A2:	dc.b 0, 2, $52, $EC, $B2, $F2	
00018A12 0004 52FE 7304 130C 030E   SME_CfLJT_2A8:	dc.b 0, 4, $52, $FE, $73, 4, $13, $C, 3, $E	
00018A1C 0004 130F 7311 2319 031C   SME_CfLJT_2B2:	dc.b 0, 4, $13, $F, $73, $11, $23, $19, 3, $1C	
00018A26 0003 231D 2320 F323        SME_CfLJT_2BC:	dc.b 0, 3, $23, $1D, $23, $20, $F3, $23	
00018A2E 0003 B333 733F 0071        SME_CfLJT_2C4:	dc.b 0, 3, $B3, $33, $73, $3F, 0, $71	
00018A36 0003 7347 334F 2353        SME_CfLJT_2CC:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
00018A3E 0001 8356                  SME_CfLJT_2D4:	dc.b 0, 1, $83, $56	
00018A42 0003 735F 0367 3368        SME_CfLJT_2D8:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
00018A4A 0003 736C 3374 2378        SME_CfLJT_2E0:	dc.b 0, 3, $73, $6C, $33, $74, $23, $78	
00018A52 0003 B37B 1387 0389        SME_CfLJT_2E8:	dc.b 0, 3, $B3, $7B, $13, $87, 3, $89	
00018A5A 0004 B38A 3396 039A 039B   SME_CfLJT_2F0:	dc.b 0, 4, $B3, $8A, $33, $96, 3, $9A, 3, $9B	
00018A64 0004 B39C 33A8 03AC 03AD   SME_CfLJT_2FA:	dc.b 0, 4, $B3, $9C, $33, $A8, 3, $AC, 3, $AD	
00018A6E 0000                       SME_CfLJT_304:	dc.b 0, 0	
00018A70 0000                       SME_CfLJT_306:	dc.b 0, 0	
00018A72 0002 83AE 73B7             SME_CfLJT_308:	dc.b 0, 2, $83, $AE, $73, $B7	
00018A78 0003 83BF 23C8 13CB        SME_CfLJT_30E:	dc.b 0, 3, $83, $BF, $23, $C8, $13, $CB	
00018A80 0002 83CD 73D6             SME_CfLJT_316:	dc.b 0, 2, $83, $CD, $73, $D6	
00018A86 0003 83BF 23DE 13E1        SME_CfLJT_31C:	dc.b 0, 3, $83, $BF, $23, $DE, $13, $E1	
00018A8E 0000                       SME_CfLJT_324:	dc.b 0, 0	
00018A90 0000                       SME_CfLJT_326:	dc.b 0, 0	
00018A92 0000                       SME_CfLJT_328:	dc.b 0, 0	
00018A94 0005 73E3 13EB 53ED 33F3+  SME_CfLJT_32A:	dc.b 0, 5, $73, $E3, $13, $EB, $53, $ED, $33, $F3, 3, $F7	
00018AA0 0005 73F8 13EB 5400 33F3+  SME_CfLJT_336:	dc.b 0, 5, $73, $F8, $13, $EB, $54, 0, $33, $F3, 3, $F7	
00018AAC 0000                       SME_CfLJT_342:	dc.b 0, 0	
00018AAE 0000                       SME_CfLJT_344:	dc.b 0, 0	
00018AB0 0000                       SME_CfLJT_346:	dc.b 0, 0	
00018AB2 0000                       SME_CfLJT_348:	dc.b 0, 0	
00018AB4 0000                       SME_CfLJT_34A:	dc.b 0, 0	
00018AB6 0003 7347 334F 2353        SME_CfLJT_34C:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
00018ABE 0003 735F 0367 3368        SME_CfLJT_354:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
00018AC6 0003 B406 1412 3414        SME_CfLJT_35C:	dc.b 0, 3, $B4, 6, $14, $12, $34, $14	
00018ACE 0003 5418 B41E 106D        SME_CfLJT_364:	dc.b 0, 3, $54, $18, $B4, $1E, $10, $6D	
00018AD6 0002 F42A 243A             SME_CfLJT_36C:	dc.b 0, 2, $F4, $2A, $24, $3A	
00018ADC 0002 F43D 244D             SME_CfLJT_372:	dc.b 0, 2, $F4, $3D, $24, $4D	
00018AE2 0002 F450 2460             SME_CfLJT_378:	dc.b 0, 2, $F4, $50, $24, $60	
00018AE8 0002 F463 2473             SME_CfLJT_37E:	dc.b 0, 2, $F4, $63, $24, $73	
00018AEE 0002 F476 1486             SME_CfLJT_384:	dc.b 0, 2, $F4, $76, $14, $86	
00018AF4 0000                       SME_CfLJT_38A:	dc.b 0, 0	
00018AF6 0000                       SME_CfLJT_38C:	dc.b 0, 0	
00018AF8 0000                       SME_CfLJT_38E:	dc.b 0, 0	
00018AFA 0000                       SME_CfLJT_390:	dc.b 0, 0	
00018AFC 0000                       SME_CfLJT_392:	dc.b 0, 0	
00018AFE 0000                       SME_CfLJT_394:	dc.b 0, 0	
00018B00 0000                       SME_CfLJT_396:	dc.b 0, 0	
00018B02 0000                       SME_CfLJT_398:	dc.b 0, 0	
00018B04 0000                       SME_CfLJT_39A:	dc.b 0, 0	
00018B06 0000                       SME_CfLJT_39C:	dc.b 0, 0	
00018B08 0000                       SME_CfLJT_39E:	dc.b 0, 0	
00018B0A 0000                       SME_CfLJT_3A0:	dc.b 0, 0	
00018B0C 0003 5488 B48E 149A        SME_CfLJT_3A2:	dc.b 0, 3, $54, $88, $B4, $8E, $14, $9A	
00018B14 0003 B49C 14A8 34AA        SME_CfLJT_3AA:	dc.b 0, 3, $B4, $9C, $14, $A8, $34, $AA	
00018B1C 0002 B4AE 14BA             SME_CfLJT_3B2:	dc.b 0, 2, $B4, $AE, $14, $BA	
00018B22 0001 F4BC                  SME_CfLJT_3B8:	dc.b 0, 1, $F4, $BC	
00018B26 0002 B4CC 14D8             SME_CfLJT_3BC:	dc.b 0, 2, $B4, $CC, $14, $D8	
00018B2C 0003 B4DA 14E6 14E8        SME_CfLJT_3C2:	dc.b 0, 3, $B4, $DA, $14, $E6, $14, $E8	
00018B34 0003 54EA B4F0 34FC        SME_CfLJT_3CA:	dc.b 0, 3, $54, $EA, $B4, $F0, $34, $FC	
00018B3C 0003 B500 150C 350E        SME_CfLJT_3D2:	dc.b 0, 3, $B5, 0, $15, $C, $35, $E	
00018B44 0002 B512 151E             SME_CfLJT_3DA:	dc.b 0, 2, $B5, $12, $15, $1E	
00018B4A 0002 B520 152C             SME_CfLJT_3E0:	dc.b 0, 2, $B5, $20, $15, $2C	
00018B50 0003 B52E 153A 353C        SME_CfLJT_3E6:	dc.b 0, 3, $B5, $2E, $15, $3A, $35, $3C	
00018B58 0002 F540 3550             SME_CfLJT_3EE:	dc.b 0, 2, $F5, $40, $35, $50	
00018B5E 0002 B554 5560             SME_CfLJT_3F4:	dc.b 0, 2, $B5, $54, $55, $60	
00018B64 0002 B566 2572             SME_CfLJT_3FA:	dc.b 0, 2, $B5, $66, $25, $72	
00018B6A 0002 B575 2581             SME_CfLJT_400:	dc.b 0, 2, $B5, $75, $25, $81	
00018B70 0003 B584 2590 5593        SME_CfLJT_406:	dc.b 0, 3, $B5, $84, $25, $90, $55, $93	
00018B78 0003 B599 55A5 35AB        SME_CfLJT_40E:	dc.b 0, 3, $B5, $99, $55, $A5, $35, $AB	
00018B80 0003 B5AF 55BB 15C1        SME_CfLJT_416:	dc.b 0, 3, $B5, $AF, $55, $BB, $15, $C1	
00018B88 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_41E:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B92 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_428:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018B9C 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_432:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018BA6 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_43C:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00018BB0                            		even
00018BB0                            		even
00018BB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018BB0                            Ani_ObjMighty:
00018BB0                            		include	"Level/Objects/Mighty/Animations.asm"
00018BB0                            ; ---------------------------------------------------------------------------
00018BB0                            ; Animation script - Sonic
00018BB0                            ; ---------------------------------------------------------------------------
00018BB0                            SonicAniData:
00018BB0 0000                       		dc.w SonicAni_Walk-SonicAniData
00018BB2 0000                       		dc.w SonicAni_Run-SonicAniData
00018BB4 0000                       		dc.w SonicAni_Roll-SonicAniData
00018BB6 0000                       		dc.w SonicAni_Roll2-SonicAniData
00018BB8 0000                       		dc.w SonicAni_Push-SonicAniData
00018BBA 0000                       		dc.w SonicAni_Wait-SonicAniData
00018BBC 0000                       		dc.w SonicAni_Balance-SonicAniData
00018BBE 0000                       		dc.w SonicAni_LookUp-SonicAniData
00018BC0 0000                       		dc.w SonicAni_Duck-SonicAniData
00018BC2 0000                       		dc.w SonicAni_Sprint-SonicAniData
00018BC4 0000                       		dc.w SonicAni_Hang-SonicAniData
00018BC6 0000                       		dc.w SonicAni_Seizure-SonicAniData
00018BC8 0000                       		dc.w SonicAni_Blank-SonicAniData
00018BCA 0000                       		dc.w SonicAni_Skid-SonicAniData
00018BCC 0000                       		dc.w SonicAni_Float1-SonicAniData
00018BCE 0000                       		dc.w SonicAni_Float2-SonicAniData
00018BD0 0000                       		dc.w SonicAni_Spring-SonicAniData
00018BD2 0000                       		dc.w SonicAni_Blank-SonicAniData
00018BD4 0000                       		dc.w SonicAni_Blank-SonicAniData
00018BD6 0000                       		dc.w SonicAni_Blank-SonicAniData
00018BD8 0000                       		dc.w SonicAni_Blank-SonicAniData
00018BDA 0000                       		dc.w SonicAni_Bubble-SonicAniData
00018BDC 0000                       		dc.w SonicAni_Blank-SonicAniData
00018BDE 0000                       		dc.w SonicAni_Drown-SonicAniData
00018BE0 0000                       		dc.w SonicAni_Death-SonicAniData
00018BE2 0000                       		dc.w SonicAni_Blank-SonicAniData
00018BE4 0000                       		dc.w SonicAni_Hurt-SonicAniData
00018BE6 0000                       		dc.w SonicAni_Slide-SonicAniData
00018BE8 0000                       		dc.w SonicAni_Blank-SonicAniData
00018BEA 0000                       		dc.w SonicAni_Float3-SonicAniData
00018BEC 0000                       		dc.w SonicAni_Float4-SonicAniData
00018BEE 0100 FD00                  SonicAni_Blank:		dc.b 1, 0, $FD, 0
00018BF2 FF08 090A 0B06 07FF        SonicAni_Walk:		dc.b $FF, $08, $09, $0A, $0B, $06, $07, $FF
00018BFA FF1E 1F20 21FF FFFF        SonicAni_Run:		dc.b $FF, $1E, $1F, $20, $21, $FF, $FF,	$FF
00018C02 FF58 595A 5BFF FFFF        SonicAni_Sprint:	dc.b $FF, $58, $59, $5A, $5B, $FF, $FF, $FF
00018C0A FE2E 2F30 3132 FFFF        SonicAni_Roll:		dc.b $FE, $2E, $2F, $30, $31, $32, $FF,	$FF
00018C12 FE2E 2F32 3031 32FF        SonicAni_Roll2:		dc.b $FE, $2E, $2F, $32, $30, $31, $32,	$FF
00018C1A FD45 4647 48FF FFFF        SonicAni_Push:		dc.b $FD, $45, $46, $47, $48, $FF, $FF,	$FF
00018C22 1701 0101 0101 0101 0101+  SonicAni_Wait:		dc.b $17, 1, 1,	1, 1, 1, 1, 1, 1, 1, 1,	1, 1, 3, 2, 2, 2, 3, 4, $FE, 2, 0
00018C38 1F3A 3BFF                  SonicAni_Balance:	dc.b $1F, $3A, $3B, $FF
00018C3C 3F05 FF00                  SonicAni_LookUp:	dc.b $3F, 5, $FF, 0
00018C40 3F39 FF00                  SonicAni_Duck:		dc.b $3F, $39, $FF, 0
00018C44 0737 38FF                  SonicAni_Skid:		dc.b 7,	$37, $38, $FF
00018C48 073C 3FFF                  SonicAni_Float1:	dc.b 7,	$3C, $3F, $FF
00018C4C 073C 3D53 3E54 FF00        SonicAni_Float2:	dc.b 7,	$3C, $3D, $53, $3E, $54, $FF, 0
00018C54 2F40 FD00                  SonicAni_Spring:	dc.b $2F, $40, $FD, 0
00018C58 FC78 7978 77FF             SonicAni_Hang:		dc.b $FC, $78, $79, $78, $77, $FF
00018C5E 0B56 560A 0BFD 0000        SonicAni_Bubble:	dc.b $B, $56, $56, $A, $B, $FD,	0, 0
00018C66 2F4C FF00                  SonicAni_Drown:		dc.b $2F, $4C, $FF, 0
00018C6A 034D FF00                  SonicAni_Death:		dc.b 3,	$4D, $FF, 0
00018C6E 0355 FF00                  SonicAni_Hurt:		dc.b 3,	$55, $FF, 0
00018C72 0755 57FF                  SonicAni_Slide:		dc.b 7, $55, $57, $FF
00018C76 033C 3D53 3E54 FF00        SonicAni_Float3:	dc.b 3,	$3C, $3D, $53, $3E, $54, $FF, 0
00018C7E 033C FD00                  SonicAni_Float4:	dc.b 3,	$3C, $FD, 0
00018C82 027A 7B7C 7DFF             SonicAni_Seizure:	dc.b 2, $7A, $7B, $7C, $7D, $FF
00018C88                            		even
00018C88                            		even
00018C88                            ; =========================================================================================================================================================
00018C88                            		include	"Level/Objects/Ring/Code.asm"		; Ring loss object
00018C88                            ; =========================================================================================================================================================
00018C88                            ; Mighty The Armadillo in PRISM PARADISE
00018C88                            ; By Nat The Porcupine 2021
00018C88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018C88                            ; Water surface object
00018C88                            ; =========================================================================================================================================================
00018C88                            		rsset	oLvlSSTs
00018C88                            
00018C88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018C88                            ObjRingLoss:
00018C88 2248                       		movea.l	a0,a1
00018C8A 7A00                       		moveq	#0,d5
00018C8C 3A38 F3D4                  		move.w	rRings.w,d5
00018C90 7020                       		moveq	#32,d0
00018C92 BA40                       		cmp.w	d0,d5
00018C94 6500                       		bcs.s	.BelowMax
00018C96 3A00                       		move.w	d0,d5
00018C98                            
00018C98                            .BelowMax:
00018C98 5345                       		subq.w	#1,d5
00018C9A 47F9 0000 0000             		lea	ObjLostRing_Speeds,a3
00018CA0 6000                       		bra.s	.MakeRings
00018CA2                            
00018CA2                            .Loop:
00018CA2 4EB8 19B0                  		jsr	FindFreeObj.w
00018CA6 6700                       		beq.s	.ResetCounter
00018CA8                            
00018CA8                            .MakeRings:
00018CA8 22BC 0000 0000             		move.l	#ObjLostRing,oAddr(a1)
00018CAE 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
00018CB4 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
00018CBA 237C 0000 0000 0010        		move.l	#Map_ObjLostRing,oMap(a1)	; Mappings
00018CC2 337C 26B4 000E             		move.w	#$26B4,oVRAM(a1)		; Tile properties
00018CC8 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
00018CCE                            	displaySprite	3,a1,a2,0			; Priority
00018CCE 337C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a1)
00018CD4 3478 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a2
00018CD8 334A 000A                M 	move.w	a2,odrawprev(a1)
00018CDC 3549 0008                M 	move.w	a1,odrawnext(a2)
00018CE0 31C9 BE7C                M 	move.w	a1,rdispinput+dprev+(3*dsize).w
00018CE4 0C78 BE72 BE7C           M 	cmp.w	#rdispinput+(3*dsize),rdispinput+dprev+(3*dsize).w
00018CEA 6600                     M 	bne.s	.no_223
00018CEC 31C9 BE7C                M 	move.w	a1,rdispinput+dprev+(3*dsize).w
00018CF0                          M .no_223
00018CF0 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
00018CF6 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
00018CFC 137C 0008 002C             		move.b	#8,oColW(a1)			; Collision width
00018D02 137C 0008 002D             		move.b	#8,oColH(a1)			; Collision height
00018D08 335B 001C                  		move.w	(a3)+,oXVel(a1)
00018D0C 335B 001E                  		move.w	(a3)+,oYVel(a1)
00018D10 51CD FF90                  		dbf	d5,.Loop
00018D14 11FC 00FF F3D9             		move.b	#-1,rRLossAniT.w
00018D1A                            
00018D1A                            .ResetCounter:
00018D1A 4278 F3D4                  		clr.w	rRings.w
00018D1E 11FC 0001 F8F3             		move.b	#1,rUpdateRings.w
00018D24                            		playSnd	#sRingLoss, 2
00018D24 11FC 008D C4BD           M 	move.b	#sringloss,(mqueue+((2)-1)).w
00018D2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D2A                            ObjLostRing:
00018D2A 4EB8 1CF0                  		jsr	ObjectMove.w
00018D2E 0668 0018 001E             		addi.w	#$18,oYVel(a0)
00018D34 6B00                       		bmi.s	.ChkCol
00018D36 1038 C759                  		move.b	(rFrameCnt+3).w,d0
00018D3A D048                       		add.w	a0,d0
00018D3C 0200 0006                  		andi.b	#6,d0
00018D40 6600                       		bne.s	.ChkCol
00018D42 4EB8 2FD2                  		jsr	ObjCheckFloorDist
00018D46 4A41                       		tst.w	d1
00018D48 6A00                       		bpl.s	.ChkCol
00018D4A D368 0018                  		add.w	d1,oYPos(a0)
00018D4E 3028 001E                  		move.w	oYVel(a0),d0
00018D52 E440                       		asr.w	#2,d0
00018D54 9168 001E                  		sub.w	d0,oYVel(a0)
00018D58 4468 001E                  		neg.w	oYVel(a0)
00018D5C                            
00018D5C                            .ChkCol:
00018D5C 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00018D60 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
00018D64 4EB8 1D2A                  		jsr	CheckObjInRange.w		; Is the player in range?
00018D68 4A40                       		tst.w	d0				; ''
00018D6A 6700                       		beq.s	.ChkDel				; If not, branch
00018D6C 0C2A 0069 0042             		cmpi.b	#105,oInvulTime(a2)
00018D72 6400                       		bhs.s	.ChkDel
00018D74 6000                       		bra.s	ObjLostRing_Collect
00018D76                            
00018D76                            .ChkDel:
00018D76 4A38 F3D9                  		tst.b	rRLossAniT.w
00018D7A 6700 0000                  		beq.w	ObjLostRing_Delete
00018D7E 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
00018D82 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
00018D86 B068 0018                  		cmp.w	oYPos(a0),d0			; Have we touched the bottom boundary?
00018D8A 6D00                       		blt.s	ObjLostRing_Delete		; If so, branch
00018D8C                            	nextObject
00018D8C 3068 0004                M 	movea.w	onext(a0),a0
00018D90 2250                     M 	move.l	oaddr(a0),a1
00018D92 4ED1                     M 	jmp	(a1)
00018D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D94                            .RangeData:
00018D94 FFF0 0020                  		dc.w	-$10, $20
00018D98 FFF0 0020                  		dc.w	-$10, $20
00018D9C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018D9C                            ObjLostRing_Collect:
00018D9C                            	removeSprite	a0,a1,0
00018D9C 3268 000A                M 	move.w	odrawprev(a0),a1
00018DA0 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00018DA6 3268 0008                M 	move.w	odrawnext(a0),a1
00018DAA 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00018DB0 B2E8 000A                M 	cmp.w	odrawprev(a0),a1
00018DB4 6600                     M 	bne.s	.no_226
00018DB6 3349 0008                M 	move.w	a1,odrawnext(a1)
00018DBA                          M .no_226
00018DBA 42A8 0008                M 	clr.l	odrawnext(a0)
00018DBE                          M .yes_226
00018DBE                            	displaySprite	1,a0,a1,0
00018DBE 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00018DC4 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00018DC8 3149 000A                M 	move.w	a1,odrawprev(a0)
00018DCC 3348 0008                M 	move.w	a0,odrawnext(a1)
00018DD0 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018DD4 0C78 BE62 BE6C           M 	cmp.w	#rdispinput+(1*dsize),rdispinput+dprev+(1*dsize).w
00018DDA 6600                     M 	bne.s	.no_227
00018DDC 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018DE0                          M .no_227
00018DE0 4EB8 3EDC                  		jsr	CollectRing
00018DE4 20BC 0000 0000             		move.l	#ObjLostRing_Sparkle,(a0)
00018DEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018DEA                            ObjLostRing_Sparkle:
00018DEA 43F9 0000 0000             		lea	Ani_ObjRing,a1
00018DF0 4EB8 1C0A                  		jsr	AnimateObject.w
00018DF4 4A28 0025                  		tst.b	oRoutine(a0)
00018DF8 6600                       		bne.s	ObjLostRing_Delete
00018DFA                            	nextObject
00018DFA 3068 0004                M 	movea.w	onext(a0),a0
00018DFE 2250                     M 	move.l	oaddr(a0),a1
00018E00 4ED1                     M 	jmp	(a1)
00018E02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E02                            ObjLostRing_Delete:
00018E02 4EB8 19E0                  		jsr	DeleteObject.w
00018E06                            	nextObject
00018E06 3068 0004                M 	movea.w	onext(a0),a0
00018E0A 2250                     M 	move.l	oaddr(a0),a1
00018E0C 4ED1                     M 	jmp	(a1)
00018E0E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E0E                            ; Ring Spawn Array
00018E0E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E0E                            ObjLostRing_Speeds:
00018E0E FF3C FC14 00C4 FC14 FDC8+  		dc.w	$FF3C,$FC14,$00C4,$FC14,$FDC8,$FCB0,$0238,$FCB0
00018E1E FCB0 FDC8 0350 FDC8 FC14+  		dc.w	$FCB0,$FDC8,$0350,$FDC8,$FC14,$FF3C,$03EC,$FF3C
00018E2E FC14 00C4 03EC 00C4 FCB0+  		dc.w	$FC14,$00C4,$03EC,$00C4,$FCB0,$0238,$0350,$0238
00018E3E FDC8 0350 0238 0350 FF3C+  		dc.w	$FDC8,$0350,$0238,$0350,$FF3C,$03EC,$00C4,$03EC
00018E4E FF9E FE0A 0062 FE0A FEE4+  		dc.w	$FF9E,$FE0A,$0062,$FE0A,$FEE4,$FE58,$011C,$FE58
00018E5E FE58 FEE4 01A8 FEE4 FE0A+  		dc.w	$FE58,$FEE4,$01A8,$FEE4,$FE0A,$FF9E,$01F6,$FF9E
00018E6E FE0A 0062 01F6 0062 FE58+  		dc.w	$FE0A,$0062,$01F6,$0062,$FE58,$011C,$01A8,$011C
00018E7E FEE4 01A8 011C 01A8 FF9E+  		dc.w	$FEE4,$01A8,$011C,$01A8,$FF9E,$01F6,$0062,$01F6
00018E8E                            		even
00018E8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E8E                            ; Data
00018E8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018E8E                            Map_ObjLostRing:
00018E8E                            		include	"Level/Objects/Ring/Mappings.asm"
00018E8E                            ; --------------------------------------------------------------------------------
00018E8E                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00018E8E                            ; --------------------------------------------------------------------------------
00018E8E                            
00018E8E                            SME_k4ulR:	
00018E8E 0000 0000                  		dc.w SME_k4ulrA-SME_k4ulR, SME_k4ulrC-SME_k4ulR	
00018E92 0000 0000                  		dc.w SME_k4ulr14-SME_k4ulR, SME_k4ulr1C-SME_k4ulR	
00018E96 0000                       		dc.w SME_k4ulr24-SME_k4ulR	
00018E98 0001                       SME_k4ulrA:	dc.b 0, 1	
00018E9A F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8
00018EA0 0001                       SME_k4ulrC:	dc.b 0, 1	
00018EA2 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00018EA8 0001                       SME_k4ulr14:	dc.b 0, 1	
00018EAA F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00018EB0 0001                       SME_k4ulr1C:	dc.b 0, 1	
00018EB2 F805 0804 FFF8             		dc.b $F8, 5, 8, 4, $FF, $F8	
00018EB8 0001                       SME_k4ulr24:	dc.b 0, 1	
00018EBA F805 1004 FFF8             		dc.b $F8, 5, $10, 4, $FF, $F8	
00018EC0                            		even
00018EC0                            		even
00018EC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EC0                            Ani_ObjRing:
00018EC0 0000                       		dc.w	.Ani0-Ani_ObjRing
00018EC2 0501 0203 04FC             .Ani0:		dc.b	5, 1, 2, 3, 4, $FC
00018EC8                            		even
00018EC8                            ; =========================================================================================================================================================
00018EC8                            		include	"Level/Objects/Explosion/Code.asm"	; Explosion object
00018EC8                            ; =========================================================================================================================================================
00018EC8                            ; Mighty The Armadillo in PRISM PARADISE
00018EC8                            ; By Nat The Porcupine 2021
00018EC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EC8                            ; Explosion object
00018EC8                            ; =========================================================================================================================================================
00018EC8 =00000003                  EXPLODE_ANI	EQU	3
00018EC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018EC8                            ObjBossExplode:
00018EC8                            		playSnd	#sBomb, 2			; Play explosion sound
00018EC8 11FC 0099 C4BD           M 	move.b	#sbomb,(mqueue+((2)-1)).w
00018ECE 6000                       		bra.s	ObjExplosion_Init		; Continue
00018ED0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018ED0                            ObjExplosion:
00018ED0                            		playSnd	#sBreakItem, 2			; Play explosion sound
00018ED0 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
00018ED6                            
00018ED6                            ObjExplosion_Init:
00018ED6 20BC 0000 0000             		move.l	#ObjExplosion_Main,oAddr(a0)	; Next routine
00018EDC 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00018EE2 317C 86C0 000E             		move.w	#$86C0,oVRAM(a0)		; Tile properties
00018EE8 217C 0000 0000 0010        		move.l	#Map_ObjExplosion,oMap(a0)	; Mappings
00018EF0                            	displaySprite	1,a0,a1,0			; Priority
00018EF0 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00018EF6 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00018EFA 3149 000A                M 	move.w	a1,odrawprev(a0)
00018EFE 3348 0008                M 	move.w	a0,odrawnext(a1)
00018F02 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018F06 0C78 BE62 BE6C           M 	cmp.w	#rdispinput+(1*dsize),rdispinput+dprev+(1*dsize).w
00018F0C 6600                     M 	bne.s	.no_232
00018F0E 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00018F12                          M .no_232
00018F12 117C 000C 0017             		move.b	#$C,oDrawW(a0)			; Sprite width
00018F18 117C 000C 001B             		move.b	#$C,oDrawH(a0)			; Sprite height
00018F1E 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Animation timer
00018F24 4228 0010                  		clr.b	oFrame(a0)			; Mapping frame
00018F28                            		
00018F28                            ObjExplosion_Main:
00018F28 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00018F2C 6A00                       		bpl.s	.Display			; If it hasn't run out, branch
00018F2E 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Reset animation timer
00018F34 5228 0010                  		addq.b	#1,oFrame(a0)			; Next frame
00018F38 0C28 0005 0010             		cmpi.b	#5,oFrame(a0)			; Has it reached the last frame?
00018F3E 6600                       		bne.s	.Display			; If not, branch
00018F40 4EB8 19E0                  		jsr	DeleteObject.w
00018F44                            		
00018F44                            .Display:
00018F44                            	nextObject
00018F44 3068 0004                M 	movea.w	onext(a0),a0
00018F48 2250                     M 	move.l	oaddr(a0),a1
00018F4A 4ED1                     M 	jmp	(a1)
00018F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018F4C                            ; Data
00018F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00018F4C                            ArtKosM_Explosion:
00018F4C                            		incbin	"Level/Objects/Explosion/Art.kosm.bin"
000193DE                            		even
000193DE                            Map_ObjExplosion:
000193DE                            		include	"Level/Objects/Explosion/Mappings.asm"
000193DE                            ; --------------------------------------------------------------------------------
000193DE                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
000193DE                            ; --------------------------------------------------------------------------------
000193DE                            
000193DE                            SME_PS_OI:	
000193DE 0000 0000                  		dc.w SME_PS_OI_A-SME_PS_OI, SME_PS_OI_12-SME_PS_OI	
000193E2 0000 0000                  		dc.w SME_PS_OI_1A-SME_PS_OI, SME_PS_OI_22-SME_PS_OI	
000193E6 0000                       		dc.w SME_PS_OI_3C-SME_PS_OI	
000193E8 0001                       SME_PS_OI_A:	dc.b 0, 1	
000193EA F809 0000 FFF4             		dc.b $F8, 9, 0, 0, $FF, $F4	
000193F0 0001                       SME_PS_OI_12:	dc.b 0, 1	
000193F2 F00F 0020 FFF0             		dc.b $F0, $F, 0, $20, $FF, $F0	
000193F8 0001                       SME_PS_OI_1A:	dc.b 0, 1	
000193FA F00F 0030 FFF0             		dc.b $F0, $F, 0, $30, $FF, $F0	
00019400 0004                       SME_PS_OI_22:	dc.b 0, 4	
00019402 EC0A 0006 FFEC             		dc.b $EC, $A, 0, 6, $FF, $EC	
00019408 EC05 000F 0004             		dc.b $EC, 5, 0, $F, 0, 4	
0001940E 0405 180F FFEC             		dc.b 4, 5, $18, $F, $FF, $EC	
00019414 FC0A 1806 FFFC             		dc.b $FC, $A, $18, 6, $FF, $FC	
0001941A 0004                       SME_PS_OI_3C:	dc.b 0, 4	
0001941C EC0A 0013 FFEC             		dc.b $EC, $A, 0, $13, $FF, $EC	
00019422 EC05 001C 0004             		dc.b $EC, 5, 0, $1C, 0, 4	
00019428 0405 181C FFEC             		dc.b 4, 5, $18, $1C, $FF, $EC	
0001942E FC0A 1813 FFFC             		dc.b $FC, $A, $18, $13, $FF, $FC	
00019434                            		even
00019434                            		even
00019434                            ; =========================================================================================================================================================
00019434                            		include	"Level/Objects/Water Surface/Code.asm"	; Water surface object
00019434                            ; =========================================================================================================================================================
00019434                            ; Mighty The Armadillo in PRISM PARADISE
00019434                            ; By Nat The Porcupine 2021
00019434                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019434                            ; Water surface object
00019434                            ; =========================================================================================================================================================
00019434                            		rsset	oLvlSSTs
00019434 =00000030                  oSurfPause	rs.b	1			; Animation stop flag
00019434                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019434                            ObjWaterSurface:
00019434 20BC 0000 0000             		move.l	#ObjWaterSurface_Main,oAddr(a0)	; Next routine
0001943A 217C 0000 0000 0010        		move.l	#Map_ObjWaterSurface,oMap(a0)	; Mappings
00019442 317C 8690 000E             		move.w	#$8690,oVRAM(a0)		; Tile properties
00019448 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0001944E                            	displaySprite	0,a0,a1,0			; Priority
0001944E 317C BE5A 0008           M 	move.w	#rdispinput+(0*dsize),odrawnext(a0)
00019454 3278 BE64                M 	move.w	rdispinput+dprev+(0*dsize).w,a1
00019458 3149 000A                M 	move.w	a1,odrawprev(a0)
0001945C 3348 0008                M 	move.w	a0,odrawnext(a1)
00019460 31C8 BE64                M 	move.w	a0,rdispinput+dprev+(0*dsize).w
00019464 0C78 BE5A BE64           M 	cmp.w	#rdispinput+(0*dsize),rdispinput+dprev+(0*dsize).w
0001946A 6600                     M 	bne.s	.no_234
0001946C 31C8 BE64                M 	move.w	a0,rdispinput+dprev+(0*dsize).w
00019470                          M .no_234
00019470 117C 0080 0017             		move.b	#$80,oDrawW(a0)			; Sprite width
00019476 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
0001947C                            
0001947C                            ObjWaterSurface_Main:
0001947C 3238 F8F6                  		move.w	rWaterLvl.w,d1		; Get water height
00019480 5D41                       		subq.w	#6,d1				; Shift it
00019482 3141 0018                  		move.w	d1,oYPos(a0)			; Set Y position
00019486                            
00019486 4A28 0030                  		tst.b	oSurfPause(a0)			; Is the animation paused?
0001948A 6600                       		bne.s	.ChkUnpause			; If so, branch
0001948C 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
00019492 6700                       		beq.s	.Animate			; If not, branch
00019494 5628 0010                  		addq.b	#3,oFrame(a0)			; Use different frames
00019498 50E8 0030                  		st	oSurfPause(a0)			; Pause the animation
0001949C 6000                       		bra.s	.Animate			; Continue
0001949E                            
0001949E                            .ChkUnpause:
0001949E 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game paused?
000194A2 6600                       		bne.s	.Animate			; If so, branch
000194A4 4228 0030                  		clr.b	oSurfPause(a0)			; Resume animation
000194A8 5728 0010                  		subq.b	#3,oFrame(a0)			; Use normal frames
000194AC                            
000194AC                            .Animate:
000194AC 43FA 0000                  		lea	.AniScript(pc),a1		; Get animation script
000194B0 7200                       		moveq	#0,d1
000194B2 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation script frame
000194B6 1171 1000 0010             		move.b	(a1,d1.w),oFrame(a0)		; Set mapping frame
000194BC 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next frame in animation script
000194C0 0228 003F 0022             		andi.b	#$3F,oAniFrame(a0)		; Loop in necessary
000194C6                            	nextObject
000194C6 3068 0004                M 	movea.w	onext(a0),a0
000194CA 2250                     M 	move.l	oaddr(a0),a1
000194CC 4ED1                     M 	jmp	(a1)
000194CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000194CE                            .AniScript:
000194CE 0001 0001 0001 0001 0001+  		dc.b	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
000194DE 0102 0102 0102 0102 0102+  		dc.b	1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2
000194EE 0201 0201 0201 0201 0201+  		dc.b	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1
000194FE 0100 0100 0100 0100 0100+  		dc.b	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
0001950E 00                         		even
0001950E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001950E                            ; Data
0001950E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001950E                            Map_ObjWaterSurface:
0001950E                            		include	"Level/Objects/Water Surface/Mappings.asm"
0001950E                            MapConv_obj1B:
0001950E 0000                       	dc.w	byte_11178-MapConv_obj1B
00019510 0000                       	dc.w	byte_11188-MapConv_obj1B
00019512 0000                       	dc.w	byte_11198-MapConv_obj1B
00019514 0000                       	dc.w	byte_111A8-MapConv_obj1B
00019516 0000                       	dc.w	byte_111C7-MapConv_obj1B
00019518 0000                       	dc.w	byte_111E6-MapConv_obj1B
0001951A                            
0001951A 0003                       byte_11178:	dc.w 3
0001951C FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
00019522 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00019528 FD0D 0000 0020             	dc.w $FD0D, 0, $20
0001952E                            
0001952E 0003                       byte_11188:	dc.w 3
00019530 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
00019536 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
0001953C FD0D 0008 0020             	dc.w $FD0D, 8, $20
00019542                            
00019542 0003                       byte_11198:	dc.w 3
00019544 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
0001954A FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
00019550 FD0D 0800 0020             	dc.w $FD0D, $800, $20
00019556                            
00019556 0006                       byte_111A8:	dc.w 6
00019558 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
0001955E FD0D 0000 FFC0             	dc.w $FD0D, 0, $FFC0
00019564 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
0001956A FD0D 0000 0000             	dc.w $FD0D, 0, 0
00019570 FD0D 0000 0020             	dc.w $FD0D, 0, $20
00019576 FD0D 0000 0040             	dc.w $FD0D, 0, $40
0001957C                            
0001957C 0006                       byte_111C7:	dc.w 6
0001957E FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
00019584 FD0D 0008 FFC0             	dc.w $FD0D, 8, $FFC0
0001958A FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
00019590 FD0D 0008 0000             	dc.w $FD0D, 8, 0
00019596 FD0D 0008 0020             	dc.w $FD0D, 8, $20
0001959C FD0D 0008 0040             	dc.w $FD0D, 8, $40
000195A2                            
000195A2 0006                       byte_111E6:	dc.w 6
000195A4 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
000195AA FD0D 0800 FFC0             	dc.w $FD0D, $800, $FFC0
000195B0 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
000195B6 FD0D 0800 0000             	dc.w $FD0D, $800, 0
000195BC FD0D 0800 0020             	dc.w $FD0D, $800, $20
000195C2 FD0D 0800 0040             	dc.w $FD0D, $800, $40
000195C8                            
000195C8                            	even
000195C8                            		even
000195C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000195C8                            ArtKosM_WaterSurface:
000195C8                            		incbin	"Level/Objects/Water Surface/Art.kosm.bin"
00019722                            		even
00019722                            ; =========================================================================================================================================================
00019722                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019722                            		include	"Level/Objects/Monitor/Code.asm"	; Monitor object
00019722                            ; =========================================================================================================================================================
00019722                            ; Mighty The Armadillo in PRISM PARADISE
00019722                            ; By Nat The Porcupine 2021
00019722                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019722                            ; Monitor object
00019722                            ; =========================================================================================================================================================
00019722                            		rsset	oLvlSSTs
00019722 =00000030                  oMonFall	rs.b	1				; Fall flag
00019722                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019722                            ObjMonitor:
00019722 20BC 0000 0000             		move.l	#ObjMonitorMain,oAddr(a0)
00019728 117C 000E 002D             		move.b	#$E,oColH(a0)
0001972E 117C 000E 002C             		move.b	#$E,oColW(a0)
00019734 217C 0000 0000 0010        		move.l	#Map_ObjMonitor,oMap(a0)
0001973C 317C 0588 000E             		move.w	#$588,oVRAM(a0)
00019742 117C 0004 000D             		move.b	#4,oRender(a0)
00019748                            	displaySprite	3,a0,a1,0			; Priority
00019748 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
0001974E 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
00019752 3149 000A                M 	move.w	a1,odrawprev(a0)
00019756 3348 0008                M 	move.w	a0,odrawnext(a1)
0001975A 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
0001975E 0C78 BE72 BE7C           M 	cmp.w	#rdispinput+(3*dsize),rdispinput+dprev+(3*dsize).w
00019764 6600                     M 	bne.s	.no_236
00019766 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
0001976A                          M .no_236
0001976A 117C 000F 0017             		move.b	#$F,oDrawW(a0)
00019770 117C 000F 001B             		move.b	#$F,oDrawH(a0)
00019776 3028 0026                  		move.w	oRespawn(a0),d0
0001977A 6700                       		beq.s	ObjMonitorNotBroken
0001977C 3440                       		movea.w	d0,a2
0001977E 0812 0000                  		btst	#0,(a2)				; has monitor been broken?
00019782 6700                       		beq.s	ObjMonitorNotBroken		; if not, branch
00019784 117C 0007 0010             		move.b	#7,oFrame(a0)		; use broken monitor frame
0001978A 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
00019790                            	nextObject
00019790 3068 0004                M 	movea.w	onext(a0),a0
00019794 2250                     M 	move.l	oaddr(a0),a1
00019796 4ED1                     M 	jmp	(a1)
00019798                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019798                            ObjMonitorNotBroken:
00019798 117C 0006 002A             		move.b	#6,oColType(a0)
0001979E 1168 0024 0020             		move.b	oSubtype(a0),oAni(a0)
000197A4                            
000197A4                            ObjMonitorMain:
000197A4 6100                       		bsr.s	ObjMonitorFall
000197A6 323C 0019                  		move.w	#$19,d1
000197AA 343C 0010                  		move.w	#$10,d2
000197AE 3602                       		move.w	d2,d3
000197B0 3828 0014                  		move.w	oXPos(a0),d4
000197B4 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
000197B8 6100                       		bsr.s	SolidObject_Monitor
000197BA                            
000197BA 3038 F8C2                  		move.w	rMaxCamY.w,d0
000197BE 0640 00E0                  		addi.w	#$E0,d0
000197C2 B068 0018                  		cmp.w	oYPos(a0),d0
000197C6 6D00                       		blt.s	ObjMonitorDelete
000197C8                            
000197C8 4EB8 49EC                  		jsr	AddToColResponse
000197CC 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
000197D0 4EB8 1C0A                  		jsr	AnimateObject.w
000197D4 4EB8 1FC8                  		jsr	CheckObjActive.w
000197D8                            	nextObject
000197D8 3068 0004                M 	movea.w	onext(a0),a0
000197DC 2250                     M 	move.l	oaddr(a0),a1
000197DE 4ED1                     M 	jmp	(a1)
000197E0                            
000197E0                            ObjMonitorDelete:
000197E0 4EB8 19E0                  		jsr	DeleteObject.w
000197E4                            	nextObject
000197E4 3068 0004                M 	movea.w	onext(a0),a0
000197E8 2250                     M 	move.l	oaddr(a0),a1
000197EA 4ED1                     M 	jmp	(a1)
000197EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000197EC                            ObjMonitorAnimate:
000197EC 0C28 0007 0010             		cmpi.b	#7,oFrame(a0)
000197F2 6500                       		bcs.s	.NotBroken
000197F4 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
000197FA                            
000197FA                            .NotBroken:
000197FA 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
000197FE 4EB8 1C0A                  		jsr	AnimateObject.w
00019802                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019802                            ObjMonitorCheckActive:
00019802 4EB8 1FC8                  		jsr	CheckObjActive.w
00019806                            	nextObject
00019806 3068 0004                M 	movea.w	onext(a0),a0
0001980A 2250                     M 	move.l	oaddr(a0),a1
0001980C 4ED1                     M 	jmp	(a1)
0001980E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001980E                            ObjMonitorFall:
0001980E 1028 0030                  		move.b	oMonFall(a0),d0
00019812 6700                       		beq.s	.End
00019814 4EB8 1D0A                  		jsr	ObjectMoveAndFall.w
00019818 4A68 001E                  		tst.w	oYVel(a0)
0001981C 6B00                       		bmi.s	.End
0001981E 4EB8 2FD2                  		jsr	ObjCheckFloorDist
00019822 4A41                       		tst.w	d1
00019824 6700                       		beq.s	.InGround
00019826 6A00                       		bpl.s	.End
00019828                            
00019828                            .InGround:
00019828 D368 0018                  		add.w	d1,oYPos(a0)
0001982C 4268 001E                  		clr.w	oYVel(a0)
00019830 4228 0030                  		clr.b	oMonFall(a0)
00019834                            
00019834                            .End:
00019834 4E75                       		rts
00019836                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019836                            SolidObject_Monitor:
00019836 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
0001983C 6600                       		bne.s	ObjMonitorChkOverEdge
0001983E 0C29 0002 0020             		cmpi.b	#2,oAni(a1)
00019844 6700                       		beq.s	.End
00019846 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)		; check if in drowning animation
0001984C 6600                       		bne.s	.SetSolid
0001984E                            
0001984E                            .End:
0001984E 4E75                       		rts
00019850                            
00019850                            .SetSolid:
00019850 4EF8 451E                  		jmp	SolidObject_ChkCollision
00019854                            
00019854                            ObjMonitorChkOverEdge:
00019854 3401                       		move.w	d1,d2
00019856 D442                       		add.w	d2,d2
00019858 0829 0001 0028             		btst	#1,oStatus(a1)
0001985E 6600                       		bne.s	.NotOnMonitor
00019860 3029 0014                  		move.w	oXPos(a1),d0
00019864 9068 0014                  		sub.w	oXPos(a0),d0
00019868 D041                       		add.w	d1,d0
0001986A 6B00                       		bmi.s	.NotOnMonitor
0001986C B042                       		cmp.w	d2,d0
0001986E 6500                       		blo.s	ObjMonitorCharStandOn
00019870                            
00019870                            .NotOnMonitor:
00019870 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)
00019876 08E9 0001 0028             		bset	#1,oStatus(a1)
0001987C 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)
00019882 7800                       		moveq	#0,d4
00019884 4E75                       		rts
00019886                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019886                            ObjMonitorCharStandOn:
00019886 3404                       		move.w	d4,d2
00019888 4EB8 4848                  		jsr	PlayerMoveOnPtfm
0001988C 7800                       		moveq	#0,d4
0001988E 4E75                       		rts
00019890                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019890                            ObjMonitorBreakOpen:
00019890                            		playSnd	#sBreakItem, 2			; Play destroy sound
00019890 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
00019896                            		
00019896 1028 0028                  		move.b	oStatus(a0),d0
0001989A 0200 0028                  		andi.b	#cStand|cPush,d0
0001989E 6700                       		beq.s	ObjMonitorSpawnIcon
000198A0 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
000198A4 0229 00D7 0028             		andi.b	#$D7,oStatus(a1)
000198AA 0029 0002 0028             		ori.b	#2,oStatus(a1)
000198B0                            
000198B0                            ObjMonitorSpawnIcon:
000198B0 4228 0028                  		clr.b	oStatus(a0)
000198B4 117C 0000 002A             		move.b	#0,oColType(a0)
000198BA 4EB8 19B0                  		jsr	FindFreeObj.w
000198BE 6700                       		beq.s	.SkipIconCreation
000198C0 22BC 0000 0000             		move.l	#ObjMonitorContents,oAddr(a1)		; load monitor contents	object
000198C6 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
000198CC 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
000198D2 1368 0020 0020             		move.b	oAni(a0),oAni(a1)
000198D8 1368 000D 000D             		move.b	oRender(a0),oRender(a1)
000198DE 1368 0028 0028             		move.b	oStatus(a0),oStatus(a1)
000198E4                            
000198E4                            .SkipIconCreation:
000198E4 4EB8 19B0                  		jsr	FindFreeObj.w
000198E8 6700                       		beq.s	.SkipExplosionCreation
000198EA 22BC 0001 8ED0             		move.l	#ObjExplosion,oAddr(a1)			; load explosion object
000198F0 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
000198F6 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
000198FC                            
000198FC                            .SkipExplosionCreation:
000198FC 3028 0026                  		move.w	oRespawn(a0),d0
00019900 6700                       		beq.s	.NotRemembered
00019902 3440                       		movea.w	d0,a2
00019904 08D2 0000                  		bset	#0,(a2)
00019908                            
00019908                            .NotRemembered:
00019908 117C 0006 0020             		move.b	#6,oAni(a0)
0001990E 20BC 0001 97EC             		move.l	#ObjMonitorAnimate,oAddr(a0)
00019914                            	nextObject
00019914 3068 0004                M 	movea.w	onext(a0),a0
00019918 2250                     M 	move.l	oaddr(a0),a1
0001991A 4ED1                     M 	jmp	(a1)
0001991C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001991C                            ; Contents of monitor object
0001991C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001991C                            ObjMonitorContents:
0001991C 7000                       		moveq	#0,d0
0001991E 1028 0025                  		move.b	oRoutine(a0),d0
00019922 4EBB 0000                  		jsr	ObjMonitorContents_Index(pc,d0.w)
00019926                            	nextObject
00019926 3068 0004                M 	movea.w	onext(a0),a0
0001992A 2250                     M 	move.l	oaddr(a0),a1
0001992C 4ED1                     M 	jmp	(a1)
0001992E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001992E                            ObjMonitorContents_Index:
0001992E 6000                       		bra.s	ObjMonitorContents_Main
00019930 6000                       		bra.s	ObjMonitorContents_Move
00019932 6000 0000                  		bra.w	ObjMonitorContents_Delete
00019936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00019936                            ObjMonitorContents_Main:
00019936 5428 0025                  		addq.b	#2,oRoutine(a0)
0001993A 317C 8588 000E             		move.w	#$8588,oVRAM(a0)
00019940 117C 0024 000D             		move.b	#$24,oRender(a0)
00019946                            	displaySprite	3,a0,a1,0			; Priority
00019946 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
0001994C 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
00019950 3149 000A                M 	move.w	a1,odrawprev(a0)
00019954 3348 0008                M 	move.w	a0,odrawnext(a1)
00019958 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
0001995C 0C78 BE72 BE7C           M 	cmp.w	#rdispinput+(3*dsize),rdispinput+dprev+(3*dsize).w
00019962 6600                     M 	bne.s	.no_244
00019964 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
00019968                          M .no_244
00019968 117C 0008 0017             		move.b	#8,oDrawW(a0)
0001996E 117C 0008 001B             		move.b	#8,oDrawH(a0)
00019974 317C FD00 001E             		move.w	#-$300,oYVel(a0)
0001997A 7000                       		moveq	#0,d0
0001997C 1028 0020                  		move.b	oAni(a0),d0
00019980 5200                       		addq.b	#1,d0
00019982 227C 0000 0000             		movea.l	#Map_ObjMonitor,a1
00019988 D000                       		add.b	d0,d0
0001998A D2F1 0000                  		adda.w	(a1,d0.w),a1
0001998E 5449                       		addq.w	#2,a1
00019990 2149 0010                  		move.l	a1,oMap(a0)
00019994                            
00019994 1028 0020                  		move.b	oAni(a0),d0
00019998 5200                       		addq.b	#1,d0
0001999A 1140 0010                  		move.b	d0,oFrame(a0)
0001999E                            
0001999E                            ObjMonitorContents_Move:
0001999E 4A68 001E                  		tst.w	oYVel(a0)			; is object moving?
000199A2 6A00 0000                  		bpl.w	ObjMonitorContents_GetType	; if not, branch
000199A6 4EB8 1CF0                  		jsr	ObjectMove.w
000199AA 0668 0018 001E             		addi.w	#$18,oYVel(a0)			; reduce object	speed
000199B0 4E75                       		rts
000199B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199B2                            ObjMonitorContents_GetType:
000199B2 5428 0025                  		addq.b	#2,oRoutine(a0)
000199B6 117C 001D 0023             		move.b	#29,oAniTimer(a0)
000199BC 1028 0020                  		move.b	oAni(a0),d0
000199C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199C0 0C00 0001                  		cmpi.b	#1,d0
000199C4 6600                       		bne.s	.ChkRings
000199C6                            		push.l	a0
000199C6 2F08                     M 	move.l	a0,-(sp)
000199C8 2448                       		movea.l	a0,a2
000199CA 3078 F86C                  		movea.w	rPlayer1Addr.w,a0
000199CE 4EB9 0000 BE1A             		jsr	ObjMighty_GetHurt
000199D4                            		pop.l	a0
000199D4 205F                     M 	move.l	(sp)+,a0
000199D6 4E75                       		rts
000199D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199D8                            .ChkRings:
000199D8 0C00 0002                  		cmpi.b	#2,d0
000199DC 6600                       		bne.s	.Display
000199DE 0678 000A F3D4             		addi.w	#10,rRings.w 				; add 10 rings to the number of rings you have
000199E4 0038 0001 F8F3             		ori.b	#1,rUpdateRings.w 			; update the ring counter
000199EA                            		playSnd	#sRing, 2				; Play ring sound
000199EA 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
000199F0                            
000199F0                            .Display:
000199F0 4E75                       		rts
000199F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199F2                            ObjMonitorContents_Delete:
000199F2 5328 0023                  		subq.b	#1,oAniTimer(a0)
000199F6 6A00                       		bpl.s	.NoDelete
000199F8 4EF8 19E0                  		jmp	DeleteObject.w
000199FC                            
000199FC                            .NoDelete:
000199FC 4E75                       		rts
000199FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199FE                            ; Data
000199FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000199FE                            ArtKosM_Monitor:
000199FE                            		incbin	"Level/Objects/Monitor/Art.kosm.bin"
00019D20 00                         		even
00019D20                            Map_ObjMonitor:
00019D20                            		include	"Level/Objects/Monitor/Mappings.asm"
00019D20                            ; --------------------------------------------------------------------------------
00019D20                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00019D20                            ; --------------------------------------------------------------------------------
00019D20                            
00019D20                            SME_7TKK1:	
00019D20 0000 0000                  		dc.w SME_7TKK1_10-SME_7TKK1, SME_7TKK1_18-SME_7TKK1	
00019D24 0000 0000                  		dc.w SME_7TKK1_26-SME_7TKK1, SME_7TKK1_34-SME_7TKK1	
00019D28 0000 0000                  		dc.w SME_7TKK1_42-SME_7TKK1, SME_7TKK1_50-SME_7TKK1	
00019D2C 0000 0000                  		dc.w SME_7TKK1_5E-SME_7TKK1, SME_7TKK1_6C-SME_7TKK1	
00019D30 0001                       SME_7TKK1_10:	dc.b 0, 1	
00019D32 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D38 0002                       SME_7TKK1_18:	dc.b 0, 2	
00019D3A F505 0018 FFF8             		dc.b $F5, 5, 0, $18, $FF, $F8	
00019D40 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D46 0002                       SME_7TKK1_26:	dc.b 0, 2	
00019D48 F505 001C FFF8             		dc.b $F5, 5, 0, $1C, $FF, $F8	
00019D4E EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D54 0002                       SME_7TKK1_34:	dc.b 0, 2	
00019D56 F505 2020 FFF8             		dc.b $F5, 5, $20, $20, $FF, $F8	
00019D5C EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D62 0002                       SME_7TKK1_42:	dc.b 0, 2	
00019D64 F505 0024 FFF8             		dc.b $F5, 5, 0, $24, $FF, $F8	
00019D6A EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D70 0002                       SME_7TKK1_50:	dc.b 0, 2	
00019D72 F505 0028 FFF8             		dc.b $F5, 5, 0, $28, $FF, $F8	
00019D78 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D7E 0002                       SME_7TKK1_5E:	dc.b 0, 2	
00019D80 F505 002C FFF8             		dc.b $F5, 5, 0, $2C, $FF, $F8	
00019D86 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00019D8C 0001                       SME_7TKK1_6C:	dc.b 0, 1	
00019D8E FF0D 0010 FFF0             		dc.b $FF, $D, 0, $10, $FF, $F0	
00019D94                            		even
00019D94                            Ani_ObjMonitor:
00019D94                            		include	"Level/Objects/Monitor/Animations.asm"
00019D94                            ; ---------------------------------------------------------------------------
00019D94                            ; Animation script - monitors
00019D94                            ; ---------------------------------------------------------------------------
00019D94 0000                       		dc.w .Static-Ani_ObjMonitor
00019D96 0000                       		dc.w .Eggman-Ani_ObjMonitor
00019D98 0000                       		dc.w .Rings-Ani_ObjMonitor
00019D9A 0000                       		dc.w .Shoes-Ani_ObjMonitor
00019D9C 0000                       		dc.w .Shield-Ani_ObjMonitor
00019D9E 0000                       		dc.w .Stars-Ani_ObjMonitor
00019DA0 0000                       		dc.w .Destroyed-Ani_ObjMonitor
00019DA2 0100 01FF 00               .Static:	dc.b 1, 0, 1, $FF, 0
00019DA7 0100 0202 0102 02FF 00     .Eggman:	dc.b 1, 0, 2, 2, 1, 2, 2, $FF, 0
00019DB0 0100 0303 0103 03FF 00     .Rings:		dc.b 1, 0, 3, 3, 1, 3, 3, $FF, 0
00019DB9 0100 0404 0104 04FF 00     .Shoes:		dc.b 1, 0, 4, 4, 1, 4, 4, $FF, 0
00019DC2 0100 0505 0105 05FF 00     .Shield:	dc.b 1, 0, 5, 5, 1, 5, 5, $FF, 0
00019DCB 0100 0606 0106 06FF 00     .Stars:		dc.b 1, 0, 6, 6, 1, 6, 6, $FF, 0
00019DD4 0100 0107 FE01 00          .Destroyed:	dc.b 1, 0, 1, 7, $FE, 1, 0
00019DDC 00                         		even
00019DDC                            ; =========================================================================================================================================================
00019DDC                            		include	"Level/Objects/Spikes/Code.asm"		; Spike object
00019DDC                            ; ===========================================================================
00019DDC                            ; Mighty The Armadillo in PRISM PARADISE
00019DDC                            ; By Nat The Porcupine 2021
00019DDC                            ; ---------------------------------------------------------------------------
00019DDC                            ; Spike object
00019DDC                            ; ===========================================================================
00019DDC                            		rsset	oLvlSSTs
00019DDC =00000030                  oSpikeX		rs.w	1
00019DDC =00000032                  oSpikeY		rs.w	1
00019DDC =00000034                  oSpkMvOff	rs.w	1
00019DDC =00000036                  oSpkMvState	rs.w	1
00019DDC =00000038                  oSpkMvTime	rs.w	1
00019DDC                            ; ===========================================================================
00019DDC                            ObjSpike:
00019DDC 7000                       		moveq	#0,d0
00019DDE 1028 0025                  		move.b	oRoutine(a0),d0
00019DE2 4EBB 0000                  		jsr	ObjSpike_Index(pc,d0.w)
00019DE6                            	nextObject
00019DE6 3068 0004                M 	movea.w	onext(a0),a0
00019DEA 2250                     M 	move.l	oaddr(a0),a1
00019DEC 4ED1                     M 	jmp	(a1)
00019DEE                            ; ===========================================================================
00019DEE                            ObjSpike_Index:
00019DEE 6000 0000                  		bra.w ObjSpike_Init
00019DF2 6000 0000                  		bra.w ObjSpike_Upright
00019DF6 6000 0000                  		bra.w ObjSpike_Sideways
00019DFA 6000 0000                  		bra.w ObjSpike_UpsideDown
00019DFE                            ; ===========================================================================
00019DFE                            ;ObjSpike_InitData:
00019DFE                            ;		dc.b $10,$10	; 0	- Upright or ceiling spikes
00019DFE                            ;		dc.b $10,$10	; 2	- Sideways spikes
00019DFE                            ; ===========================================================================
00019DFE                            ObjSpike_Init:
00019DFE 5828 0025                  		addq.b	#4,oRoutine(a0)
00019E02 217C 0000 0000 0010        		move.l	#Map_ObjSpike,oMap(a0)
00019E0A 317C 06A8 000E             		move.w	#$6A8,oVRAM(a0)
00019E10 0028 0004 000D             		ori.b	#4,oRender(a0)
00019E16                            	displaySprite	4,a0,a1,0			; Priority
00019E16 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
00019E1C 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
00019E20 3149 000A                M 	move.w	a1,odrawprev(a0)
00019E24 3348 0008                M 	move.w	a0,odrawnext(a1)
00019E28 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
00019E2C 0C78 BE7A BE84           M 	cmp.w	#rdispinput+(4*dsize),rdispinput+dprev+(4*dsize).w
00019E32 6600                     M 	bne.s	.no_249
00019E34 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
00019E38                          M .no_249
00019E38 1028 0024                  		move.b	oSubtype(a0),d0
00019E3C 0228 000F 0024             		andi.b	#$F,oSubtype(a0)
00019E42 0240 00F0                  		andi.w	#$F0,d0
00019E46 7210                       		moveq	#$10,d1
00019E48 1141 0017                  		move.b	d1,oDrawW(a0)
00019E4C 1141 002C                  		move.b	d1,oColW(a0)
00019E50 1141 001B                  		move.b	d1,oDrawH(a0)
00019E54 1141 002D                  		move.b	d1,oColH(a0)
00019E58 E848                       		lsr.w	#4,d0
00019E5A 1140 0010                  		move.b	d0,oFrame(a0)
00019E5E 0C00 0001                  		cmpi.b	#1,d0
00019E62 6600                       		bne.s	.ChkUpsideDown
00019E64 5828 0025                  		addq.b	#4,oRoutine(a0)
00019E68 317C 06AC 000E             		move.w	#$6AC,oVRAM(a0)
00019E6E                            
00019E6E                            .ChkUpsideDown:
00019E6E 0828 0001 0028             		btst	#1,oStatus(a0)
00019E74 6700                       		beq.s	.SavePos
00019E76 117C 000C 0025             		move.b	#$C,oRoutine(a0)
00019E7C                            
00019E7C                            .SavePos:
00019E7C 3168 0014 0030             		move.w	oXPos(a0),oSpikeX(a0)
00019E82 3168 0018 0032             		move.w	oYPos(a0),oSpikeY(a0)
00019E88                            
00019E88 6100 0000                  		bsr.w	MoveSpikes		; make the object move
00019E8C 0C28 0001 0010             		cmpi.b	#1,oFrame(a0)		; is object type $1x ?
00019E92 6700                       		beq.s	ObjSpike_SideWays	; if yes, branch
00019E94                            ; ===========================================================================
00019E94                            ; Upright spikes
00019E94                            ; ===========================================================================
00019E94                            ObjSpike_Upright:
00019E94 6100 0000                  		bsr.w	MoveSpikes
00019E98 7200                       		moveq	#0,d1
00019E9A 1228 0017                  		move.b	oDrawW(a0),d1
00019E9E 0641 000B                  		addi.w	#$B,d1
00019EA2 7400                       		moveq	#0,d2
00019EA4 1428 001B                  		move.b	oDrawH(a0),d2
00019EA8 3602                       		move.w	d2,d3
00019EAA 5243                       		addq.w	#1,d3
00019EAC 3828 0014                  		move.w	oXPos(a0),d4
00019EB0 4EB8 43CC                  		jsr	SolidObject
00019EB4 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
00019EBA 6700                       		beq.s	ObjSpike_UprightEnd
00019EBC 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019EC0 6100 0000                  		bsr.w	Touch_ChkHurt2
00019EC4                            
00019EC4                            ObjSpike_UprightEnd:
00019EC4 3028 0030                  		move.w	oSpikeX(a0),d0
00019EC8 4EF8 1FC8                  		jmp	CheckObjActive.w
00019ECC                            ; ===========================================================================
00019ECC                            ; Sideways spikes
00019ECC                            ; ===========================================================================
00019ECC                            ObjSpike_Sideways:
00019ECC 3F28 0014                  		move.w	oXPos(a0),-(sp)	
00019ED0 6100 0000                  		bsr.w	MoveSpikes
00019ED4 7200                       		moveq	#0,d1
00019ED6 1228 0017                  		move.b	oDrawW(a0),d1
00019EDA 0641 000B                  		addi.w	#$B,d1
00019EDE 7400                       		moveq	#0,d2
00019EE0 1428 001B                  		move.b	oDrawH(a0),d2
00019EE4 3602                       		move.w	d2,d3
00019EE6 5243                       		addq.w	#1,d3
00019EE8 381F                       		move.w	(sp)+,d4
00019EEA 4EB8 43CC                  		jsr	SolidObject
00019EEE 0806 0000                  		btst	#cTouchSideBit,d6
00019EF2 6700                       		beq.s	ObjSpike_SidewaysEnd
00019EF4 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019EF8 6100 0000                  		bsr.w	Touch_ChkHurt2
00019EFC                            
00019EFC                            ObjSpike_SidewaysEnd:
00019EFC 3028 0030                  		move.w	oSpikeX(a0),d0
00019F00 4EF8 1FC8                  		jmp	CheckObjActive.w
00019F04                            ; ===========================================================================
00019F04                            ; Upside down spikes
00019F04                            ; ===========================================================================
00019F04                            ObjSpike_UpsideDown:
00019F04 6100 0000                  		bsr.w	MoveSpikes
00019F08 7200                       		moveq	#0,d1
00019F0A 1228 0017                  		move.b	oDrawW(a0),d1
00019F0E 0641 000B                  		addi.w	#$B,d1
00019F12 7400                       		moveq	#0,d2
00019F14 1428 001B                  		move.b	oDrawH(a0),d2
00019F18 3602                       		move.w	d2,d3
00019F1A 5243                       		addq.w	#1,d3
00019F1C 3828 0014                  		move.w	oXPos(a0),d4
00019F20 4EB8 43CC                  		jsr	SolidObject
00019F24 0806 0002                  		btst	#cTouchBtmBit,d6
00019F28 6700                       		beq.s	ObjSpike_UpsideDownEnd
00019F2A 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00019F2E 6100 0000                  		bsr.w	Touch_ChkHurt2
00019F32                            
00019F32                            ObjSpike_UpsideDownEnd:
00019F32 3028 0030                  		move.w	oSpikeX(a0),d0
00019F36 4EF8 1FC8                  		jmp	CheckObjActive.w
00019F3A                            ; ===========================================================================
00019F3A                            Touch_ChkHurt2:
00019F3A 4A29 0042                  		tst.b	oInvulTime(a1)			; is Sonic invincible?
00019F3E 6600                       		bne.s	.End				; if yes, branch
00019F40 0C29 0008 0025             		cmpi.b	#8,oRoutine(a1)
00019F46 6700                       		beq.s	.End
00019F48 2629 0018                  		move.l	oYPos(a1),d3
00019F4C 3029 001E                  		move.w	oYVel(a1),d0
00019F50 48C0                       		ext.l	d0
00019F52 E180                       		asl.l	#8,d0
00019F54 9680                       		sub.l	d0,d3
00019F56 2343 0018                  		move.l	d3,oYPos(a1)
00019F5A 2448                       		movea.l	a0,a2
00019F5C 2049                       		movea.l	a1,a0
00019F5E 4EB9 0000 BE1A             		jsr	ObjMighty_GetHurt
00019F64 204A                       		movea.l	a2,a0
00019F66                            
00019F66                            .End:
00019F66 4E75                       		rts
00019F68                            ; ===========================================================================
00019F68                            MoveSpikes:	
00019F68 7000                       		moveq	#0,d0
00019F6A 1028 0024                  		move.b	oSubtype(a0),d0
00019F6E D040                       		add.w	d0,d0
00019F70 4EFB 0000                  		jmp	MoveSpikes_Behaviors(pc,d0.w)
00019F74                            ; ===========================================================================
00019F74                            MoveSpikes_Behaviors:
00019F74 6000                       		bra.s MoveSpikes_Still
00019F76 6000                       		bra.s MoveSpikes_Vertical
00019F78 6000                       		bra.s MoveSpikes_Horizontal
00019F7A                            ; ===========================================================================
00019F7A                            MoveSpikes_Still:
00019F7A 4E75                       		rts			; don't move the object
00019F7C                            ; ===========================================================================
00019F7C                            MoveSpikes_Vertical:
00019F7C 6100 0000                  		bsr.w	MoveSpikes_Delay
00019F80 7000                       		moveq	#0,d0
00019F82 1028 0034                  		move.b	oSpkMvOff(a0),d0
00019F86 D068 0032                  		add.w	oSpikeY(a0),d0
00019F8A 3140 0018                  		move.w	d0,oYPos(a0)	; move the object vertically
00019F8E 4E75                       		rts
00019F90                            ; ===========================================================================
00019F90                            MoveSpikes_Horizontal:
00019F90 6100 0000                  		bsr.w	MoveSpikes_Delay
00019F94 7000                       		moveq	#0,d0
00019F96 1028 0034                  		move.b	oSpkMvOff(a0),d0
00019F9A D068 0030                  		add.w	oSpikeX(a0),d0
00019F9E 3140 0014                  		move.w	d0,oXPos(a0)	; move the object horizontally
00019FA2 4E75                       		rts
00019FA4                            ; ===========================================================================
00019FA4                            MoveSpikes_Delay:
00019FA4 4A68 0038                  		tst.w	oSpkMvTime(a0)		; is time delay	= zero?
00019FA8 6700                       		beq.s	MoveSpikes_ChkDir		; if yes, branch
00019FAA 5368 0038                  		subq.w	#1,oSpkMvTime(a0)	; subtract 1 from time delay
00019FAE 6600                       		bne.s	locret_CFE6
00019FB0 4A28 000D                  		tst.b	oRender(a0)
00019FB4 6A00                       		bpl.s	locret_CFE6
00019FB6                            		playSnd	#sSpikeMove, 2		; Play spike move sound
00019FB6 11FC 008B C4BD           M 	move.b	#sspikemove,(mqueue+((2)-1)).w
00019FBC 6000                       		bra.s	locret_CFE6
00019FBE                            ; ===========================================================================
00019FBE                            MoveSpikes_ChkDir:
00019FBE 4A68 0036                  		tst.w	oSpkMvState(a0)
00019FC2 6700                       		beq.s	MoveSpikes_Retract
00019FC4 0468 0800 0034             		subi.w	#$800,oSpkMvOff(a0)
00019FCA 6400                       		bcc.s	locret_CFE6
00019FCC 317C 0000 0034             		move.w	#0,oSpkMvOff(a0)
00019FD2 317C 0000 0036             		move.w	#0,oSpkMvState(a0)
00019FD8 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
00019FDE 6000                       		bra.s	locret_CFE6
00019FE0                            ; ===========================================================================
00019FE0                            MoveSpikes_Retract:
00019FE0 0668 0800 0034             		addi.w	#$800,oSpkMvOff(a0)
00019FE6 0C68 2000 0034             		cmpi.w	#$2000,oSpkMvOff(a0)
00019FEC 6500                       		bcs.s	locret_CFE6
00019FEE 317C 2000 0034             		move.w	#$2000,oSpkMvOff(a0)
00019FF4 317C 0001 0036             		move.w	#1,oSpkMvState(a0)
00019FFA 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
0001A000                            
0001A000                            locret_CFE6:
0001A000 4E75                       		rts
0001A002                            ; ===========================================================================
0001A002                            ; Spike object mappings
0001A002                            ; ===========================================================================
0001A002                            Map_ObjSpike:
0001A002                            	include "Level/Objects/Spikes/Mappings.asm"
0001A002                            ; --------------------------------------------------------------------------------
0001A002                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001A002                            ; --------------------------------------------------------------------------------
0001A002                            
0001A002                            SME_5AG23:	
0001A002 0000 0000                  		dc.w SME_5AG23_4-SME_5AG23, SME_5AG23_1E-SME_5AG23	
0001A006 0004                       SME_5AG23_4:	dc.b 0, 4	
0001A008 F003 0000 FFF0             		dc.b $F0, 3, 0, 0, $FF, $F0	
0001A00E F003 0000 FFF8             		dc.b $F0, 3, 0, 0, $FF, $F8	
0001A014 F003 0000 0000             		dc.b $F0, 3, 0, 0, 0, 0	
0001A01A F003 0000 0008             		dc.b $F0, 3, 0, 0, 0, 8	
0001A020 0004                       SME_5AG23_1E:	dc.b 0, 4	
0001A022 F00C 0000 FFF0             		dc.b $F0, $C, 0, 0, $FF, $F0	
0001A028 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
0001A02E 000C 0000 FFF0             		dc.b 0, $C, 0, 0, $FF, $F0	
0001A034 080C 0000 FFF0             		dc.b 8, $C, 0, 0, $FF, $F0	
0001A03A                            		even
0001A03A                            ; ===========================================================================
0001A03A                            ArtKosM_SpikesN:
0001A03A                            		incbin	"Level/Objects/Spikes/Art - Normal.kosm.bin"
0001A07A                            		even
0001A07A                            ; ===========================================================================
0001A07A                            ArtKosM_SpikesS:
0001A07A                            		incbin	"Level/Objects/Spikes/Art - Sideways.kosm.bin"
0001A0BC 00                         		even
0001A0BC                            ; ===========================================================================
0001A0BC                            		include	"Level/Objects/Spring/Code.asm"		; Spring object
0001A0BC                            ; =========================================================================================================================================================
0001A0BC                            ; Mighty The Armadillo in PRISM PARADISE
0001A0BC                            ; By Nat The Porcupine 2021
0001A0BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0BC                            ; Spring object
0001A0BC                            ; =========================================================================================================================================================
0001A0BC                            		rsset	oLvlSSTs
0001A0BC =00000030                  oSprSpd		rs.w	1				; Spring strength
0001A0BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A0BC                            ObjSpring:
0001A0BC 217C 0000 0000 0010        		move.l	#Map_ObjSpring,oMap(a0)		; Mappings
0001A0C4 317C 05BA 000E             		move.w	#$5BA,oVRAM(a0)			; Tile properties
0001A0CA 0028 0004 000D             		ori.b	#4,oRender(a0)			; Render flags
0001A0D0 117C 0010 0017             		move.b	#$10,oDrawW(a0)			; Sprite width
0001A0D6 117C 0008 001B             		move.b	#8,oDrawH(a0)			; Sprite height
0001A0DC 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
0001A0E2                            	displaySprite	4,a0,a1,0			; Priority
0001A0E2 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
0001A0E8 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
0001A0EC 3149 000A                M 	move.w	a1,odrawprev(a0)
0001A0F0 3348 0008                M 	move.w	a0,odrawnext(a1)
0001A0F4 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
0001A0F8 0C78 BE7A BE84           M 	cmp.w	#rdispinput+(4*dsize),rdispinput+dprev+(4*dsize).w
0001A0FE 6600                     M 	bne.s	.no_251
0001A100 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
0001A104                          M .no_251
0001A104                            		
0001A104 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A108 E648                       		lsr.w	#3,d0				; Turn into offset
0001A10A 0240 000E                  		andi.w	#$E,d0				; ''
0001A10E 4EFB 0000                  		jmp	.Subtypes(pc,d0.w)		; Jump to it
0001A112                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A112                            .Subtypes:
0001A112 6000                       		bra.s .Init_Up				; Up
0001A114 6000                       		bra.s .Init_Horizontal			; Horizontal
0001A116 6000                       		bra.s .Init_Down			; Down
0001A118 6000                       		bra.s .Init_DiagonallyUp		; Diagonally up
0001A11A 6000                       		bra.s .Init_DiagonallyDown		; Diagonally down
0001A11C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A11C                            .Init_Horizontal:
0001A11C 117C 0002 0020             		move.b	#2,oAni(a0)			; Animation
0001A122 117C 0002 0010             		move.b	#2,oFrame(a0)			; Mapping frame
0001A128 317C 05CA 000E             		move.w	#$5CA,oVRAM(a0)			; Tile properties
0001A12E 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
0001A134 117C 0010 001B             		move.b	#$10,oDrawH(a0)			; Sprite height
0001A13A 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
0001A140 20BC 0000 0000             		move.l	#ObjSpring_Horizontal,oAddr(a0)	; Next routine
0001A146 6000                       		bra.s	.Init_Common			; Continue
0001A148                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A148                            .Init_Down:
0001A148 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
0001A14E 20BC 0000 0000             		move.l	#ObjSpring_Down,oAddr(a0)	; Next routine
0001A154 6000                       		bra.s	.Init_Common			; Continue
0001A156                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A156                            .Init_DiagonallyUp:
0001A156 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
0001A15C 117C 0004 0010             		move.b	#4,oFrame(a0)			; Map frame
0001A162 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
0001A168 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyUp,oAddr(a0); Next routine
0001A16E 6000                       		bra.s	.Init_Common			; Continue
0001A170                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A170                            .Init_DiagonallyDown:
0001A170 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
0001A176 117C 0006 0010             		move.b	#6,oFrame(a0)			; Map frame
0001A17C 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
0001A182 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
0001A188 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyDown,oAddr(a0); Next routine
0001A18E 6000                       		bra.s	.Init_Common			; Continue
0001A190                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A190                            .Init_Up:
0001A190 20BC 0000 0000             		move.l	#ObjSpring_Up,oAddr(a0)		; Next routine
0001A196                            
0001A196                            .Init_Common:
0001A196 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A19A 0240 0002                  		andi.w	#2,d0				; Turn into offset
0001A19E 317B 0000 0030             		move.w	.Strengths(pc,d0.w),oSprSpd(a0)	; Get spring strength
0001A1A4 0800 0001                  		btst	#1,d0				; Is the spring supposed to be yellow?
0001A1A8 6700                       		beq.s	.NotYellow			; If not, branch
0001A1AA 08E8 0005 000E             		bset	#5,oVRAM(a0)			; Make the spring yellow
0001A1B0                            
0001A1B0                            .NotYellow:
0001A1B0                            	nextObject
0001A1B0 3068 0004                M 	movea.w	onext(a0),a0
0001A1B4 2250                     M 	move.l	oaddr(a0),a1
0001A1B6 4ED1                     M 	jmp	(a1)
0001A1B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A1B8                            .Strengths:
0001A1B8 F000                       		dc.w	-$1000				; Strength of red spring
0001A1BA F600                       		dc.w	-$A00				; Strength of yellow spring
0001A1BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A1BC                            ObjSpring_Up:
0001A1BC 323C 001A                  		move.w	#27-1,d1			; Width
0001A1C0 343C 0008                  		move.w	#16/2,d2			; Height
0001A1C4 3602                       		move.w	d2,d3				; ''
0001A1C6 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A1CA 4EB8 441C                  		jsr	SolidObject_Always		; Set object as solid
0001A1CE 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the top of the of spring?
0001A1D4 6700                       		beq.s	.Display			; If not, branch
0001A1D6 6100                       		bsr.s	.Bounce				; Bounce the player up
0001A1D8                            
0001A1D8                            .Display:
0001A1D8 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A1DC 4EB8 1C0A                  		jsr	AnimateObject.w			; ''
0001A1E0 4EB8 1FC8                  		jsr	CheckObjActive.w		; Display sprite
0001A1E4                            	nextObject
0001A1E4 3068 0004                M 	movea.w	onext(a0),a0
0001A1E8 2250                     M 	move.l	oaddr(a0),a1
0001A1EA 4ED1                     M 	jmp	(a1)
0001A1EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A1EC                            .Bounce:
0001A1EC 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
0001A1F2 5069 0018                  		addq.w	#8,oYPos(a1)			; Align player to spring
0001A1F6 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
0001A1FC 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
0001A202 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
0001A208 4229 0040                  		clr.b	oJumping(a1)			; Clear the player's jump flag
0001A20C 137C 0010 0020             		move.b	#$10,oAni(a1)			; Set the player's animation to the spring animation
0001A212 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
0001A218                            		
0001A218 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A21C 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
0001A21E 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
0001A222                            
0001A222                            .ChkPath1:
0001A222 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A226 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A22A 6600                       		bne.s	.ChkPath2			; If not, branch
0001A22C 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A232 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A238                            
0001A238                            .ChkPath2:
0001A238 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A23C 6600                       		bne.s	.PlaySound			; If not, branch
0001A23E 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A244 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A24A                            
0001A24A                            .PlaySound:
0001A24A                            		playSnd	#sSpring, 2			; Play spring sound
0001A24A 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A250 4E75                       		rts
0001A252                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A252                            ObjSpring_Horizontal:
0001A252 323C 0013                  		move.w	#20-1,d1			; Width
0001A256 343C 000E                  		move.w	#28/2,d2			; Height
0001A25A 3602                       		move.w	d2,d3				; ''
0001A25C 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A260 4EB8 441C                  		jsr	SolidObject_Always		; Set object as solid
0001A264 0806 0000                  		btst	#cTouchSideBit,d6		; Has the player touched the side of the spring?
0001A268 6700                       		beq.s	.Display			; If not, branch
0001A26A 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0001A26E 3028 0014                  		move.w	oXPos(a0),d0			; Get which side of the spring the player is facing
0001A272 9069 0014                  		sub.w	oXPos(a1),d0			; ''
0001A276 6500                       		bcs.s	.NoFlip				; If the player is on the left side of the spring, branch
0001A278 0A01 0001                  		eori.b	#1,d1				; Flip so that we check for the other side of the spring
0001A27C                            
0001A27C                            .NoFlip:
0001A27C 0201 0001                  		andi.b	#1,d1				; Is the player touching the bouncy side of the spring?
0001A280 6600                       		bne.s	.Display			; If not, branch
0001A282 6100                       		bsr.s	.Bounce				; Bounce the player
0001A284                            
0001A284                            .Display:
0001A284 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A288 4EB8 1C0A                  		jsr	AnimateObject.w			; ''
0001A28C 4EB8 1FC8                  		jsr	CheckObjActive.w		; Display sprite
0001A290                            	nextObject
0001A290 3068 0004                M 	movea.w	onext(a0),a0
0001A294 2250                     M 	move.l	oaddr(a0),a1
0001A296 4ED1                     M 	jmp	(a1)
0001A298                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A298                            .Bounce:	
0001A298 317C 0300 0020             		move.w	#$300,oAni(a0)			; Reset animation
0001A29E 5069 0014                  		addq.w	#8,oXPos(a1)			; Align player to spring
0001A2A2 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)		; Set the player's X velocity
0001A2A8 08E9 0000 0028             		bset	#0,oStatus(a1)			; Make the player face the left
0001A2AE 0828 0000 0028             		btst	#0,oStatus(a0)			; Is this spring facing the left?
0001A2B4 6600                       		bne.s	.SetMoveLock			; If so, branch
0001A2B6 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Make the player face the right
0001A2BC 0469 0010 0014             		subi.w	#$10,oXPos(a1)			; Align player to spring
0001A2C2 4469 001C                  		neg.w	oXVel(a1)			; Move the player to the right
0001A2C6                            
0001A2C6                            .SetMoveLock:
0001A2C6 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Lock the player's movement for a bit
0001A2CC 3369 001C 003A             		move.w	oXVel(a1),oGVel(a1)		; Set the player's ground velocity
0001A2D2                            		
0001A2D2 0829 0002 0028             		btst	#2,oStatus(a1)			; Is the player jumping?
0001A2D8 6600                       		bne.s	.ChkYStop			; If so, branch
0001A2DA 4229 0020                  		clr.b	oAni(a1)			; Set the animation to the walking animation
0001A2DE                            		
0001A2DE                            .ChkYStop:
0001A2DE 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A2E2 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move vertically
0001A2E4 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's Y movement
0001A2E8                            
0001A2E8                            .ChkPath1:
0001A2E8 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A2EC 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A2F0 6600                       		bne.s	.ChkPath2			; If not, branch
0001A2F2 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A2F8 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A2FE                            
0001A2FE                            .ChkPath2:
0001A2FE 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A302 6600                       		bne.s	.PlaySound			; If not, branch
0001A304 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A30A 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A310                            
0001A310                            .PlaySound:
0001A310 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear "push" flags
0001A316 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
0001A31C                            		playSnd	#sSpring, 2			; Play spring sound
0001A31C 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A322 4E75                       		rts
0001A324                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A324                            ObjSpring_Down:
0001A324 323C 0012                  		move.w	#19-1,d1			; Width
0001A328 343C 0008                  		move.w	#16/2,d2			; Height
0001A32C 3602                       		move.w	d2,d3				; ''
0001A32E 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A332 4EB8 441C                  		jsr	SolidObject_Always		; Set object as solid
0001A336 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the bottom of the spring?
0001A33A 6600                       		bne.s	.Display			; If not, branch
0001A33C 6100                       		bsr.s	.Bounce				; Bounce the player
0001A33E                            
0001A33E                            .Display:
0001A33E 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A342 4EB8 1C0A                  		jsr	AnimateObject.w			; ''
0001A346 4EB8 1FC8                  		jsr	CheckObjActive.w		; Display sprite
0001A34A                            	nextObject
0001A34A 3068 0004                M 	movea.w	onext(a0),a0
0001A34E 2250                     M 	move.l	oaddr(a0),a1
0001A350 4ED1                     M 	jmp	(a1)
0001A352                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A352                            .Bounce:
0001A352 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
0001A358 5169 0018                  		subq.w	#8,oYPos(a1)			; Align player with the spring
0001A35C 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
0001A362 4469 001E                  		neg.w	oYVel(a1)			; Move the player down
0001A366                            		
0001A366 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001A36A 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
0001A36C 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
0001A370                            
0001A370                            .ChkPath1:
0001A370 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A374 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A378 6600                       		bne.s	.ChkPath2			; If not, branch
0001A37A 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A380 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A386                            
0001A386                            .ChkPath2:
0001A386 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A38A 6600                       		bne.s	.PlaySound			; If not, branch
0001A38C 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A392 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A398                            
0001A398                            .PlaySound:
0001A398 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
0001A39E 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
0001A3A4 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
0001A3AA                            		playSnd	#sSpring, 2			; Play spring sound
0001A3AA 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A3B0 4E75                       		rts
0001A3B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A3B2                            ObjSpring_DiagonallyUp:
0001A3B2 323C 0019                  		move.w	#26-1,d1			; Width
0001A3B6 343C 0010                  		move.w	#32/2,d2			; Height
0001A3BA 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001A3BE 45FA 0000                  		lea	.SlopeData(pc),a2		; Slope Data
0001A3C2 4EB8 446C                  		jsr	SlopedSolid			; Set object as a solid slope
0001A3C6                            		
0001A3C6 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the spring?
0001A3CC 6700                       		beq.s	.End				; If not, branch
0001A3CE 6100                       		bsr.s	.Bounce				; Bounce the player
0001A3D0                            
0001A3D0                            .End:
0001A3D0 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A3D4 4EB8 1C0A                  		jsr	AnimateObject.w			; ''
0001A3D8 4EB8 1FC8                  		jsr	CheckObjActive.w		; Display sprite
0001A3DC                            	nextObject
0001A3DC 3068 0004                M 	movea.w	onext(a0),a0
0001A3E0 2250                     M 	move.l	oaddr(a0),a1
0001A3E2 4ED1                     M 	jmp	(a1)
0001A3E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A3E4                            .Bounce:
0001A3E4 0828 0000 0028             		btst	#0,oStatus(a0)			; Is the spring facing left?
0001A3EA 6600                       		bne.s	.FaceLeft			; If so, branch
0001A3EC 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
0001A3F0 5940                       		subq.w	#4,d0				; Subtract 4
0001A3F2 B069 0014                  		cmp.w	oXPos(a1),d0			; Is the player
0001A3F6 6500                       		blo.s	.DoBounce
0001A3F8 4E75                       		rts
0001A3FA                            
0001A3FA                            .FaceLeft:
0001A3FA 3028 0014                  		move.w	oXPos(a0),d0
0001A3FE 5840                       		addq.w	#4,d0
0001A400 B069 0014                  		cmp.w	oXPos(a1),d0
0001A404 6400                       		bhs.s	.DoBounce
0001A406 4E75                       		rts
0001A408                            
0001A408                            .DoBounce:
0001A408 317C 0500 0020             		move.w	#$500,oAni(a0)
0001A40E 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
0001A414 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
0001A41A 5C69 0018                  		addq.w	#6,oYPos(a1)
0001A41E 5C69 0014                  		addq.w	#6,oXPos(a1)
0001A422 08E9 0000 0028             		bset	#0,oStatus(a1)
0001A428 0828 0000 0028             		btst	#0,oStatus(a0)
0001A42E 6600                       		bne.s	.SetAni
0001A430 08A9 0000 0028             		bclr	#0,oStatus(a1)
0001A436 0469 000C 0014             		subi.w	#$C,oXPos(a1)
0001A43C 4469 001C                  		neg.w	oXVel(a1)
0001A440                            
0001A440                            .SetAni:
0001A440 08E9 0001 0028             		bset	#1,oStatus(a1)
0001A446 08A9 0003 0028             		bclr	#3,oStatus(a1)
0001A44C 137C 0010 0020             		move.b	#$10,oAni(a1)
0001A452 137C 0004 0025             		move.b	#4,oRoutine(a1)
0001A458                            
0001A458 1028 0024                  		move.b	oSubtype(a0),d0
0001A45C 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A460 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A464 6600                       		bne.s	.ChkPath2			; If not, branch
0001A466 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A46C 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A472                            
0001A472                            .ChkPath2:
0001A472 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A476 6600                       		bne.s	.PlaySound			; If not, branch
0001A478 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A47E 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A484                            
0001A484                            .PlaySound:
0001A484                            		playSnd	#sSpring, 2			; Play spring sound
0001A484 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A48A 4E75                       		rts
0001A48C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A48C                            .SlopeData:
0001A48C 1010 1010 1010 10          		dc.b	$10, $10, $10, $10, $10, $10, $10
0001A493 1010 1010 100E 0C          		dc.b	$10, $10, $10, $10, $10, $0E, $0C
0001A49A 0A08 0604 0200 FE          		dc.b	$0A, $08, $06, $04, $02, $00, $FE
0001A4A1 FCFC FCFC FCFC FC          		dc.b	$FC, $FC, $FC, $FC, $FC, $FC, $FC
0001A4A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A4A8                            ObjSpring_DiagonallyDown:
0001A4A8 323C 0019                  		move.w	#26-1,d1			; Width
0001A4AC 343C 0010                  		move.w	#32/2,d2
0001A4B0 3828 0014                  		move.w	oXPos(a0),d4
0001A4B4 45FA 0000                  		lea	.SlopeData(pc),a2
0001A4B8 4EB8 446C                  		jsr	SlopedSolid			; Set object as a solid slope
0001A4BC 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the spring?
0001A4C0 6600                       		bne.s	.End				; If not, branch
0001A4C2 6100                       		bsr.s	.Bounce				; Bounce the player
0001A4C4                            
0001A4C4                            .End:
0001A4C4 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
0001A4C8 4EB8 1C0A                  		jsr	AnimateObject.w			; ''
0001A4CC 4EB8 1FC8                  		jsr	CheckObjActive.w		; Display sprite
0001A4D0                            	nextObject
0001A4D0 3068 0004                M 	movea.w	onext(a0),a0
0001A4D4 2250                     M 	move.l	oaddr(a0),a1
0001A4D6 4ED1                     M 	jmp	(a1)
0001A4D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A4D8                            .Bounce:
0001A4D8 317C 0500 0020             		move.w	#$500,oAni(a0)
0001A4DE 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
0001A4E4 4469 001E                  		neg.w	oYVel(a1)
0001A4E8 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
0001A4EE 5C69 0018                  		addq.w	#6,oYPos(a1)
0001A4F2 5C69 0014                  		addq.w	#6,oXPos(a1)
0001A4F6 08E9 0000 0028             		bset	#0,oStatus(a1)
0001A4FC 0828 0000 0028             		btst	#0,oStatus(a0)
0001A502 6600                       		bne.s	.SetAni
0001A504 08A9 0000 0028             		bclr	#0,oStatus(a1)
0001A50A 0469 000C 0014             		subi.w	#$C,oXPos(a1)
0001A510 4469 001C                  		neg.w	oXVel(a1)
0001A514                            
0001A514                            .SetAni:
0001A514 08E9 0001 0028             		bset	#1,oStatus(a1)
0001A51A 08A9 0003 0028             		bclr	#3,oStatus(a1)
0001A520 137C 0004 0025             		move.b	#4,oRoutine(a1)
0001A526                            
0001A526 1028 0024                  		move.b	oSubtype(a0),d0
0001A52A 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0001A52E 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0001A532 6600                       		bne.s	.ChkPath2			; If not, branch
0001A534 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0001A53A 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0001A540                            
0001A540                            .ChkPath2:
0001A540 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
0001A544 6600                       		bne.s	.PlaySound			; If not, branch
0001A546 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0001A54C 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0001A552                            
0001A552                            .PlaySound:
0001A552                            		playSnd	#sSpring, 2			; Play spring sound
0001A552 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001A558 4E75                       		rts
0001A55A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A55A                            .SlopeData:
0001A55A F4F0 F0F0 F0F0 F0          		dc.b	$F4, $F0, $F0, $F0, $F0, $F0, $F0
0001A561 F0F0 F0F0 F0F2 F4          		dc.b	$F0, $F0, $F0, $F0, $F0, $F2, $F4
0001A568 F6F8 FAFC FE00 02          		dc.b	$F6, $F8, $FA, $FC, $FE, $00, $02
0001A56F 0404 0404 0404 04          		dc.b	$04, $04, $04, $04, $04, $04, $04
0001A576                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A576                            ; Data
0001A576                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001A576                            Ani_ObjSpring:
0001A576                            		include	"Level/Objects/Spring/Animations.asm"
0001A576                            ; ---------------------------------------------------------------------------
0001A576                            ; Animation script - springs
0001A576                            ; ---------------------------------------------------------------------------
0001A576 0000                       		dc.w byte_18FEE-Ani_ObjSpring
0001A578 0000                       		dc.w byte_18FF1-Ani_ObjSpring
0001A57A 0000                       		dc.w byte_18FFD-Ani_ObjSpring
0001A57C 0000                       		dc.w byte_19000-Ani_ObjSpring
0001A57E 0000                       		dc.w byte_1900C-Ani_ObjSpring
0001A580 0000                       		dc.w byte_1900F-Ani_ObjSpring
0001A582                            byte_18FEE:
0001A582 0F00 FF                    		dc.b  $F, 0, $FF
0001A586 00                         		even
0001A586                            byte_18FF1:
0001A586 0001 0101 0101 01FD 00     		dc.b 0, 1, 1, 1, 1, 1, 1, $FD, 0
0001A590 00                         		even
0001A590                            byte_18FFD:
0001A590 0F02 FF                    		dc.b $F, 2, $FF
0001A594 00                         		even
0001A594                            byte_19000:
0001A594 0003 0303 0303 03FD 02     		dc.b 0, 3, 3, 3, 3, 3, 3, $FD, 2
0001A59E 00                         		even
0001A59E                            byte_1900C:
0001A59E 0F04 FF                    		dc.b $F, 4, $FF
0001A5A2 00                         		even
0001A5A2                            byte_1900F:
0001A5A2 0005 0505 0505 05FD 04     		dc.b 0, 5, 5, 5, 5, 5, 5, $FD, 4
0001A5AC 00                         		even
0001A5AC                            Map_ObjSpring:
0001A5AC                            		include	"Level/Objects/Spring/Mappings.asm"
0001A5AC                            ; --------------------------------------------------------------------------------
0001A5AC                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001A5AC                            ; --------------------------------------------------------------------------------
0001A5AC                            
0001A5AC                            SME_q_6K9:	
0001A5AC 0000 0000                  		dc.w SME_q_6K9_E-SME_q_6K9, SME_q_6K9_1C-SME_q_6K9	
0001A5B0 0000 0000                  		dc.w SME_q_6K9_3C-SME_q_6K9, SME_q_6K9_44-SME_q_6K9	
0001A5B4 0000 0000                  		dc.w SME_q_6K9_70-SME_q_6K9, SME_q_6K9_7E-SME_q_6K9	
0001A5B8 0000                       		dc.w SME_q_6K9_9E-SME_q_6K9	
0001A5BA 0002                       SME_q_6K9_E:	dc.b 0, 2	
0001A5BC F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
0001A5C2 000C 0004 FFF0             		dc.b 0, $C, 0, 4, $FF, $F0	
0001A5C8 0005                       SME_q_6K9_1C:	dc.b 0, 5	
0001A5CA E00C 0000 FFF0             		dc.b $E0, $C, 0, 0, $FF, $F0	
0001A5D0 E804 0008 FFF8             		dc.b $E8, 4, 0, 8, $FF, $F8	
0001A5D6 F004 000A FFF8             		dc.b $F0, 4, 0, $A, $FF, $F8	
0001A5DC F804 000A FFF8             		dc.b $F8, 4, 0, $A, $FF, $F8	
0001A5E2 000C 000C FFF0             		dc.b 0, $C, 0, $C, $FF, $F0	
0001A5E8 0001                       SME_q_6K9_3C:	dc.b 0, 1	
0001A5EA E807 0000 FFF7             		dc.b $E8, 7, 0, 0, $FF, $F7	
0001A5F0 0007                       SME_q_6K9_44:	dc.b 0, 7	
0001A5F2 E803 0004 0017             		dc.b $E8, 3, 0, 4, 0, $17	
0001A5F8 F001 0008 000F             		dc.b $F0, 1, 0, 8, 0, $F	
0001A5FE F001 000A 0007             		dc.b $F0, 1, 0, $A, 0, 7	
0001A604 F001 000A FFFF             		dc.b $F0, 1, 0, $A, $FF, $FF	
0001A60A F001 000C FFF7             		dc.b $F0, 1, 0, $C, $FF, $F7	
0001A610 E800 000E FFF7             		dc.b $E8, 0, 0, $E, $FF, $F7	
0001A616 0000 100E FFF7             		dc.b 0, 0, $10, $E, $FF, $F7	
0001A61C 0002                       SME_q_6K9_70:	dc.b 0, 2	
0001A61E F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
0001A624 FA02 000C 0008             		dc.b $FA, 2, 0, $C, 0, 8	
0001A62A 0005                       SME_q_6K9_7E:	dc.b 0, 5	
0001A62C E20B 000F 0000             		dc.b $E2, $B, 0, $F, 0, 0	
0001A632 EA02 001B 0018             		dc.b $EA, 2, 0, $1B, 0, $18	
0001A638 F201 201E FFF8             		dc.b $F2, 1, $20, $1E, $FF, $F8	
0001A63E FA00 0020 FFF0             		dc.b $FA, 0, 0, $20, $FF, $F0	
0001A644 0209 0021 FFF0             		dc.b 2, 9, 0, $21, $FF, $F0	
0001A64A 0002                       SME_q_6K9_9E:	dc.b 0, 2	
0001A64C 020B 1000 FFF0             		dc.b 2, $B, $10, 0, $FF, $F0	
0001A652 0202 100C 0008             		dc.b 2, 2, $10, $C, 0, 8	
0001A658                            		even
0001A658                            ArtKosM_SpringH:
0001A658                            		incbin	"Level/Objects/Spring/Art - Horizontal.kosm.bin"
0001A734 00                         		even
0001A734                            ArtKosM_SpringV:
0001A734                            		incbin	"Level/Objects/Spring/Art - Vertical.kosm.bin"
0001A81A 00                         		even
0001A81A                            ArtKosM_SpringD:
0001A81A                            		incbin	"Level/Objects/Spring/Art - Diagonal.kosm.bin"
0001AA34 00                         		even
0001AA34                            ; =========================================================================================================================================================
0001AA34                            		include	"Level/Objects/Checkpoint/Code.asm"	; Checkpoint object
0001AA34                            ; =========================================================================================================================================================
0001AA34                            ; Mighty The Armadillo in PRISM PARADISE
0001AA34                            ; By Nat The Porcupine 2021
0001AA34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AA34                            ; Checkpoint object
0001AA34                            ; =========================================================================================================================================================
0001AA34                            		rsset	oLvlSSTs
0001AA34 =00000030                  oDongleX	rs.w	1				; Ball dongle X
0001AA34 =00000032                  oDongleY	rs.w	1				; Ball dongle Y
0001AA34 =00000034                  oDongleTime	rs.w	1				; Ball dongle timer
0001AA34 =00000036                  oDonglePar	rs.w	1				; Ball dongle parent
0001AA34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AA34                            ObjCheckpoint:
0001AA34 7000                       		moveq	#0,d0
0001AA36 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
0001AA3A 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
0001AA3E                            	nextObject
0001AA3E 3068 0004                M 	movea.w	onext(a0),a0
0001AA42 2250                     M 	move.l	oaddr(a0),a1
0001AA44 4ED1                     M 	jmp	(a1)
0001AA46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AA46                            .Index:
0001AA46 6000 0000                  		bra.w	ObjChkpoint_Init
0001AA4A 6000 0000                  		bra.w	ObjChkpoint_Main
0001AA4E 6000 0000                  		bra.w	ObjChkpoint_Animate
0001AA52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AA52                            ObjChkpoint_Init:
0001AA52 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
0001AA56                            		
0001AA56 217C 0000 0000 0010        		move.l	#Map_ObjChkpoint,oMap(a0)	; Mappings
0001AA5E 317C 057E 000E             		move.w	#$57E,oVRAM(a0)			; Tile properties
0001AA64 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0001AA6A 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
0001AA70 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
0001AA76                            	displaySprite	5,a0,a1,0			; Priority
0001AA76 317C BE82 0008           M 	move.w	#rdispinput+(5*dsize),odrawnext(a0)
0001AA7C 3278 BE8C                M 	move.w	rdispinput+dprev+(5*dsize).w,a1
0001AA80 3149 000A                M 	move.w	a1,odrawprev(a0)
0001AA84 3348 0008                M 	move.w	a0,odrawnext(a1)
0001AA88 31C8 BE8C                M 	move.w	a0,rdispinput+dprev+(5*dsize).w
0001AA8C 0C78 BE82 BE8C           M 	cmp.w	#rdispinput+(5*dsize),rdispinput+dprev+(5*dsize).w
0001AA92 6600                     M 	bne.s	.no_264
0001AA94 31C8 BE8C                M 	move.w	a0,rdispinput+dprev+(5*dsize).w
0001AA98                          M .no_264
0001AA98                            		
0001AA98 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
0001AA9C 3440                       		movea.w	d0,a2				; ''
0001AA9E 0812 0000                  		btst	#0,(a2)				; Is it already set?
0001AAA2 6600                       		bne.s	.AlreadySet			; If so, branch
0001AAA4                            
0001AAA4 1228 0024                  		move.b	oSubtype(a0),d1			; Get checkpoint ID
0001AAA8 B238 C7AE                  		cmp.b	rLastChkpoint.w,d1		; Has a later checkpoint already been hit?
0001AAAC 6E00                       		bgt.s	ObjChkpoint_Main		; If not, branch
0001AAAE                            
0001AAAE                            .AlreadySet:
0001AAAE 08D2 0000                  		bset	#0,(a2)				; Mark as set
0001AAB2 117C 0002 0020             		move.b	#2,oAni(a0)			; ''
0001AAB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AAB8                            ObjChkpoint_Main:
0001AAB8 4A38 F8D1                  		tst.b	rDebugMode.w			; Are we in debug placement mode?
0001AABC 6600 0000                  		bne.w	ObjChkpoint_Animate		; If so, branch
0001AAC0                            		
0001AAC0 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Player object
0001AAC4 1238 C7AE                  		move.b	rLastChkpoint.w,d1		; Get last checkpoint hit
0001AAC8 B228 0024                  		cmp.b	oSubtype(a0),d1			; Has a later checkpoint already been hit?
0001AACC 6400 0000                  		bhs.w	.ChkSetAnim			; If so, branch
0001AAD0                            
0001AAD0 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0001AAD4 9068 0014                  		sub.w	oXPos(a0),d0			; Get delta X from current position
0001AAD8 5040                       		addq.w	#8,d0				; Add 8
0001AADA 0C40 0010                  		cmpi.w	#$10,d0				; Is the player within horizontal boundaries?
0001AADE 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
0001AAE2 3029 0018                  		move.w	oYPos(a1),d0			; Get player's Y position
0001AAE6 9068 0018                  		sub.w	oYPos(a0),d0			; Get delta Y from current position
0001AAEA 0640 0040                  		addi.w	#$40,d0				; Add $40
0001AAEE 0C40 0068                  		cmpi.w	#$68,d0				; Is the player within vertical boundaries?
0001AAF2 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
0001AAF6                            		
0001AAF6                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
0001AAF6 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
0001AAFC                            
0001AAFC 4EB8 19B0                  		jsr	FindFreeObj.w			; Find a free object slot
0001AB00 6700                       		beq.s	.SetPoint			; If there is none, branch
0001AB02 22BC 0000 0000             		move.l	#ObjChkPoint_Dongle,oAddr(a1)	; Load the checkpoint ball dongle object
0001AB08 3368 0014 0030             		move.w	oXPos(a0),oDongleX(a1)		; Dongle X
0001AB0E 3368 0018 0032             		move.w	oYPos(a0),oDongleY(a1)		; Dongle Y
0001AB14 0469 0014 0032             		subi.w	#$14,oDongleY(a1)		; ''
0001AB1A 2368 0010 0010             		move.l	oMap(a0),oMap(a1)		; Mappings
0001AB20 3368 000E 000E             		move.w	oVRAM(a0),oVRAM(a1)		; Tile properties
0001AB26 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
0001AB2C 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
0001AB32 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
0001AB38                            	displaySprite	4,a1,a2,0			; Priority
0001AB38 337C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a1)
0001AB3E 3478 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a2
0001AB42 334A 000A                M 	move.w	a2,odrawprev(a1)
0001AB46 3549 0008                M 	move.w	a1,odrawnext(a2)
0001AB4A 31C9 BE84                M 	move.w	a1,rdispinput+dprev+(4*dsize).w
0001AB4E 0C78 BE7A BE84           M 	cmp.w	#rdispinput+(4*dsize),rdispinput+dprev+(4*dsize).w
0001AB54 6600                     M 	bne.s	.no_266
0001AB56 31C9 BE84                M 	move.w	a1,rdispinput+dprev+(4*dsize).w
0001AB5A                          M .no_266
0001AB5A 137C 0002 0010             		move.b	#2,oFrame(a1)			; Map frame
0001AB60 337C 0020 0034             		move.w	#$20,oDongleTime(a1)		; Dongle timer
0001AB66 3348 0036                  		move.w	a0,oDonglePar(a1)		; Dongle parent
0001AB6A                            
0001AB6A                            .SetPoint:
0001AB6A 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
0001AB6E 3440                       		movea.w	d0,a2				; ''
0001AB70 08D2 0000                  		bset	#0,(a2)				; Mark as set
0001AB74                            		
0001AB74 117C 0001 0020             		move.b	#1,oAni(a0)			; Use dongling animation
0001AB7A 11E8 0024 C7AE             		move.b	oSubtype(a0),rLastChkpoint.w	; Set checkpoint ID
0001AB80                            
0001AB80 5828 0025                  		addq.b	#4,oRoutine(a0)
0001AB84 4879 0000 0000             		pea	ObjChkpoint_Animate		; Animate
0001AB8A 4EF8 49FE                  		jmp	Level_SaveInfo			; Save data
0001AB8E                            		
0001AB8E                            .ChkSetAnim:
0001AB8E 5828 0025                  		addq.b	#4,oRoutine(a0)
0001AB92 4A28 0020                  		tst.b	oAni(a0)			; Are we still unset?
0001AB96 6600                       		bne.s	ObjChkpoint_Animate		; If not, branch
0001AB98 117C 0002 0020             		move.b	#2,oAni(a0)			; Use the set animation
0001AB9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001AB9E                            ObjChkpoint_Animate:
0001AB9E 43F9 0000 0000             		lea	Ani_ObjChkpoint,a1		; Animate
0001ABA4 4EB8 1C0A                  		jsr	AnimateObject.w			; ''
0001ABA8 4EF8 1FC8                  		jmp	CheckObjActive.w		; Display
0001ABAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001ABAC                            ; Ball dongle object
0001ABAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
0001ABAC                            ObjChkPoint_Dongle:
0001ABAC 5368 0034                  		subq.w	#1,oDongleTime(a0)		; Decrement timer
0001ABB0 6A00                       		bpl.s	.MoveDongle			; If it hasn't run out, branch
0001ABB2 3268 0036                  		movea.w	oDonglePar(a0),a1		; Get parent
0001ABB6 137C 0002 0020             		move.b	#2,oAni(a1)			; Set set animation for parent
0001ABBC 4229 0010                  		clr.b	oFrame(a1)			; Reset map frame for parent
0001ABC0 4EB8 19E0                  		jsr	DeleteObject.w			; Delete ourselves
0001ABC4                            	nextObject
0001ABC4 3068 0004                M 	movea.w	onext(a0),a0
0001ABC8 2250                     M 	move.l	oaddr(a0),a1
0001ABCA 4ED1                     M 	jmp	(a1)
0001ABCC                            
0001ABCC                            .MoveDongle:
0001ABCC 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
0001ABD0 0428 0010 0041             		subi.b	#$10,oAngle(a0)			; Decrement angle
0001ABD6 0400 0040                  		subi.b	#$40,d0				; Subtract $40
0001ABDA 4EB8 1308                  		jsr	CalcSine.w			; Get sine and cosine
0001ABDE C3FC 0C00                  		muls.w	#$C00,d1			; Multiply cosine with $C00
0001ABE2 4841                       		swap	d1				; Get high word
0001ABE4 D268 0030                  		add.w	oDongleX(a0),d1			; Add dongle X
0001ABE8 3141 0014                  		move.w	d1,oXPos(a0)			; Set actual X
0001ABEC C1FC 0C00                  		muls.w	#$C00,d0			; Multiply sine with $C00
0001ABF0 4840                       		swap	d0				; Get high word
0001ABF2 D068 0032                  		add.w	oDongleY(a0),d0			; Add dongle X
0001ABF6 3140 0018                  		move.w	d0,oYPos(a0)			; Set actual X
0001ABFA 4EB8 1FC8                  		jsr	CheckObjActive.w		; Display
0001ABFE                            	nextObject
0001ABFE 3068 0004                M 	movea.w	onext(a0),a0
0001AC02 2250                     M 	move.l	oaddr(a0),a1
0001AC04 4ED1                     M 	jmp	(a1)
0001AC06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AC06                            ; Data
0001AC06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AC06                            ArtKosM_Chkpoint:
0001AC06                            		incbin	"Level/Objects/Checkpoint/Art.kosm.bin"
0001AD06 00                         		even
0001AD06                            Ani_ObjChkpoint:
0001AD06 0000                       		dc.w	.Ani0-Ani_ObjChkpoint
0001AD08 0000                       		dc.w	.Ani1-Ani_ObjChkpoint
0001AD0A 0000                       		dc.w	.Ani2-Ani_ObjChkpoint
0001AD0C 0F00 FF                    .Ani0:		dc.b	$F, 0, $FF
0001AD10 00                         		even
0001AD10 0F01 FF                    .Ani1:		dc.b	$F, 1, $FF
0001AD14 00                         		even
0001AD14 0300 04FF                  .Ani2:		dc.b	3, 0, 4, $FF
0001AD18                            		even
0001AD18                            Map_ObjChkpoint:
0001AD18                            		include	"Level/Objects/Checkpoint/Mappings.asm"
0001AD18                            ; --------------------------------------------------------------------------------
0001AD18                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001AD18                            ; --------------------------------------------------------------------------------
0001AD18                            
0001AD18                            SME_JjCUP:	
0001AD18 0000 0000                  		dc.w SME_JjCUP_A-SME_JjCUP, SME_JjCUP_24-SME_JjCUP	
0001AD1C 0000 0000                  		dc.w SME_JjCUP_38-SME_JjCUP, SME_JjCUP_40-SME_JjCUP	
0001AD20 0000                       		dc.w SME_JjCUP_48-SME_JjCUP	
0001AD22 0004                       SME_JjCUP_A:	dc.b 0, 4	
0001AD24 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AD2A F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AD30 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AD36 D805 0000 FFF8             		dc.b $D8, 5, 0, 0, $FF, $F8	
0001AD3C 0003                       SME_JjCUP_24:	dc.b 0, 3	
0001AD3E E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AD44 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AD4A F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AD50 0001                       SME_JjCUP_38:	dc.b 0, 1	
0001AD52 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8	
0001AD58 0001                       SME_JjCUP_40:	dc.b 0, 1	
0001AD5A F805 2000 FFF8             		dc.b $F8, 5, $20, 0, $FF, $F8	
0001AD60 0004                       SME_JjCUP_48:	dc.b 0, 4	
0001AD62 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0001AD68 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0001AD6E F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0001AD74 D805 2000 FFF8             		dc.b $D8, 5, $20, 0, $FF, $F8	
0001AD7A                            		even
0001AD7A                            ; =========================================================================================================================================================
0001AD7A                            		include	"Level/Objects/Wall Spring/Code.asm"	; Wall spring object
0001AD7A                            ; =========================================================================================================================================================
0001AD7A                            ; Mighty The Armadillo in PRISM PARADISE
0001AD7A                            ; By Nat The Porcupine 2021
0001AD7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AD7A                            ; Wall spring object
0001AD7A                            ; =========================================================================================================================================================
0001AD7A                            ObjWallSpring:
0001AD7A 20BC 0000 0000             		move.l	#ObjWallSpring_Main,oAddr(a0)	; Next routine
0001AD80                            	;	move.l	#Map_ObjWallSpring,oMap(a0)	; Mappings
0001AD80                            	;	clr.w	oVRAM(a0)			; Tile properties
0001AD80                            	;	ori.b	#4,oRender(a0)			; Render flags
0001AD80                            	;	move.w	#rSprInput+$200,oPrio(a0)	; Priority
0001AD80                            	;	move.b	#8,oDrawW(a0)			; Sprite width
0001AD80                            	;	move.b	#$40,oDrawH(a0)			; Sprite height
0001AD80 117C 0008 002C             		move.b	#8,oColW(a0)			; Collision width
0001AD86 117C 0040 002D             		move.b	#$40,oColH(a0)			; Collision height
0001AD8C                            
0001AD8C 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001AD90 E808                       		lsr.b	#4,d0				; Get map frame
0001AD92 0200 0007                  		andi.b	#7,d0				; ''
0001AD96 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
0001AD9A 6700                       		beq.s	ObjWallSpring_Main		; If it was 0, branch
0001AD9C                            	;	move.b	#$80,oDrawH(a0)			; Larger sprite height
0001AD9C 117C 0080 002D             		move.b	#$80,oColH(a0)			; Larger collision height
0001ADA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADA2                            ObjWallSpring_Main:
0001ADA2 7208                       		moveq	#8,d1				; Width
0001ADA4 7400                       		moveq	#0,d2
0001ADA6 1428 002D                  		move.b	oColH(a0),d2			; Height
0001ADAA 3602                       		move.w	d2,d3				; ''
0001ADAC 5243                       		addq.w	#1,d3				; ''
0001ADAE 3828 0014                  		move.w	oXPos(a0),d4			; X position
0001ADB2 4EB8 441C                  		jsr	SolidObject_Always		; Make us solid
0001ADB6                            
0001ADB6 0806 0000                  		btst	#cTouchSideBit,d6		; Has Sonic touched the side of the spring?
0001ADBA 6700                       		beq.s	.Display			; If not, branch
0001ADBC 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set in air
0001ADC2 1228 0028                  		move.b	oStatus(a0),d1			; Get status
0001ADC6 3028 0014                  		move.w	oXPos(a0),d0			; Get distance between us and Sonic
0001ADCA 9069 0014                  		sub.w	oXPos(a1),d0			; ''
0001ADCE 6500                       		bcs.s	.ChkXStat			; If Sonic is towards the right of the spring, branch
0001ADD0 0A01 0001                  		eori.b	#1,d1				; Go the other way
0001ADD4                            
0001ADD4                            .ChkXStat:
0001ADD4 0201 0001                  		andi.b	#1,d1				; Has Sonic touched the front of spring?
0001ADD8 6600                       		bne.s	.Display			; If not, branch
0001ADDA 6100                       		bsr.s	.Bounce
0001ADDC                            
0001ADDC                            .Display:
0001ADDC 4EB8 1FC8                  		jsr	CheckObjActive.w		; Delete if inactive
0001ADE0                            	nextObject
0001ADE0 3068 0004                M 	movea.w	onext(a0),a0
0001ADE4 2250                     M 	move.l	oaddr(a0),a1
0001ADE6 4ED1                     M 	jmp	(a1)
0001ADE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001ADE8                            .Bounce:
0001ADE8 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is Sonic dead?
0001ADEE 6500                       		blo.s	.DoBounce			; If not, branch
0001ADF0 4E75                       		rts
0001ADF2                            
0001ADF2                            .DoBounce:
0001ADF2 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Make Sonic not hurt if he is
0001ADF8 337C F800 001C             		move.w	#-$800,oXVel(a1)		; Bounce left
0001ADFE 337C F800 001E             		move.w	#-$800,oYVel(a1)		; Bounce up
0001AE04 08E9 0000 0028             		bset	#0,oStatus(a1)			; Face left
0001AE0A 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing left?
0001AE10 6600                       		bne.s	.MoveLock			; If so, branch
0001AE12 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Face right
0001AE18 4469 001C                  		neg.w	oXVel(a1)			; Go right
0001AE1C                            
0001AE1C                            .MoveLock:
0001AE1C 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Set move lock timer
0001AE22 0829 0002 0028             		btst	#2,oStatus(a1)			; Was Sonic jumping?
0001AE28 6600                       		bne.s	.ChkNoYVel			; If so, branch
0001AE2A 4229 0020                  		clr.b	oAni(a1)			; Reset animation
0001AE2E                            
0001AE2E                            .ChkNoYVel:
0001AE2E 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0001AE32 6A00                       		bpl.s	.ChkFlip			; If Sonic should still bounce up, branch
0001AE34 4229 001E                  		clr.b	oYVel(a1)			; Stop Y velocity
0001AE38                            
0001AE38                            .ChkFlip:
0001AE38 0800 0000                  		btst	#0,d0				; Should Sonic tumble?
0001AE3C 6700                       		beq.s	.PlaySnd			; If not, branch
0001AE3E 337C 0001 003A             		move.w	#1,oFlipDir(a1)			; Set flip direction
0001AE44 137C 0001 0047             		move.b	#1,oFlipAngle(a1)		; Set flip angle
0001AE4A 4229 0020                  		clr.b	oAni(a1)			; Reset animation
0001AE4E 137C 0001 0049             		move.b	#1,oFlipRemain(a1)		; Set flips remaining
0001AE54 137C 0008 004A             		move.b	#8,oFlipSpeed(a1)		; Set flip speed
0001AE5A 0800 0001                  		btst	#1,d0				; Should Sonic do 3 flips?
0001AE5E 6600                       		bne.s	.ChkDir				; If not, branch
0001AE60 137C 0003 0049             		move.b	#3,oFlipRemain(a1)		; Do 3 flips isntead
0001AE66                            
0001AE66                            .ChkDir:
0001AE66 0829 0000 0028             		btst	#0,oStatus(a1)			; Was Sonic facing left?
0001AE6C 6700                       		beq.s	.PlaySnd			; If not, branch
0001AE6E 4429 0047                  		neg.b	oFlipAngle(a1)			; Flip the other way
0001AE72 4469 003A                  		neg.w	oFlipDir(a1)			; ''
0001AE76                            
0001AE76                            .PlaySnd:
0001AE76 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Stop pushing
0001AE7C 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
0001AE82                            		playSnd	#sSpring, 2			; Play spring sound
0001AE82 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
0001AE88 4E75                       		rts
0001AE8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE8A                            ; Data
0001AE8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AE8A                            Map_ObjWallSpring:
0001AE8A                            		include	"Level/Objects/Wall Spring/Mappings.asm"
0001AE8A                            ; --------------------------------------------------------------------------------
0001AE8A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001AE8A                            ; --------------------------------------------------------------------------------
0001AE8A                            
0001AE8A                            SME_ReVf5:	
0001AE8A 0000 0000                  		dc.w SME_ReVf5_4-SME_ReVf5, SME_ReVf5_12-SME_ReVf5	
0001AE8E 0002                       SME_ReVf5_4:	dc.b 0, 2	
0001AE90 C005 0034 FFF8             		dc.b $C0, 5, 0, $34, $FF, $F8	
0001AE96 3005 0034 FFF8             		dc.b $30, 5, 0, $34, $FF, $F8	
0001AE9C 0002                       SME_ReVf5_12:	dc.b 0, 2	
0001AE9E 8005 0034 FFF8             		dc.b $80, 5, 0, $34, $FF, $F8	
0001AEA4 7005 0034 FFF8             		dc.b $70, 5, 0, $34, $FF, $F8	
0001AEAA                            		even
0001AEAA                            		even
0001AEAA                            ; =========================================================================================================================================================
0001AEAA                            		include	"Level/Objects/Ball Mode/Code.asm"	; Ball mode switch object
0001AEAA                            ; =========================================================================================================================================================
0001AEAA                            ; Mighty The Armadillo in PRISM PARADISE
0001AEAA                            ; By Nat The Porcupine 2021
0001AEAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AEAA                            ; Ball mode enable/disable object
0001AEAA                            ; =========================================================================================================================================================
0001AEAA                            		rsset	oLvlSSTs
0001AEAA =00000030                  oBModeTouch	rs.b	1				; Touched flag
0001AEAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AEAA                            ObjBallMode:
0001AEAA                            	;	move.l	#ObjBallMode_Main,oAddr(a0)	; Next routine
0001AEAA                            	;	move.l	#Map_ObjMonitor,oMap(a0)	; Mappings
0001AEAA                            	;	clr.w	oVRAM(a0)			; Tile properties
0001AEAA                            	;	ori.b	#4,oRender(a0)			; Render flags
0001AEAA                            	;	move.w	#rSprInput+$280,oPrio(a0)	; Priority
0001AEAA                            	;	move.b	#$10,oDrawW(a0)			; Sprite width
0001AEAA                            	;	move.b	#$10,oDrawH(a0)			; Sprite height
0001AEAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AEAA                            ObjBallMode_Main:
0001AEAA 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
0001AEAE 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
0001AEB2 4EB8 1D2A                  		jsr	CheckObjInRange.w		; Is the player in range?
0001AEB6 4A40                       		tst.w	d0				; ''
0001AEB8 6700                       		beq.s	.NotTouched			; If not, branch
0001AEBA                            
0001AEBA 08AA 0002 000C             		bclr	#2,oFlags(a2)
0001AEC0                            		
0001AEC0 4A28 0024                  		tst.b	oSubtype(a0)			; Should we force Sonic out of ball mode?
0001AEC4 6B00                       		bmi.s	.NoBallMode			; If so, branch
0001AEC6 6600                       		bne.s	.BallMode			; Branch if we should force Sonic in to ball mode
0001AEC8                            
0001AEC8 4A28 0030                  		tst.b	oBModeTouch(a0)			; Have we already been touched?
0001AECC 6600                       		bne.s	.End				; If so, branch
0001AECE 50E8 0030                  		st	oBModeTouch(a0)			; Touched
0001AED2                            
0001AED2 462A 004B                  		not.b	oBallMode(a2)			; Switch ball mode for Sonic
0001AED6 6700                       		beq.s	.End				; If it's not set, branch
0001AED8                            
0001AED8                            .MakeSonicRoll:
0001AED8 2248                       		movea.l	a0,a1				; Save a0
0001AEDA 204A                       		movea.l	a2,a0				; Make Sonic roll
0001AEDC 4EB9 0000 BAD2             		jsr	ObjMighty_DoRoll			; ''
0001AEE2 2049                       		movea.l	a1,a0				; Restore a0
0001AEE4                            	nextObject
0001AEE4 3068 0004                M 	movea.w	onext(a0),a0
0001AEE8 2250                     M 	move.l	oaddr(a0),a1
0001AEEA 4ED1                     M 	jmp	(a1)
0001AEEC                            
0001AEEC                            .NotTouched:
0001AEEC 4228 0030                  		clr.b	oBModeTouch(a0)			; Not touched
0001AEF0                            	nextObject
0001AEF0 3068 0004                M 	movea.w	onext(a0),a0
0001AEF4 2250                     M 	move.l	oaddr(a0),a1
0001AEF6 4ED1                     M 	jmp	(a1)
0001AEF8                            
0001AEF8                            .BallMode:
0001AEF8 50EA 004B                  		st	oBallMode(a2)			; Get in to ball mode
0001AEFC 60DA                       		bra.s	.MakeSonicRoll			; ''
0001AEFE                            
0001AEFE                            .NoBallMode:
0001AEFE 422A 004B                  		clr.b	oBallMode(a2)			; Get out of ball mode
0001AF02                            
0001AF02                            .End:
0001AF02                            	nextObject
0001AF02 3068 0004                M 	movea.w	onext(a0),a0
0001AF06 2250                     M 	move.l	oaddr(a0),a1
0001AF08 4ED1                     M 	jmp	(a1)
0001AF0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF0A                            .RangeData:
0001AF0A FFF0 0020                  		dc.w	-$10, $20
0001AF0E FFF0 0020                  		dc.w	-$10, $20
0001AF12                            ; =========================================================================================================================================================
0001AF12                            		include	"Level/Objects/Bumper/Code.asm"		; Bumper object
0001AF12                            ; =========================================================================================================================================================
0001AF12                            ; Mighty The Armadillo in PRISM PARADISE
0001AF12                            ; By Nat The Porcupine 2021
0001AF12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF12                            ; Water surface object
0001AF12                            ; =========================================================================================================================================================
0001AF12                            		rsset	oLvlSSTs
0001AF12                            
0001AF12                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF12                            ObjBumper:
0001AF12 20BC 0000 0000             		move.l	#ObjBumperMain,oAddr(a0)	; Next routine
0001AF18 217C 0000 0000 0010        		move.l	#Map_ObjBumper,oMap(a0)		; Mappings
0001AF20 317C 035B 000E             		move.w	#$35B,oVRAM(a0)			; Tile properties
0001AF26 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
0001AF2C                            	displaySprite	1,a0,a1,0			; Priority
0001AF2C 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
0001AF32 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
0001AF36 3149 000A                M 	move.w	a1,odrawprev(a0)
0001AF3A 3348 0008                M 	move.w	a0,odrawnext(a1)
0001AF3E 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
0001AF42 0C78 BE62 BE6C           M 	cmp.w	#rdispinput+(1*dsize),rdispinput+dprev+(1*dsize).w
0001AF48 6600                     M 	bne.s	.no_274
0001AF4A 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
0001AF4E                          M .no_274
0001AF4E 7210                       		moveq	#$10,d1
0001AF50 1141 0017                  		move.b	d1,oDrawW(a0)
0001AF54 1141 002C                  		move.b	d1,oColW(a0)
0001AF58 1141 001B                  		move.b	d1,oDrawH(a0)
0001AF5C 1141 002D                  		move.b	d1,oColH(a0)
0001AF60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001AF60                            ObjBumperMain:
0001AF60 4A38 F8D1                  		tst.b	rDebugMode.w
0001AF64 6600 0000                  		bne.w	.Display
0001AF68                            
0001AF68 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
0001AF6C 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
0001AF70 0C2A 000C 0025             		cmpi.b	#$C,oRoutine(a2)
0001AF76 6400 0000                  		bcc.w	.Display
0001AF7A 4EB8 1D2A                  		jsr	CheckObjInRange.w		; Is the player in range?
0001AF7E 4A40                       		tst.w	d0				; ''
0001AF80 6700                       		beq.s	.Display			; If not, branch
0001AF82                            
0001AF82 3228 0014                  		move.w	oXPos(a0),d1
0001AF86 3428 0018                  		move.w	oYPos(a0),d2
0001AF8A 926A 0014                  		sub.w	oXPos(a2),d1
0001AF8E 946A 0018                  		sub.w	oYPos(a2),d2
0001AF92 4EB8 171A                  		jsr	CalcArcTan.w
0001AF96 1238 C759                  		move.b	(rFrameCnt+3).w,d1
0001AF9A 0241 0003                  		andi.w	#3,d1
0001AF9E D041                       		add.w	d1,d0
0001AFA0 4EB8 1308                  		jsr	CalcSine.w
0001AFA4 C3FC F900                  		muls.w	#-$700,d1
0001AFA8 E081                       		asr.l	#8,d1
0001AFAA 3541 001C                  		move.w	d1,oXVel(a2)
0001AFAE C1FC F900                  		muls.w	#-$700,d0
0001AFB2 E080                       		asr.l	#8,d0
0001AFB4 3540 001E                  		move.w	d0,oYVel(a2)
0001AFB8 0C2A 0008 0025             		cmpi.b	#8,oRoutine(a2)
0001AFBE 6600                       		bne.s	.NotHurt
0001AFC0 157C 0002 0020             		move.b	#2,oAni(a2)
0001AFC6 5A6A 0018                  		addq.w	#5,oYPos(a2)
0001AFCA 157C 000E 002D             		move.b	#$E,oColH(a2)
0001AFD0 157C 0007 002C             		move.b	#7,oColW(a2)
0001AFD6 08EA 0002 0028             		bset	#2,oStatus(a2)
0001AFDC                            
0001AFDC                            .NotHurt:
0001AFDC 157C 0004 0025             		move.b	#4,oRoutine(a2)
0001AFE2 08EA 0001 0028             		bset	#1,oStatus(a2)
0001AFE8 08AA 0005 0028             		bclr	#5,oStatus(a2)
0001AFEE 422A 0040                  		clr.b	oJumping(a2)
0001AFF2 117C 0001 0020             		move.b	#1,oAni(a0)
0001AFF8                            		playSnd	#sBumper, 2
0001AFF8 11FC 0091 C4BD           M 	move.b	#sbumper,(mqueue+((2)-1)).w
0001AFFE                            
0001AFFE                            .Display:
0001AFFE 43FA 0000                  		lea	Ani_ObjBumper(pc),a1
0001B002 4EB8 1C0A                  		jsr	AnimateObject.w
0001B006 4EB8 1FC8                  		jsr	CheckObjActive.w		; Display
0001B00A 4EB8 49EC                  		jsr	AddToColResponse		; Allow collision
0001B00E                            	nextObject
0001B00E 3068 0004                M 	movea.w	onext(a0),a0
0001B012 2250                     M 	move.l	oaddr(a0),a1
0001B014 4ED1                     M 	jmp	(a1)
0001B016                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B016                            .RangeData:
0001B016 FFE8 0030                  		dc.w	-$18, $30
0001B01A FFE8 0030                  		dc.w	-$18, $30
0001B01E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B01E                            ; Data
0001B01E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B01E                            Map_ObjBumper:
0001B01E                            		include	"Level/Objects/Bumper/Mappings.asm"
0001B01E                            ; --------------------------------------------------------------------------------
0001B01E                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0001B01E                            ; --------------------------------------------------------------------------------
0001B01E                            
0001B01E                            SME_3VuTU:	
0001B01E 0000 0000                  		dc.w SME_3VuTU_6-SME_3VuTU, SME_3VuTU_E-SME_3VuTU	
0001B022 0000                       		dc.w SME_3VuTU_16-SME_3VuTU	
0001B024 0001                       SME_3VuTU_6:	dc.b 0, 1	
0001B026 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0001B02C 0001                       SME_3VuTU_E:	dc.b 0, 1	
0001B02E F40A 0029 FFF4             		dc.b $F4, $A, 0, $29, $FF, $F4	
0001B034 0004                       SME_3VuTU_16:	dc.b 0, 4	
0001B036 EC0F 0010 FFEC             		dc.b $EC, $F, 0, $10, $FF, $EC	
0001B03C EC03 0020 000C             		dc.b $EC, 3, 0, $20, 0, $C	
0001B042 0C0C 0024 FFEC             		dc.b $C, $C, 0, $24, $FF, $EC	
0001B048 0C00 0028 000C             		dc.b $C, 0, 0, $28, 0, $C	
0001B04E                            		even
0001B04E                            		even
0001B04E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B04E                            Ani_ObjBumper:
0001B04E 0000                       		dc.w	.Ani0-Ani_ObjBumper
0001B050 0000                       		dc.w	.Ani1-Ani_ObjBumper
0001B052 0500 FF00                  .Ani0:		dc.b	5, 0, $FF, 0
0001B056 0501 0201 02FD 00          .Ani1:		dc.b	5, 1, 2, 1, 2, $FD, 0
0001B05E 00                         		even
0001B05E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B05E                            ArtKosM_Bumper:
0001B05E                            		incbin	"Level/Objects/Bumper/Art.kosm.bin"
0001B32C 00                         		even
0001B32C                            ; =========================================================================================================================================================
0001B32C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32C                            ; Unused/Temporary
0001B32C                            ;		include	"Level/Objects/Slicer/Code.asm"		; Slicer object
0001B32C                            ;		include	"Level/Objects/Shellcracker/Code.asm"	; Shellcracker object
0001B32C                            ;		include	"Level/Objects/Asteron/Code.asm"	; Asteron object
0001B32C                            ;		include	"Level/Objects/Boss - WFZ/Code.asm"	; WFZ boss object
0001B32C                            ;		include	"Level/Objects/Harpoon/Code.asm"	; Harpoon object
0001B32C                            ;		include	"Level/Objects/CNZ Barrel/Code.asm"	; CNZ barrel object
0001B32C                            ;		include	"Level/Objects/Diamond/Code.asm"	; Diamond object
0001B32C                            ;		include	"Level/Objects/Orbinaut/Code.asm"	; Orbinaut object
0001B32C                            ; =========================================================================================================================================================
0001B32C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32C                            ; Ending
0001B32C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32C                            		include	"Ending/Main.asm"
0001B32C                            ; =========================================================================================================================================================
0001B32C                            ; Mighty The Armadillo in PRISM PARADISE
0001B32C                            ; By Nat The Porcupine 2021
0001B32C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32C                            ; End splash screen
0001B32C                            ; =========================================================================================================================================================
0001B32C                            
0001B32C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32C                            Ending:
0001B32C 60FE                       		bra.s	Ending
0001B32E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32E                            ;		playSnd	#Mus_Stop, 1			; Stop sound
0001B32E                            ;
0001B32E                            ;		intsOff					; Disable interrupts
0001B32E                            ;
0001B32E                            ;		lea	VDP_CTRL,a5
0001B32E                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
0001B32E                            ;		move.w	#$8134,(a5)			; $8134 - Disable display, enable V-INT, enable DMA, V28
0001B32E                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
0001B32E                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
0001B32E                            ;		move.w	#$9001,(a5)			; $9001 - 64x32 cell plane area
0001B32E                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
0001B32E                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
0001B32E                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
0001B32E                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
0001B32E                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
0001B32E                            ;
0001B32E                            ;		jsr	ClearScreen.w			; Clear screen
0001B32E                            ;
0001B32E                            ;		lea	MapEni_End(pc),a0		; Decompress background mappings
0001B32E                            ;		lea	rBuffer,a1			; Decompress into RAM
0001B32E                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
0001B32E                            ;		jsr	EniDec.w			; Decompress!
0001B32E                            ;
0001B32E                            ;		lea	rBuffer,a1			; Load mappings
0001B32E                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
0001B32E                            ;		moveq	#$27,d1				; $28x$1C tiles
0001B32E                            ;		moveq	#$1B,d2				; ''
0001B32E                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
0001B32E                            ;		jsr	LoadPlaneMap.w			; Load the map
0001B32E                            ;
0001B32E                            ;		lea	ArtKosM_End,a1			; Load background art
0001B32E                            ;		move.w	#$20,d2				; ''
0001B32E                            ;		jsr	QueueKosMData.w			; ''
0001B32E                            ;
0001B32E                            ;.WaitPLCs:
0001B32E                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
0001B32E                            ;		jsr	ProcessKos.w			; Process Kosinski queue
0001B32E                            ;		jsr	VSync_Routine.w			; V-SYNC
0001B32E                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
0001B32E                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
0001B32E                            ;		bne.s	.WaitPLCs			; If so, branch
0001B32E                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
0001B32E                            ;		jsr	VSync_Routine.w			; V-SYNC
0001B32E                            ;
0001B32E                            ;		lea	SampleList+$F0,a3
0001B32E                            ;		jsr	PlayDAC1
0001B32E                            ;
0001B32E                            ;		lea	Pal_End(pc),a0			; Load palette to target buffer
0001B32E                            ;		move.w	#(Pal_End_End-Pal_End)>>1-1,d0	; ''
0001B32E                            ;		jsr	LoadPalette.w			; ''
0001B32E                            ;
0001B32E                            ;		displayOn
0001B32E                            ;
0001B32E                            ;.Loop:
0001B32E                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
0001B32E                            ;		jsr	VSync_Routine.w			; ''
0001B32E                            ;		bra.s	.Loop
0001B32E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32E                            ; Art
0001B32E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32E                            ;ArtKosM_End:
0001B32E                            ;		incbin	"Ending/Data/Art - Background.kosm.bin"
0001B32E                            ;		even
0001B32E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32E                            ; Plane mappings
0001B32E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32E                            ;MapEni_End:
0001B32E                            ;		incbin	"Ending/Data/Map - Background.eni.bin"
0001B32E                            ;		even
0001B32E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32E                            ; Palette
0001B32E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32E                            ;Pal_End:
0001B32E                            ;		incbin	"Ending/Data/Palette.pal.bin"
0001B32E                            ;Pal_End_End:
0001B32E                            ;		even
0001B32E                            ; =========================================================================================================================================================
0001B32E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32E                            ; Horizontal interrupt for palette swapping (for water)
0001B32E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B32E                            HInt_Water:
0001B32E                            		intsOff					; Disable interrupts
0001B32E 007C 0700                M 	ori	#$700,sr
0001B332                            
0001B332 4A38 C749                  		tst.b	rHIntFlag.w			; Is the H-INT allowed to run?
0001B336 6700                       		beq.s	.End				; If not, branch
0001B338 4238 C749                  		clr.b	rHIntFlag.w			; Clear the H-INT flag
0001B33C                            
0001B33C                            		push.l	a0-a1				; Save registers
0001B33C 48E7 00C0                M 	movem.l	a0-a1,-(sp)
0001B340                            
0001B340 43F9 00C0 0000             		lea	VDP_DATA,a1			; VDP data port
0001B346 337C 8AFF 0004             		move.w	#$8AFF,4(a1)			; Don't do any more H-INT calls for the rest of the frame
0001B34C 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette
0001B350                            		vdpCmd	move.l, 0, CRAM, WRITE, 4(a1)	; Set VDP command
0001B350 237C C000 0000 0004      M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),4(a1)
0001B358                            		rept	32
0001B358                            			move.l	(a0)+,(a1)		; Tranfer palette
0001B358                            		endr
0001B358 2298                     M 	move.l	(a0)+,(a1)
0001B35A 2298                     M 	move.l	(a0)+,(a1)
0001B35C 2298                     M 	move.l	(a0)+,(a1)
0001B35E 2298                     M 	move.l	(a0)+,(a1)
0001B360 2298                     M 	move.l	(a0)+,(a1)
0001B362 2298                     M 	move.l	(a0)+,(a1)
0001B364 2298                     M 	move.l	(a0)+,(a1)
0001B366 2298                     M 	move.l	(a0)+,(a1)
0001B368 2298                     M 	move.l	(a0)+,(a1)
0001B36A 2298                     M 	move.l	(a0)+,(a1)
0001B36C 2298                     M 	move.l	(a0)+,(a1)
0001B36E 2298                     M 	move.l	(a0)+,(a1)
0001B370 2298                     M 	move.l	(a0)+,(a1)
0001B372 2298                     M 	move.l	(a0)+,(a1)
0001B374 2298                     M 	move.l	(a0)+,(a1)
0001B376 2298                     M 	move.l	(a0)+,(a1)
0001B378 2298                     M 	move.l	(a0)+,(a1)
0001B37A 2298                     M 	move.l	(a0)+,(a1)
0001B37C 2298                     M 	move.l	(a0)+,(a1)
0001B37E 2298                     M 	move.l	(a0)+,(a1)
0001B380 2298                     M 	move.l	(a0)+,(a1)
0001B382 2298                     M 	move.l	(a0)+,(a1)
0001B384 2298                     M 	move.l	(a0)+,(a1)
0001B386 2298                     M 	move.l	(a0)+,(a1)
0001B388 2298                     M 	move.l	(a0)+,(a1)
0001B38A 2298                     M 	move.l	(a0)+,(a1)
0001B38C 2298                     M 	move.l	(a0)+,(a1)
0001B38E 2298                     M 	move.l	(a0)+,(a1)
0001B390 2298                     M 	move.l	(a0)+,(a1)
0001B392 2298                     M 	move.l	(a0)+,(a1)
0001B394 2298                     M 	move.l	(a0)+,(a1)
0001B396 2298                     M 	move.l	(a0)+,(a1)
0001B398                            		pop.l	a0-a1				; Restore registers
0001B398 4CDF 0300                M 	movem.l	(sp)+,a0-a1
0001B39C                            		
0001B39C 4A38 C75D                  		tst.b	rHIntUpdates.w		; Do we need to do level updates in here?
0001B3A0 6600                       		bne.s	.DoUpdates			; If so, branch
0001B3A2                            
0001B3A2                            .End:
0001B3A2 4E73                       		rte
0001B3A4                            
0001B3A4                            .DoUpdates:
0001B3A4 4238 C75D                  		clr.b	rHIntUpdates.w		; Clear the update flag
0001B3A8                            		push.l	d0-a6				; Save registers
0001B3A8 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
0001B3AC 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0001B3B2 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
0001B3B6 4EB8 3FCC                  		jsr	Level_UpdateHUD			; Update the HUD
0001B3BA 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
0001B3C0                            		pop.l	d0-a6				; Restore registers
0001B3C0 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0001B3C4 4E73                       		rte
0001B3C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B3C6                            ; Sound driver
0001B3C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001B3C6                            		include	"../amps/code/68k.asm"
0001B3C6                            	opt oz+					; enable zero-offset optimization
0001B3C6                            	opt l.					; local lables are dots
0001B3C6                            	opt ae+					; enable automatic even's
0001B3C6                            
0001B3C6                            	include "../amps/code/routines.asm"	; include macro'd routines
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Note timout handler macro
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dNoteToutHandler	macro
0001B3C6                            		tst.b	cNoteTimeCur(a5)	; check if timer is 0
0001B3C6                            		beq.s	.endt			; if is, do not timeout
0001B3C6                            		subq.b	#1,cNoteTimeCur(a5)	; decrease delay by 1
0001B3C6                            		bne.s	.endt			; if still not 0, branch
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Note timout handler macro for DAC
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dNoteToutDAC	macro
0001B3C6                            	dNoteToutHandler			; include timeout handler
0001B3C6                            		moveq	#0,d0			; play stop sample
0001B3C6                            		bra.w	dNoteOnDAC2		; ''
0001B3C6                            .endt
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Note timout handler macro for FM
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dNoteToutFM	macro
0001B3C6                            	dNoteToutHandler			; include timeout handler
0001B3C6                            		bset	#cfbRest,(a5)		; set track to resting
0001B3C6                            		bsr.w	dKeyOffFM		; key off FM
0001B3C6                            		bra.\0	.next			; jump to next track
0001B3C6                            .endt
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Note timout handler macro for PSG
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dNoteToutPSG	macro
0001B3C6                            	dNoteToutHandler			; include timeout handler
0001B3C6                            		bset	#cfbRest,(a5)		; set track to resting
0001B3C6                            		bsr.w	dMutePSGmus		; mute PSG channel
0001B3C6                            		bra.s	.next			; jump to next track
0001B3C6                            .endt
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Macro for calculating the current frequency (without modulation) into d6.
0001B3C6                            ; Used if user wants to add extra pitch effects such as pitch slides.
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dCalcFreq	macro
0001B3C6                            		move.b	cDetune(a5),d6		; get detune value to d6
0001B3C6                            		ext.w	d6			; extend to word
0001B3C6                            		add.w	cFreq(a5),d6		; add channel base frequency to it
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Macro for generating frequency modulation code
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dModulate	macro jump,loop,type
0001B3C6                            		btst	#cfbMod,(a5)		; check if modulation is active
0001B3C6                            		beq.s	.noret			; if not, update volume and return
0001B3C6                            		tst.b	cModDelay(a5)		; check if there is delay left
0001B3C6                            		beq.s	.started		; if not, modulate!
0001B3C6                            		subq.b	#1,cModDelay(a5)	; decrease delay
0001B3C6                            
0001B3C6                            .noret
0001B3C6                            	if narg>0
0001B3C6                            		if narg=3
0001B3C6                            			if type<2
0001B3C6                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B3C6                            				beq.s	.noupdatevol		; if not, skip
0001B3C6                            				jsr	dUpdateVolFM(pc)	; update FM volume
0001B3C6                            			.noupdatevol:
0001B3C6                            			endif
0001B3C6                            			if type>=4
0001B3C6                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B3C6                            				beq.s	.noupdatevol		; if not, skip
0001B3C6                            				jsr	dUpdateVolDAC(pc)	; update DAC volume
0001B3C6                            			.noupdatevol:
0001B3C6                            			endif
0001B3C6                            			if \type<>5
0001B3C6                            				dbf	d7,\loop		; loop for all channels
0001B3C6                            			endif
0001B3C6                            		endif
0001B3C6                            		bra.w	\jump			; jump to next routine
0001B3C6                            	else
0001B3C6                            		bra.s	.endm			; jump to the next .endm routine
0001B3C6                            	endif
0001B3C6                            
0001B3C6                            .started
0001B3C6                            		subq.b	#1,cModSpeed(a5)	; decrease modulation speed counter
0001B3C6                            		bne.s	.noret			; if there's still delay left, update vol and return
0001B3C6                            		movea.l	cMod(a5),a1		; get modulation data offset to a1
0001B3C6                            		move.b	1(a1),cModSpeed(a5)	; reset modulation speed counter
0001B3C6                            
0001B3C6                            		tst.b	cModCount(a5)		; check if this was the last step
0001B3C6                            		bne.s	.norev			; if was not, do not reverse
0001B3C6                            		move.b	3(a1),cModCount(a5)	; reset steps counter
0001B3C6                            		neg.b	cModStep(a5)		; negate step amount
0001B3C6                            
0001B3C6                            .norev
0001B3C6                            		subq.b	#1,cModCount(a5)	; decrease step counter
0001B3C6                            		move.b	cModStep(a5),d5		; get step offset into d5
0001B3C6                            		ext.w	d5			; extend to word
0001B3C6                            
0001B3C6                            		add.w	cModFreq(a5),d5		; add modulation frequency to it
0001B3C6                            		move.w	d5,cModFreq(a5)		; save as the modulation frequency
0001B3C6                            		add.w	d5,d6			; add to channel base frequency
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Macro for processing the tracker
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dDoTracker	macro
0001B3C6                            		movea.l	cData(a5),a4		; grab tracker address
0001B3C6                            	if safe=1
0001B3C6                            		AMPS_Debug_TrackUpd		; check if this address is valid
0001B3C6                            	endif
0001B3C6                            
0001B3C6                            .data
0001B3C6                            		moveq	#0,d5
0001B3C6                            		move.b	(a4)+,d5		; get a byte from tracker
0001B3C6                            		cmpi.b	#$E0,d5			; is this a command?
0001B3C6                            		blo.s	.notcomm		; if not, continue
0001B3C6                            		jsr	dCommands(pc)		; run the condition flag
0001B3C6                            		bra.s	.data			; for most commands, use this branch to loop
0001B3C6                            		bra.s	.next			; however, for example sStop will make us return here.
0001B3C6                            .notcomm
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Macro for playing a note, and setting up for it (software updates only)
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dProcNote	macro sfx, psg
0001B3C6                            		move.l	a4,cData(a5)		; save tracker address
0001B3C6                            		move.b	cLastDur(a5),cDuration(a5); copy stored duration
0001B3C6                            		btst	#cfbHold,(a5)		; check if we are holding
0001B3C6                            		bne.s	.endpn			; if we are, branch
0001B3C6                            
0001B3C6                            	if sfx=0
0001B3C6                            		move.b	cNoteTimeMain(a5),cNoteTimeCur(a5); copy note timeout value
0001B3C6                            	endif
0001B3C6                            
0001B3C6                            	if psg<>0
0001B3C6                            		clr.b	cEnvPos(a5)		; clear envelope position if PSG channel
0001B3C6                            	endif
0001B3C6                            
0001B3C6                            		btst	#cfbMod,(a5)		; check if modulation is enabled
0001B3C6                            		beq.s	.endpn			; if not, branch
0001B3C6                            
0001B3C6                            		movea.l	cMod(a5),a1		; get modulation data address
0001B3C6                            		move.b	(a1)+,cModDelay(a5)	; copy delay
0001B3C6                            		move.b	(a1)+,cModSpeed(a5)	; copy speed
0001B3C6                            		move.b	(a1)+,cModStep(a5)	; copy step offset
0001B3C6                            
0001B3C6                            		move.b	(a1),d0			; get number of steps
0001B3C6                            		lsr.b	#1,d0			; halve it
0001B3C6                            		move.b	d0,cModCount(a5)	; save as the current number of steps
0001B3C6                            		clr.w	cModFreq(a5)		; clear frequency offset
0001B3C6                            .endpn
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Macro for processing a note in DAC channel
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dTrackNoteDAC	macro
0001B3C6                            		btst	#cfbMode,(a5)		; check if we are on pitch mode
0001B3C6                            		bne.s	.pitch			; if so, load pitch
0001B3C6                            		move.b	d5,cSample(a5)		; else, save as a sample
0001B3C6                            		bra.s	.cont
0001B3C6                            
0001B3C6                            .pitch
0001B3C6                            		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001B3C6                            		bne.s	.noprest		; branch if note wasnt $80 (rest)
0001B3C6                            		moveq	#0,d0			; play stop sample
0001B3C6                            		bsr.w	dNoteOnDAC2		; ''
0001B3C6                            		moveq	#-$80,d6		; tell the code we are resting
0001B3C6                            		bra.s	.cont
0001B3C6                            
0001B3C6                            .noprest
0001B3C6                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001B3C6                            		add.w	d5,d5			; double offset (each entry is a word)
0001B3C6                            		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001B3C6                            		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001B3C6                            
0001B3C6                            .cont
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Macro for doing keying-on FM channel
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dKeyOnFM	macro
0001B3C6                            		btst	#cfbHold,(a5)		; check if note is held
0001B3C6                            		bne.s	.k			; if so, do not note on
0001B3C6                            		btst	#cfbRest,(a5)		; check if channel is resting
0001B3C6                            		bne.s	.k			; if so, do not note on
0001B3C6                            	if narg=0
0001B3C6                            		btst	#cfbInt,(a5)		; check if overridden by sfx
0001B3C6                            		bne.s	.k			; if so, do not note on
0001B3C6                            	endif
0001B3C6                            
0001B3C6                            		moveq	#$28,d0			; YM command: Key on
0001B3C6                            		move.b	cType(a5),d1		; get channel type bits
0001B3C6                            		ori.b	#$F0,d1			; turn all FM operators on
0001B3C6                            		bsr.w	WriteYM_Pt1		; send note-on event
0001B3C6                            .k
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Macro for processing a note in PSG channel
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            dGetFreqPSG	macro
0001B3C6                            		subi.b	#$81,d5			; sub $81 from the note (notes start at $80)
0001B3C6                            		bhs.s	.norest			; branch if note wasnt $80 (rest)
0001B3C6                            		bset	#cfbRest,(a5)		; set channel to resting
0001B3C6                            		move.w	#-1,cFreq(a5)		; set invalid PSG frequency
0001B3C6                            		jsr	dMutePSGmus(pc)		; mute this PSG channel
0001B3C6                            		bra.s	.freqgot
0001B3C6                            
0001B3C6                            .norest
0001B3C6                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001B3C6                            		andi.w	#$7F,d5			; keep within $80 notes
0001B3C6                            		add.w	d5,d5			; double offset (each entry is a word)
0001B3C6                            		move.w	(a6,d5.w),cFreq(a5)	; load and save the requested frequency
0001B3C6                            
0001B3C6                            	if safe=1
0001B3C6                            		AMPS_Debug_NotePSG		; check if the note was valid
0001B3C6                            	endif
0001B3C6                            .freqgot
0001B3C6                                endm
0001B3C6                            ; ===========================================================================
0001B3C6                            	include "../amps/code/debug.asm"	; debug data blob
0001B3C6                            ; ===========================================================================
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            ; Routine for loading the Dual PCM driver into Z80 RAM
0001B3C6                            ; ---------------------------------------------------------------------------
0001B3C6                            
0001B3C6                            LoadDualPCM:
0001B3C6 33FC 0100 00A1 1100        		move.w	#$0100,$A11100		; request Z80 stop
0001B3CE 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001B3D6                            
0001B3D6 41F9 0000 0000             		lea	DualPCM,a0		; load Dual PCM address into a0
0001B3DC 43F9 00A0 0000             		lea	dZ80,a1			; load Z80 RAM address into a1
0001B3E2 323C 0000                  		move.w	#DualPCM_sz-1,d1	; get lenght counter for dbf into d1
0001B3E6                            
0001B3E6                            .z80
0001B3E6 0839 0000 00A1 1100        		btst	#$00,$A11100		; check if Z80 has stopped
0001B3EE 66F6                       		bne.s	.z80			; if not, wait more
0001B3F0                            
0001B3F0                            .load
0001B3F0 12D8                       		move.b	(a0)+,(a1)+		; copy the Dual PCM driver into Z80 RAM
0001B3F2 51C9 FFFC                  		dbf	d1,.load		; write every single byte
0001B3F6                            
0001B3F6 41FA 0000                  		lea	SampleList(pc),a0	; load address for the stop sample data into a0
0001B3FA 43F9 0000 0000             		lea	dZ80+MuteSample,a1	; load address in Dual PCM to write into a1
0001B400                            
0001B400                            	rept 6
0001B400                            		move.b	(a0)+,(a1)+		; copy all required data
0001B400                            	endr
0001B400 12D8                     M 	move.b	(a0)+,(a1)+
0001B402 12D8                     M 	move.b	(a0)+,(a1)+
0001B404 12D8                     M 	move.b	(a0)+,(a1)+
0001B406 12D8                     M 	move.b	(a0)+,(a1)+
0001B408 12D8                     M 	move.b	(a0)+,(a1)+
0001B40A 12D8                     M 	move.b	(a0)+,(a1)+
0001B40C                            
0001B40C 7002                       		moveq	#2,d0			; set flush timer for 60hz systems
0001B40E 0838 0006 C744             		btst	#6,rHWVersion.w	; is this a PAL Mega Drive?
0001B414 6700                       		beq.s	.ntsc			; if not, branch
0001B416 7003                       		moveq	#3,d0			; set flush timer for 50hz systems
0001B418                            .ntsc
0001B418 13C0 0000 0000             		move.b	d0,dZ80+YM_FlushTimer+2	; save flush timer
0001B41E                            
0001B41E 33FC 0000 00A1 1200        		move.w	#$0000,$A11200		; request Z80 reset
0001B426 727F                       		moveq	#$7F,d1			; wait for a little bit
0001B428 51C9 FFFE                  		dbf	d1,*			; we can't check for reset, so we need to delay
0001B42C                            
0001B42C 33FC 0000 00A1 1100        		move.w	#$0000,$A11100		; enable Z80
0001B434 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001B43C 4E75                       		rts
0001B43E                            ; ---------------------------------------------------------------------------
0001B43E                            ; Play DAC
0001B43E                            ; ---------------------------------------------------------------------------
0001B43E                            
0001B43E                            PlayDAC2:
0001B43E 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001B444                            	StopZ80					; wait for Z80 to stop
0001B444 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B44C                          M 	waitz80stop
0001B44C 0839 0000 00A1 1100      M .wait_284:	btst	#0,z80_bus_req
0001B454 66F6                     M 	bne.s	.wait_284
0001B456                            	rept 12
0001B456                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B456                            	endr
0001B456 12DB                     M 	move.b	(a3)+,(a1)+
0001B458 12DB                     M 	move.b	(a3)+,(a1)+
0001B45A 12DB                     M 	move.b	(a3)+,(a1)+
0001B45C 12DB                     M 	move.b	(a3)+,(a1)+
0001B45E 12DB                     M 	move.b	(a3)+,(a1)+
0001B460 12DB                     M 	move.b	(a3)+,(a1)+
0001B462 12DB                     M 	move.b	(a3)+,(a1)+
0001B464 12DB                     M 	move.b	(a3)+,(a1)+
0001B466 12DB                     M 	move.b	(a3)+,(a1)+
0001B468 12DB                     M 	move.b	(a3)+,(a1)+
0001B46A 12DB                     M 	move.b	(a3)+,(a1)+
0001B46C 12DB                     M 	move.b	(a3)+,(a1)+
0001B46E 101B                       		move.b	(a3)+,d0
0001B470 5200                       		addq.b	#1,d0
0001B472 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchHigh+1
0001B478 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM2_PitchLow+1
0001B47E 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001B486                            
0001B486 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001B48E                            	StartZ80				; enable Z80 execution
0001B48E 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B496 4E75                       		rts
0001B498                            
0001B498                            ; ---------------------------------------------------------------------------
0001B498                            
0001B498                            PlayDAC1:
0001B498 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1
0001B49E                            	StopZ80					; wait for Z80 to stop
0001B49E 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B4A6                          M 	waitz80stop
0001B4A6 0839 0000 00A1 1100      M .wait_287:	btst	#0,z80_bus_req
0001B4AE 66F6                     M 	bne.s	.wait_287
0001B4B0                            	rept 12
0001B4B0                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B4B0                            	endr
0001B4B0 12DB                     M 	move.b	(a3)+,(a1)+
0001B4B2 12DB                     M 	move.b	(a3)+,(a1)+
0001B4B4 12DB                     M 	move.b	(a3)+,(a1)+
0001B4B6 12DB                     M 	move.b	(a3)+,(a1)+
0001B4B8 12DB                     M 	move.b	(a3)+,(a1)+
0001B4BA 12DB                     M 	move.b	(a3)+,(a1)+
0001B4BC 12DB                     M 	move.b	(a3)+,(a1)+
0001B4BE 12DB                     M 	move.b	(a3)+,(a1)+
0001B4C0 12DB                     M 	move.b	(a3)+,(a1)+
0001B4C2 12DB                     M 	move.b	(a3)+,(a1)+
0001B4C4 12DB                     M 	move.b	(a3)+,(a1)+
0001B4C6 12DB                     M 	move.b	(a3)+,(a1)+
0001B4C8 101B                       		move.b	(a3)+,d0
0001B4CA 5200                       		addq.b	#1,d0
0001B4CC 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchHigh+1
0001B4D2 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM1_PitchLow+1
0001B4D8 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001B4E0                            
0001B4E0 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001B4E8                            	StartZ80				; enable Z80 execution
0001B4E8 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B4F0 4E75                       		rts
0001B4F2                            ; ===========================================================================
0001B4F2                            ; ---------------------------------------------------------------------------
0001B4F2                            ; Handle Dual PCM YM Cue correctly
0001B4F2                            ; ---------------------------------------------------------------------------
0001B4F2                            
0001B4F2                            UpdateAMPS:
0001B4F2                            	StopZ80					; wait for Z80 to stop
0001B4F2 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B4FA                          M 	waitz80stop
0001B4FA 0839 0000 00A1 1100      M .wait_290:	btst	#0,z80_bus_req
0001B502 66F6                     M 	bne.s	.wait_290
0001B504 1039 0000 0000             		move.b	dZ80+YM_Buffer,d0	; load current cue buffer in use
0001B50A                            	StartZ80				; enable Z80 execution
0001B50A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B512                            
0001B512 207C 0000 0000             		move.l	#dZ80+YM_Buffer1,a0	; set the cue address to buffer 1
0001B518 4A00                       		tst.b	d0			; check buffer to use
0001B51A 6600                       		bne.s	.gotbuffer		; if Z80 is reading buffer 2, branch
0001B51C D0FC 0000                  		add.w	#YM_Buffer2-YM_Buffer1,a0; set the cue address to buffer 2
0001B520                            
0001B520                            .gotbuffer
0001B520 6100                       		bsr.s	dUpdateAllAMPS		; process the driver
0001B522                            
0001B522                            	StopZ80					; wait for Z80 to stop
0001B522 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B52A                          M 	waitz80stop
0001B52A 0839 0000 00A1 1100      M .wait_293:	btst	#0,z80_bus_req
0001B532 66F6                     M 	bne.s	.wait_293
0001B534 50D0                       		st	(a0)			; make sure cue is marked as completed
0001B536                            	StartZ80				; enable Z80 execution
0001B536 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B53E                            
0001B53E                            dPaused:
0001B53E 4E75                       		rts
0001B540                            ; ===========================================================================
0001B540                            ; ---------------------------------------------------------------------------
0001B540                            ; Main routine for updating the AMPS driver
0001B540                            ; ---------------------------------------------------------------------------
0001B540                            
0001B540                            dUpdateAllAMPS:
0001B540 4EBA 0000                  		jsr	dPlaySnd(pc)		; check if any music needs playing
0001B544 4A38 C4A6                  		tst.b	mFlags.w		; is music paused?
0001B548 6BF4                       		bmi.s	dPaused			; if yes, branch
0001B54A                            ; ---------------------------------------------------------------------------
0001B54A                            ; This is the new fading feature I created, to make custom fading
0001B54A                            ; types easier to program. You can define series of 3 bytes, each
0001B54A                            ; representing FM, PSG and DAC volumes. Each group of 3 is executed
0001B54A                            ; once per frame. If the first value in a frame is a command flag,
0001B54A                            ; instead its code is executed. Additionally, no fade program may
0001B54A                            ; appear before ROM offset $10000, or else it will never be executed.
0001B54A                            ; ---------------------------------------------------------------------------
0001B54A                            
0001B54A 4A38 C4B5                  .notempo	tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001B54E 6700                       		beq.s	.chkregion		; branch if not
0001B550                            
0001B550 2278 C4B4                  		move.l	mFadeAddr.w,a1		; get the fade porogram address to a1
0001B554 56B8 C4B4                  		addq.l	#3,mFadeAddr.w		; set the fade address to next group
0001B558                            
0001B558 7220                       		moveq	#(1<<cfbVol),d1		; prepare volume update to d1
0001B55A 7000                       		moveq	#0,d0
0001B55C 1019                       		move.b	(a1)+,d0		; get FM/command byte from fade data
0001B55E 6A00                       		bpl.s	.nofadeend		; branch if this is not a command
0001B560                            
0001B560 45FA 0000                  		lea	dFadeCommands-$80(pc),a2; load fade commands pointer table to a2
0001B564 4EB2 0000                  		jsr	(a2,d0.w)		; run the fade command code
0001B568 4238 C4B5                  		clr.b	mFadeAddr+1.w		; mark the fade program as completed
0001B56C 6000                       		bra.s	.chkregion		; go check the region
0001B56E                            
0001B56E                            .nofadeend
0001B56E B038 C4B4                  		cmp.b	mMasterVolFM.w,d0	; check if volume did not change
0001B572 6700                       		beq.s	.fadedac		; if did not, branch
0001B574 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save the new volume
0001B578 4EBA 0000                  		jsr	dReqVolUpFM(pc)		; go request volume update for FM
0001B57C                            
0001B57C                            .fadedac
0001B57C 1019                       		move.b	(a1)+,d0		; get DAC volume byte from fade data
0001B57E B038 C4C0                  		cmp.b	mMasterVolDAC.w,d0	; check if volume did not change
0001B582 6700                       		beq.s	.fadepsg		; if did not, branch
0001B584 11C0 C4C0                  		move.b	d0,mMasterVolDAC.w	; save new volume
0001B588                            
0001B588 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001B588                            	rept Mus_DAC				; do for all music DAC channels
0001B588                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B588                            .ch =		.ch+cSize			; go to next channel
0001B588                            	endr
0001B588 8338 C4C4                M 	or.b	d1,.ch.w
0001B58C =FFFFC4F0                M .ch	=	.ch+csize
0001B58C 8338 C4F0                M 	or.b	d1,.ch.w
0001B590 =FFFFC51C                M .ch	=	.ch+csize
0001B590 8338 C67C                  		or.b	d1,mSFXDAC1.w		; tell SFX DAC1 to update its volume
0001B594                            
0001B594                            .fadepsg
0001B594 1019                       		move.b	(a1)+,d0		; get PSG volume byte from fade data
0001B596 B038 C4BF                  		cmp.b	mMasterVolPSG.w,d0	; check if volume did not change
0001B59A 6700                       		beq.s	.chkregion		; if did not, branch
0001B59C 11C0 C4BF                  		move.b	d0,mMasterVolPSG.w	; save new volume
0001B5A0                            
0001B5A0 =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001B5A0                            	rept Mus_PSG				; do for all music PSG channels
0001B5A0                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B5A0                            .ch =		.ch+cSize			; go to next channel
0001B5A0                            	endr
0001B5A0 8338 C5F8                M 	or.b	d1,.ch.w
0001B5A4 =FFFFC624                M .ch	=	.ch+csize
0001B5A4 8338 C624                M 	or.b	d1,.ch.w
0001B5A8 =FFFFC650                M .ch	=	.ch+csize
0001B5A8 8338 C650                M 	or.b	d1,.ch.w
0001B5AC =FFFFC67C                M .ch	=	.ch+csize
0001B5AC                            
0001B5AC =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001B5AC                            	rept SFX_PSG				; do for all SFX PSG channels
0001B5AC                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001B5AC                            .ch =		.ch+cSizeSFX			; go to next channel
0001B5AC                            	endr
0001B5AC 8338 C6EC                M 	or.b	d1,.ch.w
0001B5B0 =FFFFC708                M .ch	=	.ch+csizesfx
0001B5B0 8338 C708                M 	or.b	d1,.ch.w
0001B5B4 =FFFFC724                M .ch	=	.ch+csizesfx
0001B5B4 8338 C724                M 	or.b	d1,.ch.w
0001B5B8 =FFFFC740                M .ch	=	.ch+csizesfx
0001B5B8                            ; ---------------------------------------------------------------------------
0001B5B8                            ; Since PAL Mega Drive's run slower than NTSC, if we want the music to
0001B5B8                            ; sound consistent, we need to run the sound driver 1.2 times as fast
0001B5B8                            ; on PAL systems. This will cause issues with some songs that rely on
0001B5B8                            ; game engine to seem "in sync". Because of that, I added a flag to
0001B5B8                            ; disable the PAL fix (much like in Sonic 2's driver). Unlike the fix
0001B5B8                            ; in SMPS drivers (and Sonic 3 and above), this fix will make the music
0001B5B8                            ; play at the exact right speed, instead of slightly too slow.
0001B5B8                            ; ---------------------------------------------------------------------------
0001B5B8                            
0001B5B8 0838 0006 C744             .chkregion	btst	#6,rHWVersion.w	; is this PAL system?
0001B5BE 6700                       		beq.s	.driver			; if not, branch
0001B5C0 5338 C4A7                  		subq.b	#1,mCtrPal.w		; decrease PAL frame counter
0001B5C4 6E00                       		bgt.s	.driver			; if hasn't become 0 (or lower!), branch
0001B5C6                            
0001B5C6 0838 0003 C4A6             		btst	#mfbNoPAL,mFlags.w	; check if we have disabled the PAL fix
0001B5CC 6600                       		bne.s	.nofix			; if yes, run music and SFX
0001B5CE 6100                       		bsr.s	.nosfx			; run the sound driver
0001B5D0                            
0001B5D0                            .nofix
0001B5D0 11FC 0005 C4A7             		move.b	#6-1,mCtrPal.w		; reset counter
0001B5D6                            .driver
0001B5D6 6100 0000                  		bsr.w	dAMPSdoSFX		; run SFX this time
0001B5DA                            
0001B5DA                            .nosfx		; continue to run sound driver again
0001B5DA                            ; ---------------------------------------------------------------------------
0001B5DA                            ; There are 2 methods of handling tempo adjustments in SMPS,
0001B5DA                            ; overflow (where a value is added to the accumulator, and when it
0001B5DA                            ; range overflows, tick of delay is added), and counter (where a
0001B5DA                            ; counter is copied to the tempo, which is then decreased each frame,
0001B5DA                            ; until it becomes 0, after which a tick of delay is added). AMPS
0001B5DA                            ; supports these both too, because there is no single right answer,
0001B5DA                            ; and users may prefer one over the other. The overflow method is
0001B5DA                            ; really good for low values, as it provides very fine control over
0001B5DA                            ; the tempo, but at high ranges it gets worse. Meanwhile the counter
0001B5DA                            ; method isn't as good for small values, but for large value it works
0001B5DA                            ; better. You may choose this setting in the macro.asm file,
0001B5DA                            ; ---------------------------------------------------------------------------
0001B5DA                            
0001B5DA 1038 C4BA                  		move.b	mTempo.w,d0		; get tempo to d0
0001B5DE D138 C4BB                  		add.b	d0,mTempoCur.w		; add to accumulator
0001B5E2 6400                       		bcc.s	dAMPSdoAll		; if carry clear, branch
0001B5E4                            
0001B5E4                            
0001B5E4 =FFFFC4D0                  .ch =	mDAC1+cDuration				; start at DAC1 duration
0001B5E4                            	rept Mus_Ch				; loop through all music channels
0001B5E4                            		addq.b	#1,.ch.w		; add 1 to duration
0001B5E4                            .ch =		.ch+cSize			; go to next channel
0001B5E4                            	endr
0001B5E4 5238 C4D0                M 	addq.b	#1,.ch.w
0001B5E8 =FFFFC4FC                M .ch	=	.ch+csize
0001B5E8 5238 C4FC                M 	addq.b	#1,.ch.w
0001B5EC =FFFFC528                M .ch	=	.ch+csize
0001B5EC 5238 C528                M 	addq.b	#1,.ch.w
0001B5F0 =FFFFC554                M .ch	=	.ch+csize
0001B5F0 5238 C554                M 	addq.b	#1,.ch.w
0001B5F4 =FFFFC580                M .ch	=	.ch+csize
0001B5F4 5238 C580                M 	addq.b	#1,.ch.w
0001B5F8 =FFFFC5AC                M .ch	=	.ch+csize
0001B5F8 5238 C5AC                M 	addq.b	#1,.ch.w
0001B5FC =FFFFC5D8                M .ch	=	.ch+csize
0001B5FC 5238 C5D8                M 	addq.b	#1,.ch.w
0001B600 =FFFFC604                M .ch	=	.ch+csize
0001B600 5238 C604                M 	addq.b	#1,.ch.w
0001B604 =FFFFC630                M .ch	=	.ch+csize
0001B604 5238 C630                M 	addq.b	#1,.ch.w
0001B608 =FFFFC65C                M .ch	=	.ch+csize
0001B608 5238 C65C                M 	addq.b	#1,.ch.w
0001B60C =FFFFC688                M .ch	=	.ch+csize
0001B60C                            ; ===========================================================================
0001B60C                            ; ---------------------------------------------------------------------------
0001B60C                            ; Process music DAC channels
0001B60C                            ; ---------------------------------------------------------------------------
0001B60C                            
0001B60C                            dAMPSdoAll:
0001B60C 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001B610 4BF8 C498                  		lea	mDAC1-cSize.w,a5	; get DAC1 channel RAM address into a5
0001B614 7E01                       		moveq	#Mus_DAC-1,d7		; get total number of DAC channels to d7
0001B616                            
0001B616                            dAMPSdoDAC:
0001B616 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel (first time its mDAC1!)
0001B61A 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001B61C 6A00 0000                  		bpl.w	.next			; if not, branch
0001B620 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001B624 6700 0000                  		beq.w	.update			; if timed out, update channel
0001B628                            	dNoteToutDAC	 			; handle DAC-specific note timeout behavior
0001B628                          M 	dnotetouthandler
0001B628 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001B62C 6700                     M 	beq.s	.endt
0001B62E 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001B632 6600                     M 	bne.s	.endt
0001B634 7000                     M 	moveq	#0,d0
0001B636 6000 0000                M 	bra.w	dnoteondac2
0001B63A                          M .endt
0001B63A                            
0001B63A                            	dCalcFreq				; calculate channel base frequency
0001B63A 1C2D 0007                M 	move.b	cdetune(a5),d6
0001B63E 4886                     M 	ext.w	d6
0001B640 DC6D 000E                M 	add.w	cfreq(a5),d6
0001B644                            	dModulate dAMPSdoFM, dAMPSdoDAC, 4	; run modulation code
0001B644 0815 0003                M 	btst	#cfbmod,(a5)
0001B648 6700                     M 	beq.s	.noret
0001B64A 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001B64E 6700                     M 	beq.s	.started
0001B650 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001B654                          M .noret
0001B654 0895 0005                M 	bclr	#cfbvol,(a5)
0001B658 6700                     M 	beq.s	.noupdatevol
0001B65A 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001B65E                          M 	.noupdatevol:
0001B65E 51CF FFB6                M 	dbf	d7,dampsdodac
0001B662 6000 0000                M 	bra.w	dampsdofm
0001B666                          M .started
0001B666 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001B66A 66E8                     M 	bne.s	.noret
0001B66C 226D 0010                M 	movea.l	cmod(a5),a1
0001B670 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001B676 4A2D 0018                M 	tst.b	cmodcount(a5)
0001B67A 6600                     M 	bne.s	.norev
0001B67C 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001B682 442D 0017                M 	neg.b	cmodstep(a5)
0001B686                          M .norev
0001B686 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001B68A 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001B68E 4885                     M 	ext.w	d5
0001B690 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001B694 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001B698 DC45                     M 	add.w	d5,d6
0001B69A 6100 0000                  		bsr.w	dUpdateFreqDAC		; if frequency needs changing, do it
0001B69E                            
0001B69E 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B6A2 6700                       		beq.s	.next			; if not, skip
0001B6A4 6100 0000                  		bsr.w	dUpdateVolDAC		; update DAC volume
0001B6A8                            
0001B6A8                            .next
0001B6A8 51CF FF6C                  		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001B6AC 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process music FM channels
0001B6B0                            
0001B6B0                            .update
0001B6B0 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001B6B4                            	dDoTracker				; process tracker
0001B6B4 286D 0002                M 	movea.l	cdata(a5),a4
0001B6B8                          M .data
0001B6B8 7A00                     M 	moveq	#0,d5
0001B6BA 1A1C                     M 	move.b	(a4)+,d5
0001B6BC 0C05 00E0                M 	cmpi.b	#$e0,d5
0001B6C0 6500                     M 	blo.s	.notcomm
0001B6C2 4EBA 0000                M 	jsr	dcommands(pc)
0001B6C6 60F0                     M 	bra.s	.data
0001B6C8 60DE                     M 	bra.s	.next
0001B6CA                          M .notcomm
0001B6CA 7C00                       		moveq	#0,d6			; clear rest flag
0001B6CC 4A05                       		tst.b	d5			; check if note is being played
0001B6CE 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001B6D0                            
0001B6D0                            	dTrackNoteDAC				; calculate frequency or update sample
0001B6D0 0815 0000                M 	btst	#cfbmode,(a5)
0001B6D4 6600                     M 	bne.s	.pitch
0001B6D6 1B45 000B                M 	move.b	d5,csample(a5)
0001B6DA 6000                     M 	bra.s	.cont
0001B6DC                          M .pitch
0001B6DC 0405 0080                M 	subi.b	#$80,d5
0001B6E0 6600                     M 	bne.s	.noprest
0001B6E2 7000                     M 	moveq	#0,d0
0001B6E4 6100 0000                M 	bsr.w	dnoteondac2
0001B6E8 7C80                     M 	moveq	#-$80,d6
0001B6EA 6000                     M 	bra.s	.cont
0001B6EC                          M .noprest
0001B6EC DA2D 0008                M 	add.b	cpitch(a5),d5
0001B6F0 DA45                     M 	add.w	d5,d5
0001B6F2 43FA 0000                M 	lea	dfreqdac(pc),a1
0001B6F6 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001B6FC                          M .cont
0001B6FC 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001B6FE 6A00                       		bpl.s	.timer			; if yes, handle timer
0001B700 534C                       		subq.w	#1,a4			; else, undo the increment
0001B702 6000                       		bra.s	.pcnote			; do not calculate duration
0001B704                            
0001B704                            .timer
0001B704 4EBA 0000                  		jsr	dCalcDuration(pc)	; calculate duration
0001B708                            .pcnote
0001B708                            	dProcNote 0, 0				; reset necessary channel memory
0001B708 2B4C 0002                M 	move.l	a4,cdata(a5)
0001B70C 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001B712 0815 0002                M 	btst	#cfbhold,(a5)
0001B716 6600                     M 	bne.s	.endpn
0001B718 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001B71E 0815 0003                M 	btst	#cfbmod,(a5)
0001B722 6700                     M 	beq.s	.endpn
0001B724 226D 0010                M 	movea.l	cmod(a5),a1
0001B728 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001B72C 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001B730 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001B734 1011                     M 	move.b	(a1),d0
0001B736 E208                     M 	lsr.b	#1,d0
0001B738 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001B73C 426D 0014                M 	clr.w	cmodfreq(a5)
0001B740                          M .endpn
0001B740                            
0001B740 4A06                       		tst.b	d6			; check if channel was resting
0001B742 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001B744 6100                       		bsr.s	dNoteOnDAC		; do hardware note-on behavior
0001B746                            
0001B746 51CF FECE                  .noplay		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001B74A 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process FM channels
0001B74E                            ; ===========================================================================
0001B74E                            ; ---------------------------------------------------------------------------
0001B74E                            ; Write DAC sample information to Dual PCM
0001B74E                            ; ---------------------------------------------------------------------------
0001B74E                            
0001B74E                            dNoteOnDAC2:
0001B74E 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B752 6700                       		beq.s	dNoteOnDAC3		; if not, process note
0001B754 4E75                       		rts
0001B756                            
0001B756                            dNoteOnDAC:
0001B756 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B75A 6600                       		bne.s	locret_dNoteOnDAC4	; if so, do not note on or update frequency
0001B75C                            
0001B75C 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001B75E 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001B762 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001B766 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001B76A 6600 0000                  		bne.w	dUpdateFreqOffDAC2	; if so, only update frequency
0001B76E                            
0001B76E                            dNoteOnDAC3:
0001B76E E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001B770 47F6 0000                  		lea	(a6,d0.w),a3		; get sample data to a3
0001B774                            
0001B774 487A 0000                  		pea	dUpdateFreqOffDAC(pc)	; update frequency after loading sample
0001B778 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001B77E 6700                       		beq.s	dNoteWriteDAC1		; if is, branch
0001B780                            ; ---------------------------------------------------------------------------
0001B780                            ; This code is for updating the note to Dual PCM. We have tracker commands
0001B780                            ; for also playing notes on DAC channels, which is why the code seems a
0001B780                            ; little weird.
0001B780                            ; ---------------------------------------------------------------------------
0001B780                            
0001B780                            dNoteWriteDAC2:
0001B780 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001B786 45F9 0000 0000             		lea	dZ80+PCM2_NewRET,a2	; ''
0001B78C 6000                       		bra.s	dNoteOnDAC4
0001B78E                            
0001B78E                            dNoteWriteDAC1:
0001B78E                            
0001B78E 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 2
0001B794 45F9 0000 0000             		lea	dZ80+PCM1_NewRET,a2	; ''
0001B79A                            
0001B79A                            dNoteOnDAC4:
0001B79A                            	StopZ80					; wait for Z80 to stop
0001B79A 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B7A2                          M 	waitz80stop
0001B7A2 0839 0000 00A1 1100      M .wait_303:	btst	#0,z80_bus_req
0001B7AA 66F6                     M 	bne.s	.wait_303
0001B7AC                            	rept 12
0001B7AC                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001B7AC                            	endr
0001B7AC 12DB                     M 	move.b	(a3)+,(a1)+
0001B7AE 12DB                     M 	move.b	(a3)+,(a1)+
0001B7B0 12DB                     M 	move.b	(a3)+,(a1)+
0001B7B2 12DB                     M 	move.b	(a3)+,(a1)+
0001B7B4 12DB                     M 	move.b	(a3)+,(a1)+
0001B7B6 12DB                     M 	move.b	(a3)+,(a1)+
0001B7B8 12DB                     M 	move.b	(a3)+,(a1)+
0001B7BA 12DB                     M 	move.b	(a3)+,(a1)+
0001B7BC 12DB                     M 	move.b	(a3)+,(a1)+
0001B7BE 12DB                     M 	move.b	(a3)+,(a1)+
0001B7C0 12DB                     M 	move.b	(a3)+,(a1)+
0001B7C2 12DB                     M 	move.b	(a3)+,(a1)+
0001B7C4                            
0001B7C4 14BC 00DA                  		move.b	#$DA,(a2)		; activate sample switch (change instruction)
0001B7C8                            	StartZ80				; enable Z80 execution
0001B7C8 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B7D0                            
0001B7D0                            locret_dNoteOnDAC4:
0001B7D0 4E75                       		rts
0001B7D2                            ; ===========================================================================
0001B7D2                            ; ---------------------------------------------------------------------------
0001B7D2                            ; Write DAC frequency to Dual PCM
0001B7D2                            ; ---------------------------------------------------------------------------
0001B7D2                            
0001B7D2                            dUpdateFreqOffDAC2:
0001B7D2 E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001B7D4 47F6 000C                  		lea	$0C(a6,d0.w),a3		; get sample pitch to a3
0001B7D8                            
0001B7D8                            dUpdateFreqOffDAC:
0001B7D8 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001B7DC DC5B                       		add.w	(a3)+,d6		; add sample frequency offset to d6
0001B7DE                            
0001B7DE 102D 0007                  		move.b	cDetune(a5),d0		; get detune value
0001B7E2 4880                       		ext.w	d0			; extend to word
0001B7E4 DC40                       		add.w	d0,d6			; add it to d6
0001B7E6                            
0001B7E6 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001B7EA 6700                       		beq.s	dUpdateFreqDAC3		; if not, branch
0001B7EC DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001B7F0 6000                       		bra.s	dUpdateFreqDAC3
0001B7F2                            
0001B7F2                            dUpdateFreqDAC:
0001B7F2 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B7F6 6600                       		bne.s	locret_UpdFreqDAC	; if so, branch
0001B7F8                            
0001B7F8                            dUpdateFreqDAC2:
0001B7F8 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001B7FA 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001B7FE 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001B802 E948                       		lsl.w	#4,d0			; multiply ID by $10 (size of each entry)
0001B804 DC76 000C                  		add.w	$0C(a6,d0.w),d6		; add sample frequency offset to d6
0001B808                            
0001B808                            dUpdateFreqDAC3:
0001B808                            
0001B808 1006                       		move.b	d6,d0			; copy the frequency to d0
0001B80A E04E                       		lsr.w	#8,d6			; get the upper byte to the lower byte
0001B80C 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if DAC1
0001B812 6700                       		beq.s	dFreqDAC1		; if is, branch
0001B814                            
0001B814                            	StopZ80					; wait for Z80 to stop
0001B814 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B81C                          M 	waitz80stop
0001B81C 0839 0000 00A1 1100      M .wait_306:	btst	#0,z80_bus_req
0001B824 66F6                     M 	bne.s	.wait_306
0001B826 13C6 0000 0000             		move.b	d6,dZ80+PCM2_PitchHigh+1
0001B82C 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchLow+1
0001B832 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001B83A                            	StartZ80				; enable Z80 execution
0001B83A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B842                            
0001B842                            locret_UpdFreqDAC;
0001B842 4E75                       		rts
0001B844                            
0001B844                            dFreqDAC1:
0001B844                            	StopZ80					; wait for Z80 to stop
0001B844 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B84C                          M 	waitz80stop
0001B84C 0839 0000 00A1 1100      M .wait_309:	btst	#0,z80_bus_req
0001B854 66F6                     M 	bne.s	.wait_309
0001B856 13C6 0000 0000             		move.b	d6,dZ80+PCM1_PitchHigh+1
0001B85C 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchLow+1
0001B862 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001B86A                            	StartZ80				; enable Z80 execution
0001B86A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B872 4E75                       		rts
0001B874                            ; ===========================================================================
0001B874                            ; ---------------------------------------------------------------------------
0001B874                            ; Routine to multiply duration by tick rate
0001B874                            ; We actually use a dbf loop instead of mulu, because 2 rounds
0001B874                            ; around the loop will be faster than a single mulu instruction
0001B874                            ; ---------------------------------------------------------------------------
0001B874                            
0001B874                            dCalcDuration:
0001B874 7000                       		moveq	#0,d0			; clear duration
0001B876 7200                       		moveq	#0,d1			; clear upper bytes (for dbf)
0001B878 122D 000A                  		move.b	cTick(a5),d1		; get tick multiplier to d1
0001B87C                            
0001B87C D005                       .multiply	add.b	d5,d0			; add duration value to d0
0001B87E 51C9 FFFC                  		dbf	d1,.multiply		; multiply by tick rate
0001B882                            
0001B882 1B40 000D                  		move.b	d0,cLastDur(a5)		; save as the new duration
0001B886 4E75                       		rts				; get copied to duration by later code
0001B888                            ; ===========================================================================
0001B888                            ; ---------------------------------------------------------------------------
0001B888                            ; Process SFX DAC channels
0001B888                            ; ---------------------------------------------------------------------------
0001B888                            
0001B888                            dAMPSdoSFX:
0001B888 4BF8 C660                  		lea	mSFXDAC1-cSizeSFX.w,a5	; get SFX DAC1 channel RAM address into a5
0001B88C                            
0001B88C                            dAMPSdoDACSFX:
0001B88C DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001B890 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001B892 6A00                       		bpl.s	.next			; if not, branch
0001B894                            
0001B894 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001B898 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001B89C 6700 0000                  		beq.w	.update			; if timed out, update channel
0001B8A0                            
0001B8A0                            	dCalcFreq				; calculate channel base frequency
0001B8A0 1C2D 0007                M 	move.b	cdetune(a5),d6
0001B8A4 4886                     M 	ext.w	d6
0001B8A6 DC6D 000E                M 	add.w	cfreq(a5),d6
0001B8AA                            	dModulate dAMPSdoFMSFX, dAMPSdoDAC, 5	; run modulation code
0001B8AA 0815 0003                M 	btst	#cfbmod,(a5)
0001B8AE 6700                     M 	beq.s	.noret
0001B8B0 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001B8B4 6700                     M 	beq.s	.started
0001B8B6 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001B8BA                          M .noret
0001B8BA 0895 0005                M 	bclr	#cfbvol,(a5)
0001B8BE 6700                     M 	beq.s	.noupdatevol
0001B8C0 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001B8C4                          M 	.noupdatevol:
0001B8C4 6000 0000                M 	bra.w	dampsdofmsfx
0001B8C8                          M .started
0001B8C8 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001B8CC 66EC                     M 	bne.s	.noret
0001B8CE 226D 0010                M 	movea.l	cmod(a5),a1
0001B8D2 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001B8D8 4A2D 0018                M 	tst.b	cmodcount(a5)
0001B8DC 6600                     M 	bne.s	.norev
0001B8DE 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001B8E4 442D 0017                M 	neg.b	cmodstep(a5)
0001B8E8                          M .norev
0001B8E8 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001B8EC 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001B8F0 4885                     M 	ext.w	d5
0001B8F2 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001B8F6 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001B8FA DC45                     M 	add.w	d5,d6
0001B8FC 6100 FEFA                  		bsr.w	dUpdateFreqDAC2		; if frequency needs changing, do it
0001B900                            
0001B900 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001B904 6700                       		beq.s	.next			; if not, skip
0001B906 6100 0000                  		bsr.w	dUpdateVolDAC2		; update DAC volume
0001B90A                            
0001B90A                            .next
0001B90A 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001B90E                            
0001B90E                            .update
0001B90E 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001B912                            	dDoTracker				; process tracker
0001B912 286D 0002                M 	movea.l	cdata(a5),a4
0001B916                          M .data
0001B916 7A00                     M 	moveq	#0,d5
0001B918 1A1C                     M 	move.b	(a4)+,d5
0001B91A 0C05 00E0                M 	cmpi.b	#$e0,d5
0001B91E 6500                     M 	blo.s	.notcomm
0001B920 4EBA 0000                M 	jsr	dcommands(pc)
0001B924 60F0                     M 	bra.s	.data
0001B926 60E2                     M 	bra.s	.next
0001B928                          M .notcomm
0001B928 7C00                       		moveq	#0,d6			; clear rest flag
0001B92A 4A05                       		tst.b	d5			; check if note is being played
0001B92C 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001B92E                            
0001B92E                            	dTrackNoteDAC				; calculate frequency or update sample
0001B92E 0815 0000                M 	btst	#cfbmode,(a5)
0001B932 6600                     M 	bne.s	.pitch
0001B934 1B45 000B                M 	move.b	d5,csample(a5)
0001B938 6000                     M 	bra.s	.cont
0001B93A                          M .pitch
0001B93A 0405 0080                M 	subi.b	#$80,d5
0001B93E 6600                     M 	bne.s	.noprest
0001B940 7000                     M 	moveq	#0,d0
0001B942 6100 FE0A                M 	bsr.w	dnoteondac2
0001B946 7C80                     M 	moveq	#-$80,d6
0001B948 6000                     M 	bra.s	.cont
0001B94A                          M .noprest
0001B94A DA2D 0008                M 	add.b	cpitch(a5),d5
0001B94E DA45                     M 	add.w	d5,d5
0001B950 43FA 0000                M 	lea	dfreqdac(pc),a1
0001B954 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001B95A                          M .cont
0001B95A 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001B95C 6A00                       		bpl.s	.timer			; if yes, handle timer
0001B95E 534C                       		subq.w	#1,a4			; else, undo the increment
0001B960 6000                       		bra.s	.pcnote			; do not calculate duration
0001B962                            
0001B962                            .timer
0001B962 4EBA FF10                  		jsr	dCalcDuration(pc)	; calculate duration
0001B966                            .pcnote
0001B966                            	dProcNote 1, 0				; reset necessary channel memory
0001B966 2B4C 0002                M 	move.l	a4,cdata(a5)
0001B96A 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001B970 0815 0002                M 	btst	#cfbhold,(a5)
0001B974 6600                     M 	bne.s	.endpn
0001B976 0815 0003                M 	btst	#cfbmod,(a5)
0001B97A 6700                     M 	beq.s	.endpn
0001B97C 226D 0010                M 	movea.l	cmod(a5),a1
0001B980 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001B984 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001B988 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001B98C 1011                     M 	move.b	(a1),d0
0001B98E E208                     M 	lsr.b	#1,d0
0001B990 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001B994 426D 0014                M 	clr.w	cmodfreq(a5)
0001B998                          M .endpn
0001B998 4A06                       		tst.b	d6			; check if channel was resting
0001B99A 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001B99C 6100 FDB8                  		bsr.w	dNoteOnDAC		; do hardware note-on behavior
0001B9A0                            
0001B9A0                            .noplay
0001B9A0 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001B9A4                            ; ===========================================================================
0001B9A4                            ; ---------------------------------------------------------------------------
0001B9A4                            ; Write DAC volume to Dual PCM
0001B9A4                            ; ---------------------------------------------------------------------------
0001B9A4                            
0001B9A4                            dUpdateVolDAC:
0001B9A4 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001B9A8 6600                       		bne.s	locret_VolDAC		; if yes, do not update
0001B9AA                            
0001B9AA                            dUpdateVolDAC2:
0001B9AA 162D 0009                  		move.b	cVolume(a5),d3		; get channel volume to d3
0001B9AE D638 C4C0                  		add.b	mMasterVolDAC.w,d3	; add master volume to it
0001B9B2 6A00                       		bpl.s	.gotvol			; if positive (in range), branch
0001B9B4 7680                       		moveq	#$FFFFFF80,d3		; force volume to mute ($80 is the last valid volume)
0001B9B6                            
0001B9B6                            .gotvol
0001B9B6                            	StopZ80					; wait for Z80 to stop
0001B9B6 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001B9BE                          M 	waitz80stop
0001B9BE 0839 0000 00A1 1100      M .wait_317:	btst	#0,z80_bus_req
0001B9C6 66F6                     M 	bne.s	.wait_317
0001B9C8 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM_ChangeVolume; set volume change flag
0001B9D0                            
0001B9D0 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001B9D6 6700                       		beq.s	.dac1			; if is, branch
0001B9D8 13C3 0000 0000             		move.b	d3,dZ80+PCM2_Volume+1	; save volume for PCM 1
0001B9DE                            	StartZ80				; enable Z80 execution
0001B9DE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B9E6 4E75                       		rts
0001B9E8                            
0001B9E8                            .dac1
0001B9E8 13C3 0000 0000             		move.b	d3,dZ80+PCM1_Volume+1	; save volume for PCM 2
0001B9EE                            	StartZ80				; enable Z80 execution
0001B9EE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001B9F6                            
0001B9F6                            locret_VolDAC:
0001B9F6 4E75                       		rts
0001B9F8                            ; ===========================================================================
0001B9F8                            ; ---------------------------------------------------------------------------
0001B9F8                            ; Routine for unpausing the sound driver
0001B9F8                            ; ---------------------------------------------------------------------------
0001B9F8                            
0001B9F8                            dPlaySnd_Unpause:
0001B9F8 08B8 0007 C4A6             		bclr	#mfbPaused,mFlags.w	; unpause music
0001B9FE 67F6                       		beq.s	locret_VolDAC		; if was already unpaused, skip
0001BA00                            ; ---------------------------------------------------------------------------
0001BA00                            ; The following code will reset the panning values for each running
0001BA00                            ; channel. It also makes sure that the channel is not interrupted
0001BA00                            ; by sound effects, and that each running sound effect channel gets
0001BA00                            ; updated. We do not handle key on's, since that could potentially
0001BA00                            ; cause issues if notes are half-done. The next time tracker plays
0001BA00                            ; notes, they start being audible again.
0001BA00                            ; ---------------------------------------------------------------------------
0001BA00                            
0001BA00 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001BA04 7804                       		moveq	#Mus_FM-1,d4		; load the number of music FM channels to d4
0001BA06 762C                       		moveq	#cSize,d3		; get the size of each music channel to d3
0001BA08                            
0001BA08                            .musloop
0001BA08 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001BA0A 6A00                       		bpl.s	.skipmus		; if not, do not update
0001BA0C 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001BA10 6600                       		bne.s	.skipmus		; if is, do not update
0001BA12                            
0001BA12 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001BA14 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001BA18 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001BA1C                            
0001BA1C                            .skipmus
0001BA1C DAC3                       		adda.w	d3,a5			; go to next channel
0001BA1E 51CC FFE8                  		dbf	d4,.musloop		; repeat for all music FM channels
0001BA22                            
0001BA22 4BF8 C698                  		lea	mSFXFM3.w,a5		; start from SFX FM1 channel
0001BA26 7802                       		moveq	#SFX_FM-1,d4		; load the number of SFX FM channels to d4
0001BA28 761C                       		moveq	#cSizeSFX,d3		; get the size of each SFX channel to d3
0001BA2A                            
0001BA2A                            .sfxloop
0001BA2A 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001BA2C 6A00                       		bpl.s	.skipsfx		; if not, do not update
0001BA2E                            
0001BA2E 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001BA30 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001BA34 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001BA38                            
0001BA38                            .skipsfx
0001BA38 DAC3                       		adda.w  d3,a5			; go to next channel
0001BA3A 51CC FFEE                  		dbf     d4,.sfxloop		; repeat for all SFX FM channels
0001BA3E                            ; ---------------------------------------------------------------------------
0001BA3E                            ; Since the DAC channels have or based panning behavior, we need this
0001BA3E                            ; piece of code to update its panning
0001BA3E                            ; ---------------------------------------------------------------------------
0001BA3E                            
0001BA3E 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001BA42 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001BA48 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001BA4A 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001BA4E                            
0001BA4E                            .nodacsfx
0001BA4E 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001BA52 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001BA54 4EFA 0000                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001BA58                            ; ===========================================================================
0001BA58                            ; ---------------------------------------------------------------------------
0001BA58                            ; Routine for pausing the sound driver
0001BA58                            ; ---------------------------------------------------------------------------
0001BA58                            
0001BA58                            dPlaySnd_Pause:
0001BA58 08F8 0007 C4A6             		bset	#mfbPaused,mFlags.w	; pause music
0001BA5E 6696                       		bne.s	locret_VolDAC		; if was already paused, skip
0001BA60                            ; ---------------------------------------------------------------------------
0001BA60                            ; The following code will set channel panning to none for all FM channels.
0001BA60                            ; This will ensure they are muted while we are pausing.
0001BA60                            ; ---------------------------------------------------------------------------
0001BA60                            
0001BA60 7602                       		moveq	#3-1,d3			; 3 channels per YM2616 "part"
0001BA62 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001BA64 7200                       		moveq	#0,d1			; pan to neither speaker and remove LFO
0001BA66                            
0001BA66                            .muteFM
0001BA66 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BA6A 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BA6E 5200                       		addq.b	#1,d0			; go to next FM channel
0001BA70 51CB FFF4                  		dbf	d3,.muteFM		; write each 3 channels per part
0001BA74                            ; ---------------------------------------------------------------------------
0001BA74                            ; The following code will key off all FM channels. There is a special
0001BA74                            ; behavior in that, we must write all channels into part 1, and we
0001BA74                            ; control the channel we are writing in the data portion.
0001BA74                            ; 4 bits are reserved for which operators are active (in this case,
0001BA74                            ; none), and 3 bits are reserved for the channel we want to affect.
0001BA74                            ; ---------------------------------------------------------------------------
0001BA74                            
0001BA74 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BA76 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001BA78                            
0001BA78                            .note
0001BA78 1203                       		move.b	d3,d1			; copy value into d1
0001BA7A 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BA7E 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001BA80 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001BA84 51CB FFF2                  		dbf	d3,.note		; loop for all 3 channel groups
0001BA88                            
0001BA88 4EBA 0000                  		jsr	dMutePSG(pc)		; mute all PSG channels
0001BA8C                            	; continue to mute all DAC channels
0001BA8C                            ; ===========================================================================
0001BA8C                            ; ---------------------------------------------------------------------------
0001BA8C                            ; Routine for muting all DAC channels
0001BA8C                            ; ---------------------------------------------------------------------------
0001BA8C                            
0001BA8C                            dMuteDAC:
0001BA8C                            	StopZ80					; wait for Z80 to stop
0001BA8C 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001BA94                          M 	waitz80stop
0001BA94 0839 0000 00A1 1100      M .wait_321:	btst	#0,z80_bus_req
0001BA9C 66F6                     M 	bne.s	.wait_321
0001BA9E 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001BAA2 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1 sample to a1
0001BAA8                            
0001BAA8                            	rept 12
0001BAA8                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001BAA8                            	endr
0001BAA8 12DA                     M 	move.b	(a2)+,(a1)+
0001BAAA 12DA                     M 	move.b	(a2)+,(a1)+
0001BAAC 12DA                     M 	move.b	(a2)+,(a1)+
0001BAAE 12DA                     M 	move.b	(a2)+,(a1)+
0001BAB0 12DA                     M 	move.b	(a2)+,(a1)+
0001BAB2 12DA                     M 	move.b	(a2)+,(a1)+
0001BAB4 12DA                     M 	move.b	(a2)+,(a1)+
0001BAB6 12DA                     M 	move.b	(a2)+,(a1)+
0001BAB8 12DA                     M 	move.b	(a2)+,(a1)+
0001BABA 12DA                     M 	move.b	(a2)+,(a1)+
0001BABC 12DA                     M 	move.b	(a2)+,(a1)+
0001BABE 12DA                     M 	move.b	(a2)+,(a1)+
0001BAC0                            
0001BAC0 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001BAC8                            
0001BAC8 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001BACC 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 2 sample to a1
0001BAD2                            
0001BAD2                            	rept 12
0001BAD2                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001BAD2                            	endr
0001BAD2 12DA                     M 	move.b	(a2)+,(a1)+
0001BAD4 12DA                     M 	move.b	(a2)+,(a1)+
0001BAD6 12DA                     M 	move.b	(a2)+,(a1)+
0001BAD8 12DA                     M 	move.b	(a2)+,(a1)+
0001BADA 12DA                     M 	move.b	(a2)+,(a1)+
0001BADC 12DA                     M 	move.b	(a2)+,(a1)+
0001BADE 12DA                     M 	move.b	(a2)+,(a1)+
0001BAE0 12DA                     M 	move.b	(a2)+,(a1)+
0001BAE2 12DA                     M 	move.b	(a2)+,(a1)+
0001BAE4 12DA                     M 	move.b	(a2)+,(a1)+
0001BAE6 12DA                     M 	move.b	(a2)+,(a1)+
0001BAE8 12DA                     M 	move.b	(a2)+,(a1)+
0001BAEA                            
0001BAEA 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001BAF2                            	StartZ80				; enable Z80 execution
0001BAF2 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001BAFA                            
0001BAFA                            locret_MuteDAC:
0001BAFA 4E75                       		rts
0001BAFC                            ; ===========================================================================
0001BAFC                            ; ---------------------------------------------------------------------------
0001BAFC                            ; Subroutine to play any queued music tracks, sound effects or commands
0001BAFC                            ; ---------------------------------------------------------------------------
0001BAFC                            
0001BAFC                            dPlaySnd:
0001BAFC 4DF8 C4BC                  		lea	mQueue.w,a6		; get address to the sound queue
0001BB00 7E00                       		moveq	#0,d7
0001BB02 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BB04 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001BB06 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BB08 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001BB0A 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001BB0C 67EC                       		beq.s	locret_MuteDAC		; if 0, no sounds were queued, return
0001BB0E                            
0001BB0E                            .found
0001BB0E 422E FFFF                  		clr.b	-1(a6)			; clear the slot we are processing
0001BB12 0C07 0082                  		cmpi.b	#SFXoff,d7		; check if this sound was a sound effect
0001BB16 6400 0000                  		bhs.w	dPlaySnd_SFX		; if so, handle it
0001BB1A 0C07 000A                  		cmpi.b	#MusOff,d7		; check if this sound was a command
0001BB1E 6500 0000                  		blo.w	dPlaySnd_Comm		; if so, handle it
0001BB22                            	; it was music, handle it below
0001BB22                            ; ===========================================================================
0001BB22                            ; ---------------------------------------------------------------------------
0001BB22                            ; Subroutine to play a queued music track
0001BB22                            ; ---------------------------------------------------------------------------
0001BB22                            
0001BB22                            dPlaySnd_Music:
0001BB22 4EBA 0000                  		jsr	dStopMusic(pc)		; mute hardware and reset all driver memory
0001BB26 4EBA 0000                  		jsr	dResetVolume(pc)	; reset volumes and end any fades
0001BB2A                            ; ---------------------------------------------------------------------------
0001BB2A                            ; To save few cycles, we don't directly substract the music offset from
0001BB2A                            ; the ID, and instead offset the table position. In practice this will
0001BB2A                            ; have the same effect, but saves us 8 cycles overall.
0001BB2A                            ; ---------------------------------------------------------------------------
0001BB2A                            
0001BB2A 49FA 0000                  		lea	MusicIndex-(MusOff*4)(pc),a4; get music pointer table with an offset
0001BB2E DE47                       		add.w	d7,d7			; quadruple music ID
0001BB30 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001BB32 11F4 7000 C4B9             		move.b	(a4,d7.w),mTempoSpeed.w	; load speed shoes tempo from the unused 8 bits
0001BB38 2874 7000                  		movea.l	(a4,d7.w),a4		; get music header pointer from the table
0001BB3C                            
0001BB3C                            
0001BB3C 264C                       		move.l	a4,a3			; copy pointer to a3
0001BB3E 584C                       		addq.w	#4,a4			; go to DAC1 data section
0001BB40                            
0001BB40 7000                       		moveq	#0,d0
0001BB42 102B 0001                  		move.b	1(a3),d0		; load song tempo to d0
0001BB46 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as regular tempo
0001BB4A 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes flag was set
0001BB50 6700                       		beq.s	.tempogot		; if not, use main tempo
0001BB52 1038 C4B9                  		move.b	mTempoSpeed.w,d0	; load speed shoes tempo to d0 instead
0001BB56                            
0001BB56                            .tempogot
0001BB56 11C0 C4BA                  		move.b	d0,mTempo.w		; save as the current tempo
0001BB5A 11C0 C4BB                  		move.b	d0,mTempoCur.w		; copy into the accumulator/counter
0001BB5E 0238 00F7 C4A6             		and.b	#$FF-(1<<mfbNoPAL),mFlags.w; enable PAL fix
0001BB64                            ; ---------------------------------------------------------------------------
0001BB64                            ; If the 7th bit (msb) of tick multiplier is set, PAL fix gets
0001BB64                            ; disabled. I know, very weird place to put it, but we dont have
0001BB64                            ; much free room in the song header
0001BB64                            ; ---------------------------------------------------------------------------
0001BB64                            
0001BB64 1813                       		move.b	(a3),d4			; load the tick multiplier to d4
0001BB66 6A00                       		bpl.s	.noPAL			; branch if the loaded value was positive
0001BB68 0244 007F                  		and.w	#$7F,d4			; keep value in range
0001BB6C 0038 0008 C4A6             		or.b	#1<<mfbNoPAL,mFlags.w	; disable PAL fix
0001BB72                            
0001BB72                            .noPAL
0001BB72 74A0                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbVol),d2; prepare running tracker and volume flags into d2
0001BB74 72C0                       		moveq	#$FFFFFFC0,d1		; prepare panning value of centre to d1
0001BB76 7C2C                       		moveq	#cSize,d6		; prepare channel size to d6
0001BB78 7A01                       		moveq	#1,d5			; prepare duration of 0 frames to d5
0001BB7A                            
0001BB7A 43F8 C4C4                  		lea	mDAC1.w,a1		; start from DAC1 channel
0001BB7E 45FA 0000                  		lea	dDACtypeVals(pc),a2	; prepare DAC (and FM) type value list into a2
0001BB82 7E01                       		moveq	#2-1,d7			; always run for 2 DAC channels
0001BB84 363C 0100                  		move.w	#$100,d3		; prepare default DAC frequency
0001BB88                            
0001BB88                            .loopDAC
0001BB88 1282                       		move.b	d2,(a1)			; save channel flags
0001BB8A 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BB8E 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BB92 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BB96 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001BB9A 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BB9E 3343 000E                  		move.w	d3,cFreq(a1)		; reset channel base frequency
0001BBA2                            
0001BBA2 7000                       		moveq	#0,d0
0001BBA4 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BBA6 D08B                       		add.l	a3,d0			; add music header offset to d0
0001BBA8 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BBAC                            
0001BBAC 135C 0009                  		move.b	(a4)+,cVolume(a1)	; load channel volume
0001BBB0 135C 000B                  		move.b	(a4)+,cSample(a1)	; load channel sample ID
0001BBB4 6700                       		beq.s	.sampmode		; if 0, we are in sample mode
0001BBB6 08D1 0000                  		bset	#cfbMode,(a1)		; if not 0, enable pitch mode
0001BBBA                            
0001BBBA                            .sampmode
0001BBBA D2C6                       		add.w	d6,a1			; go to the next channel
0001BBBC 51CF FFCA                  		dbf	d7,.loopDAC		; repeat for all DAC channels
0001BBC0                            
0001BBC0 7E00                       		moveq	#0,d7
0001BBC2 7481                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbRest),d2; prepare running tracker and channel rest flags
0001BBC4 1E2B 0002                  		move.b	2(a3),d7		; load the FM channel count to d7
0001BBC8 6B00                       		bmi.s	.doPSG			; if no FM channels are loaded, branch
0001BBCA                            
0001BBCA                            .loopFM
0001BBCA 1282                       		move.b	d2,(a1)			; save channel flags
0001BBCC 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BBD0 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BBD4 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BBD8 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001BBDC 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BBE0                            
0001BBE0 7000                       		moveq	#0,d0
0001BBE2 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BBE4 D08B                       		add.l	a3,d0			; add music header offset to d0
0001BBE6 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BBEA                            
0001BBEA 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001BBEE D2C6                       		adda.w	d6,a1			; go to the next channel
0001BBF0 51CF FFD8                  		dbf	d7,.loopFM		; repeat for all FM channels
0001BBF4                            
0001BBF4                            .doPSG
0001BBF4 7E00                       		moveq	#0,d7
0001BBF6 1E2B 0003                  		move.b	3(a3),d7		; load the FM channel count to d7
0001BBFA 6B00                       		bmi.s	.intSFX			; if no PSG channels are loaded, branch
0001BBFC                            ; ---------------------------------------------------------------------------
0001BBFC                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001BBFC                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001BBFC                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001BBFC                            ; is controlled by the 68000, we would be off by a single frame without
0001BBFC                            ; this fix.
0001BBFC                            ; ---------------------------------------------------------------------------
0001BBFC                            
0001BBFC 7A02                       		moveq	#2,d5			; prepare duration of 1 frames to d5
0001BBFE 45FA 0000                  		lea	dPSGtypeVals(pc),a2	; prepare PSG type value list into a2
0001BC02 43F8 C5F8                  		lea	mPSG1.w,a1		; start from PSG1 channel
0001BC06                            
0001BC06                            .loopPSG
0001BC06 1282                       		move.b	d2,(a1)			; save channel flags
0001BC08 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001BC0C 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001BC10 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001BC14 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001BC18                            
0001BC18 7000                       		moveq	#0,d0
0001BC1A 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001BC1C D08B                       		add.l	a3,d0			; add music header offset to d0
0001BC1E 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001BC22                            
0001BC22 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001BC26 135C 0007                  		move.b	(a4)+,cDetune(a1)	; load detune offset
0001BC2A 135C 000B                  		move.b	(a4)+,cVolEnv(a1)	; load volume envelope ID
0001BC2E D2C6                       		adda.w	d6,a1			; go to the next channel
0001BC30 51CF FFD4                  		dbf	d7,.loopPSG		; repeat for all FM channels
0001BC34                            
0001BC34                            .intSFX
0001BC34                            ; ---------------------------------------------------------------------------
0001BC34                            ; Now follows initializing FM6 to be ready for PCM streaming,
0001BC34                            ; and resetting the PCM filter for Dual PCM. Simply, this just
0001BC34                            ; clears some YM registers.
0001BC34                            ; ---------------------------------------------------------------------------
0001BC34                            
0001BC34 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BC36 7206                       		moveq	#6,d1			; FM6, all operators off
0001BC38 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001BC3C                            
0001BC3C 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001BC3E 7042                       		moveq	#$42,d0			; YM address: Total Level Operator 1 (FM3/6)
0001BC40 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BC44 704A                       		moveq	#$4A,d0			; YM address: Total Level Operator 2 (FM3/6)
0001BC46 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BC4A 7046                       		moveq	#$46,d0			; YM address: Total Level Operator 3 (FM3/6)
0001BC4C 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BC50 704E                       		moveq	#$4E,d0			; YM address: Total Level Operator 4 (FM3/6)
0001BC52 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BC56                            
0001BC56 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001BC58 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001BC5A 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BC5E                            
0001BC5E 303C 0000                  		move.w	#fLog>>$0F,d0		; use linear filter
0001BC62 4EBA 0000                  		jsr	dSetFilter(pc)		; set filter
0001BC66                            ; ---------------------------------------------------------------------------
0001BC66                            ; This piece of code here handles SFX overriding our newly loaded
0001BC66                            ; music channels. Since we did not do this at the initialization
0001BC66                            ; step, we will handle it here instead.
0001BC66                            ; ---------------------------------------------------------------------------
0001BC66                            
0001BC66 45FA 0000                  		lea	dSFXoverList(pc),a2	; load quick reference to the SFX override list
0001BC6A 43F8 C67C                  		lea	mSFXDAC1.w,a1		; start from SFX DAC1 channel
0001BC6E 7E06                       		moveq	#SFX_Ch-1,d7		; prepare total number of SFX channels into d7
0001BC70 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001BC72                            
0001BC72                            .loopSFX
0001BC72 4A11                       		tst.b	(a1)			; check if SFX channel is running a tracker
0001BC74 6A00                       		bpl.s	.nextSFX		; if not, skip this channel
0001BC76                            
0001BC76 7000                       		moveq	#0,d0
0001BC78 1029 0001                  		move.b	cType(a1),d0		; load SFX channel type to d0
0001BC7C 6B00                       		bmi.s	.SFXPSG			; if negative, it is a PSG channel
0001BC7E                            
0001BC7E 0240 0007                  		and.w	#$07,d0			; get only the necessary bits to d3
0001BC82 5540                       		subq.w	#2,d0			; since FM 1 and 2 are not used, skip over them
0001BC84 D040                       		add.w	d0,d0			; double offset (each entry is 1 word in size)
0001BC86 6000                       		bra.s	.override
0001BC88                            ; ---------------------------------------------------------------------------
0001BC88                            
0001BC88                            .SFXPSG
0001BC88 E808                       		lsr.b	#4,d0			; make it easier to reference the right offset in the table
0001BC8A                            .override
0001BC8A 3672 0000                  		move.w	(a2,d0.w),a3		; get music channel RAM address to a3
0001BC8E 08D3 0001                  		bset	#cfbInt,(a3)		; set as interrupted
0001BC92                            
0001BC92                            .nextSFX
0001BC92 D2C6                       		adda.w	d6,a1			; go to the next channel
0001BC94 51CF FFDC                  		dbf	d7,.loopSFX		; repeat for all SFX channels
0001BC98                            ; ---------------------------------------------------------------------------
0001BC98                            ; Here we mute all non-interrupted FM and PSG channels
0001BC98                            ; ---------------------------------------------------------------------------
0001BC98                            
0001BC98 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001BC9C 7804                       		moveq	#Mus_FM-1,d4		; prepare total number of FM channels into d7
0001BC9E                            .stopFM
0001BC9E 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key off even if not interrupted
0001BCA2 DAC6                       		adda.w	d6,a5			; go to the next channel
0001BCA4 51CC FFF8                  		dbf	d4,.stopFM		; repeat for all FM channels
0001BCA8                            
0001BCA8 7802                       		moveq	#Mus_PSG-1,d4		; start from PSG1 channel
0001BCAA                            .mutePSG
0001BCAA 4EBA 0000                  		jsr	dMutePSGmus(pc)		; mute PSG channel if not interrupted
0001BCAE DAC6                       		adda.w	d6,a5			; go to the next channel
0001BCB0 51CC FFF8                  		dbf	d4,.mutePSG		; repeat for all FM channels
0001BCB4 4E75                       		rts
0001BCB6                            
0001BCB6                            ; ===========================================================================
0001BCB6                            ; ---------------------------------------------------------------------------
0001BCB6                            ; Type values for different channels. Used for playing music
0001BCB6                            ; ---------------------------------------------------------------------------
0001BCB6 0B0E                       dDACtypeVals:	dc.b ctDAC1, ctDAC2
0001BCB8 0001 0204 05               dFMtypeVals:	dc.b ctFM1, ctFM2, ctFM3, ctFM4, ctFM5
0001BCBD 80A0 C0                    dPSGtypeVals:	dc.b ctPSG1, ctPSG2, ctPSG3
0001BCC0                            		even
0001BCC0                            ; ===========================================================================
0001BCC0                            ; ---------------------------------------------------------------------------
0001BCC0                            ; Subroutine to play a queued sound effect
0001BCC0                            ; ---------------------------------------------------------------------------
0001BCC0                            
0001BCC0                            dPlaySnd_SFX:
0001BCC0                            ; ---------------------------------------------------------------------------
0001BCC0                            ; This is a little special case with Sonic 1 - 3K, where the ring
0001BCC0                            ; sound effect would change panning each time it is played. AMPS
0001BCC0                            ; emulates this behavior like the original drivers did, by
0001BCC0                            ; playing a different sound effect ID.
0001BCC0                            ; ---------------------------------------------------------------------------
0001BCC0                            
0001BCC0                            		;cmpi.b	#sfx_RingRight,d7	; check if the sound effect was the ring sound effect
0001BCC0                            		;bne.s	.noring			; if not, skip
0001BCC0                            		;bchg	#mfbRing,mFlags.w	; swap flag and check if it was set
0001BCC0                            		;beq.s	.noring			; if was not, do not change sound effect
0001BCC0                            		;move.w	#sfx_RingLeft,d7	; switch to left panned sound effect instead
0001BCC0                            ; ---------------------------------------------------------------------------
0001BCC0                            ; To save few cycles, we don't directly substract the SFX offset from
0001BCC0                            ; the ID, and instead offset the table position. In practice this will
0001BCC0                            ; have the same effect, but saves us 8 cycles overall.
0001BCC0                            ; ---------------------------------------------------------------------------
0001BCC0                            
0001BCC0                            .noring
0001BCC0 43FA 0000                  		lea	SoundIndex-(SFXoff*4)(pc),a1; get sfx pointer table with an offset to a4
0001BCC4 1207                       		move.b	d7,d1			; copy sfx ID to d1 (used later)
0001BCC6 DE47                       		add.w	d7,d7			; quadruple sfx ID
0001BCC8 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001BCCA 2871 7000                  		movea.l	(a1,d7.w),a4		; get SFX header pointer from the table
0001BCCE                            
0001BCCE                            ; ---------------------------------------------------------------------------
0001BCCE                            ; Continous SFX is a very special type of sound effect. Unlike other
0001BCCE                            ; sound effects, when a continous SFX is played, it will run a loop
0001BCCE                            ; again, until it is no longer queued. This is very useful for sound
0001BCCE                            ; effects that need to be queued very often, but that really do not
0001BCCE                            ; sound good when restarted (plus, it requires more CPU time, anyway).
0001BCCE                            ; Even the Marble Zone block pushing sound effect had similar behavior,
0001BCCE                            ; but the code was not quite as matured as this here. Only one continous
0001BCCE                            ; SFX may be running at once, when other type is loaded, the earlier one
0001BCCE                            ; is stopped and replaced.
0001BCCE                            ; ---------------------------------------------------------------------------
0001BCCE                            
0001BCCE 4A31 7000                  		tst.b	(a1,d7.w)		; check if this sound effect is continously looping
0001BCD2 6A00                       		bpl.s	.nocont			; if not, skip
0001BCD4 11EC 0001 C4C2             		move.b	1(a4),mContCtr.w	; copy the number of channels as the new continous loop counter
0001BCDA B238 C4C3                  		cmp.b	mContLast.w,d1		; check if the last continous SFX had the same ID
0001BCDE 6600                       		bne.s	.setcont		; if not, play as a new sound effect anyway
0001BCE0 4E75                       		rts
0001BCE2                            
0001BCE2                            .setcont
0001BCE2 11C1 C4C3                  		move.b	d1,mContLast.w		; save new continous SFX ID
0001BCE6                            .nocont
0001BCE6 224C                       		movea.l	a4,a1			; copy tracker header pointer to a1
0001BCE8                            
0001BCE8 7E00                       		moveq	#0,d7
0001BCEA 47FA 0000                  		lea	dSFXoverList(pc),a3	; load quick reference to the SFX override list to a3
0001BCEE 45FA 0000                  		lea	dSFXoffList(pc),a2	; load quick reference to the SFX channel list to a2
0001BCF2 1A19                       		move.b	(a1)+,d5		; load sound effect priority to d5
0001BCF4 1E19                       		move.b	(a1)+,d7		; load number of SFX channels to d7
0001BCF6 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001BCF8                            ; ---------------------------------------------------------------------------
0001BCF8                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001BCF8                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001BCF8                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001BCF8                            ; is controlled by the 68000, we would be off by a single frame without
0001BCF8                            ; this fix.
0001BCF8                            ; ---------------------------------------------------------------------------
0001BCF8                            
0001BCF8                            .loopSFX
0001BCF8 7600                       		moveq	#0,d3
0001BCFA 7402                       		moveq	#2,d2			; prepare duration of 1 frames to d5
0001BCFC 1629 0001                  		move.b	1(a1),d3		; load sound effect channel type to d3
0001BD00 1803                       		move.b	d3,d4			; copy type to d4
0001BD02 6B00                       		bmi.s	.chPSG			; if channel is a PSG channel, branch
0001BD04                            
0001BD04 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001BD08 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001BD0A D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001BD0C                            
0001BD0C 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001BD10 BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001BD14 6500                       		blo.s	.skip			; if not, we can not override it
0001BD16                            
0001BD16 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001BD1A 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001BD1E 7401                       		moveq	#1,d2			; prepare duration of 0 frames to d5
0001BD20 6000                       		bra.s	.clearCh
0001BD22                            ; ---------------------------------------------------------------------------
0001BD22                            
0001BD22                            .skip
0001BD22 5C89                       		addq.l	#6,a1			; skip this sound effect channel
0001BD24 51CF FFD2                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BD28 4E75                       		rts
0001BD2A                            ; ---------------------------------------------------------------------------
0001BD2A                            
0001BD2A                            .chPSG
0001BD2A E84B                       		lsr.w	#4,d3			; make it easier to reference the right offset in the table
0001BD2C 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001BD30 BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001BD34 65EC                       		blo.s	.skip			; if not, we can not override it
0001BD36                            
0001BD36 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001BD3A 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001BD3E 0004 001F                  		ori.b	#$1F,d4			; add volume update and max volume to channel type
0001BD42 13C4 00C0 0011             		move.b	d4,dPSG			; send volume mute command to PSG
0001BD48                            
0001BD48 0C04 00DF                  		cmpi.b	#ctPSG3|$1F,d4		; check if we sent command about PSG3
0001BD4C 6600                       		bne.s	.clearCh		; if not, skip
0001BD4E 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send volume mute command for PSG4 to PSG
0001BD56                            
0001BD56                            .clearCh
0001BD56 3C4D                       		move.w	a5,a6			; copy sound effect channel RAM pointer to a6
0001BD58 7006                       		moveq	#cSizeSFX/4-1,d0	; prepare SFX channel size / 4 to d0
0001BD5A                            .clear
0001BD5A 429E                       		clr.l	(a6)+			; clear 4 bytes of channel data
0001BD5C 51C8 FFFC                  		dbf	d0,.clear		; clear the entire channel
0001BD60                            
0001BD60                            
0001BD60 3A99                       		move.w	(a1)+,(a5)		; load channel flags and type
0001BD62 1B45 001A                  		move.b	d5,cPrio(a5)		; set channel priority
0001BD66 1B42 000C                  		move.b	d2,cDuration(a5)	; reset channel duration
0001BD6A                            
0001BD6A 7000                       		moveq	#0,d0
0001BD6C 3019                       		move.w	(a1)+,d0		; load tracker offset to d0
0001BD6E D08C                       		add.l	a4,d0			; add music header offset to d0
0001BD70 2B40 0002                  		move.l	d0,cData(a5)		; save as the tracker address of the channel
0001BD74                            
0001BD74 3B59 0008                  		move.w	(a1)+,cPitch(a5)	; load pitch offset and channel volume
0001BD78 4A04                       		tst.b	d4			; check if this channel is a PSG channel
0001BD7A 6B00                       		bmi.s	.loop			; if is, skip over this
0001BD7C                            
0001BD7C 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001BD7E 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel memory too
0001BD82 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001BD84 4EBA 0000                  		jsr	WriteChYM(pc)		; write to part 2 channel
0001BD88                            
0001BD88 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this channel is a DAC channel
0001BD8C 6600                       		bne.s	.fm			; if not, branch
0001BD8E 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; DAC default frequency is $100, NOT $000
0001BD94                            
0001BD94                            .loop
0001BD94 51CF FF62                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BD98 4E75                       		rts
0001BD9A                            ; ---------------------------------------------------------------------------
0001BD9A                            ; The instant release for FM channels behavior was not in the Sonic 1
0001BD9A                            ; SMPS driver by default, but it has been added since it fixes an
0001BD9A                            ; issue with YM2612, where sometimes subsequent sound effect activations
0001BD9A                            ; would sound different over time. This fix will help to mitigate that.
0001BD9A                            ; ---------------------------------------------------------------------------
0001BD9A                            
0001BD9A                            .fm
0001BD9A 720F                       		moveq	#$F,d1			; set to release note instantly
0001BD9C 7080                       		moveq	#$FFFFFF80,d0		; YM address: Release Rate Operator 1
0001BD9E 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BDA2 7088                       		moveq	#$FFFFFF88,d0		; YM address: Release Rate Operator 3
0001BDA4 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BDA8 7084                       		moveq	#$FFFFFF84,d0		; YM address: Release Rate Operator 2
0001BDAA 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BDAE 708C                       		moveq	#$FFFFFF8C,d0		; YM address: Release Rate Operator 4
0001BDB0 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001BDB4                            
0001BDB4 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BDB6 122D 0001                  		move.b	cType(a5),d1		; FM channel, all operators off
0001BDBA 6100 0000                  		bsr.w	WriteYM_Pt1		; write to part 1 or 2 channel
0001BDBE                            
0001BDBE 51CF FF38                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001BDC2 4E75                       		rts
0001BDC4                            ; ===========================================================================
0001BDC4                            ; ---------------------------------------------------------------------------
0001BDC4                            ; pointers for music channels SFX can override and addresses of SFX channels
0001BDC4                            ; ---------------------------------------------------------------------------
0001BDC4                            
0001BDC4 C698                       dSFXoffList:	dc.w mSFXFM3			; FM3
0001BDC6 C67C                       		dc.w mSFXDAC1			; DAC1
0001BDC8 C6B4                       		dc.w mSFXFM4			; FM4
0001BDCA C6D0                       		dc.w mSFXFM5			; FM5
0001BDCC C6EC                       		dc.w mSFXPSG1			; PSG1
0001BDCE C708                       		dc.w mSFXPSG2			; PSG2
0001BDD0 C724                       		dc.w mSFXPSG3			; PSG3
0001BDD2 C724                       		dc.w mSFXPSG3			; PSG4
0001BDD4                            
0001BDD4 C574                       dSFXoverList:	dc.w mFM3			; SFX FM3
0001BDD6 C4C4                       		dc.w mDAC1			; SFX DAC1
0001BDD8 C5A0                       		dc.w mFM4			; SFX FM4
0001BDDA C5CC                       		dc.w mFM5			; SFX FM5
0001BDDC C5F8                       		dc.w mPSG1			; SFX PSG1
0001BDDE C624                       		dc.w mPSG2			; SFX PSG2
0001BDE0 C650                       		dc.w mPSG3			; SFX PSG3
0001BDE2 C650                       		dc.w mPSG3			; SFX PSG4
0001BDE4                            ; ===========================================================================
0001BDE4                            ; ---------------------------------------------------------------------------
0001BDE4                            ; Play queued command
0001BDE4                            ; ---------------------------------------------------------------------------
0001BDE4                            
0001BDE4                            dPlaySnd_Comm:
0001BDE4                            
0001BDE4 DE47                       		add.w	d7,d7			; quadruple ID
0001BDE6 DE47                       		add.w	d7,d7			; because each entry is 1 long word
0001BDE8 4EFB 7000                  		jmp	dSoundCommands-4(pc,d7.w); jump to appropriate command handler
0001BDEC                            
0001BDEC                            ; ---------------------------------------------------------------------------
0001BDEC                            dSoundCommands:
0001BDEC 6000 0000                  		bra.w	dPlaySnd_Reset		; 01 - Reset underwater and speed shoes flags, update volume
0001BDF0 6000 0000                  		bra.w	dPlaySnd_FadeOut	; 02 - Initialize a music fade out
0001BDF4 6000 0000                  		bra.w	dPlaySnd_Stop		; 03 - Stop all music
0001BDF8 6000 0000                  		bra.w	dPlaySnd_ShoesOn	; 04 - Enable speed shoes mode
0001BDFC 6000 0000                  		bra.w	dPlaySnd_ShoesOff	; 05 - Disable speed shoes mode
0001BE00 6000 0000                  		bra.w	dPlaySnd_ToWater	; 06 - Enable underwater mode
0001BE04 6000 0000                  		bra.w	dPlaySnd_OutWater	; 07 - Disable underwater mode
0001BE08 6000 FC4E                  		bra.w	dPlaySnd_Pause		; 08 - Pause the sound driver
0001BE0C 6000 FBEA                  		bra.w	dPlaySnd_Unpause	; 09 - Unpause the sound driver
0001BE10                            dSoundCommands_End:
0001BE10                            ; ===========================================================================
0001BE10                            ; ---------------------------------------------------------------------------
0001BE10                            ; Commands for what to do after a volume fade
0001BE10                            ; ---------------------------------------------------------------------------
0001BE10                            
0001BE10                            dFadeCommands:
0001BE10 4E75                       		rts				; 80 - Do nothing
0001BE12 4E75                       		rts
0001BE14 6000                       .stop		bra.s	dPlaySnd_Stop		; 84 - Stop all music
0001BE16 4E75                       		rts
0001BE18 6000 0000                  .resv		bra.w	dResetVolume		; 88 - Reset volume and update
0001BE1C 61FA                       		bsr.s	.resv			; 8C - Stop music playing and reset volume
0001BE1E 60F4                       		bra.s	.stop
0001BE20                            ; ===========================================================================
0001BE20                            ; ---------------------------------------------------------------------------
0001BE20                            ; Stop music and SFX from playing (This code clears SFX RAM also)
0001BE20                            ; ---------------------------------------------------------------------------
0001BE20                            
0001BE20                            dPlaySnd_Stop:
0001BE20                            ; Not needed,	moveq	#$2B,d0			; YM command: DAC Enable
0001BE20                            ; Dual PCM does	moveq	#$FFFFFF80,d1		; FM6 acts as DAC
0001BE20                            ; this for us	jsr	WriteYM_Pt1(pc)		; write to YM global register
0001BE20                            
0001BE20 7027                       		moveq	#$27,d0			; YM command: Channel 3 Mode & Timer Control
0001BE22 7200                       		moveq	#0,d1			; disable timers and channel 3 special mode
0001BE24 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to YM global register
0001BE28                            
0001BE28 43F8 C67C                  		lea	mSFXDAC1.w,a1		; prepare SFX DAC 1 to start clearing fromn
0001BE2C                            
0001BE2C                            	rept (mSize-mSFXDAC1)/4
0001BE2C                            		clr.l	(a1)+			; clear entire SFX RAM (others done below)
0001BE2C                            	endr
0001BE2C 4299                     M 	clr.l	(a1)+
0001BE2E 4299                     M 	clr.l	(a1)+
0001BE30 4299                     M 	clr.l	(a1)+
0001BE32 4299                     M 	clr.l	(a1)+
0001BE34 4299                     M 	clr.l	(a1)+
0001BE36 4299                     M 	clr.l	(a1)+
0001BE38 4299                     M 	clr.l	(a1)+
0001BE3A 4299                     M 	clr.l	(a1)+
0001BE3C 4299                     M 	clr.l	(a1)+
0001BE3E 4299                     M 	clr.l	(a1)+
0001BE40 4299                     M 	clr.l	(a1)+
0001BE42 4299                     M 	clr.l	(a1)+
0001BE44 4299                     M 	clr.l	(a1)+
0001BE46 4299                     M 	clr.l	(a1)+
0001BE48 4299                     M 	clr.l	(a1)+
0001BE4A 4299                     M 	clr.l	(a1)+
0001BE4C 4299                     M 	clr.l	(a1)+
0001BE4E 4299                     M 	clr.l	(a1)+
0001BE50 4299                     M 	clr.l	(a1)+
0001BE52 4299                     M 	clr.l	(a1)+
0001BE54 4299                     M 	clr.l	(a1)+
0001BE56 4299                     M 	clr.l	(a1)+
0001BE58 4299                     M 	clr.l	(a1)+
0001BE5A 4299                     M 	clr.l	(a1)+
0001BE5C 4299                     M 	clr.l	(a1)+
0001BE5E 4299                     M 	clr.l	(a1)+
0001BE60 4299                     M 	clr.l	(a1)+
0001BE62 4299                     M 	clr.l	(a1)+
0001BE64 4299                     M 	clr.l	(a1)+
0001BE66 4299                     M 	clr.l	(a1)+
0001BE68 4299                     M 	clr.l	(a1)+
0001BE6A 4299                     M 	clr.l	(a1)+
0001BE6C 4299                     M 	clr.l	(a1)+
0001BE6E 4299                     M 	clr.l	(a1)+
0001BE70 4299                     M 	clr.l	(a1)+
0001BE72 4299                     M 	clr.l	(a1)+
0001BE74 4299                     M 	clr.l	(a1)+
0001BE76 4299                     M 	clr.l	(a1)+
0001BE78 4299                     M 	clr.l	(a1)+
0001BE7A 4299                     M 	clr.l	(a1)+
0001BE7C 4299                     M 	clr.l	(a1)+
0001BE7E 4299                     M 	clr.l	(a1)+
0001BE80 4299                     M 	clr.l	(a1)+
0001BE82 4299                     M 	clr.l	(a1)+
0001BE84 4299                     M 	clr.l	(a1)+
0001BE86 4299                     M 	clr.l	(a1)+
0001BE88 4299                     M 	clr.l	(a1)+
0001BE8A 4299                     M 	clr.l	(a1)+
0001BE8C 4299                     M 	clr.l	(a1)+
0001BE8E                            
0001BE8E                            	; continue straight to stopping music
0001BE8E                            ; ===========================================================================
0001BE8E                            ; ---------------------------------------------------------------------------
0001BE8E                            ; Stop music from playing, reset driver memory and mute hardware
0001BE8E                            ; ---------------------------------------------------------------------------
0001BE8E                            
0001BE8E                            dStopMusic:
0001BE8E 43F8 C4A6                  		lea	mFlags.w,a1		; load driver RAM start to a1
0001BE92 3611                       		move.w	(a1),d3			; load driver flags and PAL counter to d3
0001BE94 1838 C4C0                  		move.b	mMasterVolDAC.w,d4	; load DAC master volume to d4
0001BE98 2A38 C4BC                  		move.l	mQueue.w,d5		; load sound queue and PSG master volume to d5
0001BE9C 4CF8 0007 C4AC             		movem.l	mComm.w,d0-d2		; load communications bytes, FM master volume and fade address to d0-d2
0001BEA2                            
0001BEA2                            	rept (mSFXDAC1-mFlags)/4
0001BEA2                            		clr.l	(a1)+			; clear driver and music channel memory
0001BEA2                            	endr
0001BEA2 4299                     M 	clr.l	(a1)+
0001BEA4 4299                     M 	clr.l	(a1)+
0001BEA6 4299                     M 	clr.l	(a1)+
0001BEA8 4299                     M 	clr.l	(a1)+
0001BEAA 4299                     M 	clr.l	(a1)+
0001BEAC 4299                     M 	clr.l	(a1)+
0001BEAE 4299                     M 	clr.l	(a1)+
0001BEB0 4299                     M 	clr.l	(a1)+
0001BEB2 4299                     M 	clr.l	(a1)+
0001BEB4 4299                     M 	clr.l	(a1)+
0001BEB6 4299                     M 	clr.l	(a1)+
0001BEB8 4299                     M 	clr.l	(a1)+
0001BEBA 4299                     M 	clr.l	(a1)+
0001BEBC 4299                     M 	clr.l	(a1)+
0001BEBE 4299                     M 	clr.l	(a1)+
0001BEC0 4299                     M 	clr.l	(a1)+
0001BEC2 4299                     M 	clr.l	(a1)+
0001BEC4 4299                     M 	clr.l	(a1)+
0001BEC6 4299                     M 	clr.l	(a1)+
0001BEC8 4299                     M 	clr.l	(a1)+
0001BECA 4299                     M 	clr.l	(a1)+
0001BECC 4299                     M 	clr.l	(a1)+
0001BECE 4299                     M 	clr.l	(a1)+
0001BED0 4299                     M 	clr.l	(a1)+
0001BED2 4299                     M 	clr.l	(a1)+
0001BED4 4299                     M 	clr.l	(a1)+
0001BED6 4299                     M 	clr.l	(a1)+
0001BED8 4299                     M 	clr.l	(a1)+
0001BEDA 4299                     M 	clr.l	(a1)+
0001BEDC 4299                     M 	clr.l	(a1)+
0001BEDE 4299                     M 	clr.l	(a1)+
0001BEE0 4299                     M 	clr.l	(a1)+
0001BEE2 4299                     M 	clr.l	(a1)+
0001BEE4 4299                     M 	clr.l	(a1)+
0001BEE6 4299                     M 	clr.l	(a1)+
0001BEE8 4299                     M 	clr.l	(a1)+
0001BEEA 4299                     M 	clr.l	(a1)+
0001BEEC 4299                     M 	clr.l	(a1)+
0001BEEE 4299                     M 	clr.l	(a1)+
0001BEF0 4299                     M 	clr.l	(a1)+
0001BEF2 4299                     M 	clr.l	(a1)+
0001BEF4 4299                     M 	clr.l	(a1)+
0001BEF6 4299                     M 	clr.l	(a1)+
0001BEF8 4299                     M 	clr.l	(a1)+
0001BEFA 4299                     M 	clr.l	(a1)+
0001BEFC 4299                     M 	clr.l	(a1)+
0001BEFE 4299                     M 	clr.l	(a1)+
0001BF00 4299                     M 	clr.l	(a1)+
0001BF02 4299                     M 	clr.l	(a1)+
0001BF04 4299                     M 	clr.l	(a1)+
0001BF06 4299                     M 	clr.l	(a1)+
0001BF08 4299                     M 	clr.l	(a1)+
0001BF0A 4299                     M 	clr.l	(a1)+
0001BF0C 4299                     M 	clr.l	(a1)+
0001BF0E 4299                     M 	clr.l	(a1)+
0001BF10 4299                     M 	clr.l	(a1)+
0001BF12 4299                     M 	clr.l	(a1)+
0001BF14 4299                     M 	clr.l	(a1)+
0001BF16 4299                     M 	clr.l	(a1)+
0001BF18 4299                     M 	clr.l	(a1)+
0001BF1A 4299                     M 	clr.l	(a1)+
0001BF1C 4299                     M 	clr.l	(a1)+
0001BF1E 4299                     M 	clr.l	(a1)+
0001BF20 4299                     M 	clr.l	(a1)+
0001BF22 4299                     M 	clr.l	(a1)+
0001BF24 4299                     M 	clr.l	(a1)+
0001BF26 4299                     M 	clr.l	(a1)+
0001BF28 4299                     M 	clr.l	(a1)+
0001BF2A 4299                     M 	clr.l	(a1)+
0001BF2C 4299                     M 	clr.l	(a1)+
0001BF2E 4299                     M 	clr.l	(a1)+
0001BF30 4299                     M 	clr.l	(a1)+
0001BF32 4299                     M 	clr.l	(a1)+
0001BF34 4299                     M 	clr.l	(a1)+
0001BF36 4299                     M 	clr.l	(a1)+
0001BF38 4299                     M 	clr.l	(a1)+
0001BF3A 4299                     M 	clr.l	(a1)+
0001BF3C 4299                     M 	clr.l	(a1)+
0001BF3E 4299                     M 	clr.l	(a1)+
0001BF40 4299                     M 	clr.l	(a1)+
0001BF42 4299                     M 	clr.l	(a1)+
0001BF44 4299                     M 	clr.l	(a1)+
0001BF46 4299                     M 	clr.l	(a1)+
0001BF48 4299                     M 	clr.l	(a1)+
0001BF4A 4299                     M 	clr.l	(a1)+
0001BF4C 4299                     M 	clr.l	(a1)+
0001BF4E 4299                     M 	clr.l	(a1)+
0001BF50 4299                     M 	clr.l	(a1)+
0001BF52 4299                     M 	clr.l	(a1)+
0001BF54 4299                     M 	clr.l	(a1)+
0001BF56 4299                     M 	clr.l	(a1)+
0001BF58 4299                     M 	clr.l	(a1)+
0001BF5A 4299                     M 	clr.l	(a1)+
0001BF5C 4299                     M 	clr.l	(a1)+
0001BF5E 4299                     M 	clr.l	(a1)+
0001BF60 4299                     M 	clr.l	(a1)+
0001BF62 4299                     M 	clr.l	(a1)+
0001BF64 4299                     M 	clr.l	(a1)+
0001BF66 4299                     M 	clr.l	(a1)+
0001BF68 4299                     M 	clr.l	(a1)+
0001BF6A 4299                     M 	clr.l	(a1)+
0001BF6C 4299                     M 	clr.l	(a1)+
0001BF6E 4299                     M 	clr.l	(a1)+
0001BF70 4299                     M 	clr.l	(a1)+
0001BF72 4299                     M 	clr.l	(a1)+
0001BF74 4299                     M 	clr.l	(a1)+
0001BF76 4299                     M 	clr.l	(a1)+
0001BF78 4299                     M 	clr.l	(a1)+
0001BF7A 4299                     M 	clr.l	(a1)+
0001BF7C 4299                     M 	clr.l	(a1)+
0001BF7E 4299                     M 	clr.l	(a1)+
0001BF80 4299                     M 	clr.l	(a1)+
0001BF82 4299                     M 	clr.l	(a1)+
0001BF84 4299                     M 	clr.l	(a1)+
0001BF86 4299                     M 	clr.l	(a1)+
0001BF88 4299                     M 	clr.l	(a1)+
0001BF8A 4299                     M 	clr.l	(a1)+
0001BF8C                            
0001BF8C 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0001BF8E                            
0001BF8E 31C3 C4A6                  		move.w	d3,mFlags.w		; save driver flags and PAL counter
0001BF92 11C4 C4C0                  		move.b	d4,mMasterVolDAC.w	; save DAC master volume
0001BF96 21C5 C4BC                  		move.l	d5,mQueue.w		; save sound queue and PSG master volume
0001BF9A 48F8 0007 C4AC             		movem.l	d0-d2,mComm.w		; save communications bytes, FM master volume and fade address
0001BFA0                            
0001BFA0 6100                       		bsr.s	dMutePSG		; hardware mute PSG
0001BFA2 4EBA FAE8                  		jsr	dMuteDAC(pc)		; hardware mute DAC
0001BFA6                            	; continue straight to hardware muting FM
0001BFA6                            ; ===========================================================================
0001BFA6                            ; ---------------------------------------------------------------------------
0001BFA6                            ; Mute all FM channels
0001BFA6                            ; ---------------------------------------------------------------------------
0001BFA6                            
0001BFA6                            dMuteFM:
0001BFA6 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001BFA8 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001BFAA                            
0001BFAA                            .noteoff
0001BFAA 1203                       		move.b	d3,d1			; copy value into d1
0001BFAC 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BFB0 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001BFB2 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001BFB6 51CB FFF2                  		dbf	d3,.noteoff		; loop for all 3 channel groups
0001BFBA                            
0001BFBA 7040                       		moveq	#$40,d0			; YM command: Total Level Operator 1
0001BFBC 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001BFBE 7802                       		moveq	#3-1,d4			; prepare 3 groups of channels to d4
0001BFC0                            
0001BFC0                            .chloop
0001BFC0 7603                       		moveq	#4-1,d3			; prepare 4 operator writes per channel to d3
0001BFC2 7A0F                       		moveq	#$10-1,d5		; prepare the value for going to next channel to d5
0001BFC4                            
0001BFC4                            .oploop
0001BFC4 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001BFC8 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001BFCC 5840                       		addq.w	#4,d0			; go to next operator (1 2 3 4)
0001BFCE 51CB FFF4                  		dbf	d3,.oploop		; repeat for each operator
0001BFD2                            
0001BFD2 9005                       		sub.b	d5,d0			; go to next FM channel
0001BFD4 51CC FFEA                  		dbf	d4,.chloop		; repeat for each channel
0001BFD8 4E75                       		rts
0001BFDA                            ; ===========================================================================
0001BFDA                            ; ---------------------------------------------------------------------------
0001BFDA                            ; Routine for muting all PSG channels
0001BFDA                            ; ---------------------------------------------------------------------------
0001BFDA                            
0001BFDA                            dMutePSG:
0001BFDA 43F9 00C0 0011             		lea	dPSG,a1			; load PSG data port address to a1
0001BFE0 12BC 009F                  		move.b	#ctPSG1|$1F,(a1)	; send volume mute command for PSG1 to PSG
0001BFE4 12BC 00BF                  		move.b	#ctPSG2|$1F,(a1)	; send volume mute command for PSG2 to PSG
0001BFE8 12BC 00DF                  		move.b	#ctPSG3|$1F,(a1)	; send volume mute command for PSG3 to PSG
0001BFEC 12BC 00FF                  		move.b	#ctPSG4|$1F,(a1)	; send volume mute command for PSG4 to PSG
0001BFF0 4E75                       		rts
0001BFF2                            ; ===========================================================================
0001BFF2                            ; ---------------------------------------------------------------------------
0001BFF2                            ; Normal fade out data
0001BFF2                            ; ---------------------------------------------------------------------------
0001BFF2                            
0001BFF2                            dFadeOutDataLog:
0001BFF2 0101 0002 0200 0204 0103+  	dc.b $01, $01, $00,  $02, $02, $00,  $02, $04, $01,  $03, $05, $01
0001BFFE 0405 0104 0602 0507 0206+  	dc.b $04, $05, $01,  $04, $06, $02,  $05, $07, $02,  $06, $08, $02
0001C00A 0709 0309 0B03 0A0C 030C+  	dc.b $07, $09, $03,  $09, $0B, $03,  $0A, $0C, $03,  $0C, $0E, $03
0001C016 0E10 0410 1104 1113 0414+  	dc.b $0E, $10, $04,  $10, $11, $04,  $11, $13, $04,  $14, $15, $05
0001C022 1618 051A 1C05 1C1F 0620+  	dc.b $16, $18, $05,  $1A, $1C, $05,  $1C, $1F, $06,  $20, $24, $06
0001C02E 2228 0726 2E07 2C34 0830+  	dc.b $22, $28, $07,  $26, $2E, $07,  $2C, $34, $08,  $30, $39, $08
0001C03A 343E 093C 440A 404C 0A46+  	dc.b $34, $3E, $09,  $3C, $44, $0A,  $40, $4C, $0A,  $46, $54, $0B
0001C046 4C5A 0C54 620D 5C6B 0D60+  	dc.b $4C, $5A, $0C,  $54, $62, $0D,  $5C, $6B, $0D,  $60, $76, $0E
0001C052 6C7C 0E74 7F0F 7F7F 0F8C   	dc.b $6C, $7C, $0E,  $74, $7F, $0F,  $7F, $7F, $0F,  fReset
0001C05C                            
0001C05C                            ;dFadeOutDataLinear:
0001C05C                            ;	dc.b $01, $00, $00,  $02, $01, $00,  $02, $01, $01,  $03, $02, $01
0001C05C                            ;	dc.b $04, $02, $01,  $04, $03, $02,  $05, $03, $02,  $06, $04, $02
0001C05C                            ;	dc.b $07, $05, $03,  $09, $06, $03,  $0A, $08, $03,  $0C, $0A, $03
0001C05C                            ;	dc.b $0E, $0D, $04,  $10, $0F, $04,  $11, $10, $04,  $14, $13, $05
0001C05C                            ;	dc.b $16, $16, $05,  $1A, $1A, $05,  $1C, $1E, $06,  $20, $22, $06
0001C05C                            ;	dc.b $22, $27, $07,  $26, $2A, $07,  $2C, $2E, $08,  $30, $34, $08
0001C05C                            ;	dc.b $34, $39, $09,  $3C, $3E, $0A,  $40, $3F, $0A,  $46, $40, $0B
0001C05C                            ;	dc.b $4C, $40, $0C,  $54, $40, $0D,  $5C, $40, $0D,  $60, $40, $0E
0001C05C                            ;	dc.b $6C, $40, $0E,  $74, $40, $0F,  $7F, $40, $0F,  fReset
0001C05C                            	even
0001C05C                            ; ===========================================================================
0001C05C                            ; ---------------------------------------------------------------------------
0001C05C                            ; Subroutine for initializing a fade effect.
0001C05C                            ; Since the driver allows for such an extensive and customizable
0001C05C                            ; fading code, we may hit a snag if we use fades too fast. It is
0001C05C                            ; possible, for example, to fade out, then in the middle of that,
0001C05C                            ; start fading in. This would normally cause a quick jump in the
0001C05C                            ; volume level from maybe half to completely mute. This routine
0001C05C                            ; aims to combat this by actually searching for the closest FM
0001C05C                            ; volume level in the fade program, and to start the new fade from
0001C05C                            ; where that byte appears. This can alter how long a volume fade
0001C05C                            ; lasts however, and if PSG and DAC volume are not correct faded,
0001C05C                            ; it may still cause a jump in their volume (especially if only,
0001C05C                            ; say, DAC fades volume). In the future, there might be a fix for
0001C05C                            ; that.
0001C05C                            ; ---------------------------------------------------------------------------
0001C05C                            
0001C05C                            dPlaySnd_FadeOut:
0001C05C 43FA FF94                  		lea	dFadeOutDataLog(pc),a1	; prepare stock fade out program to a1
0001C060                            
0001C060                            dLoadFade:
0001C060 1038 C4B4                  		move.b	mMasterVolFM.w,d0	; load FM master volume to d0
0001C064 4A38 C4B5                  		tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001C068 6700                       		beq.s	.nofade			; if not, load fade as is
0001C06A                            
0001C06A 2449                       		move.l	a1,a2			; copy fade program address to a2
0001C06C 74FF                       		moveq	#-1,d2			; prepare max byter difference
0001C06E                            
0001C06E                            .find
0001C06E 1212                       		move.b	(a2),d1			; load the next FM volume from fade program
0001C070 6A00                       		bpl.s	.search			; branch if this is not a command
0001C072                            
0001C072                            .nofade
0001C072 21C9 C4B4                  		move.l	a1,mFadeAddr.w		; save new fade program address to memory
0001C076 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save new FM master volume
0001C07A 4E75                       		rts
0001C07C                            
0001C07C                            .search
0001C07C 568A                       		addq.l	#3,a2			; skip over the current volume group
0001C07E 9200                       		sub.b	d0,d1			; sub current FM volume from read volume
0001C080 6A00                       		bpl.s	.abs			; if positive, do not negate
0001C082 4401                       		neg.b	d1			; negative to positive
0001C084                            
0001C084                            .abs
0001C084 B202                       		cmp.b	d2,d1			; check if volume difference was smaller than before
0001C086 64E6                       		bhs.s	.find			; if not, read next group
0001C088                            
0001C088 1401                       		move.b	d1,d2			; else save the new difference
0001C08A 224A                       		move.l	a2,a1			; also save the fade program address where we found it
0001C08C 60E0                       		bra.s	.find			; loop through each group in the program
0001C08E                            ; ===========================================================================
0001C08E                            ; ---------------------------------------------------------------------------
0001C08E                            ; Routine for loading a volume filter into Dual PCM ROM.
0001C08E                            ; This routine will actually write the bank number the volume filter
0001C08E                            ; is in. This requires volume filters are aligned to Z80 banks, and
0001C08E                            ; just because we can, we write 9 bits (yeah its not necessary, but
0001C08E                            ; what the hell, you have to have fun sometimes!)
0001C08E                            ; ---------------------------------------------------------------------------
0001C08E                            
0001C08E                            dSetFilter:
0001C08E 43F9 0000 0000             		lea	dZ80+SV_VolumeBank,a1	; load volume bank instructions address to a1
0001C094 7274                       		moveq	#$74,d1			; prepare the "ld  (hl),h" instruction to d1
0001C096 7408                       		moveq	#9-1,d2			; prepare number of instructions to write to d2
0001C098                            	StopZ80					; wait for Z80 to stop
0001C098 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C0A0                          M 	waitz80stop
0001C0A0 0839 0000 00A1 1100      M .wait_324:	btst	#0,z80_bus_req
0001C0A8 66F6                     M 	bne.s	.wait_324
0001C0AA                            ; ---------------------------------------------------------------------------
0001C0AA                            ; addx in Motorola 68000 is much like adc in Z80. It allows us to add
0001C0AA                            ; a register AND the carry to another register. What this means, is if
0001C0AA                            ; we push 1 into carry (so, carry set), we will be loading $75 instead
0001C0AA                            ; of $74 into the carry, making us able to switch between the Z80
0001C0AA                            ; instructions  "ld  (hl),h" and "ld  (hl),l", which in turn allows
0001C0AA                            ; Dual PCM to bank switch into the appropriate bank.
0001C0AA                            ; ---------------------------------------------------------------------------
0001C0AA                            
0001C0AA                            .loop
0001C0AA 7600                       		moveq	#0,d3			; prepare 0 into d3 (because of addx)
0001C0AC E248                       		lsr.w	#1,d0			; shift lsb into carry
0001C0AE D701                       		addx.b	d1,d3			; add instruction and carry into d3
0001C0B0                            
0001C0B0 12C3                       		move.b	d3,(a1)+		; save instruction into Z80 memory
0001C0B2 51CA FFF6                  		dbf	d2,.loop		; repeat for each bit/instruction
0001C0B6                            	StartZ80				; enable Z80 execution
0001C0B6 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C0BE 4E75                       		rts
0001C0C0                            
0001C0C0                            ; ===========================================================================
0001C0C0                            ; ---------------------------------------------------------------------------
0001C0C0                            ; Routine for resetting master volumes, filters and disabling fading
0001C0C0                            ; ---------------------------------------------------------------------------
0001C0C0                            
0001C0C0                            dResetVolume:
0001C0C0 42B8 C4B4                  		clr.l	mFadeAddr.w		; stop fading program and reset FM master volume
0001C0C4 4238 C4BF                  		clr.b	mMasterVolPSG.w		; reset PSG master volume
0001C0C8 4238 C4C0                  		clr.b	mMasterVolDAC.w		; reset DAC master volume
0001C0CC 303C 0000                  		move.w	#fLog>>$0F,d0		; load value for linear filter
0001C0D0 61BC                       		bsr.s	dSetFilter		; load filter instructions
0001C0D2                            
0001C0D2                            dUpdateVolumeAll:
0001C0D2 6100                       		bsr.s	dReqVolUpFM		; request FM volume update
0001C0D4 8138 C67C                  		or.b	d0,mSFXDAC1.w		; request update for SFX DAC1 channel
0001C0D8                            
0001C0D8 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001C0D8                            	rept Mus_DAC				; loop through all music DAC channels
0001C0D8                            		or.b	d0,.ch.w		; request channel volume update
0001C0D8                            .ch =		.ch+cSize			; go to next channel
0001C0D8                            	endr
0001C0D8 8138 C4C4                M 	or.b	d0,.ch.w
0001C0DC =FFFFC4F0                M .ch	=	.ch+csize
0001C0DC 8138 C4F0                M 	or.b	d0,.ch.w
0001C0E0 =FFFFC51C                M .ch	=	.ch+csize
0001C0E0                            
0001C0E0 =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001C0E0                            	rept Mus_PSG				; loop through all music PSG channels
0001C0E0                            		or.b	d0,.ch.w		; request channel volume update
0001C0E0                            .ch =		.ch+cSize			; go to next channel
0001C0E0                            	endr
0001C0E0 8138 C5F8                M 	or.b	d0,.ch.w
0001C0E4 =FFFFC624                M .ch	=	.ch+csize
0001C0E4 8138 C624                M 	or.b	d0,.ch.w
0001C0E8 =FFFFC650                M .ch	=	.ch+csize
0001C0E8 8138 C650                M 	or.b	d0,.ch.w
0001C0EC =FFFFC67C                M .ch	=	.ch+csize
0001C0EC                            
0001C0EC =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001C0EC                            	rept SFX_PSG				; loop through all SFX PSG channels
0001C0EC                            		or.b	d0,.ch.w		; request channel volume update
0001C0EC                            .ch =		.ch+cSizeSFX			; go to next channel
0001C0EC                            	endr
0001C0EC 8138 C6EC                M 	or.b	d0,.ch.w
0001C0F0 =FFFFC708                M .ch	=	.ch+csizesfx
0001C0F0 8138 C708                M 	or.b	d0,.ch.w
0001C0F4 =FFFFC724                M .ch	=	.ch+csizesfx
0001C0F4 8138 C724                M 	or.b	d0,.ch.w
0001C0F8 =FFFFC740                M .ch	=	.ch+csizesfx
0001C0F8 4E75                       		rts
0001C0FA                            ; ===========================================================================
0001C0FA                            ; ---------------------------------------------------------------------------
0001C0FA                            ; Enable speed shoes mode
0001C0FA                            ; ---------------------------------------------------------------------------
0001C0FA                            
0001C0FA                            dPlaySnd_ShoesOn:
0001C0FA 11F8 C4B9 C4BB             		move.b	mTempoSpeed.w,mTempoCur.w; set tempo accumulator/counter to speed shoes one
0001C100 11F8 C4B9 C4BA             		move.b	mTempoSpeed.w,mTempo.w	; set main tempor to speed shoes one
0001C106 08F8 0001 C4A6             		bset	#mfbSpeed,mFlags.w	; enable speed shoes flag
0001C10C 4E75                       		rts
0001C10E                            ; ===========================================================================
0001C10E                            ; ---------------------------------------------------------------------------
0001C10E                            ; Reset music flags (underwater mode and tempo mode)
0001C10E                            ; ---------------------------------------------------------------------------
0001C10E                            
0001C10E                            dPlaySnd_Reset:
0001C10E 6100                       		bsr.s	dPlaySnd_OutWater	; gp reset underwater flag and request volume update
0001C110                            ; ===========================================================================
0001C110                            ; ---------------------------------------------------------------------------
0001C110                            ; Disable speed shoes mode
0001C110                            ; ---------------------------------------------------------------------------
0001C110                            
0001C110                            dPlaySnd_ShoesOff:
0001C110 11F8 C4B8 C4BB             		move.b	mTempoMain.w,mTempoCur.w; set tempo accumulator/counter to normal one
0001C116 11F8 C4B8 C4BA             		move.b	mTempoMain.w,mTempo.w	; set main tempor to normal one
0001C11C 08B8 0001 C4A6             		bclr	#mfbSpeed,mFlags.w	; disable speed shoes flag
0001C122 4E75                       		rts
0001C124                            ; ===========================================================================
0001C124                            ; ---------------------------------------------------------------------------
0001C124                            ; Enable Underwater mode
0001C124                            ; ---------------------------------------------------------------------------
0001C124                            
0001C124                            dPlaySnd_ToWater:
0001C124 08F8 0002 C4A6             		bset	#mfbWater,mFlags.w	; enable underwater mode
0001C12A 6000                       		bra.s	dReqVolUpFM		; request FM volume update
0001C12C                            ; ===========================================================================
0001C12C                            ; ---------------------------------------------------------------------------
0001C12C                            ; Disable Underwater mode
0001C12C                            ; ---------------------------------------------------------------------------
0001C12C                            
0001C12C                            dPlaySnd_OutWater:
0001C12C 08B8 0002 C4A6             		bclr	#mfbWater,mFlags.w	; disable underwater mode
0001C132                            ; ===========================================================================
0001C132                            ; ---------------------------------------------------------------------------
0001C132                            ; force volume update on all FM channels
0001C132                            ; ---------------------------------------------------------------------------
0001C132                            
0001C132                            dReqVolUpFM;
0001C132 7020                       		moveq	#1<<cfbVol,d0		; prepare volume update flag to d0
0001C134 =FFFFC51C                  .ch =	mFM1					; start at FM1
0001C134                            	rept Mus_FM				; loop through all music FM channels
0001C134                            		or.b	d0,.ch.w		; request channel volume update
0001C134                            .ch =		.ch+cSize			; go to next channel
0001C134                            	endr
0001C134 8138 C51C                M 	or.b	d0,.ch.w
0001C138 =FFFFC548                M .ch	=	.ch+csize
0001C138 8138 C548                M 	or.b	d0,.ch.w
0001C13C =FFFFC574                M .ch	=	.ch+csize
0001C13C 8138 C574                M 	or.b	d0,.ch.w
0001C140 =FFFFC5A0                M .ch	=	.ch+csize
0001C140 8138 C5A0                M 	or.b	d0,.ch.w
0001C144 =FFFFC5CC                M .ch	=	.ch+csize
0001C144 8138 C5CC                M 	or.b	d0,.ch.w
0001C148 =FFFFC5F8                M .ch	=	.ch+csize
0001C148                            
0001C148 =FFFFC698                  .ch =	mSFXFM3					; start at SFX FM3
0001C148                            	rept SFX_FM				; loop through all SFX FM channels
0001C148                            		or.b	d0,.ch.w		; request channel volume update
0001C148                            .ch =		.ch+cSizeSFX			; go to next channel
0001C148                            	endr
0001C148 8138 C698                M 	or.b	d0,.ch.w
0001C14C =FFFFC6B4                M .ch	=	.ch+csizesfx
0001C14C 8138 C6B4                M 	or.b	d0,.ch.w
0001C150 =FFFFC6D0                M .ch	=	.ch+csizesfx
0001C150 8138 C6D0                M 	or.b	d0,.ch.w
0001C154 =FFFFC6EC                M .ch	=	.ch+csizesfx
0001C154 4E75                       		rts
0001C156                            ; ===========================================================================
0001C156                            ; ---------------------------------------------------------------------------
0001C156                            ; Subroutine for updating Total Levels for FM channel
0001C156                            ; ---------------------------------------------------------------------------
0001C156                            
0001C156                            dUpdateVolFM:
0001C156 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C15A 6600                       		bne.s	locret_VolFM		; if yes, do not update
0001C15C                            
0001C15C 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001C160 D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001C164 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001C166 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001C168                            
0001C168                            .noover
0001C168 7000                       		moveq	#0,d0
0001C16A 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001C16E 224E                       		move.l	a6,a1			; copy music voice table address to a1
0001C170                            
0001C170                            	dCALC_VOICE				; get address of the specific voice to a1
0001C170 EB48                     M 	lsl.w	#5,d0
0001C172 D2C0                     M 	add.w	d0,a1
0001C174 1011                       		move.b	(a1),d0			; load algorithm and feedback to d0
0001C176 7C00                       		moveq	#0,d6			; reset the modulator offset
0001C178                            
0001C178 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001C17E 6700                       		beq.s	.uwdone			; if not, skip
0001C180 1C00                       		move.b	d0,d6			; copy algorithm and feedback to d6
0001C182 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001C186 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001C188 1C00                       		move.b	d0,d6			; set algorithm and feedback to modulator offset
0001C18A                            
0001C18A                            .uwdone
0001C18A 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001C18C D2FC 0019                  		add.w	#VoiceTL,a1		; go to the Total Level offset of the voice
0001C190 45FA 0000                  		lea	dOpTLFM(pc),a2		; load Total Level address table to a3
0001C194                            
0001C194                            .tlloop
0001C194 101A                       		move.b	(a2)+,d0		; load YM address to write to
0001C196 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001C198 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001C19A                            
0001C19A D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001C19C 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001C19E 727F                       		moveq	#$7F,d1			; cap to silent volume
0001C1A0 6000                       		bra.s	.slot
0001C1A2                            
0001C1A2                            .noslot
0001C1A2 D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001C1A4                            .slot
0001C1A4 4EBA 0000                  		jsr	WriteChYM(pc)		; write Total Level to YM according to channel
0001C1A8                            .ignore
0001C1A8 51CD FFEA                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001C1AC                            
0001C1AC                            
0001C1AC                            locret_VolFM:
0001C1AC 4E75                       		rts
0001C1AE                            ; ===========================================================================
0001C1AE                            ; ---------------------------------------------------------------------------
0001C1AE                            ; YM2612 register update list
0001C1AE                            ; ---------------------------------------------------------------------------
0001C1AE                            
0001C1AE 3038 343C                  dOpListYM:	dc.b $30, $38, $34, $3C		; Detune, Multiple
0001C1B2 5058 545C                  		dc.b $50, $58, $54, $5C		; Rate Scale, Attack Rate
0001C1B6 6068 646C                  dAMSEn_Ops:	dc.b $60, $68, $64, $6C		; Decay 1 Rate
0001C1BA 7078 747C                  		dc.b $70, $78, $74, $7C		; Decay 2 Rate
0001C1BE 8088 848C                  		dc.b $80, $88, $84, $8C		; Decay 1 level, Release Rate
0001C1C2 9098 949C                  		dc.b $90, $98, $94, $9C		; SSG-EG
0001C1C6 4048 444C                  dOpTLFM:	dc.b $40, $48, $44, $4C		; Total Level
0001C1CA                            ; ===========================================================================
0001C1CA                            ; ---------------------------------------------------------------------------
0001C1CA                            ; Process SFX FM channels
0001C1CA                            ; ---------------------------------------------------------------------------
0001C1CA                            
0001C1CA                            dAMPSdoFMSFX:
0001C1CA 4DFA 0000                  		lea	VoiceBankSFX(pc),a6	; load sound effects voice table into a6
0001C1CE 7E02                       		moveq	#SFX_FM-1,d7		; get total number of SFX FM channels to d7
0001C1D0                            
0001C1D0                            dAMPSnextFMSFX:
0001C1D0 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001C1D4 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C1D6 6A00 0000                  		bpl.w	.next			; if not, branch
0001C1DA 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C1DE 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C1E2                            
0001C1E2                            	dCalcFreq				; calculate channel base frequency
0001C1E2 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C1E6 4886                     M 	ext.w	d6
0001C1E8 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C1EC                            	dModulate dAMPSdoPSGSFX, dAMPSnextFMSFX, 1; run modulation code
0001C1EC 0815 0003                M 	btst	#cfbmod,(a5)
0001C1F0 6700                     M 	beq.s	.noret
0001C1F2 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C1F6 6700                     M 	beq.s	.started
0001C1F8 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C1FC                          M .noret
0001C1FC 0895 0005                M 	bclr	#cfbvol,(a5)
0001C200 6700                     M 	beq.s	.noupdatevol
0001C202 4EBA FF52                M 	jsr	dupdatevolfm(pc)
0001C206                          M 	.noupdatevol:
0001C206 51CF FFC8                M 	dbf	d7,dampsnextfmsfx
0001C20A 6000 0000                M 	bra.w	dampsdopsgsfx
0001C20E                          M .started
0001C20E 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C212 66E8                     M 	bne.s	.noret
0001C214 226D 0010                M 	movea.l	cmod(a5),a1
0001C218 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C21E 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C222 6600                     M 	bne.s	.norev
0001C224 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C22A 442D 0017                M 	neg.b	cmodstep(a5)
0001C22E                          M .norev
0001C22E 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C232 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C236 4885                     M 	ext.w	d5
0001C238 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C23C 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C240 DC45                     M 	add.w	d5,d6
0001C242 6100 0000                  		bsr.w	dUpdateFreqFM3		; send FM frequency to hardware
0001C246                            
0001C246 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C24A 6700                       		beq.s	.next			; if not, skip
0001C24C 4EBA FF08                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C250                            
0001C250                            .next
0001C250 51CF FF7E                  		dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001C254 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001C258                            
0001C258                            .update
0001C258 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C25C                            	dDoTracker				; process tracker
0001C25C 286D 0002                M 	movea.l	cdata(a5),a4
0001C260                          M .data
0001C260 7A00                     M 	moveq	#0,d5
0001C262 1A1C                     M 	move.b	(a4)+,d5
0001C264 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C268 6500                     M 	blo.s	.notcomm
0001C26A 4EBA 0000                M 	jsr	dcommands(pc)
0001C26E 60F0                     M 	bra.s	.data
0001C270 60DE                     M 	bra.s	.next
0001C272                          M .notcomm
0001C272 4EBA 0000                  		jsr	dKeyOffFM2(pc)		; send key-off command to YM
0001C276 4A05                       		tst.b	d5			; check if note is being played
0001C278 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C27A                            
0001C27A 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001C27E 1A1C                       		move.b	(a4)+,d5		; check next byte
0001C280 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001C282 534C                       		subq.w	#1,a4			; if not, then return back
0001C284 6000                       		bra.s	.pcnote			; do some extra clearing
0001C286                            
0001C286                            .timer
0001C286 4EBA F5EC                  		jsr	dCalcDuration(pc)	; calculate duration
0001C28A                            .pcnote
0001C28A                            	dProcNote 1, 0				; reset necessary channel memory
0001C28A 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C28E 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C294 0815 0002                M 	btst	#cfbhold,(a5)
0001C298 6600                     M 	bne.s	.endpn
0001C29A 0815 0003                M 	btst	#cfbmod,(a5)
0001C29E 6700                     M 	beq.s	.endpn
0001C2A0 226D 0010                M 	movea.l	cmod(a5),a1
0001C2A4 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C2A8 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C2AC 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C2B0 1011                     M 	move.b	(a1),d0
0001C2B2 E208                     M 	lsr.b	#1,d0
0001C2B4 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C2B8 426D 0014                M 	clr.w	cmodfreq(a5)
0001C2BC                          M .endpn
0001C2BC 6100 0000                  		bsr.w	dUpdateFreqFM		; send FM frequency to hardware
0001C2C0                            	dKeyOnFM 1				; send key-on command to YM
0001C2C0 0815 0002                M 	btst	#cfbhold,(a5)
0001C2C4 6600                     M 	bne.s	.k
0001C2C6 0815 0000                M 	btst	#cfbrest,(a5)
0001C2CA 6600                     M 	bne.s	.k
0001C2CC 7028                     M 	moveq	#$28,d0
0001C2CE 122D 0001                M 	move.b	ctype(a5),d1
0001C2D2 0001 00F0                M 	ori.b	#$f0,d1
0001C2D6 6100 0000                M 	bsr.w	writeym_pt1
0001C2DA                          M .k
0001C2DA                            
0001C2DA 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C2DE 6700                       		beq.s	.noupdate		; if not, branch
0001C2E0 4EBA FE74                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C2E4                            
0001C2E4 51CF FEEA                  .noupdate	dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001C2E8 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001C2EC                            ; ===========================================================================
0001C2EC                            ; ---------------------------------------------------------------------------
0001C2EC                            ; Process music FM channels
0001C2EC                            ; ---------------------------------------------------------------------------
0001C2EC                            
0001C2EC                            dAMPSdoFM:
0001C2EC 4DFA 0000                  		lea	VoiceBankMusic(pc),a6	; load music voice table into a6
0001C2F0 7E04                       		moveq	#Mus_FM-1,d7		; get total number of music FM channels to d7
0001C2F2                            
0001C2F2                            dAMPSnextFM:
0001C2F2 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel
0001C2F6 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C2F8 6A00 0000                  		bpl.w	.next			; if not, branch
0001C2FC 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C300 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C304                            
0001C304                            	dNoteToutFM.w				; handle FM-specific note timeout behavior
0001C304                          M 	dnotetouthandler
0001C304 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001C308 6700                     M 	beq.s	.endt
0001C30A 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001C30E 6600                     M 	bne.s	.endt
0001C310 08D5 0000                M 	bset	#cfbrest,(a5)
0001C314 6100 0000                M 	bsr.w	dkeyofffm
0001C318 6000 0000                M 	bra.w	.next
0001C31C                          M .endt
0001C31C                            	dCalcFreq				; calculate channel base frequency
0001C31C 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C320 4886                     M 	ext.w	d6
0001C322 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C326                            	dModulate dAMPSdoPSG, dAMPSnextFM, 0	; run modulation code
0001C326 0815 0003                M 	btst	#cfbmod,(a5)
0001C32A 6700                     M 	beq.s	.noret
0001C32C 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C330 6700                     M 	beq.s	.started
0001C332 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C336                          M .noret
0001C336 0895 0005                M 	bclr	#cfbvol,(a5)
0001C33A 6700                     M 	beq.s	.noupdatevol
0001C33C 4EBA FE18                M 	jsr	dupdatevolfm(pc)
0001C340                          M 	.noupdatevol:
0001C340 51CF FFB0                M 	dbf	d7,dampsnextfm
0001C344 6000 0000                M 	bra.w	dampsdopsg
0001C348                          M .started
0001C348 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C34C 66E8                     M 	bne.s	.noret
0001C34E 226D 0010                M 	movea.l	cmod(a5),a1
0001C352 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C358 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C35C 6600                     M 	bne.s	.norev
0001C35E 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C364 442D 0017                M 	neg.b	cmodstep(a5)
0001C368                          M .norev
0001C368 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C36C 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C370 4885                     M 	ext.w	d5
0001C372 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C376 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C37A DC45                     M 	add.w	d5,d6
0001C37C 6100 0000                  		bsr.w	dUpdateFreqFM2		; send FM frequency to hardware
0001C380                            
0001C380 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C384 6700                       		beq.s	.next			; if not, skip
0001C386 4EBA FDCE                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C38A                            
0001C38A                            .next
0001C38A 51CF FF66                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001C38E 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001C392                            
0001C392                            .update
0001C392 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C396                            	dDoTracker				; process tracker
0001C396 286D 0002                M 	movea.l	cdata(a5),a4
0001C39A                          M .data
0001C39A 7A00                     M 	moveq	#0,d5
0001C39C 1A1C                     M 	move.b	(a4)+,d5
0001C39E 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C3A2 6500                     M 	blo.s	.notcomm
0001C3A4 4EBA 0000                M 	jsr	dcommands(pc)
0001C3A8 60F0                     M 	bra.s	.data
0001C3AA 60DE                     M 	bra.s	.next
0001C3AC                          M .notcomm
0001C3AC 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001C3B0 4A05                       		tst.b	d5			; check if note is being played
0001C3B2 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001C3B4                            
0001C3B4 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001C3B8 1A1C                       		move.b	(a4)+,d5		; check next byte
0001C3BA 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001C3BC 534C                       		subq.w	#1,a4			; if not, then return back
0001C3BE 6000                       		bra.s	.pcnote			; do some extra clearing
0001C3C0                            
0001C3C0                            .timer
0001C3C0 4EBA F4B2                  		jsr	dCalcDuration(pc)	; calculate duration
0001C3C4                            .pcnote
0001C3C4                            	dProcNote 0, 0				; reset necessary channel memory
0001C3C4 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C3C8 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C3CE 0815 0002                M 	btst	#cfbhold,(a5)
0001C3D2 6600                     M 	bne.s	.endpn
0001C3D4 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001C3DA 0815 0003                M 	btst	#cfbmod,(a5)
0001C3DE 6700                     M 	beq.s	.endpn
0001C3E0 226D 0010                M 	movea.l	cmod(a5),a1
0001C3E4 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C3E8 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C3EC 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C3F0 1011                     M 	move.b	(a1),d0
0001C3F2 E208                     M 	lsr.b	#1,d0
0001C3F4 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C3F8 426D 0014                M 	clr.w	cmodfreq(a5)
0001C3FC                          M .endpn
0001C3FC 6100                       		bsr.s	dUpdateFreqFM		; send FM frequency to hardware
0001C3FE                            	dKeyOnFM				; send key-on command to YM
0001C3FE 0815 0002                M 	btst	#cfbhold,(a5)
0001C402 6600                     M 	bne.s	.k
0001C404 0815 0000                M 	btst	#cfbrest,(a5)
0001C408 6600                     M 	bne.s	.k
0001C40A 0815 0001                M 	btst	#cfbint,(a5)
0001C40E 6600                     M 	bne.s	.k
0001C410 7028                     M 	moveq	#$28,d0
0001C412 122D 0001                M 	move.b	ctype(a5),d1
0001C416 0001 00F0                M 	ori.b	#$f0,d1
0001C41A 6100 0000                M 	bsr.w	writeym_pt1
0001C41E                          M .k
0001C41E                            
0001C41E 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C422 6700                       		beq.s	.noupdate		; if not, branch
0001C424 4EBA FD30                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001C428                            
0001C428                            .noupdate
0001C428 51CF FEC8                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001C42C 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001C430                            ; ===========================================================================
0001C430                            ; ---------------------------------------------------------------------------
0001C430                            ; Write FM frequency to Dual PCM YMCue
0001C430                            ; ---------------------------------------------------------------------------
0001C430                            
0001C430                            dUpdateFreqFM:
0001C430 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001C434 6600                       		bne.s	locret_UpdFreqFM	; if is, skip
0001C436 3C2D 000E                  		move.w	cFreq(a5),d6		; load channel base frequency to d6
0001C43A 6700                       		beq.s	dUpdFreqFMrest		; if 0, this channel should be resting
0001C43C                            
0001C43C 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001C440 4880                       		ext.w	d0			; extend to word
0001C442 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001C444                            
0001C444 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001C448 6700                       		beq.s	dUpdateFreqFM2		; if not, branch
0001C44A DC6D 0014                  		add.w	cModFreq(a5),d6		; add channel modulation frequency offset to d6
0001C44E                            
0001C44E                            dUpdateFreqFM2:
0001C44E 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C452 6600                       		bne.s	locret_UpdFreqFM	; if is, do not update frequency anyway
0001C454                            
0001C454                            dUpdateFreqFM3:
0001C454 3206                       		move.w	d6,d1			; copy frequency to d1
0001C456 E049                       		lsr.w	#8,d1			; shift upper byte into lower byte
0001C458 70A4                       		moveq	#$FFFFFFA4,d0		; YM command: Frequency MSB & Octave
0001C45A 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001C45E                            
0001C45E 1206                       		move.b	d6,d1			; copy lower byte of frequency into d1 (value)
0001C460 103C 00A0                  		move.b	#$FFFFFFA0,d0		; YM command: Frequency LSB
0001C464 4EFA 0000                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001C468                            
0001C468                            dUpdFreqFMrest:
0001C468 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C46C                            
0001C46C                            locret_UpdFreqFM:
0001C46C 4E75                       		rts
0001C46E                            ; ===========================================================================
0001C46E                            ; ---------------------------------------------------------------------------
0001C46E                            ; Process a note in FM channel (enable resting or get frequency)
0001C46E                            ; ---------------------------------------------------------------------------
0001C46E                            
0001C46E                            dGetFreqFM:
0001C46E 0405 0080                  		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001C472 6600                       		bne.s	.norest			; branch if note wasnt $80 (rest)
0001C474 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001C478 426D 000E                  		clr.w	cFreq(a5)		; set base frequency to 0
0001C47C 4E75                       		rts
0001C47E                            
0001C47E                            .norest
0001C47E DA2D 0008                  		add.b	cPitch(a5),d5		; add pitch offset to note
0001C482 0245 007F                  		andi.w	#$7F,d5			; keep within $80 notes
0001C486 DA45                       		add.w	d5,d5			; double offset (each entry is a word)
0001C488                            
0001C488 43FA 0000                  		lea	dFreqFM(pc),a1		; load FM frequency table to a1
0001C48C 3B71 5000 000E             		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001C492                            
0001C492 4E75                       		rts
0001C494                            ; ===========================================================================
0001C494                            ; ---------------------------------------------------------------------------
0001C494                            ; Subroutine for doing keying-off FM channel
0001C494                            ; ---------------------------------------------------------------------------
0001C494                            
0001C494                            dKeyOffFM:
0001C494 0815 0001                  		btst	#cfbInt,(a5)		; check if overridden by sfx
0001C498 66D2                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001C49A                            
0001C49A                            dKeyOffFM2:
0001C49A 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001C49E 66CC                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001C4A0                            
0001C4A0 7028                       		moveq	#$28,d0			; YM command: Key on
0001C4A2 122D 0001                  		move.b	cType(a5),d1		; get channel type bits (and turn all operators off)
0001C4A6 6000                       		bra.s	WriteYM_Pt1		; write to part 1 channel
0001C4A8                            ; ===========================================================================
0001C4A8                            ; ---------------------------------------------------------------------------
0001C4A8                            ; Write to YMCue according to channel and check if interrupted by sfx
0001C4A8                            ; ---------------------------------------------------------------------------
0001C4A8                            
0001C4A8                            dWriteYMchnInt:
0001C4A8 0815 0001                  		btst	#cfbInt,(a5)		; check if interrupted by sfx
0001C4AC 6600                       		bne.s	WriteYM_Pt1_rts		; if was, do not note on
0001C4AE                            ; ===========================================================================
0001C4AE                            ; ---------------------------------------------------------------------------
0001C4AE                            ; Write to YMCue according to channel
0001C4AE                            ; ---------------------------------------------------------------------------
0001C4AE                            
0001C4AE                            WriteChYM:
0001C4AE 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this is a YM part 1 or 2 channel
0001C4B4 6600                       		bne.s	WriteChYM2		; if part 2, branch
0001C4B6 D02D 0001                  		add.b	cType(a5),d0		; add channel type to address
0001C4BA                            ; ===========================================================================
0001C4BA                            ; ---------------------------------------------------------------------------
0001C4BA                            ; Write to YMCue using part 1
0001C4BA                            ; ---------------------------------------------------------------------------
0001C4BA                            
0001C4BA                            WriteYM_Pt1:
0001C4BA                            	StopZ80					; wait for Z80 to stop
0001C4BA 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C4C2                          M 	waitz80stop
0001C4C2 0839 0000 00A1 1100      M .wait_340:	btst	#0,z80_bus_req
0001C4CA 66F6                     M 	bne.s	.wait_340
0001C4CC 51D8                       		sf	(a0)+			; set YM port address as 0
0001C4CE 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001C4D0 10C0                       		move.b	d0,(a0)+		; write address to cue
0001C4D2                            	;	st	(a0)			; mark as the end of the cue data
0001C4D2                            	StartZ80				; enable Z80 execution
0001C4D2 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C4DA                            
0001C4DA                            WriteYM_Pt1_rts:
0001C4DA 4E75                       		rts
0001C4DC                            ; ===========================================================================
0001C4DC                            ; ---------------------------------------------------------------------------
0001C4DC                            ; Write to YMCue according to channel in part 2
0001C4DC                            ; ---------------------------------------------------------------------------
0001C4DC                            
0001C4DC                            WriteChYM2:
0001C4DC 142D 0001                  		move.b	cType(a5),d2		; get channel type to d2
0001C4E0 0882 0002                  		bclr	#ctbPt2,d2		; remove part 2 marker from it
0001C4E4 D002                       		add.b	d2,d0			; add to YM address
0001C4E6                            ; ===========================================================================
0001C4E6                            ; ---------------------------------------------------------------------------
0001C4E6                            ; Write to YMCue using part 2
0001C4E6                            ; ---------------------------------------------------------------------------
0001C4E6                            
0001C4E6                            WriteYM_Pt2:
0001C4E6                            	StopZ80					; wait for Z80 to stop
0001C4E6 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C4EE                          M 	waitz80stop
0001C4EE 0839 0000 00A1 1100      M .wait_343:	btst	#0,z80_bus_req
0001C4F6 66F6                     M 	bne.s	.wait_343
0001C4F8 10FC 0002                  		move.b	#$02,(a0)+		; set YM port address as 2
0001C4FC 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001C4FE 10C0                       		move.b	d0,(a0)+		; write address to cue
0001C500                            	;	st	(a0)			; mark as the end of the cue data
0001C500                            	StartZ80				; enable Z80 execution
0001C500 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C508 4E75                       		rts
0001C50A                            ; ===========================================================================
0001C50A                            ; ---------------------------------------------------------------------------
0001C50A                            ; Note to FM frequency conversion table
0001C50A                            ; ---------------------------------------------------------------------------
0001C50A                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C50A 025E                       dFreqFM:dc.w								       $025E; Octave-1 - (80)
0001C50C 0284 02AB 02D3 02FE 032D+  	dc.w $0284,$02AB,$02D3,$02FE,$032D,$035C,$038F,$03C5,$03FF,$043C,$047C,$0A5E; Octave 0 - (81 - 8C)
0001C524 0A84 0AAB 0AD3 0AFE 0B2D+  	dc.w $0A84,$0AAB,$0AD3,$0AFE,$0B2D,$0B5C,$0B8F,$0BC5,$0BFF,$0C3C,$0C7C,$125E; Octave 1 - (8D - 98)
0001C53C 1284 12AB 12D3 12FE 132D+  	dc.w $1284,$12AB,$12D3,$12FE,$132D,$135C,$138F,$13C5,$13FF,$143C,$147C,$1A5E; Octave 2 - (99 - A4)
0001C554 1A84 1AAB 1AD3 1AFE 1B2D+  	dc.w $1A84,$1AAB,$1AD3,$1AFE,$1B2D,$1B5C,$1B8F,$1BC5,$1BFF,$1C3C,$1C7C,$225E; Octave 3 - (A5 - B0)
0001C56C 2284 22AB 22D3 22FE 232D+  	dc.w $2284,$22AB,$22D3,$22FE,$232D,$235C,$238F,$23C5,$23FF,$243C,$247C,$2A5E; Octave 4 - (B1 - BC)
0001C584 2A84 2AAB 2AD3 2AFE 2B2D+  	dc.w $2A84,$2AAB,$2AD3,$2AFE,$2B2D,$2B5C,$2B8F,$2BC5,$2BFF,$2C3C,$2C7C,$325E; Octave 5 - (BD - C8)
0001C59C 3284 32AB 32D3 32FE 332D+  	dc.w $3284,$32AB,$32D3,$32FE,$332D,$335C,$338F,$33C5,$33FF,$343C,$347C,$3A5E; Octave 6 - (c9 - D4)
0001C5B4 3A84 3AAB 3AD3 3AFE 3B2D+  	dc.w $3A84,$3AAB,$3AD3,$3AFE,$3B2D,$3B5C,$3B8F,$3BC5,$3BFF,$3C3C,$3C7C	    ; Octave 7 - (D5 - DF)
0001C5CA                            dFreqFM_:
0001C5CA                            ; ===========================================================================
0001C5CA                            ; ---------------------------------------------------------------------------
0001C5CA                            ; Note to Dual PCM frequency conversion table
0001C5CA                            ; ---------------------------------------------------------------------------
0001C5CA                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C5CA 0000                       dFreqDAC:dc.w $0000								    ; Octave NOPE - (80)
0001C5CC 0010 0011 0012 0013 0014+  	dc.w $0010,$0011,$0012,$0013,$0014,$0015,$0017,$0018,$0019,$001B,$001D,$001E; Octave 0 - (81 - 8C)
0001C5E4 0020 0022 0024 0026 0028+  	dc.w $0020,$0022,$0024,$0026,$0028,$002B,$002D,$0030,$0033,$0036,$0039,$003C; Octave 1 - (8D - 98)
0001C5FC 0040 0044 0048 004C 0051+  	dc.w $0040,$0044,$0048,$004C,$0051,$0055,$005B,$0060,$0066,$006C,$0072,$0079; Octave 2 - (99 - A4)
0001C614 0080 0088 0090 0098 00A1+  	dc.w $0080,$0088,$0090,$0098,$00A1,$00AB,$00B5,$00C0,$00CB,$00D7,$00E4,$00F2; Octave 3 - (A5 - B0)
0001C62C 0100 010F 011F 0130 0143+  	dc.w $0100,$010F,$011F,$0130,$0143,$0156,$016A,$0180,$0196,$01AF,$01C8,$01E3; Octave 4 - (B1 - BC)
0001C644 0200 021E 023F 0261 0285+  	dc.w $0200,$021E,$023F,$0261,$0285,$02AB,$02D4,$02FF,$032D,$035D,$0390,$03C7; Octave 5 - (BD - C8)
0001C65C 0400 043D 047D 04C2 050A+  	dc.w $0400,$043D,$047D,$04C2,$050A,$0557,$05A8,$05FE,$0659,$06BA,$0721,$078D; Octave 6 - (C9 - D4)
0001C674 0800 087A 08FB 0983 0A14+  	dc.w $0800,$087A,$08FB,$0983,$0A14,$0AAE,$0B50,$0BFD,$0CB3,$0D74,$0E41,$0F1A; Octave 7 - (D5 - E0)
0001C68C 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 8 - (E1 - EC)
0001C6A4 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 9 - (ED - F8)
0001C6BC 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF				    ; Octave 10 -(F9 - FF)
0001C6CA                            
0001C6CA F001 F001 F001 F001 F001+  	dc.w			     -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -10 -(00 - 07)
0001C6DA F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -9 - (08 - 13)
0001C6F2 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -8 - (14 - 1F)
0001C70A F0E6 F1BF F28C F34D F403+  	dc.w -$F1A,-$E41,-$D74,-$CB3,-$BFD,-$B50,-$AAE,-$A14,-$983,-$8FB,-$87A,-$800; Octave -7 - (20 - 2B)
0001C722 F873 F8DF F946 F9A7 FA02+  	dc.w -$78D,-$721,-$6BA,-$659,-$5FE,-$5A8,-$557,-$50A,-$4C2,-$47D,-$43D,-$400; Octave -6 - (2C - 37)
0001C73A FC39 FC70 FCA3 FCD3 FD01+  	dc.w -$3C7,-$390,-$35D,-$32D,-$2FF,-$2D4,-$2AB,-$285,-$261,-$23F,-$21E,-$200; Octave -5 - (38 - 43)
0001C752 FE1D FE38 FE51 FE6A FE80+  	dc.w -$1E3,-$1C8,-$1AF,-$196,-$180,-$16A,-$156,-$143,-$130,-$11F,-$10F,-$100; Octave -4 - (44 - 4F)
0001C76A FF0E FF1C FF29 FF35 FF40+  	dc.w -$0F2,-$0E4,-$0D7,-$0CB,-$0C0,-$0B5,-$0AB,-$0A1,-$098,-$090,-$088,-$080; Octave -3 - (50 - 5B)
0001C782 FF87 FF8E FF94 FF9A FFA0+  	dc.w -$079,-$072,-$06C,-$066,-$060,-$05B,-$055,-$051,-$04C,-$048,-$044,-$040; Octave -2 - (5C - 67)
0001C79A FFC4 FFC7 FFCA FFCD FFD0+  	dc.w -$03C,-$039,-$036,-$033,-$030,-$02D,-$02B,-$028,-$026,-$024,-$022,-$020; Octave -1 - (68 - 73)
0001C7B2 FFE2 FFE3 FFE5 FFE7 FFE8+  	dc.w -$01E,-$01D,-$01B,-$019,-$018,-$017,-$015,-$014,-$013,-$012,-$011,-$010; Octave -0 - (74 - 7F)
0001C7CA                            ; ===========================================================================
0001C7CA                            ; ---------------------------------------------------------------------------
0001C7CA                            ; Note to PSG frequency conversion table
0001C7CA                            ; ---------------------------------------------------------------------------
0001C7CA                            ;	dc.w	C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001C7CA 0356 0326 02F9 02CE 02A5+  dFreqPSG:dc.w $0356,$0326,$02F9,$02CE,$02A5,$0280,$025C,$023A,$021A,$01FB,$01DF,$01C4; Octave 3 - (81 - 8C)
0001C7E2 01AB 0193 017D 0167 0153+  	dc.w  $01AB,$0193,$017D,$0167,$0153,$0140,$012E,$011D,$010D,$00FE,$00EF,$00E2; Octave 4 - (8D - 98)
0001C7FA 00D6 00C9 00BE 00B4 00A9+  	dc.w  $00D6,$00C9,$00BE,$00B4,$00A9,$00A0,$0097,$008F,$0087,$007F,$0078,$0071; Octave 5 - (99 - A4)
0001C812 006B 0065 005F 005A 0055+  	dc.w  $006B,$0065,$005F,$005A,$0055,$0050,$004B,$0047,$0043,$0040,$003C,$0039; Octave 6 - (A5 - B0)
0001C82A 0036 0033 0030 002D 002B+  	dc.w  $0036,$0033,$0030,$002D,$002B,$0028,$0026,$0024,$0022,$0020,$001F,$001D; Octave 7 - (B1 - BC)
0001C842 001B 001A 0018 0017 0016+  	dc.w  $001B,$001A,$0018,$0017,$0016,$0015,$0013,$0012,$0011		     ; Notes (BD - C5)
0001C854 0000                       	dc.w  $0000								     ; Note (C6)
0001C856                            dFreqPSG_:
0001C856                            ; ===========================================================================
0001C856                            ; ---------------------------------------------------------------------------
0001C856                            ; Process SFX PSG channels
0001C856                            ; ---------------------------------------------------------------------------
0001C856                            
0001C856                            dAMPSdoPSGSFX:
0001C856 7E02                       		moveq	#SFX_PSG-1,d7		; get total number of SFX PSG channels to d7
0001C858 4DFA FF70                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001C85C                            
0001C85C                            dAMPSnextPSGSFX:
0001C85C DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001C860 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C862 6A00                       		bpl.s	.next			; if not, branch
0001C864 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C868 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C86C                            
0001C86C                            	dCalcFreq				; calculate channel base frequency
0001C86C 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C870 4886                     M 	ext.w	d6
0001C872 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C876                            	dModulate				; run modulation code
0001C876 0815 0003                M 	btst	#cfbmod,(a5)
0001C87A 6700                     M 	beq.s	.noret
0001C87C 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C880 6700                     M 	beq.s	.started
0001C882 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C886                          M .noret
0001C886 6000                     M 	bra.s	.endm
0001C888                          M .started
0001C888 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C88C 66F8                     M 	bne.s	.noret
0001C88E 226D 0010                M 	movea.l	cmod(a5),a1
0001C892 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C898 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C89C 6600                     M 	bne.s	.norev
0001C89E 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C8A4 442D 0017                M 	neg.b	cmodstep(a5)
0001C8A8                          M .norev
0001C8A8 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C8AC 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C8B0 4885                     M 	ext.w	d5
0001C8B2 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C8B6 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C8BA DC45                     M 	add.w	d5,d6
0001C8BC 6100 0000                  		bsr.w	dUpdateFreqPSG3		; if frequency needs changing, do it
0001C8C0                            
0001C8C0                            .endm
0001C8C0 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001C8C4                            .next
0001C8C4 51CF FF96                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001C8C8 4EFA 0000                  		jmp	dCheckTracker(pc)	; after that, check tracker and end loop
0001C8CC                            
0001C8CC                            .update
0001C8CC 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C8D0                            	dDoTracker				; process tracker
0001C8D0 286D 0002                M 	movea.l	cdata(a5),a4
0001C8D4                          M .data
0001C8D4 7A00                     M 	moveq	#0,d5
0001C8D6 1A1C                     M 	move.b	(a4)+,d5
0001C8D8 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C8DC 6500                     M 	blo.s	.notcomm
0001C8DE 4EBA 0000                M 	jsr	dcommands(pc)
0001C8E2 60F0                     M 	bra.s	.data
0001C8E4 60DE                     M 	bra.s	.next
0001C8E6                          M .notcomm
0001C8E6 4A05                       		tst.b	d5			; check if note is being played
0001C8E8 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001C8EA                            
0001C8EA                            	dGetFreqPSG				; get PSG frequency
0001C8EA 0405 0081                M 	subi.b	#$81,d5
0001C8EE 6400                     M 	bhs.s	.norest
0001C8F0 08D5 0000                M 	bset	#cfbrest,(a5)
0001C8F4 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001C8FA 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001C8FE 6000                     M 	bra.s	.freqgot
0001C900                          M .norest
0001C900 DA2D 0008                M 	add.b	cpitch(a5),d5
0001C904 0245 007F                M 	andi.w	#$7f,d5
0001C908 DA45                     M 	add.w	d5,d5
0001C90A 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001C910                          M .freqgot
0001C910 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001C912 6A00                       		bpl.s	.timer			; if yes, handle timer
0001C914 534C                       		subq.w	#1,a4			; else, undo the increment
0001C916 6000                       		bra.s	.pcnote			; do not calculate duration
0001C918                            
0001C918                            .timer
0001C918 4EBA EF5A                  		jsr	dCalcDuration(pc)	; calculate duration
0001C91C                            .pcnote
0001C91C                            	dProcNote 1, 1				; reset necessary channel memory
0001C91C 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C920 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C926 0815 0002                M 	btst	#cfbhold,(a5)
0001C92A 6600                     M 	bne.s	.endpn
0001C92C 422D 0006                M 	clr.b	cenvpos(a5)
0001C930 0815 0003                M 	btst	#cfbmod,(a5)
0001C934 6700                     M 	beq.s	.endpn
0001C936 226D 0010                M 	movea.l	cmod(a5),a1
0001C93A 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C93E 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C942 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C946 1011                     M 	move.b	(a1),d0
0001C948 E208                     M 	lsr.b	#1,d0
0001C94A 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C94E 426D 0014                M 	clr.w	cmodfreq(a5)
0001C952                          M .endpn
0001C952                            
0001C952 6100 0000                  		bsr.w	dUpdateFreqPSG		; update hardware frequency
0001C956 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001C95A 51CF FF00                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001C95E                            	; continue to check tracker and end loop
0001C95E                            ; ===========================================================================
0001C95E                            ; ---------------------------------------------------------------------------
0001C95E                            ; End channel loop and check if tracker debugger should be opened
0001C95E                            ; ---------------------------------------------------------------------------
0001C95E                            
0001C95E                            dCheckTracker:
0001C95E                            .rts
0001C95E 4E75                       		rts
0001C960                            ; ===========================================================================
0001C960                            ; ---------------------------------------------------------------------------
0001C960                            ; Music PSG channel loop
0001C960                            ; ---------------------------------------------------------------------------
0001C960                            
0001C960                            dAMPSdoPSG:
0001C960 7E02                       		moveq	#Mus_PSG-1,d7		; get total number of music PSG channels to d7
0001C962 4DFA FE66                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001C966                            
0001C966                            dAMPSnextPSG:
0001C966 DAFC 002C                  		add.w	#cSize,a5		; go to the next channe
0001C96A 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C96C 6A00 0000                  		bpl.w	.next			; if not, branch
0001C970 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C974 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C978                            
0001C978                            	dNoteToutPSG				; handle PSG-specific note timeout behavior
0001C978                          M 	dnotetouthandler
0001C978 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001C97C 6700                     M 	beq.s	.endt
0001C97E 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001C982 6600                     M 	bne.s	.endt
0001C984 08D5 0000                M 	bset	#cfbrest,(a5)
0001C988 6100 0000                M 	bsr.w	dmutepsgmus
0001C98C 6000                     M 	bra.s	.next
0001C98E                          M .endt
0001C98E                            	dCalcFreq				; calculate channel base frequency
0001C98E 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C992 4886                     M 	ext.w	d6
0001C994 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C998                            	dModulate				; run modulation code
0001C998 0815 0003                M 	btst	#cfbmod,(a5)
0001C99C 6700                     M 	beq.s	.noret
0001C99E 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C9A2 6700                     M 	beq.s	.started
0001C9A4 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C9A8                          M .noret
0001C9A8 6000                     M 	bra.s	.endm
0001C9AA                          M .started
0001C9AA 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C9AE 66F8                     M 	bne.s	.noret
0001C9B0 226D 0010                M 	movea.l	cmod(a5),a1
0001C9B4 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C9BA 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C9BE 6600                     M 	bne.s	.norev
0001C9C0 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C9C6 442D 0017                M 	neg.b	cmodstep(a5)
0001C9CA                          M .norev
0001C9CA 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C9CE 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C9D2 4885                     M 	ext.w	d5
0001C9D4 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C9D8 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C9DC DC45                     M 	add.w	d5,d6
0001C9DE 6100 0000                  		bsr.w	dUpdateFreqPSG2		; if frequency needs changing, do it
0001C9E2                            
0001C9E2                            .endm
0001C9E2 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001C9E6                            .next
0001C9E6 51CF FF7E                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001C9EA 4EFA EEA0                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001C9EE                            
0001C9EE                            .update
0001C9EE 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001C9F2                            	dDoTracker				; process tracker
0001C9F2 286D 0002                M 	movea.l	cdata(a5),a4
0001C9F6                          M .data
0001C9F6 7A00                     M 	moveq	#0,d5
0001C9F8 1A1C                     M 	move.b	(a4)+,d5
0001C9FA 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C9FE 6500                     M 	blo.s	.notcomm
0001CA00 4EBA 0000                M 	jsr	dcommands(pc)
0001CA04 60F0                     M 	bra.s	.data
0001CA06 60DE                     M 	bra.s	.next
0001CA08                          M .notcomm
0001CA08 4A05                       		tst.b	d5			; check if note is being played
0001CA0A 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001CA0C                            
0001CA0C                            	dGetFreqPSG				; get PSG frequency
0001CA0C 0405 0081                M 	subi.b	#$81,d5
0001CA10 6400                     M 	bhs.s	.norest
0001CA12 08D5 0000                M 	bset	#cfbrest,(a5)
0001CA16 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001CA1C 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001CA20 6000                     M 	bra.s	.freqgot
0001CA22                          M .norest
0001CA22 DA2D 0008                M 	add.b	cpitch(a5),d5
0001CA26 0245 007F                M 	andi.w	#$7f,d5
0001CA2A DA45                     M 	add.w	d5,d5
0001CA2C 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001CA32                          M .freqgot
0001CA32 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001CA34 6A00                       		bpl.s	.timer			; if yes, handle timer
0001CA36 534C                       		subq.w	#1,a4			; else, undo the increment
0001CA38 6000                       		bra.s	.pcnote			; do not calculate duration
0001CA3A                            
0001CA3A                            .timer
0001CA3A 4EBA EE38                  		jsr	dCalcDuration(pc)	; calculate duration
0001CA3E                            .pcnote
0001CA3E                            	dProcNote 0, 1				; reset necessary channel memory
0001CA3E 2B4C 0002                M 	move.l	a4,cdata(a5)
0001CA42 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001CA48 0815 0002                M 	btst	#cfbhold,(a5)
0001CA4C 6600                     M 	bne.s	.endpn
0001CA4E 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001CA54 422D 0006                M 	clr.b	cenvpos(a5)
0001CA58 0815 0003                M 	btst	#cfbmod,(a5)
0001CA5C 6700                     M 	beq.s	.endpn
0001CA5E 226D 0010                M 	movea.l	cmod(a5),a1
0001CA62 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001CA66 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001CA6A 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001CA6E 1011                     M 	move.b	(a1),d0
0001CA70 E208                     M 	lsr.b	#1,d0
0001CA72 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001CA76 426D 0014                M 	clr.w	cmodfreq(a5)
0001CA7A                          M .endpn
0001CA7A                            
0001CA7A 6100                       		bsr.s	dUpdateFreqPSG		; update hardware frequency
0001CA7C 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001CA80 51CF FEE4                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001CA84 4EFA EE06                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001CA88                            ; ===========================================================================
0001CA88                            ; ---------------------------------------------------------------------------
0001CA88                            ; Write PSG frequency to hardware
0001CA88                            ; ---------------------------------------------------------------------------
0001CA88                            
0001CA88                            dUpdateFreqPSG:
0001CA88 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001CA8C 6A00                       		bpl.s	.detune			; if it was not rest frequency, branch
0001CA8E 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001CA92 4E75                       		rts
0001CA94                            
0001CA94                            .detune
0001CA94 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001CA98 4880                       		ext.w	d0			; extend to word
0001CA9A DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001CA9C                            
0001CA9C 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001CAA0 6700                       		beq.s	dUpdateFreqPSG2		; if not, branch
0001CAA2 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001CAA6                            
0001CAA6                            dUpdateFreqPSG2:
0001CAA6 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001CAAA 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001CAAC                            
0001CAAC                            dUpdateFreqPSG3:
0001CAAC 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001CAB0 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001CAB2                            
0001CAB2 102D 0001                  		move.b	cType(a5),d0		; load channel type value to d0
0001CAB6 0C00 00E0                  		cmpi.b	#ctPSG4,d0		; check if this channel is in PSG4 mode
0001CABA 6600                       		bne.s	.notPSG4		; if not, branch
0001CABC 70C0                       		moveq	#$FFFFFF00|ctPSG3,d0	; load PSG3 type value instead
0001CABE                            
0001CABE                            .notPSG4
0001CABE 3206                       		move.w	d6,d1			; copy frequency to d1
0001CAC0 0201 000F                  		andi.b	#$F,d1			; get the low nibble of it
0001CAC4 8001                       		or.b	d1,d0			; combine with channel type
0001CAC6                            ; ---------------------------------------------------------------------------
0001CAC6                            ; Note about the and instruction below: If this instruction is
0001CAC6                            ; not commented out, the instashield SFX will not sound correct.
0001CAC6                            ; This instruction was removed in Sonic 3K because of this, but
0001CAC6                            ; this can cause issues when values overflow the valid range of
0001CAC6                            ; PSG frequency. This may cause erroneous behavior if not anded,
0001CAC6                            ; but will also make the instashield SFX not sound correctly.
0001CAC6                            ; Comment out the instruction with caution, if you are planning
0001CAC6                            ; to port said sound effect to this driver. This has not caused
0001CAC6                            ; any issues for me, and if you are careful you can avoid any
0001CAC6                            ; such case, but beware of this issue!
0001CAC6                            ; ---------------------------------------------------------------------------
0001CAC6                            
0001CAC6 E84E                       		lsr.w	#4,d6			; get the 2 higher nibbles of frequency
0001CAC8 0206 003F                  		andi.b	#$3F,d6			; clear any extra bits that aren't valid
0001CACC 13C0 00C0 0011             		move.b	d0,dPSG			; write frequency low nibble and latch channel
0001CAD2 13C6 00C0 0011             		move.b	d6,dPSG			; write frequency high nibbles to PSG
0001CAD8                            
0001CAD8                            locret_dUpdateFreqPSG:
0001CAD8 4E75                       		rts
0001CADA                            ; ===========================================================================
0001CADA                            ; ---------------------------------------------------------------------------
0001CADA                            ; Routine for running envelope programs
0001CADA                            ; ---------------------------------------------------------------------------
0001CADA                            
0001CADA                            dEnvProgPSG:
0001CADA 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001CADE DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001CAE2                            
0001CAE2 7800                       		moveq	#0,d4
0001CAE4 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001CAE8 6700                       		beq.s	dUpdateVolPSG2		; if 0, update volume only
0001CAEA 6000                       		bra.s	dEnvProgPSG2		; continue to run code below
0001CAEC                            
0001CAEC                            dEnvelopePSG:
0001CAEC 7800                       		moveq	#0,d4
0001CAEE 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001CAF2 6700                       		beq.s	locret_UpdVolPSG	; if 0, return
0001CAF4                            
0001CAF4 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001CAF8 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001CAFC                            
0001CAFC                            dEnvProgPSG2:
0001CAFC                            
0001CAFC 43FA 0000                  		lea	VolEnvs-4(pc),a1	; load volume envelope data array
0001CB00 D844                       		add.w	d4,d4			; quadruple volume envelope ID
0001CB02 D844                       		add.w	d4,d4			; (each entry is 4 bytes in size)
0001CB04 2271 4000                  		move.l	(a1,d4.w),a1		; get pointer to volume envelope data
0001CB08                            
0001CB08 7200                       		moveq	#0,d1
0001CB0A 7000                       		moveq	#0,d0
0001CB0C                            
0001CB0C                            dEnvProgPSG3:
0001CB0C 122D 0006                  		move.b	cEnvPos(a5),d1		; get envelope position to d1
0001CB10 1031 1000                  		move.b	(a1,d1.w),d0		; get the date in that position
0001CB14 6B00                       		bmi.s	dEnvCommand		; if it is a command, handle it
0001CB16                            
0001CB16 522D 0006                  		addq.b	#1,cEnvPos(a5)		; increment envelope position
0001CB1A DA00                       		add.b	d0,d5			; add envelope volume to d5
0001CB1C                            	; continue to update PSG volume
0001CB1C                            ; ===========================================================================
0001CB1C                            ; ---------------------------------------------------------------------------
0001CB1C                            ; Routine for updating PSG volume to hardware
0001CB1C                            ; ---------------------------------------------------------------------------
0001CB1C                            
0001CB1C                            dUpdateVolPSG2:
0001CB1C 0C05 000F                  		cmpi.b	#$F,d5			; check if volume is out of range
0001CB20 6300                       		bls.s	dUpdateVolPSG		; if not, branch
0001CB22 7A0F                       		moveq	#$F,d5			; cap volume to silent
0001CB24                            
0001CB24                            dUpdateVolPSG:
0001CB24 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001CB28 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001CB2A 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001CB2E 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001CB30                            
0001CB30 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001CB34 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001CB36 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this is a SFX channel
0001CB3A 6400                       		bhs.s	dUpdVolPSGset		; if so, update volume
0001CB3C                            
0001CB3C 4A2D 001D                  		tst.b	cNoteTimeMain(a5)	; check if note timeout is active
0001CB40 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001CB42 4A2D 001C                  		tst.b	cNoteTimeCur(a5)	; is note stopped already?
0001CB46 6700                       		beq.s	locret_UpdVolPSG	; if is, do not update
0001CB48                            
0001CB48                            dUpdVolPSGset:
0001CB48 8A2D 0001                  		or.b	cType(a5),d5		; combine channel type value with volume
0001CB4C 0605 0010                  		addi.b	#$10,d5			; set volume update bit
0001CB50 13C5 00C0 0011             		move.b	d5,dPSG			; write volume command to PSG port
0001CB56                            
0001CB56                            locret_UpdVolPSG:
0001CB56 4E75                       		rts
0001CB58                            ; ===========================================================================
0001CB58                            ; ---------------------------------------------------------------------------
0001CB58                            ; Subroutine for handling volume envelope commands
0001CB58                            ; ---------------------------------------------------------------------------
0001CB58                            
0001CB58                            dEnvCommand:
0001CB58                            
0001CB58 4EFB 0000                  		jmp	.comm-$80(pc,d0.w)	; jump to command handler
0001CB5C                            
0001CB5C                            .comm
0001CB5C 6000                       		bra.s	.reset			; 80 - Loop back to beginning
0001CB5E 6000                       		bra.s	.hold			; 82 - Hold the envelope at current level
0001CB60 6000                       		bra.s	.loop			; 84 - Go to position defined by the next byte
0001CB62                            	;	bra.s	.stop			; 86 - Stop current note and envelope
0001CB62                            ; ---------------------------------------------------------------------------
0001CB62                            
0001CB62                            .stop
0001CB62 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting bit
0001CB66 6000                       		bra.s	dMutePSGmus		; nute the channel
0001CB68                            ; ---------------------------------------------------------------------------
0001CB68                            
0001CB68                            .hold
0001CB68 532D 0006                  		subq.b	#1,cEnvPos(a5)		; decrease envelope position
0001CB6C 4EFA FF9E                  		jmp	dEnvProgPSG3(pc)	; run the program again (make sure volume fades work)
0001CB70                            ; ---------------------------------------------------------------------------
0001CB70                            
0001CB70                            .reset
0001CB70 422D 0006                  		clr.b	cEnvPos(a5)		; set envelope position to 0
0001CB74 4EFA FF96                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001CB78                            ; ---------------------------------------------------------------------------
0001CB78                            
0001CB78                            .loop
0001CB78 1B71 1001 0006             		move.b	1(a1,d1.w),cEnvPos(a5)	; set envelope position to the next byte
0001CB7E 4EFA FF8C                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001CB82                            ; ===========================================================================
0001CB82                            ; ---------------------------------------------------------------------------
0001CB82                            ; Routine for hardware muting a PSG channel
0001CB82                            ; ---------------------------------------------------------------------------
0001CB82                            
0001CB82                            dMutePSGmus:
0001CB82 0815 0001                  		btst	#cfbInt,(a5)		; check if this is a SFX channel
0001CB86 6600                       		bne.s	locret_MutePSG		; if yes, do not update
0001CB88                            
0001CB88                            dMutePSGsfx:
0001CB88 701F                       		moveq	#$1F,d0			; prepare volume update to mute value to d0
0001CB8A 802D 0001                  		or.b	cType(a5),d0		; combine channel type value with d0
0001CB8E 13C0 00C0 0011             		move.b	d0,dPSG			; write volume command to PSG port
0001CB94                            
0001CB94                            locret_MutePSG:
0001CB94 4E75                       		rts
0001CB96                            
0001CB96 414D 5053 2031 2E30        	dc.b "AMPS 1.0"				; not required, just here to make my life easier
0001CB9E                            ; ===========================================================================
0001CB9E                            ; ---------------------------------------------------------------------------
0001CB9E                            ; Routine to execute tracker commands
0001CB9E                            ;
0001CB9E                            ; The reason we use add.b instead of add.w, is to get rid of some bits that
0001CB9E                            ; would make this kind of arbitary jumping way more complex than it needs to be.
0001CB9E                            ; What do we win by doing this? Why, 8 cycles per command! Thats... Not a lot,
0001CB9E                            ; but it may be helpful with speed anyway.
0001CB9E                            ; ---------------------------------------------------------------------------
0001CB9E                            
0001CB9E                            dCommands:
0001CB9E DA05                       		add.b	d5,d5			; quadruple command ID
0001CBA0 DA05                       		add.b	d5,d5			; since each entry is 4 bytes large
0001CBA2                            
0001CBA2 0815 0004                  		btst	#cfbCond,(a5)		; check if condition state
0001CBA6 6600 0000                  		bne.w	.falsecomm		; branch if false
0001CBAA 4EFB 5000                  		jmp	.comm-$80(pc,d5.w)	; jump to appropriate handler
0001CBAE                            ; ===========================================================================
0001CBAE                            ; ---------------------------------------------------------------------------
0001CBAE                            ; Command handlers for normal execution
0001CBAE                            ; ---------------------------------------------------------------------------
0001CBAE                            
0001CBAE                            .comm
0001CBAE 6000 0000                  	bra.w	dcPan		; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001CBB2 6000 0000                  	bra.w	dcsDetune	; E1 - Set channel frequency displacement to xx (DETUNE_SET)
0001CBB6 6000 0000                  	bra.w	dcaDetune	; E2 - Add xx to channel frequency displacement (DETUNE)
0001CBBA 6000 0000                  	bra.w	dcsTransp	; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001CBBE 6000 0000                  	bra.w	dcaTransp	; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001CBC2 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001CBC6 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001CBCA 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001CBCE 6000 0000                  	bra.w	dcVoice		; E8 - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001CBD2 6000 0000                  	bra.w	dcsTempoShoes	; E9 - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
0001CBD6 6000 0000                  	bra.w	dcsTempo	; EA - Set music tempo to xx (TEMPO - TEMPO_SET)
0001CBDA 6000 0000                  	bra.w	dcModOn		; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001CBDE 6000 0000                  	bra.w	dcModOff	; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001CBE2 6000 0000                  	bra.w	dcaVolume	; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001CBE6 6000 0000                  	bra.w	dcsVolume	; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001CBEA 6000 0000                  	bra.w	dcsLFO		; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001CBEE 6000 0000                  	bra.w	dcMod68K	; F0 - Modulation (MOD_SETUP)
0001CBF2 6000 0000                  	bra.w	dcSampDAC	; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001CBF6 6000 0000                  	bra.w	dcPitchDAC	; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001CBFA 6000 0000                  	bra.w	dcNoisePSG	; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_AMPS)
0001CBFE 6000 0000                  	bra.w	dcCont		; F4 - Do a continuous SFX loop (CONT_SFX)
0001CC02 6000 0000                  	bra.w	dcStop		; F5 - End of channel (TRK_END - TEND_STD)
0001CC06 6000 0000                  	bra.w	dcJump		; F6 - Jump to xxxx (GOTO)
0001CC0A 6000 0000                  	bra.w	dcLoop		; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001CC0E 6000 0000                  	bra.w	dcCall		; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001CC12 6000 0000                  	bra.w	dcReturn	; F9 - Return (RETURN)
0001CC16 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001CC1A 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001CC1E 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COMM_RESET)
0001CC22 6000 0000                  	bra.w	dcTimeout	; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001CC26 6000 0000                  	bra.w	dcYM		; FE - YM command (YMCMD)
0001CC2A                            				; FF - META
0001CC2A                            ; ===========================================================================
0001CC2A                            ; ---------------------------------------------------------------------------
0001CC2A                            ; Routine to execute tracker meta and false condition commands
0001CC2A                            ; ---------------------------------------------------------------------------
0001CC2A                            
0001CC2A                            .metacall
0001CC2A 1A1C                       		move.b	(a4)+,d5		; get next command byte
0001CC2C DA45                       		add.w	d5,d5			; quadruple ID
0001CC2E DA45                       		add.w	d5,d5			; since each entry is again 4 bytes large
0001CC30 4EFB 5000                  		jmp	.meta(pc,d5.w)		; jump to appropriate meta handler
0001CC34                            
0001CC34                            .falsecomm
0001CC34 4EFB 5000                  		jmp	.false-$80(pc,d5.w)	; jump to appropriate handler (false command)
0001CC38                            ; ===========================================================================
0001CC38                            ; ---------------------------------------------------------------------------
0001CC38                            ; Command handlers for meta commands
0001CC38                            ; ---------------------------------------------------------------------------
0001CC38                            
0001CC38                            .meta
0001CC38 6000 0000                  	bra.w	dcWriteDAC1	; FF 00 - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
0001CC3C 6000 0000                  	bra.w	dcWriteDAC2	; FF 01 - Play sample xx on DAC2 (PLAY_DAC - PLAY_DAC2)
0001CC40 6000 0000                  	bra.w	dcsFreq		; FF 02 - Set channel frequency to xxxx (CHFREQ_SET)
0001CC44 6000 0000                  	bra.w	dcsFreqNote	; FF 03 - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
0001CC48 6000 0000                  	bra.w	dcSpRev		; FF 04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
0001CC4C 6000 0000                  	bra.w	dcSpReset	; FF 05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
0001CC50 6000 0000                  	bra.w	dcaTempoShoes	; FF 06 - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
0001CC54 6000 0000                  	bra.w	dcaTempo	; FF 07 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001CC58 6000 0000                  	bra.w	dcCondReg	; FF 08 - Get RAM table offset by y, and chk zz with cond x (COMM_CONDITION - COMM_SPEC)
0001CC5C 6000 0000                  	bra.w	dcSound		; FF 09 - Play another music/sfx (SND_CMD)
0001CC60 6000 0000                  	bra.w	dcFreqOn	; FF 0A - Enable raw frequency mode (RAW_FREQ)
0001CC64 6000 0000                  	bra.w	dcFreqOff	; FF 0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
0001CC68 6000 0000                  	bra.w	dcSpecFM3	; FF 0C - Enable FM3 special mode (SPC_FM3)
0001CC6C 6000 0000                  	bra.w	dcFilter	; FF 0D - Set DAC filter bank. (DAC_FILTER)
0001CC70                            
0001CC70                            ; ===========================================================================
0001CC70                            ; ---------------------------------------------------------------------------
0001CC70                            ; Command handlers for false condition execution
0001CC70                            ; ---------------------------------------------------------------------------
0001CC70                            
0001CC70                            .false
0001CC70 524C                       	addq.w	#1,a4
0001CC72 4E75                       	rts			; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001CC74 524C                       	addq.w	#1,a4
0001CC76 4E75                       	rts			; E1 - Add xx to channel frequency displacement (DETUNE)
0001CC78 524C                       	addq.w	#1,a4
0001CC7A 4E75                       	rts			; E2 - Add xx to channel frequency displacement (DETUNE)
0001CC7C 524C                       	addq.w	#1,a4
0001CC7E 4E75                       	rts			; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001CC80 524C                       	addq.w	#1,a4
0001CC82 4E75                       	rts			; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001CC84 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001CC88 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001CC8C 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001CC90 524C                       	addq.w	#1,a4
0001CC92 4E75                       	rts			; E8 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001CC94 524C                       	addq.w	#1,a4
0001CC96 4E75                       	rts			; E9 - Set music tempo to xx (TEMPO - TEMPO_SET)
0001CC98 524C                       	addq.w	#1,a4
0001CC9A 4E75                       	rts			; EA - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001CC9C 4E75                       	rts
0001CC9E 4E75                       	rts			; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001CCA0 4E75                       	rts
0001CCA2 4E75                       	rts			; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001CCA4 524C                       	addq.w	#1,a4
0001CCA6 4E75                       	rts			; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001CCA8 524C                       	addq.w	#1,a4
0001CCAA 4E75                       	rts			; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001CCAC 524C                       	addq.w	#1,a4
0001CCAE 4E75                       	rts			; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001CCB0 584C                       	addq.w	#4,a4
0001CCB2 4E75                       	rts			; F0 - Modulation (MOD_SETUP)
0001CCB4 4E75                       	rts
0001CCB6 4E75                       	rts			; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001CCB8 4E75                       	rts
0001CCBA 4E75                       	rts			; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001CCBC 524C                       	addq.w	#1,a4
0001CCBE 4E75                       	rts			; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_SET)
0001CCC0 544C                       	addq.w	#2,a4
0001CCC2 4E75                       	rts			; F4 - Do a continuous SFX loop (CONT_SFX)
0001CCC4 4E75                       	rts
0001CCC6 4E75                       	rts			; F5 - End of channel (TRK_END - TEND_STD)
0001CCC8 544C                       	addq.w	#2,a4
0001CCCA 4E75                       	rts			; F6 - Jump to xxxx (GOTO)
0001CCCC 584C                       	addq.w	#4,a4
0001CCCE 4E75                       	rts			; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001CCD0 544C                       	addq.w	#2,a4
0001CCD2 4E75                       	rts			; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001CCD4 4E75                       	rts
0001CCD6 4E75                       	rts			; F9 - Return (RETURN)
0001CCD8 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001CCDC 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001CCE0 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COND_RESET)
0001CCE4 524C                       	addq.w	#1,a4
0001CCE6 4E75                       	rts			; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001CCE8 524C                       	addq.w	#1,a4
0001CCEA 4E75                       	rts			; FE - YM command (YMCMD)
0001CCEC 6000 FF3C                  	bra.w	.metacall	; FF - META
0001CCF0                            ; ===========================================================================
0001CCF0                            ; ---------------------------------------------------------------------------
0001CCF0                            ; Tracker commands for writing direct DAC samples to Dual PCM.
0001CCF0                            ; Note that this will override any DAC already being played,
0001CCF0                            ; and in turn trackers may override these DAC samples at any
0001CCF0                            ; time. Use with caution!
0001CCF0                            ; ---------------------------------------------------------------------------
0001CCF0                            
0001CCF0                            dcWriteDAC1:
0001CCF0 7000                       		moveq	#0,d0
0001CCF2 101C                       		move.b	(a4)+,d0		; get note to write
0001CCF4 4EFA EA98                  		jmp	dNoteWriteDAC1(pc)	; note-on
0001CCF8                            
0001CCF8                            dcWriteDAC2:
0001CCF8 7000                       		moveq	#0,d0
0001CCFA 101C                       		move.b	(a4)+,d0		; get note to write
0001CCFC 4EFA EA82                  		jmp	dNoteWriteDAC2(pc)	; note-on
0001CD00                            ; ===========================================================================
0001CD00                            ; ---------------------------------------------------------------------------
0001CD00                            ; Tracker commands for handling spindash revving.
0001CD00                            ; The way spindash revving works, is it actually just
0001CD00                            ; increments a counter each time, and this counter is
0001CD00                            ; added into the channel pitch offset.
0001CD00                            ; ---------------------------------------------------------------------------
0001CD00                            
0001CD00                            dcSpRev:
0001CD00 1038 C4C1                  		move.b	mSpindash.w,d0		; load spindash rev counter to d0
0001CD04 5238 C4C1                  		addq.b	#1,mSpindash.w		; increment spindash rev counter
0001CD08 D12D 0008                  		add.b	d0,cPitch(a5)		; add d0 to channel pitch offset
0001CD0C                            
0001CD0C 0C00 000B                  		cmp.b	#$C-1,d0		; check if this is the max pitch offset
0001CD10 6500                       		blo.s	.rts			; if not, skip
0001CD12 5338 C4C1                  		subq.b	#1,mSpindash.w		; cap at pitch offset $C
0001CD16                            
0001CD16                            .rts
0001CD16 4E75                       		rts
0001CD18                            
0001CD18                            dcSpReset:
0001CD18 4238 C4C1                  		clr.b	mSpindash.w		; reset spindash rev counter
0001CD1C 4E75                       		rts
0001CD1E                            ; ===========================================================================
0001CD1E                            ; ---------------------------------------------------------------------------
0001CD1E                            ; Tracker command for changing channel panning
0001CD1E                            ; ---------------------------------------------------------------------------
0001CD1E                            
0001CD1E                            dcPan:
0001CD1E                            
0001CD1E 7237                       		moveq	#$37,d1			; prepare bits to keep
0001CD20 C22D 0006                  		and.b	cPanning(a5),d1		; and with channel LFO settings
0001CD24 821C                       		or.b	(a4)+,d1		; or panning value
0001CD26 1B41 0006                  		move.b	d1,cPanning(a5)		; save as channel panning
0001CD2A                            
0001CD2A 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001CD2C 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001CD32 6700 F774                  		beq.w	dWriteYMchnInt		; if not, write channel-specific YM command
0001CD36                            ; ---------------------------------------------------------------------------
0001CD36                            ; Since the DAC channels have or based panning behavior, we need this
0001CD36                            ; piece of code to update its panning
0001CD36                            ; ---------------------------------------------------------------------------
0001CD36                            
0001CD36 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001CD3A 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001CD40 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001CD42 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001CD46                            
0001CD46                            .nodacsfx
0001CD46 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001CD4A 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001CD4C 4EFA F798                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001CD50                            ; ===========================================================================
0001CD50                            ; ---------------------------------------------------------------------------
0001CD50                            ; Tracker commands for changing detune offset
0001CD50                            ; ---------------------------------------------------------------------------
0001CD50                            
0001CD50                            dcaDetune:
0001CD50 101C                       		move.b	(a4)+,d0		; load detune offset from tracker
0001CD52 D12D 0007                  		add.b	d0,cDetune(a5)		; Add to channel detune offset
0001CD56 4E75                       		rts
0001CD58                            
0001CD58                            dcsDetune:
0001CD58 1B5C 0007                  		move.b	(a4)+,cDetune(a5)	; load detune offset from tracker to channel
0001CD5C 4E75                       		rts
0001CD5E                            ; ===========================================================================
0001CD5E                            ; ---------------------------------------------------------------------------
0001CD5E                            ; Tracker command for changing channel volume
0001CD5E                            ; ---------------------------------------------------------------------------
0001CD5E                            
0001CD5E                            dcsVolume:
0001CD5E 1B5C 0009                  		move.b	(a4)+,cVolume(a5)	; load volume from tracker to channel
0001CD62 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001CD66 4E75                       		rts
0001CD68                            
0001CD68                            dcaVolume:
0001CD68 101C                       		move.b	(a4)+,d0		; load volume from tracker
0001CD6A D12D 0009                  		add.b	d0,cVolume(a5)		; add to channel volume
0001CD6E 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001CD72 4E75                       		rts
0001CD74                            ; ===========================================================================
0001CD74                            ; ---------------------------------------------------------------------------
0001CD74                            ; Tracker command for setting DAC to sample mode and resetting frequency
0001CD74                            ; ---------------------------------------------------------------------------
0001CD74                            
0001CD74                            dcSampDAC:
0001CD74 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; reset to defualt base frequency
0001CD7A 0895 0000                  		bclr	#cfbMode,(a5)		; enable sample mode
0001CD7E 4E75                       		rts
0001CD80                            ; ===========================================================================
0001CD80                            ; ---------------------------------------------------------------------------
0001CD80                            ; Tracker command for setting DAC to pitch mode
0001CD80                            ; ---------------------------------------------------------------------------
0001CD80                            
0001CD80                            dcPitchDAC:
0001CD80 08D5 0000                  		bset	#cfbMode,(a5)		; enable pitch mode
0001CD84 4E75                       		rts
0001CD86                            ; ===========================================================================
0001CD86                            ; ---------------------------------------------------------------------------
0001CD86                            ; Tracker commands for changing channel tick multiplier
0001CD86                            ; ---------------------------------------------------------------------------
0001CD86                            
0001CD86                            dcsTmulCh:
0001CD86 1B5C 000A                  		move.b	(a4)+,cTick(a5)		; load tick multiplier from tracker to channel
0001CD8A 4E75                       		rts
0001CD8C                            
0001CD8C                            dcsTmul:
0001CD8C 101C                       		move.b	(a4)+,d0		; load tick multiplier from tracker to d0
0001CD8E =FFFFC4C4                  .x =	mDAC1					; start at DAC1
0001CD8E                            	rept Mus_Ch				; do for all music channels
0001CD8E                            		move.b	d0,cTick+.x.w		; set channel tick multiplier
0001CD8E                            .x =		.x+cSize			; go to next channel
0001CD8E                            	endr
0001CD8E 11C0 C4CE                M 	move.b	d0,ctick+.x.w
0001CD92 =FFFFC4F0                M .x	=	.x+csize
0001CD92 11C0 C4FA                M 	move.b	d0,ctick+.x.w
0001CD96 =FFFFC51C                M .x	=	.x+csize
0001CD96 11C0 C526                M 	move.b	d0,ctick+.x.w
0001CD9A =FFFFC548                M .x	=	.x+csize
0001CD9A 11C0 C552                M 	move.b	d0,ctick+.x.w
0001CD9E =FFFFC574                M .x	=	.x+csize
0001CD9E 11C0 C57E                M 	move.b	d0,ctick+.x.w
0001CDA2 =FFFFC5A0                M .x	=	.x+csize
0001CDA2 11C0 C5AA                M 	move.b	d0,ctick+.x.w
0001CDA6 =FFFFC5CC                M .x	=	.x+csize
0001CDA6 11C0 C5D6                M 	move.b	d0,ctick+.x.w
0001CDAA =FFFFC5F8                M .x	=	.x+csize
0001CDAA 11C0 C602                M 	move.b	d0,ctick+.x.w
0001CDAE =FFFFC624                M .x	=	.x+csize
0001CDAE 11C0 C62E                M 	move.b	d0,ctick+.x.w
0001CDB2 =FFFFC650                M .x	=	.x+csize
0001CDB2 11C0 C65A                M 	move.b	d0,ctick+.x.w
0001CDB6 =FFFFC67C                M .x	=	.x+csize
0001CDB6 4E75                       		rts
0001CDB8                            ; ===========================================================================
0001CDB8                            ; ---------------------------------------------------------------------------
0001CDB8                            ; Tracker command for enabling or disabling the hold flag
0001CDB8                            ; ---------------------------------------------------------------------------
0001CDB8                            
0001CDB8                            dcHold:
0001CDB8 0855 0002                  		bchg	#cfbHold,(a5)		; flip the channel hold flag
0001CDBC 4E75                       		rts
0001CDBE                            ; ===========================================================================
0001CDBE                            ; ---------------------------------------------------------------------------
0001CDBE                            ; Tracker command for enabling or disabling note timeout
0001CDBE                            ; ---------------------------------------------------------------------------
0001CDBE                            
0001CDBE                            dcTimeout:
0001CDBE                            
0001CDBE 1B54 001D                  		move.b	(a4),cNoteTimeMain(a5)	; load note timeout from tracker to channel
0001CDC2 1B5C 001C                  		move.b	(a4)+,cNoteTimeCur(a5)	; ''
0001CDC6 4E75                       		rts
0001CDC8                            ; ===========================================================================
0001CDC8                            ; ---------------------------------------------------------------------------
0001CDC8                            ; Tracker commands for changing channel pitch
0001CDC8                            ; ---------------------------------------------------------------------------
0001CDC8                            
0001CDC8                            dcaTransp:
0001CDC8 101C                       		move.b	(a4)+,d0		; load pitch offset from tracker
0001CDCA D12D 0008                  		add.b	d0,cPitch(a5)		; add to channel pitch offset
0001CDCE 4E75                       		rts
0001CDD0                            
0001CDD0                            dcsTransp:
0001CDD0 1B5C 0008                  		move.b	(a4)+,cPitch(a5)	; load pitch offset from tracker to channel
0001CDD4 4E75                       		rts
0001CDD6                            ; ===========================================================================
0001CDD6                            ; ---------------------------------------------------------------------------
0001CDD6                            ; Tracker commands for tempo control
0001CDD6                            ; ---------------------------------------------------------------------------
0001CDD6                            
0001CDD6                            dcsTempoShoes:
0001CDD6 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CDD8 11C0 C4B9                  		move.b	d0,mTempoSpeed.w	; save as the speed shoes tempo
0001CDDC 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CDE2 6600                       		bne.s	dcsTempoCur		; if is, load as current tempo too
0001CDE4 4E75                       		rts
0001CDE6                            
0001CDE6                            dcsTempo:
0001CDE6 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CDE8 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as the main tempo
0001CDEC 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CDF2 6600                       		bne.s	locret_Tempo		; if not, load as current tempo too
0001CDF4                            
0001CDF4                            dcsTempoCur:
0001CDF4 11C0 C4BA                  		move.b	d0,mTempo.w		; save as current tempo
0001CDF8                            
0001CDF8                            locret_Tempo:
0001CDF8 4E75                       		rts
0001CDFA                            
0001CDFA                            dcaTempoShoes:
0001CDFA 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CDFC D138 C4B9                  		add.b	d0,mTempoSpeed.w	; add to the speed shoes tempo
0001CE00 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CE06 6600                       		bne.s	dcaTempoCur		; if is, add to current tempo too
0001CE08 4E75                       		rts
0001CE0A                            
0001CE0A                            dcaTempo:
0001CE0A 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001CE0C D138 C4B8                  		add.b	d0,mTempoMain.w		; add to the main tempo
0001CE10 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001CE16 66E0                       		bne.s	locret_Tempo		; if not, add to current tempo too
0001CE18                            
0001CE18                            dcaTempoCur:
0001CE18 D138 C4BA                  		add.b	d0,mTempo.w		; add to current tempo
0001CE1C 4E75                       		rts
0001CE1E                            ; ===========================================================================
0001CE1E                            ; ---------------------------------------------------------------------------
0001CE1E                            ; Tracker command for enabling or disabling PSG4 noise mode
0001CE1E                            ; ---------------------------------------------------------------------------
0001CE1E                            
0001CE1E                            dcNoisePSG:
0001CE1E 1B54 001B                  		move.b	(a4),cStatPSG4(a5)	; load PSG4 status command from tracker to channel
0001CE22 6700                       		beq.s	.psg3			; if disabling PSG4 mode, branch
0001CE24 1B7C 00E0 0001             		move.b	#ctPSG4,cType(a5)	; make PSG3 act on behalf of PSG4
0001CE2A 13DC 00C0 0011             		move.b	(a4)+,dPSG		; send command to PSG port
0001CE30 4E75                       		rts
0001CE32                            
0001CE32                            .psg3
0001CE32 1B7C 00C0 0001             		move.b	#ctPSG3,cType(a5)	; make PSG3 not act on behalf of PSG4
0001CE38 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send PSG4 mute command to PSG
0001CE40 524C                       		addq.w	#1,a4			; skip param
0001CE42 4E75                       		rts
0001CE44                            ; ===========================================================================
0001CE44                            ; ---------------------------------------------------------------------------
0001CE44                            ; Tracker command for playing another music or SFX
0001CE44                            ; ---------------------------------------------------------------------------
0001CE44                            
0001CE44                            dcSound:
0001CE44 11DC C4BE                  		move.b	(a4)+,mQueue+2.w	; load sound ID from tracker to sound queue
0001CE48                            
0001CE48                            Return_dcSound:
0001CE48 4E75                       		rts
0001CE4A                            ; ===========================================================================
0001CE4A                            ; ---------------------------------------------------------------------------
0001CE4A                            ; Tracker command for setting DAC filter bank
0001CE4A                            ; ---------------------------------------------------------------------------
0001CE4A                            
0001CE4A                            dcFilter:
0001CE4A 7000                       		moveq	#0,d0
0001CE4C 101C                       		move.b	(a4)+,d0		; load filter bank number from tracker
0001CE4E 4EFA F23E                  		jmp	dSetFilter(pc)		; load filter bank instructions to Z80 RAM
0001CE52                            ; ===========================================================================
0001CE52                            ; ---------------------------------------------------------------------------
0001CE52                            ; Tracker command for writing a YM command to YMCue
0001CE52                            ; ---------------------------------------------------------------------------
0001CE52                            
0001CE52                            dcYM:
0001CE52 101C                       		move.b	(a4)+,d0		; load YM address from tracker to d0
0001CE54 121C                       		move.b	(a4)+,d1		; get command value from tracker to d1
0001CE56 0815 0001                  		btst	#cfbInt,(a5)		; is this channel overridden by SFX?
0001CE5A 66EC                       		bne.s	Return_dcSound		; if so, skip
0001CE5C                            
0001CE5C 0C00 0030                  		cmp.b	#$30,d0			; is this register 00-2F?
0001CE60 6500 F658                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001CE64                            
0001CE64 1400                       		move.b	d0,d2			; copy address to d2
0001CE66 0402 00A8                  		sub.b	#$A8,d2			; align $A8 with 0
0001CE6A 0C02 0008                  		cmp.b	#$08,d2			; is this egister A8-AF?
0001CE6E 6500 F64A                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001CE72 4EFA F63A                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001CE76                            ; ===========================================================================
0001CE76                            ; ---------------------------------------------------------------------------
0001CE76                            ; Tracker command for setting channel base frequency
0001CE76                            ; ---------------------------------------------------------------------------
0001CE76                            
0001CE76                            dcsFreq:
0001CE76 1B5C 000E                  		move.b	(a4)+,cFreq(a5)		; load base frequency from tracker to channel
0001CE7A 1B5C 000F                  		move.b	(a4)+,cFreq+1(a5)	; ''
0001CE7E                            
0001CE7E                            .rts
0001CE7E 4E75                       		rts
0001CE80                            ; ===========================================================================
0001CE80                            ; ---------------------------------------------------------------------------
0001CE80                            ; Tracker command for setting channel base frequency from the note table
0001CE80                            ; ---------------------------------------------------------------------------
0001CE80                            
0001CE80                            dcsFreqNote:
0001CE80 7000                       		moveq	#0,d0
0001CE82 101C                       		move.b	(a4)+,d0		; load note from tracker to d0
0001CE84 D02D 0008                  		add.b	cPitch(a5),d0		; add pitch offset to note
0001CE88 D040                       		add.w	d0,d0			; double offset (each entry is a word)
0001CE8A                            
0001CE8A 43FA F73E                  		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001CE8E 3B71 0000 000E             		move.w	(a1,d0.w),cFreq(a5)	; load and save the requested frequency
0001CE94                            
0001CE94                            .rts
0001CE94 4E75                       		rts
0001CE96                            ; ===========================================================================
0001CE96                            ; ---------------------------------------------------------------------------
0001CE96                            ; Tracker command for doing a continous SFX loop
0001CE96                            ; ---------------------------------------------------------------------------
0001CE96                            
0001CE96                            dcCont:
0001CE96 5338 C4C2                  		subq.b	#1,mContCtr.w		; decrease continous sfx counter
0001CE9A 6A00                       		bpl.s	dcJump			; if positive, jump to routine
0001CE9C 4238 C4C3                  		clr.b	mContLast.w		; clear continous SFX ID
0001CEA0 544C                       		addq.w	#2,a4			; skip over jump offset
0001CEA2 4E75                       		rts
0001CEA4                            ; ===========================================================================
0001CEA4                            ; ---------------------------------------------------------------------------
0001CEA4                            ; Tracker command for calling a tracker subroutine
0001CEA4                            ; ---------------------------------------------------------------------------
0001CEA4                            
0001CEA4                            dcCall:
0001CEA4                            
0001CEA4 7000                       		moveq	#0,d0
0001CEA6 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001CEAA 5900                       		subq.b	#4,d0			; allocate space for another routine
0001CEAC                            
0001CEAC 2B8C 0000                  		move.l	a4,(a5,d0.w)		; save current address in stack
0001CEB0 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001CEB4                            ; ===========================================================================
0001CEB4                            ; ---------------------------------------------------------------------------
0001CEB4                            ; Tracker command for jumping to another tracker location
0001CEB4                            ; ---------------------------------------------------------------------------
0001CEB4                            
0001CEB4                            dcJump:
0001CEB4                            	dREAD_WORD a4, d0			; read a word from tracker to d0
0001CEB4 1E9C                     M 	move.b	(a4)+,(sp)
0001CEB6 3017                     M 	move.w	(sp),d0
0001CEB8 1014                     M 	move.b	(a4),d0
0001CEBA D8C0                       		adda.w	d0,a4			; offset tracker address by d0
0001CEBC 4E75                       		rts
0001CEBE                            ; ===========================================================================
0001CEBE                            ; ---------------------------------------------------------------------------
0001CEBE                            ; Tracker command for handling loops
0001CEBE                            ; ---------------------------------------------------------------------------
0001CEBE                            
0001CEBE                            dcLoop:
0001CEBE 7000                       		moveq	#0,d0
0001CEC0 101C                       		move.b	(a4)+,d0		; load loop index from tracker to d0
0001CEC2                            
0001CEC2 4A35 0019                  		tst.b	cLoop(a5,d0.w)		; check the loop counter
0001CEC6 6600                       		bne.s	.loopok			; if nonzero, branch
0001CEC8 1BAC 0002 0019             		move.b	2(a4),cLoop(a5,d0.w)	; reload loop counter
0001CECE                            
0001CECE                            .loopok
0001CECE 5335 0019                  		subq.b	#1,cLoop(a5,d0.w)	; decrease loop counter
0001CED2 66E0                       		bne.s	dcJump			; if not 0, jump to routine
0001CED4 564C                       		addq.w	#3,a4			; skip over jump offset
0001CED6 4E75                       		rts
0001CED8                            ; ===========================================================================
0001CED8                            ; ---------------------------------------------------------------------------
0001CED8                            ; Tracker command for initializing modulation
0001CED8                            ; ---------------------------------------------------------------------------
0001CED8                            
0001CED8                            dcMod68K:
0001CED8 2B4C 0010                  		move.l	a4,cMod(a5)		; set modulation data address
0001CEDC 1B5C 0010                  		move.b	(a4)+,cModDelay(a5)	; load modulation delay from tracker to channel
0001CEE0 1B5C 0016                  		move.b	(a4)+,cModSpeed(a5)	; load modulation speed from tracker to channel
0001CEE4 1B5C 0017                  		move.b	(a4)+,cModStep(a5)	; load modulation step offset from tracker to channel
0001CEE8                            
0001CEE8 101C                       		move.b	(a4)+,d0		; load modulation step count from tracker to d0
0001CEEA E208                       		lsr.b	#1,d0			; halve it
0001CEEC 1B40 0018                  		move.b	d0,cModCount(a5)	; save as modulation step count to channel
0001CEF0 426D 0014                  		clr.w	cModFreq(a5)		; reset modulation frequency offset to 0
0001CEF4                            	; continue to enabling modulation
0001CEF4                            ; ===========================================================================
0001CEF4                            ; ---------------------------------------------------------------------------
0001CEF4                            ; Tracker commands for enabling and disabling modulation
0001CEF4                            ; ---------------------------------------------------------------------------
0001CEF4                            
0001CEF4                            dcModOn:
0001CEF4 08D5 0003                  		bset	#cfbMod,(a5)		; enable modulation
0001CEF8 4E75                       		rts
0001CEFA                            
0001CEFA                            dcModOff:
0001CEFA 0895 0003                  		bclr	#cfbMod,(a5)		; disable modulation
0001CEFE 4E75                       		rts
0001CF00                            ; ===========================================================================
0001CF00                            ; ---------------------------------------------------------------------------
0001CF00                            ; Tracker command for returning from tracker subroutine
0001CF00                            ; ---------------------------------------------------------------------------
0001CF00                            
0001CF00                            dcReturn:
0001CF00 7000                       		moveq	#0,d0
0001CF02 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001CF06 2875 0000                  		movea.l	(a5,d0.w),a4		; load the address to return to
0001CF0A                            
0001CF0A 544C                       		addq.w	#2,a4			; skip the call address parameter
0001CF0C 5800                       		addq.b	#4,d0			; deallocate stack space
0001CF0E 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001CF12                            
0001CF12 4E75                       		rts
0001CF14                            ; ===========================================================================
0001CF14                            ; ---------------------------------------------------------------------------
0001CF14                            ; Tracker command for initializing special FM3 mode
0001CF14                            ; ---------------------------------------------------------------------------
0001CF14                            
0001CF14                            dcSpecFM3:
0001CF14 4E75                       		rts
0001CF16                            ; ===========================================================================
0001CF16                            ; ---------------------------------------------------------------------------
0001CF16                            ; Tracker command for enabling raw frequency mode
0001CF16                            ; ---------------------------------------------------------------------------
0001CF16                            
0001CF16                            dcFreqOn:
0001CF16 4E75                       		rts
0001CF18                            ; ===========================================================================
0001CF18                            ; ---------------------------------------------------------------------------
0001CF18                            ; Tracker command for disabling raw frequency mode
0001CF18                            ; ---------------------------------------------------------------------------
0001CF18                            
0001CF18                            dcFreqOff:
0001CF18                            
0001CF18                            locret_FreqOff:
0001CF18 4E75                       		rts
0001CF1A                            ; ===========================================================================
0001CF1A                            ; ---------------------------------------------------------------------------
0001CF1A                            ; Tracker command for changing voice, volume envelope or sample
0001CF1A                            ; ---------------------------------------------------------------------------
0001CF1A                            
0001CF1A                            dcVoice:
0001CF1A 7000                       		moveq	#0,d0
0001CF1C 101C                       		move.b	(a4)+,d0		; load voice/sample/volume envelope from tracker to d0
0001CF1E 1B40 000B                  		move.b	d0,cVoice(a5)		; save to channel
0001CF22                            
0001CF22 4A2D 0001                  		tst.b	cType(a5)		; check if this is a PSG channel
0001CF26 6BF0                       		bmi.s	locret_FreqOff		; if is, skip
0001CF28 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001CF2E 66E8                       		bne.s	locret_FreqOff		; if is, skip
0001CF30                            
0001CF30 0815 0001                  		btst	#cfbInt,(a5)		; check if channel is interrupted by SFX
0001CF34 66E2                       		bne.s	locret_FreqOff		; if is, skip
0001CF36 224E                       		move.l	a6,a1			; load voice table to a1
0001CF38                            	; continue to send FM voice
0001CF38                            ; ===========================================================================
0001CF38                            ; ---------------------------------------------------------------------------
0001CF38                            ; Subroutine for sending the FM voice to YM2612
0001CF38                            ; This routine is speed optimized in a way that allows Dual PCM
0001CF38                            ; to only be stopped for as long as it must be. This will waste
0001CF38                            ; some cycles for 68000, but it will help improve DAC quality.
0001CF38                            ; ---------------------------------------------------------------------------
0001CF38                            
0001CF38                            dUpdateVoiceFM:
0001CF38                            	dCALC_VOICE				; get address of the specific voice to a1
0001CF38 EB48                     M 	lsl.w	#5,d0
0001CF3A D2C0                     M 	add.w	d0,a1
0001CF3C 9EFC 003C                  		sub.w	#(VoiceRegs+1)*2,sp	; prepapre space in the stack
0001CF40 264F                       		move.l	sp,a3			; copy pointer to the free space to a3
0001CF42                            
0001CF42 1819                       		move.b	(a1)+,d4		; load feedback and algorithm to d4
0001CF44 16C4                       		move.b	d4,(a3)+		; save it to free space
0001CF46 16FC 00B0                  		move.b	#$B0,(a3)+		; YM command: Algorithm & FeedBack
0001CF4A                            
0001CF4A 45FA F262                  		lea	dOpListYM(pc),a2	; load YM2612 operator list into a2
0001CF4E                            	rept VoiceRegs-5
0001CF4E                            		move.b	(a1)+,(a3)+		; copy each value (except Total Level)
0001CF4E                            		move.b	(a2)+,(a3)+		; copy each command
0001CF4E                            	endr
0001CF4E 16D9                     M 	move.b	(a1)+,(a3)+
0001CF50 16DA                     M 	move.b	(a2)+,(a3)+
0001CF52 16D9                     M 	move.b	(a1)+,(a3)+
0001CF54 16DA                     M 	move.b	(a2)+,(a3)+
0001CF56 16D9                     M 	move.b	(a1)+,(a3)+
0001CF58 16DA                     M 	move.b	(a2)+,(a3)+
0001CF5A 16D9                     M 	move.b	(a1)+,(a3)+
0001CF5C 16DA                     M 	move.b	(a2)+,(a3)+
0001CF5E 16D9                     M 	move.b	(a1)+,(a3)+
0001CF60 16DA                     M 	move.b	(a2)+,(a3)+
0001CF62 16D9                     M 	move.b	(a1)+,(a3)+
0001CF64 16DA                     M 	move.b	(a2)+,(a3)+
0001CF66 16D9                     M 	move.b	(a1)+,(a3)+
0001CF68 16DA                     M 	move.b	(a2)+,(a3)+
0001CF6A 16D9                     M 	move.b	(a1)+,(a3)+
0001CF6C 16DA                     M 	move.b	(a2)+,(a3)+
0001CF6E 16D9                     M 	move.b	(a1)+,(a3)+
0001CF70 16DA                     M 	move.b	(a2)+,(a3)+
0001CF72 16D9                     M 	move.b	(a1)+,(a3)+
0001CF74 16DA                     M 	move.b	(a2)+,(a3)+
0001CF76 16D9                     M 	move.b	(a1)+,(a3)+
0001CF78 16DA                     M 	move.b	(a2)+,(a3)+
0001CF7A 16D9                     M 	move.b	(a1)+,(a3)+
0001CF7C 16DA                     M 	move.b	(a2)+,(a3)+
0001CF7E 16D9                     M 	move.b	(a1)+,(a3)+
0001CF80 16DA                     M 	move.b	(a2)+,(a3)+
0001CF82 16D9                     M 	move.b	(a1)+,(a3)+
0001CF84 16DA                     M 	move.b	(a2)+,(a3)+
0001CF86 16D9                     M 	move.b	(a1)+,(a3)+
0001CF88 16DA                     M 	move.b	(a2)+,(a3)+
0001CF8A 16D9                     M 	move.b	(a1)+,(a3)+
0001CF8C 16DA                     M 	move.b	(a2)+,(a3)+
0001CF8E 16D9                     M 	move.b	(a1)+,(a3)+
0001CF90 16DA                     M 	move.b	(a2)+,(a3)+
0001CF92 16D9                     M 	move.b	(a1)+,(a3)+
0001CF94 16DA                     M 	move.b	(a2)+,(a3)+
0001CF96 16D9                     M 	move.b	(a1)+,(a3)+
0001CF98 16DA                     M 	move.b	(a2)+,(a3)+
0001CF9A 16D9                     M 	move.b	(a1)+,(a3)+
0001CF9C 16DA                     M 	move.b	(a2)+,(a3)+
0001CF9E 16D9                     M 	move.b	(a1)+,(a3)+
0001CFA0 16DA                     M 	move.b	(a2)+,(a3)+
0001CFA2 16D9                     M 	move.b	(a1)+,(a3)+
0001CFA4 16DA                     M 	move.b	(a2)+,(a3)+
0001CFA6 16D9                     M 	move.b	(a1)+,(a3)+
0001CFA8 16DA                     M 	move.b	(a2)+,(a3)+
0001CFAA 16D9                     M 	move.b	(a1)+,(a3)+
0001CFAC 16DA                     M 	move.b	(a2)+,(a3)+
0001CFAE                            
0001CFAE 7C00                       		moveq	#0,d6			; reset the modulator offset
0001CFB0 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001CFB4 D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001CFB8 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001CFBA 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001CFBC                            
0001CFBC                            .noover
0001CFBC 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001CFC2 6700                       		beq.s	.uwdone			; if not, skip
0001CFC4 1C04                       		move.b	d4,d6			; copy algorithm and feedback to d6
0001CFC6 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001CFCA D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001CFCC 1C04                       		move.b	d4,d6			; set algorithm and feedback to modulator offset
0001CFCE                            
0001CFCE                            .uwdone
0001CFCE 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001CFD0                            
0001CFD0                            .tlloop
0001CFD0 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001CFD2 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001CFD4                            
0001CFD4 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001CFD6 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001CFD8 727F                       		moveq	#$7F,d1			; cap to silent volume
0001CFDA 6000                       		bra.s	.slot
0001CFDC                            
0001CFDC                            .noslot
0001CFDC D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001CFDE                            .slot
0001CFDE 16C1                       		move.b	d1,(a3)+		; save the Total Level value
0001CFE0 16DA                       		move.b	(a2)+,(a3)+		; copy total level command
0001CFE2 51CD FFEC                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001CFE6                            
0001CFE6                            
0001CFE6 0895 0005                  		bclr	#cfbVol,(a5)		; reset volume update request flag
0001CFEA 16ED 0006                  		move.b	cPanning(a5),(a3)+	; copy panning value to free space
0001CFEE 16FC 00B4                  		move.b	#$B4,(a3)+		; YM command: Panning & LFO
0001CFF2                            
0001CFF2 7400                       		moveq	#0,d2			; prepare part 1 value
0001CFF4 162D 0001                  		move.b	cType(a5),d3		; load FM channel type to d3
0001CFF8 0803 0002                  		btst	#ctbPt2,d3		; check if its part 1
0001CFFC 6700                       		beq.s	.ptok			; if so, branch
0001CFFE 0203 0003                  		and.b	#3,d3			; get channel offset only
0001D002 7402                       		moveq	#2,d2			; prepare part 2 value
0001D004                            
0001D004                            .ptok
0001D004 264F                       		move.l	sp,a3			; copy free space pointer to a3 again
0001D006 721D                       		moveq	#VoiceRegs,d1		; prepare loop point
0001D008                            	StopZ80					; wait for Z80 to stop
0001D008 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001D010                          M 	waitz80stop
0001D010 0839 0000 00A1 1100      M .wait_360:	btst	#0,z80_bus_req
0001D018 66F6                     M 	bne.s	.wait_360
0001D01A                            
0001D01A                            .write
0001D01A 10C2                       		move.b	d2,(a0)+		; select YM port to access (4000 or 4002)
0001D01C 10DB                       		move.b	(a3)+,(a0)+		; write command values
0001D01E                            
0001D01E 101B                       		move.b	(a3)+,d0		; load YM command
0001D020 8003                       		or.b	d3,d0			; add the channel offset to command
0001D022 10C0                       		move.b	d0,(a0)+		; save to Z80 cue
0001D024 51C9 FFF4                  		dbf	d1,.write		; write all registers
0001D028 50D0                       		st	(a0)			; mark as end of the cue
0001D02A                            
0001D02A                            	StartZ80				; enable Z80 execution
0001D02A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001D032 DEFC 003C                  		add.w	#(VoiceRegs+1)*2,sp	; reset stack pointer
0001D036 4E75                       		rts
0001D038                            ; ===========================================================================
0001D038                            ; ---------------------------------------------------------------------------
0001D038                            ; Tracker command for stopping the current channel
0001D038                            ; ---------------------------------------------------------------------------
0001D038                            
0001D038                            dcStop:
0001D038 0215 007B                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRun),(a5); clear hold and running tracker flags
0001D03C 4A2D 0001                  		tst.b	cType(a5)		; check if this was a PSG channel
0001D040 6B00                       		bmi.s	.mutePSG		; if yes, mute it
0001D042                            
0001D042 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this was a DAC channel
0001D048 6600                       		bne.s	.cont			; if we are, skip
0001D04A 4EBA F448                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001D04E 6000                       		bra.s	.cont
0001D050                            ; ---------------------------------------------------------------------------
0001D050                            
0001D050                            .mutePSG
0001D050 4EBA FB30                  		jsr	dMutePSGmus(pc)		; mute PSG channel
0001D054                            
0001D054                            .cont
0001D054 BAFC C698                  		cmpa.w	#mSFXFM3,a5		; check if this is a SFX channel
0001D058 6500                       		blo.s	.exit			; if not, skip all this mess
0001D05A 422D 001A                  		clr.b	cPrio(a5)		; clear channel priority
0001D05E                            
0001D05E 43FA ED74                  		lea	dSFXoverList(pc),a1	; load quick reference to the SFX override list to a1
0001D062 7600                       		moveq	#0,d3
0001D064 162D 0001                  		move.b	cType(a5),d3		; load channel type to d3
0001D068 6B00                       		bmi.s	.psg			; if this is a PSG channel, branch
0001D06A 3F0D                       		move.w	a5,-(sp)		; push channel pointer
0001D06C                            
0001D06C 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001D070 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001D072 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001D074 3A71 3000                  		move.w	(a1,d3.w),a5		; get the SFX channel we were overriding
0001D078                            
0001D078                            .dacdone
0001D078 4A15                       		tst.b	(a5)			; check if that channel is running a tracker
0001D07A 6A00                       		bpl.s	.fixch			; if not, branch
0001D07C                            
0001D07C 08D5 0005                  		bset	#cfbVol,(a5)		; set update volume flag (cleared by dUpdateVoiceFM)
0001D080 0895 0001                  		bclr	#cfbInt,(a5)		; reset sfx override flag
0001D084 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if the channel is a DAC channel
0001D08A 6600                       		bne.s	.fixch			; if yes, skip
0001D08C                            
0001D08C 08D5 0000                  		bset	#cfbRest,(a5)		; Set channel resting flag
0001D090 43FA 0000                  		lea	VoiceBankMusic(pc),a1	; load music voice table to a1
0001D094 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001D098 4EBA FE9E                  		jsr	dUpdateVoiceFM(pc)	; send FM voice for this channel
0001D09C                            
0001D09C                            .fixch
0001D09C 3A5F                       		move.w	(sp)+,a5		; pop the current channel
0001D09E                            .exit
0001D09E 5497                       		addq.l	#2,(sp)			; go to next channel immediately
0001D0A0 4E75                       		rts
0001D0A2                            ; ---------------------------------------------------------------------------
0001D0A2                            ; There is nothing that would break even if the channel is not
0001D0A2                            ; running a tracker, so we do not bother checking
0001D0A2                            ; ---------------------------------------------------------------------------
0001D0A2                            
0001D0A2                            .psg
0001D0A2 E80B                       		lsr.b	#4,d3			; make it easier to reference the right offset in the table
0001D0A4 3271 3000                  		movea.w	(a1,d3.w),a1		; get the SFX channel we were overriding
0001D0A8 0891 0001                  		bclr	#cfbInt,(a1)		; channel is not interrupted anymore
0001D0AC 08D1 0000                  		bset	#cfbRest,(a1)		; reset sfx override flag
0001D0B0                            
0001D0B0 0C29 00E0 0001             		cmp.b	#ctPSG4,cType(a1)	; check if this channel is in PSG4 mode
0001D0B6 66E6                       		bne.s	.exit			; if not, skip
0001D0B8 13E9 001B 00C0 0011        		move.b	cStatPSG4(a1),dPSG	; update PSG4 status to PSG port
0001D0C0 60DC                       		bra.s	.exit
0001D0C2                            ; ===========================================================================
0001D0C2                            ; ---------------------------------------------------------------------------
0001D0C2                            ; Tracker command for enabling LFO
0001D0C2                            ; ---------------------------------------------------------------------------
0001D0C2                            
0001D0C2                            dcsLFO:
0001D0C2 7000                       		moveq	#0,d0
0001D0C4 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001D0C8 224E                       		move.l	a6,a1			; load voice table to a1
0001D0CA                            
0001D0CA                            	dCALC_VOICE 9				; get address of the specific voice to a1
0001D0CA EB48                     M 	lsl.w	#5,d0
0001D0CC 0640 0009                M 	add.w	#9,d0
0001D0D0 D2C0                     M 	add.w	d0,a1
0001D0D2 1614                       		move.b	(a4),d3			; load LFO enable operators to d3
0001D0D4 45FA F0E0                  		lea	dAMSEn_Ops(pc),a2	; load Decay 1 Rate address table to a2
0001D0D8 7C03                       		moveq	#4-1,d6			; prepare 4 operators to d5
0001D0DA                            
0001D0DA                            .decayloop
0001D0DA 1219                       		move.b	(a1)+,d1		; get Decay 1 Level value from voice to d1
0001D0DC 101A                       		move.b	(a2)+,d0		; load YM address to write to d0
0001D0DE                            
0001D0DE D603                       		add.b	d3,d3			; check if LFO is enabled for this channeö
0001D0E0 6400                       		bcc.s	.noLFO			; if not, skip
0001D0E2 0001 0080                  		or.b	#$80,d1			; set enable LFO bit
0001D0E6 4EBA F3C6                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001D0EA                            
0001D0EA                            .noLFO
0001D0EA 51CE FFEE                  		dbf	d6,.decayloop		; repeat for each Decay 1 Level operator
0001D0EE                            
0001D0EE 121C                       		move.b	(a4)+,d1		; load LFO frequency value from tracker
0001D0F0 7022                       		moveq	#$22,d0			; YM command: LFO
0001D0F2 4EBA F3C6                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001D0F6                            
0001D0F6 121C                       		move.b	(a4)+,d1		; load AMS, FMS & Panning from tracker
0001D0F8 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel panning
0001D0FC                            
0001D0FC 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001D0FE 4EFA F3A8                  		jmp	dWriteYMchnInt(pc)	; write to YM according to channel
0001D102                            ; ===========================================================================
0001D102                            ; ---------------------------------------------------------------------------
0001D102                            ; Tracker command for resetting condition
0001D102                            ; ---------------------------------------------------------------------------
0001D102                            
0001D102                            dcResetCond:
0001D102 0895 0004                  		bclr	#cfbCond,(a5)		; reset condition flag
0001D106 4E75                       		rts
0001D108                            ; ===========================================================================
0001D108                            ; ---------------------------------------------------------------------------
0001D108                            ; Tracker command for writing to communications flags
0001D108                            ; ---------------------------------------------------------------------------
0001D108                            
0001D108                            dcsComm:
0001D108 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001D10C 7000                       		moveq	#0,d0
0001D10E 101C                       		move.b	(a4)+,d0		; load byte number to write from tracker
0001D110 139C 0000                  		move.b	(a4)+,(a1,d0.w)		; load vaue from tracker to communications byte
0001D114 4E75                       		rts
0001D116                            ; ===========================================================================
0001D116                            ; ---------------------------------------------------------------------------
0001D116                            ; RAM addresses for special condition code
0001D116                            ; ---------------------------------------------------------------------------
0001D116                            
0001D116                            dcCondRegTable:
0001D116 C744 C4A6                  	dc.w rHWVersion, mFlags	; 0
0001D11A C4B8 C4B9                  	dc.w mTempoMain, mTempoSpeed	; 2
0001D11E 0000 0000                  	dc.w 0, 0			; 4
0001D122 0000 0000                  	dc.w 0, 0			; 6
0001D126 0000 0000                  	dc.w 0, 0			; 8
0001D12A 0000 0000                  	dc.w 0, 0			; $A
0001D12E 0000 0000                  	dc.w 0, 0			; $C
0001D132 0000 0001                  	dc.w 0, cType			; $E
0001D136                            ; ===========================================================================
0001D136                            ; ---------------------------------------------------------------------------
0001D136                            ; Tracker command for checking special RAM addresses
0001D136                            ; ---------------------------------------------------------------------------
0001D136                            
0001D136                            dcCondReg:
0001D136 101C                       		move.b	(a4)+,d0		; get value from tracker
0001D138 1200                       		move.b	d0,d1			; copy to d1
0001D13A                            
0001D13A 0240 000F                  		and.w	#$F,d0			; get RAM table offset to d0
0001D13E D040                       		add.w	d0,d0			; double it (each entry is 1 word)
0001D140 303B 00D4                  		move.w	dcCondRegTable(pc,d0.w),d0; get data to read from
0001D144 6B00                       		bmi.s	.gotit			; branch if if was a RAM address
0001D146 D04D                       		add.w	a5,d0			; else it was a channel offset
0001D148                            
0001D148                            .gotit
0001D148 3240                       		move.w	d0,a1			; get the desired address from d0 to a1
0001D14A 1011                       		move.b	(a1),d0			; read byte from it
0001D14C 6000                       		bra.s	dcCondCom
0001D14E                            ; ===========================================================================
0001D14E                            ; ---------------------------------------------------------------------------
0001D14E                            ; Tracker command for checking communications bytes
0001D14E                            ; ---------------------------------------------------------------------------
0001D14E                            
0001D14E                            dcCond:
0001D14E 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001D152 101C                       		move.b	(a4)+,d0		; load condition and offset from tracker to d0
0001D154 1200                       		move.b	d0,d1			; copy to d1
0001D156 0240 000F                  		and.w	#$F,d0			; get offset only
0001D15A 1031 0000                  		move.b	(a1,d0.w),d0		; load value from communcations byte to d0
0001D15E                            
0001D15E                            dcCondCom:
0001D15E 0895 0004                  		bclr	#cfbCond,(a5)		; set condition to true
0001D162 0241 00F0                  		and.w	#$F0,d1			; get condition value only
0001D166 E449                       		lsr.w	#2,d1			; shift 2 bits down (each entry is 4 bytes large)
0001D168 B01C                       		cmp.b	(a4)+,d0		; check value against tracker byte
0001D16A 4EFB 1000                  		jmp	.cond(pc,d1.w)		; handle conditional code
0001D16E                            ; ===========================================================================
0001D16E                            ; ---------------------------------------------------------------------------
0001D16E                            ; Code for setting the condition flag
0001D16E                            ; ---------------------------------------------------------------------------
0001D16E                            
0001D16E                            .c	macro x
0001D16E                            	\x	.false
0001D16E                            	rts
0001D16E                                 endm
0001D16E                            
0001D16E                            .false
0001D16E 08D5 0004                  		bset	#cfbCond,(a5)		; set condition to false
0001D172                            
0001D172 4E75                       .cond	rts		; T
0001D174 4E75                       	rts
0001D176                            	.c bra.s	; F
0001D176 60F6                     M 	bra.s	.false
0001D178 4E75                     M 	rts
0001D17A                            	.c bls.s	; HI
0001D17A 63F2                     M 	bls.s	.false
0001D17C 4E75                     M 	rts
0001D17E                            	.c bhi.s	; LS
0001D17E 62EE                     M 	bhi.s	.false
0001D180 4E75                     M 	rts
0001D182                            	.c blo.s	; HS/CC
0001D182 65EA                     M 	blo.s	.false
0001D184 4E75                     M 	rts
0001D186                            	.c bhs.s	; LO/CS
0001D186 64E6                     M 	bhs.s	.false
0001D188 4E75                     M 	rts
0001D18A                            	.c beq.s	; NE
0001D18A 67E2                     M 	beq.s	.false
0001D18C 4E75                     M 	rts
0001D18E                            	.c bne.s	; EQ
0001D18E 66DE                     M 	bne.s	.false
0001D190 4E75                     M 	rts
0001D192                            	.c bvs.s	; VC
0001D192 69DA                     M 	bvs.s	.false
0001D194 4E75                     M 	rts
0001D196                            	.c bvc.s	; VS
0001D196 68D6                     M 	bvc.s	.false
0001D198 4E75                     M 	rts
0001D19A                            	.c bmi.s	; PL
0001D19A 6BD2                     M 	bmi.s	.false
0001D19C 4E75                     M 	rts
0001D19E                            	.c bpl.s	; MI
0001D19E 6ACE                     M 	bpl.s	.false
0001D1A0 4E75                     M 	rts
0001D1A2                            	.c blt.s	; GE
0001D1A2 6DCA                     M 	blt.s	.false
0001D1A4 4E75                     M 	rts
0001D1A6                            	.c bge.s	; LT
0001D1A6 6CC6                     M 	bge.s	.false
0001D1A8 4E75                     M 	rts
0001D1AA                            	.c ble.s	; GT
0001D1AA 6FC2                     M 	ble.s	.false
0001D1AC 4E75                     M 	rts
0001D1AE                            	.c bgt.s	; LE
0001D1AE 6EBE                     M 	bgt.s	.false
0001D1B0 4E75                     M 	rts
0001D1B2                            ; ===========================================================================
0001D1B2                            ; ---------------------------------------------------------------------------
0001D1B2                            ; Tracker command for freezing the CPU. DEBUG FLAG
0001D1B2                            ; ---------------------------------------------------------------------------
0001D1B2                            
0001D1B2                            ; ===========================================================================
0001D1B2                            ; ---------------------------------------------------------------------------
0001D1B2                            ; Check if a song is playing
0001D1B2                            ; ---------------------------------------------------------------------------
0001D1B2                            
0001D1B2                            dChkSongPlay:
0001D1B2 43F8 C4C4                  	lea	mDAC1.w,a1		; Music track RAM
0001D1B6 7209                       	moveq	#Mus_Ch-1,d1
0001D1B8                            
0001D1B8                            .ChkTracks:
0001D1B8 4A11                       	tst.b	cFlags(a1)		; Is this track playing?
0001D1BA 6B00                       	bmi.s	.Playing		; If so, branch
0001D1BC 43E9 002C                  	lea	cSize(a1),a1		; Next track
0001D1C0 51C9 FFF6                  	dbf	d1,.ChkTracks		; Loop
0001D1C4 7200                       	moveq	#0,d1
0001D1C6 4E75                       	rts
0001D1C8                            
0001D1C8                            .Playing:
0001D1C8 50C1                       	st	d1
0001D1CA 4E75                       	rts
0001D1CC                            ; ===========================================================================
0001D1CC                            ; ---------------------------------------------------------------------------
0001D1CC                            ; Define music and SFX
0001D1CC                            ; ---------------------------------------------------------------------------
0001D1CC                            
0001D1CC                            	opt oz-				; disable zero-offset optimization
000C3988                            	list				; continue source listing
000C3988                            ; ===========================================================================
000C3988                            DualPCM:
000C3988                            		z80prog	0
000C3988                          M 	pusho
000C3988                          M 	opt	ae-
000C3988                          M 	opt	an+
00000000                            		include	"../amps/code/Z80.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DUAL-PCM - by MarkeyJester
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Read		macro
00000000                            		ldi					; 16	; copy from window to buffer, and increment register
00000000                            		zadd	a,b				; 04	; add dividend
00000000                            		adc	hl,sp				; 15	; add quotient
00000000                            		endm					; Total: 35
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_CapPCM	macro
00000000                            		jp	po, .ov\@			; 10	; if the sample hasn't overflown the 7F/80 boundary, branch
00000000                            		sbc	a,a				; 04	; erase sample, and subtract the carry to get either FF or 00, depending on overflow direction
00000000                            		xor	07Fh				; 07	; reverse FF/00 (xor 80 below helps)
00000000                            .ov\@		xor	080h				; 07	; convert to unsigned
00000000                            		endm					; Total: 17/28
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush01	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 2 to volume 1
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush02	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 1 to volume 2
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert01	macro
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert02	macro
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Wrap		macro
00000000                            		dec	l				; 04	; check l...
00000000                            		inc	l				; 04	; ''
00000000                            		M_WrapCondition
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_WrapCondition	macro
00000000                            		jp	nz, .c\@			; 10	; if it's not 0, branch
00000000                            		inc	h				; 04	; advance OUT buffers
00000000                            		bit	004h,h				; 08	; have the OUT buffer addresses reached 1000 (end of buffer) yet?
00000000                            		jp	z, .c\@				; 10	; if not, branch
00000000                            		ld	hl,PCM_Buffer2			; 10	; reset OUT buffers
00000000                            .c\@
00000000                            		endm
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start of Z80 ROM
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80_Start:
0000000B                            
0000000B 0000 0000 00               		align	MaxPitch/$100
00000010                            
00000010                            	; The space from "Start" until the maximum pitch amount, is the space
00000010                            	; where data could potentially be pushed into, thanks to the sp.
00000010                            
00000010                            	; The sp will likely be from roughly FFEF - 000F for the quotient of
00000010                            	; the pitch.  Now, FFEF - FFFF will be fine, since that points to the
00000010                            	; 68k window, which will be pointing to 68k ROM, so nothing will happen.
00000010                            	; But the address from 0000 - 000F points to the beginning of ROM, so
00000010                            	; this place must be free from use outside of V-blank.
00000010                            
00000010                            Z80_Stack:
00000010                            
00000010                            ; ===========================================================================
00000010                            ; ---------------------------------------------------------------------------
00000010                            ; PCM 1 Resetting
00000010                            ; ---------------------------------------------------------------------------
00000010                            		align	010h
00000010                            ; ---------------------------------------------------------------------------
00000010                            
00000010                            BreakLate:
00000019                            
00000019                            ; ===========================================================================
00000019                            ; ---------------------------------------------------------------------------
00000019                            ; PCM 1 Resetting
00000019                            ; ---------------------------------------------------------------------------
00000019 0000 0000 0000 0000 0000+  		align	028h
00000028                            ; ---------------------------------------------------------------------------
00000028                            
00000028                            PCM1_ResetJmp:
0000002B                            
0000002B                            ; ===========================================================================
0000002B                            ; ---------------------------------------------------------------------------
0000002B                            ; PCM 2 Resetting
0000002B                            ; ---------------------------------------------------------------------------
0000002B 0000 0000 00               		align	030h
00000030                            ; ---------------------------------------------------------------------------
00000030                            
00000030                            PCM2_ResetJmp:
00000033                            
00000033                            ; ===========================================================================
00000033                            ; ---------------------------------------------------------------------------
00000033                            ; Breaking out for V-blank
00000033                            ; ---------------------------------------------------------------------------
00000033 0000 0000 00               		align	038h
00000038                            ; ---------------------------------------------------------------------------
00000038                            
00000038                            BreakVBlank:
0000003C 2F                         		cpl					; 04	; change buffer
00000040                            
00000040                            BVB_Check:
00000046                            
00000046                            ; ---------------------------------------------------------------------------
00000046                            ; Breaking out for V-blank, during non-read
00000046                            ; ---------------------------------------------------------------------------
00000046                            
00000046                            BreakPrep:
00000061                            	;	ei					; 04	; enable interrupts
00000061 ED4D                       		reti					; 14	; return
00000063                            
00000063                            ; ===========================================================================
00000063                            ; ---------------------------------------------------------------------------
00000063                            ; Breaking out for V-blank, during read of window or bank register
00000063                            ; ---------------------------------------------------------------------------
00000063                            
00000063                            BreakDMA:
00000066                            
00000066                            	; --- Finding out which registers we're dealing with ---
00000066                            
00000074 1F                         BDMA_NoExchange:	rra					; 04	; get buffer we're currently reading from
00000083 D9                         BDMA_NoFixFlush:	exx					; 04	; swap to the "read" set of exx registers
00000084                            BDMA_ReadSet:
00000084                            
00000084                            ; ---------------------------------------------------------------------------
00000084                            ; Flush remaining data
00000084                            ; ---------------------------------------------------------------------------
00000084                            
00000084                            BreakBank:
00000084 D9                         			exx					; 04	; switch registers
00000086 D9                         			exx					; 04	; switch registers
00000087 ED44                       		zneg	a				; 08	; reverse position
00000090                            
00000090                            BDMA_NoMax:
0000009A                            
0000009A                            BDMA_FlushLoop:
0000009E                            
0000009E                            BDMA_Flush02:
0000009E D9                         			exx					; 04	; switch registers
000000B2 D9                         			exx					; 04	; switch registers
000000B7                            
000000B7                            BDMA_Flush01:
000000B7 D9                         			exx					; 04	; switch registers
000000CB D9                         			exx					; 04	; switch registers
000000D0                            
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            ; Wrapping OUT buffers
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            
000000D0 D9                         			exx					; 04	; switch registers
000000DF D9                         			exx					; 04	; switch back
000000E0                            
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            ; Restore interrupt instructions
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            
00000107                            
00000107                            BDMA_NoRestore:
00000107                            
00000107                            ; ---------------------------------------------------------------------------
00000107                            ; YM2612 flushing
00000107                            ; ---------------------------------------------------------------------------
00000107                            
0000010A                            
00000116                            
00000116                            YMF_Buff1:
0000011F D9                         			exx					; 04	; switch registers back
00000120                            
00000120                            YM_Flush:
00000123                            
00000123                            YMF_NextByte:
00000136 D9                         			exx					; 04	; switch registers
00000149 D9                         			exx					; 04	; switch registers
0000015D D9                         			exx					; 04	; switch registers
00000170 D9                         			exx					; 04	; switch registers
00000176                            
00000176                            	; --- Advance/Wrap OUT buffers ---
00000176                            
00000189                            
00000189                            YMF_Finish02:
00000192                            
00000192                            YMF_Finish01:
0000019B                            
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            ; Waiting for v-blank to finish
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            
0000019B                            PCM_Flush_exx:
0000019B D9                         			exx
0000019C                            
0000019C                            PCM_Flush:
0000019F                            
0000019F                            PCM_NextByte:
000001B2 D9                         			exx					; 04	; switch registers
000001B7                            
000001B7                            
000001B7 D9                         			exx					; 04	; switch registers
000001CB D9                         			exx					; 04	; switch registers
000001CC                            
000001D0                            
000001D0 D9                         			exx					; 04	; switch registers
000001D6                            
000001D6                            	; --- Advance/Wrap OUT buffers ---
000001D6                            
000001E4                            
000001E9 D9                         		exx					; 04	; switch registers down again...
000001EA                            
000001F6                            
000001F6                            YMF_SetBuff1:
000001F8                            
00000202                            
00000202                            VB_PCM1_VolOK:
0000020C                            
0000020C                            VB_PCM2_VolOK:
0000020C                            
0000020C 37                         		scf					; 04	; set carry flag
0000020D                            
00000222                            
00000222                            PCM_VolChangeNo:
00000222                            
00000222                            
0000022D                            
0000022D                            ; ===========================================================================
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            ; Setup/Init
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            
0000022D                            Z80_Init:
00000230                            
00000230                            	; --- YM2612 DAC Setup ---
00000230                            
0000023F                            
0000023F                            	; --- Setting up channels to be mute ---
0000023F                            
00000251                            
0000025A EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000261 EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000268 EDB0                       			ldir					; 21 16	; copy mute sample data over...
0000026F EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000271                            
00000271                            	; --- Setting up PCM 1 switch ---
00000271                            
0000027A                            
0000027A                            	; --- Setting up PCM 2 switch ---
0000027A                            
00000283                            
00000283                            	; --- Final register setup ---
00000283                            
0000028B                            
00000290                            
00000290 D9                         			exx					; 04	; switch registers
00000291                            
00000291                            ; ===========================================================================
00000291                            ; ---------------------------------------------------------------------------
00000291                            ; The catch up loop
00000291                            ; ---------------------------------------------------------------------------
00000291                            
00000291                            CatchUp:
00000291 D9                         			exx					; 04	; switch registers
00000292                            
00000292                            CatchUp_Exx:
000002A5 D9                         			exx					; 04	; switch registers
000002A6                            
000002A6                            Z80_Int2:	;ei
000002A6 00                         		znop					; 04
000002A7                            
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            ; PCM 1
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            
000002A7                            PCM1_MuteRet:
000002AC 00                         Int1_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
000002C8 D9                         			exx					; 04	; switch registers
000002DC D9                         			exx					; 04	; switch registers
000002E4                            
000002E4                            PCM1_PrepRet:
000002E4                            
000002F2                            
000002FC EDA0                       PCM1_PreInst03:	ldi					; 16	; copy from window to buffer, and increment register
000002FE D9                         			exx					; 04	; switch registers
00000313 D9                         			exx					; 04	; switch registers
0000032C D9                         			exx					; 04	; switch registers
00000341 D9                         			exx					; 04	; switch registers
00000357 EDA0                       PCM1_PreInst0C:	ldi					; 16	; copy from window to buffer, and increment register
00000359 D9                         			exx					; 04	; switch registers
0000036E D9                         			exx					; 04	; switch registers
00000387 D9                         			exx					; 04	; switch registers
0000039C D9                         			exx					; 04	; switch registers
000003B2 EDA0                       PCM1_PreInst15:	ldi					; 16	; copy from window to buffer, and increment register
000003B4 D9                         			exx					; 04	; switch registers
000003C9 D9                         			exx					; 04	; switch registers
000003E6 D9                         			exx					; 04	; switch registers
000003FB D9                         			exx					; 04	; switch registers
00000403                            
00000403                            ; ---------------------------------------------------------------------------
00000403                            ; PCM 2
00000403                            ; ---------------------------------------------------------------------------
00000403                            
00000403                            PCM2_MuteRet:
00000408 00                         Int2_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
0000041A D9                         			exx					; 04	; switch registers
0000042E D9                         			exx					; 04	; switch registers
00000440                            
00000440                            PCM2_PrepRet:
00000440                            
0000044E                            
00000453 D9                         			exx					; 04	; switch registers
00000468 D9                         			exx					; 04	; switch registers
0000047E EDA0                       PCM2_PreInst06:	ldi					; 16	; copy from window to buffer, and increment register
00000480 D9                         			exx					; 04	; switch registers
00000495 D9                         			exx					; 04	; switch registers
000004AE D9                         			exx					; 04	; switch registers
000004C3 D9                         			exx					; 04	; switch registers
000004D9 EDA0                       PCM2_PreInst0F:	ldi					; 16	; copy from window to buffer, and increment register
000004DB D9                         			exx					; 04	; switch registers
000004F0 D9                         			exx					; 04	; switch registers
00000509 D9                         			exx					; 04	; switch registers
0000051E D9                         			exx					; 04	; switch registers
00000534 EDA0                       PCM2_PreInst18:	ldi					; 16	; copy from window to buffer, and increment register
00000536 D9                         			exx					; 04	; switch registers
0000054B D9                         			exx					; 04	; switch registers
0000055F                            
00000570                            
00000570                            ; ---------------------------------------------------------------------------
00000570                            ; Wrapping OUT buffers
00000570                            ; ---------------------------------------------------------------------------
00000570                            
00000570 D9                         			exx					; 04	; switch registers
00000590 D9                         			exx					; 04	; switch back
00000591                            
00000591                            ; ---------------------------------------------------------------------------
00000591                            ; Wrap IN buffers
00000591                            ; ---------------------------------------------------------------------------
00000591                            
000005A3                            
000005A3                            PCM_BuffNoReset:
000005A3                            
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            ; Rebank...
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            
000005A3 37                         		scf					; 04	; set carry flag
000005BA 37                         		scf					; 04	; set carry flag
000005BB                            
000005BB                            PCM1_IgnoreBank:
000005D1 37                         		scf					; 04	; set carry flag
000005D2                            
000005D2                            PCM2_IgnoreBank:
000005D2                            
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            ; Pitch control
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            
000005DA                            
00000602 37                         		scf					; 04	; set carry flag
00000603                            
00000603                            PCM1_IgnorePitch:
00000603                            
0000060B                            
00000633 37                         		scf					; 04	; set carry flag
00000634                            
00000634                            PCM2_IgnorePitch:
00000634                            
00000634                            ; ---------------------------------------------------------------------------
00000634                            ; Updating Volume
00000634                            ; ---------------------------------------------------------------------------
00000634                            
0000064B                            	;	scf					; 04	; don't think it's necessary here...
0000064B                            
0000064E                            PCM_VolumeRet:
0000064E                            
0000064E                            
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            ; New samples...
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            
00000654                            
00000654                            ; ---------------------------------------------------------------------------
00000654                            ; Checking for "Flush" mode
00000654                            ; ---------------------------------------------------------------------------
00000654                            
00000654                            PCM_NoUpdate:
00000654 D9                         		exx					; 04	; switch registers
00000656 1F                         			rra					; 04	; get upper bit only into carry
00000658 1F                         			rra					; 04	; shift address down with carry
00000659 D9                         		exx					; 04	; switch registers
0000066A                            
0000066A                            CU_ValidDist:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; New sample playback
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F                            CU_Flush:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; Main "Flush" loop
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F D9                         			exx					; 04	; switch registers back
00000673                            
00000673                            FL_NextByte:
00000686 D9                         			exx					; 04	; switch registers
0000068C D9                         			exx					; 04	; switch registers
000006A0 D9                         			exx					; 04	; switch registers
000006A5 D9                         			exx					; 04	; switch registers
000006A6                            
000006AB                            
000006AB                            	; --- Advance/Wrap OUT buffers ---
000006AB                            
000006BC                            
000006BC                            ; ===========================================================================
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            ; When PCM sample 1 has reached an end marker & needs to loop back
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            
000006BC                            PCM1_Mute:
000006CE                            
000006CE                            PCM1_Normal:
000006D4                            
000006D4                            PCM1_Reverse:
000006E4 D9                         			exx					; 04	; switch registers
000006E9 D9                         			exx					; 04	; switch registers
000006ED                            
000006ED                            ; ===========================================================================
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            ; When PCM sample 1 address has reached the end of a window, just to play the last bit
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            
000006ED                            PCM1_PrepReset:
000006FC                            
000006FC                            PCM1_PrepCount:
00000715 D9                         			exx					; 04	; switch registers
00000729 D9                         			exx					; 04	; switch registers
00000731                            
00000731                            ; ===========================================================================
00000731                            ; ---------------------------------------------------------------------------
00000731                            ; When PCM sample 1 address has gone outside the window, and needs to reset
00000731                            ; ---------------------------------------------------------------------------
00000731                            
00000731                            PCM1_Reset:
0000074B                            
00000755                            
00000758                            
0000075A                            
0000075F                            
0000076B                            
00000771 0F                         		rrca					; 04
00000773 0F                         		rrca					; 04
00000775 0F                         		rrca					; 04
00000777 0F                         		rrca					; 04
00000779 0F                         		rrca					; 04
0000077B 0F                         		rrca					; 04
0000077D 0F                         		rrca					; 04
00000780                            
00000782                            
00000787                            
00000797                            
0000079A                            
0000079A                            ; ===========================================================================
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            ; 68K SET - routine to load a new sample 1
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            
0000079A                            PCM1_NewSample:
000007AA                            
000007AA                            PCM1_NewNormal:
000007B0                            
000007B0                            PCM1_NewReverse:
000007C0                            
000007C5 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000007C7                            
000007C7                            ; ===========================================================================
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            ; When PCM sample 2 has reached an end marker & needs to loop back
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            
000007C7                            PCM2_Mute:
000007D9                            
000007D9                            PCM2_Normal:
000007DF                            
000007DF                            PCM2_Reverse:
000007EF D9                         			exx					; 04	; switch registers
000007F4 D9                         			exx					; 04	; switch registers
000007F8                            
000007F8                            ; ===========================================================================
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            ; When PCM sample 2 address has reached the end of a window, just to play the last bit
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            
000007F8                            PCM2_PrepReset:
00000807                            
00000807                            PCM2_PrepCount:
00000827                            
00000827                            ; ===========================================================================
00000827                            ; ---------------------------------------------------------------------------
00000827                            ; When PCM sample 2 address has gone outside the window, and needs to reset
00000827                            ; ---------------------------------------------------------------------------
00000827                            
00000827                            PCM2_Reset:
00000841                            
0000084B                            
0000084E                            
00000850                            
00000855                            
00000861                            
00000867 0F                         		rrca					; 04
00000869 0F                         		rrca					; 04
0000086B 0F                         		rrca					; 04
0000086D 0F                         		rrca					; 04
0000086F 0F                         		rrca					; 04
00000871 0F                         		rrca					; 04
00000873 0F                         		rrca					; 04
00000876                            
00000878                            
0000087D                            
0000088D                            
00000890                            
00000890                            ; ===========================================================================
00000890                            ; ---------------------------------------------------------------------------
00000890                            ; 68K SET - routine to load a new sample 2
00000890                            ; ---------------------------------------------------------------------------
00000890                            
00000890                            PCM2_NewSample:
000008A0                            
000008A0                            PCM2_NewNormal:
000008A6                            
000008A6                            PCM2_NewReverse:
000008B6                            
000008BB 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000008BD                            
000008BD                            ; ===========================================================================
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            ; PCM volume Lists
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            		align	00200h
00000A00                            ; ---------------------------------------------------------------------------
00000A00                            
00000A00 0081 8283 8485 8687 8889+  PCM_Volume1:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000A10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000A20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000A30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000A40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000A50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000A60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000A70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000A80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000A90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000AA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000AB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000AC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000AD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000AE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000AF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000B00                            
00000B00 0081 8283 8485 8687 8889+  PCM_Volume2:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000B10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000B20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000B30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000B40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000B50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000B60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000B70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000B80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000B90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000BA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000BB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000BC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000BD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000BE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000BF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000C00                            
00000C00                            ; ===========================================================================
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            ; Bank interrupt preparation list
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            		align	00080h
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            
00000C00 F202                       PCM1_PrepTable:	dw	PCM1_PreInst01
00000C02 F702                       		dw	PCM1_PreInst02
00000C04 FC02                       		dw	PCM1_PreInst03
00000C06 1803                       		dw	PCM1_PreInst04
00000C08 1D03                       		dw	PCM1_PreInst05
00000C0A 2203                       		dw	PCM1_PreInst06
00000C0C 2703                       		dw	PCM1_PreInst07
00000C0E 4303                       		dw	PCM1_PreInst08
00000C10 4803                       		dw	PCM1_PreInst09
00000C12 4D03                       		dw	PCM1_PreInst0A
00000C14 5203                       		dw	PCM1_PreInst0B
00000C16 5703                       		dw	PCM1_PreInst0C
00000C18 7303                       		dw	PCM1_PreInst0D
00000C1A 7803                       		dw	PCM1_PreInst0E
00000C1C 7D03                       		dw	PCM1_PreInst0F
00000C1E 8203                       		dw	PCM1_PreInst10
00000C20 9E03                       		dw	PCM1_PreInst11
00000C22 A303                       		dw	PCM1_PreInst12
00000C24 A803                       		dw	PCM1_PreInst13
00000C26 AD03                       		dw	PCM1_PreInst14
00000C28 B203                       		dw	PCM1_PreInst15
00000C2A CE03                       		dw	PCM1_PreInst16
00000C2C D303                       		dw	PCM1_PreInst17
00000C2E D803                       		dw	PCM1_PreInst18
00000C30 4E04                       PCM2_PrepTable:	dw	PCM2_PreInst01
00000C32 6A04                       		dw	PCM2_PreInst02
00000C34 6F04                       		dw	PCM2_PreInst03
00000C36 7404                       		dw	PCM2_PreInst04
00000C38 7904                       		dw	PCM2_PreInst05
00000C3A 7E04                       		dw	PCM2_PreInst06
00000C3C 9A04                       		dw	PCM2_PreInst07
00000C3E 9F04                       		dw	PCM2_PreInst08
00000C40 A404                       		dw	PCM2_PreInst09
00000C42 A904                       		dw	PCM2_PreInst0A
00000C44 C504                       		dw	PCM2_PreInst0B
00000C46 CA04                       		dw	PCM2_PreInst0C
00000C48 CF04                       		dw	PCM2_PreInst0D
00000C4A D404                       		dw	PCM2_PreInst0E
00000C4C D904                       		dw	PCM2_PreInst0F
00000C4E F504                       		dw	PCM2_PreInst10
00000C50 FA04                       		dw	PCM2_PreInst11
00000C52 FF04                       		dw	PCM2_PreInst12
00000C54 0405                       		dw	PCM2_PreInst13
00000C56 2005                       		dw	PCM2_PreInst14
00000C58 2505                       		dw	PCM2_PreInst15
00000C5A 2A05                       		dw	PCM2_PreInst16
00000C5C 2F05                       		dw	PCM2_PreInst17
00000C5E 3405                       		dw	PCM2_PreInst18
00000C60                            
00000C60                            ; ===========================================================================
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            ; Specific variable data...
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            
00000C60                            	; --- Current bank address for PCM channels ---
00000C60                            
00000C60 00                         PCM1_BankCur:	db	000h					; The current bank address of PCM 1
00000C61 00                         PCM2_BankCur:	db	000h					; The current bank address of PCM 2
00000C62                            
00000C62                            	; --- "Mute Sample" pointer into 68k memory ---
00000C62                            
00000C62 0000                       MuteSample:	dw	00000h					; sample window address
00000C64 00                         MuteBank:	db	000h					; sample bank address
00000C65 0000                       MuteSample_Rev:	dw	00000h					; sample window address
00000C67 00                         MuteBank_Rev:	db	000h					; sample bank address
00000C68                            
00000C68                            	; --- YM2612 Pointers ---
00000C68                            
00000C68 00                         YM_Buffer:	db	000h					; 00 = Z80 Buffer 1 | 68k Buffer 2 ... FF = Z80 Buffer 2 | 68k Buffer 1
00000C69                            
00000C69                            ; ===========================================================================
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            ; Sample requested by 68k
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            
00000C69                            	; --- PCM 1 start sample ---
00000C69                            
00000C69 0000                       PCM1_Sample:		dw	00000h					; PCM 1 requested sample
00000C6B 00                         PCM1_Bank:		db	000h					; PCM 1 requested bank
00000C6C 0000                       PCM1_Sample_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C6E 00                         PCM1_Bank_Rev:		db	000h					; PCM 1 requested bank (reverse position)
00000C6F                            
00000C6F                            	; --- PCM 1 next sample ---
00000C6F                            
00000C6F 0000                       PCM1_SampleNext:	dw	00000h					; PCM 1 requested sample
00000C71 00                         PCM1_BankNext:		db	000h					; PCM 1 requested bank
00000C72 0000                       PCM1_SampleNext_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C74 00                         PCM1_BankNext_Rev:	db	000h					; PCM 1 requested bank (reverse position)
00000C75                            
00000C75                            	; --- PCM 2 start sample ---
00000C75                            
00000C75 0000                       PCM2_Sample:		dw	00000h					; PCM 2 requested sample
00000C77 00                         PCM2_Bank:		db	000h					; PCM 2 requested bank
00000C78 0000                       PCM2_Sample_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C7A 00                         PCM2_Bank_Rev:		db	000h					; PCM 2 requested bank (reverse position)
00000C7B                            
00000C7B                            	; --- PCM 2 next sample ---
00000C7B                            
00000C7B 0000                       PCM2_SampleNext:	dw	00000h					; PCM 2 requested sample
00000C7D 00                         PCM2_BankNext:		db	000h					; PCM 2 requested bank
00000C7E 0000                       PCM2_SampleNext_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C80 00                         PCM2_BankNext_Rev:	db	000h					; PCM 2 requested bank (reverse position)
00000C81                            
00000C81                            ; ===========================================================================
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            ; PCM buffer (1000h = start of cue, Make sure both buffers end in a multiple of 100)
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            
00000C81 0000 0000 0000 0000 0000+  		align	(01000h-00200h)-00150h
00000CB0                            PCM_Buffer1:	rept	00150h
00000CB0                            		db	080h
00000CB0 8080 8080 8080 8080 8080+  		endr
00000E00                            
00000E00 0000 0000 0000 0000 0000+  		align	01000h-00150h
00000EB0                            PCM_Buffer2:	rept	00150h
00000EB0                            		db	080h
00000EB0 8080 8080 8080 8080 8080+  		endr
00001000                            
00001000                            ; ===========================================================================
00001000                            ; ---------------------------------------------------------------------------
00001000                            ; The YM2612 operator writing lists (68k writes here, z80 must flush off)
00001000                            ; ---------------------------------------------------------------------------
00001000                            
00001000                            YM_Buffer1:	rept	00400h
00001000                            		db	0FFh
00001000 FFFF FFFF FFFF FFFF FFFF+  		endr
00001400                            
00001400                            YM_Buffer2:	rept	00400h
00001400                            		db	0FFh
00001400 FFFF FFFF FFFF FFFF FFFF+  		endr
00001800                            
00001800                            ; ===========================================================================
00001800                            ; ---------------------------------------------------------------------------
00001800                            ; Overflow calculation multiplication tables
00001800                            ; ---------------------------------------------------------------------------
00001800                            
00001800                            PCM_OverflwCalc:
00001800                            
00001800                            		; --- Lower byte ---
00001800                            
00001800 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001810 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001820 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001830 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001840 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001850 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001860 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001870 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001880 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001890 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018A0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018B0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018C0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018D0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018E0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018F0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001900                            
00001900                            		; --- Upper byte ---
00001900                            
00001900 0000 0000 0000 0000 0000+  		db	000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,001h,001h,001h,001h,001h
00001910 0101 0101 0101 0202 0202+  		db	001h,001h,001h,001h,001h,001h,002h,002h,002h,002h,002h,002h,002h,002h,002h,002h
00001920 0303 0303 0303 0303 0303+  		db	003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,004h,004h,004h,004h,004h
00001930 0404 0404 0404 0505 0505+  		db	004h,004h,004h,004h,004h,004h,005h,005h,005h,005h,005h,005h,005h,005h,005h,005h
00001940 0606 0606 0606 0606 0606+  		db	006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,007h,007h,007h,007h,007h
00001950 0707 0707 0707 0808 0808+  		db	007h,007h,007h,007h,007h,007h,008h,008h,008h,008h,008h,008h,008h,008h,008h,008h
00001960 0909 0909 0909 0909 0909+  		db	009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,00Ah,00Ah,00Ah,00Ah,00Ah
00001970 0A0A 0A0A 0A0A 0B0B 0B0B+  		db	00Ah,00Ah,00Ah,00Ah,00Ah,00Ah,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh
00001980 0C0C 0C0C 0C0C 0C0C 0C0C+  		db	00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Dh,00Dh,00Dh,00Dh,00Dh
00001990 0D0D 0D0D 0D0D 0E0E 0E0E+  		db	00Dh,00Dh,00Dh,00Dh,00Dh,00Dh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh
000019A0 0F0F 0F0F 0F0F 0F0F 0F0F+  		db	00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,010h,010h,010h,010h,010h
000019B0 1010 1010 1010 1111 1111+  		db	010h,010h,010h,010h,010h,010h,011h,011h,011h,011h,011h,011h,011h,011h,011h,011h
000019C0 1212 1212 1212 1212 1212+  		db	012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,013h,013h,013h,013h,013h
000019D0 1313 1313 1313 1414 1414+  		db	013h,013h,013h,013h,013h,013h,014h,014h,014h,014h,014h,014h,014h,014h,014h,014h
000019E0 1515 1515 1515 1515 1515+  		db	015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,016h,016h,016h,016h,016h
000019F0 1616 1616 1616 1717 1717+  		db	016h,016h,016h,016h,016h,016h,017h,017h,017h,017h,017h,017h,017h,017h,017h,017h
00001A00                            
00001A00                            ; ===========================================================================
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            ; Subroutine to change a channel's volume table
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            
00001A00                            PCM_VolumeControl:
00001A06                            
00001A1B                            
00001A1B                            PCM1_NoVolume:
00001A1B                            
00001A30                            
00001A30                            PCM2_NoVolume:
00001A31 37                         		scf					; 04	; set carry flag
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; The volume changing itself
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            SwitchVolume:
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; Software version of volume table (This is slower to process but will save
00001A35                            ; 8000 bytes of ROM space).  It'll also cause chopping in the sample playback
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            ;		ld	b,a				; 04	; store volume
00001A35                            ;		zneg					; 08	; convert volume to 00 - 80 (mute - loud)
00001A35                            ;		zadd	a,080h				; 07	; ''
00001A35                            ;		zadd	a,a				; 04	; shift MSB into carry
00001A35                            ;		ld	(SV_Fraction+001h),a		; 13	; store fraction
00001A35                            ;		sbc	a,a				; 04	; get only the carry (for quotient)
00001A35                            ;		zneg					; 08	; ''
00001A35                            ;		ld	c,a				; 04	; store quotient in c
00001A35                            ;		ld	hl,00000h			; 10	; reset current fraction/dividend
00001A35                            ;		ld	a,b				; 04	; reload volume
00001A35                            ;		zadd	a,080h				; 07	; rotate starting volume
00001A35                            ;SV_Fraction:	ld	b,000h				; 07	; set fraction/dividend
00001A35                            ;
00001A35                            ;SV_SetNormal:
00001A35                            ;		ld	(de),a				; 07	; save to table
00001A35                            ;		zadd	hl,bc 				; 11	; add fraction/dividend
00001A35                            ;		adc	a,c				; 04	; add carry to quotient
00001A35                            ;		inc	e				; 04	; advance table
00001A35                            ;		jp	nz,SV_SetNormal			; 10	; repeat until the table is finished (should reach 100)
00001A35                            ;
00001A35                            ;SV_Return:	jp	00000h				; 10	; return
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A46                            
00001A46                            	; --- Non-flush version ---
00001A46                            
00001A55                            
00001A55                            SV_NoMute:
00001A5A                            
00001A5A                            SV_LoadVolume:
00001A5A                            		rept	008h
00001A5A                            		ldi					; 16	; copy volume bytes over
00001A5A EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001A6E                            
00001A6E                            	; --- Flush version ---
00001A6E                            
00001A6E                            SV_Flush:
00001A79 D9                         			exx					; 04	; switch registers
00001A8D D9                         			exx					; 04	; switch registers
00001A91                            
00001A91                            SVF_NoMute:
00001A96                            
00001A96                            SVF_LoadVolume:
00001A96 D9                         			exx					; 04	; switch registers
00001AAA D9                         			exx					; 04	; switch registers
00001AAB                            
00001AAB                            SVF_StartVolume:
00001AAB                            		rept	008h
00001AAB                            		ldi					; 16	; copy volume bytes over
00001AAB EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001ABB D9                         			exx					; 04	; switch registers
00001ACF D9                         			exx					; 04	; switch registers
00001AD0                            		rept	008h
00001AD0                            		ldi					; 16	; copy volume bytes over
00001AD0 EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001AE2 D9                         			exx					; 04	; switch registers
00001AF1 D9                         			exx					; 04	; switch registers
00001AFC                            
00001AFC                            ; ===========================================================================
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ; Switching a channel's bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	hl,PCM1_BankCur			; 10	; address of bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		ld	a,(PCM1_PitchQuo+001h)		; 13	; load pitch quotient
00001AFC                            ;		call	SwitchBank			; 17	; change the bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	a,(PCM1_BankCur)		; 13	; load bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		call	SetBank				; 17	; set bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            
00001AFC                            SwitchBank:
00001B03                            
00001B03                            SetBank:
00001B06                            	rept	008h
00001B06                            		xor	a				; 04	; clear a
00001B06                            		rrc	l				; 08	; shift bit into carry
00001B06                            		adc	a,h				; 04	; set instruction bits (with carry register bit)
00001B06                            		ld	(de),a				; 07	; write instruction
00001B06                            		inc	e	; WARNING (see comment)	; 04	; advance to next instruction (ONLY WORKS IF THE INSTRUCTIONS DON'T CROSS A 100 BYTE BOUNDARY, please align)
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            ; Warning stuff
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            
00001B37                            
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ===========================================================================
00001B37                            DualPCM_sz:
000C54BF =00000000                M z80prg	=	0
000C54BF                          M 	mexit
000C54BF                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            ; Error handler
000C54BF                            ; -------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            		include	"_ERROR_/error.asm"
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; Mighty The Armadillo in PRISM PARADISE
000C54BF                            ; By Nat The Porcupine 2021
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; Vladikcomper's debugger
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            
000C54BF                            exBus	EQU	ICD_BLK
000C54BF                            exAddr	EQU	ICD_BLK
000C54BF                            exIll	EQU	ICD_BLK
000C54BF                            exDiv	EQU	ICD_BLK
000C54BF                            exChk	EQU	ICD_BLK
000C54BF                            Trapv	EQU	ICD_BLK
000C54BF                            exPriv	EQU	ICD_BLK
000C54BF                            exTrace	EQU	ICD_BLK
000C54BF                            exLineA	EQU	ICD_BLK
000C54BF                            exLineF	EQU	ICD_BLK
000C54BF                            exMisc	EQU	ICD_BLK
000C54BF                            
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; =========================================================================================================================================================
