00000000                            ; =========================================================================================================================================================
00000000                            ; Hedgebrew Engine (Clean, Overhauled, Enhanced S3&K Engine)
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Configuration
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Configuration.asm"	; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ASM68K Options
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		opt	l.				; Use "." for local labels
00000000                            		opt	ws+				; allow white spaces in operand parsing
00000000                            		opt	op+				; Optimize to PC relative addressing
00000000                            		opt	os+				; Optimize short branches
00000000                            		opt	ow+				; Optimize absolute long addressing
00000000                            		opt	oz+				; Optimize zero displacements
00000000                            		opt	oaq+				; Optimize to addq
00000000                            		opt	osq+				; Optimize to subq
00000000                            		opt	omq+				; Optimize to moveq
00000000                            		opt	ae-				; Disable automatic evens
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Required
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            GAME_NAME	equs	"Hedgebrew Engine Project                        "; International name
00000000                            IO_SUPPORT	equs	"J"				; I/O support
00000000 =20202020                  SRAM_SUPPORT	equ	$20202020			; SRAM support
00000000 =20202020                  SRAM_START	equ	$20202020			; SRAM start address
00000000 =20202020                  SRAM_END	equ	$20202020			; SRAM end address
00000000                            NOTES		equs	""; Notes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000001                  DEBUG_BUILD	equ	1				; Debug build flag (0 = Disabled)
00000000                            ENABLE_HANDLER	equ	0|DEBUG				; Vladikcomper's error handler enable flag (0 = Disabled)
00000000 =00000000                  ENABLE_LAGMETER	equ	0				; Lag meter enable flag (0 = Disabled)
00000000 =00000001                  DEBUG		equ	DEBUG_BUILD			; Hack
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Sound/langZ80.asm"		; Z80 Language macros
00000000                            ; MADE BY NATSUMI 2017
00000000                            
00000000                            ; DEFINE HELPERS
00000000 =00000000                  z80prg =	0		; 0 IN 68K MODE, 1 IN Z80 MODE
00000000 =00000000                  ztemp =		0		; TEMPORARY REGISTER
00000000 =00000000                  zundoc =	0		; SET TO 0 TO USE UNDOCUMENTED OPCODES
00000000 =00000001                  zchkoffs =	1		; SET TO 0 TO NOT CHECK IX/IY AND JR OFFSETS
00000000                            z80regstr	EQUS "a b c d e h l bc de hl sp af ix iy i r ixh ixl iyh iyl (bc) (de) (hl) (sp) af' (ix) (iy)"
00000000                            
00000000                            ; EASILY MAKE SECTIONS
00000000                            z80prog	macro obj
00000000                            	if narg=0
00000000                            		OBJEND
00000000                            	; magic function that fixes all the jr and djnz opcodes, along with offsets.
00000000                            	; Used for detecting illegal forward jumps
00000000                            		local lastpos
00000000                            lastpos =	*
00000000                            			local off, byte
00000000                            		rept zfuturec
00000000                            			popp off
00000000                            			popp byte
00000000                            			org zfuturepos-zfutureobj+off
00000000                            			dc.b byte
00000000                            		endr
00000000                            		org lastpos
00000000                            		POPO		; restore options
00000000                            z80prg =	0
00000000                            		MEXIT		; exit macro here
00000000                            	endif
00000000                            	PUSHO			; push options
00000000                            	OPT AE-			; automatic evens off
00000000                            	OPT AN+			; allow use of 100H instead of $100
00000000                            	OPT M-			; do not print better macro info. Comment out for large text dump.
00000000                            	OPT D-			; make sure EQU/SET do not descope local lables
00000000                            zfutureobj =	\obj
00000000                            zfuturepos =	*
00000000                            zfuturec =	0
00000000                            	if narg=1
00000000                            		OBJ \obj
00000000                            z80prg =	1
00000000                            	else
00000000                            		inform 0,"Invalid num of args!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; CREATE A LITTLE-ENDIAN Z80 ABSOLUTE ADDRESS
00000000                            z80word	macro word
00000000                            	dc.b ((\word)&$FF), ((\word)>>8&$FF)
00000000                                endm
00000000                            
00000000                            ; SAVES THE RÃˆGISTER ID TO ZTEMP
00000000                            zgetreg	macro reg, err
00000000                            	if strlen("\reg")=0
00000000                            		inform \err,"The register must not be empty!"
00000000                            		mexit
00000000                            	endif
00000000                            ztemp = instr("\z80regstr", "\reg")
00000000                            	if (ztemp<>0)&(ztemp<55)
00000000                            ztemp =		(z\reg)
00000000                            	elseif ztemp=56
00000000                            ztemp =		zbcr
00000000                            	elseif ztemp=61
00000000                            ztemp =		zder
00000000                            	elseif ztemp=66
00000000                            ztemp =		zhlr
00000000                            	elseif ztemp=71
00000000                            ztemp =		zspr
00000000                            	elseif ztemp=76
00000000                            ztemp =		zaf2
00000000                            	elseif ztemp=79
00000000                            ztemp =		zixr
00000000                            	elseif ztemp=85
00000000                            ztemp =		ziyr
00000000                            	else
00000000                            		if instr("\reg", "(ix+")<>0|instr("\reg", "(ix-")<>0
00000000                            ztemp =		zixp
00000000                            		elseif instr("\reg", "(iy+")<>0|instr("\reg", "(iy-")<>0
00000000                            ztemp =		ziyp
00000000                            		else
00000000                            ztemp =			-1
00000000                            			local a, cc, p
00000000                            a =			0
00000000                            p =			1
00000000                            d =			0
00000000                            			while a=0
00000000                            				if p>strlen("\reg")
00000000                            ztemp =					-2
00000000                            a =					1
00000000                            				else
00000000                            cc					substr p,p,"\reg"
00000000                            					if '\cc'='('
00000000                            d =						d+1
00000000                            					elseif '\cc'=')'
00000000                            d =						d-1
00000000                            					elseif ('\cc'<>' ')&('\cc'<>'	')
00000000                            						if d<1
00000000                            a =							1
00000000                            						endif
00000000                            					endif
00000000                            				endif
00000000                            p =				p+1
00000000                            			endw
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; PLACES THE SIGNED OFFSET INTO ROM, AND QUEUES A CHECK
00000000                            zindoff	macro reg, byte
00000000                            	local off
00000000                            off	substr 4, strlen("\reg")-1, "\reg"
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zjrfuture macro off, byte
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; QUEUES SIGNED VALUES TO BE FIXED
00000000                            zfuture	macro byte
00000000                            zfuturec =	zfuturec+1
00000000                            		local p,v
00000000                            p =		*-2
00000000                            v =		\byte
00000000                            		pushp "\#v"
00000000                            		pushp "\#p"
00000000                                endm
00000000                            
00000000                            ; Define equates for registers
00000000 =00000000                  zb = 	0
00000000 =00000001                  zc =	1
00000000 =00000002                  zd =	2
00000000 =00000003                  ze =	3
00000000 =00000004                  zh =	4
00000000 =00000005                  zl =	5
00000000 =00000007                  za =	7
00000000 =00000008                  zbc =	8
00000000 =00000009                  zde =	9
00000000 =0000000A                  zhl =	$A
00000000 =0000000B                  zsp =	$B
00000000 =00000018                  zbcr =	$18
00000000 =00000019                  zder =	$19
00000000 =0000001A                  zhlr =	$1A
00000000 =0000001B                  zspr =	$1B
00000000 =00000020                  zix =	$20
00000000 =00000021                  ziy =	$21
00000000 =00000022                  zixr =	$22
00000000 =00000023                  ziyr =	$23
00000000 =00000024                  zixp =	$24
00000000 =00000025                  ziyp =	$25
00000000 =00000028                  zixh =	$28
00000000 =00000029                  zixl =	$29
00000000 =0000002A                  ziyh =	$2A
00000000 =0000002B                  ziyl =	$2B
00000000 =00000030                  zaf =	$30
00000000 =00000031                  zaf2 =	$31
00000000 =00000038                  zi =	$38
00000000 =00000039                  zr =	$39
00000000                            
00000000                            
00000000                            ; Define instructions
00000000                            
00000000                            db	macro val
00000000                            	dc.b \_
00000000                                endm
00000000                            
00000000                            dsb	macro num, val
00000000                            	dcb.b \_
00000000                                endm
00000000                            
00000000                            dw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            dsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            rlc	macro reg, reg2
00000000                            	zgetreg \reg, 0
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $00+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $00+ztemp		; rlc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $06			; rlc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rlc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rlc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rrc	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $08+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $08+ztemp		; rrc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $0E			; rrc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rrc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rrc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $10+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $10+ztemp		; rl a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $16			; rl (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rl (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rl (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rr	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $18+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $18+ztemp		; rr a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $1E			; rr (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rr (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rr (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sla	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $20+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $20+ztemp		; sla a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $26			; sla (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sla (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sla (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sra	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $28+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $28+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $2E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sll	macro reg
00000000                            	if zundoc
00000000                            		inform 2,"Undocumented opcodes are not enabled."
00000000                            	endif
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $30+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $30+ztemp		; sll a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $36			; sll (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sll (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sll (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            srl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $38+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $38+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $3E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            bit	macro bit, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $40+ztemp+(\bit*$08)	; bit 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $46+(\bit*$08)	; bit 0-7,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; bit 0-7,(ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; bit 0-7,(iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            res	macro bit, reg, reg2
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $80+ztemp+(\bit*$08)	; res 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $86+(\bit*$08)	; res 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; res 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $80+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zset	macro bit, reg
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $C0+ztemp+(\bit*$08)	; set 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $C6+(\bit*$08)	; set 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; set 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $C0+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            im	macro im
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if "\im"="0/1"
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $ED, $4E		; im 0/1
00000000                            	elseif (\im<0)|(\im>2)
00000000                            		inform 2,"Interrupt mode must only be 0, 1 or 2!"
00000000                            	elseif \im=2
00000000                            		dc.b $ED, $5E		; im 2
00000000                            	else
00000000                            		dc.b $ED, $46+(\im*$10); im 0 or 1
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rst	macro addr
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if type(\addr)&1
00000000                            		if (\addr&7)=0
00000000                            			if \addr>$48|\addr<0
00000000                            				inform 2,"Invalid address! Must be at least 0 and at most $38!"
00000000                            			endif
00000000                            		else
00000000                            			inform 2,"Address must be aligned by $8!"
00000000                            		endif
00000000                            	endif
00000000                            		dc.b $C7+\addr	; RST *
00000000                                endm
00000000                            
00000000                            inc	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $04+(ztemp*$08)		; inc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $34			; inc (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $03+((ztemp-zbc)*$10)	; inc bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $23			; inc ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $23			; inc iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; inc ix+
00000000                            		zindoff \reg, $34
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; inc iy+
00000000                            		zindoff \reg, $34
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $24+((ztemp&$01)*$08); inc ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            dec	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $05+(ztemp*$08)		; dec a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $35			; dec (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $0B+((ztemp-zbc)*$10)	; dec bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $2B			; dec ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $2B			; dec iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; dec ix+
00000000                            		zindoff \reg, $35
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; dec iy+
00000000                            		zindoff \reg, $35
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $25+((ztemp&$01)*$08); dec ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zsub	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $D6			; sub a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $90+ztemp			; sub a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $96			; sub a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sub a,(ix+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sub a,(iy+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $94+(ztemp&$01); sub a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zand	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $E6			; and a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A0+ztemp			; and a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $A6			; and a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; and a,(ix+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; and a,(iy+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $A4+(ztemp&$01); and a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $F6			; or a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B0+ztemp			; or a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; or a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; or a,(ix+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; or a,(iy+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $B4+(ztemp&$01); or a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            xor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $EE			; xor a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A8+ztemp			; xor a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; xor a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; xor a,(ix+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; xor a,(iy+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $AC+(ztemp&$01); xor a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            cp	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $FE			; cp a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B8+ztemp			; cp a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $BE			; cp a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; cp a,(ix+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; cp a,(iy+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $BC+(ztemp&$01); cp a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zadd	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; add a,(ix+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; add a,(iy+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $86		; add a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $C6		; add a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $80+ztemp		; add a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $84+(ztemp&$01); add a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $09+((ztemp-zbc)*$10)	; add hl,bc, de, hl or sp
00000000                            	elseif ztemp1=zix
00000000                            		dc.b $DD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add ix,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add ix,de
00000000                            		elseif ztemp=zix
00000000                            			dc.b $29		; add ix,ix
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add ix,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: ix, \reg2!"
00000000                            		endif
00000000                            	elseif ztemp1=ziy
00000000                            		dc.b $FD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add iy,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add iy,de
00000000                            		elseif ztemp=ziy
00000000                            			dc.b $29		; add iy,iy
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add iy,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: iy, \reg2!"
00000000                            		endif
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            adc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; adc a,(ix+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; adc a,(iy+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $8E		; adc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $CE		; adc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $88+ztemp		; adc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $8C+(ztemp&$01); adc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $4A+((ztemp-zbc)*$10)	; adc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sbc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; sbc a,(ix+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; sbc a,(iy+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $9E		; sbc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DE		; sbc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $98+ztemp		; sbc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $9C+(ztemp&$01); sbc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $42+((ztemp-zbc)*$10)	; sbc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpop	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C1+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F1		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E1		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E1		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpush	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C5+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F5		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E5		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E5		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ex	macro reg1, reg2
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            	if ((zreg1=zaf)|(zreg1=zaf2))&((ztemp=zaf)|(ztemp=zaf2))
00000000                            		dc.b $08			; ex af,af' & ex af',af & ex af,af
00000000                            	elseif ((zreg1=zde)|(zreg1=zhl))&((ztemp=zde)|(ztemp=zhl))
00000000                            		dc.b $EB			; ex de,hl & ex hl,de
00000000                            	elseif ((zreg1=zspr)|(zreg1=zhl))&((ztemp=zspr)|(ztemp=zhl))
00000000                            		dc.b $E3			; ex (sp),hl & ex hl,(sp)
00000000                            	elseif ((zreg1=zix)|(zreg1=zspr))&((ztemp=zix)|(ztemp=zspr))
00000000                            		dc.b $DD,$E3			; ex (sp),ix & ex ix,(sp)
00000000                            	elseif ((zreg1=ziy)|(zreg1=zspr))&((ztemp=ziy)|(ztemp=zspr))
00000000                            		dc.b $FD,$E3			; ex (sp),iy & ex iy,(sp)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            out	macro port, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if (ztemp=-1)&(instr("\port", "0")<>0)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $71		; out (c),0
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $41+(ztemp*$08)		; out (c),a, b, c, d, e, h or l
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; out (*),a
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            in	macro reg, port
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if narg=1
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $70		; in (c)
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $40+(ztemp*$08)		; in a, b, c, d, e, h or l,(c)
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; in a,(*)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ld	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            zreg2 =	ztemp
00000000                            	if zreg1=-2
00000000                            		if zreg2=za
00000000                            			dc.b $32			; ld (**),a
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zhl
00000000                            			dc.b $22			; ld (**),hl
00000000                            			z80word \reg1
00000000                            		elseif (zreg2>=zbc)&(zreg2<=zsp)
00000000                            			dc.b $ED, $43+((zreg2-zbc)*$10)	; ld (**),bc, de, sp
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zix
00000000                            			dc.b $DD, $22			; ld (**),ix
00000000                            			z80word \reg1
00000000                            		elseif zreg2=ziy
00000000                            			dc.b $FD, $22			; ld (**),iy
00000000                            			z80word \reg1
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-1
00000000                            		if (zreg1<=za)
00000000                            			dc.b $06+(zreg1*$08), \reg2	; ld a, b, c, d, e, h or l,*
00000000                            		elseif zreg1=zhlr
00000000                            			dc.b $36, \reg2			; ld (hl),*
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $01+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $21			; ld ix,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $21			; ld iy,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zixp
00000000                            			dc.b $DD			; ld (ix+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif zreg1=ziyp
00000000                            			dc.b $FD			; ld (iy+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif (zreg1>=zixh)&(zreg1<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((zreg1&$02)*$10), $26+((zreg1&$01)*$08), \reg2; ld ixh, ixl, iyh, iyl,*
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-2
00000000                            		if (zreg1=za)
00000000                            			dc.b $3A			; ld a,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zhl
00000000                            			dc.b $2A			; ld hl,(**)
00000000                            			z80word \reg2
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $ED, $4B+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $2A			; ld ix,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $2A			; ld iy,(**)
00000000                            			z80word \reg2
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif (zreg1<=za)&(zreg2<=za)
00000000                            		dc.b $40+(zreg1*$08)+zreg2		; ld a, b, c, d, e, h or l,a, b, c, d, e, h or l
00000000                            	elseif (zreg1=za)&(zreg2=zbcr)
00000000                            		dc.b $0A				; ld a,(bc)
00000000                            	elseif (zreg1=za)&(zreg2=zder)
00000000                            		dc.b $1A				; ld a,(de)
00000000                            	elseif (zreg1<=za)&(zreg2=zhlr)
00000000                            		dc.b $46+(zreg1*$08)			; ld a, b, c, d, e, h or l,(hl)
00000000                            	elseif (zreg1=zhlr)&(zreg2<=za)
00000000                            		dc.b $70+zreg2				; ld (hl),a, b, c, d, e, h or l
00000000                            	elseif (zreg1<=za)&(zreg2=zixp)
00000000                            		dc.b $DD				; ld a, b, c, d, e, h or l,(ix+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg1<=za)&(zreg2=ziyp)
00000000                            		dc.b $FD				; ld a, b, c, d, e, h or l,(iy+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg2<=za)&(zreg1=zixp)
00000000                            		dc.b $DD				; ld (ix+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg2<=za)&(zreg1=ziyp)
00000000                            		dc.b $FD				; ld (iy+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg1=zbcr)&(zreg2=za)
00000000                            		dc.b $02				; ld (bc),a
00000000                            	elseif (zreg1=zder)&(zreg2=za)
00000000                            		dc.b $12				; ld (de),a
00000000                            	elseif (zreg1=zsp)&(zreg2=zhl)
00000000                            		dc.b $F9				; ld sp,hl
00000000                            	elseif (zreg1=zi)&(zreg2=za)
00000000                            		dc.b $ED, $47				; ld i,a
00000000                            	elseif (zreg2=zi)&(zreg1=za)
00000000                            		dc.b $ED, $57				; ld a,i
00000000                            	elseif (zreg1=zr)&(zreg2=za)
00000000                            		dc.b $ED, $4F				; ld r,a
00000000                            	elseif (zreg2=zr)&(zreg1=za)
00000000                            		dc.b $ED, $5F				; ld a,r
00000000                            	elseif (zreg1=zsp)&(zreg2=zix)
00000000                            		dc.b $DD, $F9				; ld sp, ix
00000000                            	elseif (zreg1=zsp)&(zreg2=ziy)
00000000                            		dc.b $FD, $F9				; ld sp, iy
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&((zreg2<=za)&(zreg2<>zh)&(zreg2<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+zreg2; ld ixh, ixl, iyh, iyl,a, b, c, d, e
00000000                            	elseif (zreg2>=zixh)&(zreg2<=ziyl)&((zreg1<=za)&(zreg1<>zh)&(zreg1<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg2&$02)*$10), $44+(zreg2&$01)+(zreg1*$08); ld a, b, c, d, e,ixh, ixl, iyh, iyl
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&(zreg2>=zixh)&(zreg2>=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if ((zreg1&$02)<>(zreg2&$02))
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            			mexit
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+(zreg2&$01); ld ixh, ixl, iyh, iyl,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            djnz	macro addr
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \addr-*-2, $10
00000000                                endm
00000000                            
00000000                            jr	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zjrfuture \cond-*-2, $18
00000000                            	else
00000000                            		jr\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jrnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $20
00000000                                endm
00000000                            
00000000                            jrnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $30
00000000                                endm
00000000                            
00000000                            jrz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $28
00000000                                endm
00000000                            
00000000                            jrc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $38
00000000                                endm
00000000                            
00000000                            jp	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zgetreg \cond, 0
00000000                            		if ztemp=zhlr
00000000                            			dc.b $E9		; jp (hl)
00000000                            		elseif ztemp=zixr
00000000                            			dc.b $DD, $E9		; jp (ix)
00000000                            		elseif ztemp=ziyr
00000000                            			dc.b $FD, $E9		; jp (iy)
00000000                            		else
00000000                            			dc.b $C3		; jp **
00000000                            			z80word \cond
00000000                            		endif
00000000                            	else
00000000                            		jp\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jpnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpc	macro off
00000000                            	dc.b $DA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            call	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		dc.b $CD
00000000                            		z80word \cond
00000000                            	else
00000000                            		call\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            callnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $DC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            ret	macro cond
00000000                            	if narg=0
00000000                            		dc.b $C9
00000000                            	else
00000000                            		ret\cond
00000000                            	endif
00000000                                endm
00000000                            
00000000                            retnz	macro
00000000                            	dc.b $C0
00000000                                endm
00000000                            
00000000                            retz	macro
00000000                            	dc.b $C8
00000000                                endm
00000000                            
00000000                            retnc	macro
00000000                            	dc.b $D0
00000000                                endm
00000000                            
00000000                            retc	macro
00000000                            	dc.b $D8
00000000                                endm
00000000                            
00000000                            retpo	macro
00000000                            	dc.b $E0
00000000                                endm
00000000                            
00000000                            retpe	macro
00000000                            	dc.b $E8
00000000                                endm
00000000                            
00000000                            retp	macro
00000000                            	dc.b $F0
00000000                                endm
00000000                            
00000000                            retm	macro
00000000                            	dc.b $F8
00000000                                endm
00000000                            
00000000                            di	macro
00000000                            	if z80prg=0
00000000                            		move	#$2700,sr	; THIS IS HERE, IF YOU WANNA USE DI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $F3
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ei	macro
00000000                            	if z80prg=0
00000000                            		move	#$2300,sr	; THIS IS HERE, IF YOU WANNA USE EI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $FB
00000000                            	endif
00000000                                endm
00000000                            
00000000                            halt	macro
00000000                            	if z80prg=0
00000000                            		stop	#$2700		; THIS IS HERE, IF YOU WANNA USE HALT IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $76
00000000                            	endif
00000000                                endm
00000000                            
00000000                            znop	macro
00000000                            	dc.b $00
00000000                                endm
00000000                            
00000000                            rlca	macro
00000000                            	dc.b $07
00000000                                endm
00000000                            
00000000                            rla	macro
00000000                            	dc.b $17
00000000                                endm
00000000                            
00000000                            daa	macro
00000000                            	dc.b $27
00000000                                endm
00000000                            
00000000                            scf	macro
00000000                            	dc.b $37
00000000                                endm
00000000                            
00000000                            rrca	macro
00000000                            	dc.b $0F
00000000                                endm
00000000                            
00000000                            rra	macro
00000000                            	dc.b $1F
00000000                                endm
00000000                            
00000000                            cpl	macro
00000000                            	dc.b $2F
00000000                                endm
00000000                            
00000000                            ccf	macro
00000000                            	dc.b $3F
00000000                                endm
00000000                            
00000000                            exx	macro
00000000                            	dc.b $D9
00000000                                endm
00000000                            
00000000                            zneg	macro
00000000                            	dc.b $ED, $44
00000000                                endm
00000000                            
00000000                            retn	macro
00000000                            	dc.b $ED, $45
00000000                                endm
00000000                            
00000000                            reti	macro
00000000                            	dc.b $ED, $4D
00000000                                endm
00000000                            
00000000                            rrd	macro
00000000                            	dc.b $ED, $67
00000000                                endm
00000000                            
00000000                            rld	macro
00000000                            	dc.b $ED, $6F
00000000                                endm
00000000                            
00000000                            ldi	macro
00000000                            	dc.b $ED, $A0
00000000                                endm
00000000                            
00000000                            cpi	macro
00000000                            	dc.b $ED, $A1
00000000                                endm
00000000                            
00000000                            ini	macro
00000000                            	dc.b $ED, $A2
00000000                                endm
00000000                            
00000000                            outi	macro
00000000                            	dc.b $ED, $A3
00000000                                endm
00000000                            
00000000                            ldd	macro
00000000                            	dc.b $ED, $A8
00000000                                endm
00000000                            
00000000                            cpd	macro
00000000                            	dc.b $ED, $A9
00000000                                endm
00000000                            
00000000                            ind	macro
00000000                            	dc.b $ED, $AA
00000000                                endm
00000000                            
00000000                            outd	macro
00000000                            	dc.b $ED, $AB
00000000                                endm
00000000                            
00000000                            ldir	macro
00000000                            	dc.b $ED, $B0
00000000                                endm
00000000                            
00000000                            cpir	macro
00000000                            	dc.b $ED, $B1
00000000                                endm
00000000                            
00000000                            inir	macro
00000000                            	dc.b $ED, $B2
00000000                                endm
00000000                            
00000000                            otir	macro
00000000                            	dc.b $ED, $B3
00000000                                endm
00000000                            
00000000                            lddr	macro
00000000                            	dc.b $ED, $B8
00000000                                endm
00000000                            
00000000                            cpdr	macro
00000000                            	dc.b $ED, $B9
00000000                                endm
00000000                            
00000000                            indr	macro
00000000                            	dc.b $ED, $BA
00000000                                endm
00000000                            
00000000                            otdr	macro
00000000                            	dc.b $ED, $BB
00000000                                endm
00000000                            		include	"Sound/amps/code/macro.asm"	; AMPS macros
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Various assembly flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            	opt ae+
00000000                            
00000000                            ; if safe mode is enabled (1), then the driver will attempt to find any issues.
00000000                            ; if Vladik's error debugger is installed, then the error will be displayed.
00000000                            ; else, the CPU is trapped.
00000000                            
00000000 =00000001                  safe =	DEBUG
00000000                            
00000000                            ; Select the tempo algorith.
00000000                            ; 0 = Overflow method.
00000000                            ; 1 = Counter method.
00000000                            
00000000 =00000000                  tempo =	0
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Channel configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cFlags		rs.b 1		; various channel flags, see below
00000000 =00000001                  cType		rs.b 1		; hardware type for the channel
00000000 =00000002                  cData		rs.l 1		; 68k tracker address for the channel
00000000 =00000006                  cPanning	rs.b 0		; channel panning and LFO. FM and DAC only
00000000 =00000006                  cEnvPos		rs.b 1		; volume envelope position. PSG only
00000000 =00000007                  cDetune		rs.b 1		; frequency detune (offset)
00000000 =00000008                  cPitch		rs.b 1		; pitch (transposition) offset
00000000 =00000009                  cVolume		rs.b 1		; channel volume
00000000 =0000000A                  cTick		rs.b 1		; channel tick multiplier
00000000 =0000000B                  cSample		rs.b 0		; channel sample ID, DAC only
00000000 =0000000B                  cVolEnv		rs.b 0		; volume envelope ID. PSG only
00000000 =0000000B                  cVoice		rs.b 1		; YM2612 voice ID. FM only
00000000 =0000000C                  cDuration	rs.b 1		; current note duration
00000000 =0000000D                  cLastDur	rs.b 1		; last note duration
00000000 =0000000E                  cFreq		rs.w 1		; channel base frequency
00000000 =00000010                  cModDelay	rs.b 0		; delay before modulation starts
00000000 =00000010                  cMod		rs.l 1		; modulation data address
00000000 =00000014                  cModFreq	rs.w 1		; modulation frequency offset
00000000 =00000016                  cModSpeed	rs.b 1		; number of frames til next modulation step
00000000 =00000017                  cModStep	rs.b 1		; modulation frequency offset per step
00000000 =00000018                  cModCount	rs.b 1		; number of modulation steps until reversal
00000000 =00000019                  cLoop		rs.b 3		; loop counter values
00000000 =0000001B                  cStatPSG4 =	__rs-1		; PSG4 type value. PSG3 only
00000000 =0000001A                  cPrio =		__rs-2		; sound effect channel priority. SFX only
00000000 =0000001C                  cSizeSFX	rs.w 0		; size of each SFX track
00000000                            
00000000 =0000001C                  cNoteTimeCur	rs.b 1		; frame counter to note off. Music only
00000000 =0000001D                  cNoteTimeMain	rs.b 1		; copy of frame counter to note off. Music only
00000000 =0000001E                  cStack		rs.b 1		; channel stack pointer. Music only
00000000                            		rs.b 1		; unused. Music only
00000000                            		rs.l 3		; channel stack data. Music only
00000000 =0000002C                  cSize		rs.w 0		; size of each music track
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for cFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cfbMode		rs.b 0		; set if in pitch mode, clear if in sample mode. DAC only
00000000 =00000000                  cfbRest		rs.b 1		; set if channel is resting. FM and PSG only
00000000 =00000001                  cfbInt		rs.b 1		; set if interrupted by SFX. Music only
00000000 =00000002                  cfbHold		rs.b 1		; set if playing notes does not trigger note-on's
00000000 =00000003                  cfbMod		rs.b 1		; set if modulation is enabled
00000000 =00000004                  cfbCond		rs.b 1		; set if ignoring many tracker commands
00000000 =00000005                  cfbVol		rs.b 1		; set if channel should update volume
00000000 =00000007                  cfbRun =	$07		; set if channel is running a tracker
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc variables for channel modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  ctbPt2 =	$02		; bit part 2 - FM 4-6
00000000 =00000000                  ctFM1 =		$00		; FM 1
00000000 =00000001                  ctFM2 =		$01		; FM 2
00000000 =00000002                  ctFM3 =		$02		; FM 3	- Valid for SFX
00000000 =00000004                  ctFM4 =		$04		; FM 4	- Valid for SFX
00000000 =00000005                  ctFM5 =		$05		; FM 5	- Valid for SFX
00000000                            
00000000 =00000003                  ctbDAC =	$03		; DAC bit
00000000 =0000000B                  ctDAC1 =	(1<<ctbDAC)|$03	; DAC 1	- Valid for SFX
00000000 =0000000E                  ctDAC2 =	(1<<ctbDAC)|$06	; DAC 2
00000000                            
00000000 =00000080                  ctPSG1 =	$80		; PSG 1	- Valid for SFX
00000000 =000000A0                  ctPSG2 =	$A0		; PSG 2	- Valid for SFX
00000000 =000000C0                  ctPSG3 =	$C0		; PSG 3	- Valid for SFX
00000000 =000000E0                  ctPSG4 =	$E0		; PSG 4
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  Mus_DAC =	2		; number of DAC channels
00000000 =00000005                  Mus_FM =	5		; number of FM channels
00000000 =00000003                  Mus_PSG =	3		; number of PSG channels
00000000 =0000000A                  Mus_Ch =	Mus_DAC+Mus_FM+Mus_PSG; total number of music channels
00000000 =00000001                  SFX_DAC =	1		; number of DAC SFX channels
00000000 =00000003                  SFX_FM =	3		; number of FM SFX channels
00000000 =00000003                  SFX_PSG =	3		; number of PSG SFX channels
00000000 =00000007                  SFX_Ch =	SFX_DAC+SFX_FM+SFX_PSG; total number of SFX channels
00000000                            
00000000 =0000001D                  VoiceRegs =	29		; total number of registers inside of a voice
00000000 =00000019                  VoiceTL =	VoiceRegs-4	; location of voice TL levels
00000000                            
00000000 =00001000                  MaxPitch =	$1000		; this is the maximum pitch Dual PCM is capable of processing
00000000 =00000018                  Z80E_Read =	$00018		; this is used by Dual PCM internally but we need this for macros
00000000                            
00000000                            ; NOTE: There is no magic trick to making Dual PCM play samples at higher rates.
00000000                            ; These values are only here to allow you to give lower pitch samples higher
00000000                            ; quality, and playing samples at higher rates than Dual PCM can process them
00000000                            ; may decrease the perceived quality by the end user. Use these equates only
00000000                            ; if you know what you are doing.
00000000                            
00000000 =00000140                  sr17 =		$0140		; 5 Quarter sample rate	17500 Hz
00000000 =00000120                  sr15 =		$0120		; 9 Eights sample rate	15750 Hz
00000000 =00000100                  sr14 =		$0100		; Default sample rate	14000 Hz
00000000 =000000E0                  sr12 =		$00E0		; 7 Eights sample rate	12250 Hz
00000000 =000000C0                  sr10 =		$00C0		; 3 Quarter sample rate	10500 Hz
00000000 =000000A0                  sr8 =		$00A0		; 5 Eights sample rate	8750 Hz
00000000 =00000080                  sr7 =		$0080		; Half sample rate	7000 HZ
00000000 =00000060                  sr5 =		$0060		; 3 Eights sample rate	5250 Hz
00000000 =00000040                  sr3 =		$0040		; 1 Quarter sample rate	3500 Hz
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound driver RAM configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00A00000                  dZ80 =		$A00000		; quick reference to Z80 RAM
00000000 =00C00011                  dPSG =		$C00011		; quick reference to PSG port
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for mFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  mfbRing		rs.b 1		; if set, change speaker (play different sfx)
00000000 =00000001                  mfbSpeed	rs.b 1		; if set, speed shoes are active
00000000 =00000002                  mfbWater	rs.b 1		; if set, underwater mode is active
00000000 =00000003                  mfbNoPAL	rs.b 1		; if set, play songs slowly in PAL region
00000000 =00000007                  mfbPaused =	$07		; if set, sound driver is paused
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound ID equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 1
00000000 =00000001                  Mus_Reset	rs.b 1		; reset underwater and speed shoes flags, update volume
00000000 =00000002                  Mus_FadeOut	rs.b 1		; initialize a music fade out
00000000 =00000003                  Mus_Stop	rs.b 1		; stop all music
00000000 =00000004                  Mus_ShoesOn	rs.b 1		; enable speed shoes mode
00000000 =00000005                  Mus_ShoesOff	rs.b 1		; disable speed shoes mode
00000000 =00000006                  Mus_ToWater	rs.b 1		; enable underwater mode
00000000 =00000007                  Mus_OutWater	rs.b 1		; disable underwater mode
00000000 =00000008                  Mus_Pause	rs.b 1		; pause the music
00000000 =00000009                  Mus_Unpause	rs.b 1		; unpause the music
00000000 =0000000A                  MusOff		rs.b 0		; first music ID
00000000                            
00000000 =00000078                  MusCount =	$78		; number of installed music tracks
00000000 =00000082                  SFXoff =	MusCount+MusOff	; first SFX ID
00000000 =00000078                  SFXcount =	$78		; number of intalled sound effects
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Condition modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  dcoT		rs.b 1		; condition T	; True
00000000 =00000001                  dcoF		rs.b 1		; condition F	; False
00000000 =00000002                  dcoHI		rs.b 1		; condition HI	; HIgher (unsigned)
00000000 =00000003                  dcoLS		rs.b 1		; condition LS	; Less or Same (unsigned)
00000000 =00000004                  dcoHS		rs.b 0		; condition HS	; Higher or Sane (unsigned)
00000000 =00000004                  dcoCC		rs.b 1		; condition CC	; Carry Clear (unsigned)
00000000 =00000005                  dcoLO		rs.b 0		; condition LO	; LOwer (unsigned)
00000000 =00000005                  dcoCS		rs.b 1		; condition CS	; Carry Set (unsigned)
00000000 =00000006                  dcoNE		rs.b 1		; condition NE	; Not Equal
00000000 =00000007                  dcoEQ		rs.b 1		; condition EQ	; EQual
00000000 =00000008                  dcoVC		rs.b 1		; condition VC	; oVerflow Clear (signed)
00000000 =00000009                  dcoVS		rs.b 1		; condition VS	; oVerflow Set (signed)
00000000 =0000000A                  dcoPL		rs.b 1		; condition PL	; Positive (PLus)
00000000 =0000000B                  dcoMI		rs.b 1		; condition MI	; Negamite (MInus)
00000000 =0000000C                  dcoGE		rs.b 1		; condition GE	; Greater or Equal (signed)
00000000 =0000000D                  dcoLT		rs.b 1		; condition LT	; Less Than (signed)
00000000 =0000000E                  dcoGT		rs.b 1		; condition GT	; GreaTer (signed)
00000000 =0000000F                  dcoLE		rs.b 1		; condition LE	; Less or Equal (signed)
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Emvelope commands equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  eReset		rs.w 1		; 80 - Restart from position 0
00000000 =00000082                  eHold		rs.w 1		; 82 - Hold volume at current level
00000000 =00000084                  eLoop		rs.w 1		; 84 - Jump back/forwards according to next byte
00000000 =00000086                  eStop		rs.w 1		; 86 - Stop current note and envelope
00000000 =00000088                  eLast		rs.w 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Fade out end commands
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  fEnd		rs.l 1		; 80 - Do nothing
00000000 =00000084                  fStop		rs.l 1		; 84 - Stop all music
00000000 =00000088                  fResVol		rs.l 1		; 88 - Reset volume and update
00000000 =0000008C                  fReset		rs.l 1		; 8C - Stop music playing and reset volume
00000000 =00000090                  fLast		rs.l 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Quickly read a word from odd address. 28 cycles
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dREAD_WORD	macro areg, dreg
00000000                            	move.b	(\areg)+,(sp)		; read the next byte into stack
00000000                            	move.w	(sp),\dreg		; get word back from stack (shift byte by 8 bits)
00000000                            	move.b	(\areg),\dreg		; get the next byte into register
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; used to calculate the address of the right FM voice
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dCALC_VOICE	macro off
00000000                            	lsl.w	#5,d0			; multiply voice ID by $20
00000000                            	if narg>0
00000000                            		add.w	#\off,d0	; if have had extra argument, add it to offset
00000000                            	endif
00000000                            	add.w	d0,a1			; add offset to voice table address
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to stop, and waits for it to finish stopping (acquire bus)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;stopZ80 	macro
00000000                            ;	move.w	#$100,$A11100		; stop the Z80
00000000                            ;.loop\@
00000000                            ;	btst	#0,$A11100
00000000                            ;	bne.s	.loop\@			; loop until it says it's stopped
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to start again
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;startZ80 	macro
00000000                            ;	move.w	#0,$A11100		; start the Z80
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for pausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSPAUSE	macro	; enable request pause and paused flags
00000000                            	move.b	#Mus_Pause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for unpausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSUNPAUSE	macro	; enable request unpause flag
00000000                            	move.b	#Mus_Unpause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for queueing sound
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            playSnd	macro id, queue	; queue sound
00000000                            	move.b	\id,(mQueue+((\queue\)-1)).w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create volume envelope table, and SMPS2ASM equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            volenv		macro name
00000000                            	rept narg			; repeate for all arguments
00000000                            v\name =	__venv			; create SMPS2ASM equate
00000000                            		dc.l vd\name		; create pointer
00000000                            __venv =	__venv+1		; increase ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates SFX pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrSFX		macro type, name
00000000                            .type =		\type<<24		; create equate for the type mask
00000000                            	rept narg-1			; repeat for all arguments
00000000                            		dc.l \name\|.type	; create pointer with specified type
00000000                            __sfx =		__sfx+1			; increase SFX ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates music pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrMusic	macro name, sptempo
00000000                            	rept narg/2			; repeat for half of the arguments
00000000                            		dc.l ((\sptempo)<<24)|\name\; create pointer with tempo
00000000                            __mus =		__mus+1			; increase music ID
00000000                            	shift				; shift next argument into view
00000000                            	shift				; ''
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Include PCM data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            incSWF		macro name, file
00000000                            SWF_\name\	incbin	\file		; include PCM data
00000000                            SWFR_\name\ 	dcb.b Z80E_Read*(MaxPitch/$100),$00; add end markers (for Dual PCM)
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create data for a sample
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            sample		macro freq, start, loop, name
00000000                            	if narg=4		; if we have 4 arguments, we'd like a custom name
00000000                            d\name =	__samp		; use the extra argument to create SMPS2ASM equate
00000000                            	else
00000000                            d\start =	__samp		; else, use the first one!
00000000                            	endif
00000000                            __samp =	__samp+1	; increase sample ID
00000000                            ; create offsets for the sample normal, reverse, loop normal, loop reverse.
00000000                            	dc.b SWF_\start&$FF,((SWF_\start>>$08)&$7F)|$80,(SWF_\start>>$0F)&$FF
00000000                            	dc.b (SWFR_\start-1)&$FF,(((SWFR_\start-1)>>$08)&$7F)|$80,((SWFR_\start-1)>>$0F)&$FF
00000000                            	dc.b SWF_\loop&$FF,((SWF_\loop>>$08)&$7F)|$80, (SWF_\loop>>$0F)&$FF
00000000                            	dc.b (SWFR_\loop-1)&$FF,(((SWFR_\loop-1)>>$08)&$7F)|$80,((SWFR_\loop-1)>>$0F)&$FF
00000000                            	dc.w \freq-$100		; sample frequency (actually offset, so we remove $100)
00000000                            	dc.w 0			; unused!
00000000                                endm
00000000                            ; ===========================================================================
00000000                            	opt ae-
00000000                            		include	"Sound/amps/code/smps2asm.asm"	; AMPS SMPS2ASM
00000000                            ; ===============================================
00000000                            ; Based on Flamewing's SMPS2ASM, and S1SMPS2ASM by Marc (AKA Cinossu)
00000000                            ; Reworked and improved by Natsumi
00000000                            ; ===============================================
00000000                            ; this macro is created to emulate enum in AS
00000000                            enum	macro	num, lable
00000000                            ; copy initial number for referencing later
00000000                            .num	= num
00000000                            	rept narg-1
00000000                            \lable		set .num
00000000                            .num =	.num+1
00000000                            	shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Note Equates
00000000                            	enum $80+0, nRst
00000000 =00000080                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000080                M nrst	set	.num
00000000 =00000081                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nRst+1,nC0,nCs0,nD0,nEb0,nE0,nF0,nFs0,nG0,nAb0,nA0,nBb0,nB0
00000000 =00000081                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000081                M nc0	set	.num
00000000 =00000082                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000082                M ncs0	set	.num
00000000 =00000083                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000083                M nd0	set	.num
00000000 =00000084                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000084                M neb0	set	.num
00000000 =00000085                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000085                M ne0	set	.num
00000000 =00000086                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000086                M nf0	set	.num
00000000 =00000087                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000087                M nfs0	set	.num
00000000 =00000088                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000088                M ng0	set	.num
00000000 =00000089                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000089                M nab0	set	.num
00000000 =0000008A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008A                M na0	set	.num
00000000 =0000008B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008B                M nbb0	set	.num
00000000 =0000008C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008C                M nb0	set	.num
00000000 =0000008D                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB0+1, nC1,nCs1,nD1,nEb1,nE1,nF1,nFs1,nG1,nAb1,nA1,nBb1,nB1
00000000 =0000008D                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =0000008D                M nc1	set	.num
00000000 =0000008E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008E                M ncs1	set	.num
00000000 =0000008F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008F                M nd1	set	.num
00000000 =00000090                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000090                M neb1	set	.num
00000000 =00000091                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000091                M ne1	set	.num
00000000 =00000092                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000092                M nf1	set	.num
00000000 =00000093                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000093                M nfs1	set	.num
00000000 =00000094                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000094                M ng1	set	.num
00000000 =00000095                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000095                M nab1	set	.num
00000000 =00000096                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000096                M na1	set	.num
00000000 =00000097                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000097                M nbb1	set	.num
00000000 =00000098                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000098                M nb1	set	.num
00000000 =00000099                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB1+1, nC2,nCs2,nD2,nEb2,nE2,nF2,nFs2,nG2,nAb2,nA2,nBb2,nB2
00000000 =00000099                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000099                M nc2	set	.num
00000000 =0000009A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009A                M ncs2	set	.num
00000000 =0000009B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009B                M nd2	set	.num
00000000 =0000009C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009C                M neb2	set	.num
00000000 =0000009D                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009D                M ne2	set	.num
00000000 =0000009E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009E                M nf2	set	.num
00000000 =0000009F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009F                M nfs2	set	.num
00000000 =000000A0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A0                M ng2	set	.num
00000000 =000000A1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A1                M nab2	set	.num
00000000 =000000A2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A2                M na2	set	.num
00000000 =000000A3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A3                M nbb2	set	.num
00000000 =000000A4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A4                M nb2	set	.num
00000000 =000000A5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB2+1, nC3,nCs3,nD3,nEb3,nE3,nF3,nFs3,nG3,nAb3,nA3,nBb3,nB3
00000000 =000000A5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000A5                M nc3	set	.num
00000000 =000000A6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A6                M ncs3	set	.num
00000000 =000000A7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A7                M nd3	set	.num
00000000 =000000A8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A8                M neb3	set	.num
00000000 =000000A9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A9                M ne3	set	.num
00000000 =000000AA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AA                M nf3	set	.num
00000000 =000000AB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AB                M nfs3	set	.num
00000000 =000000AC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AC                M ng3	set	.num
00000000 =000000AD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AD                M nab3	set	.num
00000000 =000000AE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AE                M na3	set	.num
00000000 =000000AF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AF                M nbb3	set	.num
00000000 =000000B0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B0                M nb3	set	.num
00000000 =000000B1                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB3+1, nC4,nCs4,nD4,nEb4,nE4,nF4,nFs4,nG4,nAb4,nA4,nBb4,nB4
00000000 =000000B1                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000B1                M nc4	set	.num
00000000 =000000B2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B2                M ncs4	set	.num
00000000 =000000B3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B3                M nd4	set	.num
00000000 =000000B4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B4                M neb4	set	.num
00000000 =000000B5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B5                M ne4	set	.num
00000000 =000000B6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B6                M nf4	set	.num
00000000 =000000B7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B7                M nfs4	set	.num
00000000 =000000B8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B8                M ng4	set	.num
00000000 =000000B9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B9                M nab4	set	.num
00000000 =000000BA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BA                M na4	set	.num
00000000 =000000BB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BB                M nbb4	set	.num
00000000 =000000BC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BC                M nb4	set	.num
00000000 =000000BD                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB4+1, nC5,nCs5,nD5,nEb5,nE5,nF5,nFs5,nG5,nAb5,nA5,nBb5,nB5
00000000 =000000BD                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000BD                M nc5	set	.num
00000000 =000000BE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BE                M ncs5	set	.num
00000000 =000000BF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BF                M nd5	set	.num
00000000 =000000C0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C0                M neb5	set	.num
00000000 =000000C1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C1                M ne5	set	.num
00000000 =000000C2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C2                M nf5	set	.num
00000000 =000000C3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C3                M nfs5	set	.num
00000000 =000000C4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C4                M ng5	set	.num
00000000 =000000C5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C5                M nab5	set	.num
00000000 =000000C6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C6                M na5	set	.num
00000000 =000000C7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C7                M nbb5	set	.num
00000000 =000000C8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C8                M nb5	set	.num
00000000 =000000C9                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB5+1, nC6,nCs6,nD6,nEb6,nE6,nF6,nFs6,nG6,nAb6,nA6,nBb6,nB6
00000000 =000000C9                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000C9                M nc6	set	.num
00000000 =000000CA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CA                M ncs6	set	.num
00000000 =000000CB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CB                M nd6	set	.num
00000000 =000000CC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CC                M neb6	set	.num
00000000 =000000CD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CD                M ne6	set	.num
00000000 =000000CE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CE                M nf6	set	.num
00000000 =000000CF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CF                M nfs6	set	.num
00000000 =000000D0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D0                M ng6	set	.num
00000000 =000000D1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D1                M nab6	set	.num
00000000 =000000D2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D2                M na6	set	.num
00000000 =000000D3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D3                M nbb6	set	.num
00000000 =000000D4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D4                M nb6	set	.num
00000000 =000000D5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB6+1, nC7,nCs7,nD7,nEb7,nE7,nF7,nFs7,nG7,nAb7,nA7,nBb7
00000000 =000000D5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000D5                M nc7	set	.num
00000000 =000000D6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D6                M ncs7	set	.num
00000000 =000000D7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D7                M nd7	set	.num
00000000 =000000D8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D8                M neb7	set	.num
00000000 =000000D9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D9                M ne7	set	.num
00000000 =000000DA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DA                M nf7	set	.num
00000000 =000000DB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DB                M nfs7	set	.num
00000000 =000000DC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DC                M ng7	set	.num
00000000 =000000DD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DD                M nab7	set	.num
00000000 =000000DE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DE                M na7	set	.num
00000000 =000000DF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DF                M nbb7	set	.num
00000000 =000000E0                M .num	=	.num+1
00000000                          M 	shift
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; PSG volume envelope equates
00000000 =00000000                  v00 =	$00
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Header Macros
00000000                            sHeaderInit	macro
00000000                            sPointZero =	*
00000000                            sPatNum =	0
00000000                                endm
00000000                            
00000000                            ; Header - Set up Channel Usage
00000000                            sHeaderCh	macro fm,psg
00000000                            	dc.b \fm-1
00000000                            	if narg=2
00000000                            		if \fm>5
00000000                            			inform 2,"You sure there are \fm FM channels?"
00000000                            		endif
00000000                            		dc.b \psg-1
00000000                            		if \psg>3
00000000                            			inform 2,"You sure there are \psg PSG channels?"
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Convert S1 tempo to S3 tempo
00000000                            sConvS1Tempo	macro tempo
00000000                            s2tempo = ((((((((tempo=0)&1)<<8)|tempo)-1)<<8)+(((((tempo=0)&1)<<8)|tempo)>>1))/((((tempo=0)&1)<<8)|tempo))&$FF
00000000                            s3tempo = ($100-(((s2tempo=0)&1)|s2tempo))&$FF
00000000                                endm
00000000                            
00000000                            ; Header - Set up Tempo and Tick Multiplier
00000000                            sHeaderTempo	macro tmul,tempo
00000000                            	dc.b \tmul-1,\tempo
00000000                                endm
00000000                            
00000000                            sHeaderTempoS1	macro tmul,tempo
00000000                            	sConvS1Tempo \tempo
00000000                            	dc.b \tmul-1,s3tempo
00000000                                endm
00000000                            
00000000                            ; Header - Set priority leve
00000000                            sHeaderPrio	macro prio
00000000                            	dc.b \prio
00000000                                endm
00000000                            
00000000                            ; Header - Set up DAC Channel
00000000                            sHeaderDAC	macro loc,vol,samp
00000000                            	dc.w \loc-sPointZero
00000000                            	if narg>=2
00000000                            		dc.b \vol
00000000                            		if narg>=3
00000000                            			dc.b \samp
00000000                            		else
00000000                            			dc.b $00
00000000                            		endif
00000000                            	else
00000000                            		dc.w $00
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Header - Set up FM Channel
00000000                            sHeaderFM	macro loc,pitch,vol
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; Header - Set up PSG Channel
00000000                            sHeaderPSG	macro loc,pitch,vol,detune,volenv
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol,\detune,\volenv
00000000                                endm
00000000                            
00000000                            ; Header - Set up SFX Channel
00000000                            sHeaderSFX	macro flags,type,loc,pitch,vol
00000000                            	dc.b \flags,\type
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Command Flag Macros and Equates. Based on the original s1smps2asm, and Flamewing's smps2asm
00000000 =00000000                  spNone set $00
00000000 =00000040                  spRight set $40
00000000 =00000080                  spLeft set $80
00000000 =000000C0                  spCentre set $C0
00000000 =000000C0                  spCenter set $C0
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Macros for FM instruments
00000000                            ; Patches - Feedback
00000000                            
00000000                            ; Patches - Algorithm
00000000                            spAlgorithm macro val, name
00000000                            	if (sPatNum<>0)&(safe=0)
00000000                            		; align the patch
00000000                            		dc.b (*^(sPatNum*spTL4))&$FF
00000000                            		dc.b ((*>>8)+(spDe3*spDR3))&$FF
00000000                            		dc.b ((*>>16)-(spTL1*spRR3))&$FF
00000000                            	endif
00000000                            	if narg>1
00000000                            p\name =	sPatNum
00000000                            	endif
00000000                            sPatNum =	sPatNum+1
00000000                            spAl	= val
00000000                                endm
00000000                            
00000000                            spFeedback macro val
00000000                            spFe	= val
00000000                                endm
00000000                            
00000000                            ; Patches - Detune
00000000                            spDetune macro op1,op2,op3,op4
00000000                            spDe1	= op1
00000000                            spDe2	= op2
00000000                            spDe3	= op3
00000000                            spDe4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Multiple
00000000                            spMultiple macro op1,op2,op3,op4
00000000                            spMu1	= op1
00000000                            spMu2	= op2
00000000                            spMu3	= op3
00000000                            spMu4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Rate Scale
00000000                            spRateScale macro op1,op2,op3,op4
00000000                            spRS1	= op1
00000000                            spRS2	= op2
00000000                            spRS3	= op3
00000000                            spRS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Attack Rate
00000000                            spAttackRt macro op1,op2,op3,op4
00000000                            spAR1	= op1
00000000                            spAR2	= op2
00000000                            spAR3	= op3
00000000                            spAR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Amplitude Modulation
00000000                            spAmpMod macro op1,op2,op3,op4
00000000                            spAM1	= op1
00000000                            spAM2	= op2
00000000                            spAM3	= op3
00000000                            spAM4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Rate
00000000                            spSustainRt macro op1,op2,op3,op4
00000000                            spSR1	= op1		; Also known as decay 1 rate
00000000                            spSR2	= op2
00000000                            spSR3	= op3
00000000                            spSR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Level
00000000                            spSustainLv macro op1,op2,op3,op4
00000000                            spSL1	= op1		; also known as decay 1 level
00000000                            spSL2	= op2
00000000                            spSL3	= op3
00000000                            spSL4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Decay Rate
00000000                            spDecayRt macro op1,op2,op3,op4
00000000                            spDR1	= op1		; Also known as decay 2 rate
00000000                            spDR2	= op2
00000000                            spDR3	= op3
00000000                            spDR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Release Rate
00000000                            spReleaseRt macro op1,op2,op3,op4
00000000                            spRR1	= op1
00000000                            spRR2	= op2
00000000                            spRR3	= op3
00000000                            spRR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - SSG-EG
00000000                            spSSGEG macro op1,op2,op3,op4
00000000                            spSS1	= op1
00000000                            spSS2	= op2
00000000                            spSS3	= op3
00000000                            spSS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level
00000000                            spTotalLv macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            ; Construct the patch finally.
00000000                            	dc.b	(spFe<<3)+spAl
00000000                            ;   0     1     2     3     4     5     6     7
00000000                            ;%1000,%1000,%1000,%1000,%1010,%1110,%1110,%1111
00000000                            spTLMask4 set $80
00000000                            spTLMask2 set ((spAl>=5)<<7)
00000000                            spTLMask3 set ((spAl>=4)<<7)
00000000                            spTLMask1 set ((spAl=7)<<7)
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1|spTLMask1,  spTL3|spTLMask3,  spTL2|spTLMask2,  spTL4|spTLMask4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level (for broken total level masks)
00000000                            spTotalLv2 macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            	dc.b (spFe<<3)+spAl
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1,	       spTL3,		 spTL2,		   spTL4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; SMPS commands
00000000                            
00000000                            ; E0xx - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00000000                            sPan		macro pan, ams, fms
00000000                            	if narg=1
00000000                            		dc.b $E0, \pan
00000000                            	elseif narg=2
00000000                            		dc.b $E0, \pan|\ams
00000000                            	else
00000000                            		dc.b $E0, \pan|(\ams<<4)|\fms
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; E1xx - Set channel frequency displacement to xx (DETUNE_SET)
00000000                            ssDetune	macro val
00000000                            	dc.b $E1, \val
00000000                                endm
00000000                            
00000000                            ; E2xx - Add xx to channel frequency displacement (DETUNE)
00000000                            saDetune	macro val
00000000                            	dc.b $E2, \val
00000000                                endm
00000000                            
00000000                            ; E3xx - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00000000                            ssTranspose	macro val
00000000                            	dc.b $E3, \val
00000000                                endm
00000000                            
00000000                            ; E4xx - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00000000                            saTranspose	macro val
00000000                            	dc.b $E4, \val
00000000                                endm
00000000                            
00000000                            ; E5xx - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00000000                            ssTickMulCh	macro val
00000000                            	dc.b $E5, \val-1
00000000                                endm
00000000                            
00000000                            ; E6xx - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00000000                            ssTickMul	macro val
00000000                            	dc.b $E6, \val-1
00000000                                endm
00000000                            
00000000                            ; E7 - Do not attack of next note (HOLD)
00000000 =000000E7                  sHold =		$E7
00000000                            
00000000                            ; E8xx - Set patch/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00000000                            sVoice		macro val
00000000                            	dc.b $E8, \val
00000000                                endm
00000000                            
00000000                            ; E9xx - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00000000                            ssTempoShoes	macro val
00000000                            	dc.b $E9, \val
00000000                                endm
00000000                            
00000000                            ; EAxx - Set music tempo to xx (TEMPO - TEMPO_SET)
00000000                            ssTempo		macro val
00000000                            	dc.b $EA, \val
00000000                                endm
00000000                            ssTempoS1	macro val
00000000                            	sConvS1Tempo \val
00000000                            	dc.b $EA, s3tempo
00000000                                endm
00000000                            
00000000                            ; EB - Turn on Modulation (MOD_SET - MODS_ON)
00000000                            sModOn		macro
00000000                            	dc.b $EB
00000000                                endm
00000000                            
00000000                            ; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00000000                            sModOff		macro
00000000                            	dc.b $EC
00000000                                endm
00000000                            
00000000                            ; EDxx - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00000000                            saVol		macro vol
00000000                            	dc.b $ED, \vol
00000000                                endm
00000000                            
00000000                            ; EExx - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00000000                            ssVol		macro vol
00000000                            	dc.b $EE, \vol
00000000                                endm
00000000                            
00000000                            ; EFxxyy - Enable/Disable LFO (SET_LFO - LFO_AMSEN)
00000000                            ssLFO		macro reg, ams, fms, pan
00000000                            	if narg=2
00000000                            		dc.b $EF, \reg,\ams
00000000                            	elseif narg=3
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms
00000000                            	else
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms|\pan
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; F0wwxxyyzz - Modulation
00000000                            ;  ww: wait time
00000000                            ;  xx: modulation speed
00000000                            ;  yy: change per step
00000000                            ;  zz: number of steps
00000000                            ; (MOD_SETUP)
00000000                            ssMod68k	macro wait, speed, step, count
00000000                            	dc.b $F0, \wait,\speed,\step,\count
00000000                                endm
00000000                            
00000000                            ; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00000000                            sModeSampDAC	macro
00000000                            	dc.b $F1
00000000                                endm
00000000                            
00000000                            ; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00000000                            sModePitchDAC	macro
00000000                            	dc.b $F2
00000000                                endm
00000000                            
00000000                            ; F3xx - PSG4 noise mode xx (PSG_NOISE - PNOIS_AMPS)
00000000                            sNoisePSG	macro val
00000000                            	dc.b $F3, \val
00000000                                endm
00000000                            
00000000                            ; F4xxxx - Keep looping back to xxxx each time the SFX is being played (CONT_SFX)
00000000                            sCont		macro loc
00000000                            	dc.b $F4
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F5 - End of channel (TRK_END - TEND_STD)
00000000                            sStop		macro
00000000                            	dc.b $F5
00000000                                endm
00000000                            
00000000                            ; F6xxxx - Jump to xxxx (GOTO)
00000000                            ssJump		macro loc
00000000                            	dc.b $F6
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F7xxyyzzzz - Loop back to zzzz yy times, xx being the loop index for loop recursion fixing (LOOP)
00000000                            sLoop		macro index,loops,loc
00000000                            	dc.b $F7, \index
00000000                            	dc.w \loc-*-1
00000000                            	dc.b \loops
00000000                                endm
00000000                            
00000000                            ; F8xxxx - Call pattern at xxxx, saving return point (GOSUB)
00000000                            sCall		macro loc
00000000                            	dc.b $F8
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F9 - Return (RETURN)
00000000                            sRet		macro
00000000                            	dc.b $F9
00000000                                endm
00000000                            
00000000                            ; FAyyxx - Set communications byte yy to xx (SET_COMM - SPECIAL)
00000000                            sComm		macro num, val
00000000                            	dc.b $FA, \num,\val
00000000                                endm
00000000                            
00000000                            ; FBxyzz - Get communications byte y, and compare zz with it using condition x (COMM_CONDITION)
00000000                            sCond		macro num, cond, val
00000000                            	dc.b $FB, \num|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FC - Reset condition (COMM_RESET)
00000000                            sCondOff	macro
00000000                            	dc.b $FC
00000000                                endm
00000000                            
00000000                            ; FDxx - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL)
00000000                            sNoteTimeOut	macro val
00000000                            	dc.b $FD, \val
00000000                                endm
00000000                            
00000000                            ; FExxyy - YM command yy on register xx (YMCMD)
00000000                            sCmdYM		macro reg, val
00000000                            	dc.b $FE, \reg,\val
00000000                                endm
00000000                            
00000000                            ; FF00xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00000000                            sPlaySamp1	macro id
00000000                            	dc.b $FF,$00, \id
00000000                                endm
00000000                            
00000000                            ; FF01xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC2)
00000000                            sPlaySamp2	macro id
00000000                            	dc.b $FF,$01, \id
00000000                                endm
00000000                            
00000000                            ; FF02xxxx - Set channel frequency to xxxx (CHFREQ_SET)
00000000                            ssFreq		macro freq
00000000                            	dc.b $FF,$02
00000000                            	dc.w \freq
00000000                                endm
00000000                            
00000000                            ; FF03xx - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00000000                            ssFreqNote	macro note
00000000                            	dc.b $FF,$03, \note^$80
00000000                                endm
00000000                            
00000000                            ; FF04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00000000                            sSpinRev	macro
00000000                            	dc.b $FF,$04
00000000                                endm
00000000                            
00000000                            ; FF05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00000000                            sSpinReset	macro
00000000                            	dc.b $FF,$05
00000000                                endm
00000000                            
00000000                            ; FF06xx - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00000000                            saTempoSpeed	macro tempo
00000000                            	dc.b $FF,$06, \tempo
00000000                                endm
00000000                            
00000000                            ; FF07xx - Add xx to music tempo (TEMPO - TEMPO_ADD)
00000000                            saTempo		macro tempo
00000000                            	dc.b $FF,$07, \tempo
00000000                                endm
00000000                            
00000000                            ; FF08xyzz - Get RAM address pointer offset by y, compare zz with it using condition x (COMM_CONDITION - COMM_SPEC)
00000000                            sCondReg	macro off, cond, val
00000000                            	dc.b $FF,$08, \off|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FF09xx - Play another music/sfx (SND_CMD)
00000000                            sPlayMus	macro id
00000000                            	dc.b $FF,$09, \id
00000000                                endm
00000000                            
00000000                            ; FF0A - Enable raw frequency mode (RAW_FREQ)
00000000                            sFreqOn		macro freq
00000000                            	dc.b $FF,$0A
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00000000                            sFreqOff	macro freq
00000000                            	dc.b $FF,$0B
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0C - Enable FM3 special mode (SPC_FM3)
00000000                            sSpecFM3	macro freq
00000000                            	dc.b $FF,$0C
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0Dxx - Set DAC filter bank address (DAC_FILTER)
00000000                            ssFilter	macro bank
00000000                            	dc.b $FF,$0D, \bank
00000000                                endm
00000000                            
00000000                            ; FF0E - Freeze 68k. Debug flag (DEBUG_STOP_CPU)
00000000                            sFreeze		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0E
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; FF0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00000000                            sCheck		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0F
00000000                            	endif
00000000                                endm
00000000                            
00000000                            		include	"Config/Constants.asm"		; Constants
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive constants
00000000                            ; =========================================================================================================================================================
00000000 =00000000                  ROM_START		equ	$000000				; ROM area start address
00000000 =00400000                  ROM_END			equ	$3FFFFF+1			; ROM area end address
00000000                            
00000000 =00A00000                  Z80_RAM			equ	$A00000				; Z80 RAM start address
00000000 =00A02000                  Z80_RAM_END		equ	$A02000				; Z80 RAM end address
00000000 =00A11100                  Z80_BUS_REQ		equ	$A11100				; Z80 bus request
00000000 =00A11200                  Z80_RESET		equ	$A11200				; Z80 reset
00000000                            
00000000 =00A04000                  YM2612_A0		equ	$A04000				; M68K YM2612 register port 0
00000000 =00A04001                  YM2612_D0		equ	$A04001				; M68K YM2612 data port 0
00000000 =00A04002                  YM2612_A1		equ	$A04002				; M68K YM2612 register port 1
00000000 =00A04003                  YM2612_D1		equ	$A04003				; M68K YM2612 data port 1
00000000 =00C00011                  PSG_INPUT		equ	$C00011				; M68K PSG input
00000000                            
00000000 =00A10001                  HW_VERSION		equ	$A10001				; Hardware version
00000000 =00A14000                  TMSS_PORT		equ	$A14000				; TMSS port
00000000                            
00000000 =00A10003                  PORT_A_DATA		equ	$A10003				; Port A data
00000000 =00A10005                  PORT_B_DATA		equ	$A10005				; Port B data
00000000 =00A10007                  PORT_C_DATA		equ	$A10007				; Port C data
00000000 =00A10009                  PORT_A_CTRL		equ	$A10009				; Port A control
00000000 =00A1000B                  PORT_B_CTRL		equ	$A1000B				; Port B control
00000000 =00A1000D                  PORT_C_CTRL		equ	$A1000D				; Port C control
00000000 =00A1000F                  PORT_A_TX		equ	$A1000F				; Port A Tx data
00000000 =00A10011                  PORT_A_RX		equ	$A10011				; Port A Rx data
00000000 =00A10013                  PORT_A_SCTRL		equ	$A10013				; Port A S control
00000000 =00A10015                  PORT_B_TX		equ	$A10015				; Port B Tx data
00000000 =00A10017                  PORT_B_RX		equ	$A10017				; Port B Rx data
00000000 =00A10019                  PORT_B_SCTRL		equ	$A10019				; Port B S control
00000000 =00A1001B                  PORT_C_TX		equ	$A1001B				; Port C Tx data
00000000 =00A1001D                  PORT_C_RX		equ	$A1001D				; Port C Rx data
00000000 =00A1001F                  PORT_C_SCTRL		equ	$A1001F				; Port C S control
00000000                            
00000000 =00A130F1                  SRAM_ACCESS		equ	$A130F1				; SRAM access register ($200000 - $3FFFFF)
00000000                            
00000000 =00A130F3                  MAPPER_BANK_1		equ	$A130F3				; Mapper bank 1 register ($080000 - $0FFFFF)
00000000 =00A130F5                  MAPPER_BANK_2		equ	$A130F5				; Mapper bank 2 register ($100000 - $17FFFF)
00000000 =00A130F7                  MAPPER_BANK_3		equ	$A130F7				; Mapper bank 3 register ($180000 - $1FFFFF)
00000000 =00A130F9                  MAPPER_BANK_4		equ	$A130F9				; Mapper bank 4 register ($200000 - $27FFFF)
00000000 =00A130FB                  MAPPER_BANK_5		equ	$A130FB				; Mapper bank 5 register ($280000 - $2FFFFF)
00000000 =00A130FD                  MAPPER_BANK_6		equ	$A130FD				; Mapper bank 6 register ($300000 - $37FFFF)
00000000 =00A130FF                  MAPPER_BANK_7		equ	$A130FF				; Mapper bank 7 register ($380000 - $3FFFFF)
00000000                            
00000000 =00C00000                  VDP_DATA		equ	$C00000				; VDP data port
00000000 =00C00004                  VDP_CTRL		equ	$C00004				; VDP control port
00000000 =00C00008                  VDP_HVCOUNT		equ	$C00008				; VDP H/V counter
00000000 =00C0001C                  VDP_DEBUG		equ	$C0001C				; VDP debug register
00000000                            
00000000 =00FF0000                  RAM_START		equ	$FF0000				; M68K RAM start address
00000000 =01000000                  RAM_END			equ	$FFFFFF+1			; M68K RAM end address
00000000                            
00000000 =FFFF8000                  RAM_WORD_START		equ	$FFFF8000			; Starting address of absolute word addressable M68K RAM
00000000 =00000000                  RAM_WORD_END		equ	$FFFFFFFF+1			; Ending address of absolute word addressable M68K RAM
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Align
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound	- Size boundary
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            align		macros	bound
00000000                            		cnop	0,\bound
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pad RS to even address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------
00000000                            rseven		macros
00000000                            		rs.b	__rs&1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Push registers to stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to push
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            push		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 \regs,-(sp)
00000000                            			else
00000000                            				move.\0	\regs,-(sp)
00000000                            			endif
00000000                            		else
00000000                            			zpush	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Pop registers from stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to pop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            pop		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 (sp)+,\regs
00000000                            			else
00000000                            				move.\0	(sp)+,\regs
00000000                            			endif
00000000                            		else
00000000                            			zpop	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Clear memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	starta	- Address to start clearing memory at
00000000                            ;	enda	- Address to finish clearing memory at
00000000                            ;		  (not rEQUired if there exists a label that is the same as the starting label, but with "_End" at the end of it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            clrRAM		macro	starta, enda
00000000                            		local	endaddr
00000000                            		if narg<2
00000000                            endaddr			EQUS	"\starta\_End"
00000000                            		else
00000000                            endaddr			EQUS	"\enda"
00000000                            		endif
00000000                            		moveq	#0,d0
00000000                            		if ((\starta)&$8000)=0
00000000                            			lea	\starta,a1
00000000                            		else
00000000                            			lea	(\starta).w,a1
00000000                            		endif
00000000                            		if (\starta)&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		move.w	#(((\endaddr)-(\starta))-((\starta)&1))>>2-1,d1
00000000                            .Clear\@:	move.l	d0,(a1)+
00000000                            		dbf	d1,.Clear\@
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&2
00000000                            			move.w	d0,(a1)+
00000000                            		endif
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOff		macros
00000000                            		move.b	#0,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOn		macros
00000000                            		move.b	#1,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOff		macros
00000000                            		ori	#$700,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOn		macros
00000000                            		andi	#$F8FF,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            doZ80Stop	macros
00000000                            		move.w	#$100,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to stop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Stop	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80 and wait for it to
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            stopZ80		macro
00000000                            		doZ80Stop
00000000                          M 	move.w	#$100,z80_bus_req
00000000                            		waitZ80Stop
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            startZ80	macros
00000000                            		move.w	#0,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to start
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Start	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		beq.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80Off	macros
00000000                            		move.w	#$100,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Reset the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80	macros
00000000                            		move.w	#0,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the YM2612 to not be busy
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitYM		macro
00000000                            		nop
00000000                            		nop
00000000                            		nop
00000000                            @Wait\@:	tst.b	(a0)
00000000                            		bmi.s	@Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for DMA finish
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	port	- Something to represent the VDP control port (default is VDP_CTRL_PORT)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00000000                            waitDMA		macro	port
00000000                            .Wait\@:
00000000                            		if narg>0
00000000                            			move.w	\port,d1
00000000                            		else
00000000                            			move.w	VDP_CTRL,d1
00000000                            		endif
00000000                            		btst	#1,d1
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr	- Address in VDP memory
00000000                            ;	type	- Type of VDP memory
00000000                            ;	rwd	- VDP command
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000021                  VRAM		EQU	%100001		; VRAM
00000000 =0000002B                  CRAM		EQU	%101011		; CRAM
00000000 =00000025                  VSRAM		EQU	%100101		; VSRAM
00000000 =0000000C                  READ		EQU	%001100		; VDP read
00000000 =00000007                  WRITE		EQU	%000111		; VDP write
00000000 =00000027                  DMA		EQU	%100111		; VDP DMA
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            vdpCmd		macro	ins, addr, type, rwd, end, end2
00000000                            		if narg=5
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14)), \end
00000000                            		elseif narg>=6
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))\end, \end2
00000000                            		else
00000000                            			\ins	((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in 68000 memory
00000000                            ;	dest	- Destination address in VDP memory
00000000                            ;	len	- Length of data in bytes
00000000                            ;	type	- Type of VDP memory
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dma68k		macro	src, dest, len, type, port
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(a6)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(a6)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, >>16, (a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, &$FFFF, -(sp)
00000000                            		move.w	(sp)+,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Fill VRAM with byte
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte	- Byte to fill VRAM with
00000000                            ;	addr	- Address in VRAM
00000000                            ;	len	- Length of fill in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaFill		macro	byte, addr, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.w	#$9780,(a6)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(a6)
00000000                            		move.w	#(\byte)<<8,-4(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Copy a region of VRAM to a location in VRAM
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in VRAM
00000000                            ;	dest	- Destination address in VRAM
00000000                            ;	len	- Length of copy in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaCopy		macro	src, dest, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(a6)
00000000                            		move.w	#$97C0,(a6)
00000000                            		move.l	#$000000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOn		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9193,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOff		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9100,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOff	macro
00000000                            		move.w	vdpReg1.w,d0
00000000                            		andi.b	#%10111111,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOn	macro
00000000                            		move.w	vdpReg1.w,d0
00000000                            		ori.b	#%01000000,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDDown	macros
00000000                            		move.l	#-$80000,rHUD_Accel.w		; Set to move HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDUp	macros
00000000                            		move.l	#$8000,rHUD_Accel.w		; Set to move HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Convert a string to the textbox's format and store as a line
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	str	- The string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLine		macro	str
00000000                            c		= 1
00000000                            		rept	strlen(\str)
00000000                            ochar			substr c, c, \str
00000000                            char			substr "\ochar"-$1F, "\ochar"-$1F, "skojh`aledisfsg\0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ABCDEFGHIJKLMNOPQRSTUVWXYZncmb"
00000000                            			dc.w	"\char"+$588
00000000                            c			= c+1
00000000                            		endr
00000000                            		dc.w	$FFFF
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a line break character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineBreak	macros
00000000                            		dc.w	$FFFF
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a message terminator character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineEnd	macros
00000000                            		dc.w	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an animation change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ani	- New animation script pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewAni	macro	ani
00000000                            		dc.w	$FFFE
00000000                            		dc.l	\ani
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an icon change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	icon	- New icon art pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewIcon	macro	icon
00000000                            		dc.w	$FFFD
00000000                            		dc.l	\icon
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a finished flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtEnd		macros
00000000                            		dc.w	$FFFC
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an entry to the level art animation script
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	duration	- Global duration
00000000                            ;	artaddr		- Source art
00000000                            ;	tileid		- Destination tile ID
00000000                            ;	numentries	- Number of entries
00000000                            ;	numvramtiles	- Number of tiles per entry
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lvlAniDat	macro	duration, artaddr, tileid, numentries, numvramtiles
00000000                            		dc.l	(\duration&$FF)<<24|\artaddr
00000000                            		dc.w	((\tileid&$7FF)<<5)
00000000                            		dc.b	\numentries, \numvramtiles
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Get a unique character set from a string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string		- String to go throuhg
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	unique_chars	- A string of unique characters found
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            getUniqueChars	macro	string
00000000                            unique_chars	substr 1,1,\string
00000000                            strpos		= 1
00000000                            		while strpos<strlen(\string)
00000000                            found			= 0
00000000                            pos			= 0
00000000                            char			substr strpos+1,strpos+1,\string
00000000                            			while (pos<strlen("\unique_chars"))&(found=0)
00000000                            uchar				substr pos+1,pos+1,"\unique_chars"
00000000                            				if strcmp("\uchar","\char")|strcmp("\char", " ")
00000000                            found					= 1
00000000                            				endif
00000000                            pos				= pos+1
00000000                            			endw
00000000                            			if found=0
00000000                            unique_chars			equs "\unique_chars\\char"
00000000                            			endif
00000000                            strpos			= strpos+1
00000000                            			endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Run objects macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            runObjects		macro
00000000                            		movea.w	objExecFirst.w,a0				; load first object slot into a0
00000000                            		move.l	_objAddress(a0),a1				; load its pointer to a1
00000000                            		jsr	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Next object macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            nextObject		macro
00000000                            		movea.w	_objNext(a0),a0				; load the next object address to a0
00000000                            		move.l	_objAddress(a0),a1				; load its pointer to a1
00000000                            		jmp	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	layer	- The destination display layer
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySprite		macro	layer, obj, fre, chk
00000000                            ;	if layer >= 8
00000000                            ;		inform 2,"Invalid display layer!"
00000000                            ;	endif
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\obj)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	#objDisplay+(\layer*dSize),_objDrawNext(\obj)	; put end marker as the next pointer
00000000                            		move.w	objDisplay+dPrev+(\layer*dSize).w,\fre		; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,_objDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,_objDrawNext(\fre)				;
00000000                            		move.w	\obj,objDisplay+dPrev+(\layer*dSize).w		; copy the pointer from the end marker to dst register
00000000                            ;		cmp.w	#objDisplay+(\layer*dSize),objDisplay+dPrev+(\layer*dSize).w	; special case: points to itself
00000000                            ;		bne.s	.no\@								; if no, skip
00000000                            ;		move.w	\obj,objDisplay+dPrev+(\layer*dSize).w				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list using an address register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg	- The address regsister containing target
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySpriteReg		macro	reg, obj, fre, chk
00000000                            	local layer
00000000                            layer EQUR	\reg							; convert register
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\reg)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	layer,_objDrawNext(\obj)				; put end marker as the next pointer
00000000                            		move.w	_objDrawPrev(layer),\fre				; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,_objDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,_objDrawNext(\fre)				;
00000000                            		move.w	\obj,_objDrawPrev(layer)				; copy the pointer from the end marker to dst register
00000000                            ;		cmp.w	_objDrawPrev(layer),layer				; special case: points to itself
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\obj,_objDrawPrev(layer)				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Remove a sprite from a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            removeSprite		macro	obj, fre, chk
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\obj)					; check if displayed already
00000000                            		beq.s	.yes\@						; if not, skip
00000000                            	endif
00000000                            		move.w	_objDrawPrev(\obj),\fre				; load the prev pointer to dst
00000000                            		move.w	_objDrawNext(\obj),_objDrawNext(\fre)			; copy the next object pointer from src to dst
00000000                            		move.w	_objDrawNext(\obj),\fre				; load the next pointer to dst
00000000                            		move.w	_objDrawPrev(\obj),_objDrawPrev(\fre)			; copy the prev object pointer from src to dst
00000000                            ;		cmp.w	_objDrawPrev(\obj),\fre				; special case: last object
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\fre,_objDrawNext(\fre)				; else, change to point to same address
00000000                            .no\@
00000000                            		clr.l	_objDrawNext(\obj)
00000000                            .yes\@
00000000                            	endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Offsets.asm"		; Offsets
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Game mode IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  gTitle		rs.l	1				; Title screen game mode
00000000 =00000004                  gLevel		rs.l	1				; Level game mode
00000000 =00000008                  gEnd		rs.l	1				; Ending game mode
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; V-INT routine IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  vLag		rs.w	1				; Lag updates
00000000 =00000002                  vGeneral	rs.w	1				; General updates
00000000 =00000004                  vLevel		rs.w	1				; Level updates
00000000 =00000006                  vLvlLoad	rs.w	1				; Level load updates
00000000 =00000008                  vTitle		rs.w	1				; Title screen updates
00000000 =0000000A                  vFade		rs.w	1				; Fade updates
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  zWWZ		rs.b	1				; Wacky Workbench
00000000                            
00000000 =00000001                  ZONE_COUNT	equ	__rs				; Number of zones
00000000                            
00000000 =00000000                  lWWZ		equ	zWWZ<<8				; Wacky Workbench
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Music definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	MusOff
00000000 =0000000A                  mFirst		rs.b	0
00000000 =0000000A                  mSega		rs.b	1				; SEGA jingle
00000000 =0000000B                  mWWZ		rs.b	1				; Wacky Workbench music
00000000 =0000000C                  mBoss		rs.b	1				; Boss music
00000000 =0000000D                  mInvincible	rs.b	1				; Invincibility music
00000000 =0000000E                  mEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; SFX definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	SFXoff
00000000 =00000082                  sFirst		rs.b	0
00000000 =00000082                  sLeap		rs.b	1				; Jump sound
00000000 =00000083                  sSkid		rs.b	1				; Skid sound
00000000 =00000084                  sHurt		rs.b	0				; Hurt sound
00000000 =00000084                  sDeath		rs.b	1				; Death sound
00000000 =00000085                  sPush		rs.b	1				; Push sound
00000000 =00000086                  sBubble		rs.b	1				; Bubble sound
00000000 =00000087                  sDrown		rs.b	1				; Drowning sound
00000000 =00000088                  sDrownWarn	rs.b	1				; Drown warning sound
00000000 =00000089                  sDrownCount	rs.b	1				; Drown countdown sound
00000000 =0000008A                  sCheckpoint	rs.b	1				; Checkpoint sound
00000000 =0000008B                  sSpikeMove	rs.b	1				; Spike movement sound
00000000 =0000008C                  sRing		rs.b	1				; Ring sound
00000000 =0000008D                  sRingLoss	rs.b	1				; Ring loss sound
00000000 =0000008E                  sSpring		rs.b	1				; Spring sound
00000000 =0000008F                  sShield		rs.b	1				; Shield sound
00000000 =00000090                  sSplash		rs.b	1				; Water splash sound
00000000 =00000091                  sBumper		rs.b	1				; Bumper sound
00000000 =00000092                  sSwitch		rs.b	1				; Switch sound
00000000 =00000093                  sSignpost	rs.b	1				; Signpost sound
00000000 =00000094                  sCollapse	rs.b	1				; Collapse sound
00000000 =00000095                  sWallSmash	rs.b	1				; Wall smash sound
00000000 =00000096                  sRumble		rs.b	1				; Rumble sound
00000000 =00000097                  sWarp		rs.b	1				; Warp sound
00000000 =00000098                  sBossHit	rs.b	1				; Boss hit sound
00000000 =00000099                  sBomb		rs.b	1				; Bomb sound
00000000 =0000009A                  sBreakItem	rs.b	1				; Break item sound
00000000 =0000009B                  sFloorBounce	rs.b	1				; Floor bounce sound
00000000 =0000009C                  sCharge		rs.b	1				; Charge sound
00000000 =0000009D                  sChargeStop	rs.b	1				; Charge stop sound
00000000 =0000009E                  sChargeRelease	rs.b	1				; Charge release sound
00000000 =0000009F                  sDiamBreak	rs.b	1				; Diamond break sound
00000000 =000000A0                  sEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Object SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  _objPrevDPLC	rs.b	0				; Previous DPLC ID (only used by a few objects)
00000000 =00000000                  _objAddress	rs.l	1				; Pointer to object code
00000000 =00000004                  _objNext	rs.w	1				; Pointer to next object in the linked list
00000000 =00000006                  _objPrev	rs.w	1				; Pointer to previous object in the linked list
00000000 =00000008                  _objDrawNext	rs.w	1				; Pointer to next object to display
00000000 =0000000A                  _objDrawPrev	rs.w	1				; Pointer to previous object to display
00000000                            
00000000 =0000000C                  _objFlags	rs.b	1				; Object flags
00000000 =0000000D                  _objRender	rs.b	1				; Render flags
00000000 =0000000E                  _objVRAM	rs.w	1				; Sprite tile properties
00000000 =00000010                  _objFrame	rs.b	0				; Mapping frame ID (top byte of the following long)
00000000 =00000010                  _objMapping	rs.l	1				; Sprite mappings
00000000                            
00000000 =00000014                  _objXPos	rs.l	1				; X position
00000000 =00000017                  _objDrawW	equ	__rs-1				; Sprite width
00000000 =00000018                  _objYPos	rs.l	1				; Y position
00000000 =0000001B                  _objDrawH	equ	__rs-1				; Sprite height
00000000 =0000001C                  _objXVel	rs.w	1				; X velocity
00000000 =0000001E                  _objYVel	rs.w	1				; Y velocity
00000000                            
00000000 =00000020                  _objAnim	rs.b	1				; Animation ID
00000000 =00000021                  _objPrevAnim	rs.b	1				; Saved animation ID
00000000 =00000022                  _objAnimFrame	rs.b	1				; Animation script frame ID
00000000 =00000023                  _objAnimTimer	rs.b	1				; Animation timer
00000000                            
00000000 =00000024                  _objSubtype	rs.b	1				; Subtype ID (top byte of the following long)
00000000 =00000025                  _objRoutine	rs.b	1				; Routine ID
00000000 =00000026                  _objRespawn	rs.w	1				; Respawn table entry pointer
00000000 =00000028                  _objStatus	rs.b	1				; Status flags
00000000 =00000029                  _objShield	rs.b	1				; Shield flags
00000000                            
00000000 =0000002A                  _objDynSSTs	rs.b	$60-__rs			; Dynamic SSTs
00000000 =00000060                  _objSize	rs.b	0				; Size of the SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Dynamic SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	_objDynSSTs
00000000 =0000002A                  _objColType	rs.b	1				; Collision type
00000000 =0000002B                  _objColStat	rs.b	1				; Collision status
00000000 =0000002B                  _objHitCnt	equ	_objColStat			; Boss hit count
00000000 =0000002C                  _objColW	rs.b	1				; Collision width
00000000 =0000002D                  _objColH	rs.b	1				; Collision height
00000000 =0000002E                  _objNextTilt	rs.b	1				; Next tilt value
00000000 =0000002F                  _objTilt	rs.b	1				; Tilt value
00000000 =00000030                  _objLvlSSTs	rs.b	0				; Beginning of dynamic level SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sub sprite SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	_objNextTilt			; Allow some reserved SSTs
00000000 =0000002E                  _objSubSSTs	rs.b	0				; Start of sub sprite SSTs
00000000 =0000002E                  _objSubCnt	rs.w	1				; Main sprite sub sprite count
00000000 =00000030                  _objSubStart	rs.b	0				; Actual sub sprite SSTs start
00000000 =00000000                  ct		=	0
00000000                            
00000000                            	rept	8					; Allow 8 sub sprites per object
00000000                            _objSub\$ct\XPos	rs.w	1			; Sub sprite X position
00000000                            _objSub\$ct\YPos	rs.w	1			; Sub sprite Y position
00000000                            _objSub\$ct\Free	rs.b	1			; Sub sprite free byte
00000000                            _objSub\$ct\Frame	rs.b	1			; Sub sprite mapping frame
00000000                            ct		=	ct+1
00000000                            	endr
00000000 =00000030                M _objsub0xpos	rs.w	1
00000000 =00000032                M _objsub0ypos	rs.w	1
00000000 =00000034                M _objsub0free	rs.b	1
00000000 =00000035                M _objsub0frame	rs.b	1
00000000 =00000001                M ct	=	ct+1
00000000 =00000036                M _objsub1xpos	rs.w	1
00000000 =00000038                M _objsub1ypos	rs.w	1
00000000 =0000003A                M _objsub1free	rs.b	1
00000000 =0000003B                M _objsub1frame	rs.b	1
00000000 =00000002                M ct	=	ct+1
00000000 =0000003C                M _objsub2xpos	rs.w	1
00000000 =0000003E                M _objsub2ypos	rs.w	1
00000000 =00000040                M _objsub2free	rs.b	1
00000000 =00000041                M _objsub2frame	rs.b	1
00000000 =00000003                M ct	=	ct+1
00000000 =00000042                M _objsub3xpos	rs.w	1
00000000 =00000044                M _objsub3ypos	rs.w	1
00000000 =00000046                M _objsub3free	rs.b	1
00000000 =00000047                M _objsub3frame	rs.b	1
00000000 =00000004                M ct	=	ct+1
00000000 =00000048                M _objsub4xpos	rs.w	1
00000000 =0000004A                M _objsub4ypos	rs.w	1
00000000 =0000004C                M _objsub4free	rs.b	1
00000000 =0000004D                M _objsub4frame	rs.b	1
00000000 =00000005                M ct	=	ct+1
00000000 =0000004E                M _objsub5xpos	rs.w	1
00000000 =00000050                M _objsub5ypos	rs.w	1
00000000 =00000052                M _objsub5free	rs.b	1
00000000 =00000053                M _objsub5frame	rs.b	1
00000000 =00000006                M ct	=	ct+1
00000000 =00000054                M _objsub6xpos	rs.w	1
00000000 =00000056                M _objsub6ypos	rs.w	1
00000000 =00000058                M _objsub6free	rs.b	1
00000000 =00000059                M _objsub6frame	rs.b	1
00000000 =00000007                M ct	=	ct+1
00000000 =0000005A                M _objsub7xpos	rs.w	1
00000000 =0000005C                M _objsub7ypos	rs.w	1
00000000 =0000005E                M _objsub7free	rs.b	1
00000000 =0000005F                M _objsub7frame	rs.b	1
00000000 =00000008                M ct	=	ct+1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sprite drawing input list definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset _objDrawPrev-6			; this awkward thing will make dPrev == _objDrawPrev
00000000 =00000004                  dNext		rs.w 1					; pointer to first display object in linked list
00000000 =00000006                  dN2		rs.w 1					; must be 0
00000000 =00000008                  dN1		rs.w 1					; must be 0
00000000 =0000000A                  dPrev		rs.w 1					; pointer to last display object in linked list
00000000 =00000008                  dSize =		__rs-dNext				; size of display layer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Solid object collision bits
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000003                  cStandBit	equ	3
00000000 =00000008                  cStand		equ	1<<cStandBit
00000000                            
00000000 =00000002                  cPushDelta	equ	2
00000000                            
00000000 =00000005                  cPushBit	equ	cStandBit+cPushDelta
00000000 =00000020                  cPush		equ	1<<cPushBit
00000000                            
00000000 =00000000                  cTouchSideBit	equ	0
00000000 =00000001                  cTouchSide	equ	1<<cTouchSideBit
00000000                            
00000000 =00000002                  cTouchBtmBit	equ	cTouchSideBit+cPushDelta
00000000 =00000004                  cTouchBtm	equ	1<<cTouchBtmBit
00000000                            
00000000 =00000004                  cTouchTopBit	equ	cTouchBtmBit+cPushDelta
00000000 =00000010                  cTouchTop	equ	1<<cTouchTopBit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Macro to calculate the RAM space used by objects without going over the given max size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	size	- Max size for this object SST space
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  curobj		=	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            maxObjRAM	macro	size
00000000                            curobj_size	=	0
00000000                            		while curobj_size<(\size)
00000000                            rObj_\$curobj		rs.b	_objSize
00000000                            curobj_size		=	curobj_size+_objSize
00000000                            curobj			=	curobj+1
00000000                            		endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level drawing variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  cXPos		rs.l	1				; Plane X position
00000000 =00000004                  cXPrev		rs.w	1				; Plane previous X position
00000000 =00000006                  cXPrevR		rs.w	1				; Plane previous X position (rounded)
00000000 =00000008                  cYPos		rs.l	1				; Plane Y position
00000000 =0000000C                  cYPrev		rs.w	1				; Plane previous Y position
00000000 =0000000E                  cYPrevR		rs.w	1				; Plane previous Y position (rounded)
00000000 =00000010                  cRBlks		rs.b	1				; Number of blocks in the first set of tiles in a row
00000000 =00000011                  cCBlks		rs.b	1				; Number of blocks in the first set of tiles in a column
00000000 =00000012                  cVDP		rs.l	1				; VDP command
00000000 =00000016                  cLayout		rs.w	1				; Layout offset
00000000 =00000018                  cUpdate		rs.l	1				; Update routine
00000000 =0000001C                  cRedraw		rs.w	1				; Redraw flag
00000000 =0000001E                  cSize2		rs.b	0				; Variable list size
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Variables.asm"		; Variables
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Standard variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	RAM_START
00000000                            
00000000                            		; --- BUFFERS ---
00000000                            
00000000 =00FF0000                  miscBuff	rs.b	0				; General buffer
00000000 =00FF0000                  chunkData	rs.b	$8000				; Chunk table (uses same space as general buffer)
00000000 =00FF8000                  miscBuff_End	rs.b	0
00000000                            
00000000                            		rsset	RAM_WORD_START
00000000                            
00000000 =FFFF8000                  kosMBuff	rs.b	$1000				; Kosinski decompression buffer
00000000                            
00000000 =FFFF9000                  dmaQueue	rs.b	$FC				; DMA queue buffer
00000000 =FFFF90FC                  dmaSlot		rs.w	1				; DMA queue buffer slot
00000000                            
00000000 =FFFF90FE                  hScrollBuff	rs.b	$380				; HScroll table
00000000 =FFFF947E                  hScrollBuff_End	rs.b	0				; ''
00000000                            
00000000 =FFFF947E                  vScrollBuff	rs.b	$50				; VScroll table
00000000 =FFFF94CE                  vScrollBuff_End	rs.b	0				; ''
00000000 =FFFF947E                  vScrollBuffFG	EQU	vScrollBuff			; VScroll foreground value
00000000 =FFFF9480                  vScrollBuffBG	EQU	vScrollBuff+2			; VScroll background value
00000000                            
00000000 =FFFF94CE                  spriteBuff	rs.b	$280				; Sprite table
00000000 =FFFF974E                  spriteBuff_End	rs.b	0				; ''
00000000                            
00000000                            ; NTP: we won't be able to save ram like this until we switch to SWAP mappings (and we'll need per-piece limit checks on lest we overwrite the water palette)
00000000                            ;palFadeBuffAlt	equ	spriteBuff_End-$100		; Target water palette buffer
00000000                            ;palFadeBuff	equ	spriteBuff_End-$80		; Target palette buffer
00000000                            
00000000 =FFFF974E                  palFadeBuffAlt	rs.b	$80				; Target water palette buffer
00000000 =FFFF97CE                  palFadeBuff	rs.b	$80				; Target palette buffer
00000000 =FFFF984E                  paletteBuffAlt	rs.b	$80				; Water palette buffer
00000000 =FFFF98CE                  paletteBuff	rs.b	$80				; Palette buffer
00000000                            
00000000 =FFFF994E                  kosVars		rs.b	0				; Kosinski decompression queue variables
00000000 =FFFF994E                  kosCount	rs.w	1				; Kosinski decompression queue count
00000000 =FFFF9950                  kosRegisters	rs.b	$1A				; Kosinski decompression stored registers
00000000 =FFFF996A                  kosStatusReg	rs.w	1				; Kosinski decompression stored SR
00000000 =FFFF996C                  kosBookmark	rs.l	1				; Kosinski decompression bookmark
00000000 =FFFF9970                  kosList		rs.b	$20				; Kosinski decompression queue
00000000 =FFFF9970                  kosSource	equ	kosList				; ''
00000000 =FFFF9974                  kosDestination	equ	kosList+4			; ''
00000000 =FFFF9990                  kosList_End	rs.b	0				; ''
00000000 =FFFF9990                  kosMModules	rs.w	1				; Kosinski moduled decompression modules left
00000000 =FFFF9992                  kosMLastSize	rs.w	1				; Kosinski moduled decompression last module size
00000000 =FFFF9994                  kosMList	rs.b	$20*6				; Kosinski moduled decompression queue
00000000 =FFFF9994                  kosMSource	equ	kosMList			; ''
00000000 =FFFF9998                  kosMDestination	equ	kosMList+4			; ''
00000000 =FFFF9A54                  kosMList_End	rs.b	0				; ''
00000000 =FFFF9A54                  kosVars_End	rs.b	0				; End of Kosinski decompression queue variables
00000000                            
00000000 =FFFF9A54                  objRespawn	rs.b	$300				; Object respawn table
00000000 =FFFF9D54                  objRespawn_End	rs.b	0				; ''
00000000                            
00000000 =FFFF9D54                  objMemory	rs.b	0				; Object SSTs
00000000                            		maxObjRAM $2400				; ''
00000000 =00000000                M curobj_size	=	0
00000000                          M 	while	curobj_size<($2400)
00000000 =FFFF9D54                M robj_0	rs.b	_objsize
00000000 =00000060                M curobj_size	=	curobj_size+_objsize
00000000 =00000001                M curobj	=	curobj+1
00000000 =FFFF9DB4                M robj_1	rs.b	_objsize
00000000 =000000C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000002                M curobj	=	curobj+1
00000000 =FFFF9E14                M robj_2	rs.b	_objsize
00000000 =00000120                M curobj_size	=	curobj_size+_objsize
00000000 =00000003                M curobj	=	curobj+1
00000000 =FFFF9E74                M robj_3	rs.b	_objsize
00000000 =00000180                M curobj_size	=	curobj_size+_objsize
00000000 =00000004                M curobj	=	curobj+1
00000000 =FFFF9ED4                M robj_4	rs.b	_objsize
00000000 =000001E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000005                M curobj	=	curobj+1
00000000 =FFFF9F34                M robj_5	rs.b	_objsize
00000000 =00000240                M curobj_size	=	curobj_size+_objsize
00000000 =00000006                M curobj	=	curobj+1
00000000 =FFFF9F94                M robj_6	rs.b	_objsize
00000000 =000002A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000007                M curobj	=	curobj+1
00000000 =FFFF9FF4                M robj_7	rs.b	_objsize
00000000 =00000300                M curobj_size	=	curobj_size+_objsize
00000000 =00000008                M curobj	=	curobj+1
00000000 =FFFFA054                M robj_8	rs.b	_objsize
00000000 =00000360                M curobj_size	=	curobj_size+_objsize
00000000 =00000009                M curobj	=	curobj+1
00000000 =FFFFA0B4                M robj_9	rs.b	_objsize
00000000 =000003C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000A                M curobj	=	curobj+1
00000000 =FFFFA114                M robj_a	rs.b	_objsize
00000000 =00000420                M curobj_size	=	curobj_size+_objsize
00000000 =0000000B                M curobj	=	curobj+1
00000000 =FFFFA174                M robj_b	rs.b	_objsize
00000000 =00000480                M curobj_size	=	curobj_size+_objsize
00000000 =0000000C                M curobj	=	curobj+1
00000000 =FFFFA1D4                M robj_c	rs.b	_objsize
00000000 =000004E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000D                M curobj	=	curobj+1
00000000 =FFFFA234                M robj_d	rs.b	_objsize
00000000 =00000540                M curobj_size	=	curobj_size+_objsize
00000000 =0000000E                M curobj	=	curobj+1
00000000 =FFFFA294                M robj_e	rs.b	_objsize
00000000 =000005A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000F                M curobj	=	curobj+1
00000000 =FFFFA2F4                M robj_f	rs.b	_objsize
00000000 =00000600                M curobj_size	=	curobj_size+_objsize
00000000 =00000010                M curobj	=	curobj+1
00000000 =FFFFA354                M robj_10	rs.b	_objsize
00000000 =00000660                M curobj_size	=	curobj_size+_objsize
00000000 =00000011                M curobj	=	curobj+1
00000000 =FFFFA3B4                M robj_11	rs.b	_objsize
00000000 =000006C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000012                M curobj	=	curobj+1
00000000 =FFFFA414                M robj_12	rs.b	_objsize
00000000 =00000720                M curobj_size	=	curobj_size+_objsize
00000000 =00000013                M curobj	=	curobj+1
00000000 =FFFFA474                M robj_13	rs.b	_objsize
00000000 =00000780                M curobj_size	=	curobj_size+_objsize
00000000 =00000014                M curobj	=	curobj+1
00000000 =FFFFA4D4                M robj_14	rs.b	_objsize
00000000 =000007E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000015                M curobj	=	curobj+1
00000000 =FFFFA534                M robj_15	rs.b	_objsize
00000000 =00000840                M curobj_size	=	curobj_size+_objsize
00000000 =00000016                M curobj	=	curobj+1
00000000 =FFFFA594                M robj_16	rs.b	_objsize
00000000 =000008A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000017                M curobj	=	curobj+1
00000000 =FFFFA5F4                M robj_17	rs.b	_objsize
00000000 =00000900                M curobj_size	=	curobj_size+_objsize
00000000 =00000018                M curobj	=	curobj+1
00000000 =FFFFA654                M robj_18	rs.b	_objsize
00000000 =00000960                M curobj_size	=	curobj_size+_objsize
00000000 =00000019                M curobj	=	curobj+1
00000000 =FFFFA6B4                M robj_19	rs.b	_objsize
00000000 =000009C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001A                M curobj	=	curobj+1
00000000 =FFFFA714                M robj_1a	rs.b	_objsize
00000000 =00000A20                M curobj_size	=	curobj_size+_objsize
00000000 =0000001B                M curobj	=	curobj+1
00000000 =FFFFA774                M robj_1b	rs.b	_objsize
00000000 =00000A80                M curobj_size	=	curobj_size+_objsize
00000000 =0000001C                M curobj	=	curobj+1
00000000 =FFFFA7D4                M robj_1c	rs.b	_objsize
00000000 =00000AE0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001D                M curobj	=	curobj+1
00000000 =FFFFA834                M robj_1d	rs.b	_objsize
00000000 =00000B40                M curobj_size	=	curobj_size+_objsize
00000000 =0000001E                M curobj	=	curobj+1
00000000 =FFFFA894                M robj_1e	rs.b	_objsize
00000000 =00000BA0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001F                M curobj	=	curobj+1
00000000 =FFFFA8F4                M robj_1f	rs.b	_objsize
00000000 =00000C00                M curobj_size	=	curobj_size+_objsize
00000000 =00000020                M curobj	=	curobj+1
00000000 =FFFFA954                M robj_20	rs.b	_objsize
00000000 =00000C60                M curobj_size	=	curobj_size+_objsize
00000000 =00000021                M curobj	=	curobj+1
00000000 =FFFFA9B4                M robj_21	rs.b	_objsize
00000000 =00000CC0                M curobj_size	=	curobj_size+_objsize
00000000 =00000022                M curobj	=	curobj+1
00000000 =FFFFAA14                M robj_22	rs.b	_objsize
00000000 =00000D20                M curobj_size	=	curobj_size+_objsize
00000000 =00000023                M curobj	=	curobj+1
00000000 =FFFFAA74                M robj_23	rs.b	_objsize
00000000 =00000D80                M curobj_size	=	curobj_size+_objsize
00000000 =00000024                M curobj	=	curobj+1
00000000 =FFFFAAD4                M robj_24	rs.b	_objsize
00000000 =00000DE0                M curobj_size	=	curobj_size+_objsize
00000000 =00000025                M curobj	=	curobj+1
00000000 =FFFFAB34                M robj_25	rs.b	_objsize
00000000 =00000E40                M curobj_size	=	curobj_size+_objsize
00000000 =00000026                M curobj	=	curobj+1
00000000 =FFFFAB94                M robj_26	rs.b	_objsize
00000000 =00000EA0                M curobj_size	=	curobj_size+_objsize
00000000 =00000027                M curobj	=	curobj+1
00000000 =FFFFABF4                M robj_27	rs.b	_objsize
00000000 =00000F00                M curobj_size	=	curobj_size+_objsize
00000000 =00000028                M curobj	=	curobj+1
00000000 =FFFFAC54                M robj_28	rs.b	_objsize
00000000 =00000F60                M curobj_size	=	curobj_size+_objsize
00000000 =00000029                M curobj	=	curobj+1
00000000 =FFFFACB4                M robj_29	rs.b	_objsize
00000000 =00000FC0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002A                M curobj	=	curobj+1
00000000 =FFFFAD14                M robj_2a	rs.b	_objsize
00000000 =00001020                M curobj_size	=	curobj_size+_objsize
00000000 =0000002B                M curobj	=	curobj+1
00000000 =FFFFAD74                M robj_2b	rs.b	_objsize
00000000 =00001080                M curobj_size	=	curobj_size+_objsize
00000000 =0000002C                M curobj	=	curobj+1
00000000 =FFFFADD4                M robj_2c	rs.b	_objsize
00000000 =000010E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002D                M curobj	=	curobj+1
00000000 =FFFFAE34                M robj_2d	rs.b	_objsize
00000000 =00001140                M curobj_size	=	curobj_size+_objsize
00000000 =0000002E                M curobj	=	curobj+1
00000000 =FFFFAE94                M robj_2e	rs.b	_objsize
00000000 =000011A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002F                M curobj	=	curobj+1
00000000 =FFFFAEF4                M robj_2f	rs.b	_objsize
00000000 =00001200                M curobj_size	=	curobj_size+_objsize
00000000 =00000030                M curobj	=	curobj+1
00000000 =FFFFAF54                M robj_30	rs.b	_objsize
00000000 =00001260                M curobj_size	=	curobj_size+_objsize
00000000 =00000031                M curobj	=	curobj+1
00000000 =FFFFAFB4                M robj_31	rs.b	_objsize
00000000 =000012C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000032                M curobj	=	curobj+1
00000000 =FFFFB014                M robj_32	rs.b	_objsize
00000000 =00001320                M curobj_size	=	curobj_size+_objsize
00000000 =00000033                M curobj	=	curobj+1
00000000 =FFFFB074                M robj_33	rs.b	_objsize
00000000 =00001380                M curobj_size	=	curobj_size+_objsize
00000000 =00000034                M curobj	=	curobj+1
00000000 =FFFFB0D4                M robj_34	rs.b	_objsize
00000000 =000013E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000035                M curobj	=	curobj+1
00000000 =FFFFB134                M robj_35	rs.b	_objsize
00000000 =00001440                M curobj_size	=	curobj_size+_objsize
00000000 =00000036                M curobj	=	curobj+1
00000000 =FFFFB194                M robj_36	rs.b	_objsize
00000000 =000014A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000037                M curobj	=	curobj+1
00000000 =FFFFB1F4                M robj_37	rs.b	_objsize
00000000 =00001500                M curobj_size	=	curobj_size+_objsize
00000000 =00000038                M curobj	=	curobj+1
00000000 =FFFFB254                M robj_38	rs.b	_objsize
00000000 =00001560                M curobj_size	=	curobj_size+_objsize
00000000 =00000039                M curobj	=	curobj+1
00000000 =FFFFB2B4                M robj_39	rs.b	_objsize
00000000 =000015C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003A                M curobj	=	curobj+1
00000000 =FFFFB314                M robj_3a	rs.b	_objsize
00000000 =00001620                M curobj_size	=	curobj_size+_objsize
00000000 =0000003B                M curobj	=	curobj+1
00000000 =FFFFB374                M robj_3b	rs.b	_objsize
00000000 =00001680                M curobj_size	=	curobj_size+_objsize
00000000 =0000003C                M curobj	=	curobj+1
00000000 =FFFFB3D4                M robj_3c	rs.b	_objsize
00000000 =000016E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003D                M curobj	=	curobj+1
00000000 =FFFFB434                M robj_3d	rs.b	_objsize
00000000 =00001740                M curobj_size	=	curobj_size+_objsize
00000000 =0000003E                M curobj	=	curobj+1
00000000 =FFFFB494                M robj_3e	rs.b	_objsize
00000000 =000017A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003F                M curobj	=	curobj+1
00000000 =FFFFB4F4                M robj_3f	rs.b	_objsize
00000000 =00001800                M curobj_size	=	curobj_size+_objsize
00000000 =00000040                M curobj	=	curobj+1
00000000 =FFFFB554                M robj_40	rs.b	_objsize
00000000 =00001860                M curobj_size	=	curobj_size+_objsize
00000000 =00000041                M curobj	=	curobj+1
00000000 =FFFFB5B4                M robj_41	rs.b	_objsize
00000000 =000018C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000042                M curobj	=	curobj+1
00000000 =FFFFB614                M robj_42	rs.b	_objsize
00000000 =00001920                M curobj_size	=	curobj_size+_objsize
00000000 =00000043                M curobj	=	curobj+1
00000000 =FFFFB674                M robj_43	rs.b	_objsize
00000000 =00001980                M curobj_size	=	curobj_size+_objsize
00000000 =00000044                M curobj	=	curobj+1
00000000 =FFFFB6D4                M robj_44	rs.b	_objsize
00000000 =000019E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000045                M curobj	=	curobj+1
00000000 =FFFFB734                M robj_45	rs.b	_objsize
00000000 =00001A40                M curobj_size	=	curobj_size+_objsize
00000000 =00000046                M curobj	=	curobj+1
00000000 =FFFFB794                M robj_46	rs.b	_objsize
00000000 =00001AA0                M curobj_size	=	curobj_size+_objsize
00000000 =00000047                M curobj	=	curobj+1
00000000 =FFFFB7F4                M robj_47	rs.b	_objsize
00000000 =00001B00                M curobj_size	=	curobj_size+_objsize
00000000 =00000048                M curobj	=	curobj+1
00000000 =FFFFB854                M robj_48	rs.b	_objsize
00000000 =00001B60                M curobj_size	=	curobj_size+_objsize
00000000 =00000049                M curobj	=	curobj+1
00000000 =FFFFB8B4                M robj_49	rs.b	_objsize
00000000 =00001BC0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004A                M curobj	=	curobj+1
00000000 =FFFFB914                M robj_4a	rs.b	_objsize
00000000 =00001C20                M curobj_size	=	curobj_size+_objsize
00000000 =0000004B                M curobj	=	curobj+1
00000000 =FFFFB974                M robj_4b	rs.b	_objsize
00000000 =00001C80                M curobj_size	=	curobj_size+_objsize
00000000 =0000004C                M curobj	=	curobj+1
00000000 =FFFFB9D4                M robj_4c	rs.b	_objsize
00000000 =00001CE0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004D                M curobj	=	curobj+1
00000000 =FFFFBA34                M robj_4d	rs.b	_objsize
00000000 =00001D40                M curobj_size	=	curobj_size+_objsize
00000000 =0000004E                M curobj	=	curobj+1
00000000 =FFFFBA94                M robj_4e	rs.b	_objsize
00000000 =00001DA0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004F                M curobj	=	curobj+1
00000000 =FFFFBAF4                M robj_4f	rs.b	_objsize
00000000 =00001E00                M curobj_size	=	curobj_size+_objsize
00000000 =00000050                M curobj	=	curobj+1
00000000 =FFFFBB54                M robj_50	rs.b	_objsize
00000000 =00001E60                M curobj_size	=	curobj_size+_objsize
00000000 =00000051                M curobj	=	curobj+1
00000000 =FFFFBBB4                M robj_51	rs.b	_objsize
00000000 =00001EC0                M curobj_size	=	curobj_size+_objsize
00000000 =00000052                M curobj	=	curobj+1
00000000 =FFFFBC14                M robj_52	rs.b	_objsize
00000000 =00001F20                M curobj_size	=	curobj_size+_objsize
00000000 =00000053                M curobj	=	curobj+1
00000000 =FFFFBC74                M robj_53	rs.b	_objsize
00000000 =00001F80                M curobj_size	=	curobj_size+_objsize
00000000 =00000054                M curobj	=	curobj+1
00000000 =FFFFBCD4                M robj_54	rs.b	_objsize
00000000 =00001FE0                M curobj_size	=	curobj_size+_objsize
00000000 =00000055                M curobj	=	curobj+1
00000000 =FFFFBD34                M robj_55	rs.b	_objsize
00000000 =00002040                M curobj_size	=	curobj_size+_objsize
00000000 =00000056                M curobj	=	curobj+1
00000000 =FFFFBD94                M robj_56	rs.b	_objsize
00000000 =000020A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000057                M curobj	=	curobj+1
00000000 =FFFFBDF4                M robj_57	rs.b	_objsize
00000000 =00002100                M curobj_size	=	curobj_size+_objsize
00000000 =00000058                M curobj	=	curobj+1
00000000 =FFFFBE54                M robj_58	rs.b	_objsize
00000000 =00002160                M curobj_size	=	curobj_size+_objsize
00000000 =00000059                M curobj	=	curobj+1
00000000 =FFFFBEB4                M robj_59	rs.b	_objsize
00000000 =000021C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005A                M curobj	=	curobj+1
00000000 =FFFFBF14                M robj_5a	rs.b	_objsize
00000000 =00002220                M curobj_size	=	curobj_size+_objsize
00000000 =0000005B                M curobj	=	curobj+1
00000000 =FFFFBF74                M robj_5b	rs.b	_objsize
00000000 =00002280                M curobj_size	=	curobj_size+_objsize
00000000 =0000005C                M curobj	=	curobj+1
00000000 =FFFFBFD4                M robj_5c	rs.b	_objsize
00000000 =000022E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005D                M curobj	=	curobj+1
00000000 =FFFFC034                M robj_5d	rs.b	_objsize
00000000 =00002340                M curobj_size	=	curobj_size+_objsize
00000000 =0000005E                M curobj	=	curobj+1
00000000 =FFFFC094                M robj_5e	rs.b	_objsize
00000000 =000023A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005F                M curobj	=	curobj+1
00000000 =FFFFC0F4                M robj_5f	rs.b	_objsize
00000000 =00002400                M curobj_size	=	curobj_size+_objsize
00000000 =00000060                M curobj	=	curobj+1
00000000 =FFFFC154                  objMemory_End	rs.b	0
00000000                            
00000000 =00000060                  OBJECT_COUNT	equ	(objMemory_End-objMemory)/_objSize
00000000                            
00000000 =FFFFC154                  objExecute	rs.b	0				; Object execution list variables (DO NOT REARRANGE THE ORDER OF THESE!)
00000000 =FFFFC154                  objExecExit	rs.l	1				; Pointer to a return intstruction that will exit object execution
00000000 =FFFFC158                  objExecFirst	rs.w	1				; Pointer to the first object to be executed in the list
00000000 =FFFFC15A                  objExecLast	rs.w	1				; Pointer to the last object to be executed in the list
00000000 =FFFFC15C                  objExecFree	rs.w	1				; Pointer to the next free slot in object memory
00000000 =FFFFC15E                  objExecute_End	rs.b	0
00000000                            
00000000 =FFFFC15A                  objDisplay	equ __rs-dnext
00000000                            		rs.b	dSize*8				; Sprite display input list (8 priority levels)
00000000 =FFFFC19E                  objDisplay_End	rs.b	0				; 
00000000                            
00000000 =FFFFC19E                  fgRowBuff	rs.b	$102				; Foreground horizontal plane buffer
00000000 =FFFFC2A0                  fgColBuff	rs.b	$82				; Foreground vertical plane buffer
00000000 =FFFFC322                  bgRowBuff	rs.b	$102				; Background horizontal plane buffer
00000000 =FFFFC424                  bgColBuff	rs.b	$82				; Background vertical plane buffer
00000000                            
00000000 =FFFFC4A6                  ampsVars		rs.b	0			; AMPS variables
00000000                            		include	"Sound/amps/code/ram.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =FFFFC4A6                  mFlags		rs.b 1		; various driver flags, see below
00000000 =FFFFC4A7                  mCtrPal		rs.b 1		; frame counter fo 50hz fix
00000000 =FFFFC4A8                  mVctSFX		rs.l 1		; address of voice table for sfx
00000000 =FFFFC4AC                  mComm		rs.b 8		; communications bytes
00000000 =FFFFC4B4                  mMasterVolFM	rs.b 0		; master volume for FM channels
00000000 =FFFFC4B4                  mFadeAddr	rs.l 1		; fading program address
00000000 =FFFFC4B8                  mTempoMain	rs.b 1		; music normal tempo
00000000 =FFFFC4B9                  mTempoSpeed	rs.b 1		; music speed shoes tempo
00000000 =FFFFC4BA                  mTempo		rs.b 1		; current tempo we are using right now
00000000 =FFFFC4BB                  mTempoCur	rs.b 1		; tempo counter/accumulator
00000000 =FFFFC4BC                  mQueue		rs.b 3		; sound queue
00000000 =FFFFC4BF                  mMasterVolPSG	rs.b 1		; master volume for PSG channels
00000000 =FFFFC4C0                  mMasterVolDAC	rs.b 1		; master volume for DAC channels
00000000 =FFFFC4C1                  mSpindash	rs.b 1		; spindash rev counter
00000000 =FFFFC4C2                  mContCtr	rs.b 1		; continous sfx loop counter
00000000 =FFFFC4C3                  mContLast	rs.b 1		; last continous sfx played
00000000                            		rs.w 0		; align channel data
00000000                            
00000000 =FFFFC4C4                  mDAC1		rs.b cSize	; DAC 1 data
00000000 =FFFFC4F0                  mDAC2		rs.b cSize	; DAC 2 data
00000000 =FFFFC51C                  mFM1		rs.b cSize	; FM 1 data
00000000 =FFFFC548                  mFM2		rs.b cSize	; FM 2 data
00000000 =FFFFC574                  mFM3		rs.b cSize	; FM 3 data
00000000 =FFFFC5A0                  mFM4		rs.b cSize	; FM 4 data
00000000 =FFFFC5CC                  mFM5		rs.b cSize	; FM 5 data
00000000 =FFFFC5F8                  mPSG1		rs.b cSize	; PSG 1 data
00000000 =FFFFC624                  mPSG2		rs.b cSize	; PSG 2 data
00000000 =FFFFC650                  mPSG3		rs.b cSize	; PSG 3 data
00000000 =FFFFC67C                  mSFXDAC1	rs.b cSizeSFX	; SFX DAC 1 data
00000000 =FFFFC698                  mSFXFM3		rs.b cSizeSFX	; SFX FM 3 data
00000000 =FFFFC6B4                  mSFXFM4		rs.b cSizeSFX	; SFX FM 4 data
00000000 =FFFFC6D0                  mSFXFM5		rs.b cSizeSFX	; SFX FM 5 data
00000000 =FFFFC6EC                  mSFXPSG1	rs.b cSizeSFX	; SFX PSG 1 data
00000000 =FFFFC708                  mSFXPSG2	rs.b cSizeSFX	; SFX PSG 2 data
00000000 =FFFFC724                  mSFXPSG3	rs.b cSizeSFX	; SFX PSG 3 data
00000000                            
00000000 =FFFFC740                  msChktracker	rs.b 1		; safe mode only: If set, bring up debugger
00000000                            		rsEven
00000000                          M 	rs.b	__rs&1
00000000 =FFFFC742                  mSize		rs.w 0		; end of the driver RAM
00000000                            ; ===========================================================================
00000000                            
00000000                            		; --- ENGINE VARIABLES ---
00000000                            
00000000 =FFFFC742                  ctrlDataP1	rs.b	0				; Controller 1 data
00000000 =FFFFC742                  ctrlHoldP1	rs.b	1				; Controller 1 held button data
00000000 =FFFFC743                  ctrlPressP1	rs.b	1				; Controller 1 pressed button data
00000000                            
00000000 =FFFFC744                  ctrlDataP2	rs.b	0				; Controller 2 data
00000000 =FFFFC744                  ctrlHoldP2	rs.b	1				; Controller 2 held button data
00000000 =FFFFC745                  ctrlPressP2	rs.b	1				; Controller 2 pressed button data
00000000                            
00000000 =FFFFC746                  hwVersion	rs.b	1				; Hardware version
00000000 =FFFFC747                  vIntFlag	rs.b	0				; V-INT flag
00000000 =FFFFC747                  vIntRoutine	rs.b	1				; V-INT routine
00000000                            
00000000 =FFFFC748                  palFadeVars	rs.b	0				; Palette fade properties
00000000 =FFFFC748                  palFadeStart	rs.b	1				; Palette fade start index
00000000 =FFFFC749                  palFadeLength	rs.b	1				; Palette fade size
00000000 =FFFFC74A                  palFadeVars_End	rs.b	0
00000000                            
00000000 =FFFFC74A                  lagCounter	rs.b	1				; Lag frame counter
00000000 =FFFFC74B                  hIntFlag	rs.b	1				; H-INT run flag
00000000                            
00000000 =FFFFC74C                  vIntJump	rs.w	1				; Header will point here for V-INT
00000000 =FFFFC74E                  vIntAddress	rs.l	1				; V-INT address
00000000                            
00000000 =FFFFC752                  hIntJump	rs.w	1				; Header will point here for H-INT
00000000 =FFFFC754                  hIntAddress	rs.l	1				; H-INT address
00000000                            
00000000 =FFFFC758                  frameCounter	rs.l	1				; Frame counter
00000000                            
00000000 =FFFFC75C                  opmode		rs.b	1				; Game opmode ID
00000000 =FFFFC75D                  spriteCount	rs.b	1				; Sprite count
00000000 =FFFFC75E                  pauseFlag	rs.b	1				; Pause flag
00000000 =FFFFC75F                  hIntUpdates	rs.b	1				; Level updates in H-INT flag
00000000                            
00000000 =FFFFC760                  hIntCounter	rs.b	0
00000000 =FFFFC760                  hIntCntReg	rs.b	1				; H-INT counter register
00000000 =FFFFC761                  hIntCntValue	rs.b	1				; H-INT counter value
00000000                            
00000000 =FFFFC762                  randomSeed	rs.l	1				; RNG seed
00000000                            
00000000 =FFFFC766                  vdpReg1		rs.w	1				; VDP register 1 register ID and value
00000000 =FFFFC768                  vdpWindowY	rs.w	1				; Window Y position (VDP register)
00000000                            
00000000 =FFFFC76A                  moveCheat	rs.b	1
00000000 =FFFFC76B                  artCheat	rs.b	1
00000000                            
00000000 =FFFFC76C                  oscillators	rs.b	0				; Oscillation numbers
00000000 =FFFFC76C                  oscControl	rs.w	1				; Oscillation control
00000000 =FFFFC76E                  oscValues	rs.w	$20				; Oscialltion data
00000000 =FFFFC7AE                  oscillators_End	rs.b	0				; ''
00000000                            
00000000                            		; --- GLOBAL VARIABLES ---
00000000                            
00000000 =FFFFC7AE                  levelID		rs.b	0				; Level ID
00000000 =FFFFC7AE                  zoneID		rs.b	1				; Zone ID
00000000 =FFFFC7AF                  actID		rs.b	1				; Act ID
00000000                            
00000000 =FFFFC7B0                  checkpoint	rs.b	0				; Checkpoint RAM
00000000 =FFFFC7B0                  chkIDLast	rs.b	1				; Last checkpoint hit
00000000                            		rs.b	1
00000000 =FFFFC7B2                  chkSavedXPos	rs.w	1				; Saved player X position
00000000 =FFFFC7B4                  chkSavedYPos	rs.w	1				; Saved player Y position
00000000 =FFFFC7B6                  checkpoint_End	rs.b	0				; End of checkpoint RAM
00000000                            
00000000 =FFFFC7B6                  objManager	rs.b	0
00000000 =FFFFC7B6                  objMgrInit	rs.b	1				; Object manager initialized flag
00000000                            
00000000 =FFFFC7B7                  rStartFall	rs.b	1				; Start level by falling flag
00000000                            
00000000 =FFFFC7B8                  objMgrLayout	rs.l	1				; Object position data pointer
00000000 =FFFFC7BC                  objMgrLoadR	rs.l	1				; Object data address (for going right)
00000000 =FFFFC7C0                  objMgrLoadL	rs.l	1				; Object data address (for going left)
00000000 =FFFFC7C4                  objMgrRespR	rs.w	1				; Object respawn address (for going right)
00000000 =FFFFC7C6                  objMgrRespL	rs.w	1				; Object respawn address (for going left)
00000000 =FFFFC7C8                  objMgrCoarseX	rs.w	1				; Object manager's coarse X position
00000000 =FFFFC7CA                  objMgrCoarseY	rs.w	1				; Object manager's coarse Y position
00000000 =FFFFC7CC                  objMgrCameraX	rs.w	1				; Object manager's camera X position
00000000 =FFFFC7CE                  objMgrCameraY	rs.w	1				; Object manager's camera Y position
00000000 =FFFFC7D0                  objManager_End	rs.b	0
00000000                            
00000000 =FFFFC7D0                  palCycTimer	rs.b	1				; Palette cycle timer
00000000 =FFFFC7D1                  palCycIndex	rs.b	1				; Palette cycle index
00000000                            
00000000                            		; --- LOCAL VARIABLES ---
00000000                            
00000000 =FFFFC7D2                  opmodeVars	rs.b	0				; Start of local game variables
00000000                            		rs.b	((-__rs)&$FFFF)-$100		; You have the rest of RAM here for local variables
00000000 =FFFFFF00                  opmodeVars_End	rs.b	0				; End of local game variables
00000000                            
00000000                            		; --- STACK SPACE ---
00000000                            
00000000 =FFFFFF00                  stackSpace	rs.b	$100				; Stack space
00000000 =00000000                  stack		rs.b	0				; ''
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Title screen variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	opmodeVars
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	opmodeVars
00000000 =FFFFC7D2                  blockData	rs.b	$1800				; Block table
00000000                            
00000000 =FFFFDFD2                  ringStatus	rs.b	$400				; Ring status table
00000000 =FFFFE3D2                  ringStatus_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE3D2                  ringCollect	rs.b	0				; Ring collection table
00000000 =FFFFE3D2                  ringColCount	rs.w	1				; Ring collection count
00000000 =FFFFE3D4                  ringColList	rs.b	$7E				; Ring collection list
00000000 =FFFFE452                  ringCollect_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE452                  scrollSects	rs.b	$384				; Scroll sections
00000000 =FFFFE7D6                  scrollSects_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE7D6                  collideList	rs.b	$80				; Collision response list
00000000 =FFFFE856                  collideList_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE856                  lvlLayout	rs.b	0				; Level layout ROM addresses
00000000 =FFFFE856                  lvlLayoutFG	rs.l	1				
00000000 =FFFFE85A                  lvlLayoutBG	rs.l	1				
00000000                            
00000000 =FFFFE85E                  ringCount	rs.w	1				; Ring count
00000000 =FFFFE860                  ringAnimFrame	rs.b	1				; Ring animation frame
00000000 =FFFFE861                  ringAnimTime	rs.b	1				; Ring animation timer
00000000                            
00000000 =FFFFE862                  ringLossAnimA	rs.w	1
00000000 =FFFFE864                  ringLossAnimT	rs.b	1
00000000 =FFFFE865                  ringLossAnimF	rs.b	1
00000000                            
00000000 =FFFFE866                  ringMgrRoutine	rs.b	1				; Ring manager routine
00000000 =FFFFE867                  hudUpdateRings	rs.b	1				; Update Ring counter in the HUD flag
00000000                            
00000000 =FFFFE868                  ringMgrLayout	rs.l	1				; Ring position data pointer
00000000 =FFFFE86C                  ringMgrLoadL	rs.l	1				; Ring data address for the left side of the screen
00000000 =FFFFE870                  ringMgrLoadR	rs.l	1				; Ring data address for the right side of the screen
00000000 =FFFFE874                  ringMgrStatPtr	rs.w	1				; Ring status address
00000000                            
00000000 =FFFFE876                  playerPtrP1	rs.w	1				; Player 1 object address
00000000 =FFFFE878                  shieldPtrP1	rs.w	1				; Player 1 shield address
00000000 =FFFFE87A                  invincPtrP1	rs.w	1				; Player 1 invincibility address
00000000 =FFFFE87C                  afterImgPtrP1	rs.w	1				; Player 1 after image address
00000000                            
00000000 =FFFFE87E                  playerPtrP2	rs.w	1				; Player 2 object address
00000000 =FFFFE880                  shieldPtrP2	rs.w	1				; Player 2 shield address
00000000 =FFFFE882                  invincPtrP2	rs.w	1				; Player 2 invincibility address
00000000 =FFFFE884                  afterImgPtrP2	rs.w	1				; Player 2 after image address
00000000                            
00000000 =FFFFE886                  waterObjPtr1	rs.w	1				; Water surface 1 address
00000000 =FFFFE888                  waterObjPtr2	rs.w	1				; Water surface 2 address
00000000                            
00000000 =FFFFE88A                  cameraVars	rs.b	0				; Camera RAM
00000000 =FFFFE88A                  fgCamVars	rs.b	cSize2				; Foreground variables
00000000 =FFFFE8A8                  bgCamVars	rs.b	cSize2				; Background variables
00000000                            
00000000 =FFFFE8C6                  targetMaxCamPos	rs.b	0				; Target maximum camera positions
00000000 =FFFFE8C6                  targetMaxCamX	rs.w	1				; Target maximum camera X position
00000000 =FFFFE8C8                  targetMaxCamY	rs.w	1				; Target maximum camera Y position
00000000                            
00000000 =FFFFE8CA                  maxCamPos	rs.b	0				; Maximum camera positions
00000000 =FFFFE8CA                  maxCamXPos	rs.w	1				; Maximum camera X position
00000000 =FFFFE8CC                  maxCamYPos	rs.w	1				; Maximum camera Y position
00000000                            
00000000 =FFFFE8CE                  targetMinCamPos	rs.b	0				; Target minimum camera positions
00000000 =FFFFE8CE                  targetMinCamX	rs.w	1				; Target minimum camera X position
00000000 =FFFFE8D0                  targetMinCamY	rs.w	1				; Target minimum camera Y position
00000000                            
00000000 =FFFFE8D2                  minCamPos	rs.b	0				; Minimum camera positions
00000000 =FFFFE8D2                  minCamXPos	rs.w	1				; Minimum camera X position
00000000 =FFFFE8D4                  minCamYPos	rs.w	1				; Minimum camera Y position
00000000                            
00000000 =FFFFE8D6                  panCamPos	rs.b	0
00000000 =FFFFE8D6                  panCamXPos	rs.w	1				; Camera X center
00000000 =FFFFE8D8                  panCamYPos	rs.w	1				; Distance from the player's Y position and the camera's
00000000                            
00000000 =FFFFE8DA                  camLocked	rs.b	0				; Camera locked flags
00000000 =FFFFE8DA                  camLockX	rs.b	1				; Camera locked horizontally flag
00000000 =FFFFE8DB                  camLockY	rs.b	1				; Camera locked vertically flag
00000000                            
00000000 =FFFFE8DC                  chgCamMaxY	rs.b	1				; Camera max Y position changing flag
00000000 =FFFFE8DD                  cameraVars_End	rs.b	0				; End of camera RAM
00000000                            
00000000 =FFFFE8DD                  debugMode	rs.b	1				; Debug placement mode
00000000                            
00000000 =FFFFE8DE                  plrCtrlData	rs.b	0				; Player control data
00000000 =FFFFE8DE                  plrCtrlHold	rs.b	1				; Player control held button data
00000000 =FFFFE8DF                  plrCtrlPress	rs.b	1				; Player control pressed button data
00000000                            
00000000 =FFFFE8E0                  lvlMusic	rs.b	1				; Level music ID
00000000 =FFFFE8E1                  bossMusic	rs.b	1				; Boss music ID
00000000                            
00000000 =FFFFE8E2                  primaryColPtr	rs.l	1				; Primary level collision data pointer
00000000 =FFFFE8E6                  secondaryColPtr	rs.l	1				; Secondary level collision data pointer
00000000                            
00000000 =FFFFE8EA                  currentColAddr	rs.l	1				; Current collsion address
00000000                            
00000000 =FFFFE8EE                  layerPosition	rs.w	1				; Fake layer position
00000000                            
00000000 =FFFFE8F0                  angleValPtr	rs.l	1				; Angle value array pointer
00000000 =FFFFE8F4                  normColArrayPtr	rs.l	1				; Normal height map array pointer
00000000 =FFFFE8F8                  rotColArrayPtr	rs.l	1				; Rotated height map array pointer
00000000                            
00000000 =FFFFE8FC                  got_objNextLvl	rs.b	1				; Flag to go to the next level
00000000 =FFFFE8FD                  bossDefeated	rs.b	1
00000000                            
00000000 =FFFFE8FE                  lvlHasWater	rs.b	1				; Water in level flag
00000000 =FFFFE8FF                  waterFullscr	rs.b	1				; Water fullscreen flag
00000000 =FFFFE900                  waterYPos	rs.w	1				; Water height
00000000 =FFFFE902                  destWaterYPos	rs.w	1				; Target water height
00000000                            
00000000 =FFFFE904                  lvlFrameCnt	rs.w	1				; Level frame counter
00000000 =FFFFE906                  lvlReload	rs.b	1				; Level reload flag
00000000 =FFFFE907                  timeOver	rs.b	1				; Time over flag
00000000                            
00000000 =FFFFE908                  dynEventRout	rs.b	1				; Dynamic event routine ID
00000000                            
00000000 =FFFFE909                  rFlooactIDive	rs.b	1				; Floor active flag
00000000 =FFFFE90A                  rFloorTimer	rs.w	1				; Floor timer
00000000                            
00000000 =FFFFE90C                  lvlAnimCntrs	rs.b	$10				; Level art animation counters
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Camera variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFE88A                  fgCamXPos	equ	fgCamVars+cXPos			; Camera X position
00000000 =FFFFE892                  fgCamYPos	equ	fgCamVars+cYPos			; Camera Y position
00000000 =FFFFE8A8                  bgCamXPos	equ	bgCamVars+cXPos			; Background camera X position
00000000 =FFFFE8B0                  bgCamYPos	equ	bgCamVars+cYPos			; Background camera Y position
00000000 =FFFFE8A6                  fgRedraw	equ	fgCamVars+cRedraw		; Foreground redraw flag
00000000 =FFFFE8C4                  bgRedraw	equ	bgCamVars+cRedraw		; Background redraw flag
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Variables for the vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFC74C                  vInterrupt	equ	vIntJump			; V-INT
00000000 =FFFFC752                  hInterrupt	equ	hIntJump			; H-INT
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Config/Error/debugger.asm"	; Debugger macro set
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000001                  isAMPS =		1		; Set to 1
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dem		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000DF                  fstr		equ		$DF				; flag to display as string (treat as offset, insert string from that offset)
00000000 =000000D0                  fasm		equ		$D0				; flag to display as code (treat as offset, decode from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            ;	* The "asm" flag will use "setpat" flag to switch text color, and will reset pattern to normal again.
00000000                            ;		you must reapply any pattern you used before yourself.
00000000                            ;	* The "asm" flag will overwrite $FF0000-$FF0080, so be careful when viewing RAM.
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  fsplit	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  fendl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  fpal0	equ		$E8				; use palette line #0
00000000 =000000EA                  fpal1	equ		$EA				; use palette line #1
00000000 =000000EC                  fpal2	equ		$EC				; use palette line #2
00000000 =000000EE                  fpal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            	pea		*(pc)
00000000                            	RaiseError2 \_
00000000                            	endm
00000000                            
00000000                            RaiseError2 &
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea	4*4(sp), a2
00000000                            		endc
00000000                            		lea	.str\@(pc), a1
00000000                            		jsr	ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea	__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	.instr_end\@
00000000                            	.str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	.instr_end\@:
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr	ErrorHandler.__extern__console_only
00000000                            		jsr	\1
00000000                            		if narg<=1		; HACK
00000000                            			bra.s	*
00000000                            		endif
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr	ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	while (__pos)
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            	endm
00000000                            		
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Header.asm"
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Based on MarkeyJester's shortened header and initialization
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Store a string in memory with a character limit (also pads to that limit if it doesn't exceed it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string	- The string
00000000                            ;	limit	- character limit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            headStr		macro	string, limit
00000000                            		local	p
00000000                            p =		*
00000000                            		dcb.b	\limit, " "
00000000                            		org	p
00000000                            		dc.b	\string
00000000                            		org	p+\limit
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		org	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 F0A1 000C                  		dc.l	($F0<<24)|PORT_C_CTRL-1		; Stack pointer (set like so for initialization routine) (also manufacture lineF exception)
00000004                            
00000004 0000 0000                  		dc.l	.PrgInit			; Entry pointer
00000008                            
00000008 0000 0000                  		dc.l	exBus				; Bus error
0000000C 0000 0000                  		dc.l	exAddr				; Address error
00000010 0000 0000                  		dc.l	exIll				; Illegal instruction error
00000014 0000 0000                  		dc.l	exDiv				; Division by zero error
00000018 0000 0000                  		dc.l	exChk				; CHK out of bounds error
0000001C 0000 0000                  		dc.l	Trapv				; TRAPV interrupt
00000020 0000 0000                  		dc.l	exPriv				; Privilege violation error
00000024 0000 0000                  		dc.l	exTrace				; TRACE interrupt
00000028 0000 0000                  		dc.l	exLineA				; Line A emulation
0000002C 0000 0000                  		dc.l	exLineF				; Line F emulation
00000030                            
00000030 0017                       .InitVals:	dc.w	$18-1				; Number of registers to set up
00000032 8004                       		dc.w	$8004				; VDP register base (preset for register 0 - H-INT disabled)
00000034 0100                       		dc.w	$100				; Register increment (also used for Z80 later)
00000036                            
00000036 34                         		dc.b	$34				; DMA enabled, V-INT enabled
00000037 30                         		dc.b	$C000/$400			; Plane A at $C000
00000038 34                         		dc.b	$D000/$400			; Plane W at $D000
00000039 07                         		dc.b	$E000/$2000			; Plane B at $E000
0000003A 7C                         		dc.b	$F800/$200			; Sprite table at $F800
0000003B 00                         		dc.b	$00				; Unused
0000003C 00                         		dc.b	$00				; BG color line 0 entry 0
0000003D 00                         		dc.b	$00				; Unused
0000003E 00                         		dc.b	$00				; Unused
0000003F FF                         		dc.b	$FF				; H-INT every 255th line
00000040 00                         		dc.b	$00				; EXT-INT off, VScroll by screen, HScroll by screen
00000041 81                         		dc.b	$81				; H40 width, interalce disabled, S/H disabled
00000042 3F                         		dc.b	$FC00/$400			; HScroll table at $FC00
00000043 00                         		dc.b	$00				; Unused
00000044 02                         		dc.b	$02				; Autoincrement by 2
00000045 01                         		dc.b	$01				; Plane size 64x32
00000046 00                         		dc.b	$00				; Disable window
00000047 00                         		dc.b	$00				; ''
00000048 FF                         		dc.b	$FF				; DMA length $FFFF
00000049 FF                         		dc.b	$FF				; ''
0000004A 00                         		dc.b	$00				; DMA source 0
0000004B 00                         		dc.b	$00				; ''
0000004C 80                         		dc.b	$80				; '' + VRAM fill mode
0000004D                            
0000004D 40                         		dc.b	$40				; Port initialization value
0000004E                            
0000004E                            		vdpCmd	dc.l,0,VRAM,DMA			; VDP DMA at $0000
0000004E 4000 0080                M 	dc.l	((((vram&dma)&3)<<30)|((0&$3fff)<<16)|(((vram&dma)&$fc)<<2)|((0&$c000)>>14))
00000052                            
00000052 000E 1FFD                  		dc.w	$E, $2000-2-1			; Checksum error color, amount of Z80 to clear
00000056 00A0 0000                  		dc.l	Z80_RAM				; Z80 RAM
0000005A 00A1 1100                  		dc.l	Z80_BUS_REQ			; Z80 bus request
0000005E 00A1 1200                  		dc.l	Z80_RESET			; Z80 reset
00000062                            
00000062                            		vdpCmd	dc.l,0,CRAM,WRITE		; CRAM WRITE at $0000
00000062 C000 0000                M 	dc.l	((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14))
00000066                            		vdpCmd	dc.l,0,VSRAM,WRITE		; VSRAM WRITE at $0000
00000066 4000 0010                M 	dc.l	((((vsram&write)&3)<<30)|((0&$3fff)<<16)|(((vsram&write)&$fc)<<2)|((0&$c000)>>14))
0000006A                            
0000006A 9FBF DFFF                  		dc.b	$9F, $BF, $DF, $FF		; PSG mute values
0000006E                            
0000006E F3C3                       		dc.b	$F3, $C3			; di and jp instructions for Z80
00000070                            
00000070 FFFF C752                  		dc.l	hInterrupt			; Horizontal interrupt
00000074 00C0 0000                  .VDPDPort:	dc.l	VDP_DATA			; Interrupt level 5
00000078 FFFF C74C                  		dc.l	vInterrupt			; Vertical interrupt
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ; Program initialization
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ICD_BLK		EQU	.PrgInit
0000007C                            .PrgInit:
0000007C                            		intsOff
0000007C 007C 0700                M 	ori	#$700,sr
00000080                            
00000080                            		; --- CHECK WARM BOOT ---
00000080                            
00000080 4A57                       		tst.w	(sp)				; Has port C been initialized already?
00000082 6600 0000                  		bne.w	.WarmBoot			; If so, branch
00000086                            
00000086 7800                       		moveq	#0,d4				; Register that holds 0
00000088 7C00                       		moveq	#0,d6				; Checksum value
0000008A                            
0000008A                            		; --- CHECK TMSS ---
0000008A                            
0000008A 162F FFF5                  		move.b	-$B(sp),d3			; Get hardware version
0000008E E903                       		asl.b	#4,d3				; ''
00000090 6700                       		beq.s	.NoTMSS				; If this is a non-TMSS system, branch
00000092 2F78 0100 3FF4             		move.l	$100.w,$3FF4(sp)		; Satisfy the TMSS
00000098                            
00000098                            .NoTMSS:
00000098                            
00000098                            		; --- SET UP VDP REGISTERS ---
00000098                            
00000098 2A78 0074                  		movea.l	.VDPDPort.w,a5			; VDP data port
0000009C 4DED 0004                  		lea	4(a5),a6			; VDP control port
000000A0                            
000000A0                            .WaitDMA:
000000A0 44D6                       		move.w	(a6),ccr			; Load status
000000A2 69FC                       		bvs.s	.WaitDMA			; If there's a DMA, wait
000000A4                            
000000A4 41F8 0030                  		lea	.InitVals.w,a0			; VDP registers
000000A8 4C98 0026                  		movem.w	(a0)+,d1/d2/d5			; Get number of entries, register base, and register increment
000000AC                            
000000AC                            .InitVDPRegs:
000000AC 3C82                       		move.w	d2,(a6)				; Set register data
000000AE D445                       		add.w	d5,d2				; Next register
000000B0 1418                       		move.b	(a0)+,d2			; Get register data
000000B2 51C9 FFF8                  		dbf	d1,.InitVDPRegs			; Loop
000000B6                            
000000B6                            		; --- CLEAR VRAM ---
000000B6                            
000000B6 2C98                       		move.l	(a0)+,(a6)			; Set DMA fill destination
000000B8 3C84                       		move.w	d4,(a6)				; Set DMA fill value
000000BA                            
000000BA                            		; --- CLEAR RAM ---
000000BA                            
000000BA 2444                       		movea.l	d4,a2				; End of RAM
000000BC 323C 3FFF                  		move.w	#(RAM_END-RAM_START)>>2-1,d1	; Longwords to clear
000000C0                            
000000C0                            .ClearRAM:
000000C0 2504                       		move.l	d4,-(a2)			; Clear RAM
000000C2 51C9 FFFC                  		dbf	d1,.ClearRAM			; Loop
000000C6                            
000000C6                            		; --- SET UP FOR Z80 ---
000000C6                            
000000C6 4CD8 1A01                  		movem.l	(a0)+,d0/a1/a3/a4		; Load Z80 addresses and values
000000CA 3685                       		move.w	d5,(a3)				; Request Z80 stop
000000CC                            
000000CC                            		; --- CLEAR CRAM AND VSRAM AND INITIALIZE JOYPADS ---
000000CC                            
000000CC 4441                       		neg.w	d1				; Run the next bit 2 times
000000CE                            
000000CE                            .InitVDPJoypads:
000000CE 2C98                       		move.l	(a0)+,(a6)			; Set VDP command
000000D0 761F                       		moveq	#$80>>2-1,d3			; Longwords to clear
000000D2                            
000000D2                            .ClearVDPMem:
000000D2 2A84                       		move.l	d4,(a5)				; Clear memory
000000D4 51CB FFFC                  		dbf	d3,.ClearVDPMem			; Loop
000000D8 3F02                       		move.w	d2,-(sp)			; Initialize port
000000DA 51C9 FFF2                  		dbf	d1,.InitVDPJoypads		; Loop
000000DE                            
000000DE 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
000000E0                            
000000E0                            		; --- MUTE PSG ---
000000E0                            
000000E0 7603                       		moveq	#4-1,d3				; Number of PSG channels
000000E2                            
000000E2                            .MutePSG:
000000E2 1D58 000D                  		move.b	(a0)+,$D(a6)			; Mute channel
000000E6 51CB FFFA                  		dbf	d3,.MutePSG			; Loop
000000EA                            
000000EA                            		; --- INITIALIZE Z80 ---
000000EA                            
000000EA 12D8                       		move.b	(a0)+,(a1)+			; Write di (disable Z80 interrupts)
000000EC 12D8                       		move.b	(a0)+,(a1)+			; Write jp (Will end up just looping forever at the beginning)
000000EE                            
000000EE                            .ClearZ80:
000000EE 12C4                       		move.b	d4,(a1)+			; Clear Z80
000000F0 51C8 FFFC                  		dbf	d0,.ClearZ80			; Loop
000000F4                            
000000F4 3884                       		move.w	d4,(a4)				; Reset the Z80
000000F6                            
000000F6                            		; --- CHECK THE CHECKSUM ---
000000F6                            
000000F6 41F8 0200                  		lea	$200.w,a0			; Start reading data at the end of the header
000000FA 2238 01A4                  		move.l	$1A4.w,d1			; Get ROM end address
000000FE                            
000000FE 6000                       		bra.s	.ChkChecksum			; Continue
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100                            ; Header
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100 5345 4741                  		dc.b	"SEGA"				; Hardware system ID
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            ; Program initialization (part 2)
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            .ChkChecksum:
00000104 DC58                       		add.w	(a0)+,d6			; Add ROM data to the checksum value
00000106 B288                       		cmp.l	a0,d1				; Are we at the end of the ROM?
00000108 64FA                       		bcc.s	.ChkChecksum			; If not, keep adding
0000010A BC78 018E                  		cmp.w	$18E.w,d6			; Is the checksum correct?
0000010E 6700                       		beq.s	.ChksumPassed			; If not, branch
00000110                            
00000110                            .ChksumError:
00000110                            		vdpCmd	move.l,0,CRAM,WRITE,(a6)	; Set background to red
00000110 2CBC C000 0000           M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),(a6)
00000116 2A80                       		move.l	d0,(a5)				; ''
00000118 60F6                       		bra.s	.ChksumError			; Loop here forever
0000011A                            
0000011A                            .ChksumPassed:
0000011A 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
0000011C 3684                       		move.w	d4,(a3)				; Start the Z80
0000011E                            
0000011E                            		; --- FINISH I/O INITIALIZATION ---
0000011E                            
0000011E 3F42 0004                  		move.w	d2,4(sp)			; Initialize port C
00000122                            
00000122                            .WarmBoot:
00000122 4FF8 0000                  		lea	stack.w,sp		; Set the stack pointer
00000126 4CD4 7FFF                  		movem.l	(a4),d0-a6			; Clear registers
0000012A                            
0000012A 4EF9 0000 0000             		jmp	GameInit			; Go to the game initialization
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            ; Header (part 2)
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            		headStr	"\NOTES", $20			; Notes
00000130                          M 	local	p
00000130 =00000130                M p	=	*
00000130 2020 2020 2020 2020 2020+M 	dcb.b	$20," "
00000150                          M 	org	p
00000130                          M 	dc.b	""
00000130                          M 	org	p+$20
00000150                            		headStr	"\GAME_NAME", $30		; International game name
00000150                          M 	local	p
00000150 =00000150                M p	=	*
00000150 2020 2020 2020 2020 2020+M 	dcb.b	$30," "
00000180                          M 	org	p
00000150 4865 6467 6562 7265 7720+M 	dc.b	"Hedgebrew Engine Project                        "
00000180                          M 	org	p+$30
00000180 474D 2030 3030 3030 3030+  		dc.b	"GM 00000000-00"		; Version
0000018E 0000                       		dc.w	0				; Checksum value (replaced by external program)
00000190                            		headStr	"\IO_SUPPORT", $10		; I/O support
00000190                          M 	local	p
00000190 =00000190                M p	=	*
00000190 2020 2020 2020 2020 2020+M 	dcb.b	$10," "
000001A0                          M 	org	p
00000190 4A                       M 	dc.b	"J"
00000191                          M 	org	p+$10
000001A0 0000 0000 003F FFFF        		dc.l	ROM_START, ROM_END-1		; ROM start and end addresses (replaced by external program)
000001A8 00FF 0000 00FF FFFF        		dc.l	RAM_START, RAM_END-1		; RAM start and end addresses
000001B0 2020 2020                  		dc.l	SRAM_SUPPORT			; SRAM support
000001B4 2020 2020 2020 2020        		dc.l	SRAM_START, SRAM_END		; SRAM start and end addresses
000001BC                            ; =========================================================================================================================================================
000001BC                            
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Entry point
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            GameInit:
000001BC                            		intsOff						; Disable interrupts
000001BC 007C 0700                M 	ori	#$700,sr
000001C0                            		
000001C0                            		clrRAM	RAM_START, RAM_END			; Clear RAM
000001C0                          M 	local	endaddr
000001C0                          M endaddr	equs	"ram_end"
000001C0 7000                     M 	moveq	#0,d0
000001C2 43F9 00FF 0000           M 	lea	ram_start,a1
000001C8 323C 3FFF                M 	move.w	#(((ram_end)-(ram_start))-((ram_start)&1))>>2-1,d1
000001CC 22C0                     M .clear_22:	move.l	d0,(a1)+
000001CE 51C9 FFFC                M 	dbf	d1,.clear_22
000001D2                            		
000001D2 6100 0000                  		bsr.w	InitDMAQueue				; Initialize the DMA queue
000001D6 6100 0000                  		bsr.w	InitVDP					; Initialize the VDP
000001DA 4EB9 0000 0000             		jsr	LoadDualPCM				; Load Dual PCM
000001E0                            		
000001E0 1039 00A1 0001             		move.b	HW_VERSION,d0				; Get hardware version
000001E6 0200 00C0                  		andi.b	#$C0,d0					; Just get region bits
000001EA 11C0 C746                  		move.b	d0,hwVersion.w				; Store in RAM
000001EE                            
000001EE 303C 4EF9                  		move.w	#$4EF9,d0				; JMP opcode
000001F2 31C0 C74C                  		move.w	d0,vIntJump.w				; Set the "JMP" command for V-INT
000001F6 31C0 C752                  		move.w	d0,hIntJump.w				; Set the "JMP" command for H-INT
000001FA 21FC 0000 0000 C74E        		move.l	#VInt_Standard,vIntAddress.w		; Set the V-INT pointer to the standard V-INT routine
00000202 21FC 0000 0000 C754        		move.l	#HInt_Water,hIntAddress.w			; Set the H-INT pointer to the standard V-INT routine
0000020A                            
0000020A 4278 9000                  		clr.w	dmaQueue.w				; Set stop token at the beginning of the DMA queue
0000020E 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w			; Reset the DMA queue slot
00000214                            
00000214 11FC 0000 C75C             		move.b	#gTitle,opmode.w			; Set game mode to "title"
0000021A 4EF9 0000 0000             		jmp	TitleScreen					; Go to the title screen
00000220                            
00000220                            ; =========================================================================================================================================================
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            ; Go to the correct game mode
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            GotoGameMode:
00000220 7000                       		moveq	#0,d0
00000222 1038 C75C                  		move.b	opmode.w,d0				; Get game mode ID
00000226 207B 0000                  		movea.l	.GameModes(pc,d0.w),a0			; Get pointer
0000022A 4ED0                       		jmp	(a0)					; Jump to it
0000022C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000022C                            .GameModes:
0000022C 0000 0000                  		dc.l	TitleScreen				; Title screen
00000230 0000 0000                  		dc.l	Level					; Level mode
00000234 0000 0000                  		dc.l	Ending					; Ending
00000238                            
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Function libraries
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            		include	"Libraries/VDP.asm"		; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Initialize the VDP
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; PARAMETERS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; RETURNS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            InitVDP:
00000238 31FC 8134 C766             		move.w	#$8134,vdpReg1.w		; Save VDP register 1 in RAM
0000023E 31FC 8AFF C760             		move.w	#$8AFF,hIntCntReg.w		; Save H-INT counter register in RAM
00000244                            
00000244 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; Clear the screen and other VDP data (64 tile width)
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; PARAMETERS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; RETURNS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ClearScreen:
00000248 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0000024E                            		dmaFill	0,$C000,$3000			; Clear planes
0000024E 3CBC 8F01                M 	move.w	#$8f01,(a6)
00000252 2CBC 942F 93FF           M 	move.l	#$94009300|(((($3000)-1)&$ff00)<<8)|((($3000)-1)&$ff),(a6)
00000258 3CBC 9780                M 	move.w	#$9780,(a6)
0000025C 2CBC 4000 0083           M 	move.l	#$40000080|((($c000)&$3fff)<<16)|((($c000)&$c000)>>14),(a6)
00000262 3D7C 0000 FFFC           M 	move.w	#(0)<<8,-4(a6)
00000268                          M 	waitdma	(a6)
00000268                          M .wait_24:
00000268 3216                     M 	move.w	(a6),d1
0000026A 0801 0001                M 	btst	#1,d1
0000026E 66F8                     M 	bne.s	.wait_24
00000270 3CBC 8F02                M 	move.w	#$8f02,(a6)
00000274                            
00000274                            		clrRAM	hScrollBuff, vScrollBuff_End	; Clear scroll tables
00000274                          M 	local	endaddr
00000274                          M endaddr	equs	"vscrollbuff_end"
00000274 7000                     M 	moveq	#0,d0
00000276 43F8 90FE                M 	lea	(hscrollbuff).w,a1
0000027A 323C 00F3                M 	move.w	#(((vscrollbuff_end)-(hscrollbuff))-((hscrollbuff)&1))>>2-1,d1
0000027E 22C0                     M .clear_25:	move.l	d0,(a1)+
00000280 51C9 FFFC                M 	dbf	d1,.clear_25
00000284                            		
00000284 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Load a plane map
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; PARAMETERS:
00000288                            ;	d0.l	- VDP command for writing the data to VRAM
00000288                            ;	d1.w	- Width in tiles (minus 1)
00000288                            ;	d2.w	- Height in tiles (minus 1)
00000288                            ;	d3.w	- Base tile properties for each tile
00000288                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
00000288                            ;	a1.l	- Plane map address
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; RETURNS:
00000288                            ;	Nothing
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            LoadPlaneMap:
00000288                            LoadPlaneMap_H64:
00000288 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
0000028E 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000290                            
00000290                            LoadPlaneMap_H32:
00000290 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
00000296 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000298                            
00000298                            LoadPlaneMap_H128:
00000298 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
0000029E                            
0000029E                            LoadPlaneMap_Custom:
0000029E                            .RowLoop:
0000029E 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002A4 3801                       		move.w	d1,d4				; Store width
000002A6                            
000002A6                            .TileLoop:
000002A6 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002A8 DA43                       		add.w	d3,d5				; Add base tile properties
000002AA 33C5 00C0 0000             		move.w	d5,VDP_DATA			; Save in VRAM
000002B0 51CC FFF4                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002B4 D086                       		add.l	d6,d0				; Next row
000002B6 51CA FFE6                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002BA 4E75                       		rts
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; Load a plane map into RAM
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; PARAMETERS:
000002BC                            ;	d1.w	- Width in tiles (minus 1)
000002BC                            ;	d2.w	- Height in tiles (minus 1)
000002BC                            ;	d3.w	- Base tile properties for each tile
000002BC                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
000002BC                            ;	a0.l	- Buffer to load into
000002BC                            ;	a1.l	- Plane map address
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; RETURNS:
000002BC                            ;	Nothing
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            LoadPlaneMap_RAM:
000002BC                            .RowLoop:
000002BC 2448                       		movea.l	a0,a2				; Copy buffer address
000002BE 3801                       		move.w	d1,d4				; Store width
000002C0                            
000002C0                            .TileLoop:
000002C0 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002C2 DA43                       		add.w	d3,d5				; Add base tile properties
000002C4 34C5                       		move.w	d5,(a2)+			; Save in RAM
000002C6 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002CA D0FC 0080                  		adda.w	#$80,a0				; Next row
000002CE 51CA FFEC                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002D2 4E75                       		rts
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; Fill the plane map with a value in a specific region
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; PARAMETERS:
000002D4                            ;	d0.l	- VDP command for writing the data to VRAM
000002D4                            ;	d1.w	- Width in tiles (minus 1)
000002D4                            ;	d2.w	- Height in tiles (minus 1)
000002D4                            ;	d3.w	- Value to fill plane map with
000002D4                            ;	d6.l	- Delta value for drawing to the next row
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; RETURNS:
000002D4                            ;	Nothing
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            FillPlaneMap:
000002D4                            FillPlaneMap_H64:
000002D4 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
000002DA 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002DC                            
000002DC                            FillPlaneMap_H32:
000002DC 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
000002E2 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002E4                            
000002E4                            FillPlaneMap_H128:
000002E4 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
000002EA                            
000002EA                            FillPlaneMap_Custom:
000002EA                            .RowLoop:
000002EA 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002F0 3801                       		move.w	d1,d4				; Store width
000002F2                            
000002F2                            .TileLoop:
000002F2 33C3 00C0 0000             		move.w	d3,VDP_DATA			; Save value in VRAM
000002F8 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002FC D086                       		add.l	d6,d0				; Next row
000002FE 51CA FFEA                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000302 4E75                       		rts
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Queue a VDP DMA command to VRAM, to be issued the next time ProcessDMAQueue is called. Can be called a maximum of 18 times before the queue needs
00000304                            ; to be cleared by issuing the commands (this checks for overflow)
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; PARAMETERS:
00000304                            ; 	d1.l	- Source address
00000304                            ; 	d2.w	- Destination address
00000304                            ; 	d3.w	- Transfer length
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; RETURNS:
00000304                            ;	Nothing
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is disabled by default because you can simply align the art in ROM
00000304                            ; and avoid the issue altogether. It is here so that you have a high-performance routine to do the job in situations where you can't align it in ROM.
00000304 =00000001                  Use128kbSafeDMA		= 1
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to mask interrupts while updating the DMA queue. This fixes many race conditions in the DMA funcion, but it costs 46(6/1) cycles. The
00000304                            ; better way to handle these race conditions would be to make unsafe callers (such as S3&K's KosM decoder) prevent these by masking off interrupts
00000304                            ; before calling and then restore interrupts after.
00000304 =00000000                  UseVIntSafeDMA		= 0
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to assume that transfer length is always less than $7FFF. Only makes sense if Use128kbSafeDMA is 1. Moreover, setting this to 1 will
00000304                            ; cause trouble on a 64kB DMA, so make sure you never do one if you set it to 1! Enabling this saves 4(1/0) cycles on the case where a DMA is
00000304                            ; broken in two and both transfers are properly queued, and nothing at all otherwise.
00000304 =00000000                  AssumeMax7FFFXfer	= 0&Use128kbSafeDMA
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Convenience macros, for increased maintainability of the code.
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Like vdpComm, but starting from an address contained in a register
00000304 =00000001                  vdpCommReg_defined = 1
00000304                            vdpCommReg	macro	reg, type, rwd, clr
00000304                            		local	cd
00000304                            cd		= \type&\rwd
00000304                            		lsl.l	#2,\reg				; Move high bits into (word-swapped) position, accidentally moving everything else
00000304                            		if ((cd)&3)<>0
00000304                            			addq.w	#((cd)&3),\reg		; Add upper access type bits
00000304                            		endif
00000304                            		ror.w	#2,\reg				; Put upper access type bits into place, also moving all other bits into their correct
00000304                            							; (word-swapped) places
00000304                            		swap	\reg				; Put all bits in proper places
00000304                            		if \clr<>0
00000304                            			andi.w	#3,\reg			; Strip whatever junk was in upper word of reg
00000304                            		endif
00000304                            		if ((cd)&$FC)=$20
00000304                            			tas.b	\reg			; Add in the DMA flag -- tas fails on memory, but works on registers
00000304                            		elseif ((cd)&$FC)<>0
00000304                            			ori.w	#(((cd)&$FC)*4),\reg	; Add in missing access type bits
00000304                            		endif
00000304                            		endm
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            QueueDMATransfer:
00000304                            
00000304 3278 90FC                  		movea.w	dmaSlot.w,a1
00000308 B2FC 90FC                  		cmpa.w	#dmaSlot,a1
0000030C 6700                       		beq.s	.Done				; Return if there's no more room in the queue
0000030E                            
0000030E E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00000310                            
00000310 3003                       			move.w  d3,d0			; d0 = length of transfer in words
00000312                            			; Compute position of last transferred word. This handles 2 cases:
00000312                            			; (1) zero length DMAs transfer length actually transfer $10000 words
00000312                            			; (2) (source+length)&$FFFF = 0
00000312 5340                       			subq.w  #1,d0
00000314 D041                       			add.w   d1,d0			; d0 = ((src_address >> 1) & $FFFF) + ((xferlen >> 1) - 1)
00000316 6500                       			bcs.s   .DoubleTransfer		; Carry set = ($10000 << 1) = $20000, or new 128kB block
00000318                            
00000318                            		; Store VDP commands for specifying DMA into the queue
00000318 4841                       		swap	d1				; Want the high byte first
0000031A 303C 977F                  		move.w	#$977F,d0			; Command to specify source address & $FE0000, plus bitmask for the given byte
0000031E C001                       		and.b	d1,d0				; Mask in source address & $FE0000, stripping high bit in the process
00000320 32C0                       		move.w	d0,(a1)+			; Store command
00000322 3203                       		move.w	d3,d1				; Put length together with (source address & $01FFFE) >> 1...
00000324 03C9 0001                  		movep.l	d1,1(a1)			; ... and stuff them all into RAM in their proper places (movep for the win)
00000328 43E9 0008                  		lea	8(a1),a1			; Skip past all of these commands
0000032C                            
0000032C                            		vdpCommReg d2,VRAM,DMA,1		; Make DMA destination command
0000032C                          M 	local	cd
0000032C =00000021                M cd	=	vram&dma
0000032C E58A                     M 	lsl.l	#2,d2
0000032E 5242                     M 	addq.w	#((cd)&3),d2
00000330 E45A                     M 	ror.w	#2,d2
00000332 4842                     M 	swap	d2
00000334 0242 0003                M 	andi.w	#3,d2
00000338 4AC2                     M 	tas.b	d2
0000033A 22C2                       		move.l	d2,(a1)+			; Store command
0000033C                            
0000033C 4251                       		clr.w	(a1)				; Put a stop token at the end of the used part of the queue
0000033E 31C9 90FC                  		move.w	a1,dmaSlot.w			; Set the next free slot address, potentially undoing the above clr (this is intentional!)
00000342                            
00000342                            .Done:
00000342 4E75                       		rts
00000344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000344                            .DoubleTransfer:
00000344                            			; Hand-coded version to break the DMA transfer into two smaller transfers
00000344                            			; that do not cross a 128kB boundary. This is done much faster (at the cost
00000344                            			; of space) than by the method of saving parameters and calling the normal
00000344                            			; DMA function twice, as Sonic3_Complete does.
00000344                            			; d0 is the number of words-1 that got over the end of the 128kB boundary
00000344 5240                       			addq.w	#1,d0			; Make d0 the number of words past the 128kB boundary
00000346 9640                       			sub.w	d0,d3			; First transfer will use only up to the end of the 128kB boundary
00000348                            
00000348                            			; Store VDP commands for specifying DMA into the queue
00000348 4841                       			swap	d1			; Want the high byte first
0000034A                            
0000034A                            			; Sadly, all registers we can spare are in use right now, so we can't use
0000034A                            			; no-cost RAM source safety.
0000034A 0241 007F                  			andi.w	#$7F,d1			; Strip high bit
0000034E 0041 9700                  			ori.w	#$9700,d1		; Command to specify source address & $FE0000
00000352 32C1                       			move.w	d1,(a1)+		; Store command
00000354 5201                       			addq.b	#1,d1			; Advance to next 128kB boundary (**)
00000356 3341 000C                  			move.w	d1,12(a1)		; Store it now (safe to do in all cases, as we will overwrite later if queue got filled) (**)
0000035A 3203                       			move.w	d3,d1			; Put length together with (source address & $01FFFE) >> 1...
0000035C 03C9 0001                  			movep.l	d1,1(a1)		; ... and stuff them all into RAM in their proper places (movep for the win)
00000360 43E9 0008                  			lea	8(a1),a1		; Skip past all of these commands
00000364                            
00000364 3602                       			move.w	d2,d3			; Save for later
00000366                            			vdpCommReg d2,VRAM,DMA,1	; Make DMA destination command
00000366                          M 	local	cd
00000366 =00000021                M cd	=	vram&dma
00000366 E58A                     M 	lsl.l	#2,d2
00000368 5242                     M 	addq.w	#((cd)&3),d2
0000036A E45A                     M 	ror.w	#2,d2
0000036C 4842                     M 	swap	d2
0000036E 0242 0003                M 	andi.w	#3,d2
00000372 4AC2                     M 	tas.b	d2
00000374 22C2                       			move.l	d2,(a1)+		; Store command
00000376                            
00000376 B2FC 90FC                  			cmpa.w	#dmaSlot,a1		; Did this command fill the queue?
0000037A 6700                       			beq.s	.SkipSecondTransfer	; Branch if so
0000037C                            
0000037C                            			; Store VDP commands for specifying DMA into the queue
0000037C                            			; The source address high byte was done above already in the comments marked
0000037C                            			; with (**)
0000037C 7400                       				moveq	#0,d2		; Need a zero for a 128kB block start
0000037E 3400                       				move.w	d0,d2		; Copy number of words on this new block...
00000380 05C9 0003                  				movep.l	d2,3(a1)	; ... and stuff it all into RAM at the proper places (movep for the win)
00000384 43E9 000A                  			lea	10(a1),a1		; Skip past all of these commands
00000388                            
00000388                            			; d1 contains length up to the end of the 128kB boundary
00000388 D241                       			add.w	d1,d1			; Convert it into byte length...
0000038A D243                       			add.w	d3,d1			; ... and offset destination by the correct amount
0000038C                            			vdpCommReg d1,VRAM,DMA,1	; Make DMA destination command
0000038C                          M 	local	cd
0000038C =00000021                M cd	=	vram&dma
0000038C E589                     M 	lsl.l	#2,d1
0000038E 5241                     M 	addq.w	#((cd)&3),d1
00000390 E459                     M 	ror.w	#2,d1
00000392 4841                     M 	swap	d1
00000394 0241 0003                M 	andi.w	#3,d1
00000398 4AC1                     M 	tas.b	d1
0000039A 22C1                       			move.l	d1,(a1)+		; Store command
0000039C                            
0000039C 4251                       			clr.w	(a1)			; Put a stop token at the end of the used part of the queue
0000039E 31C9 90FC                  			move.w	a1,dmaSlot.w		; Set the next free slot address, potentially undoing the above clr (this is intentional!)
000003A2                            
000003A2 4E75                       			rts
000003A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A4                            .SkipSecondTransfer:
000003A4 3289                       			move.w	a1,(a1)			; Set the next free slot address, overwriting what the second (**) instruction did
000003A6                            	
000003A6 4E75                       			rts
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; Issue all the queued VDP DMA commands from QueueDMATransfer, resets the queue when it's done
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; PARAMETERS:
000003A8                            ;	a6.l	- VDP control port
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; RETURNS:
000003A8                            ;	Nothing
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ProcessDMAQueue:
000003A8 43F8 9000                  		lea	dmaQueue.w,a1
000003AC 31C9 90FC                  		move.w	a1,dmaSlot.w
000003B0                            
000003B0                            		rept (dmaSlot-dmaQueue)/(7*2)
000003B0                            			move.w	(a1)+,d0
000003B0                            			beq.w	.Done			; Branch if we reached a stop token
000003B0                            			
000003B0                            			move.w	d0,(a6)			; Issue a set of VDP commands...
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            		endr
000003B0 3019                     M 	move.w	(a1)+,d0
000003B2 6700 0000                M 	beq.w	.done
000003B6 3C80                     M 	move.w	d0,(a6)
000003B8 2C99                     M 	move.l	(a1)+,(a6)
000003BA 2C99                     M 	move.l	(a1)+,(a6)
000003BC 3C99                     M 	move.w	(a1)+,(a6)
000003BE 3C99                     M 	move.w	(a1)+,(a6)
000003C0 3019                     M 	move.w	(a1)+,d0
000003C2 6700 0000                M 	beq.w	.done
000003C6 3C80                     M 	move.w	d0,(a6)
000003C8 2C99                     M 	move.l	(a1)+,(a6)
000003CA 2C99                     M 	move.l	(a1)+,(a6)
000003CC 3C99                     M 	move.w	(a1)+,(a6)
000003CE 3C99                     M 	move.w	(a1)+,(a6)
000003D0 3019                     M 	move.w	(a1)+,d0
000003D2 6700 0000                M 	beq.w	.done
000003D6 3C80                     M 	move.w	d0,(a6)
000003D8 2C99                     M 	move.l	(a1)+,(a6)
000003DA 2C99                     M 	move.l	(a1)+,(a6)
000003DC 3C99                     M 	move.w	(a1)+,(a6)
000003DE 3C99                     M 	move.w	(a1)+,(a6)
000003E0 3019                     M 	move.w	(a1)+,d0
000003E2 6700 0000                M 	beq.w	.done
000003E6 3C80                     M 	move.w	d0,(a6)
000003E8 2C99                     M 	move.l	(a1)+,(a6)
000003EA 2C99                     M 	move.l	(a1)+,(a6)
000003EC 3C99                     M 	move.w	(a1)+,(a6)
000003EE 3C99                     M 	move.w	(a1)+,(a6)
000003F0 3019                     M 	move.w	(a1)+,d0
000003F2 6700 0000                M 	beq.w	.done
000003F6 3C80                     M 	move.w	d0,(a6)
000003F8 2C99                     M 	move.l	(a1)+,(a6)
000003FA 2C99                     M 	move.l	(a1)+,(a6)
000003FC 3C99                     M 	move.w	(a1)+,(a6)
000003FE 3C99                     M 	move.w	(a1)+,(a6)
00000400 3019                     M 	move.w	(a1)+,d0
00000402 6700 0000                M 	beq.w	.done
00000406 3C80                     M 	move.w	d0,(a6)
00000408 2C99                     M 	move.l	(a1)+,(a6)
0000040A 2C99                     M 	move.l	(a1)+,(a6)
0000040C 3C99                     M 	move.w	(a1)+,(a6)
0000040E 3C99                     M 	move.w	(a1)+,(a6)
00000410 3019                     M 	move.w	(a1)+,d0
00000412 6700 0000                M 	beq.w	.done
00000416 3C80                     M 	move.w	d0,(a6)
00000418 2C99                     M 	move.l	(a1)+,(a6)
0000041A 2C99                     M 	move.l	(a1)+,(a6)
0000041C 3C99                     M 	move.w	(a1)+,(a6)
0000041E 3C99                     M 	move.w	(a1)+,(a6)
00000420 3019                     M 	move.w	(a1)+,d0
00000422 6700 0000                M 	beq.w	.done
00000426 3C80                     M 	move.w	d0,(a6)
00000428 2C99                     M 	move.l	(a1)+,(a6)
0000042A 2C99                     M 	move.l	(a1)+,(a6)
0000042C 3C99                     M 	move.w	(a1)+,(a6)
0000042E 3C99                     M 	move.w	(a1)+,(a6)
00000430 3019                     M 	move.w	(a1)+,d0
00000432 6700 0000                M 	beq.w	.done
00000436 3C80                     M 	move.w	d0,(a6)
00000438 2C99                     M 	move.l	(a1)+,(a6)
0000043A 2C99                     M 	move.l	(a1)+,(a6)
0000043C 3C99                     M 	move.w	(a1)+,(a6)
0000043E 3C99                     M 	move.w	(a1)+,(a6)
00000440 3019                     M 	move.w	(a1)+,d0
00000442 6700 0000                M 	beq.w	.done
00000446 3C80                     M 	move.w	d0,(a6)
00000448 2C99                     M 	move.l	(a1)+,(a6)
0000044A 2C99                     M 	move.l	(a1)+,(a6)
0000044C 3C99                     M 	move.w	(a1)+,(a6)
0000044E 3C99                     M 	move.w	(a1)+,(a6)
00000450 3019                     M 	move.w	(a1)+,d0
00000452 6700 0000                M 	beq.w	.done
00000456 3C80                     M 	move.w	d0,(a6)
00000458 2C99                     M 	move.l	(a1)+,(a6)
0000045A 2C99                     M 	move.l	(a1)+,(a6)
0000045C 3C99                     M 	move.w	(a1)+,(a6)
0000045E 3C99                     M 	move.w	(a1)+,(a6)
00000460 3019                     M 	move.w	(a1)+,d0
00000462 6700 0000                M 	beq.w	.done
00000466 3C80                     M 	move.w	d0,(a6)
00000468 2C99                     M 	move.l	(a1)+,(a6)
0000046A 2C99                     M 	move.l	(a1)+,(a6)
0000046C 3C99                     M 	move.w	(a1)+,(a6)
0000046E 3C99                     M 	move.w	(a1)+,(a6)
00000470 3019                     M 	move.w	(a1)+,d0
00000472 6700 0000                M 	beq.w	.done
00000476 3C80                     M 	move.w	d0,(a6)
00000478 2C99                     M 	move.l	(a1)+,(a6)
0000047A 2C99                     M 	move.l	(a1)+,(a6)
0000047C 3C99                     M 	move.w	(a1)+,(a6)
0000047E 3C99                     M 	move.w	(a1)+,(a6)
00000480 3019                     M 	move.w	(a1)+,d0
00000482 6700 0000                M 	beq.w	.done
00000486 3C80                     M 	move.w	d0,(a6)
00000488 2C99                     M 	move.l	(a1)+,(a6)
0000048A 2C99                     M 	move.l	(a1)+,(a6)
0000048C 3C99                     M 	move.w	(a1)+,(a6)
0000048E 3C99                     M 	move.w	(a1)+,(a6)
00000490 3019                     M 	move.w	(a1)+,d0
00000492 6700 0000                M 	beq.w	.done
00000496 3C80                     M 	move.w	d0,(a6)
00000498 2C99                     M 	move.l	(a1)+,(a6)
0000049A 2C99                     M 	move.l	(a1)+,(a6)
0000049C 3C99                     M 	move.w	(a1)+,(a6)
0000049E 3C99                     M 	move.w	(a1)+,(a6)
000004A0 3019                     M 	move.w	(a1)+,d0
000004A2 6700 0000                M 	beq.w	.done
000004A6 3C80                     M 	move.w	d0,(a6)
000004A8 2C99                     M 	move.l	(a1)+,(a6)
000004AA 2C99                     M 	move.l	(a1)+,(a6)
000004AC 3C99                     M 	move.w	(a1)+,(a6)
000004AE 3C99                     M 	move.w	(a1)+,(a6)
000004B0 3019                     M 	move.w	(a1)+,d0
000004B2 6700 0000                M 	beq.w	.done
000004B6 3C80                     M 	move.w	d0,(a6)
000004B8 2C99                     M 	move.l	(a1)+,(a6)
000004BA 2C99                     M 	move.l	(a1)+,(a6)
000004BC 3C99                     M 	move.w	(a1)+,(a6)
000004BE 3C99                     M 	move.w	(a1)+,(a6)
000004C0 3019                     M 	move.w	(a1)+,d0
000004C2 6700 0000                M 	beq.w	.done
000004C6 3C80                     M 	move.w	d0,(a6)
000004C8 2C99                     M 	move.l	(a1)+,(a6)
000004CA 2C99                     M 	move.l	(a1)+,(a6)
000004CC 3C99                     M 	move.w	(a1)+,(a6)
000004CE 3C99                     M 	move.w	(a1)+,(a6)
000004D0 7000                       		moveq	#0,d0
000004D2                            
000004D2                            .Done:
000004D2 31C0 9000                  		move.w	d0,dmaQueue.w
000004D6 4E75                       		rts
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; Initialize the DMA queue
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; PARAMETERS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; RETURNS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            InitDMAQueue:
000004D8 43F8 9000                  		lea	dmaQueue.w,a1
000004DC 32BC 0000                  		move.w	#0,(a1)
000004E0 31C9 90FC                  		move.w	a1,dmaSlot.w
000004E4 223C 9695 9493             		move.l	#$96959493,d1
000004EA =00000000                  c		= 0
000004EA                            		rept (dmaSlot-dmaQueue)/(7*2)
000004EA                            			movep.l	d1,2+c(a1)
000004EA                            c			= c+14
000004EA                            		endr
000004EA 03C9 0002                M 	movep.l	d1,2+c(a1)
000004EE =0000000E                M c	=	c+14
000004EE 03C9 0010                M 	movep.l	d1,2+c(a1)
000004F2 =0000001C                M c	=	c+14
000004F2 03C9 001E                M 	movep.l	d1,2+c(a1)
000004F6 =0000002A                M c	=	c+14
000004F6 03C9 002C                M 	movep.l	d1,2+c(a1)
000004FA =00000038                M c	=	c+14
000004FA 03C9 003A                M 	movep.l	d1,2+c(a1)
000004FE =00000046                M c	=	c+14
000004FE 03C9 0048                M 	movep.l	d1,2+c(a1)
00000502 =00000054                M c	=	c+14
00000502 03C9 0056                M 	movep.l	d1,2+c(a1)
00000506 =00000062                M c	=	c+14
00000506 03C9 0064                M 	movep.l	d1,2+c(a1)
0000050A =00000070                M c	=	c+14
0000050A 03C9 0072                M 	movep.l	d1,2+c(a1)
0000050E =0000007E                M c	=	c+14
0000050E 03C9 0080                M 	movep.l	d1,2+c(a1)
00000512 =0000008C                M c	=	c+14
00000512 03C9 008E                M 	movep.l	d1,2+c(a1)
00000516 =0000009A                M c	=	c+14
00000516 03C9 009C                M 	movep.l	d1,2+c(a1)
0000051A =000000A8                M c	=	c+14
0000051A 03C9 00AA                M 	movep.l	d1,2+c(a1)
0000051E =000000B6                M c	=	c+14
0000051E 03C9 00B8                M 	movep.l	d1,2+c(a1)
00000522 =000000C4                M c	=	c+14
00000522 03C9 00C6                M 	movep.l	d1,2+c(a1)
00000526 =000000D2                M c	=	c+14
00000526 03C9 00D4                M 	movep.l	d1,2+c(a1)
0000052A =000000E0                M c	=	c+14
0000052A 03C9 00E2                M 	movep.l	d1,2+c(a1)
0000052E =000000EE                M c	=	c+14
0000052E 03C9 00F0                M 	movep.l	d1,2+c(a1)
00000532 =000000FC                M c	=	c+14
00000532 4E75                       		rts
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; Load a palette into the main palette buffer
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; PARAMETERS:
00000534                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000534                            ;	a0.l	- Pointer to palette data
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            LoadPalette:
00000534 43F8 98CE                  		lea	paletteBuff.w,a1			; Main palette buffer
00000538 6000                       		bra.s	LoadPalToBuf			; Load the palette
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; Load a palette into the target palette buffer
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; PARAMETERS:
0000053A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000053A                            ;	a0.l	- Pointer to palette data
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            LoadTargetPal:
0000053A 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
0000053E 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; Load a palette into the main water palette buffer
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; PARAMETERS:
00000540                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000540                            ;	a0.l	- Pointer to palette data
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            LoadWaterPal:
00000540 43F8 984E                  		lea	paletteBuffAlt.w,a1		; Main water palette buffer
00000544 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; Load a palette into the target water palette buffer
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; PARAMETERS:
00000546                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000546                            ;	a0.l	- Pointer to palette data
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            LoadTargetWaterPal:
00000546 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; Load a palette into a palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; PARAMETERS:
0000054A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000054A                            ;	a0.l	- Pointer to palette data
0000054A                            ;	a1.l	- Pointer to destination buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            LoadPalToBuf:
0000054A 32D8                       		move.w	(a0)+,(a1)+			; Copy palette data
0000054C 51C8 FFFC                  		dbf	d0,LoadPalToBuf			; Loop
00000550 4E75                       		rts
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; Fade the palette to black
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; PARAMETERS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; RETURNS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            FadeToBlack:
00000552 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000558                            
00000558                            FadeToBlack_Custom:
00000558 7807                       		moveq	#7,d4				; Set repeat times
0000055A                            		
0000055A                            .FadeLoop:
0000055A                            		rept	2
0000055A                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
0000055A                            			bsr.w	VSync_Routine		; Do V-SYNC
0000055A                            		endr
0000055A 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000560 6100 0000                M 	bsr.w	vsync_routine
00000564 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000056A 6100 0000                M 	bsr.w	vsync_routine
0000056E 6100                       		bsr.s	FadeToBlack_Once		; Fade the colors once
00000570 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
00000574 4E75                       		rts
00000576                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000576                            FadeToBlack_Once:
00000576 7000                       		moveq	#0,d0
00000578 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
0000057C 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000580 D0C0                       		adda.w	d0,a0				; ''
00000582 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000586                            
00000586                            .FadeLoop:
00000586 6100                       		bsr.s	.FadeColor			; Fade a color			
00000588 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000058C                            
0000058C 7000                       		moveq	#0,d0
0000058E 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
00000592 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000596 D0C0                       		adda.w	d0,a0				; ''
00000598 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000059C                            
0000059C                            .FadeLoopWater:
0000059C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000059E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000005A2 4E75                       		rts
000005A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005A4                            .FadeColor:
000005A4 3A10                       		move.w	(a0),d5				; Load color
000005A6 6700                       		beq.s	.NoRed				; If the color is already black, branch
000005A8 3205                       		move.w	d5,d1				; Copy color
000005AA 1401                       		move.b	d1,d2				; Load green and red
000005AC 1601                       		move.b	d1,d3				; Load only red
000005AE                            
000005AE 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000005B2 6700                       		beq.s	.NoBlue				; If blue is finished, branch
000005B4 0445 0200                  		subi.w	#$200,d5			; Decrease blue
000005B8                            
000005B8                            .NoBlue:
000005B8 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000005BC 6700                       		beq.s	.NoGreen			; If green is finished, branch
000005BE 0445 0020                  		subi.w	#$20,d5				; Decrease green
000005C2                            
000005C2                            .NoGreen:
000005C2 0203 000E                  		andi.b	#$E,d3				; Get only red
000005C6 6700                       		beq.s	.NoRed				; If red is finished, branch
000005C8 5545                       		subq.w	#2,d5				; Decrease red
000005CA                            
000005CA                            .NoRed:
000005CA 30C5                       		move.w	d5,(a0)+			; Save the color
000005CC 4E75                       		rts
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; Fade the palette from black to the target palette
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; PARAMETERS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; RETURNS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            FadeFromBlack:
000005CE 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
000005D4                            
000005D4                            FadeFromBlack_Custom:
000005D4 780E                       		moveq	#$E,d4				; Maximum color check
000005D6                            
000005D6                            .FadeLoop:
000005D6                            		rept	2
000005D6                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
000005D6                            			bsr.w	VSync_Routine		; Do V-SYNC
000005D6                            		endr
000005D6 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000005DC 6100 0000                M 	bsr.w	vsync_routine
000005E0 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000005E6 6100 0000                M 	bsr.w	vsync_routine
000005EA 6100                       		bsr.s	FadeFromBlack_Once		; Fade the colors once
000005EC 5504                       		subq.b	#2,d4				; Decrement color check
000005EE 66E6                       		bne.s	.FadeLoop			; If we are not done, branch
000005F0                            
000005F0 11FC 000A C747             		move.b	#vFade,vIntRoutine.w		; Set V-INT routine
000005F6 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
000005FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005FA                            FadeFromBlack_Once:
000005FA 7000                       		moveq	#0,d0
000005FC 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000600 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
00000604 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000608 D0C0                       		adda.w	d0,a0				; ''
0000060A D2C0                       		adda.w	d0,a1				; ''
0000060C 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000610                            
00000610                            .FadeLoop:
00000610 6100                       		bsr.s	.FadeColor			; Fade a color			
00000612 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000616                            
00000616 7000                       		moveq	#0,d0
00000618 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000061C 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
00000620 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000624 D0C0                       		adda.w	d0,a0				; ''
00000626 D2C0                       		adda.w	d0,a1				; ''
00000628 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000062C                            
0000062C                            .FadeLoopWater:
0000062C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000062E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000632 4E75                       		rts
00000634                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000634                            .FadeColor:
00000634 1A11                       		move.b	(a1),d5				; Load blue
00000636 3219                       		move.w	(a1)+,d1			; Load green and red
00000638 1401                       		move.b	d1,d2				; Load red
0000063A E809                       		lsr.b	#4,d1				; Get only green
0000063C 0202 000E                  		andi.b	#$E,d2				; Get only red
00000640                            
00000640 3610                       		move.w	(a0),d3				; Load current color
00000642 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000644 6200                       		bhi.s	.NoBlue				; If not, branch
00000646 0643 0200                  		addi.w	#$200,d3			; Increase blue
0000064A                            
0000064A                            .NoBlue:
0000064A B801                       		cmp.b	d1,d4				; Should the green fade?
0000064C 6200                       		bhi.s	.NoGreen			; If not, branch
0000064E 0643 0020                  		addi.w	#$20,d3				; Increase green
00000652                            
00000652                            .NoGreen:
00000652 B802                       		cmp.b	d2,d4				; Should the red fade?
00000654 6200                       		bhi.s	.NoRed				; If not, branch
00000656 5443                       		addq.w	#2,d3				; Increase red
00000658                            
00000658                            .NoRed:
00000658 30C3                       		move.w	d3,(a0)+			; Save the color
0000065A 4E75                       		rts
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; Fade the palette to white
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; PARAMETERS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; RETURNS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            FadeToWhite:
0000065C 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000662                            
00000662                            FadeToWhite_Custom:
00000662 7807                       		moveq	#7,d4				; Set repeat times
00000664                            
00000664                            .FadeLoop:
00000664                            		rept	2
00000664                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
00000664                            			bsr.w	VSync_Routine		; Do V-SYNC
00000664                            		endr
00000664 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000066A 6100 0000                M 	bsr.w	vsync_routine
0000066E 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000674 6100 0000                M 	bsr.w	vsync_routine
00000678 6100                       		bsr.s	FadeToWhite_Once		; Fade the colors once
0000067A 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
0000067E 4E75                       		rts
00000680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000680                            FadeToWhite_Once:
00000680 7000                       		moveq	#0,d0
00000682 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000686 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
0000068A D0C0                       		adda.w	d0,a0				; ''
0000068C 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000690                            
00000690                            .FadeLoop:
00000690 6100                       		bsr.s	.FadeColor			; Fade a color			
00000692 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000696                            
00000696 7000                       		moveq	#0,d0
00000698 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000069C 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000006A0 D0C0                       		adda.w	d0,a0				; ''
000006A2 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000006A6                            
000006A6                            .FadeLoopWater:
000006A6 6100                       		bsr.s	.FadeColor			; Fade a color			
000006A8 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000006AC 4E75                       		rts
000006AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006AE                            .FadeColor:
000006AE 3A10                       		move.w	(a0),d5				; Load color
000006B0 0C45 0EEE                  		cmpi.w	#$EEE,d5			; Is it already white?
000006B4 6700                       		beq.s	.NoRed				; If so, branch
000006B6 3205                       		move.w	d5,d1				; Copy color
000006B8 1401                       		move.b	d1,d2				; Load green and red
000006BA 1601                       		move.b	d1,d3				; Load only red
000006BC                            
000006BC 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000006C0 0C41 0E00                  		cmpi.w	#$E00,d1			; Is blue finished?
000006C4 6700                       		beq.s	.NoBlue				; If do, branch
000006C6 0645 0200                  		addi.w	#$200,d5			; Increase blue
000006CA                            
000006CA                            .NoBlue:
000006CA 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000006CE 0C02 00E0                  		cmpi.b	#$E0,d2				; Is green finished?
000006D2 6700                       		beq.s	.NoGreen			; If so, branch
000006D4 0645 0020                  		addi.w	#$20,d5				; Increase green
000006D8                            
000006D8                            .NoGreen:
000006D8 0203 000E                  		andi.b	#$E,d3				; Get only red
000006DC 0C03 000E                  		cmpi.b	#$E,d3				; Is red finished?
000006E0 6700                       		beq.s	.NoRed				; If so, branch
000006E2 5445                       		addq.w	#2,d5				; Increase red
000006E4                            
000006E4                            .NoRed:
000006E4 30C5                       		move.w	d5,(a0)+			; Save the color
000006E6 4E75                       		rts
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; Fade the palette from white to the target palette
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; PARAMETERS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; RETURNS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            FadeFromWhite:
000006E8 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
000006EE                            
000006EE                            FadeFromWhite_Custom:
000006EE 7800                       		moveq	#0,d4				; Minimum color check
000006F0                            		
000006F0                            .FadeLoop:
000006F0                            		rept	2
000006F0                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
000006F0                            			bsr.w	VSync_Routine		; Do V-SYNC
000006F0                            		endr
000006F0 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000006F6 6100 0000                M 	bsr.w	vsync_routine
000006FA 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000700 6100 0000                M 	bsr.w	vsync_routine
00000704 6100                       		bsr.s	FadeFromWhite_Once		; Fade the colors once
00000706 5404                       		addq.b	#2,d4				; Decrement color check
00000708 0C04 000E                  		cmpi.b	#$E,d4				; Are we done?
0000070C 66E2                       		bne.s	.FadeLoop			; If not, branch
0000070E                            
0000070E 11FC 000A C747             		move.b	#vFade,vIntRoutine.w		; Set V-INT routine
00000714 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
00000718                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000718                            FadeFromWhite_Once:
00000718 7000                       		moveq	#0,d0
0000071A 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
0000071E 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
00000722 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000726 D0C0                       		adda.w	d0,a0				; ''
00000728 D2C0                       		adda.w	d0,a1				; ''
0000072A 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000072E                            
0000072E                            .FadeLoop:
0000072E 6100                       		bsr.s	.FadeColor			; Fade a color			
00000730 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000734                            
00000734 7000                       		moveq	#0,d0
00000736 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000073A 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
0000073E 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000742 D0C0                       		adda.w	d0,a0				; ''
00000744 D2C0                       		adda.w	d0,a1				; ''
00000746 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000074A                            
0000074A                            .FadeLoopWater:
0000074A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000074C 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000750 4E75                       		rts
00000752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000752                            .FadeColor:
00000752 1A11                       		move.b	(a1),d5				; Load blue
00000754 3219                       		move.w	(a1)+,d1			; Load green and red
00000756 1401                       		move.b	d1,d2				; Load red
00000758 E809                       		lsr.b	#4,d1				; Get only green
0000075A 0202 000E                  		andi.b	#$E,d2				; Get only red
0000075E                            
0000075E 3610                       		move.w	(a0),d3				; Load current color
00000760 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000762 6500                       		bcs.s	.NoBlue				; If not, branch
00000764 0443 0200                  		subi.w	#$200,d3			; Decrease blue
00000768                            
00000768                            .NoBlue:
00000768 B801                       		cmp.b	d1,d4				; Should the green fade?
0000076A 6500                       		bcs.s	.NoGreen			; If not, branch
0000076C 0443 0020                  		subi.w	#$20,d3				; Decrease green
00000770                            
00000770                            .NoGreen:
00000770 B802                       		cmp.b	d2,d4				; Should the red fade?
00000772 6500                       		bcs.s	.NoRed				; If not, branch
00000774 5543                       		subq.w	#2,d3				; Decrease red
00000776                            
00000776                            .NoRed:
00000776 30C3                       		move.w	d3,(a0)+			; Save the color
00000778 4E75                       		rts
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; Fade the palette from the current palette to the target palette
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; PARAMETERS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; RETURNS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            FadeToPalette:
0000077A 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000780                            
00000780                            FadeToPalette_Custom:
00000780 7000                       		moveq	#0,d0
00000782 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000786 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
0000078A D0C0                       		adda.w	d0,a0				; ''
0000078C                            
0000078C 7807                       		moveq	#7,d4				; Set repeat times
0000078E                            
0000078E                            .FadeLoop:
0000078E                            		rept	2
0000078E                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
0000078E                            			bsr.w	VSync_Routine		; Do V-SYNC
0000078E                            		endr
0000078E 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000794 6100 0000                M 	bsr.w	vsync_routine
00000798 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000079E 6100 0000                M 	bsr.w	vsync_routine
000007A2 6100                       		bsr.s	FadeToPalette_Once		; Fade the colors once
000007A4 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
000007A8 4E75                       		rts
000007AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007AA                            FadeToPalette_Once:
000007AA 7000                       		moveq	#0,d0
000007AC 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
000007B0 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
000007B4 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000007B8 D0C0                       		adda.w	d0,a0				; ''
000007BA D2C0                       		adda.w	d0,a1				; ''
000007BC 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000007C0                            
000007C0                            .FadeLoop:
000007C0 6100                       		bsr.s	.FadeColor			; Fade a color			
000007C2 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
000007C6                            
000007C6 7000                       		moveq	#0,d0
000007C8 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
000007CC 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
000007D0 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000007D4 D0C0                       		adda.w	d0,a0				; ''
000007D6 D2C0                       		adda.w	d0,a1				; ''
000007D8 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000007DC                            
000007DC                            .FadeLoopWater:
000007DC 6100                       		bsr.s	.FadeColor			; Fade a color			
000007DE 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000007E2 4E75                       		rts
000007E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E4                            .FadeColor:
000007E4 3610                       		move.w	(a0),d3				; Get color
000007E6 B659                       		cmp.w	(a1)+,d3			; Has the color already reached the target color?
000007E8 6700                       		beq.s	.NoRed				; If so, branch
000007EA                            		
000007EA 3229 FFFE                  		move.w	-2(a1),d1			; Get green and red
000007EE 1401                       		move.b	d1,d2				; Get red only
000007F0 0202 000E                  		andi.b	#$E,d2				; ''
000007F4 E809                       		lsr.b	#4,d1				; Get green only
000007F6                            
000007F6 1A29 FFFE                  		move.b	-2(a1),d5			; Get blue
000007FA BA10                       		cmp.b	(a0),d5				; Does blue need to fade?
000007FC 6700                       		beq.s	.NoBlue				; If not, branch
000007FE 6500                       		bcs.s	.DecBlue			; If it needs to be decreased, branch
00000800 0643 0200                  		addi.w	#$200,d3			; Increase blue
00000804 6000                       		bra.s	.NoBlue				; Continue
00000806                            
00000806                            .DecBlue:
00000806 0443 0200                  		subi.w	#$200,d3			; Decrease blue
0000080A                            
0000080A                            .NoBlue:
0000080A 3A10                       		move.w	(a0),d5				; Get green
0000080C E80D                       		lsr.b	#4,d5				; ''
0000080E B205                       		cmp.b	d5,d1				; Does green need to fade?
00000810 6700                       		beq.s	.NoGreen			; If not, branch
00000812 6500                       		bcs.s	.DecGreen			; If it needs to be decreased, branch
00000814 0603 0020                  		addi.b	#$20,d3				; Increase green
00000818 6000                       		bra.s	.NoGreen			; Continue
0000081A                            
0000081A                            .DecGreen:
0000081A 0403 0020                  		subi.b	#$20,d3				; Decrease green
0000081E                            
0000081E                            .NoGreen:
0000081E 3A10                       		move.w	(a0),d5				; Get red
00000820 0205 000E                  		andi.b	#$E,d5				; ''
00000824 B405                       		cmp.b	d5,d2				; Does red need to fade?
00000826 6700                       		beq.s	.NoRed				; If not, branch
00000828 6500                       		bcs.s	.DecRed				; If it needs to be decreased, branch
0000082A 5403                       		addq.b	#2,d3				; Increase red
0000082C 6000                       		bra.s	.NoRed				; Continue
0000082E                            
0000082E                            .DecRed:
0000082E 5503                       		subq.b	#2,d3				; Decrease red
00000830                            
00000830                            .NoRed:
00000830 30C3                       		move.w	d3,(a0)+			; Save new color
00000832 4E75                       		rts
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            ; Initialize the sprite table
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            InitSpriteTable:
00000834 7000                       		moveq	#0,d0
00000836 41F8 94CE                  		lea	spriteBuff.w,a0			; Sprite table buffer
0000083A 7201                       		moveq	#1,d1				; Link value
0000083C 7E4F                       		moveq	#($280/8)-1,d7			; Number of sprites
0000083E                            
0000083E                            .Loop:
0000083E 3080                       		move.w	d0,(a0)				; Move off screen
00000840 1141 0003                  		move.b	d1,3(a0)			; Set link value
00000844 5241                       		addq.w	#1,d1				; Increment link value
00000846 5048                       		addq.w	#8,a0				; Next sprite
00000848 51CF FFF4                  		dbf	d7,.Loop			; Loop
0000084C 1140 FFFB                  		move.b	d0,-5(a0)			; Set final link value to 0
00000850 4E75                       		rts
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; Draw the sprites from mappings
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; PARAMETERS:
00000852                            ;	d0.w	- X position
00000852                            ;	d1.w	- Y position
00000852                            ;	d4.w	- Number of sprites to draw
00000852                            ;	d5.w	- Sprite tile properties
00000852                            ;	d6.b	- Render flags
00000852                            ;	d7.w	- Max number of sprites left to draw
00000852                            ;	a1.l	- Mappings frame data
00000852                            ;	a6.l	- Sprite table buffer
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; RETURNS:
00000852                            ;	Nothing
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            DrawSprite:
00000852 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000854 6500                       		bcs.s	DrawSprite_FlipX		; If so, branch
00000856 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
00000858 6500 0000                  		bcs.w	DrawSprite_FlipY		; If so, branch
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            ; Draw the sprites from mappings with no flip checks
0000085C                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            DrawSprite_Loop:
0000085C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000085E 4882                       		ext.w	d2				; ''
00000860 D441                       		add.w	d1,d2				; Add onto Y position
00000862 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000864 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000866 524E                       		addq.w	#1,a6				; Skip link data
00000868 3419                       		move.w	(a1)+,d2			; Get tile properties
0000086A D445                       		add.w	d5,d2				; Add base tile properties
0000086C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000086E 3419                       		move.w	(a1)+,d2			; Get X offset
00000870 D440                       		add.w	d0,d2				; Add onto X position
00000872 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000874 5347                       		subq.w	#1,d7				; Decrement sprite count
00000876 5BCC FFE4                  		dbmi	d4,DrawSprite_Loop		; Loop if there are still enough sprites left
0000087A                            		
0000087A                            DrawSprite_End:
0000087A 4E75                       		rts
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            ; Draw the sprites from mappings, horizontally flipped
0000087C                            ; (Parameters inherited from DrawSprite)
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            DrawSprite_FlipX:
0000087C E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000087E 6500                       		bcs.s	DrawSprite_FlipXY		; If so, branch
00000880                            
00000880                            .Loop:
00000880 1419                       		move.b	(a1)+,d2			; Get Y offset
00000882 4882                       		ext.w	d2				; ''
00000884 D441                       		add.w	d1,d2				; Add onto Y position
00000886 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000888 1C19                       		move.b	(a1)+,d6			; Get sprite size
0000088A 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
0000088C 524E                       		addq.w	#1,a6				; Skip link data
0000088E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000890 D445                       		add.w	d5,d2				; Add base tile properties
00000892 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
00000896 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000898 3419                       		move.w	(a1)+,d2			; Get X offset
0000089A 4442                       		neg.w	d2				; Negate it
0000089C 1C3B 6000                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008A0 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008A2 D440                       		add.w	d0,d2				; Add onto X position
000008A4 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008A6 5347                       		subq.w	#1,d7				; Decrement sprite count
000008A8 5BCC FFD6                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000008AC 4E75                       		rts
000008AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008AE                            DrawSprite_XFlipOff:
000008AE 0808 0808                  		dc.b	8, 8, 8, 8
000008B2 1010 1010                  		dc.b	$10, $10, $10, $10
000008B6 1818 1818                  		dc.b	$18, $18, $18, $18
000008BA 2020 2020                  		dc.b	$20, $20, $20, $20
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            ; Draw the sprites from mappings, horizontally and vertically flipped
000008BE                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            DrawSprite_FlipXY:
000008BE 1419                       		move.b	(a1)+,d2			; Get Y offset
000008C0 4882                       		ext.w	d2				; ''
000008C2 4442                       		neg.w	d2				; Negate it
000008C4 1C11                       		move.b	(a1),d6				; Get sprite sizes
000008C6 1C3B 6000                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
000008CA 9446                       		sub.w	d6,d2				; Subtract from the Y offset
000008CC D441                       		add.w	d1,d2				; Add onto Y position
000008CE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008D0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000008D2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000008D4 524E                       		addq.w	#1,a6				; Skip link data
000008D6 3419                       		move.w	(a1)+,d2			; Get tile properties
000008D8 D445                       		add.w	d5,d2				; Add base tile properties
000008DA 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
000008DE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008E0 3419                       		move.w	(a1)+,d2			; Get X offset
000008E2 4442                       		neg.w	d2				; Negate it
000008E4 1C3B 60C8                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008E8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008EA D440                       		add.w	d0,d2				; Add onto X position
000008EC 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008EE 5347                       		subq.w	#1,d7				; Decrement sprite count
000008F0 5BCC FFCC                  		dbmi	d4,DrawSprite_FlipXY		; Loop if there are still enough sprites left
000008F4 4E75                       		rts
000008F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008F6                            DrawSprite_YFlipOff:
000008F6 0810 1820                  		dc.b	8, $10, $18, $20
000008FA 0810 1820                  		dc.b	8, $10, $18, $20
000008FE 0810 1820                  		dc.b	8, $10, $18, $20
00000902 0810 1820                  		dc.b	8, $10, $18, $20
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            ; Draw the sprites from mappings, vertically flipped
00000906                            ; (Parameters inherited from DrawSprite)
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            DrawSprite_FlipY:
00000906 1419                       		move.b	(a1)+,d2			; Get Y offset
00000908 4882                       		ext.w	d2				; ''
0000090A 4442                       		neg.w	d2				; Negate it
0000090C 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
0000090E 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000912 1C3B 60E2                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
00000916 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000918 D441                       		add.w	d1,d2				; Add onto Y position
0000091A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000091C 544E                       		addq.w	#2,a6				; Skip link data
0000091E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000920 D445                       		add.w	d5,d2				; Add base tile properties
00000922 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000926 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000928 3419                       		move.w	(a1)+,d2			; Get X offset
0000092A D440                       		add.w	d0,d2				; Add onto X position
0000092C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000092E 5347                       		subq.w	#1,d7				; Decrement sprite count
00000930 5BCC FFD4                  		dbmi	d4,DrawSprite_FlipY		; Loop if there are still enough sprites left
00000934 4E75                       		rts
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; Draw the sprites from mappings (with boundary checks)
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; PARAMETERS:
00000936                            ;	d0.w	- X position
00000936                            ;	d1.w	- Y position
00000936                            ;	d4.w	- Number of sprites to draw
00000936                            ;	d5.w	- Sprite tile properties
00000936                            ;	d6.b	- Render flags
00000936                            ;	d7.w	- Max number of sprites left to draw
00000936                            ;	a1.l	- Mappings frame data
00000936                            ;	a6.l	- Sprite table buffer
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; RETURNS:
00000936                            ;	Nothing
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            DrawSprite_BoundChk:
00000936 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000938 6500                       		bcs.s	DrawSprite_BndChk_FlipX		; If so, branch
0000093A E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000093C 6500 0000                  		bcs.w	DrawSprite_BndChk_FlipY		; If so, branch
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            ; Draw the sprites from mappings (with boundary checks) with no flip checks
00000940                            ; (Parameters inherited from DrawSprite_BoundChk, minus d6, a.k.a. render flags)
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            DrawSprBndChk_Loop:
00000940 1419                       		move.b	(a1)+,d2			; Get Y offset
00000942 4882                       		ext.w	d2				; ''
00000944 D441                       		add.w	d1,d2				; Add onto Y position
00000946 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000094A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000094C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000950 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000952 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000954 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000956 524E                       		addq.w	#1,a6				; Skip link data
00000958 3419                       		move.w	(a1)+,d2			; Get tile properties
0000095A D445                       		add.w	d5,d2				; Add base tile properties
0000095C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000095E 3419                       		move.w	(a1)+,d2			; Get X offset
00000960 D440                       		add.w	d0,d2				; Add onto X position
00000962 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000966 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000968 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
0000096C 6400                       		bhs.s	.Next_XOffScr			; If so, branch
0000096E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000970 5347                       		subq.w	#1,d7				; Decrement sprite count
00000972 5BCC FFCC                  		dbmi	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000976 4E75                       		rts
00000978                            
00000978                            .Next_XOffScr:
00000978 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
0000097A 51CC FFC4                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
0000097E 4E75                       		rts
00000980                            
00000980                            .Next_YOffScr:
00000980 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings in the mappings
00000982 51CC FFBC                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000986 4E75                       		rts
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            ; Draw the sprites from mappings (with boundary checks), horizontally flipped
00000988                            ; (Parameters inherited from DrawSprite_BoundChk)
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            DrawSprite_BndChk_FlipX:
00000988 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000098A 6500                       		bcs.s	DrawSprite_BndChk_FlipXY	; If so, branch
0000098C                            
0000098C                            .Loop:
0000098C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000098E 4882                       		ext.w	d2				; ''
00000990 D441                       		add.w	d1,d2				; Add onto Y position
00000992 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000996 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000998 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
0000099C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
0000099E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009A0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000009A2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000009A4 524E                       		addq.w	#1,a6				; Skip link data
000009A6 3419                       		move.w	(a1)+,d2			; Get tile properties
000009A8 D445                       		add.w	d5,d2				; Add base tile properties
000009AA 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
000009AE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009B0 3419                       		move.w	(a1)+,d2			; Get X offset
000009B2 4442                       		neg.w	d2				; Negate it
000009B4 1C3B 6000                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
000009B8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000009BA D440                       		add.w	d0,d2				; Add onto X position
000009BC 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000009C0 6300                       		bls.s	.Next_XOffScr			; If so, branch
000009C2 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000009C6 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000009C8 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009CA 5347                       		subq.w	#1,d7				; Decrement sprite count
000009CC 5BCC FFBE                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000009D0 4E75                       		rts
000009D2                            
000009D2                            .Next_XOffScr:
000009D2 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000009D4 51CC FFB6                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009D8 4E75                       		rts
000009DA                            
000009DA                            .Next_YOffScr:
000009DA 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
000009DC 51CC FFAE                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009E0 4E75                       		rts
000009E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E2                            DrwSprBndChk_XFlips:
000009E2 0808 0808                  		dc.b	8, 8, 8, 8
000009E6 1010 1010                  		dc.b	$10, $10, $10, $10
000009EA 1818 1818                  		dc.b	$18, $18, $18, $18
000009EE 2020 2020                  		dc.b	$20, $20, $20, $20
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            ; Draw the sprites from mappings (with boundary checks), horizontally and vertically flipped
000009F2                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            DrawSprite_BndChk_FlipXY:
000009F2 1419                       		move.b	(a1)+,d2			; Get Y offset
000009F4 4882                       		ext.w	d2				; ''
000009F6 4442                       		neg.w	d2				; Negate it
000009F8 1C11                       		move.b	(a1),d6				; Get sprite sizes
000009FA 1C3B 6000                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
000009FE 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A00 D441                       		add.w	d1,d2				; Add onto Y position
00000A02 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A06 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A08 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A0C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A0E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A10 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000A12 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000A14 524E                       		addq.w	#1,a6				; Skip link data
00000A16 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A18 D445                       		add.w	d5,d2				; Add base tile properties
00000A1A 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
00000A1E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A20 3419                       		move.w	(a1)+,d2			; Get X offset
00000A22 4442                       		neg.w	d2				; Negate it
00000A24 1C3B 60BC                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
00000A28 9446                       		sub.w	d6,d2				; Subtract the new X offset
00000A2A D440                       		add.w	d0,d2				; Add onto X position
00000A2C 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A30 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A32 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A36 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000A38 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A3A 5347                       		subq.w	#1,d7				; Decrement sprite count
00000A3C 5BCC FFB4                  		dbmi	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A40 4E75                       		rts
00000A42                            
00000A42                            .Next_XOffScr:
00000A42 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000A44 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A48 4E75                       		rts
00000A4A                            
00000A4A                            .Next_YOffScr:
00000A4A 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000A4C 51CC FFA4                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A50 4E75                       		rts
00000A52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A52                            DrwSprBndChk_YFlips:
00000A52 0810 1820                  		dc.b	8, $10, $18, $20
00000A56 0810 1820                  		dc.b	8, $10, $18, $20
00000A5A 0810 1820                  		dc.b	8, $10, $18, $20
00000A5E 0810 1820                  		dc.b	8, $10, $18, $20
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            ; Draw the sprites from mappings (with boundary checks), vertically flipped
00000A62                            ; (Parameters inherited from DrawSprite_BoundChk)
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            DrawSprite_BndChk_FlipY:
00000A62 1419                       		move.b	(a1)+,d2			; Get Y offset
00000A64 4882                       		ext.w	d2				; ''
00000A66 4442                       		neg.w	d2				; Negate it
00000A68 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
00000A6A 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000A6E 1C3B 60E2                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
00000A72 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A74 D441                       		add.w	d1,d2				; Add onto Y position
00000A76 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A7A 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A7C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A80 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A82 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A84 544E                       		addq.w	#2,a6				; Skip link data
00000A86 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A88 D445                       		add.w	d5,d2				; Add base tile properties
00000A8A 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000A8E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A90 3419                       		move.w	(a1)+,d2			; Get X offset
00000A92 D440                       		add.w	d0,d2				; Add onto X position
00000A94 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A98 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A9A 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A9E 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000AA0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000AA2 5347                       		subq.w	#1,d7				; Decrement sprite count
00000AA4 5BCC FFBC                  		dbmi	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AA8 4E75                       		rts
00000AAA                            
00000AAA                            .Next_XOffScr:
00000AAA 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000AAC 51CC FFB4                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB0 4E75                       		rts
00000AB2                            
00000AB2                            .Next_YOffScr:
00000AB2 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000AB4 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB8 4E75                       		rts
00000ABA                            ; =========================================================================================================================================================
00000ABA                            		include	"Libraries/Joypad.asm"		; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; Read joypad input
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; PARAMETERS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; RETURNS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ReadJoypads:
00000ABA 41F8 C742                  	lea	ctrlDataP1.w,a0			; 8	; load RAM space for joypad data
00000ABE 43F9 00A1 0002             	lea	PORT_A_DATA-1,a1		; 12	; load I/O data port A
00000AC4 7000                       	moveq	#%00000000,d0			; 4	; prepare TH = 0 request value
00000AC6 7240                       	moveq	#%01000000,d1			; 4	; prepare TH = 1 request value
00000AC8                            
00000AC8                            	; Repeat the following twice to
00000AC8                            	; collect input from both pads
00000AC8                            	rept	2
00000AC8                            		move.w	d0,(a1)			; 8	; set TH = 0 (burn 8 cycles to wait for returned data by setting up bitmasks below)
00000AC8                            		moveq	#%00110000,d2		; 4	; button bitmask mask for TH = 0
00000AC8                            		moveq	#%00111111,d3		; 4	; button bitmask for TH = 1
00000AC8                            		and.w	(a1),d2			; 8	; collect current button data for TH = 0 (A and Start)
00000AC8                            		move.w	d1,(a1)			; 8	; set TH = 1 (burn 8 cycles again below to wait)
00000AC8                            		add.b	d2,d2			; 4	; shift TH = 0 button bits to the left by two
00000AC8                            		add.b	d2,d2			; 4	; (A and start will be bits $6 and $7 in saved data)
00000AC8                            		and.w	(a1)+,d3		; 8	; collect current button data for TH = 1 (Up, Down, Left, Right, B, and C)
00000AC8                            		or.b	d3,d2			; 4	; combine collected button bits
00000AC8                            		not.b	d2			; 4	; flip bits (now pressed = 1 and not pressed = 0)
00000AC8                            		move.b	(a0),d3			; 8	; d3 = last collected button data
00000AC8                            		eor.b	d2,d3			; 4	; remove any currently pressed buttons from d3
00000AC8                            		move.b	d2,(a0)+		; 8	; save d2 (current button presses) as current held buttons
00000AC8                            		and.b	d2,d3			; 4	; limit d3 (pressed buttons) to only include current buttons
00000AC8                            		move.b	d3,(a0)+		; 8	; save all pressed buttons for this frame
00000AC8                            	endr
00000AC8 3280                     M 	move.w	d0,(a1)
00000ACA 7430                     M 	moveq	#%00110000,d2
00000ACC 763F                     M 	moveq	#%00111111,d3
00000ACE C451                     M 	and.w	(a1),d2
00000AD0 3281                     M 	move.w	d1,(a1)
00000AD2 D402                     M 	add.b	d2,d2
00000AD4 D402                     M 	add.b	d2,d2
00000AD6 C659                     M 	and.w	(a1)+,d3
00000AD8 8403                     M 	or.b	d3,d2
00000ADA 4602                     M 	not.b	d2
00000ADC 1610                     M 	move.b	(a0),d3
00000ADE B503                     M 	eor.b	d2,d3
00000AE0 10C2                     M 	move.b	d2,(a0)+
00000AE2 C602                     M 	and.b	d2,d3
00000AE4 10C3                     M 	move.b	d3,(a0)+
00000AE6 3280                     M 	move.w	d0,(a1)
00000AE8 7430                     M 	moveq	#%00110000,d2
00000AEA 763F                     M 	moveq	#%00111111,d3
00000AEC C451                     M 	and.w	(a1),d2
00000AEE 3281                     M 	move.w	d1,(a1)
00000AF0 D402                     M 	add.b	d2,d2
00000AF2 D402                     M 	add.b	d2,d2
00000AF4 C659                     M 	and.w	(a1)+,d3
00000AF6 8403                     M 	or.b	d3,d2
00000AF8 4602                     M 	not.b	d2
00000AFA 1610                     M 	move.b	(a0),d3
00000AFC B503                     M 	eor.b	d2,d3
00000AFE 10C2                     M 	move.b	d2,(a0)+
00000B00 C602                     M 	and.b	d2,d3
00000B02 10C3                     M 	move.b	d3,(a0)+
00000B04                            
00000B04 4E75                       	rts					; 16	; return
00000B06                            
00000B06                            ; =========================================================================================================================================================
00000B06                            		include	"Libraries/Decompression.asm"	; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; Kosinski decompression (General purpose)
00000B06                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; PARAMETERS:
00000B06                            ;	a0.l	- Source address
00000B06                            ;	a1.l	- Destination address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; RETURNS:
00000B06                            ;	a1.l	- End of decompressed data address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06 =00000001                  _Kos_UseLUT			equ	1
00000B06 =00000003                  _Kos_LoopUnroll			equ	3
00000B06 =00000001                  _Kos_ExtremeUnrolling		equ	1
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_RunBitStream macro
00000B06                            		dbra	d2,.skip\@
00000B06                            		moveq	#7,d2				; Set repeat count to 8.
00000B06                            		move.b	d1,d0				; Use the remaining 8 bits.
00000B06                            		not.w	d3				; Have all 16 bits been used up?
00000B06                            		bne.s	.skip\@				; Branch if not.
00000B06                            		move.b	(a0)+,d0			; Get desc field low-byte.
00000B06                            		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B06                            	if _Kos_UseLUT=1
00000B06                            		move.b	(a4,d0.w),d0			; Invert bit order...
00000B06                            		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B06                            	endif
00000B06                            .skip\@:
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_ReadBit macro
00000B06                            	if _Kos_UseLUT=1
00000B06                            		add.b	d0,d0				; Get a bit from the bitstream.
00000B06                            	else
00000B06                            		lsr.b	#1,d0				; Get a bit from the bitstream.
00000B06                            	endif
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            KosDec:
00000B06 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00000B08 7000                       		moveq	#0,d0
00000B0A 7200                       		moveq	#0,d1
00000B0C 49FA 0000                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00000B10 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00000B12 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B14 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
00000B18 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B1C 7407                       		moveq	#7,d2				; Set repeat count to 8.
00000B1E 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00000B20 6000                       		bra.s	.FetchNewCode
00000B22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B22                            .FetchCodeLoop:
00000B22                            		; Code 1 (Uncompressed byte).
00000B22                            		_Kos_RunBitStream
00000B22 51CA 0000                M 	dbra	d2,.skip_30
00000B26 7407                     M 	moveq	#7,d2
00000B28 1001                     M 	move.b	d1,d0
00000B2A 4643                     M 	not.w	d3
00000B2C 6600                     M 	bne.s	.skip_30
00000B2E 1018                     M 	move.b	(a0)+,d0
00000B30 1218                     M 	move.b	(a0)+,d1
00000B32 1034 0000                M 	move.b	(a4,d0.w),d0
00000B36 1234 1000                M 	move.b	(a4,d1.w),d1
00000B3A                          M .skip_30:
00000B3A 12D8                       		move.b	(a0)+,(a1)+
00000B3C                             
00000B3C                            .FetchNewCode:
00000B3C                            		_Kos_ReadBit
00000B3C D000                     M 	add.b	d0,d0
00000B3E 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00000B40                             
00000B40                            		; Codes 00 and 01.
00000B40 7AFF                       		moveq	#-1,d5
00000B42 4BD1                       		lea	(a1),a5
00000B44                            		_Kos_RunBitStream
00000B44 51CA 0000                M 	dbra	d2,.skip_32
00000B48 7407                     M 	moveq	#7,d2
00000B4A 1001                     M 	move.b	d1,d0
00000B4C 4643                     M 	not.w	d3
00000B4E 6600                     M 	bne.s	.skip_32
00000B50 1018                     M 	move.b	(a0)+,d0
00000B52 1218                     M 	move.b	(a0)+,d1
00000B54 1034 0000                M 	move.b	(a4,d0.w),d0
00000B58 1234 1000                M 	move.b	(a4,d1.w),d1
00000B5C                          M .skip_32:
00000B5C                            		_Kos_ReadBit
00000B5C D000                     M 	add.b	d0,d0
00000B5E 6500 0000                  		bcs.w	.Code_01
00000B62                             
00000B62                            		; Code 00 (Dictionary ref. short).
00000B62                            		_Kos_RunBitStream
00000B62 51CA 0000                M 	dbra	d2,.skip_34
00000B66 7407                     M 	moveq	#7,d2
00000B68 1001                     M 	move.b	d1,d0
00000B6A 4643                     M 	not.w	d3
00000B6C 6600                     M 	bne.s	.skip_34
00000B6E 1018                     M 	move.b	(a0)+,d0
00000B70 1218                     M 	move.b	(a0)+,d1
00000B72 1034 0000                M 	move.b	(a4,d0.w),d0
00000B76 1234 1000                M 	move.b	(a4,d1.w),d1
00000B7A                          M .skip_34:
00000B7A                            		_Kos_ReadBit
00000B7A D000                     M 	add.b	d0,d0
00000B7C 6500                       		bcs.s	.Copy45
00000B7E                            		_Kos_RunBitStream
00000B7E 51CA 0000                M 	dbra	d2,.skip_36
00000B82 7407                     M 	moveq	#7,d2
00000B84 1001                     M 	move.b	d1,d0
00000B86 4643                     M 	not.w	d3
00000B88 6600                     M 	bne.s	.skip_36
00000B8A 1018                     M 	move.b	(a0)+,d0
00000B8C 1218                     M 	move.b	(a0)+,d1
00000B8E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B92 1234 1000                M 	move.b	(a4,d1.w),d1
00000B96                          M .skip_36:
00000B96                            		_Kos_ReadBit
00000B96 D000                     M 	add.b	d0,d0
00000B98 6500                       		bcs.s	.Copy3
00000B9A                            		_Kos_RunBitStream
00000B9A 51CA 0000                M 	dbra	d2,.skip_38
00000B9E 7407                     M 	moveq	#7,d2
00000BA0 1001                     M 	move.b	d1,d0
00000BA2 4643                     M 	not.w	d3
00000BA4 6600                     M 	bne.s	.skip_38
00000BA6 1018                     M 	move.b	(a0)+,d0
00000BA8 1218                     M 	move.b	(a0)+,d1
00000BAA 1034 0000                M 	move.b	(a4,d0.w),d0
00000BAE 1234 1000                M 	move.b	(a4,d1.w),d1
00000BB2                          M .skip_38:
00000BB2 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BB4 DAC5                       		adda.w	d5,a5
00000BB6 12DD                       		move.b	(a5)+,(a1)+
00000BB8 12DD                       		move.b	(a5)+,(a1)+
00000BBA 6080                       		bra.s	.FetchNewCode
00000BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BBC                            .Copy3:
00000BBC                            		_Kos_RunBitStream
00000BBC 51CA 0000                M 	dbra	d2,.skip_39
00000BC0 7407                     M 	moveq	#7,d2
00000BC2 1001                     M 	move.b	d1,d0
00000BC4 4643                     M 	not.w	d3
00000BC6 6600                     M 	bne.s	.skip_39
00000BC8 1018                     M 	move.b	(a0)+,d0
00000BCA 1218                     M 	move.b	(a0)+,d1
00000BCC 1034 0000                M 	move.b	(a4,d0.w),d0
00000BD0 1234 1000                M 	move.b	(a4,d1.w),d1
00000BD4                          M .skip_39:
00000BD4 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BD6 DAC5                       		adda.w	d5,a5
00000BD8 12DD                       		move.b	(a5)+,(a1)+
00000BDA 12DD                       		move.b	(a5)+,(a1)+
00000BDC 12DD                       		move.b	(a5)+,(a1)+
00000BDE 6000 FF5C                  		bra.w	.FetchNewCode
00000BE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE2                            .Copy45:
00000BE2                            		_Kos_RunBitStream
00000BE2 51CA 0000                M 	dbra	d2,.skip_40
00000BE6 7407                     M 	moveq	#7,d2
00000BE8 1001                     M 	move.b	d1,d0
00000BEA 4643                     M 	not.w	d3
00000BEC 6600                     M 	bne.s	.skip_40
00000BEE 1018                     M 	move.b	(a0)+,d0
00000BF0 1218                     M 	move.b	(a0)+,d1
00000BF2 1034 0000                M 	move.b	(a4,d0.w),d0
00000BF6 1234 1000                M 	move.b	(a4,d1.w),d1
00000BFA                          M .skip_40:
00000BFA                            		_Kos_ReadBit
00000BFA D000                     M 	add.b	d0,d0
00000BFC 6500                       		bcs.s	.Copy5
00000BFE                            		_Kos_RunBitStream
00000BFE 51CA 0000                M 	dbra	d2,.skip_42
00000C02 7407                     M 	moveq	#7,d2
00000C04 1001                     M 	move.b	d1,d0
00000C06 4643                     M 	not.w	d3
00000C08 6600                     M 	bne.s	.skip_42
00000C0A 1018                     M 	move.b	(a0)+,d0
00000C0C 1218                     M 	move.b	(a0)+,d1
00000C0E 1034 0000                M 	move.b	(a4,d0.w),d0
00000C12 1234 1000                M 	move.b	(a4,d1.w),d1
00000C16                          M .skip_42:
00000C16 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C18 DAC5                       		adda.w	d5,a5
00000C1A 12DD                       		move.b	(a5)+,(a1)+
00000C1C 12DD                       		move.b	(a5)+,(a1)+
00000C1E 12DD                       		move.b	(a5)+,(a1)+
00000C20 12DD                       		move.b	(a5)+,(a1)+
00000C22 6000 FF18                  		bra.w	.FetchNewCode
00000C26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C26                            .Copy5:
00000C26                            		_Kos_RunBitStream
00000C26 51CA 0000                M 	dbra	d2,.skip_43
00000C2A 7407                     M 	moveq	#7,d2
00000C2C 1001                     M 	move.b	d1,d0
00000C2E 4643                     M 	not.w	d3
00000C30 6600                     M 	bne.s	.skip_43
00000C32 1018                     M 	move.b	(a0)+,d0
00000C34 1218                     M 	move.b	(a0)+,d1
00000C36 1034 0000                M 	move.b	(a4,d0.w),d0
00000C3A 1234 1000                M 	move.b	(a4,d1.w),d1
00000C3E                          M .skip_43:
00000C3E 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C40 DAC5                       		adda.w	d5,a5
00000C42 12DD                       		move.b	(a5)+,(a1)+
00000C44 12DD                       		move.b	(a5)+,(a1)+
00000C46 12DD                       		move.b	(a5)+,(a1)+
00000C48 12DD                       		move.b	(a5)+,(a1)+
00000C4A 12DD                       		move.b	(a5)+,(a1)+
00000C4C 6000 FEEE                  		bra.w	.FetchNewCode
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            .Code_01:
00000C50 7800                       		moveq	#0,d4				; d4 will contain copy count.
00000C52                            		; Code 01 (Dictionary ref. long / special).
00000C52                            		_Kos_RunBitStream
00000C52 51CA 0000                M 	dbra	d2,.skip_44
00000C56 7407                     M 	moveq	#7,d2
00000C58 1001                     M 	move.b	d1,d0
00000C5A 4643                     M 	not.w	d3
00000C5C 6600                     M 	bne.s	.skip_44
00000C5E 1018                     M 	move.b	(a0)+,d0
00000C60 1218                     M 	move.b	(a0)+,d1
00000C62 1034 0000                M 	move.b	(a4,d0.w),d0
00000C66 1234 1000                M 	move.b	(a4,d1.w),d1
00000C6A                          M .skip_44:
00000C6A 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00000C6C 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00000C6E 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00000C70 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00000C72 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
00000C74 C847                       		and.w	d7,d4				; d4 = %00000CCC.
00000C76 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00000C78                             
00000C78                            		; special mode (extended counter)
00000C78 1818                       		move.b	(a0)+,d4			; Read cnt
00000C7A 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00000C7C 5304                       		subq.b	#1,d4
00000C7E 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00000C82                             
00000C82 DAC5                       		adda.w	d5,a5
00000C84 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C86 3C04                       		move.w	d4,d6
00000C88 4646                       		not.w	d6
00000C8A CC47                       		and.w	d7,d6
00000C8C DC46                       		add.w	d6,d6
00000C8E E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00000C90 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
00000C94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C94                            .LargeCopy:
00000C94                            	rept (1<<_Kos_LoopUnroll)
00000C94                            		move.b	(a5)+,(a1)+
00000C94                            	endr
00000C94 12DD                     M 	move.b	(a5)+,(a1)+
00000C96 12DD                     M 	move.b	(a5)+,(a1)+
00000C98 12DD                     M 	move.b	(a5)+,(a1)+
00000C9A 12DD                     M 	move.b	(a5)+,(a1)+
00000C9C 12DD                     M 	move.b	(a5)+,(a1)+
00000C9E 12DD                     M 	move.b	(a5)+,(a1)+
00000CA0 12DD                     M 	move.b	(a5)+,(a1)+
00000CA2 12DD                     M 	move.b	(a5)+,(a1)+
00000CA4 51CC FFEE                  		dbra	d4,.LargeCopy
00000CA8 6000 FE92                  		bra.w	.FetchNewCode
00000CAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CAC                            .StreamCopy:
00000CAC DAC5                       		adda.w	d5,a5
00000CAE 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000CB0 BF44                       		eor.w	d7,d4
00000CB2 D844                       		add.w	d4,d4
00000CB4 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00000CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CB8                            .MediumCopy:
00000CB8                            	rept 8
00000CB8                            		move.b	(a5)+,(a1)+
00000CB8                            	endr
00000CB8 12DD                     M 	move.b	(a5)+,(a1)+
00000CBA 12DD                     M 	move.b	(a5)+,(a1)+
00000CBC 12DD                     M 	move.b	(a5)+,(a1)+
00000CBE 12DD                     M 	move.b	(a5)+,(a1)+
00000CC0 12DD                     M 	move.b	(a5)+,(a1)+
00000CC2 12DD                     M 	move.b	(a5)+,(a1)+
00000CC4 12DD                     M 	move.b	(a5)+,(a1)+
00000CC6 12DD                     M 	move.b	(a5)+,(a1)+
00000CC8 6000 FE72                  		bra.w	.FetchNewCode
00000CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCC                            .Quit:
00000CCC 4E75                       		rts
00000CCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCE                            KosDec_ByteMap:
00000CCE 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00000CDE 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00000CEE 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00000CFE 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
00000D0E 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
00000D1E 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
00000D2E 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
00000D3E 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
00000D4E 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
00000D5E 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00000D6E 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00000D7E 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00000D8E 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00000D9E 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00000DAE 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00000DBE 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; Enigma decompression (Mainly for plane mappings)
00000DCE                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; PARAMETERS:
00000DCE                            ;	d0.w	- Base tile properties (tile ID, flags, etc.)
00000DCE                            ;	a0.l	- Source address
00000DCE                            ;	a1.l	- Destination address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; RETURNS:
00000DCE                            ;	a1.l	- End of decompressed data address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            EniDec:
00000DCE                            		push.l d0-d7/a1-a5
00000DCE 48E7 FF7C                M 	movem.l	d0-d7/a1-a5,-(sp)
00000DD2 3640                       		movea.w d0,a3				; Store base tile properties
00000DD4 1018                       		move.b	(a0)+,d0
00000DD6 4880                       		ext.w	d0
00000DD8 3A40                       		movea.w d0,a5				; Store first byte, extended to word
00000DDA 1818                       		move.b	(a0)+,d4			; Store second byte
00000DDC E70C                       		lsl.b	#3,d4				; Multiply by 8
00000DDE 3458                       		movea.w (a0)+,a2			; Store third and fourth byte
00000DE0 D4CB                       		adda.w	a3,a2				; Add base tile properties
00000DE2 3858                       		movea.w (a0)+,a4			; Store fifth and sixth byte
00000DE4 D8CB                       		adda.w	a3,a4				; Add base tile properties
00000DE6 1A18                       		move.b	(a0)+,d5			; Store seventh byte
00000DE8 E145                       		asl.w	#8,d5				; Shift up by a byte
00000DEA 1A18                       		move.b	(a0)+,d5			; Store eigth byte in lower register byte
00000DEC 7C10                       		moveq	#$10,d6				; 16 bits = 2 bytes
00000DEE                            
00000DEE                            EniDec_Loop:
00000DEE 7007                       		moveq	#7,d0				; Process 7 bits at a time
00000DF0 3E06                       		move.w	d6,d7
00000DF2 9E40                       		sub.w	d0,d7
00000DF4 3205                       		move.w	d5,d1
00000DF6 EE69                       		lsr.w	d7,d1
00000DF8 0241 007F                  		andi.w	#$7F,d1				; Keep only lower 7 bits
00000DFC 3401                       		move.w	d1,d2
00000DFE 0C41 0040                  		cmpi.w	#$40,d1				; Is Bit 6 set?
00000E02 6400                       		bcc.s	.getnext			; If so, branch
00000E04 7006                       		moveq	#6,d0				; If not, process 6 bits instead of 7
00000E06 E24A                       		lsr.w	#1,d2				; Bitfield now becomes TTSSSS isntead of TTTSSSS
00000E08                            
00000E08                            .getnext:
00000E08 6100 0000                  		bsr.w	EniDec_ChkGetNextByte
00000E0C 0242 000F                  		andi.w	#$F,d2				; Keep only lower nibble
00000E10 E849                       		lsr.w	#4,d1				; Store upper nibble (max value = 7)
00000E12 D241                       		add.w	d1,d1
00000E14 4EFB 1000                  		jmp	EniDec_JmpTable(pc,d1.w)
00000E18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E18                            EniDec_Sub0:
00000E18 32CA                       		move.w	a2,(a1)+			; Write to destination
00000E1A 524A                       		addq.w	#1,a2				; Increment
00000E1C 51CA FFFA                  		dbf	d2,EniDec_Sub0			; Repeat
00000E20 60CC                       		bra.s	EniDec_Loop
00000E22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E22                            EniDec_Sub4:
00000E22 32CC                       		move.w	a4,(a1)+			; Write to destination
00000E24 51CA FFFC                  		dbf	d2,EniDec_Sub4			; Repeat
00000E28 60C4                       		bra.s	EniDec_Loop
00000E2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E2A                            EniDec_Sub8:
00000E2A 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E2E                            
00000E2E                            .loop1:
00000E2E 32C1                       		move.w	d1,(a1)+
00000E30 51CA FFFC                  		dbf	d2,.loop1
00000E34 60B8                       		bra.s	EniDec_Loop
00000E36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E36                            EniDec_SubA:
00000E36 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E3A                            
00000E3A                            .loop2:
00000E3A 32C1                       		move.w	d1,(a1)+
00000E3C 5241                       		addq.w	#1,d1
00000E3E 51CA FFFA                  		dbf	d2,.loop2
00000E42 60AA                       		bra.s	EniDec_Loop
00000E44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E44                            EniDec_SubC:
00000E44 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E48                            
00000E48                            .loop3:
00000E48 32C1                       		move.w	d1,(a1)+
00000E4A 5341                       		subq.w	#1,d1
00000E4C 51CA FFFA                  		dbf	d2,.loop3
00000E50 609C                       		bra.s	EniDec_Loop
00000E52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E52                            EniDec_SubE:
00000E52 0C42 000F                  		cmpi.w	#$F,d2
00000E56 6700                       		beq.s	EniDec_End
00000E58                            
00000E58                            .loop4:
00000E58 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E5C 32C1                       		move.w	d1,(a1)+
00000E5E 51CA FFF8                  		dbf	d2,.loop4
00000E62 608A                       		bra.s	EniDec_Loop
00000E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E64                            EniDec_JmpTable:
00000E64 60B2                       		bra.s	EniDec_Sub0
00000E66 60B0                       		bra.s	EniDec_Sub0
00000E68 60B8                       		bra.s	EniDec_Sub4
00000E6A 60B6                       		bra.s	EniDec_Sub4
00000E6C 60BC                       		bra.s	EniDec_Sub8
00000E6E 60C6                       		bra.s	EniDec_SubA
00000E70 60D2                       		bra.s	EniDec_SubC
00000E72 60DE                       		bra.s	EniDec_SubE
00000E74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E74                            EniDec_End:
00000E74 5348                       		subq.w	#1,a0
00000E76 0C46 0010                  		cmpi.w	#16,d6				; Were we going to start on a completely new byte?
00000E7A 6600                       		bne.s	.norollback			; If not, branch
00000E7C 5348                       		subq.w	#1,a0
00000E7E                            
00000E7E                            .norollback:
00000E7E 3008                       		move.w	a0,d0
00000E80 E248                       		lsr.w	#1,d0				; Are we on an odd byte?
00000E82 6400                       		bcc.s	.evendest			; If not, branch
00000E84 5248                       		addq.w	#1,a0				; Ensure we're on an even byte
00000E86                            
00000E86                            .evendest:
00000E86                            		pop.l	d0-d7/a1-a5
00000E86 4CDF 3EFF                M 	movem.l	(sp)+,d0-d7/a1-a5
00000E8A 4E75                       		rts
00000E8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E8C                            EniDec_GetInlineCopyVal:
00000E8C 360B                       		move.w	a3,d3				; Store base tile properties
00000E8E 1204                       		move.b	d4,d1
00000E90 D201                       		add.b	d1,d1
00000E92 6400                       		bcc.s	.nopriority			; If d4 was < $80
00000E94 5346                       		subq.w	#1,d6				; Get next bit number
00000E96 0D05                       		btst	d6,d5				; Is the bit set?
00000E98 6700                       		beq.s	.nopriority			; If not, branch
00000E9A 0043 8000                  		ori.w	#(1<<15),d3			; Set high priority bit
00000E9E                            
00000E9E                            .nopriority:
00000E9E D201                       		add.b	d1,d1
00000EA0 6400                       		bcc.s	.nopal1				; If d4 < $40
00000EA2 5346                       		subq.w	#1,d6				; Get next bit number
00000EA4 0D05                       		btst	d6,d5				; Is the bit set?
00000EA6 6700                       		beq.s	.nopal1				; If not, branch
00000EA8 0643 4000                  		addi.w	#(2<<13),d3			; Set the second palette bit
00000EAC                            
00000EAC                            .nopal1:
00000EAC D201                       		add.b	d1,d1
00000EAE 6400                       		bcc.s	.nopal0				; If d4 was < $20
00000EB0 5346                       		subq.w	#1,d6				; Get next bit number
00000EB2 0D05                       		btst	d6,d5				; Is the bit set?
00000EB4 6700                       		beq.s	.nopal0				; If not, branch
00000EB6 0643 2000                  		addi.w	#(1<<13),d3			; Set the first palette bit
00000EBA                            
00000EBA                            .nopal0:
00000EBA D201                       		add.b	d1,d1
00000EBC 6400                       		bcc.s	.noyflip			; If d4 was < $10
00000EBE 5346                       		subq.w	#1,d6				; Get next bit number
00000EC0 0D05                       		btst	d6,d5				; Is the bit set?
00000EC2 6700                       		beq.s	.noyflip			; If not, branch
00000EC4 0043 1000                  		ori.w	#(1<<12),d3			; Set the Y flip bit
00000EC8                            
00000EC8                            .noyflip:
00000EC8 D201                       		add.b	d1,d1
00000ECA 6400                       		bcc.s	.noxflip			; If d4 was < 8
00000ECC 5346                       		subq.w	#1,d6				; Get next bit number
00000ECE 0D05                       		btst	d6,d5				; Is the bit set?
00000ED0 6700                       		beq.s	.noxflip			; If not, branch
00000ED2 0043 0800                  		ori.w	#(1<<11),d3			; Set the X flip bit
00000ED6                            
00000ED6                            .noxflip:
00000ED6 3205                       		move.w	d5,d1
00000ED8 3E06                       		move.w	d6,d7				; Get remaining bits
00000EDA 9E4D                       		sub.w	a5,d7				; Subtract minimum bit number
00000EDC 6400                       		bcc.s	.GotEnoughBits			; If we're beyond that, branch
00000EDE 3C07                       		move.w	d7,d6
00000EE0 0646 0010                  		addi.w	#16,d6				; 16 bits = 2 bytes
00000EE4 4447                       		neg.w	d7				; Calculate bit deficit
00000EE6 EF69                       		lsl.w	d7,d1				; Make space for this many bits
00000EE8 1A10                       		move.b	(a0),d5				; Get next byte
00000EEA EF3D                       		rol.b	d7,d5				; Make the upper X bits the lower X bits
00000EEC DE47                       		add.w	d7,d7
00000EEE CA7B 7000                  		and.w	EniDec_AndVals-2(pc,d7.w),d5	; Only keep X lower bits
00000EF2 D245                       		add.w	d5,d1				; Compensate for the bit deficit
00000EF4                            
00000EF4                            .AddBits:
00000EF4 300D                       		move.w	a5,d0
00000EF6 D040                       		add.w	d0,d0
00000EF8 C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000EFC D243                       		add.w	d3,d1				; Add base tile properties
00000EFE 1A18                       		move.b	(a0)+,d5			; Get current byte, move onto next byte
00000F00 E14D                       		lsl.w	#8,d5				; Shift up by a byte
00000F02 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F04 4E75                       		rts
00000F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F06                            .GotEnoughBits:
00000F06 6700                       		beq.s	.GotExactCount			; If the exact number of bits are leftover, branch
00000F08 EE69                       		lsr.w	d7,d1				; Remove unneeded bits
00000F0A 300D                       		move.w	a5,d0
00000F0C D040                       		add.w	d0,d0
00000F0E C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000F12 D243                       		add.w	d3,d1				; Add base tile properties
00000F14 300D                       		move.w	a5,d0				; Store number of bits used up by inline copy
00000F16 6000                       		bra.s	EniDec_ChkGetNextByte		; Move onto next byte
00000F18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F18                            .GotExactCount:
00000F18 7C10                       		moveq	#16,d6				; 16 bits = 2 bytes
00000F1A 60D8                       		bra.s	.AddBits
00000F1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F1C                            EniDec_AndVals:
00000F1C 0001 0003 0007 000F        		dc.w	1, 3, 7, $F
00000F24 001F 003F 007F 00FF        		dc.w	$1F, $3F, $7F, $FF
00000F2C 01FF 03FF 07FF 0FFF        		dc.w	$1FF, $3FF, $7FF, $FFF
00000F34 1FFF 3FFF 7FFF FFFF        		dc.w	$1FFF, $3FFF, $7FFF, $FFFF
00000F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F3C                            EniDec_ChkGetNextByte:
00000F3C 9C40                       		sub.w	d0,d6
00000F3E 0C46 0009                  		cmpi.w	#9,d6
00000F42 6400                       		bcc.s	.Done
00000F44 5046                       		addq.w	#8,d6				; 8 bits = 1 byte
00000F46 E145                       		asl.w	#8,d5				; Shift up by a byte
00000F48 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F4A                            
00000F4A                            .Done:
00000F4A 4E75                       		rts
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; Load a Kosinski Moduled Queue
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; PARAMETERS:
00000F4C                            ;	a3.l	- Queue pointer
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; RETURNS:
00000F4C                            ;	Nothing
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            LoadKosMQueue:
00000F4C 3C1B                       		move.w	(a3)+,d6			; Get number of entries
00000F4E 6B00                       		bmi.s	.End				; If it's negative, branch
00000F50                            
00000F50                            .Queue:
00000F50 225B                       		movea.l	(a3)+,a1			; Get art pointer
00000F52 341B                       		move.w	(a3)+,d2			; Get VRAM address
00000F54 6100                       		bsr.s	QueueKosMData			; Queue
00000F56 51CE FFF8                  		dbf	d6,.Queue			; Loop
00000F5A                            
00000F5A                            .End:
00000F5A 4E75                       		rts
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; Adds a Kosinski Moduled archive to the module queue
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; PARAMETERS:
00000F5C                            ;	d2.w	- Destination in VRAM
00000F5C                            ;	a1.l	- Address of the archive
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; RETURNS:
00000F5C                            ;	Nothing
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            QueueKosMData:
00000F5C 45F8 9994                  		lea	kosMList.w,a2
00000F60 4A92                       		tst.l	(a2)				; Is the first slot free?
00000F62 6700                       		beq.s	ProcessKosM_Init		; If it is, branch
00000F64                            		
00000F64                            .FindFreeSlot:
00000F64 5C4A                       		addq.w	#6,a2				; Otherwise, check next slot
00000F66 4A92                       		tst.l	(a2)
00000F68 66FA                       		bne.s	.FindFreeSlot
00000F6A 24C9                       		move.l	a1,(a2)+			; Store source address
00000F6C 34C2                       		move.w	d2,(a2)+			; Store destination VRAM address
00000F6E 4E75                       		rts
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; Initializes processing of the first module on the queue
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; PARAMETERS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; RETURNS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ProcessKosM_Init:
00000F70 3619                       		move.w	(a1)+,d3			; Get uncompressed size
00000F72 0C43 A000                  		cmpi.w	#$A000,d3
00000F76 6600                       		bne.s	.GotSize
00000F78 363C 8000                  		move.w	#$8000,d3			; $A000 means $8000 for some reason
00000F7C                            
00000F7C                            .GotSize:
00000F7C E24B                       		lsr.w	#1,d3
00000F7E 3003                       		move.w	d3,d0
00000F80 EB58                       		rol.w	#5,d0
00000F82 0240 001F                  		andi.w	#$1F,d0				; Get number of complete modules
00000F86 11C0 9990                  		move.b	d0,kosMModules.w
00000F8A 0283 0000 07FF             		andi.l	#$7FF,d3			; Get size of last module in words
00000F90 6600                       		bne.s	.GotLeftover			; Branch if it's non-zero
00000F92 5338 9990                  		subq.b	#1,kosMModules.w		; Otherwise decrement the number of modules
00000F96 263C 0000 0800             		move.l	#$800,d3			; And take the size of the last module to be $800 words
00000F9C                            
00000F9C                            .GotLeftover:
00000F9C 31C3 9992                  		move.w	d3,kosMLastSize.w
00000FA0 31C2 9998                  		move.w	d2,kosMDestination.w
00000FA4 21C9 9994                  		move.l	a1,kosMSource.w
00000FA8 5238 9990                  		addq.b	#1,kosMModules.w		; Store total number of modules
00000FAC 4E75                       		rts
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; Processes the first module on the queue
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; PARAMETERS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; RETURNS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ProcessKosM:
00000FAE 4A38 9990                  		tst.b	kosMModules.w
00000FB2 6600                       		bne.s	.ModulesLeft
00000FB4                            
00000FB4                            .Done:
00000FB4 4E75                       		rts
00000FB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FB6                            .ModulesLeft:
00000FB6 6B00                       		bmi.s	.DecompressionStarted
00000FB8 0C78 0004 994E             		cmpi.w	#(kosList_End-kosList)/8,kosCount.w
00000FBE 64F4                       		bhs.s	.Done				; Branch if the Kosinski decompression queue is full
00000FC0 2278 9994                  		movea.l	kosMList.w,a1
00000FC4 45F8 8000                  		lea	kosMBuff.w,a2
00000FC8 6100 0000                  		bsr.w	QueueKosData			; Add current module to decompression queue
00000FCC 0038 0080 9990             		ori.b	#$80,kosMModules.w		; And set bit to signify decompression in progress
00000FD2 4E75                       		rts
00000FD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FD4                            .DecompressionStarted:
00000FD4 4A78 994E                  		tst.w	kosCount.w
00000FD8 66DA                       		bne.s	.Done				; Branch if the decompression isn't complete
00000FDA                            
00000FDA                            		; Otherwise, DMA the decompressed data to VRAM
00000FDA 0238 007F 9990             		andi.b	#$7F,kosMModules.w
00000FE0 263C 0000 0800             		move.l	#$1000/2,d3
00000FE6 5338 9990                  		subq.b	#1,kosMModules.w
00000FEA 6600                       		bne.s	.Skip				; Branch if it isn't the last module
00000FEC 3638 9992                  		move.w	kosMLastSize.w,d3
00000FF0                            
00000FF0                            .Skip:
00000FF0 3438 9998                  		move.w	kosMDestination.w,d2
00000FF4 3002                       		move.w	d2,d0
00000FF6 D043                       		add.w	d3,d0
00000FF8 D043                       		add.w	d3,d0
00000FFA 31C0 9998                  		move.w	d0,kosMDestination.w		; Set new destination
00000FFE 2038 9994                  		move.l	kosMList.w,d0
00001002 2238 9970                  		move.l	kosList.w,d1
00001006 9081                       		sub.l	d1,d0
00001008 0280 0000 000F             		andi.l	#$F,d0
0000100E D280                       		add.l	d0,d1				; Round to the nearest $10 boundary
00001010 21C1 9994                  		move.l	d1,kosMList.w		; And set new source
00001014 223C FFFF 8000             		move.l	#kosMBuff,d1
0000101A 6100 F2E8                  		bsr.w	QueueDMATransfer
0000101E 4A38 9990                  		tst.b	kosMModules.w
00001022 6600 0000                  		bne.w	.Exit				; Return if this wasn't the last module
00001026 41F8 9994                  		lea	kosMList.w,a0
0000102A 43F8 999A                  		lea	(kosMList+6).w,a1
0000102E                            	rept (kosMList_End-kosMList)/6-1
0000102E                            		move.l	(a1)+,(a0)+			; Otherwise, shift all entries up
0000102E                            		move.w	(a1)+,(a0)+
0000102E                            	endr
0000102E 20D9                     M 	move.l	(a1)+,(a0)+
00001030 30D9                     M 	move.w	(a1)+,(a0)+
00001032 20D9                     M 	move.l	(a1)+,(a0)+
00001034 30D9                     M 	move.w	(a1)+,(a0)+
00001036 20D9                     M 	move.l	(a1)+,(a0)+
00001038 30D9                     M 	move.w	(a1)+,(a0)+
0000103A 20D9                     M 	move.l	(a1)+,(a0)+
0000103C 30D9                     M 	move.w	(a1)+,(a0)+
0000103E 20D9                     M 	move.l	(a1)+,(a0)+
00001040 30D9                     M 	move.w	(a1)+,(a0)+
00001042 20D9                     M 	move.l	(a1)+,(a0)+
00001044 30D9                     M 	move.w	(a1)+,(a0)+
00001046 20D9                     M 	move.l	(a1)+,(a0)+
00001048 30D9                     M 	move.w	(a1)+,(a0)+
0000104A 20D9                     M 	move.l	(a1)+,(a0)+
0000104C 30D9                     M 	move.w	(a1)+,(a0)+
0000104E 20D9                     M 	move.l	(a1)+,(a0)+
00001050 30D9                     M 	move.w	(a1)+,(a0)+
00001052 20D9                     M 	move.l	(a1)+,(a0)+
00001054 30D9                     M 	move.w	(a1)+,(a0)+
00001056 20D9                     M 	move.l	(a1)+,(a0)+
00001058 30D9                     M 	move.w	(a1)+,(a0)+
0000105A 20D9                     M 	move.l	(a1)+,(a0)+
0000105C 30D9                     M 	move.w	(a1)+,(a0)+
0000105E 20D9                     M 	move.l	(a1)+,(a0)+
00001060 30D9                     M 	move.w	(a1)+,(a0)+
00001062 20D9                     M 	move.l	(a1)+,(a0)+
00001064 30D9                     M 	move.w	(a1)+,(a0)+
00001066 20D9                     M 	move.l	(a1)+,(a0)+
00001068 30D9                     M 	move.w	(a1)+,(a0)+
0000106A 20D9                     M 	move.l	(a1)+,(a0)+
0000106C 30D9                     M 	move.w	(a1)+,(a0)+
0000106E 20D9                     M 	move.l	(a1)+,(a0)+
00001070 30D9                     M 	move.w	(a1)+,(a0)+
00001072 20D9                     M 	move.l	(a1)+,(a0)+
00001074 30D9                     M 	move.w	(a1)+,(a0)+
00001076 20D9                     M 	move.l	(a1)+,(a0)+
00001078 30D9                     M 	move.w	(a1)+,(a0)+
0000107A 20D9                     M 	move.l	(a1)+,(a0)+
0000107C 30D9                     M 	move.w	(a1)+,(a0)+
0000107E 20D9                     M 	move.l	(a1)+,(a0)+
00001080 30D9                     M 	move.w	(a1)+,(a0)+
00001082 20D9                     M 	move.l	(a1)+,(a0)+
00001084 30D9                     M 	move.w	(a1)+,(a0)+
00001086 20D9                     M 	move.l	(a1)+,(a0)+
00001088 30D9                     M 	move.w	(a1)+,(a0)+
0000108A 20D9                     M 	move.l	(a1)+,(a0)+
0000108C 30D9                     M 	move.w	(a1)+,(a0)+
0000108E 20D9                     M 	move.l	(a1)+,(a0)+
00001090 30D9                     M 	move.w	(a1)+,(a0)+
00001092 20D9                     M 	move.l	(a1)+,(a0)+
00001094 30D9                     M 	move.w	(a1)+,(a0)+
00001096 20D9                     M 	move.l	(a1)+,(a0)+
00001098 30D9                     M 	move.w	(a1)+,(a0)+
0000109A 20D9                     M 	move.l	(a1)+,(a0)+
0000109C 30D9                     M 	move.w	(a1)+,(a0)+
0000109E 20D9                     M 	move.l	(a1)+,(a0)+
000010A0 30D9                     M 	move.w	(a1)+,(a0)+
000010A2 20D9                     M 	move.l	(a1)+,(a0)+
000010A4 30D9                     M 	move.w	(a1)+,(a0)+
000010A6 20D9                     M 	move.l	(a1)+,(a0)+
000010A8 30D9                     M 	move.w	(a1)+,(a0)+
000010AA 4298                       		clr.l	(a0)+				; And mark the last slot as free
000010AC 4258                       		clr.w	(a0)+
000010AE 2038 9994                  		move.l	kosMList.w,d0
000010B2 6700                       		beq.s	.Exit				; Return if the queue is now empty
000010B4 2240                       		movea.l	d0,a1
000010B6 3438 9998                  		move.w	kosMDestination.w,d2
000010BA 6000 FEB4                  		bra.w	ProcessKosM_Init
000010BE                            
000010BE                            .Exit:
000010BE 4E75                       		rts
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; Adds Kosinski-compressed data to the decompression queue
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; PARAMETERS:
000010C0                            ;	a1.l	- Compressed data address
000010C0                            ;	a2.l	- Decompression destination in RAM
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; RETURNS:
000010C0                            ;	Nothing
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            QueueKosData:
000010C0 3038 994E                  		move.w	kosCount.w,d0
000010C4 E748                       		lsl.w	#3,d0
000010C6 47F8 9970                  		lea	kosList.w,a3
000010CA 2789 0000                  		move.l	a1,(a3,d0.w)			; Store source
000010CE 278A 0004                  		move.l	a2,4(a3,d0.w)			; Store destination
000010D2 5278 994E                  		addq.w	#1,kosCount.w
000010D6 4E75                       		rts
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; Checks if V-INT occured in the middle of Kosinski queue processing and stores the location from which processing is to resume if it did
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; PARAMETERS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; RETURNS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            SetKosBookmark:
000010D8 4A78 994E                  		tst.w	kosCount.w
000010DC 6A00                       		bpl.s	.Done				; Branch if a decompression wasn't in progress
000010DE 202F 0042                  		move.l	$42(sp),d0			; Check address V-INT is supposed to rte to
000010E2 0C80 0000 0000             		cmpi.l	#ProcessKos_Main,d0
000010E8 6500                       		bcs.s	.Done
000010EA 0C80 0000 0000             		cmpi.l	#ProcessKos_Done,d0
000010F0 6400                       		bcc.s	.Done
000010F2 21EF 0042 996C             		move.l	$42(sp),kosBookmark.w
000010F8 2F7C 0000 0000 0042        		move.l	#BackupKosRegs,$42(sp)		; Force V-INT to rte here instead if needed
00001100                            
00001100                            .Done:
00001100 4E75                       		rts
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; Processes the first entry in the Kosinski decompression queue
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; PARAMETERS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; RETURNS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ProcessKos:
00001102 4A78 994E                  		tst.w	kosCount.w
00001106 6700 0000                  		beq.w	ProcessKos_Done
0000110A 6B00 0000                  		bmi.w	RestoreKosBookmark		; Branch if a decompression was interrupted by V-int
0000110E                            
0000110E                            ProcessKos_Main:
0000110E 0078 8000 994E             		ori.w	#$8000,kosCount.w	; Set sign bit to signify decompression in progress
00001114 2078 9970                  		movea.l	kosList.w,a0
00001118 2278 9974                  		movea.l	kosDestination.w,a1
0000111C                            		
0000111C                            		; What follows is identical to the normal Kosinski decompressor
0000111C 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
0000111E 7000                       		moveq	#0,d0
00001120 7200                       		moveq	#0,d1
00001122 49FA FBAA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00001126 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00001128 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
0000112A 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
0000112E 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00001132 7407                       		moveq	#7,d2				; Set repeat count to 8.
00001134 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00001136 6000                       		bra.s	.FetchNewCode
00001138                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001138                            .FetchCodeLoop:
00001138                            		; Code 1 (Uncompressed byte).
00001138                            		_Kos_RunBitStream
00001138 51CA 0000                M 	dbra	d2,.skip_47
0000113C 7407                     M 	moveq	#7,d2
0000113E 1001                     M 	move.b	d1,d0
00001140 4643                     M 	not.w	d3
00001142 6600                     M 	bne.s	.skip_47
00001144 1018                     M 	move.b	(a0)+,d0
00001146 1218                     M 	move.b	(a0)+,d1
00001148 1034 0000                M 	move.b	(a4,d0.w),d0
0000114C 1234 1000                M 	move.b	(a4,d1.w),d1
00001150                          M .skip_47:
00001150 12D8                       		move.b	(a0)+,(a1)+
00001152                            
00001152                            .FetchNewCode:
00001152                            		_Kos_ReadBit
00001152 D000                     M 	add.b	d0,d0
00001154 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00001156                            
00001156                            		; Codes 00 and 01.
00001156 7AFF                       		moveq	#-1,d5
00001158 4BD1                       		lea	(a1),a5
0000115A                            		_Kos_RunBitStream
0000115A 51CA 0000                M 	dbra	d2,.skip_49
0000115E 7407                     M 	moveq	#7,d2
00001160 1001                     M 	move.b	d1,d0
00001162 4643                     M 	not.w	d3
00001164 6600                     M 	bne.s	.skip_49
00001166 1018                     M 	move.b	(a0)+,d0
00001168 1218                     M 	move.b	(a0)+,d1
0000116A 1034 0000                M 	move.b	(a4,d0.w),d0
0000116E 1234 1000                M 	move.b	(a4,d1.w),d1
00001172                          M .skip_49:
00001172                            		_Kos_ReadBit
00001172 D000                     M 	add.b	d0,d0
00001174 6500 0000                  		bcs.w	.Code_01
00001178                            
00001178                            		; Code 00 (Dictionary ref. short).
00001178                            		_Kos_RunBitStream
00001178 51CA 0000                M 	dbra	d2,.skip_51
0000117C 7407                     M 	moveq	#7,d2
0000117E 1001                     M 	move.b	d1,d0
00001180 4643                     M 	not.w	d3
00001182 6600                     M 	bne.s	.skip_51
00001184 1018                     M 	move.b	(a0)+,d0
00001186 1218                     M 	move.b	(a0)+,d1
00001188 1034 0000                M 	move.b	(a4,d0.w),d0
0000118C 1234 1000                M 	move.b	(a4,d1.w),d1
00001190                          M .skip_51:
00001190                            		_Kos_ReadBit
00001190 D000                     M 	add.b	d0,d0
00001192 6500                       		bcs.s	.Copy45
00001194                            		_Kos_RunBitStream
00001194 51CA 0000                M 	dbra	d2,.skip_53
00001198 7407                     M 	moveq	#7,d2
0000119A 1001                     M 	move.b	d1,d0
0000119C 4643                     M 	not.w	d3
0000119E 6600                     M 	bne.s	.skip_53
000011A0 1018                     M 	move.b	(a0)+,d0
000011A2 1218                     M 	move.b	(a0)+,d1
000011A4 1034 0000                M 	move.b	(a4,d0.w),d0
000011A8 1234 1000                M 	move.b	(a4,d1.w),d1
000011AC                          M .skip_53:
000011AC                            		_Kos_ReadBit
000011AC D000                     M 	add.b	d0,d0
000011AE 6500                       		bcs.s	.Copy3
000011B0                            		_Kos_RunBitStream
000011B0 51CA 0000                M 	dbra	d2,.skip_55
000011B4 7407                     M 	moveq	#7,d2
000011B6 1001                     M 	move.b	d1,d0
000011B8 4643                     M 	not.w	d3
000011BA 6600                     M 	bne.s	.skip_55
000011BC 1018                     M 	move.b	(a0)+,d0
000011BE 1218                     M 	move.b	(a0)+,d1
000011C0 1034 0000                M 	move.b	(a4,d0.w),d0
000011C4 1234 1000                M 	move.b	(a4,d1.w),d1
000011C8                          M .skip_55:
000011C8 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011CA DAC5                       		adda.w	d5,a5
000011CC 12DD                       		move.b	(a5)+,(a1)+
000011CE 12DD                       		move.b	(a5)+,(a1)+
000011D0 6080                       		bra.s	.FetchNewCode
000011D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011D2                            .Copy3:
000011D2                            		_Kos_RunBitStream
000011D2 51CA 0000                M 	dbra	d2,.skip_56
000011D6 7407                     M 	moveq	#7,d2
000011D8 1001                     M 	move.b	d1,d0
000011DA 4643                     M 	not.w	d3
000011DC 6600                     M 	bne.s	.skip_56
000011DE 1018                     M 	move.b	(a0)+,d0
000011E0 1218                     M 	move.b	(a0)+,d1
000011E2 1034 0000                M 	move.b	(a4,d0.w),d0
000011E6 1234 1000                M 	move.b	(a4,d1.w),d1
000011EA                          M .skip_56:
000011EA 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011EC DAC5                       		adda.w	d5,a5
000011EE 12DD                       		move.b	(a5)+,(a1)+
000011F0 12DD                       		move.b	(a5)+,(a1)+
000011F2 12DD                       		move.b	(a5)+,(a1)+
000011F4 6000 FF5C                  		bra.w	.FetchNewCode
000011F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011F8                            .Copy45:
000011F8                            		_Kos_RunBitStream
000011F8 51CA 0000                M 	dbra	d2,.skip_57
000011FC 7407                     M 	moveq	#7,d2
000011FE 1001                     M 	move.b	d1,d0
00001200 4643                     M 	not.w	d3
00001202 6600                     M 	bne.s	.skip_57
00001204 1018                     M 	move.b	(a0)+,d0
00001206 1218                     M 	move.b	(a0)+,d1
00001208 1034 0000                M 	move.b	(a4,d0.w),d0
0000120C 1234 1000                M 	move.b	(a4,d1.w),d1
00001210                          M .skip_57:
00001210                            		_Kos_ReadBit
00001210 D000                     M 	add.b	d0,d0
00001212 6500                       		bcs.s	.Copy5
00001214                            		_Kos_RunBitStream
00001214 51CA 0000                M 	dbra	d2,.skip_59
00001218 7407                     M 	moveq	#7,d2
0000121A 1001                     M 	move.b	d1,d0
0000121C 4643                     M 	not.w	d3
0000121E 6600                     M 	bne.s	.skip_59
00001220 1018                     M 	move.b	(a0)+,d0
00001222 1218                     M 	move.b	(a0)+,d1
00001224 1034 0000                M 	move.b	(a4,d0.w),d0
00001228 1234 1000                M 	move.b	(a4,d1.w),d1
0000122C                          M .skip_59:
0000122C 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000122E DAC5                       		adda.w	d5,a5
00001230 12DD                       		move.b	(a5)+,(a1)+
00001232 12DD                       		move.b	(a5)+,(a1)+
00001234 12DD                       		move.b	(a5)+,(a1)+
00001236 12DD                       		move.b	(a5)+,(a1)+
00001238 6000 FF18                  		bra.w	.FetchNewCode
0000123C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000123C                            .Copy5:
0000123C                            		_Kos_RunBitStream
0000123C 51CA 0000                M 	dbra	d2,.skip_60
00001240 7407                     M 	moveq	#7,d2
00001242 1001                     M 	move.b	d1,d0
00001244 4643                     M 	not.w	d3
00001246 6600                     M 	bne.s	.skip_60
00001248 1018                     M 	move.b	(a0)+,d0
0000124A 1218                     M 	move.b	(a0)+,d1
0000124C 1034 0000                M 	move.b	(a4,d0.w),d0
00001250 1234 1000                M 	move.b	(a4,d1.w),d1
00001254                          M .skip_60:
00001254 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00001256 DAC5                       		adda.w	d5,a5
00001258 12DD                       		move.b	(a5)+,(a1)+
0000125A 12DD                       		move.b	(a5)+,(a1)+
0000125C 12DD                       		move.b	(a5)+,(a1)+
0000125E 12DD                       		move.b	(a5)+,(a1)+
00001260 12DD                       		move.b	(a5)+,(a1)+
00001262 6000 FEEE                  		bra.w	.FetchNewCode
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            .Code_01:
00001266 7800                       		moveq	#0,d4				; d4 will contain copy count.
00001268                            		; Code 01 (Dictionary ref. long / special).
00001268                            		_Kos_RunBitStream
00001268 51CA 0000                M 	dbra	d2,.skip_61
0000126C 7407                     M 	moveq	#7,d2
0000126E 1001                     M 	move.b	d1,d0
00001270 4643                     M 	not.w	d3
00001272 6600                     M 	bne.s	.skip_61
00001274 1018                     M 	move.b	(a0)+,d0
00001276 1218                     M 	move.b	(a0)+,d1
00001278 1034 0000                M 	move.b	(a4,d0.w),d0
0000127C 1234 1000                M 	move.b	(a4,d1.w),d1
00001280                          M .skip_61:
00001280 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001282 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001284 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00001286 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00001288 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000128A C847                       		and.w	d7,d4				; d4 = %00000CCC.
0000128C 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
0000128E                            
0000128E                            		; special mode (extended counter)
0000128E 1818                       		move.b	(a0)+,d4			; Read cnt
00001290 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00001292 5304                       		subq.b	#1,d4
00001294 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00001298                            
00001298 DAC5                       		adda.w	d5,a5
0000129A 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000129C 3C04                       		move.w	d4,d6
0000129E 4646                       		not.w	d6
000012A0 CC47                       		and.w	d7,d6
000012A2 DC46                       		add.w	d6,d6
000012A4 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
000012A6 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
000012AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012AA                            .LargeCopy:
000012AA                            	rept (1<<_Kos_LoopUnroll)
000012AA                            		move.b	(a5)+,(a1)+
000012AA                            	endr
000012AA 12DD                     M 	move.b	(a5)+,(a1)+
000012AC 12DD                     M 	move.b	(a5)+,(a1)+
000012AE 12DD                     M 	move.b	(a5)+,(a1)+
000012B0 12DD                     M 	move.b	(a5)+,(a1)+
000012B2 12DD                     M 	move.b	(a5)+,(a1)+
000012B4 12DD                     M 	move.b	(a5)+,(a1)+
000012B6 12DD                     M 	move.b	(a5)+,(a1)+
000012B8 12DD                     M 	move.b	(a5)+,(a1)+
000012BA 51CC FFEE                  		dbra	d4,.LargeCopy
000012BE 6000 FE92                  		bra.w	.FetchNewCode
000012C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012C2                            .StreamCopy:
000012C2 DAC5                       		adda.w	d5,a5
000012C4 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
000012C6 BF44                       		eor.w	d7,d4
000012C8 D844                       		add.w	d4,d4
000012CA 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            .MediumCopy:
000012CE                            	rept 8
000012CE                            		move.b	(a5)+,(a1)+
000012CE                            	endr
000012CE 12DD                     M 	move.b	(a5)+,(a1)+
000012D0 12DD                     M 	move.b	(a5)+,(a1)+
000012D2 12DD                     M 	move.b	(a5)+,(a1)+
000012D4 12DD                     M 	move.b	(a5)+,(a1)+
000012D6 12DD                     M 	move.b	(a5)+,(a1)+
000012D8 12DD                     M 	move.b	(a5)+,(a1)+
000012DA 12DD                     M 	move.b	(a5)+,(a1)+
000012DC 12DD                     M 	move.b	(a5)+,(a1)+
000012DE 6000 FE72                  		bra.w	.FetchNewCode
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            .Quit:	
000012E2 21C8 9970                  		move.l	a0,kosList.w
000012E6 21C9 9974                  		move.l	a1,kosDestination.w
000012EA 0278 7FFF 994E             		andi.w	#$7FFF,kosCount.w		; Clear decompression in progress bit
000012F0 5378 994E                  		subq.w	#1,kosCount.w
000012F4 6700                       		beq.s	ProcessKos_Done			; Branch if there aren't any entries remaining in the queue
000012F6 41F8 9970                  		lea	kosList.w,a0
000012FA 43F8 9978                  		lea	(kosList+8).w,a1		; Otherwise, shift all entries up
000012FE                            	rept (kosList_End-kosList)/8-1
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            	endr
000012FE 20D9                     M 	move.l	(a1)+,(a0)+
00001300 20D9                     M 	move.l	(a1)+,(a0)+
00001302 20D9                     M 	move.l	(a1)+,(a0)+
00001304 20D9                     M 	move.l	(a1)+,(a0)+
00001306 20D9                     M 	move.l	(a1)+,(a0)+
00001308 20D9                     M 	move.l	(a1)+,(a0)+
0000130A                            
0000130A                            ProcessKos_Done:
0000130A 4E75                       		rts
0000130C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000130C                            RestoreKosBookmark:
0000130C 4CB8 007F 9950             		movem.w	kosRegisters.w,d0-d6
00001312 4CF8 2300 995E             		movem.l	(kosRegisters+2*7).w,a0-a1/a5
00001318 2F38 996C                  		move.l	kosBookmark.w,-(sp)
0000131C 3F38 996A                  		move.w	kosStatusReg.w,-(sp)
00001320 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00001322 49FA F9AA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT poiner
00001326 4E73                       		rte
00001328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001328                            BackupKosRegs:
00001328 40F8 996A                  		move	sr,kosStatusReg.w
0000132C 48B8 007F 9950             		movem.w	d0-d6,kosRegisters.w
00001332 48F8 2300 995E             		movem.l	a0-a1/a5,(kosRegisters+2*7).w
00001338 4E75                       		rts
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; Load Kosinski compressed art into VRAM
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; PARAMETERS:
0000133A                            ;	a0.l	- Source address
0000133A                            ;	a1.l	- Destination address
0000133A                            ;	a2.w	- VRAM address
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; RETURNS:
0000133A                            ;	Nothing
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            LoadKosArt:
0000133A 2649                       		movea.l	a1,a3				; Save destination address
0000133C 6100 F7C8                  		bsr.w	KosDec				; Decompress the art
00001340                            
00001340 93CB                       		suba.l	a3,a1				; Get size of decompressed art
00001342 3609                       		move.w	a1,d3				; ''
00001344 E24B                       		lsr.w	#1,d3				; Divide by 2 for DMA
00001346 220B                       		move.l	a3,d1				; Use destination address for DMA source
00001348 340A                       		move.w	a2,d2				; Get destination VRAM address
0000134A 6000 EFB8                  		bra.w	QueueDMATransfer		; Queue a DMA transfer
0000134E                            ; =========================================================================================================================================================
0000134E                            		include	"Libraries/Math.asm"		; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; Get a pseudo random number
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; PARAMETERS:
0000134E                            ;	Nothing
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; RETURNS:
0000134E                            ;	d0.l	- Random number
0000134E                            ;	d1.l	- New seed
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            RandomNumber:
0000134E 2238 C762                  		move.l	randomSeed.w,d1			; Get seed
00001352 6600                       		bne.s	.Generate			; If it's already initialized, branch
00001354 223C 2A6D 365B             		move.l	#$2A6D365B,d1			; Initialize the seed
0000135A                            
0000135A                            .Generate:
0000135A 2001                       		move.l	d1,d0				; Do a bunch of calculations to get a "random" number
0000135C E581                       		asl.l	#2,d1				; ''
0000135E D280                       		add.l	d0,d1				; ''
00001360 E781                       		asl.l	#3,d1				; ''
00001362 D280                       		add.l	d0,d1				; ''
00001364 3001                       		move.w	d1,d0				; ''
00001366 4841                       		swap	d1				; ''
00001368 D041                       		add.w	d1,d0				; ''
0000136A 3200                       		move.w	d0,d1				; ''
0000136C 4841                       		swap	d1				; ''
0000136E 21C1 C762                  		move.l	d1,randomSeed.w			; Set new seed
00001372 4E75                       		rts
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; Calculate the sine and cosine of an angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; PARAMETERS:
00001374                            ;	d0.b	- Angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; RETURNS:
00001374                            ;	d0.w	- Sine value
00001374                            ;	d1.w	- Cosine value	
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            CalcSine:
00001374 0240 00FF                  		andi.w	#$FF,d0				; Only allow angles 0-$FF
00001378 5040                       		addq.w	#8,d0				; Turn into offset
0000137A D040                       		add.w	d0,d0				; ''
0000137C 323B 0000                  		move.w	SineTable-$10+$80(pc,d0.w),d1	; Get cosine value
00001380 303B 0000                  		move.w	SineTable-$10(pc,d0.w),d0	; Get sine value
00001384 4E75                       		rts
00001386                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001386                            SineTable:
00001386 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000013A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000013C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000013E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001406 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001426 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001446 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001466 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001486 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000014A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000014C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000014E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001506 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001526 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001546 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001566 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001586 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000015A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000015C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000015E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001606 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001626 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001646 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001666 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001686 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000016A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000016C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000016E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001706 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001726 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001746 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001766 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; Calculate the arctangent of y/x
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; PARAMETERS:
00001786                            ;	d1.w	- X position
00001786                            ;	d2.w	- Y position
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; RETURNS:
00001786                            ;	d0.w	- The angle
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            CalcArcTan:
00001786                            		push.l	d3-d4
00001786 48E7 1800                M 	movem.l	d3-d4,-(sp)
0000178A 7600                       		moveq	#0,d3
0000178C 7800                       		moveq	#0,d4
0000178E 3601                       		move.w	d1,d3
00001790 3802                       		move.w	d2,d4
00001792 8843                       		or.w	d3,d4
00001794 6700                       		beq.s	GetArcTan_Zero			; Special case when both x and y are zero
00001796 3802                       		move.w	d2,d4
00001798                            		
00001798 4A43                       		tst.w	d3
0000179A 6A00                       		bpl.s	.NotNeg
0000179C 4443                       		neg.w	d3
0000179E                            
0000179E                            .NotNeg:
0000179E 4A44                       		tst.w	d4
000017A0 6A00                       		bpl.s	.NotNeg2
000017A2 4444                       		neg.w	d4
000017A4                            
000017A4                            .NotNeg2:
000017A4 B843                       		cmp.w	d3,d4
000017A6 6400                       		bhs.s	.NotGreater			; If |y| >= |x|
000017A8 E18C                       		lsl.l	#8,d4
000017AA 88C3                       		divu.w	d3,d4
000017AC 7000                       		moveq	#0,d0
000017AE 103B 4000                  		move.b	ArcTanTable(pc,d4.w),d0
000017B2 6000                       		bra.s	.Skip
000017B4                            
000017B4                            .NotGreater:
000017B4 E18B                       		lsl.l	#8,d3
000017B6 86C4                       		divu.w	d4,d3
000017B8 7040                       		moveq	#$40,d0
000017BA 903B 3000                  		sub.b	ArcTanTable(pc,d3.w),d0		; arctan(y/x) = 90 - arctan(x/y)
000017BE                            
000017BE                            .Skip:
000017BE 4A41                       		tst.w	d1
000017C0 6A00                       		bpl.s	.Skip2
000017C2 4440                       		neg.w	d0
000017C4 0640 0080                  		addi.w	#$80,d0				; Place angle in appropriate quadrant
000017C8                            
000017C8                            .Skip2:
000017C8 4A42                       		tst.w	d2
000017CA 6A00                       		bpl.s	.Skip3
000017CC 4440                       		neg.w	d0
000017CE 0640 0100                  		addi.w	#$100,d0			; Place angle in appropriate quadrant
000017D2                            
000017D2                            .Skip3:
000017D2                            		pop.l	d3-d4
000017D2 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017D6 4E75                       		rts
000017D8                            
000017D8                            GetArcTan_Zero:
000017D8 303C 0040                  		move.w	#$40,d0				; Angle = 90 degrees
000017DC                            		pop.l	d3-d4
000017DC 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017E0 4E75                       		rts
000017E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000017E2                            ArcTanTable:
000017E2 0000 0000 0101             		dc.b	$00, $00, $00, $00, $01, $01
000017E8 0101 0101 0202             		dc.b	$01, $01, $01, $01, $02, $02
000017EE 0202 0202 0303             		dc.b	$02, $02, $02, $02, $03, $03
000017F4 0303 0303 0304             		dc.b	$03, $03, $03, $03, $03, $04
000017FA 0404 0404 0405             		dc.b	$04, $04, $04, $04, $04, $05
00001800 0505 0505 0506             		dc.b	$05, $05, $05, $05, $05, $06
00001806 0606 0606 0606             		dc.b	$06, $06, $06, $06, $06, $06
0000180C 0707 0707 0707             		dc.b	$07, $07, $07, $07, $07, $07
00001812 0808 0808 0808             		dc.b	$08, $08, $08, $08, $08, $08
00001818 0809 0909 0909             		dc.b	$08, $09, $09, $09, $09, $09
0000181E 090A 0A0A 0A0A             		dc.b	$09, $0A, $0A, $0A, $0A, $0A
00001824 0A0A 0B0B 0B0B             		dc.b	$0A, $0A, $0B, $0B, $0B, $0B
0000182A 0B0B 0B0C 0C0C             		dc.b	$0B, $0B, $0B, $0C, $0C, $0C
00001830 0C0C 0C0C 0D0D             		dc.b	$0C, $0C, $0C, $0C, $0D, $0D
00001836 0D0D 0D0D 0D0E             		dc.b	$0D, $0D, $0D, $0D, $0D, $0E
0000183C 0E0E 0E0E 0E0E             		dc.b	$0E, $0E, $0E, $0E, $0E, $0E
00001842 0F0F 0F0F 0F0F             		dc.b	$0F, $0F, $0F, $0F, $0F, $0F
00001848 0F10 1010 1010             		dc.b	$0F, $10, $10, $10, $10, $10
0000184E 1010 1111 1111             		dc.b	$10, $10, $11, $11, $11, $11
00001854 1111 1111 1212             		dc.b	$11, $11, $11, $11, $12, $12
0000185A 1212 1212 1213             		dc.b	$12, $12, $12, $12, $12, $13
00001860 1313 1313 1313             		dc.b	$13, $13, $13, $13, $13, $13
00001866 1314 1414 1414             		dc.b	$13, $14, $14, $14, $14, $14
0000186C 1414 1415 1515             		dc.b	$14, $14, $14, $15, $15, $15
00001872 1515 1515 1515             		dc.b	$15, $15, $15, $15, $15, $15
00001878 1616 1616 1616             		dc.b	$16, $16, $16, $16, $16, $16
0000187E 1616 1717 1717             		dc.b	$16, $16, $17, $17, $17, $17
00001884 1717 1717 1718             		dc.b	$17, $17, $17, $17, $17, $18
0000188A 1818 1818 1818             		dc.b	$18, $18, $18, $18, $18, $18
00001890 1818 1919 1919             		dc.b	$18, $18, $19, $19, $19, $19
00001896 1919 1919 1919             		dc.b	$19, $19, $19, $19, $19, $19
0000189C 1A1A 1A1A 1A1A             		dc.b	$1A, $1A, $1A, $1A, $1A, $1A
000018A2 1A1A 1A1B 1B1B             		dc.b	$1A, $1A, $1A, $1B, $1B, $1B
000018A8 1B1B 1B1B 1B1B             		dc.b	$1B, $1B, $1B, $1B, $1B, $1B
000018AE 1B1C 1C1C 1C1C             		dc.b	$1B, $1C, $1C, $1C, $1C, $1C
000018B4 1C1C 1C1C 1C1C             		dc.b	$1C, $1C, $1C, $1C, $1C, $1C
000018BA 1D1D 1D1D 1D1D             		dc.b	$1D, $1D, $1D, $1D, $1D, $1D
000018C0 1D1D 1D1D 1D1E             		dc.b	$1D, $1D, $1D, $1D, $1D, $1E
000018C6 1E1E 1E1E 1E1E             		dc.b	$1E, $1E, $1E, $1E, $1E, $1E
000018CC 1E1E 1E1E 1F1F             		dc.b	$1E, $1E, $1E, $1E, $1F, $1F
000018D2 1F1F 1F1F 1F1F             		dc.b	$1F, $1F, $1F, $1F, $1F, $1F
000018D8 1F1F 1F1F 2020             		dc.b	$1F, $1F, $1F, $1F, $20, $20
000018DE 2020 2020 2000             		dc.b	$20, $20, $20, $20, $20, $00
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            ; Initialize oscillation
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            InitOscillation:
000018E4 43F8 C76C                  		lea	oscillators.w,a1
000018E8 45FA 0000                  		lea	OscInitData(pc),a2
000018EC 7200                       		moveq	#(OscInitData_End-OscInitData)>>1-1,d1
000018EE                            
000018EE                            .LoadData:
000018EE 32DA                       		move.w	(a2)+,(a1)+
000018F0 51C9 FFFC                  		dbf	d1,.LoadData
000018F4 4E75                       		rts
000018F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018F6                            OscInitData:
000018F6 007D                       		dc.w	%0000000001111101
000018F8 0080 0000                  		dc.w	$0080, $0000
000018FC 0080 0000                  		dc.w	$0080, $0000
00001900 0080 0000                  		dc.w	$0080, $0000
00001904 0080 0000                  		dc.w	$0080, $0000
00001908 0080 0000                  		dc.w	$0080, $0000
0000190C 0080 0000                  		dc.w	$0080, $0000
00001910 0080 0000                  		dc.w	$0080, $0000
00001914 0080 0000                  		dc.w	$0080, $0000
00001918 0080 0000                  		dc.w	$0080, $0000
0000191C 3848 00EE                  		dc.w	$3848, $00EE
00001920 2080 00B4                  		dc.w	$2080, $00B4
00001924 3080 010E                  		dc.w	$3080, $010E
00001928 5080 01C2                  		dc.w	$5080, $01C2
0000192C 7080 0276                  		dc.w	$7080, $0276
00001930 0080 0000                  		dc.w	$0080, $0000
00001934 4000 00FE                  		dc.w	$4000, $00FE
00001938                            OscInitData_End:
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            ; Update oscillation
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            UpdateOscillation:
00001938 43F8 C76C                  		lea	oscillators.w,a1
0000193C 45FA 0000                  		lea	OscUpdateData(pc),a2
00001940 3619                       		move.w	(a1)+,d3
00001942 7200                       		moveq	#(OscUpdateData_End-OscUpdateData)>>2-1,d1
00001944                            
00001944                            .OscLoop:
00001944 341A                       		move.w	(a2)+,d2
00001946 381A                       		move.w	(a2)+,d4
00001948 0303                       		btst	d1,d3
0000194A 6600                       		bne.s	.Sub
0000194C 3029 0002                  		move.w	2(a1),d0
00001950 D042                       		add.w	d2,d0
00001952 3340 0002                  		move.w	d0,2(a1)
00001956 D151                       		add.w	d0,(a1)
00001958 B811                       		cmp.b	(a1),d4
0000195A 6200                       		bhi.s	.DoLoop
0000195C 03C3                       		bset	d1,d3
0000195E 6000                       		bra.s	.DoLoop
00001960                            
00001960                            .Sub:
00001960 3029 0002                  		move.w	2(a1),d0
00001964 9042                       		sub.w	d2,d0
00001966 3340 0002                  		move.w	d0,2(a1)
0000196A D151                       		add.w	d0,(a1)
0000196C B811                       		cmp.b	(a1),d4
0000196E 6300                       		bls.s	.DoLoop
00001970 0383                       		bclr	d1,d3
00001972                            
00001972                            .DoLoop:
00001972 5849                       		addq.w	#4,a1
00001974 51C9 FFCE                  		dbf	d1,.OscLoop
00001978                            
00001978 31C3 C76C                  		move.w	d3,oscControl.w
0000197C                            
0000197C                            .End:
0000197C 4E75                       		rts
0000197E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000197E                            OscUpdateData:
0000197E 0002 0010                  		dc.w	$02, $10
00001982 0002 0018                  		dc.w	$02, $18
00001986 0002 0020                  		dc.w	$02, $20
0000198A 0002 0030                  		dc.w	$02, $30
0000198E 0004 0020                  		dc.w	$04, $20
00001992 0008 0008                  		dc.w	$08, $08
00001996 0008 0040                  		dc.w	$08, $40
0000199A 0004 0040                  		dc.w	$04, $40
0000199E 0002 0038                  		dc.w	$02, $38
000019A2 0002 0038                  		dc.w	$02, $38
000019A6 0002 0020                  		dc.w	$02, $20
000019AA 0003 0030                  		dc.w	$03, $30
000019AE 0005 0050                  		dc.w	$05, $50
000019B2 0007 0070                  		dc.w	$07, $70
000019B6 0002 0040                  		dc.w	$02, $40
000019BA 0002 0040                  		dc.w	$02, $40
000019BE                            OscUpdateData_End:
000019BE                            ; =========================================================================================================================================================
000019BE                            		include	"Libraries/Object.asm"		; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; Initialize object lists
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; PARAMETERS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; RETURNS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            InitObjectList:
000019BE                            		clrRAM	objRespawn,objMemory_End		; Clear respawn table and object memory
000019BE                          M 	local	endaddr
000019BE                          M endaddr	equs	"objmemory_end"
000019BE 7000                     M 	moveq	#0,d0
000019C0 43F8 9A54                M 	lea	(objrespawn).w,a1
000019C4 323C 09BF                M 	move.w	#(((objmemory_end)-(objrespawn))-((objrespawn)&1))>>2-1,d1
000019C8 22C0                     M .clear_65:	move.l	d0,(a1)+
000019CA 51C9 FFFC                M 	dbf	d1,.clear_65
000019CE                            
000019CE                            	; setup tail object
000019CE 31FC C154 C158             		move.w	#objExecExit,objExecFirst.w		; set the first object as the tail object
000019D4 31FC C154 C15A             		move.w	#objExecExit,objExecLast.w		; set the last object as the tail object
000019DA 21FC 0000 0000 C154        		move.l	#.rts,objExecExit.w		; set the next rts as the tail object pointer
000019E2                            
000019E2                            	; setup free object list
000019E2 41F8 9D54                  		lea	objMemory.w,a0			; load the objects list into a0
000019E6 31C8 C15C                  		move.w	a0,objExecFree.w			; set the first object as the first free object
000019EA 705E                       		moveq	#OBJECT_COUNT-2,d0		; load object count to d0
000019EC 7260                       		moveq	#_objSize,d1			; load object size to d1
000019EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019EE                            
000019EE                            .load
000019EE D0C1                       		add.w	d1,a0				; go to the next object now
000019F0 3148 FFA6                  		move.w	a0,_objPrev-_objSize(a0)		; save new previous pointer
000019F4 42A8 0008                  		clr.l	_objDrawNext(a0)			; clear the display link values
000019F8 51C8 FFF4                  		dbf	d0,.load			; loop for every object
000019FC                            
000019FC 4268 0006                  		clr.w	_objPrev(a0)			; set the last previous pointer to 0
00001A00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A00                            
00001A00                            	; reset display table
00001A00 43F8 C156                  		lea	objDisplay-dNext.w,a1		; get display table address to a1
00001A04 7207                       		moveq	#8-1,d1				; loop for all the layers
00001A06                            
00001A06                            .dsp
00001A06 3349 000E                  		move.w	a1,dPrev+dNext(a1)		; update prev pointer
00001A0A 5849                       		addq.w	#dNext,a1			; advance to the actual address
00001A0C 3349 0004                  		move.w	a1,dNext(a1)			; update next pointer
00001A10                            
00001A10 42A9 0006                  		clr.l	dN2(a1)				; clear the list end pointers
00001A14 5849                       		addq.w	#dSize-dNext,a1			; go to the next layer
00001A16 51C9 FFEE                  		dbf	d1,.dsp				; loop for all layers
00001A1A                            
00001A1A                            .rts
00001A1A 4E75                       		rts
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; Find the first free object space available
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; PARAMETERS:
00001A1C                            ;	Nothing
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; RETURNS:
00001A1C                            ;	a1.l	- Pointer to the SST space in the free object space
00001A1C                            ;	a2.l	- Trashed
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            FindFreeObj:
00001A1C 3038 C15C                  		move.w	objExecFree.w,d0			; get pointer to the next free object
00001A20 6700                       		beq.s	.rts				; if it's a null pointer (z=1), return
00001A22 3240                       		movea.w	d0,a1				; load to a1
00001A24 31E9 0006 C15C             		move.w	_objPrev(a1),objExecFree.w		; copy the next free object pointer to list start
00001A2A                            
00001A2A 3478 C15A                  		move.w	objExecLast.w,a2			; load last object to a2
00001A2E 31C9 C15A                  		move.w	a1,objExecLast.w			; save as the new last object
00001A32 336A 0004 0004             		move.w	_objNext(a2),_objNext(a1)		; copy the next pointer from old tail to new object
00001A38 3549 0004                  		move.w	a1,_objNext(a2)			; save new object as next pointer for old tail
00001A3C 334A 0006                  		move.w	a2,_objPrev(a1)			; save old tail as prev pointer for new object
00001A40                            
00001A40                            .rts:
00001A40 4E75                       		rts
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; Delete another object
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; PARAMETERS:
00001A42                            ;	a1.l	- Pointer to object space to clear
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; RETURNS:
00001A42                            ;	a1.l	- Trashed
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            DeleteOtherObj:
00001A42 4850                       		pea	(a0)
00001A44 2049                       		move.l	a1,a0
00001A46 6100                       		bsr.s	DeleteObject
00001A48                            		pop.l	a0
00001A48 205F                     M 	move.l	(sp)+,a0
00001A4A 4E75                       		rts
00001A4C                            
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; Delete the current object
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; PARAMETERS:
00001A4C                            ;	Nothing
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; RETURNS:
00001A4C                            ;	a1.l	- Trashed
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            DeleteObject:
00001A4C                            	removeSprite	a0, a1, 1			; remove object display
00001A4C 4A68 0008                M 	tst.w	_objdrawnext(a0)
00001A50 6700                     M 	beq.s	.yes_67
00001A52 3268 000A                M 	move.w	_objdrawprev(a0),a1
00001A56 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00001A5C 3268 0008                M 	move.w	_objdrawnext(a0),a1
00001A60 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
00001A66                          M .no_67
00001A66 42A8 0008                M 	clr.l	_objdrawnext(a0)
00001A6A                          M .yes_67
00001A6A 3268 0006                  		move.w	_objPrev(a0),a1			; copy previous pointer to a1
00001A6E 3368 0004 0004             		move.w	_objNext(a0),_objNext(a1)		; copy next pointer to previous object
00001A74 3268 0004                  		move.w	_objNext(a0),a1			; get next object to a1
00001A78 3368 0006 0006             		move.w	_objPrev(a0),_objPrev(a1)		; copy previous pointer
00001A7E                            
00001A7E 3178 C15C 0006             		move.w	objExecFree.w,_objPrev(a0)		; get the head of the free list to previous pointer of this object
00001A84 31C8 C15C                  		move.w	a0,objExecFree.w			; save as the new head of free list
00001A88                            
00001A88                            ; clear object memory
00001A88 7000                       		moveq	#0,d0				; clear d0
00001A8A 7214                       		moveq	#(((_objSize-_objDrawPrev)>>2)-1),d1	; set loop count
00001A8C                            
00001A8C 4852                       		pea	(a2)				; backup a2
00001A8E 45E8 000A                  		lea	_objDrawPrev(a0),a2		; load the first property to clear to a2
00001A92                            		
00001A92                            .clrLoop:
00001A92 24C0                       		move.l	d0,(a2)+			; clear a longword of the object slot's memory
00001A94 51C9 FFFC                  		dbf	d1,.clrLoop			; loop through to clear all object properties
00001A98                            
00001A98 34C0                       		move.w	d0,(a2)+			; clear the last word of data if the object ram per slot does not divide evenly by 4
00001A9A                            
00001A9A                            		pop.l	a2				; restore a2
00001A9A 245F                     M 	move.l	(sp)+,a2
00001A9C 4E75                       		rts
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; Render object sprites
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; PARAMETERS:
00001A9E                            ;	Nothing
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; RETURNS:
00001A9E                            ;	Nothing
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            RendeobjMemory:
00001A9E 7E4F                       		moveq	#($280/8)-1,d7			; Max sprite count
00001AA0 7C00                       		moveq	#0,d6				; Render flags
00001AA2                            
00001AA2 47F8 E88A                  		lea	fgCamVars.w,a3			; Foreground camera variables
00001AA6 4BF8 C15E                  		lea	objDisplay+dNext.w,a5	; Sprite input table
00001AAA 4DF8 94CE                  		lea	spriteBuff.w,a6			; Sprite table buffer
00001AAE                            
00001AAE 0C38 0004 C75C             		cmpi.b	#gLevel,opmode.w		; Are we in level mode?
00001AB4                            ;		bne.s	.PrioLvlLoop			; If not, branch
00001AB4                            ;		jsr	Level_RenderHUDAndRings		; Render the HUD & Rings (in that order)
00001AB4                            
00001AB4                            .PrioLvlLoop:
00001AB4 3055                       		move.w	(a5),a0				; Load priority level address to a0
00001AB6 504D                       		add.w	#dSize,a5			; Skip bunch of shit
00001AB8 4A68 0008                  		tst.w	_objDrawNext(a0)			; Is the next pointer for a valid object?
00001ABC 6700 0000                  		beq.w	.NextPrioLvl			; If not, branch
00001AC0                            
00001AC0                            .ObjectLoop:
00001AC0                            	;	movea.w	(a4)+,a0			; Get object SST address
00001AC0 4A90                       		tst.l	_objAddress(a0)			; Is this object slot used?
00001AC2 6700 0000                  		beq.w	.NextObject			; If not, branch
00001AC6                            
00001AC6 0228 007F 000D             		andi.b	#$7F,_objRender(a0)		; Clear on-screen flag
00001ACC 1C28 000D                  		move.b	_objRender(a0),d6			; Store render flags
00001AD0 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00001AD4 3228 0018                  		move.w	_objYPos(a0),d1			; Get Y position
00001AD8                            
00001AD8 0806 0006                  		btst	#6,d6				; Is the multi sprite flag set?
00001ADC 6600 0000                  		bne.w	.MultiDraw			; If so, branch
00001AE0 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001AE4 6700                       		beq.s	.Render				; If not, branch
00001AE6                            
00001AE6 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001AE8 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001AEC                            
00001AEC                            .Render:
00001AEC 7400                       		moveq	#0,d2
00001AEE 1428 0017                  		move.b	_objDrawW(a0),d2			; Get sprite width
00001AF2 3600                       		move.w	d0,d3				; Get sprite X position
00001AF4 D642                       		add.w	d2,d3				; Add width
00001AF6 6B00                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001AF8 3600                       		move.w	d0,d3				; Get sprite X position
00001AFA 9642                       		sub.w	d2,d3				; Subtract width
00001AFC 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001B00 6C00                       		bge.s	.NextObject			; If so, branch
00001B02 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001B06                            
00001B06 7400                       		moveq	#0,d2
00001B08 1428 001B                  		move.b	_objDrawH(a0),d2			; Get sprite height
00001B0C 3601                       		move.w	d1,d3				; Get sprite Y position
00001B0E D642                       		add.w	d2,d3				; Add height
00001B10 6B00                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001B12 3601                       		move.w	d1,d3				; Get sprite Y position
00001B14 9642                       		sub.w	d2,d3				; Subtract height
00001B16 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001B1A 6C00                       		bge.s	.NextObject			; If so, branch
00001B1C 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001B20                            
00001B20 0028 0080 000D             		ori.b	#$80,_objRender(a0)		; Set on-screen flag
00001B26 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B28 6B00                       		bmi.s	.NextObject			; If not, branch
00001B2A                            
00001B2A 2828 0010                  		move.l	_objMapping(a0),d4			; Get mappings pointer
00001B2E 6700                       		beq.s	.NextObject			; If blank, branch
00001B30 2244                       		movea.l	d4,a1				; Store it
00001B32 7800                       		moveq	#0,d4
00001B34 0806 0005                  		btst	#5,d6				; Is the static sprite flag set
00001B38 6600                       		bne.s	.Static				; If so, branch
00001B3A 1828 0010                  		move.b	_objFrame(a0),d4			; Get mapping frame
00001B3E D844                       		add.w	d4,d4				; Turn into offset
00001B40 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001B44 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001B46 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001B48 6B00                       		bmi.s	.NextObject			; If there are no sprites to draw, branch
00001B4A                            
00001B4A                            .Static:
00001B4A 3A28 000E                  		move.w	_objVRAM(a0),d5			; Get sprite tile properties
00001B4E 6100 ED02                  		bsr.w	DrawSprite			; Draw the sprites
00001B52                            
00001B52                            .NextObject:	
00001B52 3068 0008                  		move.w	_objDrawNext(a0),a0		; Load next object to a0
00001B56 4A68 0008                  		tst.w	_objDrawNext(a0)			; Check the next pointer for valid object
00001B5A 6600 FF64                  		bne.w	.ObjectLoop			; If there are still some sprites to draw in this priority level, branch
00001B5E                            
00001B5E                            .NextPrioLvl:
00001B5E BAFC C19E                  		cmpa.w	#objDisplay_End,a5		; Are we at the end of the input table?
00001B62 6500 FF50                  		blo.w	.PrioLvlLoop			; If not, branch
00001B66                            
00001B66 3C07                       		move.w	d7,d6				; Get remaining sprite count
00001B68 6B00                       		bmi.s	.SetDrawnSprites		; If we have filled the entire sprite table, branch
00001B6A 7000                       		moveq	#0,d0
00001B6C                            
00001B6C                            .FillRest:
00001B6C 3C80                       		move.w	d0,(a6)				; Move sprite off screen
00001B6E 504E                       		addq.w	#8,a6				; Next sprite
00001B70 51CF FFFA                  		dbf	d7,.FillRest			; Loop
00001B74                            
00001B74                            .SetDrawnSprites:
00001B74 0446 004F                  		subi.w	#($280/8)-1,d6			; Get number of sprites drawn
00001B78 4446                       		neg.w	d6				; ''
00001B7A 11C6 C75D                  		move.b	d6,spriteCount.w		; Store it
00001B7E                            
00001B7E 4E75                       		rts
00001B80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001B80                            .MultiDraw:
00001B80 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001B84 6700                       		beq.s	.RenderMain			; If not, branch
00001B86                            
00001B86 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001B88 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001B8C                            
00001B8C                            .RenderMain:
00001B8C 7400                       		moveq	#0,d2
00001B8E 1428 0017                  		move.b	_objDrawW(a0),d2			; Get main sprite width
00001B92 3600                       		move.w	d0,d3				; Get main sprite X position
00001B94 D642                       		add.w	d2,d3				; Add width
00001B96 6BBA                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001B98 3600                       		move.w	d0,d3				; Get main sprite X position
00001B9A 9642                       		sub.w	d2,d3				; Subtract width
00001B9C 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001BA0 6CB0                       		bge.s	.NextObject			; If so, branch
00001BA2 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001BA6                            
00001BA6 1428 001B                  		move.b	_objDrawH(a0),d2			; Get main sprite height
00001BAA 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BAC D642                       		add.w	d2,d3				; Add height
00001BAE 6BA2                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001BB0 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BB2 9642                       		sub.w	d2,d3				; Subtract height
00001BB4 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001BB8 6C98                       		bge.s	.NextObject			; If so, branch
00001BBA 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001BBE                            
00001BBE 0028 0080 000D             		ori.b	#$80,_objRender(a0)		; Set on-screen flag
00001BC4 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BC6 6B00 FF8A                  		bmi.w	.NextObject			; If not, branch
00001BCA                            
00001BCA 3A28 000E                  		move.w	_objVRAM(a0),d5			; Get sprite tile properties
00001BCE 2828 0010                  		move.l	_objMapping(a0),d4			; Get mappings pointer
00001BD2 6700 FF7E                  		beq.w	.NextObject			; If blank, branch
00001BD6 2444                       		movea.l	d4,a2				; Store it
00001BD8 7800                       		moveq	#0,d4
00001BDA 1828 0010                  		move.b	_objFrame(a0),d4			; Get mapping frame
00001BDE D844                       		add.w	d4,d4				; Turn into offset
00001BE0 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001BE2 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001BE6 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001BE8 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001BEA 6B00                       		bmi.s	.RenderSubSprites		; If there are no sprites to draw, branch
00001BEC 3606                       		move.w	d6,d3				; Store render flags
00001BEE 6100 ED46                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001BF2 3C03                       		move.w	d3,d6				; Restore render flags
00001BF4                            
00001BF4 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BF6 6B00 FF5A                  		bmi.w	.NextObject			; If not, branch
00001BFA                            
00001BFA                            .RenderSubSprites:
00001BFA 3628 002E                  		move.w	_objSubCnt(a0),d3			; Get sub sprite count
00001BFE 5343                       		subq.w	#1,d3				; Subtract 1
00001C00 6B00 FF50                  		bmi.w	.NextObject			; If there are no sprites to draw, branch
00001C04 41E8 0030                  		lea	_objSubStart(a0),a0		; Get sub sprite SSTs start
00001C08                            
00001C08                            .RenderSubSprs_Loop:
00001C08 3018                       		move.w	(a0)+,d0			; Get X position
00001C0A 0640 0080                  		addi.w	#128,d0				; Move on screen
00001C0E 3218                       		move.w	(a0)+,d1			; Get Y position
00001C10 0641 0080                  		addi.w	#128,d1				; Move on screen
00001C14                            
00001C14 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001C18 6700                       		beq.s	.RenderSub			; If not, branch
00001C1A                            
00001C1A 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001C1C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001C20                            
00001C20                            .RenderSub:
00001C20 3818                       		move.w	(a0)+,d4			; Get mapping frame
00001C22 D844                       		add.w	d4,d4				; Turn into offset
00001C24 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001C26 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001C2A 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001C2C 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001C2E 6B00                       		bmi.s	.RenderSubSprs_ChkLoop		; If there are no sprites to draw, branch
00001C30                            		push.w	d6				; Store render flags
00001C30 3F06                     M 	move.w	d6,-(sp)
00001C32 6100 ED02                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001C36                            		pop.w	d6				; Restore render flags
00001C36 3C1F                     M 	move.w	(sp)+,d6
00001C38                            
00001C38                            .RenderSubSprs_ChkLoop:
00001C38 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001C3A 5BCB FFCC                  		dbmi	d3,.RenderSubSprs_Loop		; If so, loop
00001C3E 6000 FF12                  		bra.w	.NextObject			; Continue on rendering other sprites
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; Animate an object's sprite
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; PARAMETERS:
00001C42                            ;	a0.l	- Object space pointer
00001C42                            ;	a1.l	- Animation script pointer
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; RETURNS:
00001C42                            ;	Nothing
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            AnimateObject:
00001C42 7000                       		moveq	#0,d0
00001C44 1028 0020                  		move.b	_objAnim(a0),d0			; Get animation ID
00001C48 B028 0021                  		cmp.b	_objPrevAnim(a0),d0			; Has it changed?
00001C4C 6700                       		beq.s	.Run				; If not, branch
00001C4E 1140 0021                  		move.b	d0,_objPrevAnim(a0)			; Save the new ID
00001C52 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00001C56 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001C5A                            
00001C5A                            .Run:
00001C5A 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00001C5E 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00001C60 D040                       		add.w	d0,d0				; Turn ID into offset
00001C62 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00001C66 1151 0023                  		move.b	(a1),_objAnimTimer(a0)		; Set new animation timer
00001C6A                            
00001C6A 7200                       		moveq	#0,d1
00001C6C 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get current value in the script
00001C70 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00001C74 0C00 00FA                  		cmpi.b	#$FA,d0				; Is it a command value?
00001C78 6400                       		bhs.s	.CmdReset			; If so, branch
00001C7A                            
00001C7A                            .Next:
00001C7A 1140 0010                  		move.b	d0,_objFrame(a0)			; Set mapping frame ID
00001C7E 1028 0028                  		move.b	_objStatus(a0),d0			; Get status
00001C82 0200 0003                  		andi.b	#3,d0				; Only get flip bits
00001C86 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
00001C8C 8128 000D                  		or.b	d0,_objRender(a0)			; Set flip bits
00001C90 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Advance into the animation script
00001C94                            
00001C94                            .Wait:
00001C94 4E75                       		rts
00001C96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C96                            .CmdReset:
00001C96 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00001C98 6600                       		bne.s	.CmdJump			; If not, branch
00001C9A 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00001C9E 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00001CA2 60D6                       		bra.s	.Next				; Continue
00001CA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CA4                            .CmdJump:
00001CA4 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00001CA6 6600                       		bne.s	.CmdSetAnim			; If not, branch
00001CA8 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00001CAC 9128 0022                  		sub.b	d0,_objAnimFrame(a0)		; Go back
00001CB0 9200                       		sub.b	d0,d1				; ''
00001CB2 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00001CB6 60C2                       		bra.s	.Next				; Continue
00001CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CB8                            .CmdSetAnim:
00001CB8 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00001CBA 6600                       		bne.s	.CmdNextRout			; If not, branch
00001CBC 1171 1002 0020             		move.b	2(a1,d1.w),_objAnim(a0)		; Set new animation ID
00001CC2 4E75                       		rts
00001CC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CC4                            .CmdNextRout:
00001CC4 5200                       		addq.b	#1,d0				; Is this flag $FC (next routine)?
00001CC6 6600                       		bne.s	.CmdReset2ndRout		; If not, branch
00001CC8 5428 0025                  		addq.b	#2,_objRoutine(a0)			; Next routine
00001CCC 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001CD0 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Next animation frame
00001CD4 4E75                       		rts
00001CD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CD6                            .CmdReset2ndRout:
00001CD6 5200                       		addq.b	#1,d0				; Is this flag $FB (reset secondary routine)?
00001CD8 6600                       		bne.s	.CmdNext2ndRout			; If not, branch
00001CDA 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001CDE                            ;		clr.b	oWFZRout(a0)			; Reset routine
00001CDE 4E75                       		rts
00001CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE0                            .CmdNext2ndRout:
00001CE0 5200                       		addq.b	#1,d0				; Is this flag $FA (next secondary routine)?
00001CE2 6600                       		bne.s	.CmdEnd				; If not, branch
00001CE4                            ;		addq.b	#2,oWFZRout(a0)			; Next routine
00001CE4 4E75                       		rts
00001CE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE6                            .CmdEnd:
00001CE6 4E75                       		rts
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; Load object DPLCs
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; PARAMETERS:
00001CE8                            ;	d4.w	- Target VRAM address
00001CE8                            ;	d6.l	- Pointer to uncompressed art
00001CE8                            ;	a2.l	- Pointer to DPLCs
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; RETURNS:
00001CE8                            ;	Nothing
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            LoadObjDPLCs:
00001CE8 7000                       		moveq	#0,d0
00001CEA 1028 0010                  		move.b	_objFrame(a0),d0			; Get mapping frame
00001CEE B010                       		cmp.b	_objPrevDPLC(a0),d0		; Do we need to update the art?
00001CF0 6700                       		beq.s	.End				; If not, branch
00001CF2 1080                       		move.b	d0,_objPrevDPLC(a0)		; Save the frame ID so we don't constantly load the art
00001CF4 D040                       		add.w	d0,d0				; Turn ID into offset
00001CF6 D4F2 0000                  		adda.w	(a2,d0.w),a2			; Get pointer to DPLC data for the frame
00001CFA 3A1A                       		move.w	(a2)+,d5			; Get DPLC entry count
00001CFC 5345                       		subq.w	#1,d5				; Subtract 1
00001CFE 6B00                       		bmi.s	.End				; If there are no more entires left, branch
00001D00                            
00001D00                            .ReadEntries:
00001D00 7200                       		moveq	#0,d1
00001D02 321A                       		move.w	(a2)+,d1			; Get DPLC entry data
00001D04 3601                       		move.w	d1,d3				; Copy that
00001D06 E04B                       		lsr.w	#8,d3				; Get tile count
00001D08 0243 00F0                  		andi.w	#$F0,d3				; ''
00001D0C 0643 0010                  		addi.w	#$10,d3				; ''
00001D10 0241 0FFF                  		andi.w	#$FFF,d1			; Get offset in art data
00001D14 EB89                       		lsl.l	#5,d1				; ''
00001D16 D286                       		add.l	d6,d1				; Get pointer in art data
00001D18 3404                       		move.w	d4,d2				; Copy VRAM address
00001D1A D843                       		add.w	d3,d4				; Add tile count to VRAM address
00001D1C D843                       		add.w	d3,d4				; ''
00001D1E 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the art
00001D22 51CD FFDC                  		dbf	d5,.ReadEntries			; Loop
00001D26                            
00001D26                            .End:
00001D26 4E75                       		rts
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; Move an object by it's velocity values
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; PARAMETERS:
00001D28                            ;	a0.l	- Object space pointer
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; RETURNS:
00001D28                            ;	Nothing
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ObjectMove:
00001D28 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00001D2C 48C0                       		ext.l	d0				; ''
00001D2E E188                       		lsl.l	#8,d0				; Shift
00001D30 D1A8 0014                  		add.l	d0,_objXPos(a0)			; Add to the X position
00001D34 3028 001E                  		move.w	_objYVel(a0),d0			; Get Y velocity
00001D38 48C0                       		ext.l	d0				; ''
00001D3A E188                       		lsl.l	#8,d0				; Shift
00001D3C D1A8 0018                  		add.l	d0,_objYPos(a0)			; Add to the Y position
00001D40 4E75                       		rts
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; Move an object by it's velocity values (with gravity)
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; PARAMETERS:
00001D42                            ;	a0.l	- Object space pointer
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; RETURNS:
00001D42                            ;	Nothing
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ObjectMoveAndFall:
00001D42 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00001D46 48C0                       		ext.l	d0				; ''
00001D48 E188                       		lsl.l	#8,d0				; Shift
00001D4A D1A8 0014                  		add.l	d0,_objXPos(a0)			; Add to the X position
00001D4E 3028 001E                  		move.w	_objYVel(a0),d0			; Get Y velocity
00001D52 0668 000C 001E             		addi.w	#$0C,_objYVel(a0)			; Apply gravity
00001D58 48C0                       		ext.l	d0				; ''
00001D5A E188                       		lsl.l	#8,d0				; Shift
00001D5C D1A8 0018                  		add.l	d0,_objYPos(a0)			; Add to the Y position
00001D60 4E75                       		rts
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; Check if a specific object is nearby
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; PARAMETERS:
00001D62                            ;	a0.l	- Current object space pointer
00001D62                            ;	a1.l	- Range data pointer
00001D62                            ;	a2.l	- Object to check's space pointer
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; RETURNS:
00001D62                            ;	d0.w	- Return status (0 if not in range, other object's space pointer if in range)
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            CheckObjInRange:
00001D62 7000                       		moveq	#0,d0
00001D64 322A 0014                  		move.w	_objXPos(a2),d1			; Get other object's position
00001D68 342A 0018                  		move.w	_objYPos(a2),d2			; ''
00001D6C 3628 0014                  		move.w	_objXPos(a0),d3			; Get current object's position
00001D70 3828 0018                  		move.w	_objYPos(a0),d4			; ''
00001D74 D659                       		add.w	(a1)+,d3			; Get left boundary
00001D76 3A03                       		move.w	d3,d5				; Copy
00001D78 DA59                       		add.w	(a1)+,d5			; Get right boundary
00001D7A D859                       		add.w	(a1)+,d4			; Get top boundary
00001D7C 3C04                       		move.w	d4,d6				; Copy
00001D7E DC59                       		add.w	(a1)+,d6			; Get bottom boundary
00001D80 B243                       		cmp.w	d3,d1				; Is the object past the left boundary?
00001D82 6500                       		blo.s	.End				; If not, branch
00001D84 B245                       		cmp.w	d5,d1				; Is the object within the horizontal range?
00001D86 6400                       		bhs.s	.End				; If not, branch
00001D88 B444                       		cmp.w	d4,d2				; Is the object past the top boundary?
00001D8A 6500                       		blo.s	.End				; If not, branch
00001D8C B446                       		cmp.w	d6,d2				; Is the object within the vertical range?
00001D8E 6400                       		bhs.s	.End				; If not, branch
00001D90 300A                       		move.w	a2,d0				; Copy other object's RAM space pointer as the return status
00001D92                            
00001D92                            .End:
00001D92 4E75                       		rts
00001D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D94                            ; Object manager
00001D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D94                            ObjectManager:
00001D94 4A38 C7B6                  		tst.b	objMgrInit.w
00001D98 6600                       		bne.s	ObjectManagerMain
00001D9A                            
00001D9A                            ObjectManagerInit:
00001D9A 50F8 C7B6                  		st	objMgrInit.w			; Set the init flag
00001D9E                            
00001D9E 2078 C7B8                  		movea.l	objMgrLayout.w,a0		; Get object data pointer
00001DA2 21C8 C7BC                  		move.l	a0,objMgrLoadR.w
00001DA6 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store address of object layout
00001DAA                            
00001DAA 47F8 9A54                  		lea	objRespawn.w,a3			; Object respawn table
00001DAE                            
00001DAE 3C38 E88A                  		move.w	fgCamXPos.w,d6			; Camera's X position
00001DB2 0446 0080                  		subi.w	#$80,d6				; Subtract 128
00001DB6 6400                       		bhs.s	.NoReset			; Branch if it doesn't go past the left boundary
00001DB8 7C00                       		moveq	#0,d6				; Cap at left boundary
00001DBA                            
00001DBA                            .NoReset:
00001DBA 0246 FF80                  		andi.w	#$FF80,d6			; Keep in chunks of 128 pixels
00001DBE                            
00001DBE 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get address of the object loader for the right side of the screen
00001DC2                            
00001DC2                            .ChkObjsLeft:
00001DC2 BC50                       		cmp.w	(a0),d6				; Compare object position
00001DC4 6300                       		bls.s	.ChkDone			; If higher than d6, branch
00001DC6 5C48                       		addq.w	#6,a0				; Next object
00001DC8 524B                       		addq.w	#1,a3				; Next respawn table index
00001DCA 60F6                       		bra.s	.ChkObjsLeft			; Loop
00001DCC                            
00001DCC                            .ChkDone:
00001DCC 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001DD0 31CB C7C6                  		move.w	a3,objMgrRespL.w			; ''
00001DD4                            
00001DD4 47F8 9A54                  		lea	objRespawn.w,a3			; Object respawn table
00001DD8                            
00001DD8 2078 C7C0                  		movea.l	objMgrLoadL.w,a0
00001DDC 0446 0080                  		subi.w	#$80,d6				; Subtract from camera's X position again
00001DE0 6500                       		bcs.s	.ChkDone2			; But is done to account for the object loader later on
00001DE2                            
00001DE2                            .ChkObjsRight:
00001DE2 BC50                       		cmp.w	(a0),d6				; Compate object position
00001DE4 6300                       		bls.s	.ChkDone2			; If higher than d6, branch
00001DE6 5C48                       		addq.w	#6,a0				; Next object
00001DE8 524B                       		addq.w	#1,a3				; Next respawn table index
00001DEA 60F6                       		bra.s	.ChkObjsRight			; Loop
00001DEC                            
00001DEC                            .ChkDone2:
00001DEC 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001DF0 31CB C7C4                  		move.w	a3,objMgrRespR.w			; ''
00001DF4                            
00001DF4 31FC FFFF C7CC             		move.w	#-1,objMgrCameraX.w			; Reset manager's camera X position
00001DFA 3038 E892                  		move.w	fgCamYPos.w,d0			; Get camera's Y position
00001DFE 0240 FF80                  		andi.w	#$FF80,d0			; Keep in range
00001E02 31C0 C7CE                  		move.w	d0,objMgrCameraY.w			; Store it so unnecessary Y checks shouldn't be done
00001E06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001E06                            ObjectManagerMain:
00001E06 3238 E892                  		move.w	fgCamYPos.w,d1			; Get camera's Y position
00001E0A 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E0E 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E12 31C1 C7CA                  		move.w	d1,objMgrCoarseY.w		; Store this
00001E16                            
00001E16 3238 E88A                  		move.w	fgCamXPos.w,d1			; Get camera's X position
00001E1A 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E1E 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E22 31C1 C7C8                  		move.w	d1,objMgrCoarseX.w		; Store this
00001E26                            		
00001E26 49F9 0000 0000             		lea	Level_ObjIndex,a4		; Level object index
00001E2C                            
00001E2C 3638 E892                  		move.w	fgCamYPos.w,d3			; Get camera's Y position
00001E30 0243 FF80                  		andi.w	#$FF80,d3			; Keep in range
00001E34 3803                       		move.w	d3,d4				; Copy
00001E36 0644 0200                  		addi.w	#$200,d4			; Lower Y boundary
00001E3A 0443 0080                  		subi.w	#$80,d3				; Upper Y boundary
00001E3E 6A00                       		bpl.s	.SetNoWrap			; If still positive, branch
00001E40 7600                       		moveq	#0,d3				; Cap at upper level boundary
00001E42                            
00001E42                            .SetNoWrap:
00001E42 3A3C 0FFF                  		move.w	#$FFF,d5
00001E46 3C38 E88A                  		move.w	fgCamXPos.w,d6			; Get camera's X position
00001E4A 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001E4E BC78 C7CC                  		cmp.w	objMgrCameraX.w,d6			; Check against last range
00001E52 6700 0000                  		beq.w	Level_LoadObjs_SameXRange	; Branch if they are the same
00001E56 6C00                       		bge.s	Level_LoadObjs_Forward		; If new range is greater than the last, branch
00001E58                            
00001E58 31C6 C7CC                  		move.w	d6,objMgrCameraX.w			; Set new range
00001E5C                            
00001E5C 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001E60 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001E64                            
00001E64 0446 0080                  		subi.w	#$80,d6				; Subtract 128 from the X position
00001E68 6500                       		blo.s	.EndLoad			; If outside of the level boundary, branch
00001E6A                            
00001E6A 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E6E 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E70                            
00001E70                            .LoadLoop:
00001E70 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is in range
00001E74 6C00                       		bge.s	.EndLoadRst			; If not, branch
00001E76 5D88                       		subq.l	#6,a0				; Get actual object address
00001E78 534B                       		subq.w	#1,a3				; Get acutal respawn table address
00001E7A                            
00001E7A 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E7E 6700                       		beq.s	.LoadFail			; Branch if it could not be loaded
00001E80 5D88                       		subq.l	#6,a0
00001E82 60EC                       		bra.s	.LoadLoop			; Attempt to load another object
00001E84                            
00001E84                            .LoadFail:
00001E84 5C88                       		addq.l	#6,a0				; Undo object loading
00001E86 524B                       		addq.w	#1,a3
00001E88 6000                       		bra.s	.EndLoad
00001E8A                            .EndLoadRst:
00001E8A 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001E8E                            
00001E8E                            .EndLoad:
00001E8E 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001E92 31CB C7C4                  		move.w	a3,objMgrRespR.w
00001E96                            
00001E96 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get current objects on the right side of the screen
00001E9A 3678 C7C6                  		movea.w	objMgrRespL.w,a3			; And the appropriate respawn list
00001E9E                            
00001E9E 0646 0300                  		addi.w	#$300,d6			; Load 2 chunks forward
00001EA2                            
00001EA2                            .ChkLoop:
00001EA2 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is out of range
00001EA6 6E00                       		bgt.s	.ChkDone			; If so, branch
00001EA8 5D88                       		subq.l	#6,a0				; Get the object before this
00001EAA 534B                       		subq.w	#1,a3				; And its respawn index
00001EAC 60F4                       		bra.s	.ChkLoop			; Check next object
00001EAE                            
00001EAE                            .ChkDone:
00001EAE 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001EB2 31CB C7C6                  		move.w	a3,objMgrRespL.w
00001EB6 6000                       		bra.s	Level_LoadObjs_SameXRange	; Continue
00001EB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001EB8                            Level_LoadObjs_Forward:
00001EB8 31C6 C7CC                  		move.w	d6,objMgrCameraX.w			; Set new range
00001EBC                            
00001EBC 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get current objects on the right side of the screen
00001EC0 3678 C7C6                  		movea.w	objMgrRespL.w,a3			; And the appropriate respawn list
00001EC4                            
00001EC4 0646 0280                  		addi.w	#$280,d6			; Load 2 chunks forward
00001EC8                            
00001EC8 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001ECC 6700                       		beq.s	.EndLoad			; Branch if it failed
00001ECE                            
00001ECE                            .LoadLoop:
00001ECE BC50                       		cmp.w	(a0),d6				; Check if the last obhect is in range
00001ED0 6300                       		bls.s	.EndLoadRst			; If not, branch
00001ED2 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001ED6 6700                       		beq.s	.EndLoad			; If it failed to, branch
00001ED8 524B                       		addq.w	#1,a3				; Get acutal respawn table address
00001EDA 60F2                       		bra.s	.LoadLoop
00001EDC                            
00001EDC                            .EndLoadRst:
00001EDC 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001EE0                            
00001EE0                            .EndLoad:
00001EE0 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001EE4 31CB C7C6                  		move.w	a3,objMgrRespL.w
00001EE8                            
00001EE8 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001EEC 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001EF0                            
00001EF0 0446 0300                  		subi.w	#$300,d6			; Check 1 chunk backwards
00001EF4 6500                       		blo.s	.ChkDone			; If outside of level, branch
00001EF6                            
00001EF6                            .ChkLoop:
00001EF6 BC50                       		cmp.w	(a0),d6				; Check if the last object is out of range
00001EF8 6300                       		bls.s	.ChkDone			; If so, branch
00001EFA 5C88                       		addq.l	#6,a0				; Get the object before this
00001EFC 524B                       		addq.w	#1,a3				; And its respawn index
00001EFE 60F6                       		bra.s	.ChkLoop			; Check next object
00001F00                            
00001F00                            .ChkDone:
00001F00 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001F04 31CB C7C4                  		move.w	a3,objMgrRespR.w
00001F08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F08                            Level_LoadObjs_SameXRange:
00001F08 3C38 E892                  		move.w	fgCamYPos.w,d6			; Get camera's X position
00001F0C 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001F10 3606                       		move.w	d6,d3				; Copy
00001F12 BC78 C7CE                  		cmp.w	objMgrCameraY.w,d6			; Check against last range
00001F16 6700 0000                  		beq.w	.LoadEnd			; Branch if they are the same
00001F1A 6C00                       		bge.s	.MovingDown			; If the new raqnge is greater than the last, branch
00001F1C                            
00001F1C 0443 0080                  		subi.w	#$80,d3				; Loop 1 chunk up
00001F20 6B00 0000                  		bmi.w	.LoadEnd
00001F24 6000                       		bra.s	.YCheck
00001F26                            
00001F26                            .MovingDown:
00001F26 0643 0180                  		addi.w	#$180,d3			; Look 1 chunk down
00001F2A                            
00001F2A                            .YCheck:
00001F2A 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001F2E 6700                       		beq.s	.LoadEnd			; If failed, branch
00001F30                            		
00001F30 3803                       		move.w	d3,d4				; Copy Y position
00001F32 0644 0080                  		addi.w	#$80,d4				; Look one chunk down
00001F36 3A3C 0FFF                  		move.w	#$FFF,d5
00001F3A                            
00001F3A 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001F3E 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001F42 2E38 C7BC                  		move.l	objMgrLoadR.w,d7			; Get current objects on the right side of the screen
00001F46 9E88                       		sub.l	a0,d7				; Subtract the left position from the right
00001F48 6700                       		beq.s	.LoadEndRst			; Branch if no objects
00001F4A 5488                       		addq.l	#2,a0				; Align to object's Y position
00001F4C                            
00001F4C                            .LoadNext:
00001F4C 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F4E 6B00                       		bmi.s	.LoadFail			; If so, branch
00001F50                            
00001F50 3210                       		move.w	(a0),d1				; Get object's Y position
00001F52 C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F54 B243                       		cmp.w	d3,d1
00001F56 6500                       		blo.s	.LoadFail			; Branch if out of range in the top
00001F58 B244                       		cmp.w	d4,d1
00001F5A 6200                       		bhi.s	.LoadFail			; Branch if out of range in the botoom
00001F5C                            
00001F5C 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F60 3368 FFFE 0014             		move.w	-2(a0),_objXPos(a1)			; Set X position
00001F66 3210                       		move.w	(a0),d1				; Get object's Y position
00001F68 3401                       		move.w	d1,d2				; Copy it
00001F6A C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F6C 3341 0018                  		move.w	d1,_objYPos(a1)			; Set Y position
00001F70                            
00001F70 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F72 0242 0003                  		andi.w	#3,d2				; ''
00001F76 1342 000D                  		move.b	d2,_objRender(a1)			; Set render flags
00001F7A 1342 0028                  		move.b	d2,_objStatus(a1)			; Set status
00001F7E                            
00001F7E 1428 0002                  		move.b	2(a0),d2			; Get ID
00001F82 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001F84 D442                       		add.w	d2,d2
00001F86 22B4 2000                  		move.l	(a4,d2.w),_objAddress(a1)		; Set address
00001F8A                            
00001F8A 1368 0003 0024             		move.b	3(a0),_objSubtype(a1)		; Set subtype
00001F90 334B 0026                  		move.w	a3,_objRespawn(a1)			; Set respawn address
00001F94                            
00001F94 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00001F98 6700                       		beq.s	.LoadEnd			; If none could be loaded, branch
00001F9A                            
00001F9A                            .LoadFail:
00001F9A 5C88                       		addq.l	#6,a0				; Next object
00001F9C 524B                       		addq.w	#1,a3				; ''
00001F9E 5D87                       		subq.l	#6,d7				; Subtract the size of the entry
00001FA0 66AA                       		bne.s	.LoadNext			; If there are some objects remaining, branch
00001FA2                            
00001FA2                            .LoadEndRst:
00001FA2 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001FA6                            
00001FA6                            .LoadEnd:
00001FA6 31C6 C7CE                  		move.w	d6,objMgrCameraY.w		; Store manager's camera Y position
00001FAA 4E75                       		rts
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            ; Load an object from the object layout
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            ; PARAMETERS:
00001FAC                            ;	d3.w	- Upper boundary
00001FAC                            ;	d4.w	- Lower boundary
00001FAC                            ;	d5.w	- Y position limit
00001FAC                            ;	a0.l	- Index of object layout
00001FAC                            ;	a1.l	- Target object
00001FAC                            ;	a3.l	- Respawn table address
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            Level_LoadObject:
00001FAC 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001FAE 6A00                       		bpl.s	.NotLoaded			; If not, branch
00001FB0 5C88                       		addq.l	#6,a0				; Next object
00001FB2 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FB4 4E75                       		rts
00001FB6                            
00001FB6                            .NotLoaded:
00001FB6 3E18                       		move.w	(a0)+,d7			; X position
00001FB8 3218                       		move.w	(a0)+,d1			; Y position
00001FBA 3401                       		move.w	d1,d2				; Copy
00001FBC 6B00                       		bmi.s	.LoadNoY			; If the object is set to ignore Y checks, branch
00001FBE C245                       		and.w	d5,d1				; Keey Y in range
00001FC0 B243                       		cmp.w	d3,d1
00001FC2 6500                       		bcs.s	.End				; Branch if in range
00001FC4 B244                       		cmp.w	d4,d1
00001FC6 6300                       		bls.s	.Spawn				; Branch if in range
00001FC8                            
00001FC8                            .End:
00001FC8 5448                       		addq.w	#2,a0				; Next objeect
00001FCA 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FCC 4E75                       		rts
00001FCE                            
00001FCE                            .LoadNoY:
00001FCE C245                       		and.w	d5,d1				; Keey Y in range
00001FD0                            
00001FD0                            .Spawn:
00001FD0 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001FD4 3347 0014                  		move.w	d7,_objXPos(a1)			; Store X position
00001FD8 3341 0018                  		move.w	d1,_objYPos(a1)			; Store Y position
00001FDC                            
00001FDC E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001FDE 0242 0003                  		andi.w	#3,d2				; ''
00001FE2 1342 000D                  		move.b	d2,_objRender(a1)			; Set render flags
00001FE6 1342 0028                  		move.b	d2,_objStatus(a1)			; Set status
00001FEA                            
00001FEA 1418                       		move.b	(a0)+,d2			; Get ID
00001FEC D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001FEE D442                       		add.w	d2,d2
00001FF0 22B4 2000                  		move.l	(a4,d2.w),_objAddress(a1)		; Set address
00001FF4                            
00001FF4 1358 0024                  		move.b	(a0)+,_objSubtype(a1)		; Set subtype
00001FF8 334B 0026                  		move.w	a3,_objRespawn(a1)			; Set respawn address
00001FFC                            		
00001FFC 6000 FA1E                  		bra.w	FindFreeObj			; Find a free object slot
00002000                            		
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; Check if the object is in range on the camera. If it isn't, delete it
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; PARAMETERS:
00002000                            ;	a0.l	- Object space pointer
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; RETURNS:
00002000                            ;	Nothing
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            CheckObjActive:
00002000 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00002004                            
00002004                            CheckObjActive2:
00002004 0240 FF80                  		andi.w	#$FF80,d0			; Only allow multiples of $80
00002008 9078 C7C8                  		sub.w	objMgrCoarseX.w,d0		; Subtract the camera's coarse X position
0000200C 0C40 0280                  		cmpi.w	#$280,d0			; Has it gone offscreen?
00002010 6200                       		bhi.s	.Delete				; If so, branch
00002012 4E75                       		rts
00002014                            
00002014                            .Delete:
00002014 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table entry address
00002018 6700                       		beq.s	.DoDelete			; If 0, branch
0000201A 3440                       		movea.w	d0,a2
0000201C 0892 0007                  		bclr	#7,(a2)				; Mark as gone
00002020                            
00002020                            .DoDelete:
00002020 4EF8 1A4C                  		jmp	DeleteObject.w			; Delete the object
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; Get orientation to player
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; PARAMETERS:
00002024                            ;	a0.l	- Object space pointer
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; RETURNS:
00002024                            ;	a1.l	- Player object
00002024                            ;	d0.w	- 0 if player is left from object, 2 if right
00002024                            ;	d1.w	- 0 if player is above object, 2 if below
00002024                            ;	d2.w	- Player's horizontal distance to object
00002024                            ;	d3.w	- Player's vertical distance to object
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            GetOrientToPlayer:
00002024 7000                       		moveq	#0,d0
00002026 7200                       		moveq	#0,d1
00002028                            
00002028 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get player object
0000202C                            
0000202C 3428 0014                  		move.w	_objXPos(a0),d2			; Get horizonal distance
00002030 9469 0014                  		sub.w	_objXPos(a1),d2			; ''
00002034 6A00                       		bpl.s	.GetY				; Branch if the player is left from the object
00002036 5440                       		addq.w	#2,d0				; Set flag to indicate that the player is right from the object
00002038                            
00002038                            .GetY:
00002038 3628 0018                  		move.w	_objYPos(a0),d3			; Get vertical distance
0000203C 9669 0018                  		sub.w	_objYPos(a1),d3			; ''
00002040 6400                       		bhs.s	.End				; Branch if the player is above the object
00002042 5441                       		addq.w	#2,d1				; Set flag to indicate that the player is below the object
00002044                            
00002044                            .End:
00002044 4E75                       		rts
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; Cap an object's speed
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; PARAMETERS:
00002046                            ;	a0.l	- Object space pointer
00002046                            ;	d0.w	- Max X speed
00002046                            ;	d1.w	- Max Y speed
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; RETURNS:
00002046                            ;	Nothing
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            CapObjSpeed:
00002046 3428 001C                  		move.w	_objXVel(a0),d2			; Get X velocity
0000204A 6A00                       		bpl.s	.ChkRight			; If we are going right, branch
0000204C 4440                       		neg.w	d0				; Get absolute speed
0000204E B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002050 6400                       		bhs.s	.ChkUp				; If not, branch
00002052 3400                       		move.w	d0,d2				; Cap the speed
00002054 6000                       		bra.s	.ChkUp				; Continue
00002056                            
00002056                            .ChkRight:
00002056 B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002058 6300                       		bls.s	.ChkUp				; If not, branch
0000205A 3400                       		move.w	d0,d2				; Cap the speed
0000205C                            
0000205C                            .ChkUp:
0000205C 3628 001E                  		move.w	_objYVel(a0),d3			; Get Y velocity
00002060 6A00                       		bpl.s	.ChkDown			; If we are going right, branch
00002062 4441                       		neg.w	d1				; Get absolute speed
00002064 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
00002066 6400                       		bhs.s	.UpdateVel			; If not, branch
00002068 3601                       		move.w	d1,d3				; Cap the speed
0000206A 6000                       		bra.s	.UpdateVel			; Continue
0000206C                            
0000206C                            .ChkDown:
0000206C B641                       		cmp.w	d1,d3				; Has it gone over the limit?
0000206E 6300                       		bls.s	.UpdateVel			; If not, branch
00002070 3601                       		move.w	d1,d3				; Cap the speed
00002072                            
00002072                            .UpdateVel:
00002072 3142 001C                  		move.w	d2,_objXVel(a0)			; Set X velocity
00002076 3142 001E                  		move.w	d2,_objYVel(a0)			; Set Y velocity
0000207A 4E75                       		rts
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; Load a child object	NTP: no idea wtf to do about this one. do we even need it since all objects are kinda linked anyway? we'll have to see
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; PARAMETERS:
0000207C                            ;	a2.l	- Object data
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; RETURNS:
0000207C                            ;	Nothing
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; LoadChildObject:
0000207C 6100 F99E                  		bsr.w	FindFreeObj			; Find a free object slot
00002080 6600                       		bne.s	.End				; If there is non, branch
00002082 301A                       		move.w	(a2)+,d0			; Get parent object SST
00002084 3388 0000                  		move.w	a0,(a1,d0.w)			; Store parent object
00002088 301A                       		move.w	(a2)+,d0			; Get child object SST
0000208A 3189 0000                  		move.w	a1,(a0,d0.w)			; Store child object
0000208E 229A                       		move.l	(a2)+,_objAddress(a1)			; Set object pointer
00002090 135A 0024                  		move.b	(a2)+,_objSubtype(a1)		; Set subtype
00002094 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)			; Set X
0000209A 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)			; Set Y
000020A0                            
000020A0                            .End:
000020A0 4E75                       		rts
000020A2                            ; =========================================================================================================================================================
000020A2                            		include	"Libraries/Interrupt.asm"	; Interrupt functions
000020A2                            ; =========================================================================================================================================================
000020A2                            ; Interrupt functions
000020A2                            ; =========================================================================================================================================================
000020A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A2                            ; Vertical Interrupts
000020A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A2                            VInt_Standard:
000020A2                            		intsOff					; Turn interrupts off
000020A2 007C 0700                M 	ori	#$700,sr
000020A6                            		push.l	d0-a6				; Save registers
000020A6 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000020AA                            		
000020AA 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
000020B0 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
000020B4                            
000020B4                            .WaitForVBLANK:
000020B4 3016                       		move.w	(a6),d0				; Get VDP status
000020B6 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
000020BA 67F8                       		beq.s	.WaitForVBLANK			; If not, wait
000020BC                            
000020BC 0838 0006 C746             		btst	#6,hwVersion.w		; Is this a PAL system?
000020C2 6700                       		beq.s	.SetVScroll			; If not, branch
000020C4 303C 0700                  		move.w	#$700,d0			; Do a delay
000020C8 51C8 FFFE                  		dbf	d0,*				; ''
000020CC                            
000020CC                            .SetVScroll:
000020CC                            		dma68k	vScrollBuff,0,$50,VSRAM		; Load VScroll buffer into VSRAM
000020CC 2CBC 9400 9328           M 	move.l	#$94009300|(((($50)/2)&$ff00)<<8)|((($50)/2)&$ff),(a6)
000020D2 2CBC 96CA 953F           M 	move.l	#$96009500|((((vscrollbuff)/2)&$ff00)<<8)|(((vscrollbuff)/2)&$ff),(a6)
000020D8 3CBC 977F                M 	move.w	#$9700|(((vscrollbuff)>>17)&$7f),(a6)
000020DC                          M 	vdpcmd	move.w,0,vsram,dma,>>16,(a6)
000020DC 3CBC 4000                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000020E0                          M 	vdpcmd	move.w,0,vsram,dma,&$ffff,-(sp)
000020E0 3F3C 0090                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000020E4 3C9F                     M 	move.w	(sp)+,(a6)
000020E6                            
000020E6 4A38 C747                  		tst.b	vIntRoutine.w			; Is the game lagging?
000020EA 6700 0000                  		beq.w	VInt_Lag_Main			; If so, branch
000020EE 4238 C74A                  		clr.b	lagCounter.w			; Clear lag frame counter
000020F2                            
000020F2 7000                       		moveq	#0,d0
000020F4 1038 C747                  		move.b	vIntRoutine.w,d0		; Get V-INT routine ID
000020F8 4238 C747                  		clr.b	vIntRoutine.w			; Clear V-INT routine ID
000020FC 50F8 C74B                  		st	hIntFlag.w			; Allow the H-INT to run
00002100 303B 0000                  		move.w	VInt_Routines(pc,d0.w),d0	; Get V-INT routine offset
00002104 4EBB 0000                  		jsr	VInt_Routines(pc,d0.w)		; Jump to the routine
00002108                            
00002108                            VInt_FinishUpdates:
00002108 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
0000210E                            
0000210E                            VInt_End:
0000210E 52B8 C758                  		addq.l	#1,frameCounter.w		; Increment frame count
00002112 6100 F23A                  		bsr.w	RandomNumber			; Generate a random number
00002116                            		
00002116                            		pop.l	d0-a6				; Restore registers
00002116 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000211A                            		intsOn					; Turn interrupts on
0000211A 027C F8FF                M 	andi	#$f8ff,sr
0000211E                            		lagOn					; Turn on the lag-o-meter
0000211E 4E73                       		rte
00002120                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002120                            ; V-INT routines
00002120                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002120                            VInt_Routines:
00002120 0000                       		dc.w	VInt_Lag-VInt_Routines		; Lag routine
00002122 0000                       		dc.w	VInt_General-VInt_Routines	; General routine
00002124 0000                       		dc.w	VInt_Level-VInt_Routines	; Level routine
00002126 0000                       		dc.w	VInt_LevelLoad-VInt_Routines	; Level load routine
00002128 0000                       		dc.w	VInt_Title-VInt_Routines	; Title screen routine
0000212A 0000                       		dc.w	VInt_Fade-VInt_Routines		; Fade routine
0000212C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000212C                            ; V-INT lag routine
0000212C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000212C                            VInt_Lag:
0000212C 584F                       		addq.w	#4,sp				; Don't return to caller
0000212E                            
0000212E                            VInt_Lag_Main:
0000212E 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
00002132 6600                       		bne.s	.WaterPal			; If so, branch
00002134                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
00002134 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000213A 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002140 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
00002144                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002144 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002148                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002148 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000214C 3C9F                     M 	move.w	(sp)+,(a6)
0000214E 6000                       		bra.s	.Cont				; Continue
00002150                            
00002150                            .WaterPal:
00002150                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002150 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002156 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
0000215C 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002160                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002160 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002164                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002164 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002168 3C9F                     M 	move.w	(sp)+,(a6)
0000216A                            
0000216A                            .Cont:	
0000216A 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
0000216E                            
0000216E 5238 C74A                  		addq.b	#1,lagCounter.w		; Increment lag counter
00002172 6000 FF94                  		bra.w	VInt_FinishUpdates		; Go update SMPS
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            ; V-INT general routine
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            VInt_General:
00002176 6100 0000                  		bsr.w	VInt_Update			; Do updates
0000217A 6000 EF5C                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
0000217E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000217E                            ; V-INT level load routine
0000217E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000217E                            VInt_LevelLoad:
0000217E 6100 E93A                  		bsr.w	ReadJoypads			; Read joypads
00002182                            
00002182 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
00002186 6600                       		bne.s	.WaterPal			; If so, branch
00002188                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
00002188 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000218E 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002194 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
00002198                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002198 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000219C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000219C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021A0 3C9F                     M 	move.w	(sp)+,(a6)
000021A2 6000                       		bra.s	.Cont				; Continue
000021A4                            
000021A4                            .WaterPal:
000021A4                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
000021A4 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021AA 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
000021B0 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
000021B4                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021B4 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021B8                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021B8 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021BC 3C9F                     M 	move.w	(sp)+,(a6)
000021BE                            
000021BE                            .Cont:
000021BE 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
000021C2                            		
000021C2                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
000021C2 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000021C8 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
000021CE 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
000021D2                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000021D2 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000021D6                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000021D6 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000021DA 3C9F                     M 	move.w	(sp)+,(a6)
000021DC                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
000021DC 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
000021E2 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
000021E8 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
000021EC                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
000021EC 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
000021F0                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
000021F0 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
000021F4 3C9F                     M 	move.w	(sp)+,(a6)
000021F6 6100 E1B0                  		bsr.w	ProcessDMAQueue			; Process DMA queue
000021FA                            		
000021FA 6000 EEDC                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000021FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021FE                            ; V-INT level routine
000021FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021FE                            VInt_Level:
000021FE 43F8 E88A                  		lea	fgCamVars.w,a1			; Foreground level drawing variables
00002202 47F8 C2A0                  		lea	fgColBuff.w,a3		; Foreground column plane buffer
00002206 49F8 C19E                  		lea	fgRowBuff.w,a4		; Foreground row plane buffer
0000220A 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the foreground plane
00002210 43F8 E8A8                  		lea	bgCamVars.w,a1			; Background level drawing variables
00002214 47F8 C424                  		lea	bgColBuff.w,a3		; Background column plane buffer
00002218 49F8 C322                  		lea	bgRowBuff.w,a4		; Background row plane buffer
0000221C 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the background plane
00002222                            
00002222 6100 E896                  		bsr.w	ReadJoypads			; Read joypads
00002226                            
00002226 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
0000222A 6600                       		bne.s	.WaterPal			; If so, branch
0000222C                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
0000222C 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002232 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002238 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
0000223C                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000223C 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002240                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002240 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002244 3C9F                     M 	move.w	(sp)+,(a6)
00002246 6000                       		bra.s	.Cont				; Continue
00002248                            
00002248                            .WaterPal:
00002248                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002248 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000224E 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
00002254 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002258                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002258 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000225C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000225C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002260 3C9F                     M 	move.w	(sp)+,(a6)
00002262                            
00002262                            .Cont:
00002262 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
00002266                            
00002266                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
00002266 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
0000226C 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
00002272 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
00002276                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
00002276 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000227A                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000227A 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
0000227E 3C9F                     M 	move.w	(sp)+,(a6)
00002280                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002280 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002286 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
0000228C 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
00002290                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002290 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002294                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002294 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002298 3C9F                     M 	move.w	(sp)+,(a6)
0000229A 6100 E10C                  		bsr.w	ProcessDMAQueue			; Process DMA queue
0000229E                            		
0000229E 0C38 005C C761             		cmpi.b	#92,hIntCntValue.w		; Would V-INT be unable to do updates in the next frame?
000022A4 6400                       		bhs.s	.DoUpdates			; If not, branch
000022A6 50F8 C75F                  		st	hIntUpdates.W		; Set updates in H-INT flag
000022AA 584F                       		addq.w	#4,sp				; Skip SMPS update routine afterwards
000022AC 6100 EE2A                  		bsr.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022B0 6000 FE5C                  		bra.w	VInt_End			; Continue
000022B4                            
000022B4                            .DoUpdates:
000022B4 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
000022BA 6000 EE1C                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022BE                            ; V-INT title screen update routine
000022BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022BE                            VInt_Title:
000022BE 4E75                       		rts
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            ;		bsr.w	ReadJoypads			; Read joypads
000022C0                            ;
000022C0                            ;		move.l	#$C0000000,VDP_CTRL		; Write palette to CRAM
000022C0                            ;		lea	paletteBuff.w,a0			; ''
000022C0                            ;		moveq	#$80>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WritePal:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WritePal			; ''
000022C0                            ;
000022C0                            ;		move.l	#$78000003,VDP_CTRL		; Write sprite data to VRAM
000022C0                            ;		lea	spriteBuff.w,a0			; ''
000022C0                            ;		move.w	#$280>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WriteSprs:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WriteSprs			; ''
000022C0                            ;
000022C0                            ;		move.l	#$7C000003,VDP_CTRL		; Write HScroll table to VRAM
000022C0                            ;		lea	hScrollBuff.w,a0			; ''
000022C0                            ;		move.w	#$380>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WriteHScrl:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WriteHScrl			; ''
000022C0                            ;		rts
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            ; Do standard updates in V-INT
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            VInt_Update:
000022C0                            	; NTP: We don't want to update sprites during a fade, thus it's not shared with the below interrupt routine
000022C0                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
000022C0 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000022C6 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
000022CC 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
000022D0                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000022D0 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000022D4                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000022D4 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022D8 3C9F                     M 	move.w	(sp)+,(a6)
000022DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022DA                            ; V-INT fade routine
000022DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022DA                            VInt_Fade:
000022DA 6100 E7DE                  		bsr.w	ReadJoypads			; Read joypads
000022DE                            
000022DE 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
000022E2 6600                       		bne.s	.WaterPal			; If so, branch
000022E4                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
000022E4 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000022EA 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
000022F0 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
000022F4                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000022F4 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000022F8                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000022F8 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000022FC 3C9F                     M 	move.w	(sp)+,(a6)
000022FE 6000                       		bra.s	.Cont				; Continue
00002300                            
00002300                            .WaterPal:
00002300                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002300 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002306 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
0000230C 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002310                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002310 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002314                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002314 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002318 3C9F                     M 	move.w	(sp)+,(a6)
0000231A                            
0000231A                            .Cont:
0000231A 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
0000231E                            
0000231E                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
0000231E 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002324 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
0000232A 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
0000232E                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
0000232E 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002332                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002332 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002336 3C9F                     M 	move.w	(sp)+,(a6)
00002338 6000 E06E                  		bra.w	ProcessDMAQueue			; Process DMA queue
0000233C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233C                            ; V-INT routine that only runs the SMPS driver
0000233C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233C                            VInt_RunSMPS:
0000233C                            		push.l	d0-a6				; Save registers
0000233C 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002340                            		
00002340                            .WaitForVBLANK:
00002340 3039 00C0 0004             		move.w	VDP_CTRL,d0			; Get VDP status
00002346 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
0000234A 67F4                       		beq.s	.WaitForVBLANK			; If not, wait
0000234C                            
0000234C 0838 0006 C746             		btst	#6,hwVersion.w		; Is this a PAL system?
00002352 6700                       		beq.s	.UpdateSMPS			; If not, branch
00002354 303C 0700                  		move.w	#$700,d0			; Do a delay
00002358 51C8 FFFE                  		dbf	d0,*				; ''
0000235C                            
0000235C                            .UpdateSMPS:
0000235C 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002362                            
00002362 52B8 C758                  		addq.l	#1,frameCounter.w		; Increment frame count
00002366 6100 EFE6                  		bsr.w	RandomNumber			; Generate a random number
0000236A                            		
0000236A                            		pop.l	d0-a6				; Restore registers
0000236A 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000236E 4E73                       		rte
00002370                            
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; Wait for the vertical interrupt to run and finish
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; PARAMETERS:
00002370                            ;	Nothing
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; RETURNS:
00002370                            ;	Nothing
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            VSync:
00002370 50F8 C747                  		st	vIntFlag.w			; Set V-INT flag
00002374                            
00002374                            VSync_Routine:
00002374                            		intsOn					; Enable interrupts
00002374 027C F8FF                M 	andi	#$f8ff,sr
00002378                            		lagOff					; Turn off the lag-o-meter
00002378                            
00002378                            .Wait:
00002378 4A38 C747                  		tst.b	vIntFlag.w			; Has the V-INT run yet?
0000237C 66FA                       		bne.s	.Wait				; If not, wait some more
0000237E 4E75                       		rts
00002380                            
00002380                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002380                            ; Horizontal interrupt for palette swapping (for water)
00002380                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002380                            HInt_Water:
00002380                            		intsOff					; Disable interrupts
00002380 007C 0700                M 	ori	#$700,sr
00002384                            
00002384 4A38 C74B                  		tst.b	hIntFlag.w			; Is the H-INT allowed to run?
00002388 6700                       		beq.s	.End				; If not, branch
0000238A 4238 C74B                  		clr.b	hIntFlag.w			; Clear the H-INT flag
0000238E                            
0000238E                            		push.l	a0-a1				; Save registers
0000238E 48E7 00C0                M 	movem.l	a0-a1,-(sp)
00002392                            
00002392 43F9 00C0 0000             		lea	VDP_DATA,a1			; VDP data port
00002398 337C 8AFF 0004             		move.w	#$8AFF,4(a1)			; Don't do any more H-INT calls for the rest of the frame
0000239E 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette
000023A2                            		vdpCmd	move.l, 0, CRAM, WRITE, 4(a1)	; Set VDP command
000023A2 237C C000 0000 0004      M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),4(a1)
000023AA                            		rept	32
000023AA                            			move.l	(a0)+,(a1)		; Tranfer palette
000023AA                            		endr
000023AA 2298                     M 	move.l	(a0)+,(a1)
000023AC 2298                     M 	move.l	(a0)+,(a1)
000023AE 2298                     M 	move.l	(a0)+,(a1)
000023B0 2298                     M 	move.l	(a0)+,(a1)
000023B2 2298                     M 	move.l	(a0)+,(a1)
000023B4 2298                     M 	move.l	(a0)+,(a1)
000023B6 2298                     M 	move.l	(a0)+,(a1)
000023B8 2298                     M 	move.l	(a0)+,(a1)
000023BA 2298                     M 	move.l	(a0)+,(a1)
000023BC 2298                     M 	move.l	(a0)+,(a1)
000023BE 2298                     M 	move.l	(a0)+,(a1)
000023C0 2298                     M 	move.l	(a0)+,(a1)
000023C2 2298                     M 	move.l	(a0)+,(a1)
000023C4 2298                     M 	move.l	(a0)+,(a1)
000023C6 2298                     M 	move.l	(a0)+,(a1)
000023C8 2298                     M 	move.l	(a0)+,(a1)
000023CA 2298                     M 	move.l	(a0)+,(a1)
000023CC 2298                     M 	move.l	(a0)+,(a1)
000023CE 2298                     M 	move.l	(a0)+,(a1)
000023D0 2298                     M 	move.l	(a0)+,(a1)
000023D2 2298                     M 	move.l	(a0)+,(a1)
000023D4 2298                     M 	move.l	(a0)+,(a1)
000023D6 2298                     M 	move.l	(a0)+,(a1)
000023D8 2298                     M 	move.l	(a0)+,(a1)
000023DA 2298                     M 	move.l	(a0)+,(a1)
000023DC 2298                     M 	move.l	(a0)+,(a1)
000023DE 2298                     M 	move.l	(a0)+,(a1)
000023E0 2298                     M 	move.l	(a0)+,(a1)
000023E2 2298                     M 	move.l	(a0)+,(a1)
000023E4 2298                     M 	move.l	(a0)+,(a1)
000023E6 2298                     M 	move.l	(a0)+,(a1)
000023E8 2298                     M 	move.l	(a0)+,(a1)
000023EA                            		pop.l	a0-a1				; Restore registers
000023EA 4CDF 0300                M 	movem.l	(sp)+,a0-a1
000023EE                            		
000023EE 4A38 C75F                  		tst.b	hIntUpdates.w		; Do we need to do level updates in here?
000023F2 6600                       		bne.s	.DoUpdates			; If so, branch
000023F4                            
000023F4                            .End:
000023F4 4E73                       		rte
000023F6                            
000023F6                            .DoUpdates:
000023F6 4238 C75F                  		clr.b	hIntUpdates.w		; Clear the update flag
000023FA                            		push.l	d0-a6				; Save registers
000023FA 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000023FE 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002404 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002408 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
0000240E 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002414                            		pop.l	d0-a6				; Restore registers
00002414 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
00002418 4E73                       		rte
0000241A                            ; =========================================================================================================================================================
0000241A                            
0000241A                            ; =========================================================================================================================================================
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            ; Opmode Main Code
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            		include	"Opmodes/Title/Main.asm"
0000241A                            ; =========================================================================================================================================================
0000241A                            ; Title splash screen
0000241A                            ; =========================================================================================================================================================
0000241A                            locVRAM:	macro loc,controlport
0000241A                            		move.l	#($40000000+(((loc)&$3FFF)<<16)+(((loc)&$C000)>>14)),(VDP_CTRL).l
0000241A                            		endm
0000241A                            
0000241A                            copyTilemap:	macro source,destination,width,height
0000241A                            		lea	(source).l,a1
0000241A                            		locVRAM	destination,d0
0000241A                            		moveq	#width,d1
0000241A                            		moveq	#height,d2
0000241A                            		bsr.w	TilemapToVRAM
0000241A                            		endm
0000241A                            
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            TitleScreen:
0000241A                                    playSnd #Mus_Stop,  1
0000241A 11FC 0003 C4BC           M 	move.b	#mus_stop,(mqueue+((1)-1)).w
00002420 6100 E130                          bsr.w    FadeToBlack
00002424 4BF9 00C0 0004             		lea	VDP_CTRL,a5
0000242A 3ABC 8004                  		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
0000242E 3ABC 8174                  		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
00002432 3ABC 8230                  		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00002436 3ABC 8407                  		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
0000243A 3ABC 9011                  		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
0000243E 3ABC 9200                  		move.w	#$9200,(a5)			; $9200 - Window V position at default
00002442 3ABC 8B00                  		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00002446 3ABC 8700                  		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
0000244A 4278 9000                  		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
0000244E 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
00002454                            
00002454 6100 DDF2                          bsr.w   ClearScreen
00002458 43F9 00FF 0000                     lea (miscbuff).l,  a1
0000245E 41F9 0000 0000                     lea (Eni_SegaLogo).l,   a0
00002464 303C 0000                          move.w  #0, d0
00002468 6100 E964                          bsr.w   EniDec
0000246C                            
0000246C 43F9 00FF 0000             		lea	(miscbuff).l,a1
00002472 203C 4000 0003             		move.l	#$40000003,d0			; At (0, 0) on plane A
00002478 720B                       		moveq	#$B,d1
0000247A 7403                       		moveq	#$3,d2
0000247C 6100 DE0A                  		bsr.w	LoadPlaneMap
00002480                            
00002480 43F9 0000 0000             		lea	KosM_SegaLogo,a1		; Load background art
00002486 343C 0000                  		move.w	#$0,d2				; ''
0000248A 6100 EAD0                  		bsr.w	QueueKosMData			; ''
0000248E                                    
0000248E                            .WaitPLCs:
0000248E 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002494 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
00002498 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
0000249C 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000024A0 4A38 9990                  		tst.b	kosMModules.w			; Are there still modules left?
000024A4 66E8                       		bne.s	.WaitPLCs			; If so, branch
000024A6                            
000024A6 41F9 0000 0000             		lea	WWZ_Pal,a0			; Load palette to target buffer
000024AC 303C 0000                  		move.w	#(WWZ_Pal_End-WWZ_Pal)>>1-1,d0
000024B0 6100 E088                  		bsr.w	LoadTargetPal			; ''
000024B4                            
000024B4 6100 E118                          bsr.w   FadeFromBlack
000024B8                                 ;   RaiseError  "End of title successfully reached"
000024B8                                .loop:
000024B8                            	;	move.b	#gLevel,opmode.w			; Set game mode to "title"
000024B8                            	;	jmp	Level					; Go to the title screen
000024B8                            
000024B8 60FE                       		bra.s	.loop
000024BA                            
000024BA                            KosM_SegaLogo:
000024BA                                    incbin  "Opmodes/Title/Sega Art.bin"
000027F4                            
000027F4                            Eni_SegaLogo:
000027F4                                    incbin  "Opmodes/Title/Sega Map.bin"
00002800                            
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00002800                            ;		playSnd	#Mus_Stop, 1			; Stop sound
00002800                            ;
00002800                            ;		bsr.w	FadeToBlack			; Fade to black
00002800                            ;
00002800                            ;		intsOff					; Disable interrupts
00002800                            ;		clrRAM	kosVars
00002800                            ;		clrRAM	checkpoint
00002800                            ;		clrRAM	opmodeVars
00002800                            ;		clrRAM	objMemory
00002800                            ;
00002800                            ;		lea	VDP_CTRL,a5
00002800                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00002800                            ;		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
00002800                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00002800                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00002800                            ;		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
00002800                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
00002800                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00002800                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00002800                            ;		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
00002800                            ;		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
00002800                            ;
00002800                            ;		bsr.w	ClearScreen			; Clear screen
00002800                            ;
00002800                            ;		lea	palFadeBuff.w,a0			; Fade target palette
00002800                            ;		moveq	#$80>>2-1,d0			; Size
00002800                            ;
00002800                            ;.FillPal:
00002800                            ;		move.l	#$0EEE0EEE,(a0)+		; Fill palette with white
00002800                            ;		dbf	d0,.FillPal			; Loop
00002800                            ;
00002800                            ;		bsr.w	FadeFromBlack			; Fade from black
00002800                            ;		
00002800                            ;		bsr.w	SEGA_FMV			; Run SEGA FMV
00002800                            ;
00002800                            ;TitleScreen2:
00002800                            ;		intsOff
00002800                            ;
00002800                            ;		clr.b	artCheat.w
00002800                            ;		clrRAM	opmodeVars
00002800                            ;		clrRAM	objMemory
00002800                            ;
00002800                            ;		move.w	#$8200|($C000/$400),VDP_CTRL	; Reset plane A address
00002800                            ;		bsr.w	FadeToWhite			; Fade to white
00002800                            ;
00002800                            ;		intsOff
00002800                            ;		bsr.w	ClearScreen			; Clear screen
00002800                            ;
00002800                            ;		lea	MapEni_TitleBG,a0		; Decompress background mappings
00002800                            ;		lea	miscBuff,a1			; Decompress into RAM
00002800                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00002800                            ;		bsr.w	EniDec				; Decompress!
00002800                            ;
00002800                            ;		lea	miscBuff,a1			; Load mappings
00002800                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
00002800                            ;		moveq	#$27,d1				; $28x$1C tiles
00002800                            ;		moveq	#$1B,d2				; ''
00002800                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002800                            ;		bsr.w	LoadPlaneMap			; Load the map
00002800                            ;
00002800                            ;		lea	MapEni_TitleLogo,a0		; Decompress logo mappings
00002800                            ;		lea	miscBuff,a1			; Decompress into RAM
00002800                            ;		move.w	#$8370,d0			; Base tile properties: Tile ID 1, no flags
00002800                            ;		bsr.w	EniDec				; Decompress!
00002800                            ;
00002800                            ;		lea	miscBuff,a1			; Load mappings
00002800                            ;		move.l	#$41040003,d0			; At (0, 0) on plane A
00002800                            ;		moveq	#$E,d1				; $28x$1C tiles
00002800                            ;		moveq	#$C,d2				; ''
00002800                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002800                            ;		bsr.w	LoadPlaneMap			; Load the map
00002800                            ;
00002800                            ;		lea	Pal_Title,a0			; Load palette to target buffer
00002800                            ;		move.w	#(Pal_Title_End-Pal_Title)>>1-1,d0
00002800                            ;		bsr.w	LoadTargetPal			; ''
00002800                            ;
00002800                            ;		lea	ArtKosM_TitleBG,a1		; Load background art
00002800                            ;		move.w	#$20,d2				; ''
00002800                            ;		bsr.w	QueueKosMData			; ''
00002800                            ;
00002800                            ;		lea	ArtKosM_TitleLogo,a1		; Load logo art
00002800                            ;		move.w	#$6E00,d2			; ''
00002800                            ;		bsr.w	QueueKosMData			; ''
00002800                            ;
00002800                            ;		lea	ArtKosM_TtlSonic,a1		; Load Sonic art
00002800                            ;		move.w	#$4000,d2			; ''
00002800                            ;		bsr.w	QueueKosMData			; ''
00002800                            ;
00002800                            ;		lea	ArtKosM_TtlBird,a1		; Load bird art
00002800                            ;		move.w	#$8400,d2			; ''
00002800                            ;		bsr.w	QueueKosMData			; ''
00002800                            ;
00002800                            ;		lea	ArtKosM_TtlGlove,a1		; Load glove art
00002800                            ;		move.w	#$8600,d2			; ''
00002800                            ;		bsr.w	QueueKosMData			; ''
00002800                            ;
00002800                            ;.WaitPLCs:
00002800                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002800                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002800                            ;		jsr	VSync_Routine.w			; V-SYNC
00002800                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002800                            ;		tst.b	kosMModules.w			; Are there still modules left?
00002800                            ;		bne.s	.WaitPLCs			; If so, branch
00002800                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002800                            ;		jsr	VSync_Routine.w			; V-SYNC
00002800                            ;		
00002800                            ;		move.l	#ObjTtlSonic,rObj_0.w		; Load the Sonic object
00002800                            ;		move.w	#320+96,(rObj_0+oX).w		; Set X
00002800                            ;		move.w	#128,(rObj_0+oY).w		; Set Y
00002800                            ;
00002800                            ;		move.l	#ObjTtlBird,rObj_1.w		; Load the bird object
00002800                            ;		move.w	#-64,(rObj_1+oX).w		; Set X
00002800                            ;		move.w	#64,(rObj_1+oY).w		; Set Y
00002800                            ;
00002800                            ;		move.l	#ObjTtlGlove,rObj_2.w		; Load the glove object
00002800                            ;		move.w	#224,(rObj_2+oX).w		; Set X
00002800                            ;		move.w	#320,(rObj_2+oY).w		; Set Y
00002800                            ;
00002800                            ;		jsr	RunObjects.w			; Run objects
00002800                            ;		jsr	RendeobjMemory.w			; Render objects
00002800                            ;
00002800                            ;		clr.w	palCycTimer.w		; Reset palette cycle
00002800                            ;
00002800                            ;		bsr.w	FadeFromWhite			; Fade from white
00002800                            ;
00002800                            ;		lea	SampleList+$C0,a3		; Play title screen music
00002800                            ;		jsr	PlayDAC1			; ''
00002800                            ;
00002800                            ;.Loop:
00002800                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
00002800                            ;		bsr.w	VSync_Routine			; ''
00002800                            ;
00002800                            ;		bsr.s	Title_Updates			; Do updates
00002800                            ;		
00002800                            ;		jsr	RunObjects.w			; Run objects
00002800                            ;		jsr	RendeobjMemory.w			; Render objects
00002800                            ;
00002800                            ;		lea	FreeMove_Cheat(pc),a0
00002800                            ;		lea	moveCheat.w,a1
00002800                            ;		lea	rCheatEntry.w,a2
00002800                            ;		bsr.w	Title_ChkCheats
00002800                            ;		lea	Art_Cheat(pc),a0
00002800                            ;		lea	artCheat.w,a1
00002800                            ;		lea	rCheatEntry2.w,a2
00002800                            ;		bsr.w	Title_ChkCheats
00002800                            ;
00002800                            ;		tst.b	artCheat.w
00002800                            ;		bne.w	BinbowieArt
00002800                            ;
00002800                            ;		tst.b	ctrlPressP1.w			; Has start been pressed
00002800                            ;		bpl.s	.Loop				; If so, branch
00002800                            ;
00002800                            ;		st	(rObj_2+oGloveFlag).w		; Set the punch flag
00002800                            ;
00002800                            ;		lea	SampleList+$E0,a3		; Punch
00002800                            ;		jsr	PlayDAC1			; ''
00002800                            ;
00002800                            ;.PunchLoop:
00002800                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
00002800                            ;		bsr.w	VSync_Routine			; ''
00002800                            ;
00002800                            ;		bsr.s	Title_Updates			; Do updates
00002800                            ;
00002800                            ;		jsr	RunObjects.w			; Run objects
00002800                            ;		jsr	RendeobjMemory.w			; Render objects
00002800                            ;		
00002800                            ;		tst.b	(rObj_2+oGloveTime).w		; Has the timer run out?
00002800                            ;		bpl.s	.PunchLoop			; If not, loop
00002800                            ;		
00002800                            ;		st	rStartFall.w			; Set flag to start the level by falling
00002800                            ;
00002800                            ;		move.b	#gLevel,opmode.w		; Set game mode to "level"
00002800                            ;		jmp	Level				; Go to level
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ; Palette cycle
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;Title_Updates:
00002800                            ;		move.b	rLogoAngle.w,d0		; Get logo hover angle
00002800                            ;		addq.b	#4,rLogoAngle.w		; Increment angle
00002800                            ;		jsr	CalcSine.w			; Get sine
00002800                            ;		asr.w	#5,d0				; ''
00002800                            ;		move.w	d0,vScrollBuffFG.w		; Set logo's Y position
00002800                            ;
00002800                            ;		subq.b	#1,palCycTimer.w		; Decrement timer
00002800                            ;		bpl.s	.End				; If it hasn't run out, branch
00002800                            ;		move.b	#6,palCycTimer.w		; Reset timer
00002800                            ;		
00002800                            ;		moveq	#0,d0
00002800                            ;		move.b	palCycIndex.w,d0		; Get index
00002800                            ;		mulu.w	#$C,d0				; Turn into offset
00002800                            ;		lea	PalCyc_Title(pc,d0.w),a0	; Get pointer to palette data
00002800                            ;		lea	(paletteBuff+$14).w,a1		; Palette
00002800                            ;		move.w	(a0)+,(a1)+			; Load palette
00002800                            ;		move.w	(a0)+,(a1)+			; ''
00002800                            ;		move.w	(a0)+,(a1)+			; ''
00002800                            ;		move.w	(a0)+,(a1)+			; ''
00002800                            ;		move.w	(a0)+,(a1)+			; ''
00002800                            ;		move.w	(a0)+,(a1)+			; ''
00002800                            ;		
00002800                            ;		addq.b	#1,palCycIndex.w		; Increment index
00002800                            ;		cmpi.b	#6,palCycIndex.w		; Has it reached the end?
00002800                            ;		bcs.s	.End				; If not, branch
00002800                            ;		clr.b	palCycIndex.w		; Reset index
00002800                            
00002800                            ;.End:
00002800                            ;		rts
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;PalCyc_Title:
00002800                            ;		dc.w	$00E, $08E, $0EE, $0E0, $E00, $808
00002800                            ;		dc.w	$08E, $0EE, $0E0, $E00, $808, $00E
00002800                            ;		dc.w	$0EE, $0E0, $E00, $808, $00E, $08E
00002800                            ;		dc.w	$0E0, $E00, $808, $00E, $08E, $0EE
00002800                            ;		dc.w	$E00, $808, $00E, $08E, $0EE, $0E0
00002800                            ;		dc.w	$808, $00E, $08E, $0EE, $0E0, $E00
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ; Check for cheats
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;Title_ChkCheats:
00002800                            ;		tst.b	(a1)
00002800                            ;		bne.s	.End
00002800                            ;		move.w	(a2),d0
00002800                            ;		adda.w	d0,a0
00002800                            ;		move.b	ctrlPressP1.w,d0
00002800                            ;		cmp.b	(a0),d0
00002800                            ;		bne.s	.ResetCheat
00002800                            ;		addq.w	#1,(a2)
00002800                            ;		tst.b	d0
00002800                            ;		bne.s	.End
00002800                            ;		st	(a1)
00002800                            ;		playSnd	#sRing, 2
00002800                            ;		rts
00002800                            ;
00002800                            ;.ResetCheat:
00002800                            ;		tst.b	d0
00002800                            ;		beq.s	.End
00002800                            ;		clr.w	(a2)
00002800                            ;
00002800                            ;.End:
00002800                            ;		rts
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;FreeMove_Cheat:
00002800                            ;		dc.b	1, 2, 4, 8, 0, $FF
00002800                            ;		even
00002800                            ;Art_Cheat:
00002800                            ;		dc.b	1, 1, 2, 2, 4, 8, 4, 8, $40, $10, $40, $10, 0, $FF
00002800                            ;		even
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ; BinBowie's art
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;BinbowieArt:
00002800                            ;		bsr.w	FadeToWhite			; Fade to white
00002800                            ;		
00002800                            ;		lea	SampleList,a3
00002800                            ;		jsr	PlayDAC1
00002800                            ;
00002800                            ;		intsOff
00002800                            ;
00002800                            ;		jsr	ClearScreen.w
00002800                            ;
00002800                            ;		lea	MapEni_BinBowieArt(pc),a0	; Decompress mappings
00002800                            ;		lea	miscBuff,a1			; Decompress into RAM
00002800                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00002800                            ;		bsr.w	EniDec				; Decompress!
00002800                            ;
00002800                            ;		lea	miscBuff,a1			; Load mappings
00002800                            ;		move.l	#$40000003,d0			; At (0, 0) on plane A
00002800                            ;		moveq	#$27,d1				; $28x$1C tiles
00002800                            ;		moveq	#$1B,d2				; ''
00002800                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002800                            ;		bsr.w	LoadPlaneMap			; Load the map
00002800                            ;
00002800                            ;		lea	Pal_BinBowieArt,a0		; Load palette to target buffer
00002800                            ;		move.w	#(Pal_BinBowieArt_End-Pal_BinBowieArt)>>1-1,d0
00002800                            ;		bsr.w	LoadTargetPal			; ''
00002800                            ;
00002800                            ;		lea	ArtKosM_BinBowieArt,a1		; Load art
00002800                            ;		move.w	#$20,d2				; ''
00002800                            ;		bsr.w	QueueKosMData			; ''
00002800                            ;
00002800                            ;.WaitPLCs:
00002800                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002800                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002800                            ;		jsr	VSync_Routine.w			; V-SYNC
00002800                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002800                            ;		tst.b	kosMModules.w			; Are there still modules left?
00002800                            ;		bne.s	.WaitPLCs			; If so, branch
00002800                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002800                            ;		jsr	VSync_Routine.w			; V-SYNC
00002800                            ;
00002800                            ;		jsr	FadeFromWhite.w
00002800                            ;
00002800                            ;		lea	SampleList+$100,a3
00002800                            ;		jsr	PlayDAC1
00002800                            ;
00002800                            ;.Loop:
00002800                            ;		move.b	#vTitle,vIntRoutine.w		; Level load V-INT routine
00002800                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002800                            ;		move.b	ctrlPressP1.w,d0
00002800                            ;		andi.b	#%10010000,d0
00002800                            ;		beq.s	.Loop
00002800                            ;
00002800                            ;		jmp	TitleScreen2
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ; Objects
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;		include	"Title Screen/Objects/Sonic/Code.asm"
00002800                            ;		include	"Title Screen/Objects/Bird/Code.asm"
00002800                            ;		include	"Title Screen/Objects/Glove/Code.asm"
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ; Art
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;ArtKosM_TitleBG:
00002800                            ;		incbin	"Title Screen/Data/Art - Background.kosm.bin"
00002800                            ;		even
00002800                            ;ArtKosM_TitleLogo:
00002800                            ;		incbin	"Title Screen/Data/Art - Logo.kosm.bin"
00002800                            ;		even
00002800                            ;ArtKosM_BinBowieArt:
00002800                            ;		incbin	"Title Screen/Data/Art - BinBowie.kosm.bin"
00002800                            ;		even
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ; Plane mappings
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;MapEni_TitleBG:
00002800                            ;		incbin	"Title Screen/Data/Map - Background.eni.bin"
00002800                            ;		even
00002800                            ;MapEni_TitleLogo:
00002800                            ;		incbin	"Title Screen/Data/Map - Logo.eni.bin"
00002800                            ;		even
00002800                            ;MapEni_BinBowieArt:
00002800                            ;		incbin	"Title Screen/Data/Map - BinBowie.eni.bin"
00002800                            ;		even
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ; Palette
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;Pal_Title:
00002800                            ;		incbin	"Title Screen/Data/Palette.pal.bin"
00002800                            ;Pal_Title_End:
00002800                            ;		even
00002800                            ;Pal_BinBowieArt:
00002800                            ;		incbin	"Title Screen/Data/BinBowie Palette.pal.bin"
00002800                            ;Pal_BinBowieArt_End:
00002800                            ;		even
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ; SEGA FMV
00002800                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002800                            ;		include	"Title Screen/SEGA FMV/FMV.asm"
00002800                            ; =========================================================================================================================================================
00002800                            		include	"Opmodes/Gameplay/Main.asm"
00002800                            ; =========================================================================================================================================================
00002800                            ; Level
00002800                            ; =========================================================================================================================================================
00002800                            Level:
00002800                            		playSnd	#Mus_FadeOut, 1			; Fade out sound
00002800 11FC 0002 C4BC           M 	move.b	#mus_fadeout,(mqueue+((1)-1)).w
00002806                            
00002806 4EB8 0552                  		jsr	FadeToBlack			; Fade to black
0000280A                            
0000280A                            Level_NoFade:
0000280A                            		; --- Set up the VDP ---
0000280A                            
0000280A                            		intsOff					; Disable interrupts
0000280A 007C 0700                M 	ori	#$700,sr
0000280E                            		displayOff				; Disable display
0000280E 3038 C766                M 	move.w	vdpreg1.w,d0
00002812 0200 00BF                M 	andi.b	#%10111111,d0
00002816 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
0000281C                            
0000281C 4BF9 00C0 0004             		lea	VDP_CTRL,a5			; VDP control port
00002822 3ABC 8004                  		move.w	#$8004,(a5)			; Disable H-INT
00002826 3ABC 8230                  		move.w	#$8230,(a5)			; Plane A at $C000
0000282A 3ABC 8407                  		move.w	#$8407,(a5)			; Plane B at $E000
0000282E 3ABC 8720                  		move.w	#$8720,(a5)			; Set background color to palette line 2, entry 0
00002832 3ABC 8B03                  		move.w	#$8B03,(a5)			; V-Scroll by screen, H-Scroll by scanline
00002836 3ABC 9001                  		move.w	#$9001,(a5)			; 64x32 cell plane area
0000283A 303C 9200                  		move.w	#$9200,d0			; Make the window invisible
0000283E 31C0 C768                  		move.w	d0,vdpWindowY.w			; ''
00002842 3A80                       		move.w	d0,(a5)				; ''
00002844 4278 9000                  		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
00002848 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
0000284E                            
0000284E 4EB8 0248                  		jsr	ClearScreen.w			; Clear the screen
00002852                            
00002852                            		; --- Clear some RAM ---
00002852                            
00002852                            		clrRAM	kosVars			; Clear Kosinski queue variables
00002852                          M 	local	endaddr
00002852                          M endaddr	equs	"kosvars_End"
00002852 7000                     M 	moveq	#0,d0
00002854 43F8 994E                M 	lea	(kosvars).w,a1
00002858 323C 0040                M 	move.w	#(((kosvars_end)-(kosvars))-((kosvars)&1))>>2-1,d1
0000285C 22C0                     M .clear_135:	move.l	d0,(a1)+
0000285E 51C9 FFFC                M 	dbf	d1,.clear_135
00002862 32C0                     M 	move.w	d0,(a1)+
00002864                            		clrRAM	opmodeVars			; Clear variables
00002864                          M 	local	endaddr
00002864                          M endaddr	equs	"opmodevars_End"
00002864 7000                     M 	moveq	#0,d0
00002866 43F8 C7D2                M 	lea	(opmodevars).w,a1
0000286A 323C 0DCA                M 	move.w	#(((opmodevars_end)-(opmodevars))-((opmodevars)&1))>>2-1,d1
0000286E 22C0                     M .clear_136:	move.l	d0,(a1)+
00002870 51C9 FFFC                M 	dbf	d1,.clear_136
00002874 32C0                     M 	move.w	d0,(a1)+
00002876                            		clrRAM	oscillators			; Clear oscillation data
00002876                          M 	local	endaddr
00002876                          M endaddr	equs	"oscillators_End"
00002876 7000                     M 	moveq	#0,d0
00002878 43F8 C76C                M 	lea	(oscillators).w,a1
0000287C 323C 000F                M 	move.w	#(((oscillators_end)-(oscillators))-((oscillators)&1))>>2-1,d1
00002880 22C0                     M .clear_137:	move.l	d0,(a1)+
00002882 51C9 FFFC                M 	dbf	d1,.clear_137
00002886 32C0                     M 	move.w	d0,(a1)+
00002888                            
00002888                            		; --- Do some final initializing and play the level music ---
00002888                            
00002888 11FC 0003 E861             		move.b	#3,ringAnimTime.w		; Set ring animation timer
0000288E 31FC 001E E90A             		move.w	#30,rFloorTimer.w		; Set floor timer
00002894 4278 C7D0                  		clr.w	palCycTimer.w		; Reset palette cycle
00002898                            
00002898 41FA 0000                  		lea	Level_MusicIDs(pc),a0		; Music ID list
0000289C 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
000028A0 E218                       		ror.b	#1,d0				; Turn into offset
000028A2 EE48                       		lsr.w	#7,d0				; ''
000028A4 1030 0000                  		move.b	(a0,d0.w),d0			; Get music ID
000028A8 11C0 E8E0                  		move.b	d0,lvlMusic.w		; Store it
000028AC                            		playSnd	d0, 1				; Play it
000028AC 11C0 C4BC                M 	move.b	d0,(mqueue+((1)-1)).w
000028B0                            
000028B0                            		intsOn					; Enable interrupts
000028B0 027C F8FF                M 	andi	#$f8ff,sr
000028B4                            
000028B4                            		; --- Load level data ---
000028B4                            
000028B4 47F9 0000 0000             		lea	PLC_LevelMain,a3		; Load main level PLCs
000028BA 4EB8 0F4C                  		jsr	LoadKosMQueue.w			; ''
000028BE                            
000028BE 4EB8 19BE                  		jsr	InitObjectList.w
000028C2                            
000028C2 4EB8 1A1C                  		jsr	FindFreeObj.w
000028C6 22BC 0000 0000             		move.l	#ObjPlayer,_objAddress(a1)		; Load Player object
000028CC 31C9 E876                  		move.w	a1,playerPtrP1.w		; Store the address
000028D0                            
000028D0 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
000028D4 6700                       		beq.s	.NoSurface			; If not, branch
000028D6                            
000028D6                            							; Load water surfaces
000028D6 4EB8 1A1C                  		jsr	FindFreeObj.w
000028DA 22BC 0000 0000             		move.l	#ObjWaterSurface,_objAddress(a1)
000028E0 337C 0060 0014             		move.w	#$60,_objXPos(a1)
000028E6 31C9 E886                  		move.w	a1,waterObjPtr1.w		; Store the address
000028EA                            
000028EA 4EB8 1A1C                  		jsr	FindFreeObj.w
000028EE 22BC 0000 0000             		move.l	#ObjWaterSurface,_objAddress(a1)
000028F4 337C 0120 0014             		move.w	#$120,_objXPos(a1)
000028FA 31C9 E888                  		move.w	a1,waterObjPtr2.w		; Store the address
000028FE                            
000028FE                            .NoSurface:
000028FE 6100 0000                  		bsr.w	Level_LoadData			; Load level data
00002902                            
00002902                            .WaitPLCs:
00002902 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002908 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
0000290C 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
00002910 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002914 4A38 9990                  		tst.b	kosMModules.w			; Are there still modules left?
00002918 66E8                       		bne.s	.WaitPLCs			; If so, branch
0000291A                            
0000291A 4238 E8FE                  		clr.b	lvlHasWater.w			; Clear the water flag
0000291E                            
0000291E 41FA 0000                  		lea	Level_WatelevelIDs(pc),a0	; Water heights
00002922 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002926 E218                       		ror.b	#1,d0				; Turn into offset
00002928 EC48                       		lsr.w	#6,d0				; ''
0000292A 3030 0000                  		move.w	(a0,d0.w),d0			; Get water height
0000292E 6B00                       		bmi.s	.NoWater			; If it's negative, branch
00002930 31C0 E900                  		move.w	d0,waterYPos.w		; Set the water height
00002934 31C0 E902                  		move.w	d0,destWaterYPos.w
00002938                            
00002938 50F8 E8FE                  		st	lvlHasWater.w			; Set the water flag
0000293C 33FC 8014 00C0 0004        		move.w	#$8014,VDP_CTRL			; Enable H-INT
00002944 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
00002948 33F8 C760 00C0 0004        		move.w	hIntCntReg.w,VDP_CTRL		; Set H-INT counter
00002950                            
00002950                            .NoWater:
00002950 31FC 00A0 E8D6             		move.w	#320/2,panCamXPos.w		; Set camera X center
00002956                            
00002956 4EB8 18E4                  		jsr	InitOscillation.w		; Initialize oscillation
0000295A                            
0000295A 6100 0000                  		bsr.w	Level_HandleCamera		; Initialize the camera
0000295E                            	;	bsr.w	Level_InitHUD			; Initialize the HUD
0000295E 6100 0000                  		bsr.w	Level_WaterHeight		; Initialize water height
00002962                            
00002962 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
00002966                            
00002966                            		; --- Load the planes ---
00002966                            
00002966                            		intsOff					; Disable interrupts
00002966 007C 0700                M 	ori	#$700,sr
0000296A 21FC 0000 233C C74E        		move.l	#VInt_RunSMPS,vIntAddress.w	; Swap V-INT
00002972                            		intsOn					; Enable interrupts
00002972 027C F8FF                M 	andi	#$f8ff,sr
00002976 6100 0000                  		bsr.w	Level_InitPlanes		; Initialize the planes
0000297A                            		intsOff					; Disable interrupts
0000297A 007C 0700                M 	ori	#$700,sr
0000297E 21FC 0000 20A2 C74E        		move.l	#VInt_Standard,vIntAddress.w	; Swap V-INT
00002986                            		intsOn					; Enable interrupts
00002986 027C F8FF                M 	andi	#$f8ff,sr
0000298A 11FC 0006 C747             		move.b	#vLvlLoad,vIntRoutine.w		; Level load V-INT routine
00002990 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
00002994                            
00002994                            		; --- Load the level objects and rings ---
00002994                            
00002994 51F8 C7B6                  		sf	objMgrInit.w			; Reset object manager routine
00002998 6100 0000                  		bsr.w	Level_RingsManager		; Initialize the ring manager
0000299C 4EB8 1D94                  		jsr	ObjectManager.w			; Run the object manager
000029A0                            	runObjects
000029A0 3078 C158                M 	movea.w	objexecfirst.w,a0
000029A4 2250                     M 	move.l	_objaddress(a0),a1
000029A6 4E91                     M 	jsr	(a1)
000029A8 4EB8 1A9E                  		jsr	RendeobjMemory.w			; Render objects
000029AC                            
000029AC 4238 E906                  		clr.b	lvlReload.w			; Clear the level reload flag
000029B0                            
000029B0                            		displayOn				; Enable display
000029B0 3038 C766                M 	move.w	vdpreg1.w,d0
000029B4 0000 0040                M 	ori.b	#%01000000,d0
000029B8 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
000029BE 4EB8 05CE                  		jsr	FadeFromBlack.w			; Fade from black
000029C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000029C2                            ; Main loop
000029C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000029C2                            .Loop:
000029C2 11FC 0004 C747             		move.b	#vLevel,vIntRoutine.w		; Level V-INT routine
000029C8 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
000029CC 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
000029D0                            
000029D0 4EB8 0000                  		jsr	CheckPause.w			; Check for pausing
000029D4 5278 E904                  		addq.w	#1,lvlFrameCnt.w			; Increment frame counter
000029D8                            
000029D8 4EB8 1938                  		jsr	UpdateOscillation.w		; Update oscillation
000029DC                            
000029DC 6100 0000                  		bsr.w	Level_RingsManager		; Run the ring manager
000029E0 4EB8 1D94                  		jsr	ObjectManager.w			; Run the object manager
000029E4                            
000029E4                            	runObjects
000029E4 3078 C158                M 	movea.w	objexecfirst.w,a0
000029E8 2250                     M 	move.l	_objaddress(a0),a1
000029EA 4E91                     M 	jsr	(a1)
000029EC                            
000029EC 4A38 E906                  		tst.b	lvlReload.w			; Does the level need to be reloaded?
000029F0 6600 FE0E                  		bne.w	Level				; If so, branch
000029F4                            
000029F4 6100 0000                  		bsr.w	Level_HandleCamera		; Handle the camera
000029F8 6100 0000                  		bsr.w	Level_UpdatePlanes		; Update the planes (draw new tiles and scroll)
000029FC 6100 0000                  		bsr.w	Level_UpdateWaterSurface	; Update the water surface
00002A00                            
00002A00 4EB8 1A9E                  		jsr	RendeobjMemory.w			; Render objects
00002A04                            
00002A04 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
00002A08 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
00002A0C 6100 0000                  		bsr.w	Level_PalCycle			; Do palette cycling
00002A10 6100 0000                  		bsr.w	Level_DynEvents			; Run dynamic events
00002A14                            
00002A14 5338 E861                  		subq.b	#1,ringAnimTime.w		; Decrement ring animation timer
00002A18 6A00                       		bpl.s	.NoRingAni			; If it hasn't run out, branch
00002A1A 11FC 0003 E861             		move.b	#3,ringAnimTime.w		; Reset animation timer
00002A20 5238 E860                  		addq.b	#1,ringAnimFrame.w			; Next ring frame
00002A24 0238 0007 E860             		andi.b	#7,ringAnimFrame.w			; Limit it
00002A2A                            
00002A2A 7000                       		moveq	#0,d0
00002A2C 1038 E860                  		move.b	ringAnimFrame.w,d0			; Get ring frame
00002A30 EF48                       		lsl.w	#7,d0				; Convert to offset
00002A32 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002A38 D280                       		add.l	d0,d1				; ''
00002A3A 343C D780                  		move.w	#$D780,d2			; VRAM address
00002A3E 363C 0040                  		move.w	#$80/2,d3			; Size
00002A42 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002A46                            
00002A46                            .NoRingAni:
00002A46 4A38 E864                  		tst.b	ringLossAnimT.w
00002A4A 6700                       		beq.s	.NoRingLossAni
00002A4C 7000                       		moveq	#0,d0
00002A4E 1038 E864                  		move.b	ringLossAnimT.w,d0
00002A52 D078 E862                  		add.w	ringLossAnimA.w,d0
00002A56 31C0 E862                  		move.w	d0,ringLossAnimA.w
00002A5A E158                       		rol.w	#8,d0
00002A5C 0240 0007                  		andi.w	#7,d0
00002A60 11C0 E865                  		move.b	d0,ringLossAnimF.w
00002A64 5338 E864                  		subq.b	#1,ringLossAnimT.w
00002A68                            
00002A68 7000                       		moveq	#0,d0
00002A6A 1038 E865                  		move.b	ringLossAnimF.w,d0		; Get ring frame
00002A6E EF48                       		lsl.w	#7,d0				; Convert to offset
00002A70 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002A76 D280                       		add.l	d0,d1				; ''
00002A78 343C D680                  		move.w	#$D680,d2			; VRAM address
00002A7C 363C 0040                  		move.w	#$80/2,d3			; Size
00002A80 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002A84                            
00002A84                            .NoRingLossAni:
00002A84 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002A88                            
00002A88 0C38 0004 C75C             		cmpi.b	#gLevel,opmode.w		; Is the game mode level?
00002A8E 6700 FF32                  		beq.w	.Loop				; If so, branch
00002A92 4EF8 0220                  		jmp	GotoGameMode.w			; Go to the correct game mode
00002A96                            
00002A96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A96                            ; Check for pausing
00002A96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A96                            CheckPause:
00002A96 4A38 C75E                  		tst.b	pauseFlag.w			; Is the game already paused?
00002A9A 6600                       		bne.s	.SetPause			; If so, branch
00002A9C 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
00002AA2 6700                       		beq.s	.End				; If not, branch
00002AA4                            
00002AA4                            .SetPause:
00002AA4 50F8 C75E                  		st	pauseFlag.w			; Pause the game
00002AA8                            		AMPS_MUSPAUSE				; Pause the music
00002AA8 11FC 0008 C4BE           M 	move.b	#mus_pause,mqueue+2.w
00002AAE                            
00002AAE                            .PauseLoop:
00002AAE 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; General V-INT routine
00002AB4 6100 F8BE                  		bsr.w	VSync_Routine			; V-SYNC
00002AB8 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
00002ABE 67EE                       		beq.s	.PauseLoop			; If not, branch
00002AC0                            
00002AC0                            		AMPS_MUSUNPAUSE				; Unpause the music
00002AC0 11FC 0009 C4BE           M 	move.b	#mus_unpause,mqueue+2.w
00002AC6 4238 C75E                  		clr.b	pauseFlag.w			; Unpause the game
00002ACA                            
00002ACA                            .End:
00002ACA 4E75                       		rts
00002ACC                            
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            ; Level functions
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            		include	"Opmodes/Gameplay/Level Drawing.asm"
00002ACC                            ; =========================================================================================================================================================
00002ACC                            ; Level drawing functions (Based on Sonic Crackers' and S3K's level drawing engine)
00002ACC                            ; =========================================================================================================================================================
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            ; Initialize the planes
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            ; PARAMETERS:
00002ACC                            ;	Nothing
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            ; RETURNS:
00002ACC                            ;	Nothing
00002ACC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002ACC                            Level_InitPlanes:
00002ACC 43F8 E88A                  		lea	fgCamVars.w,a1			; Get foreground level drawing RAM
00002AD0 47F8 C2A0                  		lea	fgColBuff.w,a3			; Get foreground column plane buffer
00002AD4 49F8 C19E                  		lea	fgRowBuff.w,a4			; Get foreground row plane buffer
00002AD8                            
00002AD8 237C 4000 0003 0012        		move.l	#$40000003,cVDP(a1)		; Set the base VDP command for drawing tiles
00002AE0 4269 0016                  		clr.w	cLayout(a1)			; Set the offset for the level layout (foreground)
00002AE4                            		
00002AE4 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002AE8 E218                       		ror.b	#1,d0				; Turn into offset
00002AEA E648                       		lsr.w	#3,d0				; ''
00002AEC 41F9 0000 0000             		lea	Level_RenderRouts,a0		; Get initialization routine list
00002AF2 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
00002AF8 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002AFC 4E90                       		jsr	(a0)				; Jump to it
00002AFE                            
00002AFE 31E9 0008 947E             		move.w	cYPos(a1),vScrollBuffFG.w		; Set the V-Scroll value for the foreground
00002B04                            
00002B04 43F8 E8A8                  		lea	bgCamVars.w,a1			; Get background level drawing RAM
00002B08 47F8 C424                  		lea	bgColBuff.w,a3			; Get background column plane buffer
00002B0C 49F8 C322                  		lea	bgRowBuff.w,a4			; Get background row plane buffer
00002B10                            		
00002B10 237C 6000 0003 0012        		move.l	#$60000003,cVDP(a1)		; Set the base VDP command for drawing tils
00002B18 337C 0004 0016             		move.w	#4,cLayout(a1)			; Set the offset for the level layout (background)
00002B1E                            		
00002B1E 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002B22 E218                       		ror.b	#1,d0				; Turn into offset
00002B24 E648                       		lsr.w	#3,d0				; ''
00002B26 41F9 0000 0000             		lea	Level_RenderRouts+4,a0		; Get initialization routine list
00002B2C 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
00002B32 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002B36 4E90                       		jsr	(a0)				; Jump to it
00002B38                            
00002B38 31E9 0008 9480             		move.w	cYPos(a1),vScrollBuffBG.w		; Set the V-Scroll value for the background
00002B3E 4E75                       		rts
00002B40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B40                            ; Update the planes
00002B40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B40                            Level_UpdatePlanes:
00002B40 43F8 E88A                  		lea	fgCamVars.w,a1			; Get foreground level drawing RAM
00002B44 47F8 C2A0                  		lea	fgColBuff.w,a3		; Get foreground column plane buffer
00002B48 49F8 C19E                  		lea	fgRowBuff.w,a4		; Get foreground row plane buffer
00002B4C                            		
00002B4C 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
00002B50 4E90                       		jsr	(a0)				; Jump to it
00002B52                            		
00002B52 43F8 E8A8                  		lea	bgCamVars.w,a1			; Get background level drawing RAM
00002B56 47F8 C424                  		lea	bgColBuff.w,a3		; Get background column plane buffer
00002B5A 49F8 C322                  		lea	bgRowBuff.w,a4		; Get background row plane buffer
00002B5E                            
00002B5E 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
00002B62 4E90                       		jsr	(a0)				; Jump to it
00002B64                            
00002B64 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002B68 3552 0004                  		move.w	cXPos(a2),cXPrev(a2)		; Update the previous X position for the foreground
00002B6C 356A 0008 000C             		move.w	cYPos(a2),cYPrev(a2)		; Update the previous Y position for the foreground
00002B72 31EA 0008 947E             		move.w	cYPos(a2),vScrollBuffFG.w		; Set the V-Scroll value for the foreground
00002B78 3351 0004                  		move.w	cXPos(a1),cXPrev(a1)		; Update the previous X position for the background
00002B7C 3369 0008 000C             		move.w	cYPos(a1),cYPrev(a1)		; Update the previous Y position for the background
00002B82 31E9 0008 9480             		move.w	cYPos(a1),vScrollBuffBG.w		; Set the V-Scroll value for the background
00002B88                            
00002B88 4E75                       		rts
00002B8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B8A                            ; General foreground initialization
00002B8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B8A                            General_InitFG:
00002B8A 6000 0000                  		bra.w	Level_RefreshPlane		; Refresh the plane
00002B8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B8E                            ; General background initialization
00002B8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B8E                            General_InitBG:
00002B8E 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002B92 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002B94 E240                       		asr.w	#1,d0				; Divide by 2
00002B96 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002B98 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002B9C E240                       		asr.w	#1,d0				; Divide by 2
00002B9E 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002BA2                            
00002BA2 6100 0000                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00002BA6                            		
00002BA6 6000 0000                  		bra.w	ScrollStaticBG			; Set up the scroll offsets
00002BAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BAA                            ; General foreground update
00002BAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BAA                            General_UpdateFG:
00002BAA 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002BAE                            		
00002BAE 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002BB0 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002BB2 6000 0000                  		bra.w	Level_UpdatePlane		; Update the plane
00002BB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BB6                            ; General background update
00002BB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BB6                            General_UpdateBG:
00002BB6 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002BBA 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002BBC E240                       		asr.w	#1,d0				; Divide by 2
00002BBE 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002BC0 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002BC4 E240                       		asr.w	#1,d0				; Divide by 2
00002BC6 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002BCA                            
00002BCA 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002BCE 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002BD0 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002BD2 6100 0000                  		bsr.w	Level_UpdatePlane		; Update the plane
00002BD6                            		
00002BD6 6000 0000                  		bra.w	ScrollStaticBG			; Scroll the planes
00002BDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BDA                            ; Draw new tiles in the level
00002BDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BDA                            ; PARAMETERS:
00002BDA                            ;	a1.l	- Camera RAM
00002BDA                            ;	a2.l	- Plane buffer for columns
00002BDA                            ;	a3.l	- Plane buffer for rows
00002BDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BDA                            ; RETURNS:
00002BDA                            ;	Nothing
00002BDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BDA                            VInt_DrawLevel:
00002BDA 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002BDE 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002BE2                            
00002BE2 3013                       		move.w	(a3),d0				; Get high VDP command word
00002BE4 6700 0000                  		beq.w	VInt_DrawLvlRows2		; If it's 0, branch
00002BE8 425B                       		clr.w	(a3)+				; Reset high VDP command word in buffer
00002BEA 3CBC 8F80                  		move.w	#$8F80,(a6)			; Set auto-increment to $80
00002BEE                            
00002BEE                            		; --- DRAW THE FIRST HALF OF THE COLUMN ---
00002BEE                            
00002BEE 3200                       		move.w	d0,d1				; Save high VDP command
00002BF0 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002BF2 7C00                       		moveq	#0,d6
00002BF4 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
00002BF8 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002BFA                            
00002BFA 3C80                       		move.w	d0,(a6)				; Set VDP command
00002BFC 3C84                       		move.w	d4,(a6)				; ''
00002BFE 6000                       		bra.s	.DrawCol1_1_Start		; Start
00002C00                            
00002C00                            .DrawCol1_1_Loop:
00002C00 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002C02                            
00002C02                            .DrawCol1_1_Start:
00002C02 51CE FFFC                  		dbf	d6,.DrawCol1_1_Loop		; Loop
00002C06                            
00002C06 3403                       		move.w	d3,d2				; Wrap to the top of the plane
00002C08 0642 007C                  		addi.w	#$7C,d2				; ''
00002C0C C042                       		and.w	d2,d0				; ''
00002C0E                            
00002C0E 3C80                       		move.w	d0,(a6)				; Set VDP command
00002C10 3C84                       		move.w	d4,(a6)				; ''
00002C12                            
00002C12                            .DrawCol1_2_Loop:
00002C12 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002C14 51CF FFFC                  		dbf	d7,.DrawCol1_2_Loop		; Loop
00002C18                            
00002C18                            		; --- DRAW THE SECOND HALF OF THE COLUMN ---
00002C18                            
00002C18 5441                       		addq.w	#2,d1				; Move over to the right
00002C1A 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002C1C 7C00                       		moveq	#0,d6
00002C1E 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
00002C22 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002C24                            
00002C24 3C81                       		move.w	d1,(a6)				; Set VDP command
00002C26 3C84                       		move.w	d4,(a6)				; ''
00002C28 6000                       		bra.s	.DrawCol2_1_Start		; Start
00002C2A                            
00002C2A                            .DrawCol2_1_Loop:
00002C2A 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002C2C                            
00002C2C                            .DrawCol2_1_Start:
00002C2C 51CE FFFC                  		dbf	d6,.DrawCol2_1_Loop		; Loop
00002C30                            
00002C30 3403                       		move.w	d3,d2				; Wrap to the top of the plane
00002C32 0642 007E                  		addi.w	#$7E,d2				; ''
00002C36 C242                       		and.w	d2,d1				; ''
00002C38                            
00002C38 3C81                       		move.w	d1,(a6)				; Set VDP command
00002C3A 3C84                       		move.w	d4,(a6)				; ''
00002C3C                            
00002C3C                            .DrawCol2_2_Loop:
00002C3C 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002C3E 51CF FFFC                  		dbf	d7,.DrawCol2_2_Loop		; Loop
00002C42                            
00002C42 3CBC 8F02                  		move.w	#$8F02,(a6)			; Autoincrement by 2
00002C46 6000                       		bra.s	VInt_DrawLvlRows2		; Continue
00002C48                            
00002C48                            VInt_DrawLvlRows:
00002C48 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002C4C 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002C50                            
00002C50                            VInt_DrawLvlRows2:
00002C50 3014                       		move.w	(a4),d0				; Get high VDP command
00002C52 6700 0000                  		beq.w	.End				; If it's 0, branch
00002C56 425C                       		clr.w	(a4)+				; Don't run this again unless necessary
00002C58                            		
00002C58                            		; --- DRAW THE FIRST HALF OF THE ROW ---
00002C58                            
00002C58 3200                       		move.w	d0,d1				; Save high VDP command
00002C5A 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002C5C 7C00                       		moveq	#0,d6
00002C5E 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002C62 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002C64                            
00002C64 3C80                       		move.w	d0,(a6)				; Set VDP command
00002C66 3C84                       		move.w	d4,(a6)				; ''
00002C68 6000                       		bra.s	.DrawRow1_1_Start		; Start
00002C6A                            
00002C6A                            .DrawRow1_1_Loop:
00002C6A 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002C6C                            
00002C6C                            .DrawRow1_1_Start:
00002C6C 51CE FFFC                  		dbf	d6,.DrawRow1_1_Loop		; Loop
00002C70                            
00002C70 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002C72 0642 0F00                  		addi.w	#$F00,d2			; ''
00002C76 C042                       		and.w	d2,d0				; ''
00002C78                            
00002C78 3C80                       		move.w	d0,(a6)				; Set VDP command
00002C7A 3C84                       		move.w	d4,(a6)				; ''
00002C7C                            
00002C7C                            .DrawRow1_2_Loop:
00002C7C 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002C7E 51CF FFFC                  		dbf	d7,.DrawRow1_2_Loop		; Loop
00002C82                            
00002C82                            		; --- DRAW THE SECOND HALF OF THE ROW ---
00002C82                            
00002C82 0641 0080                  		addi.w	#$80,d1				; Move over down
00002C86 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002C88 7C00                       		moveq	#0,d6
00002C8A 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002C8E 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002C90                            
00002C90 3C81                       		move.w	d1,(a6)				; Set VDP command
00002C92 3C84                       		move.w	d4,(a6)				; ''
00002C94 6000                       		bra.s	.DrawRow2_1_Start		; Start
00002C96                            
00002C96                            .DrawRow2_1_Loop:
00002C96 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002C98                            
00002C98                            .DrawRow2_1_Start:
00002C98 51CE FFFC                  		dbf	d6,.DrawRow2_1_Loop		; Loop
00002C9C                            
00002C9C 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002C9E 0642 0F80                  		addi.w	#$F80,d2			; ''
00002CA2 C242                       		and.w	d2,d1				; ''
00002CA4                            
00002CA4 3C81                       		move.w	d1,(a6)				; Set VDP command
00002CA6 3C84                       		move.w	d4,(a6)				; ''
00002CA8                            
00002CA8                            .DrawRow2_2_Loop:
00002CA8 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002CAA 51CF FFFC                  		dbf	d7,.DrawRow2_2_Loop		; Loop
00002CAE                            
00002CAE                            .End:
00002CAE 4E75                       		rts
00002CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CB0                            ; Handle plane drawing
00002CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CB0                            ; PARAMETERS:
00002CB0                            ;	d4.w	- Number of blocks per column
00002CB0                            ;	d5.w	- Number of blocks per row
00002CB0                            ;	a1.l	- Camera variables
00002CB0                            ;	a2.l	- Layout pointer
00002CB0                            ;	a3.l	- Column plane buffer
00002CB0                            ;	a4.l	- Row plane buffer
00002CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CB0                            ; RETURNS:
00002CB0                            ;	Nothing
00002CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CB0                            Level_UpdatePlane:
00002CB0                            		push.l	d5/a4				; Push row plane buffer address
00002CB0 48E7 0408                M 	movem.l	d5/a4,-(sp)
00002CB4 6100                       		bsr.s	Level_UpdatePlaneX		; Handle horizontal plane updating
00002CB6                            		pop.l	d5/a4				; Restore row plane buffer address
00002CB6 4CDF 1020                M 	movem.l	(sp)+,d5/a4
00002CBA 3805                       		move.w	d5,d4				; Number of blocks per column
00002CBC                            		; Continue to update the plane vertically
00002CBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CBC                            ; Handle plane drawing (vertical redrawing only)
00002CBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CBC                            ; PARAMETERS:
00002CBC                            ;	d4.w	- Number of blocks per row
00002CBC                            ;	a1.l	- Camera variables
00002CBC                            ;	a4.l	- Row plane buffer
00002CBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CBC                            ; RETURNS:
00002CBC                            ;	Nothing
00002CBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CBC                            Level_UpdatePlaneY:
00002CBC 3029 0008                  		move.w	cYPos(a1),d0			; Get Y
00002CC0 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002CC4 3229 000E                  		move.w	cYPrevR(a1),d1			; Get previous y (rounded)
00002CC8 3340 000E                  		move.w	d0,cYPrevR(a1)			; Save new rounded y
00002CCC                            		
00002CCC 9240                       		sub.w	d0,d1				; Get distance travelled
00002CCE 6700                       		beq.s	.End				; If a new row doesn't need to be drawn, branch
00002CD0 6B00                       		bmi.s	.DrawDown			; If a new column needs to be drawn on the bottom of the screen, branch
00002CD2                            		
00002CD2                            .DrawUp:
00002CD2 3011                       		move.w	cXPos(a1),d0			; Get X
00002CD4 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002CD8 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002CDC                            
00002CDC                            .DrawDown:
00002CDC 3011                       		move.w	cXPos(a1),d0			; Get X
00002CDE 3229 000C                  		move.w	cYPrev(a1),d1			; Get Y
00002CE2 0641 00F0                  		addi.w	#224+16,d1			; Go to the bottom of the screen
00002CE6 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002CEA                            
00002CEA                            .End:
00002CEA 4E75                       		rts
00002CEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CEC                            ; Handle plane drawing (horizontal redrawing only)
00002CEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CEC                            ; PARAMETERS:
00002CEC                            ;	d4.w	- Number of blocks per column
00002CEC                            ;	a1.l	- Camera variables
00002CEC                            ;	a3.l	- Column plane buffer
00002CEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CEC                            ; RETURNS:
00002CEC                            ;	Nothing
00002CEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CEC                            Level_UpdatePlaneX:
00002CEC 3011                       		move.w	cXPos(a1),d0			; Get X
00002CEE 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002CF2 3229 0006                  		move.w	cXPrevR(a1),d1			; Get previous X (rounded)
00002CF6 3340 0006                  		move.w	d0,cXPrevR(a1)			; Save new rounded X
00002CFA                            		
00002CFA 9240                       		sub.w	d0,d1				; Get distance travelled
00002CFC 6700                       		beq.s	.End				; If a new column doesn't need to be drawn, branch
00002CFE 6B00                       		bmi.s	.DrawRight			; If a new column needs to be drawn on the right side of the screen, branch
00002D00                            		
00002D00                            .DrawLeft:
00002D00 3011                       		move.w	cXPos(a1),d0			; Get X
00002D02 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002D06 6000 0000                  		bra.w	Level_GetCol			; Draw a column
00002D0A                            		
00002D0A                            .DrawRight:
00002D0A 3029 0004                  		move.w	cXPrev(a1),d0			; Get previous X
00002D0E 0640 0150                  		addi.w	#320+16,d0			; Go to the right side of the screen
00002D12 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002D16 6000 0000                  		bra.w	Level_GetCol			; Draw a column
00002D1A                            
00002D1A                            .End:
00002D1A 4E75                       		rts
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            ; Macro to calculate the high VDP command word for the plane buffer
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            ; PARAMETERS:
00002D1C                            ;	a1.l	- Camera variables
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            ; RETURNS:
00002D1C                            ;	d2.w	- The high VDP command word
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            calcHiVDP	macro
00002D1C                            		move.w	d0,d2				; Copy X
00002D1C                            		move.w	d1,d3				; Copy Y
00002D1C                            		lsl.w	#4,d3				; Multiply Y by $10
00002D1C                            		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002D1C                            		lsr.w	#2,d2				; Divide X by 4
00002D1C                            		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
00002D1C                            		add.w	d3,d2				; Add Y onto X
00002D1C                            		or.w	cVDP(a1),d2			; Combine with high VDP command word
00002D1C                            		endm
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            ; Macro to get an address in chunk data relative to a position
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            ; PARAMETERS:
00002D1C                            ;	d1.l	- $FFFFXXXX
00002D1C                            ;	a2.l	- Layout data
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            ; RETURNS:
00002D1C                            ;	a6.l	- Pointer in chunk data to the correct block
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            getChunk	macro
00002D1C                            		moveq	#-1,d1				; Prepare chunk pointer
00002D1C                            		move.b	(a2,d0.w),d1			; Get chunk ID
00002D1C                            		andi.w	#$FF,d1				; ''
00002D1C                            		lsl.w	#7,d1				; Turn into offset
00002D1C                            		movea.l	d1,a6				; Store into a6
00002D1C                            		endm
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            ; Get a block row and store it in a plane buffer
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            ; PARAMETERS:
00002D1C                            ;	d0.w	- X position
00002D1C                            ;	d1.w	- Y position
00002D1C                            ;	d4.w	- Number of blocks to draw (minus 1)
00002D1C                            ;	a1.l	- Camera variables
00002D1C                            ;	a4.l	- Row plane buffer
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            ; RETURNS:
00002D1C                            ;	Nothing
00002D1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D1C                            Level_GetRow:
00002D1C 45F8 E856                  		lea	lvlLayout.w,a2			; Get level layout pointer address
00002D20 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add camera offset value
00002D24 2452                       		movea.l	(a2),a2				; Load address stored within the pointer
00002D26                            
00002D26 47F8 C7D2                  		lea	blockData.w,a3			; Get block table address
00002D2A 4BEC 0082                  		lea	$82(a4),a5			; Store plane buffer address for the bottom tiles in the row
00002D2E                            
00002D2E                            		calcHiVDP				; Get high VDP command word
00002D2E 3400                     M 	move.w	d0,d2
00002D30 3601                     M 	move.w	d1,d3
00002D32 E94B                     M 	lsl.w	#4,d3
00002D34 0243 0F00                M 	andi.w	#$f00,d3
00002D38 E44A                     M 	lsr.w	#2,d2
00002D3A 0242 007C                M 	andi.w	#$7c,d2
00002D3E D443                     M 	add.w	d3,d2
00002D40 8469 0012                M 	or.w	cvdp(a1),d2
00002D44 38C2                       		move.w	d2,(a4)+			; Store it
00002D46                            
00002D46 3400                       		move.w	d0,d2				; Get X
00002D48 E44A                       		lsr.w	#2,d2				; Divide X by 4
00002D4A 0242 007C                  		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
00002D4E 3A3C 0080                  		move.w	#512/4,d5			; Get max row size in pixels divided by 4
00002D52 9A42                       		sub.w	d2,d5				; Get number of pixels (divided by 4) that the first set of tiles for a row takes up
00002D54 0245 007C                  		andi.w	#$7C,d5				; Only allow 0-$7C with multiples of 4
00002D58 E44D                       		lsr.w	#2,d5				; Divide by 4
00002D5A 1345 0010                  		move.b	d5,cRBlks(a1)			; Set tile count for the first set of tiles for a row
00002D5E                            		
00002D5E E648                       		lsr.w	#3,d0				; Get X within chunk data
00002D60 3400                       		move.w	d0,d2				; ''
00002D62 0242 000E                  		andi.w	#$E,d2				; ''
00002D66 3601                       		move.w	d1,d3				; Get Y within chunk data
00002D68 0243 0070                  		andi.w	#$70,d3				; ''
00002D6C D443                       		add.w	d3,d2				; Combine X and Y to get chunk offset
00002D6E                            		
00002D6E E848                       		lsr.w	#4,d0				; Get X within layout data
00002D70 0240 00FF                  		andi.w	#$FF,d0				; ''
00002D74 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
00002D78 EC49                       		lsr.w	#6,d1				; ''
00002D7A                            
00002D7A D072 1002                  		add.w	2(a2,d1.w),d0			; Combine X and Y to get layout offset
00002D7E                            		getChunk				; Get chunk pointer at current location
00002D7E 72FF                     M 	moveq	#-1,d1
00002D80 1232 0000                M 	move.b	(a2,d0.w),d1
00002D84 0241 00FF                M 	andi.w	#$ff,d1
00002D88 EF49                     M 	lsl.w	#7,d1
00002D8A 2C41                     M 	movea.l	d1,a6
00002D8C                            
00002D8C                            .DrawBlock_Loop:
00002D8C 3A36 2000                  		move.w	(a6,d2.w),d5			; Get block properties
00002D90 3C05                       		move.w	d5,d6				; ''
00002D92 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002D96 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002D98                            		
00002D98 2E33 5000                  		move.l	(a3,d5.w),d7			; Get block tiles
00002D9C 2A33 5004                  		move.l	4(a3,d5.w),d5			; ''
00002DA0                            
00002DA0 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002DA4 6700                       		beq.s	.ChkYFlip			; If not, branch
00002DA6 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002DAC 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002DB2 4847                       		swap	d7				; ''
00002DB4 4845                       		swap	d5				; ''
00002DB6                            
00002DB6                            .ChkYFlip:
00002DB6 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002DBA 6700                       		beq.s	.DrawBlock			; If not, branch
00002DBC 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002DC2 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002DC8 CF45                       		exg.l	d7,d5				; ''
00002DCA                            
00002DCA                            .DrawBlock:
00002DCA 28C7                       		move.l	d7,(a4)+			; Save the tiles in the plane buffers
00002DCC 2AC5                       		move.l	d5,(a5)+			; ''
00002DCE                            
00002DCE 5442                       		addq.w	#2,d2				; Go to the next block
00002DD0 0242 000E                  		andi.w	#$E,d2				; Have we gone outside of the chunk?
00002DD4 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002DD6                            		
00002DD6 5240                       		addq.w	#1,d0				; Next chunk
00002DD8                            		getChunk				; ''
00002DD8 72FF                     M 	moveq	#-1,d1
00002DDA 1232 0000                M 	move.b	(a2,d0.w),d1
00002DDE 0241 00FF                M 	andi.w	#$ff,d1
00002DE2 EF49                     M 	lsl.w	#7,d1
00002DE4 2C41                     M 	movea.l	d1,a6
00002DE6                            
00002DE6                            .DrawBlock_Cont:
00002DE6 D443                       		add.w	d3,d2				; Recombine X and Y to get chunk offset
00002DE8 51CC FFA2                  		dbf	d4,.DrawBlock_Loop		; Loop
00002DEC                            
00002DEC 4E75                       		rts
00002DEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DEE                            ; Get a block column and store it in a plane buffer
00002DEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DEE                            ; PARAMETERS:
00002DEE                            ;	d0.w	- X position
00002DEE                            ;	d1.w	- Y position
00002DEE                            ;	d4.w	- Number of blocks to draw (minus 1)
00002DEE                            ;	a1.l	- Camera RAM
00002DEE                            ;	a3.l	- Column plane buffer
00002DEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DEE                            ; RETURNS:
00002DEE                            ;	Nothing
00002DEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DEE                            Level_GetCol:
00002DEE 45F8 E856                  		lea	lvlLayout.w,a2			; Get level layout pointer address
00002DF2 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add camera offset value
00002DF6 2452                       		movea.l	(a2),a2				; Load address stored within the pointer
00002DF8                            		
00002DF8 49F8 C7D2                  		lea	blockData.w,a4			; Get block table address
00002DFC 4BEB 0042                  		lea	$42(a3),a5			; Store plane buffer address for the right tiles in the column
00002E00                            		
00002E00                            		calcHiVDP				; Get high VDP command word
00002E00 3400                     M 	move.w	d0,d2
00002E02 3601                     M 	move.w	d1,d3
00002E04 E94B                     M 	lsl.w	#4,d3
00002E06 0243 0F00                M 	andi.w	#$f00,d3
00002E0A E44A                     M 	lsr.w	#2,d2
00002E0C 0242 007C                M 	andi.w	#$7c,d2
00002E10 D443                     M 	add.w	d3,d2
00002E12 8469 0012                M 	or.w	cvdp(a1),d2
00002E16 36C2                       		move.w	d2,(a3)+			; Store it
00002E18                            
00002E18 3601                       		move.w	d1,d3				; Get Y
00002E1A E94B                       		lsl.w	#4,d3				; Multiply by $10
00002E1C 0243 0F00                  		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002E20 3A3C 1000                  		move.w	#256*16,d5			; Get max column size in pixels times 16
00002E24 9A43                       		sub.w	d3,d5				; Get number of pixels (times 16) that the first set of tiles for a column takes up
00002E26 0245 0F00                  		andi.w	#$F00,d5			; Only allow 0-$F00 with multiples of $100
00002E2A E04D                       		lsr.w	#8,d5				; Divide by $100
00002E2C 1345 0011                  		move.b	d5,cCBlks(a1)			; Set tile count for the first set of tiles for a column
00002E30                            
00002E30 E648                       		lsr.w	#3,d0				; Get X within chunk data
00002E32 3400                       		move.w	d0,d2				; ''
00002E34 0242 000E                  		andi.w	#$E,d2				; ''
00002E38 3601                       		move.w	d1,d3				; Get Y within chunk data
00002E3A 0243 0070                  		andi.w	#$70,d3				; ''
00002E3E D642                       		add.w	d2,d3				; Combine X and Y to get chunk offset
00002E40                            
00002E40 E848                       		lsr.w	#4,d0				; Get X within layout data
00002E42 0240 00FF                  		andi.w	#$FF,d0				; ''
00002E46 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
00002E4A EC49                       		lsr.w	#6,d1				; ''				
00002E4C 48A7 C000                  		movem.w	d0-d1,-(sp)			; Backup layout X and Y 
00002E50                            		
00002E50 D072 1002                  		add.w	2(a2,d1.w),d0			; Combine X and Y to get layout offset
00002E54                            		getChunk				; Get chunk pointer at current location
00002E54 72FF                     M 	moveq	#-1,d1
00002E56 1232 0000                M 	move.b	(a2,d0.w),d1
00002E5A 0241 00FF                M 	andi.w	#$ff,d1
00002E5E EF49                     M 	lsl.w	#7,d1
00002E60 2C41                     M 	movea.l	d1,a6
00002E62                            
00002E62                            .DrawBlock_Loop:
00002E62 3A36 3000                  		move.w	(a6,d3.w),d5			; Get block properties
00002E66 3C05                       		move.w	d5,d6				; ''
00002E68 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002E6C E74D                       		lsl.w	#3,d5				; Get offset in block data
00002E6E                            		
00002E6E 3E05                       		move.w	d5,d7				; Get block tiles
00002E70 2A34 7002                  		move.l	2(a4,d7.w),d5			; ''
00002E74 3A07                       		move.w	d7,d5				; ''
00002E76 2E34 5000                  		move.l	(a4,d5.w),d7			; ''
00002E7A 3E34 5004                  		move.w	4(a4,d5.w),d7			; ''
00002E7E 3A34 5006                  		move.w	6(a4,d5.w),d5			; ''
00002E82                            
00002E82 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002E86 6700                       		beq.s	.ChkYFlip			; If not, branch
00002E88 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002E8E 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002E94 CF45                       		exg.l	d7,d5				; ''
00002E96                            
00002E96                            .ChkYFlip:
00002E96 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002E9A 6700                       		beq.s	.DrawBlock			; If not, branch
00002E9C 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002EA2 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002EA8 4847                       		swap	d7				; ''
00002EAA 4845                       		swap	d5				; ''
00002EAC                            
00002EAC                            .DrawBlock:
00002EAC 26C7                       		move.l	d7,(a3)+			; Save the tiles in the plane buffers
00002EAE 2AC5                       		move.l	d5,(a5)+			; ''
00002EB0                            
00002EB0 0643 0010                  		addi.w	#$10,d3				; Go to the next block
00002EB4 0243 0070                  		andi.w	#$70,d3				; Have we gone outside of the chunk?
00002EB8 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002EBA                            
00002EBA 4C9F 0003                  		movem.w	(sp)+,d0-d1			; Get saved layout X and Y from the stack
00002EBE 5441                       		addq.w	#2,d1				; Increase layout data Y offset to the next pointer
00002EC0 48A7 C000                  		movem.w	d0-d1,-(sp)			; Push a backup copy back onto the stack
00002EC4                            		
00002EC4 D072 1002                  		add.w	2(a2,d1.w),d0			; Next chunk
00002EC8                            		getChunk				; ''
00002EC8 72FF                     M 	moveq	#-1,d1
00002ECA 1232 0000                M 	move.b	(a2,d0.w),d1
00002ECE 0241 00FF                M 	andi.w	#$ff,d1
00002ED2 EF49                     M 	lsl.w	#7,d1
00002ED4 2C41                     M 	movea.l	d1,a6
00002ED6                            
00002ED6                            .DrawBlock_Cont:
00002ED6 D642                       		add.w	d2,d3				; Recombine X and Y to get chunk offset
00002ED8 51CC FF88                  		dbf	d4,.DrawBlock_Loop		; Loop
00002EDC                            
00002EDC 4C9F 0003                  		movem.w	(sp)+,d0-d1			; Discard backup layout X and Y from the stack 
00002EE0 4E75                       		rts
00002EE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EE2                            ; Refresh a plane
00002EE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EE2                            ; PARAMETERS:
00002EE2                            ;	a1.l	- Camera variables
00002EE2                            ;	a4.l	- Row plane buffer
00002EE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EE2                            ; RETURNS:
00002EE2                            ;	Nothing
00002EE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EE2                            Level_RefreshPlane:
00002EE2 3011                       		move.w	cXPos(a1),d0			; Get X position
00002EE4 3340 0004                  		move.w	d0,cXPrev(a1)			; Store as previous X position
00002EE8 0240 FFF0                  		andi.w	#$FFF0,d0			; Only get multiples of $10
00002EEC 3340 0006                  		move.w	d0,cXPrevR(a1)			; Store as previous X position (rounded)
00002EF0                            		
00002EF0 3229 0008                  		move.w	cYPos(a1),d1			; Get Y position
00002EF4 3341 000C                  		move.w	d1,cYPrev(a1)			; Store as previous Y position
00002EF8 0241 FFF0                  		andi.w	#$FFF0,d1			; Only get multiples of $10
00002EFC 3341 000E                  		move.w	d1,cYPrevR(a1)			; Store as previous Y position (rounded)
00002F00                            		
00002F00 781F                       		moveq	#(512/16)-1,d4			; Number of rows to draw
00002F02 7C0F                       		moveq	#(256/16)-1,d6			; Number of blocks per row
00002F04                            		
00002F04                            		push.l	a4				; Save plane buffer address
00002F04 2F0C                     M 	move.l	a4,-(sp)
00002F06                            		
00002F06                            .DrawRows:
00002F06                            		push.w	d0/d1/d4/d6			; Save registers
00002F06 48A7 CA00                M 	movem.w	d0/d1/d4/d6,-(sp)
00002F0A 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002F0E 6100 FE0C                  		bsr.w	Level_GetRow			; Transfer the row to the plane buffer
00002F12 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002F16 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002F1C 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002F20 6100 FD26                  		bsr.w	VInt_DrawLvlRows		; Draw the new row
00002F24                            		pop.w	d0/d1/d4/d6			; Restore registers
00002F24 4C9F 0053                M 	movem.w	(sp)+,d0/d1/d4/d6
00002F28                            		
00002F28 0641 0010                  		addi.w	#$10,d1				; Increment Y
00002F2C 51CE FFD8                  		dbf	d6,.DrawRows			; Loop
00002F30                            		
00002F30                            		pop.l	a4				; Restore a3
00002F30 285F                     M 	move.l	(sp)+,a4
00002F32 4E75                       		rts
00002F34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F34                            ; Check if the plane needs to be redrawn
00002F34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F34                            ; PARAMETERS:
00002F34                            ;	a1.l	- Camera RAM
00002F34                            ;	a3.l	- Row plane buffer
00002F34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F34                            ; RETURNS:
00002F34                            ;	Nothing
00002F34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F34                            Level_ChkRedrawPlane:
00002F34 4A29 001C                  		tst.b	cRedraw(a1)			; Does this plane need to be redrawn?
00002F38                            		; Comment out the following line to disable blast processing :^)
00002F38 6700                       		beq.s	.End				; If not, branch
00002F3A 4229 001C                  		clr.b	cRedraw(a1)			; Clear the redraw flag
00002F3E 60A2                       		bra.s	Level_RefreshPlane		; Redraw the plane
00002F40                            
00002F40                            .End:
00002F40 4E75                       		rts
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42                            ; Scroll sections macro
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42 =00008000                  SCROLL_AUTOMATIC	EQU	$8000			; Automatic scroll flag
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42                            scrollInit	macro	label
00002F42                            SCROLL_LABEL	equs	"\label"
00002F42                            \label\:	dc.w	((\label\_End-\label\-2)/6)-1	; Number of sections
00002F42                            		endm
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42                            scrollEnd	macro
00002F42                            \SCROLL_LABEL\_End:					; End label
00002F42                            		endm
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42                            scrollSection	macro
00002F42                            	if narg<3
00002F42                            		dc.w	\2, 0, \1			; Speed, 0, Size
00002F42                            	else
00002F42                            		dc.w	\2, \3, \1			; Speed, Flags, Size
00002F42                            	endif
00002F42                            		endm
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42                            ; Do section scrolling
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42                            ; PARAMERERS:
00002F42                            ;	a1.l	- Background camera RAM
00002F42                            ;	a3.l	- Scroll section data
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42                            ; RETURNS:
00002F42                            ;	Nothing
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42                            ScrollSections:
00002F42 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing variables
00002F46 49F8 E452                  		lea	scrollSects.w,a4		; Deformation offset buffer
00002F4A 4BF8 90FE                  		lea	hScrollBuff.w,a5			; Horizontal scroll buffer
00002F4E                            
00002F4E 301B                       		move.w	(a3)+,d0			; Get the total number of scroll sections
00002F50                            
00002F50 3812                       		move.w	cXPos(a2),d4			; Get camera speed
00002F52 986A 0004                  		sub.w	cXPrev(a2),d4			; ''
00002F56 48C4                       		ext.l	d4				; ''
00002F58 E184                       		asl.l	#8,d4				; Shift over to use for calculation speeds
00002F5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F5A                            		; Update each section offset
00002F5A                            		push.w	d0/a4				; Save registers
00002F5A 48A7 8008                M 	movem.w	d0/a4,-(sp)
00002F5E                            
00002F5E                            .ScrollSects:
00002F5E 361B                       		move.w	(a3)+,d3			; Get section speed
00002F60 48C3                       		ext.l	d3				; ''
00002F62                            
00002F62 4A5B                       		tst.w	(a3)+				; Is this section set to scroll automatically?
00002F64 6A00                       		bpl.s	.NotAuto			; If not, branch
00002F66 3C04                       		move.w	d4,d6				; Get camera speed
00002F68 CDC3                       		muls.w	d3,d6				; Multiply by section speed
00002F6A E183                       		asl.l	#8,d3				; Shift section speed
00002F6C D686                       		add.l	d6,d3				; Add camera speed to section speed
00002F6E 6000                       		bra.s	.ApplySpeed			; Apply that speed
00002F70                            
00002F70                            .NotAuto:
00002F70 C7C4                       		muls.w	d4,d3				; Multiply the the background's X scroll offset with the speed
00002F72                            
00002F72                            .ApplySpeed:
00002F72 D79C                       		add.l	d3,(a4)+			; Set the new section offset
00002F74 38DB                       		move.w	(a3)+,(a4)+			; Save the section size for later
00002F76 51C8 FFE6                  		dbf	d0,.ScrollSects			; If there are still sections to check, loop
00002F7A                            
00002F7A                            		pop.w	d0/a4				; Restore registers
00002F7A 4C9F 1001                M 	movem.w	(sp)+,d0/a4
00002F7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F7E                            		; Set the scroll offsets on screen
00002F7E 3A3C 00E0                  		move.w	#224,d5				; Scanline counter
00002F82 3C29 0008                  		move.w	cYPos(a1),d6			; Get the background's Y position
00002F86                            		
00002F86                            .FindStart:
00002F86 221C                       		move.l	(a4)+,d1			; Get section offset
00002F88 9C5C                       		sub.w	(a4)+,d6			; Subtract the size of the section
00002F8A 6B00                       		bmi.s	.FoundStart			; If the current section is on screen, branch
00002F8C 51C8 FFF8                  		dbf	d0,.FindStart			; If not, continue the search
00002F90 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002F92 4441                       		neg.w	d1				; Make it scroll the right direction
00002F94 4841                       		swap	d1				; Fix which planes the scroll values go to
00002F96 4441                       		neg.w	d1				; Make the background scroll the right direction
00002F98 6000                       		bra.s	.LastSection			; If there are no more sections to go through, branch
00002F9A                            
00002F9A                            .FoundStart:
00002F9A 4446                       		neg.w	d6				; Get remaining size of the section
00002F9C 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002F9E 4441                       		neg.w	d1				; Make it scroll the right direction
00002FA0 4841                       		swap	d1				; Fix which planes the scroll values go to
00002FA2 4441                       		neg.w	d1				; Make the background scroll the right direction
00002FA4 6000                       		bra.s	.CheckScroll			; Go set some scroll offsets
00002FA6                            
00002FA6                            .NextSection:
00002FA6 321C                       		move.w	(a4)+,d1			; Set scroll offset
00002FA8 4441                       		neg.w	d1				; Make the section scroll the correct way
00002FAA 2C1C                       		move.l	(a4)+,d6			; Get section size
00002FAC                            		
00002FAC                            .CheckScroll:
00002FAC 9A46                       		sub.w	d6,d5				; Subtract that from the scanline count
00002FAE 6B00                       		bmi.s	.EndSection			; If there is still screen space to cover, loop
00002FB0 5346                       		subq.w	#1,d6				; Convert for use with dbf
00002FB2                            
00002FB2                            .Scroll:
00002FB2 2AC1                       		move.l	d1,(a5)+			; Scroll the section
00002FB4 51CE FFFC                  		dbf	d6,.Scroll			; Repeat
00002FB8 51C8 FFEC                  		dbf	d0,.NextSection			; If there are any sections left, branch
00002FBC 5245                       		addq.w	#1,d5				; Add 1 so that the foreground can still scroll properly
00002FBE                            		
00002FBE                            .EndSection:
00002FBE DA46                       		add.w	d6,d5				; Get remaining screen space
00002FC0                            		
00002FC0                            .LastSection:
00002FC0 5345                       		subq.w	#1,d5				; Convert to use with dbf
00002FC2 6B00                       		bmi.s	.End				; If there are none, exit
00002FC4                            
00002FC4                            .FillScroll:
00002FC4 2AC1                       		move.l	d1,(a5)+			; Set previous scroll values
00002FC6 51CD FFFC                  		dbf	d5,.FillScroll			; Repeat
00002FCA                            
00002FCA                            .End:
00002FCA 4E75                       		rts
00002FCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FCC                            ; Static background scrolling (no parallax)
00002FCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FCC                            ; PARAMERERS:
00002FCC                            ;	a1.l	- Background camera RAM
00002FCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FCC                            ; RETURNS:
00002FCC                            ;	Nothing
00002FCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FCC                            ScrollStaticBG:
00002FCC 45F8 E88A                  		lea	fgCamVars.w,a2		; Get foreground level drawing variables
00002FD0 4BF8 90FE                  		lea	hScrollBuff.w,a5		; Horizontal scroll buffer
00002FD4                            		
00002FD4 2212                       		move.l	cXPos(a2),d1			; Get foreground X position
00002FD6 4481                       		neg.l	d1				; Negate it so it scrolls properly
00002FD8 3211                       		move.w	cXPos(a1),d1			; Get background X position
00002FDA 4441                       		neg.w	d1				; Negate it so it scrolls properly
00002FDC                            
00002FDC 303C 00DF                  		move.w	#224-1,d0			; Number of scanlines to scroll
00002FE0                            
00002FE0                            .Scroll:
00002FE0 2AC1                       		move.l	d1,(a5)+			; Set the scroll offsets
00002FE2 51C8 FFFC                  		dbf	d0,.Scroll			; Repeat
00002FE6 4E75                       		rts
00002FE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FE8                            ; Generate fake layer art
00002FE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FE8                            ; PARAMETERS:
00002FE8                            ;	a0.l	- Layer art data pointer
00002FE8                            ;	a1.l	- Layer tile ID mappings pointer
00002FE8                            ;	d0.w	- Layer offset
00002FE8                            ;	d1.l	- Buffer pointer
00002FE8                            ;	d2.w	- VRAM destination address
00002FE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FE8                            Level_UpdateLayer:
00002FE8                            		; Prepare for transfer
00002FE8 3619                       		move.w	(a1)+,d3			; Get number of tiles to copy
00002FEA 2441                       		movea.l	d1,a2				; Copy layer buffer pointer
00002FEC                            		
00002FEC                            		; Queue a DMA transfer for later
00002FEC                            		push.l	d0/d3/a1			; Save registers
00002FEC 48E7 9040                M 	movem.l	d0/d3/a1,-(sp)
00002FF0 5243                       		addq.w	#1,d3				; Get size of transfer
00002FF2 E94B                       		lsl.w	#4,d3				; ''
00002FF4 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the transfer
00002FF8                            		pop.l	d0/d3/a1			; Restore registers
00002FF8 4CDF 0209                M 	movem.l	(sp)+,d0/d3/a1
00002FFC                            
00002FFC                            		; Copy the tiles for the layer
00002FFC D040                       		add.w	d0,d0				; Double it
00002FFE D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to layer data for the offset
00003002                            		
00003002                            .CopyTiles:
00003002 3219                       		move.w	(a1)+,d1			; Get tile offset
00003004 47F0 1000                  		lea	(a0,d1.w),a3			; Get pointer to tile data
00003008 24DB                       		move.l	(a3)+,(a2)+			; Copy tile data
0000300A 24DB                       		move.l	(a3)+,(a2)+			; ''
0000300C 24DB                       		move.l	(a3)+,(a2)+			; ''
0000300E 24DB                       		move.l	(a3)+,(a2)+			; ''
00003010 24DB                       		move.l	(a3)+,(a2)+			; ''
00003012 24DB                       		move.l	(a3)+,(a2)+			; ''
00003014 24DB                       		move.l	(a3)+,(a2)+			; ''
00003016 24DB                       		move.l	(a3)+,(a2)+			; ''
00003018 51CB FFE8                  		dbf	d3,.CopyTiles			; Loop
0000301C                            
0000301C                            .End
0000301C 4E75                       		rts
0000301E                            ; =========================================================================================================================================================
0000301E                            		include	"Opmodes/Gameplay/Level Collision.asm"
0000301E                            ; =========================================================================================================================================================
0000301E                            ; Level collision functions
0000301E                            ; =========================================================================================================================================================
0000301E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000301E                            ; Check if a player object has touched any level collision
0000301E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000301E                            PlayerChkCollision:
0000301E 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00003024 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
0000302A 6700                       		beq.s	.NotPrimary			; If not, branch
0000302C 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003032                            
00003032                            .NotPrimary:
00003032 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
00003036                            		
00003036 3228 001C                  		move.w	_objXVel(a0),d1			; Get X velocity
0000303A 3428 001E                  		move.w	_objYVel(a0),d2			; Get Y velocity
0000303E 4EB8 1786                  		jsr	CalcArcTan.w			; Get the angle
00003042 0400 0020                  		subi.b	#$20,d0				; Shift it over
00003046 0200 00C0                  		andi.b	#$C0,d0				; Get the quadrant
0000304A 0C00 0040                  		cmpi.b	#$40,d0				; Are we hitting a left wall?
0000304E 6700 0000                  		beq.w	PlayerHitLWall			; If so, branch
00003052 0C00 0080                  		cmpi.b	#$80,d0				; Are we hitting a ceiling?
00003056 6700 0000                  		beq.w	PlayerHitCeilAndWalls		; If so, branch
0000305A 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we hitting a right wall?
0000305E 6700 0000                  		beq.w	PlayerHitRWall			; If so, branch
00003062                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003062                            PlayerHitFloorAndWalls:
00003062 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00003066 4A41                       		tst.w	d1				; Have we hit the wall?
00003068 6A00                       		bpl.s	.NoLeftHit			; If not, branch
0000306A 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
0000306E 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003072                            
00003072                            .NoLeftHit:
00003072 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00003076 4A41                       		tst.w	d1				; Have we hit the wall?
00003078 6A00                       		bpl.s	.NoRightHit			; If not, branch
0000307A D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
0000307E 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003082                            
00003082                            .NoRightHit:
00003082 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00003086 4A41                       		tst.w	d1				; Have we hit the floor?
00003088 6A00                       		bpl.s	.End				; If not, branch
0000308A                            
0000308A 1428 001E                  		move.b	_objYVel(a0),d2			; Get the integer part of the Y velocity
0000308E 5002                       		addq.b	#8,d2				; Get the max distance we have to have from the floor in order to collide with it
00003090 4402                       		neg.b	d2				; Negate it since we are in the floor
00003092 B202                       		cmp.b	d2,d1				; Is the chosen primary distance small enough?
00003094 6C00                       		bge.s	.TouchFloor			; If so, branch
00003096 B002                       		cmp.b	d2,d0				; What about the other angle that was found?
00003098 6D00                       		blt.s	.End				; If not, branch
0000309A                            
0000309A                            .TouchFloor:
0000309A 1143 0000                  		move.b	d3,_objAngle(a0)			; Set the angle
0000309E D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the floor
000030A2 1003                       		move.b	d3,d0				; Copy angle
000030A4 0600 0020                  		addi.b	#$20,d0				; Shift it
000030A8 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
000030AC 6600                       		bne.s	.HitWall			; If so, branch
000030AE 1003                       		move.b	d3,d0				; Copy angle
000030B0 0600 0010                  		addi.b	#$10,d0				; Shift it
000030B4 0200 0020                  		andi.b	#$20,d0				; Are we on a slope?
000030B8 6700                       		beq.s	.HitFloor			; If not, branch
000030BA E0E8 001E                  		asr	_objYVel(a0)			; Divide the Y velocity by 2
000030BE 6000                       		bra.s	.HitSlope			; Continue
000030C0                            
000030C0                            .HitFloor:
000030C0 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
000030C4 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
000030CA 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
000030CE                            
000030CE                            .HitWall:
000030CE 4268 001C                  		clr.w	_objXVel(a0)			; Stop X movement
000030D2 0C68 0FC0 001E             		cmpi.w	#$FC0,_objYVel(a0)			; Cap the Y velocity at $FC0
000030D8 6F00                       		ble.s	.HitSlope			; ''
000030DA 317C 0FC0 001E             		move.w	#$FC0,_objYVel(a0)			; ''
000030E0                            
000030E0                            .HitSlope:
000030E0 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
000030E4 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
000030EA 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
000030EC 6A00                       		bpl.s	.End				; If so, branch
000030EE 4468 0000                  		neg.w	_objGVel(a0)			; Negate the ground velocity
000030F2                            
000030F2                            .End:
000030F2 4E75                       		rts
000030F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030F4                            PlayerHitLWall:
000030F4 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
000030F8 4A41                       		tst.w	d1				; Have we hit the wall?
000030FA 6A00                       		bpl.s	.ChkCeil			; If not, branch
000030FC 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
00003100 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003104 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
0000310A                            
0000310A                            .ChkCeil:
0000310A 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
0000310E 4A41                       		tst.w	d1				; Have we hit the ceiling?
00003110 6A00                       		bpl.s	.ChkFloor			; If not, branch
00003112 4441                       		neg.w	d1				; Get the distance inside the ceiling
00003114 0C41 0014                  		cmpi.w	#$14,d1				; Are we too far into the ceiling?
00003118 6400                       		bhs.s	.ChkRightWall			; If so, branch
0000311A D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
0000311E 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
00003122 6A00                       		bpl.s	.End				; If not, branch
00003124 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00003128                            
00003128                            .End:
00003128 4E75                       		rts
0000312A                            
0000312A                            .ChkRightWall:
0000312A 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
0000312E 4A41                       		tst.w	d1				; Have we hit the wall?
00003130 6A00                       		bpl.s	.End2				; If not, branch
00003132 D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00003136 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
0000313A                            		
0000313A                            .End2:
0000313A 4E75                       		rts
0000313C                            
0000313C                            .ChkFloor:
0000313C 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
00003140 6B00                       		bmi.s	.End3				; If so, branch
00003142 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00003146 4A41                       		tst.w	d1				; Have we hit the ceiling?
00003148 6A00                       		bpl.s	.End3				; If not, branch
0000314A D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
0000314E 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
00003152 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00003156 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
0000315C 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00003160                            		
00003160                            .End3:
00003160 4E75                       		rts
00003162                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003162                            PlayerHitCeilAndWalls:
00003162 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00003166 4A41                       		tst.w	d1				; Have we hit the wall?
00003168 6A00                       		bpl.s	.NoLeftHit			; If not, branch
0000316A 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
0000316E 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003172                            
00003172                            .NoLeftHit:
00003172 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00003176 4A41                       		tst.w	d1				; Have we hit the wall?
00003178 6A00                       		bpl.s	.NoRightHit			; If not, branch
0000317A D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
0000317E 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003182                            
00003182                            .NoRightHit:
00003182 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00003186 4A41                       		tst.w	d1				; Have we hit the floor?
00003188 6A00                       		bpl.s	.End				; If not, branch
0000318A 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move out of ceiling
0000318E 1003                       		move.b	d3,d0				; Get angle
00003190 0600 0020                  		addi.b	#$20,d0				; Shift it
00003194 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00003198 6600                       		bne.s	.HitWall			; If so, branch
0000319A 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
0000319E 4E75                       		rts
000031A0                            
000031A0                            .HitWall:
000031A0 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
000031A4 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
000031A8 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
000031AE 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
000031B0 6A00                       		bpl.s	.End				; If so, branch
000031B2 4468 0000                  		neg.w	_objGVel(a0)			; Negate the ground velocity
000031B6                            
000031B6                            .End:
000031B6 4E75                       		rts
000031B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031B8                            PlayerHitRWall:
000031B8 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
000031BC 4A41                       		tst.w	d1				; Have we hit the wall?
000031BE 6A00                       		bpl.s	.ChkCeil			; If not, branch
000031C0 D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
000031C4 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
000031C8 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
000031CE                            
000031CE                            .ChkCeil:
000031CE 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
000031D2 4A41                       		tst.w	d1				; Have we hit the ceiling?
000031D4 6A00                       		bpl.s	.ChkFloor			; If not, branch
000031D6 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move out of the ceiling
000031DA 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
000031DE 6A00                       		bpl.s	.End				; If not, branch
000031E0 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
000031E4                            
000031E4                            .End:
000031E4 4E75                       		rts
000031E6                            
000031E6                            .ChkFloor:
000031E6 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
000031EA 6B00                       		bmi.s	.End2				; If so, branch
000031EC 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
000031F0 4A41                       		tst.w	d1				; Have we hit the ceiling?
000031F2 6A00                       		bpl.s	.End2				; If not, branch
000031F4 D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
000031F8 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
000031FC 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00003200 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
00003206 6000                       		bra.s	PlayerResetOnFloor		; Reset status on floor
00003208                            		
00003208                            .End2:
00003208 4E75                       		rts
0000320A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000320A                            ; Reset a player object's status on the floor
0000320A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000320A                            PlayerResetOnFloor:
0000320A                            		playSnd	#sSkid, 2			; Play skid sound
0000320A 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
00003210 4A28 0000                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
00003214 6600                       		bne.s	PlayerResetOnFloorPart3	; If so, branch
00003216 4228 0020                  		clr.b	_objAnim(a0)			; Set walking animation
0000321A                            		
0000321A                            PlayerResetOnFloorPart2:
0000321A 0828 0002 0028             		btst	#2,_objStatus(a0)			; Was Sonic rolling?
00003220 6700                       		beq.s	PlayerResetOnFloorPart3	; If so, branch
00003222 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Clear roll flag
00003228 1168 0000 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
0000322E 1168 0000 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00003234 4228 0020                  		clr.b	_objAnim(a0)			; Set walking animation
00003238                            	;	subq.w	#5,_objYPos(a0)			; Align with floor
00003238                            
00003238                            PlayerResetOnFloorPart3:
00003238 0228 00DD 0028             		andi.b	#$DD,_objStatus(a0)		; Clear "pushing", and "jumping" flag
0000323E 4228 0000                  		clr.b	_objJumping(a0)			; Clear jumping flag
00003242 4228 0000                  		clr.b	_objFlipAngle(a0)			; Reset flip angle
00003246 4228 0000                  		clr.b	_objFlipTurned(a0)			; Reset flip inverted flag
0000324A 4228 0000                  		clr.b	_objFlipRemain(a0)			; Reset flips remaining
0000324E 4E75                       		rts
00003250                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003250                            ; Calculate the room in front of a player object
00003250                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003250                            PlayerCalcRoomInFront:
00003250 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00003256 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
0000325C 6700                       		beq.s	.NotPrimary			; If not, branch
0000325E 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003264                            
00003264                            .NotPrimary:
00003264 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
00003268                            		
00003268 2628 0014                  		move.l	_objXPos(a0),d3			; Get X position
0000326C 2428 0018                  		move.l	_objYPos(a0),d2			; Get Y position
00003270 3228 001C                  		move.w	_objXVel(a0),d1			; Get X velocity
00003274 48C1                       		ext.l	d1				; ''
00003276 E181                       		asl.l	#8,d1				; Shift it
00003278 D681                       		add.l	d1,d3				; Add onto X position
0000327A 3228 001E                  		move.w	_objYVel(a0),d1			; Get Y velocity
0000327E 48C1                       		ext.l	d1				; ''
00003280 E181                       		asl.l	#8,d1				; Shift it
00003282 D481                       		add.l	d1,d2				; Add onto Y position
00003284 4842                       		swap	d2				; Get actual Y
00003286 4843                       		swap	d3				; Get actual X
00003288 1140 002E                  		move.b	d0,_objNextTilt(a0)		; Set primary angle
0000328C 1140 002F                  		move.b	d0,_objTilt(a0)			; Set secondary angle
00003290 1200                       		move.b	d0,d1				; Copy angle
00003292 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00003296 6700                       		beq.s	.DownUp				; If not, branch
00003298 5200                       		addq.b	#1,d0				; Shift the angle
0000329A                            
0000329A                            .DownUp:
0000329A 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
0000329E 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
000032A2 6700 0000                  		beq.w	PlayerChkFloorDist_Part2	; If quadrant 0, get the floor distance
000032A6 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
000032AA 6700 0000                  		beq.w	PlayerChkCeilingDist_Part2	; If so, branch
000032AE 0201 0038                  		andi.b	#$38,d1				; Are we on a flat enough surface?
000032B2 6600                       		bne.s	.ChkWall			; If not, branch
000032B4 5042                       		addq.w	#8,d2				; Add 8 to the Y position
000032B6                            
000032B6                            .ChkWall:
000032B6 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
000032BA 6700 0000                  		beq.w	PlayerChkLeftWallDist_Part2	; If so, branch
000032BE 6000 0000                  		bra.w	PlayerChkRightWallDist_Part2	; Get the right wall distance
000032C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032C2                            ; Calculate the room over a player object
000032C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032C2                            PlayerCalcRoomOverHead:
000032C2 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
000032C8 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
000032CE 6700                       		beq.s	.NotPrimary			; If not, branch
000032D0 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
000032D6                            
000032D6                            .NotPrimary:
000032D6 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
000032DA 1140 002E                  		move.b	d0,_objNextTilt(a0)		; Set primary angle
000032DE 1140 002F                  		move.b	d0,_objTilt(a0)			; Set secondary angle
000032E2                            		
000032E2 0600 0020                  		addi.b	#$20,d0				; Shift the angle
000032E6 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
000032EA 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
000032EE 6700 0000                  		beq.w	PlayerChkLeftCeilDist		; If so, branch
000032F2 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
000032F6 6700 0000                  		beq.w	PlayerChkCeiling		; If so, branch
000032FA 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0?
000032FE 6700 0000                  		beq.w	PlayerChkRightCeilDist		; If so, branch
00003302                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003302                            ; Get the distance between the floor and a player object (with primary and secondary angles)
00003302                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003302                            PlayerChkFloor:
00003302 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00003308 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
0000330E 6700                       		beq.s	.NotPrimary			; If not, branch
00003310 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003316                            
00003316                            .NotPrimary:
00003316 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Get top solid bits
0000331A                            		
0000331A                            		; Get the angle on the bottom right sensor
0000331A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000331E 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003322 7000                       		moveq	#0,d0
00003324 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003328 4880                       		ext.w	d0				; ''
0000332A D440                       		add.w	d0,d2				; Add onto Y position
0000332C 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003330 4880                       		ext.w	d0				; ''
00003332 D640                       		add.w	d0,d3				; Add onto X position
00003334 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003338 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000333C 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000333E 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003342                            		push.w	d1				; Save the primary floor distance
00003342 3F01                     M 	move.w	d1,-(sp)
00003344                            
00003344                            		; Get the angle on the bottom left sensor
00003344 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003348 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000334C 7000                       		moveq	#0,d0
0000334E 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003352 4880                       		ext.w	d0				; ''
00003354 D440                       		add.w	d0,d2				; Add onto Y position
00003356 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000335A 4880                       		ext.w	d0				; ''
0000335C 9640                       		sub.w	d0,d3				; Subtract from X position
0000335E 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003362 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003366 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003368 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000336C                            		
0000336C                            		; Update the object's angle
0000336C                            		pop.w	d0				; Restore the primary floor distance
0000336C 301F                     M 	move.w	(sp)+,d0
0000336E 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00003370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003370                            PlayerPickAngle:
00003370 1628 002F                  		move.b	_objTilt(a0),d3			; Get secondary angle
00003374 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00003376 6F00                       		ble.s	.ChkSetAngle			; If not, branch
00003378 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
0000337C C141                       		exg.l	d0,d1				; Switch floor distance values
0000337E                            		
0000337E                            .ChkSetAngle:
0000337E 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00003382 6700                       		beq.s	.End				; If not, branch
00003384 1602                       		move.b	d2,d3				; Set the new angle value
00003386                            		
00003386                            .End:
00003386 4E75                       		rts
00003388                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003388                            ; Get the distance between the floor and the player object
00003388                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003388                            PlayerChkFloorDist:
00003388 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000338C 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003390                            
00003390                            PlayerChkFloorDist_Part2:
00003390 0642 000A                  		addi.w	#10,d2				; Check 10 pixels down
00003394 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003398 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000339C 4246                       		clr.w	d6				; No flip bits
0000339E 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000033A2 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
000033A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033A4                            PlayerGetPrimaryAngle:
000033A4 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000033A8 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
000033AC 6700                       		beq.s	.End				; If not, branch
000033AE 1602                       		move.b	d2,d3				; Set the new angle value
000033B0                            		
000033B0                            .End:
000033B0 4E75                       		rts
000033B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033B2                            sub_F846:
000033B2 3628 0014                  		move.w	_objXPos(a0),d3
000033B6 3428 0018                  		move.w	_objYPos(a0),d2
000033BA 5942                       		subq.w	#4,d2
000033BC 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
000033C2 0C28 000D 0000             		cmpi.b	#$D,_objLRBSolid(a0)		; Are we on the primary path?
000033C8 6700                       		beq.s	.NotPrimary			; If not, branch
000033CA 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
000033D0                            
000033D0                            .NotPrimary:
000033D0 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000033D4 4214                       		clr.b	(a4)				; Clear it
000033D6 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000033DA 4246                       		clr.w	d6				; No flip bits
000033DC 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Solidity bits
000033E0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000033E4 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000033E8 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000033EC 6700                       		beq.s	.End				; If not, branch
000033EE 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
000033F0                            
000033F0                            .End:
000033F0 4E75                       		rts
000033F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033F2                            ; Check for the edge of a floor
000033F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033F2                            PlayerChkFloorEdge:
000033F2 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000033F6                            
000033F6                            PlayerChkFloorEdge_Part2:
000033F6 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000033FA 7000                       		moveq	#0,d0
000033FC 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003400 4880                       		ext.w	d0				; ''
00003402 D440                       		add.w	d0,d2				; Add onto Y position
00003404                            
00003404                            PlayerChkFloorEdge_Part3:
00003404 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
0000340A 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00003410 6700                       		beq.s	.NotPrimary			; If not, branch
00003412 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003418                            
00003418                            .NotPrimary:
00003418 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000341C 4214                       		clr.b	(a4)				; Clear it
0000341E 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003422 4246                       		clr.w	d6				; No flip bits
00003424 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Solidity bits
00003428 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000342C 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003430 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003434 6700                       		beq.s	.End				; If not, branch
00003436 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00003438                            
00003438                            .End:
00003438 4E75                       		rts
0000343A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000343A                            ; Get the distance between the floor and an object
0000343A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000343A                            ObjCheckFloorDist:
0000343A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000343E                            		
0000343E                            ObjCheckFloorDist_Part2:
0000343E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003442                            
00003442                            ObjCheckFloorDist_Part3:
00003442 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003446 4880                       		ext.w	d0				; ''
00003448 D440                       		add.w	d0,d2				; Add onto Y position
0000344A 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000344E 4214                       		clr.b	(a4)				; Clear it
00003450 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003454 4246                       		clr.w	d6				; No flip bits
00003456 7A0C                       		moveq	#$C,d5				; Solidity bits
00003458 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000345C 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003460 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003464 6700                       		beq.s	.End				; If not, branch
00003466 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00003468                            
00003468                            .End:
00003468 4E75                       		rts
0000346A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000346A                            ; Get the distance between a right ceiling and a player object
0000346A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000346A                            PlayerChkRightCeilDist:
0000346A                            		; Get the angle on the bottom right (rotated) sensor
0000346A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000346E 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003472 7000                       		moveq	#0,d0
00003474 1028 002C                  		move.b	_objColW(a0),d0			; Get collision height
00003478 4880                       		ext.w	d0				; ''
0000347A 9440                       		sub.w	d0,d2				; Subtract from Y position
0000347C 1028 002D                  		move.b	_objColH(a0),d0			; Get collision width
00003480 4880                       		ext.w	d0				; ''
00003482 D640                       		add.w	d0,d3				; Add onto X position
00003484 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003488 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000348C 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000348E 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003492                            		push.w	d1				; Save the primary floor distance
00003492 3F01                     M 	move.w	d1,-(sp)
00003494                            
00003494                            		; Get the angle on the bottom left (rotated) sensor
00003494 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003498 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000349C 7000                       		moveq	#0,d0
0000349E 1028 002C                  		move.b	_objColW(a0),d0			; Get collision height
000034A2 4880                       		ext.w	d0				; ''
000034A4 D440                       		add.w	d0,d2				; Add onto Y position
000034A6 1028 002D                  		move.b	_objColH(a0),d0			; Get collision width
000034AA 4880                       		ext.w	d0				; ''
000034AC D640                       		add.w	d0,d3				; Add onto X position
000034AE 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000034B2 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000034B6 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000034B8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000034BC                            
000034BC                            		; Update the object's angle
000034BC                            		pop.w	d0				; Restore the primary floor distance
000034BC 301F                     M 	move.w	(sp)+,d0
000034BE 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
000034C2 6000 FEAC                  		bra.w	PlayerPickAngle		; Get the angle
000034C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034C6                            ; Get the distance between a right wall and a player object
000034C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034C6                            PlayerChkRightWallDist:
000034C6 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000034CA 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000034CE                            
000034CE                            PlayerChkRightWallDist_Part2:
000034CE 0643 000A                  		addi.w	#10,d3				; Check 10 pixels to the right
000034D2 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000034D6 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000034DA 4246                       		clr.w	d6				; No flip bits
000034DC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000034E0 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
000034E4 6000 FEBE                  		bra.w	PlayerGetPrimaryAngle		; Get angle
000034E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034E8                            ; Get the distance between a right wall and an object
000034E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034E8                            ObjCheckRightWallDist:
000034E8 D668 0014                  		add.w	_objXPos(a0),d3			; Add X position
000034EC 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000034F0 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000034F4 4214                       		clr.b	(a4)				; Clear it
000034F6 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000034FA 4246                       		clr.w	d6				; No flip bits
000034FC 7A0D                       		moveq	#$D,d5				; Solidity bits
000034FE 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003502 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003506 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000350A 6700                       		beq.s	.End				; If not, branch
0000350C 163C 00C0                  		move.b	#-$40,d3			; Angle value for when the object touched an odd angle (usually $FF)
00003510                            
00003510                            .End:
00003510 4E75                       		rts
00003512                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003512                            ; Get the distance between a ceiling and a player object (with primary and secondary angles)
00003512                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003512                            PlayerChkCeiling:
00003512                            		; Get the angle on the bottom right sensor
00003512 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003516 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000351A 7000                       		moveq	#0,d0
0000351C 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003520 4880                       		ext.w	d0				; ''
00003522 9440                       		sub.w	d0,d2				; Subtract from Y position
00003524 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003528 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000352C 4880                       		ext.w	d0				; ''
0000352E D640                       		add.w	d0,d3				; Add onto X position
00003530 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003534 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003538 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000353C 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003540                            		push.w	d1				; Save the primary floor distance
00003540 3F01                     M 	move.w	d1,-(sp)
00003542                            
00003542                            		; Get the angle on the bottom left sensor
00003542 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003546 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000354A 7000                       		moveq	#0,d0
0000354C 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003550 4880                       		ext.w	d0				; ''
00003552 9440                       		sub.w	d0,d2				; Subtract from Y position
00003554 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003558 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000355C 4880                       		ext.w	d0				; ''
0000355E 9640                       		sub.w	d0,d3				; Subtract from X position
00003560 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003564 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003568 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000356C 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003570                            		
00003570                            		; Update the object's angle
00003570                            		pop.w	d0				; Restore the primary floor distance
00003570 301F                     M 	move.w	(sp)+,d0
00003572 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003576 6000 FDF8                  		bra.w	PlayerPickAngle		; Get the angle
0000357A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000357A                            ; Get the distance between a ceiling and a player object
0000357A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000357A                            PlayerChkCeilingDist:
0000357A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000357E 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003582                            
00003582                            PlayerChkCeilingDist_Part2:
00003582 0442 000A                  		subi.w	#10,d2				; Check 10 pixels up
00003586 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000358A 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000358E 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003592 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003596 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000359A 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
0000359E 6000 FE04                  		bra.w	PlayerGetPrimaryAngle		; Get angle
000035A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035A2                            ; Get the distance between a ceiling and an object
000035A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035A2                            ObjCheckCeilingDist:
000035A2 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000035A6 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000035AA 7000                       		moveq	#0,d0
000035AC 1028 002D                  		move.b	_objColH(a0),d0		; Get collision height
000035B0 4880                       		ext.w	d0				; ''
000035B2 9440                       		sub.w	d0,d2				; Subtract it from Y position
000035B4 0A42 000F                  		eori.w	#$F,d2				; Flip it
000035B8 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000035BC 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000035C0 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000035C4 7A0D                       		moveq	#$D,d5				; Solidity bits
000035C6 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000035CA 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000035CE 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000035D2 6700                       		beq.s	.End				; If not, branch
000035D4 163C 0080                  		move.b	#$80,d3				; Angle value for when the object touched an odd angle (usually $FF)
000035D8                            
000035D8                            .End:
000035D8 4E75                       		rts
000035DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035DA                            ; Get the distance between a left ceiling and a player object
000035DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035DA                            PlayerChkLeftCeilDist:
000035DA                            		; Get the angle on the bottom right (rotated) sensor
000035DA 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000035DE 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000035E2 7000                       		moveq	#0,d0
000035E4 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000035E8 4880                       		ext.w	d0				; ''
000035EA 9440                       		sub.w	d0,d2				; Subtract from Y position
000035EC 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000035F0 4880                       		ext.w	d0				; ''
000035F2 9640                       		sub.w	d0,d3				; Subtract from X position
000035F4 0A43 000F                  		eori.w	#$F,d3				; Flip it
000035F8 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000035FC 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003600 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003604 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003608                            		push.w	d1				; Save the primary floor distance
00003608 3F01                     M 	move.w	d1,-(sp)
0000360A                            
0000360A                            		; Get the angle on the bottom left (rotated) sensor
0000360A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000360E 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003612 7000                       		moveq	#0,d0
00003614 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003618 4880                       		ext.w	d0				; ''
0000361A D440                       		add.w	d0,d2				; Add onto Y position
0000361C 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003620 4880                       		ext.w	d0				; ''
00003622 9640                       		sub.w	d0,d3				; Subtract from X position
00003624 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003628 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
0000362C 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003630 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003634 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003638                            
00003638                            		; Update the object's angle
00003638                            		pop.w	d0				; Restore the primary floor distance
00003638 301F                     M 	move.w	(sp)+,d0
0000363A 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
0000363E 6000 FD30                  		bra.w	PlayerPickAngle		; Get the angle
00003642                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003642                            ; Get the distance between a left wall and a player object
00003642                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003642                            PlayerChkLeftWallDist:
00003642 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003646 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000364A                            
0000364A                            PlayerChkLeftWallDist_Part2:
0000364A 0443 000A                  		subi.w	#10,d3				; Check 10 pixels to the left
0000364E 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003652 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003656 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000365A 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000365E 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003662 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003666 6000 FD3C                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000366A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000366A                            ; Get the distance between a left wall and an object
0000366A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000366A                            ObjCheckLeftWallDist:
0000366A D668 0014                  		add.w	_objXPos(a0),d3			; Add X position
0000366E 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003672 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003676 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000367A 4214                       		clr.b	(a4)				; Clear it
0000367C 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003680 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003684 7A0D                       		moveq	#$D,d5				; Solidity bits
00003686 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000368A 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
0000368E 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003692 6700                       		beq.s	.End				; If not, branch
00003694 163C 0040                  		move.b	#$40,d3				; Angle value for when the object touched an odd angle (usually $FF)
00003698                            
00003698                            .End:
00003698 4E75                       		rts
0000369A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000369A                            ; Move a player object along on the ground
0000369A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000369A                            PlayerAnglePos:
0000369A 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
000036A0 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
000036A6 6700                       		beq.s	.NotPrimary			; If not, branch
000036A8 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
000036AE                            
000036AE                            .NotPrimary:
000036AE 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Get top solid bits
000036B2 0828 0003 0028             		btst	#3,_objStatus(a0)			; Are we standing on a player object?
000036B8 6700                       		beq.s	.NotOnObj			; If not, branch
000036BA 4268 002E                  		clr.w	_objNextTilt(a0)			; Set the angles to 0
000036BE 4E75                       		rts
000036C0                            
000036C0                            .NotOnObj:
000036C0 317C 0303 002E             		move.w	#$0303,_objNextTilt(a0)		; Set the angles to 3
000036C6                            		
000036C6                            		; Get which quadrant the object is in on the ground
000036C6                            		; This makes it so that angles:
000036C6                            		; 	$E0-$20 = Quadrant 0 (floor)
000036C6                            		;	$1F-$5F = Quadrant $40 (left wall)
000036C6                            		;	$60-$A0 = Quadrant $80 (ceiling)
000036C6                            		;	$A1-$DF = Quadrant $C0 (right wall)
000036C6 1028 0000                  		move.b	_objAngle(a0),d0			; Get the angle
000036CA 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
000036CE 6700                       		beq.s	.DownUp				; If not, branch
000036D0 5200                       		addq.b	#1,d0				; Shift the angle
000036D2                            
000036D2                            .DownUp:
000036D2 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
000036D6 0200 00C0                  		andi.b	#$C0,d0				; Get which quadrant we are in (use $E0 instaead of $C0 for 8 directions)
000036DA 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40 (left wall)?
000036DE 6700 0000                  		beq.w	PlayerMoveLWall		; If so, branch
000036E2 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80 (ceiling)?
000036E6 6700 0000                  		beq.w	PlayerMoveCeiling		; Is so, branch
000036EA 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0 (right wall)?
000036EE 6700 0000                  		beq.w	PlayerMoveRWall		; If so, branch
000036F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036F2                            ; Move the object along the floor
000036F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036F2                            PlayerMoveFloor:
000036F2                            		; Get the angle on the bottom right sensor
000036F2 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000036F6 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000036FA 7000                       		moveq	#0,d0
000036FC 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003700 4880                       		ext.w	d0				; ''
00003702 D440                       		add.w	d0,d2				; Add onto Y position
00003704 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003708 4880                       		ext.w	d0				; ''
0000370A D640                       		add.w	d0,d3				; Add onto X position
0000370C 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003710 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003714 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003716 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000371A                            		push.w	d1				; Save the primary floor distance
0000371A 3F01                     M 	move.w	d1,-(sp)
0000371C                            
0000371C                            		; Get the angle on the bottom left sensor
0000371C 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003720 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003724 7000                       		moveq	#0,d0
00003726 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000372A 4880                       		ext.w	d0				; ''
0000372C D440                       		add.w	d0,d2				; Add onto Y position
0000372E 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003732 4880                       		ext.w	d0				; ''
00003734 9640                       		sub.w	d0,d3				; Add onto X position
00003736 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
0000373A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000373E 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003740 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003744                            		
00003744                            		; Update the object's angle
00003744                            		pop.w	d0				; Restore the primary floor distance
00003744 301F                     M 	move.w	(sp)+,d0
00003746 6100 0000                  		bsr.w	PlayerSetAngle			; Set the new angle
0000374A                            		
0000374A                            		; Check if the object has hit a wall or is about to fall
0000374A 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
0000374C 6700                       		beq.s	.End				; If so, branch
0000374E 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003750 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003754 6D00                       		blt.s	.End				; If so, branch
00003756 D368 0018                  		add.w	d1,_objYPos(a0)			; Move us on to the surface
0000375A                            
0000375A                            .End:
0000375A 4E75                       		rts
0000375C                            
0000375C                            .ChkFall:
0000375C 1028 001C                  		move.b	_objXVel(a0),d0			; Get the integer part of the X velocity
00003760 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003762 4400                       		neg.b	d0				; Force it to be positive
00003764                            
00003764                            .GetMinDist:
00003764 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
00003766 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000376A 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
0000376C 103C 000E                  		move.b	#$E,d0				; ''
00003770                            
00003770                            .ChkDist:
00003770 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003772 6E00                       		bgt.s	.SetAir				; If so, branch
00003774 D368 0018                  		add.w	d1,_objYPos(a0)			; Move us on to the surface
00003778 4E75                       		rts
0000377A                            
0000377A                            .SetAir:
0000377A 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00003780 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00003786 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
0000378C 4E75                       		rts
0000378E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000378E                            ; Set the objects's angle
0000378E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000378E                            PlayerSetAngle:
0000378E 1428 002F                  		move.b	_objTilt(a0),d2			; Get secondary angle
00003792 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00003794 6F00                       		ble.s	.ChkSetAngle			; If not, branch
00003796 1428 002E                  		move.b	_objNextTilt(a0),d2		; Get primary angle
0000379A 3200                       		move.w	d0,d1				; Get primary floor distance
0000379C                            		
0000379C                            .ChkSetAngle:
0000379C 0802 0000                  		btst	#0,d2				; Is this an odd angle (usually $FF)?
000037A0 6600                       		bne.s	.LatchOnFlat			; If so, branch
000037A2 1002                       		move.b	d2,d0				; Get angle change
000037A4 9028 0000                  		sub.b	_objAngle(a0),d0			; ''
000037A8 6A00                       		bpl.s	.ChkDist			; ''
000037AA 4400                       		neg.b	d0				; ''
000037AC                            
000037AC                            .ChkDist:
000037AC 0C00 0020                  		cmpi.b	#$20,d0				; Has the player moved $20 degrees or more?
000037B0 6400                       		bhs.s	.LatchOnFlat			; If so, branch
000037B2 1142 0000                  		move.b	d2,_objAngle(a0)			; Set the new angle value
000037B6 4E75                       		rts
000037B8                            
000037B8                            .LatchOnFlat:
000037B8 1428 0000                  		move.b	_objAngle(a0),d2			; Get old angle value
000037BC 0602 0020                  		addi.b	#$20,d2				; Shift the angle
000037C0 0202 00C0                  		andi.b	#$C0,d2				; Flatten the angle
000037C4 1142 0000                  		move.b	d2,_objAngle(a0)			; Set the new angle value
000037C8 4E75                       		rts
000037CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037CA                            ; Move the object along the right wall
000037CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037CA                            PlayerMoveRWall:
000037CA                            		; Get the angle on the bottom right (rotated) sensor
000037CA 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000037CE 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000037D2 7000                       		moveq	#0,d0
000037D4 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000037D8 4880                       		ext.w	d0				; ''
000037DA 9440                       		sub.w	d0,d2				; Add onto Y position
000037DC 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000037E0 4880                       		ext.w	d0				; ''
000037E2 D640                       		add.w	d0,d3				; Add onto X position
000037E4 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000037E8 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000037EC 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000037EE 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000037F2                            		push.w	d1				; Save the primary floor distance
000037F2 3F01                     M 	move.w	d1,-(sp)
000037F4                            
000037F4                            		; Get the angle on the bottom left (rotated) sensor
000037F4 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000037F8 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000037FC 7000                       		moveq	#0,d0
000037FE 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003802 4880                       		ext.w	d0				; ''
00003804 D440                       		add.w	d0,d2				; Add onto Y position
00003806 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000380A 4880                       		ext.w	d0				; ''
0000380C D640                       		add.w	d0,d3				; Add onto X position
0000380E 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003812 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003816 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003818 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000381C                            		
0000381C                            		; Update the object's angle
0000381C                            		pop.w	d0				; Restore the primary floor distance
0000381C 301F                     M 	move.w	(sp)+,d0
0000381E 6100 FF6E                  		bsr.w	PlayerSetAngle			; Set the new angle
00003822                            
00003822                            		; Check if the object has hit a wall or is about to fall
00003822 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003824 6700                       		beq.s	.End				; If so, branch
00003826 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003828 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
0000382C 6D00                       		blt.s	.End				; If so, branch
0000382E D368 0014                  		add.w	d1,_objXPos(a0)			; Move us on to the surface
00003832                            
00003832                            .End:
00003832 4E75                       		rts
00003834                            
00003834                            .ChkFall:
00003834 1028 001E                  		move.b	_objYVel(a0),d0			; Get the integer part of the Y velocity
00003838 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
0000383A 4400                       		neg.b	d0				; Force it to be positive
0000383C                            
0000383C                            .GetMinDist:
0000383C 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
0000383E 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003842 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003844 103C 000E                  		move.b	#$E,d0				; ''
00003848                            
00003848                            .ChkDist:
00003848 B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000384A 6E00                       		bgt.s	.SetAir				; If so, branch
0000384C D368 0014                  		add.w	d1,_objXPos(a0)			; Move us on to the surface
00003850 4E75                       		rts
00003852                            
00003852                            .SetAir:
00003852 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00003858 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
0000385E 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00003864 4E75                       		rts
00003866                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003866                            ; Move the object along the ceiling
00003866                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003866                            PlayerMoveCeiling:
00003866                            		; Get the angle on the bottom right (rotated) sensor
00003866 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000386A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000386E 7000                       		moveq	#0,d0
00003870 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003874 4880                       		ext.w	d0				; ''
00003876 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003878 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000387C 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003880 4880                       		ext.w	d0				; ''
00003882 D640                       		add.w	d0,d3				; Add onto X position
00003884 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003888 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000388C 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003890 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003894                            		push.w	d1				; Save the primary floor distance
00003894 3F01                     M 	move.w	d1,-(sp)
00003896                            
00003896                            		; Get the angle on the bottom left (rotated) sensor
00003896 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000389A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000389E 7000                       		moveq	#0,d0
000038A0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000038A4 4880                       		ext.w	d0				; ''
000038A6 9440                       		sub.w	d0,d2				; Subtract from the Y position
000038A8 0A42 000F                  		eori.w	#$F,d2				; Flip it
000038AC 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000038B0 4880                       		ext.w	d0				; ''
000038B2 9640                       		sub.w	d0,d3				; Subtract from the X position
000038B4 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000038B8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000038BC 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000038C0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000038C4                            		
000038C4                            		; Update the object's angle
000038C4                            		pop.w	d0				; Restore the primary floor distance
000038C4 301F                     M 	move.w	(sp)+,d0
000038C6 6100 FEC6                  		bsr.w	PlayerSetAngle			; Set the new angle
000038CA                            		
000038CA                            		; Check if the object has hit a wall or is about to fall
000038CA 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000038CC 6700                       		beq.s	.End				; If so, branch
000038CE 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000038D0 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000038D4 6D00                       		blt.s	.End				; If so, branch
000038D6 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move us on to the surface
000038DA                            
000038DA                            .End:
000038DA 4E75                       		rts
000038DC                            
000038DC                            .ChkFall:
000038DC 1028 001C                  		move.b	_objXVel(a0),d0			; Get the integer part of the X velocity
000038E0 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000038E2 4400                       		neg.b	d0				; Force it to be positive
000038E4                            
000038E4                            .GetMinDist:
000038E4 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
000038E6 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000038EA 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000038EC 103C 000E                  		move.b	#$E,d0				; ''
000038F0                            
000038F0                            .ChkDist:
000038F0 B200                       		cmp.b	d0,d1				; Are we about to fall off?
000038F2 6E00                       		bgt.s	.SetAir				; If so, branch
000038F4 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move us on to the surface
000038F8 4E75                       		rts
000038FA                            
000038FA                            .SetAir:
000038FA 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00003900 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00003906 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
0000390C 4E75                       		rts
0000390E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000390E                            ; Move the object along the left wall
0000390E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000390E                            PlayerMoveLWall:
0000390E                            		; Get the angle on the bottom right (rotated) sensor
0000390E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003912 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003916 7000                       		moveq	#0,d0
00003918 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000391C 4880                       		ext.w	d0				; ''
0000391E 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003920 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003924 4880                       		ext.w	d0				; ''
00003926 9640                       		sub.w	d0,d3				; Subtract from X position
00003928 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000392C 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
00003930 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003934 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003938 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000393C                            		push.w	d1				; Save the primary floor distance
0000393C 3F01                     M 	move.w	d1,-(sp)
0000393E                            
0000393E                            		; Get the angle on the bottom left (rotated) sensor
0000393E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003942 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003946 7000                       		moveq	#0,d0
00003948 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000394C 4880                       		ext.w	d0				; ''
0000394E D440                       		add.w	d0,d2				; Add onto Y position
00003950 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003954 4880                       		ext.w	d0				; ''
00003956 9640                       		sub.w	d0,d3				; Subtract from X position
00003958 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000395C 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003960 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003964 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003968 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000396C                            		
0000396C                            		; Update the object's angle
0000396C                            		pop.w	d0				; Restore the primary floor distance
0000396C 301F                     M 	move.w	(sp)+,d0
0000396E 6100 FE1E                  		bsr.w	PlayerSetAngle			; Set the new angle
00003972                            		
00003972                            		; Check if the object has hit a wall or is about to fall
00003972 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003974 6700                       		beq.s	.End				; If so, branch
00003976 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003978 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
0000397C 6D00                       		blt.s	.End				; If so, branch
0000397E 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move us on to the surface
00003982                            
00003982                            .End:
00003982 4E75                       		rts
00003984                            
00003984                            .ChkFall:
00003984 1028 001E                  		move.b	_objYVel(a0),d0			; Get the integer part of the Y velocity
00003988 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
0000398A 4400                       		neg.b	d0				; Force it to be positive
0000398C                            
0000398C                            .GetMinDist:
0000398C 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
0000398E 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003992 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003994 103C 000E                  		move.b	#$E,d0				; ''
00003998                            
00003998                            .ChkDist:
00003998 B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000399A 6E00                       		bgt.s	.SetAir				; If so, branch
0000399C 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move us on to the surface
000039A0 4E75                       		rts
000039A2                            
000039A2                            .SetAir:
000039A2 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
000039A8 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
000039AE 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
000039B4 4E75                       		rts
000039B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039B6                            ; Find the nearest floor from the object's position
000039B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039B6                            ; PARAMETERS:
000039B6                            ;	d2.w	- Y position of the object's bottom sensor
000039B6                            ;	d3.w	- X position of the object's bottom sensor
000039B6                            ;	d5.w	- Bit to chect for solidity
000039B6                            ;	d6.w	- Flip bits (for walls and ceilings)
000039B6                            ;	a3.w	- Distance in pixels to check for blocks above or below the sensor
000039B6                            ;	a4.w	- Pointer to where the angle value will be stored
000039B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039B6                            ; RETURNS:
000039B6                            ;	d1.w	- The distance from the object to the floor
000039B6                            ;	(a1).w	- The block ID in the chunk where the object is standing
000039B6                            ;	(a4).w	- The floor angle
000039B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039B6                            Level_FindFloor:
000039B6 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
000039BA 3011                       		move.w	(a1),d0				; Get block ID
000039BC 3800                       		move.w	d0,d4				; Copy that
000039BE 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
000039C2 6700                       		beq.s	.IsBlank			; If it's blank, branch
000039C4 0B04                       		btst	d5,d4				; Is the block solid?
000039C6 6600                       		bne.s	.IsSolid			; If so, branch
000039C8                            
000039C8                            .IsBlank:
000039C8 D44B                       		add.w	a3,d2				; Check below the sensor
000039CA 6100 0000                  		bsr.w	Level_FindFloor2		; Try to find a solid block there
000039CE 944B                       		sub.w	a3,d2				; Restore Y position of sensor
000039D0 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
000039D4 4E75                       		rts
000039D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000039D6                            .IsSolid:
000039D6 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
000039DA D040                       		add.w	d0,d0				; Turn ID into offset
000039DC 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000039E0 0240 00FF                  		andi.w	#$FF,d0				; ''
000039E4 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
000039E6                            
000039E6 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
000039EA 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
000039EE E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
000039F0                            
000039F0 3203                       		move.w	d3,d1				; Get the object's X position
000039F2 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
000039F6 6700                       		beq.s	.NoXFlip			; If not, branch
000039F8 4641                       		not.w	d1				; Flip the X position
000039FA 4414                       		neg.b	(a4)				; Flip the angle
000039FC                            		
000039FC                            .NoXFlip:
000039FC 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003A00 6700                       		beq.s	.NoYFlip			; If not, branch
00003A02 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003A06 4414                       		neg.b	(a4)				; ''
00003A08 0414 0040                  		subi.b	#$40,(a4)			; ''
00003A0C                            
00003A0C                            .NoYFlip:
00003A0C 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003A10 D240                       		add.w	d0,d1				; Add the collision block's offset
00003A12                            
00003A12 2478 E8F4                  		movea.l	normColArrayPtr.w,a2		; Get the normal collision array
00003A16 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003A1A 4880                       		ext.w	d0				; ''
00003A1C BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003A1E 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003A22 6700                       		beq.s	.NoYFlip2			; If not, branch
00003A24 4440                       		neg.w	d0				; Flip the height
00003A26                            
00003A26                            .NoYFlip2:
00003A26 4A40                       		tst.w	d0				; Check the height
00003A28 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003A2A 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003A2C 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
00003A30 6700                       		beq.s	.MaxFloor			; If so, branch
00003A32 3202                       		move.w	d2,d1				; Get the object's Y position
00003A34 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003A38 D041                       		add.w	d1,d0				; Add onto the height
00003A3A 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003A3E 9240                       		sub.w	d0,d1				; ''
00003A40 4E75                       		rts
00003A42                            
00003A42                            .NegHeight:
00003A42 3202                       		move.w	d2,d1				; Get the object's Y position
00003A44 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003A48 D041                       		add.w	d1,d0				; Add onto the height
00003A4A 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003A4E                            
00003A4E                            .MaxFloor:
00003A4E 944B                       		sub.w	a3,d2				; Check above the sensor
00003A50 6100                       		bsr.s	Level_FindFloor2		; Try to find a solid block there
00003A52 D44B                       		add.w	a3,d2				; Restore Y position of sensor
00003A54 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
00003A58 4E75                       		rts
00003A5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A5A                            Level_FindFloor2:
00003A5A 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003A5E 3011                       		move.w	(a1),d0				; Get block ID
00003A60 3800                       		move.w	d0,d4				; Copy that
00003A62 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003A66 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003A68 0B04                       		btst	d5,d4				; Is the block solid?
00003A6A 6600                       		bne.s	.IsSolid			; If so, branch
00003A6C                            
00003A6C                            .IsBlank:
00003A6C 323C 000F                  		move.w	#$F,d1				; Get max distance
00003A70 3002                       		move.w	d2,d0				; Get the object's Y position
00003A72 0240 000F                  		andi.w	#$F,d0				; Get the Y offset in the height
00003A76 9240                       		sub.w	d0,d1				; Get actual distance
00003A78 4E75                       		rts
00003A7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A7A                            .IsSolid:
00003A7A 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003A7E D040                       		add.w	d0,d0				; Turn ID into offset
00003A80 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003A84 0240 00FF                  		andi.w	#$FF,d0				; ''
00003A88 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003A8A                            
00003A8A 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003A8E 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003A92 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003A94                            
00003A94 3203                       		move.w	d3,d1				; Get the object's X position
00003A96 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003A9A 6700                       		beq.s	.NoXFlip			; If not, branch
00003A9C 4641                       		not.w	d1				; Flip the X position
00003A9E 4414                       		neg.b	(a4)				; Flip the angle
00003AA0                            
00003AA0                            .NoXFlip:
00003AA0 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003AA4 6700                       		beq.s	.NoYFlip			; If not, branch
00003AA6 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003AAA 4414                       		neg.b	(a4)				; ''
00003AAC 0414 0040                  		subi.b	#$40,(a4)			; ''
00003AB0                            
00003AB0                            .NoYFlip:
00003AB0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003AB4 D240                       		add.w	d0,d1				; Add the collision block's offset
00003AB6                            
00003AB6 2478 E8F4                  		movea.l	normColArrayPtr.w,a2		; Get the normal collision array
00003ABA 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003ABE 4880                       		ext.w	d0				; ''
00003AC0 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003AC2 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003AC6 6700                       		beq.s	.NoYFlip2			; If not, branch
00003AC8 4440                       		neg.w	d0				; Flip the height
00003ACA                            
00003ACA                            .NoYFlip2:
00003ACA 4A40                       		tst.w	d0				; Check the height
00003ACC 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003ACE 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003AD0 3202                       		move.w	d2,d1				; Get the object's Y position
00003AD2 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003AD6 D041                       		add.w	d1,d0				; Add onto the height
00003AD8 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003ADC 9240                       		sub.w	d0,d1				; ''
00003ADE 4E75                       		rts
00003AE0                            
00003AE0                            .NegHeight:
00003AE0 3202                       		move.w	d2,d1				; Get the object's Y position
00003AE2 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003AE6 D041                       		add.w	d1,d0				; Add onto the height
00003AE8 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003AEC 4641                       		not.w	d1				; Flip the height
00003AEE 4E75                       		rts
00003AF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AF0                            ; Find the nearest wall from the object's position
00003AF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AF0                            ; PARAMETERS:
00003AF0                            ;	d2.w	- Y position of the object's bottom sensor
00003AF0                            ;	d3.w	- X position of the object's bottom sensor
00003AF0                            ;	d5.w	- Bit to chect for solidity
00003AF0                            ;	d6.w	- Flip bits (for walls and ceilings)
00003AF0                            ;	a3.w	- Distance in pixels to check for blocks left of or right of the sensor
00003AF0                            ;	a4.w	- Pointer to where the angle value will be stored
00003AF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AF0                            ; RETURNS:
00003AF0                            ;	d1.w	- The distance from the object to the floor
00003AF0                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003AF0                            ;	(a4).w	- The floor angle
00003AF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AF0                            Level_FindWall:
00003AF0 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003AF4 3011                       		move.w	(a1),d0				; Get block ID
00003AF6 3800                       		move.w	d0,d4				; Copy that
00003AF8 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003AFC 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003AFE 0B04                       		btst	d5,d4				; Is the block solid?
00003B00 6600                       		bne.s	.IsSolid			; If so, branch
00003B02                            
00003B02                            .IsBlank:
00003B02 D64B                       		add.w	a3,d3				; Check right to the sensor
00003B04 6100 0000                  		bsr.w	Level_FindWall2			; Try to find a solid block there
00003B08 964B                       		sub.w	a3,d3				; Restore X position of sensor
00003B0A 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003B0E 4E75                       		rts
00003B10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B10                            .IsSolid:
00003B10 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003B14 D040                       		add.w	d0,d0				; Turn ID into offset
00003B16 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003B1A 0240 00FF                  		andi.w	#$FF,d0				; ''
00003B1E 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003B20                            
00003B20 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003B24 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003B28 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003B2A                            
00003B2A 3202                       		move.w	d2,d1				; Get the object's Y position
00003B2C 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003B30 6700                       		beq.s	.NoYFlip			; If not, branch
00003B32 4641                       		not.w	d1				; Flip the Y position
00003B34 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003B38 4414                       		neg.b	(a4)				; ''
00003B3A 0414 0040                  		subi.b	#$40,(a4)			; ''
00003B3E                            
00003B3E                            .NoYFlip:
00003B3E 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003B42 6700                       		beq.s	.NoXFlip			; If not, branch
00003B44 4414                       		neg.b	(a4)				; Flip the angle
00003B46                            
00003B46                            .NoXFlip:
00003B46 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003B4A D240                       		add.w	d0,d1				; Add the collision block's offset
00003B4C                            
00003B4C 2478 E8F8                  		movea.l	rotColArrayPtr.w,a2		; Get the normal collision array
00003B50 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003B54 4880                       		ext.w	d0				; ''
00003B56 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003B58 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003B5C 6700                       		beq.s	.NoYFlip2			; If not, branch
00003B5E 4440                       		neg.w	d0				; Flip the height
00003B60                            
00003B60                            .NoYFlip2:
00003B60 4A40                       		tst.w	d0				; Check the height
00003B62 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003B64 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003B66 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
00003B6A 6700                       		beq.s	.MaxFloor			; If so, branch
00003B6C 3203                       		move.w	d3,d1				; Get the object's X position
00003B6E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003B72 D041                       		add.w	d1,d0				; Add onto the height
00003B74 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003B78 9240                       		sub.w	d0,d1				; ''
00003B7A 4E75                       		rts
00003B7C                            
00003B7C                            .NegHeight:
00003B7C 3203                       		move.w	d3,d1				; Get the object's X position
00003B7E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003B82 D041                       		add.w	d1,d0				; Add onto the height
00003B84 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003B88                            
00003B88                            .MaxFloor:
00003B88 964B                       		sub.w	a3,d3				; Check left to the sensor
00003B8A 6100                       		bsr.s	Level_FindWall2			; Try to find a solid block there
00003B8C D64B                       		add.w	a3,d3				; Restore X position of sensor
00003B8E 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
00003B92 4E75                       		rts
00003B94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B94                            Level_FindWall2:
00003B94 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003B98 3011                       		move.w	(a1),d0				; Get block ID
00003B9A 3800                       		move.w	d0,d4				; Copy that
00003B9C 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003BA0 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003BA2 0B04                       		btst	d5,d4				; Is the block solid?
00003BA4 6600                       		bne.s	.IsSolid			; If so, branch
00003BA6                            
00003BA6                            .IsBlank:
00003BA6 323C 000F                  		move.w	#$F,d1				; Get max distance
00003BAA 3003                       		move.w	d3,d0				; Get the object's X position
00003BAC 0240 000F                  		andi.w	#$F,d0				; Get the X offset in the height
00003BB0 9240                       		sub.w	d0,d1				; Get actual distance
00003BB2 4E75                       		rts
00003BB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BB4                            .IsSolid:
00003BB4 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003BB8 D040                       		add.w	d0,d0				; Turn ID into offset
00003BBA 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003BBE 0240 00FF                  		andi.w	#$FF,d0				; ''
00003BC2 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003BC4                            
00003BC4 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003BC8 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003BCC E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003BCE                            
00003BCE 3202                       		move.w	d2,d1				; Get the object's Y position
00003BD0 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003BD4 6700                       		beq.s	.NoYFlip			; If not, branch
00003BD6 4641                       		not.w	d1				; Flip the Y position
00003BD8 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003BDC 4414                       		neg.b	(a4)				; ''
00003BDE 0414 0040                  		subi.b	#$40,(a4)			; ''
00003BE2                            
00003BE2                            .NoYFlip:
00003BE2 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003BE6 6700                       		beq.s	.NoXFlip			; If not, branch
00003BE8 4414                       		neg.b	(a4)				; Flip the angle
00003BEA                            
00003BEA                            .NoXFlip:
00003BEA 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003BEE D240                       		add.w	d0,d1				; Add the collision block's offset
00003BF0                            
00003BF0 2478 E8F8                  		movea.l	rotColArrayPtr.w,a2		; Get the normal collision array
00003BF4 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003BF8 4880                       		ext.w	d0				; ''
00003BFA BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003BFC 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003C00 6700                       		beq.s	.NoYFlip2			; If not, branch
00003C02 4440                       		neg.w	d0				; Flip the height
00003C04                            
00003C04                            .NoYFlip2:
00003C04 4A40                       		tst.w	d0				; Check the height
00003C06 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003C08 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003C0A 3203                       		move.w	d3,d1				; Get the object's X position
00003C0C 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003C10 D041                       		add.w	d1,d0				; Add onto the height
00003C12 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003C16 9240                       		sub.w	d0,d1				; ''
00003C18 4E75                       		rts
00003C1A                            
00003C1A                            .NegHeight:
00003C1A 3203                       		move.w	d3,d1				; Get the object's X position
00003C1C 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003C20 D041                       		add.w	d1,d0				; Add onto the height
00003C22 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003C26 4641                       		not.w	d1				; Flip the height
00003C28 4E75                       		rts
00003C2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C2A                            ; Find the nearest block in the level from the player
00003C2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C2A                            ; PARAMETERS:
00003C2A                            ;	d2.w	- Y position of the object's sensor
00003C2A                            ;	d3.w	- X position of the object's sensor
00003C2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C2A                            ; RETURNS:
00003C2A                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003C2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C2A                            Level_FindBlock:
00003C2A 2278 E856                  		movea.l	lvlLayout.w,a1			; Get level layout pointer address
00003C2E                            
00003C2E 3002                       		move.w	d2,d0				; Get the object's Y position
00003C30 0240 0780                  		andi.w	#$780,d0			; Get Y within layout data
00003C34 EC48                       		lsr.w	#6,d0				; ''						
00003C36 3031 0002                  		move.w	2(a1,d0.w),d0			; Get chunk row offset
00003C3A                            		
00003C3A 3203                       		move.w	d3,d1				; Get the object's X position
00003C3C E649                       		lsr.w	#3,d1				; Divide by 8
00003C3E 3801                       		move.w	d1,d4				; Save for later
00003C40                            		
00003C40 E849                       		lsr.w	#4,d1				; Divide by 16 to get the offset of the chunk in the chunk row
00003C42 0241 00FF                  		andi.w	#$FF,d1				; Only 256 chunks per row
00003C46 D041                       		add.w	d1,d0				; Get offset in the level layout
00003C48                            
00003C48 72FF                       		moveq	#-1,d1				; Prepare the chunk table pointer
00003C4A 4241                       		clr.w	d1				; ''
00003C4C                            		
00003C4C 1231 0000                  		move.b	(a1,d0.w),d1			; Get chunk ID
00003C50 D241                       		add.w	d1,d1				; Turn into offset
00003C52 323B 1000                  		move.w	.ChunkOffsets(pc,d1.w),d1	; Get offset in chunk table
00003C56 3002                       		move.w	d2,d0				; Get the object's Y position
00003C58                            		
00003C58 0240 0070                  		andi.w	#$70,d0				; Get Y position within chunk
00003C5C D240                       		add.w	d0,d1				; Add onto the offset
00003C5E 0244 000E                  		andi.w	#$E,d4				; Get the previously saved X position divided by 8 (for the row offset)
00003C62 D244                       		add.w	d4,d1				; Add onto the offset
00003C64                            		
00003C64 2241                       		movea.l	d1,a1				; Get pointer in chunk table
00003C66 4E75                       		rts
00003C68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C68                            .ChunkOffsets:
00003C68 =00000000                  c		= 0
00003C68                            		rept	256
00003C68                            			dc.w	c
00003C68                            c			= c+$80
00003C68                            		endr
00003C68 0000                     M 	dc.w	c
00003C6A =00000080                M c	=	c+$80
00003C6A 0080                     M 	dc.w	c
00003C6C =00000100                M c	=	c+$80
00003C6C 0100                     M 	dc.w	c
00003C6E =00000180                M c	=	c+$80
00003C6E 0180                     M 	dc.w	c
00003C70 =00000200                M c	=	c+$80
00003C70 0200                     M 	dc.w	c
00003C72 =00000280                M c	=	c+$80
00003C72 0280                     M 	dc.w	c
00003C74 =00000300                M c	=	c+$80
00003C74 0300                     M 	dc.w	c
00003C76 =00000380                M c	=	c+$80
00003C76 0380                     M 	dc.w	c
00003C78 =00000400                M c	=	c+$80
00003C78 0400                     M 	dc.w	c
00003C7A =00000480                M c	=	c+$80
00003C7A 0480                     M 	dc.w	c
00003C7C =00000500                M c	=	c+$80
00003C7C 0500                     M 	dc.w	c
00003C7E =00000580                M c	=	c+$80
00003C7E 0580                     M 	dc.w	c
00003C80 =00000600                M c	=	c+$80
00003C80 0600                     M 	dc.w	c
00003C82 =00000680                M c	=	c+$80
00003C82 0680                     M 	dc.w	c
00003C84 =00000700                M c	=	c+$80
00003C84 0700                     M 	dc.w	c
00003C86 =00000780                M c	=	c+$80
00003C86 0780                     M 	dc.w	c
00003C88 =00000800                M c	=	c+$80
00003C88 0800                     M 	dc.w	c
00003C8A =00000880                M c	=	c+$80
00003C8A 0880                     M 	dc.w	c
00003C8C =00000900                M c	=	c+$80
00003C8C 0900                     M 	dc.w	c
00003C8E =00000980                M c	=	c+$80
00003C8E 0980                     M 	dc.w	c
00003C90 =00000A00                M c	=	c+$80
00003C90 0A00                     M 	dc.w	c
00003C92 =00000A80                M c	=	c+$80
00003C92 0A80                     M 	dc.w	c
00003C94 =00000B00                M c	=	c+$80
00003C94 0B00                     M 	dc.w	c
00003C96 =00000B80                M c	=	c+$80
00003C96 0B80                     M 	dc.w	c
00003C98 =00000C00                M c	=	c+$80
00003C98 0C00                     M 	dc.w	c
00003C9A =00000C80                M c	=	c+$80
00003C9A 0C80                     M 	dc.w	c
00003C9C =00000D00                M c	=	c+$80
00003C9C 0D00                     M 	dc.w	c
00003C9E =00000D80                M c	=	c+$80
00003C9E 0D80                     M 	dc.w	c
00003CA0 =00000E00                M c	=	c+$80
00003CA0 0E00                     M 	dc.w	c
00003CA2 =00000E80                M c	=	c+$80
00003CA2 0E80                     M 	dc.w	c
00003CA4 =00000F00                M c	=	c+$80
00003CA4 0F00                     M 	dc.w	c
00003CA6 =00000F80                M c	=	c+$80
00003CA6 0F80                     M 	dc.w	c
00003CA8 =00001000                M c	=	c+$80
00003CA8 1000                     M 	dc.w	c
00003CAA =00001080                M c	=	c+$80
00003CAA 1080                     M 	dc.w	c
00003CAC =00001100                M c	=	c+$80
00003CAC 1100                     M 	dc.w	c
00003CAE =00001180                M c	=	c+$80
00003CAE 1180                     M 	dc.w	c
00003CB0 =00001200                M c	=	c+$80
00003CB0 1200                     M 	dc.w	c
00003CB2 =00001280                M c	=	c+$80
00003CB2 1280                     M 	dc.w	c
00003CB4 =00001300                M c	=	c+$80
00003CB4 1300                     M 	dc.w	c
00003CB6 =00001380                M c	=	c+$80
00003CB6 1380                     M 	dc.w	c
00003CB8 =00001400                M c	=	c+$80
00003CB8 1400                     M 	dc.w	c
00003CBA =00001480                M c	=	c+$80
00003CBA 1480                     M 	dc.w	c
00003CBC =00001500                M c	=	c+$80
00003CBC 1500                     M 	dc.w	c
00003CBE =00001580                M c	=	c+$80
00003CBE 1580                     M 	dc.w	c
00003CC0 =00001600                M c	=	c+$80
00003CC0 1600                     M 	dc.w	c
00003CC2 =00001680                M c	=	c+$80
00003CC2 1680                     M 	dc.w	c
00003CC4 =00001700                M c	=	c+$80
00003CC4 1700                     M 	dc.w	c
00003CC6 =00001780                M c	=	c+$80
00003CC6 1780                     M 	dc.w	c
00003CC8 =00001800                M c	=	c+$80
00003CC8 1800                     M 	dc.w	c
00003CCA =00001880                M c	=	c+$80
00003CCA 1880                     M 	dc.w	c
00003CCC =00001900                M c	=	c+$80
00003CCC 1900                     M 	dc.w	c
00003CCE =00001980                M c	=	c+$80
00003CCE 1980                     M 	dc.w	c
00003CD0 =00001A00                M c	=	c+$80
00003CD0 1A00                     M 	dc.w	c
00003CD2 =00001A80                M c	=	c+$80
00003CD2 1A80                     M 	dc.w	c
00003CD4 =00001B00                M c	=	c+$80
00003CD4 1B00                     M 	dc.w	c
00003CD6 =00001B80                M c	=	c+$80
00003CD6 1B80                     M 	dc.w	c
00003CD8 =00001C00                M c	=	c+$80
00003CD8 1C00                     M 	dc.w	c
00003CDA =00001C80                M c	=	c+$80
00003CDA 1C80                     M 	dc.w	c
00003CDC =00001D00                M c	=	c+$80
00003CDC 1D00                     M 	dc.w	c
00003CDE =00001D80                M c	=	c+$80
00003CDE 1D80                     M 	dc.w	c
00003CE0 =00001E00                M c	=	c+$80
00003CE0 1E00                     M 	dc.w	c
00003CE2 =00001E80                M c	=	c+$80
00003CE2 1E80                     M 	dc.w	c
00003CE4 =00001F00                M c	=	c+$80
00003CE4 1F00                     M 	dc.w	c
00003CE6 =00001F80                M c	=	c+$80
00003CE6 1F80                     M 	dc.w	c
00003CE8 =00002000                M c	=	c+$80
00003CE8 2000                     M 	dc.w	c
00003CEA =00002080                M c	=	c+$80
00003CEA 2080                     M 	dc.w	c
00003CEC =00002100                M c	=	c+$80
00003CEC 2100                     M 	dc.w	c
00003CEE =00002180                M c	=	c+$80
00003CEE 2180                     M 	dc.w	c
00003CF0 =00002200                M c	=	c+$80
00003CF0 2200                     M 	dc.w	c
00003CF2 =00002280                M c	=	c+$80
00003CF2 2280                     M 	dc.w	c
00003CF4 =00002300                M c	=	c+$80
00003CF4 2300                     M 	dc.w	c
00003CF6 =00002380                M c	=	c+$80
00003CF6 2380                     M 	dc.w	c
00003CF8 =00002400                M c	=	c+$80
00003CF8 2400                     M 	dc.w	c
00003CFA =00002480                M c	=	c+$80
00003CFA 2480                     M 	dc.w	c
00003CFC =00002500                M c	=	c+$80
00003CFC 2500                     M 	dc.w	c
00003CFE =00002580                M c	=	c+$80
00003CFE 2580                     M 	dc.w	c
00003D00 =00002600                M c	=	c+$80
00003D00 2600                     M 	dc.w	c
00003D02 =00002680                M c	=	c+$80
00003D02 2680                     M 	dc.w	c
00003D04 =00002700                M c	=	c+$80
00003D04 2700                     M 	dc.w	c
00003D06 =00002780                M c	=	c+$80
00003D06 2780                     M 	dc.w	c
00003D08 =00002800                M c	=	c+$80
00003D08 2800                     M 	dc.w	c
00003D0A =00002880                M c	=	c+$80
00003D0A 2880                     M 	dc.w	c
00003D0C =00002900                M c	=	c+$80
00003D0C 2900                     M 	dc.w	c
00003D0E =00002980                M c	=	c+$80
00003D0E 2980                     M 	dc.w	c
00003D10 =00002A00                M c	=	c+$80
00003D10 2A00                     M 	dc.w	c
00003D12 =00002A80                M c	=	c+$80
00003D12 2A80                     M 	dc.w	c
00003D14 =00002B00                M c	=	c+$80
00003D14 2B00                     M 	dc.w	c
00003D16 =00002B80                M c	=	c+$80
00003D16 2B80                     M 	dc.w	c
00003D18 =00002C00                M c	=	c+$80
00003D18 2C00                     M 	dc.w	c
00003D1A =00002C80                M c	=	c+$80
00003D1A 2C80                     M 	dc.w	c
00003D1C =00002D00                M c	=	c+$80
00003D1C 2D00                     M 	dc.w	c
00003D1E =00002D80                M c	=	c+$80
00003D1E 2D80                     M 	dc.w	c
00003D20 =00002E00                M c	=	c+$80
00003D20 2E00                     M 	dc.w	c
00003D22 =00002E80                M c	=	c+$80
00003D22 2E80                     M 	dc.w	c
00003D24 =00002F00                M c	=	c+$80
00003D24 2F00                     M 	dc.w	c
00003D26 =00002F80                M c	=	c+$80
00003D26 2F80                     M 	dc.w	c
00003D28 =00003000                M c	=	c+$80
00003D28 3000                     M 	dc.w	c
00003D2A =00003080                M c	=	c+$80
00003D2A 3080                     M 	dc.w	c
00003D2C =00003100                M c	=	c+$80
00003D2C 3100                     M 	dc.w	c
00003D2E =00003180                M c	=	c+$80
00003D2E 3180                     M 	dc.w	c
00003D30 =00003200                M c	=	c+$80
00003D30 3200                     M 	dc.w	c
00003D32 =00003280                M c	=	c+$80
00003D32 3280                     M 	dc.w	c
00003D34 =00003300                M c	=	c+$80
00003D34 3300                     M 	dc.w	c
00003D36 =00003380                M c	=	c+$80
00003D36 3380                     M 	dc.w	c
00003D38 =00003400                M c	=	c+$80
00003D38 3400                     M 	dc.w	c
00003D3A =00003480                M c	=	c+$80
00003D3A 3480                     M 	dc.w	c
00003D3C =00003500                M c	=	c+$80
00003D3C 3500                     M 	dc.w	c
00003D3E =00003580                M c	=	c+$80
00003D3E 3580                     M 	dc.w	c
00003D40 =00003600                M c	=	c+$80
00003D40 3600                     M 	dc.w	c
00003D42 =00003680                M c	=	c+$80
00003D42 3680                     M 	dc.w	c
00003D44 =00003700                M c	=	c+$80
00003D44 3700                     M 	dc.w	c
00003D46 =00003780                M c	=	c+$80
00003D46 3780                     M 	dc.w	c
00003D48 =00003800                M c	=	c+$80
00003D48 3800                     M 	dc.w	c
00003D4A =00003880                M c	=	c+$80
00003D4A 3880                     M 	dc.w	c
00003D4C =00003900                M c	=	c+$80
00003D4C 3900                     M 	dc.w	c
00003D4E =00003980                M c	=	c+$80
00003D4E 3980                     M 	dc.w	c
00003D50 =00003A00                M c	=	c+$80
00003D50 3A00                     M 	dc.w	c
00003D52 =00003A80                M c	=	c+$80
00003D52 3A80                     M 	dc.w	c
00003D54 =00003B00                M c	=	c+$80
00003D54 3B00                     M 	dc.w	c
00003D56 =00003B80                M c	=	c+$80
00003D56 3B80                     M 	dc.w	c
00003D58 =00003C00                M c	=	c+$80
00003D58 3C00                     M 	dc.w	c
00003D5A =00003C80                M c	=	c+$80
00003D5A 3C80                     M 	dc.w	c
00003D5C =00003D00                M c	=	c+$80
00003D5C 3D00                     M 	dc.w	c
00003D5E =00003D80                M c	=	c+$80
00003D5E 3D80                     M 	dc.w	c
00003D60 =00003E00                M c	=	c+$80
00003D60 3E00                     M 	dc.w	c
00003D62 =00003E80                M c	=	c+$80
00003D62 3E80                     M 	dc.w	c
00003D64 =00003F00                M c	=	c+$80
00003D64 3F00                     M 	dc.w	c
00003D66 =00003F80                M c	=	c+$80
00003D66 3F80                     M 	dc.w	c
00003D68 =00004000                M c	=	c+$80
00003D68 4000                     M 	dc.w	c
00003D6A =00004080                M c	=	c+$80
00003D6A 4080                     M 	dc.w	c
00003D6C =00004100                M c	=	c+$80
00003D6C 4100                     M 	dc.w	c
00003D6E =00004180                M c	=	c+$80
00003D6E 4180                     M 	dc.w	c
00003D70 =00004200                M c	=	c+$80
00003D70 4200                     M 	dc.w	c
00003D72 =00004280                M c	=	c+$80
00003D72 4280                     M 	dc.w	c
00003D74 =00004300                M c	=	c+$80
00003D74 4300                     M 	dc.w	c
00003D76 =00004380                M c	=	c+$80
00003D76 4380                     M 	dc.w	c
00003D78 =00004400                M c	=	c+$80
00003D78 4400                     M 	dc.w	c
00003D7A =00004480                M c	=	c+$80
00003D7A 4480                     M 	dc.w	c
00003D7C =00004500                M c	=	c+$80
00003D7C 4500                     M 	dc.w	c
00003D7E =00004580                M c	=	c+$80
00003D7E 4580                     M 	dc.w	c
00003D80 =00004600                M c	=	c+$80
00003D80 4600                     M 	dc.w	c
00003D82 =00004680                M c	=	c+$80
00003D82 4680                     M 	dc.w	c
00003D84 =00004700                M c	=	c+$80
00003D84 4700                     M 	dc.w	c
00003D86 =00004780                M c	=	c+$80
00003D86 4780                     M 	dc.w	c
00003D88 =00004800                M c	=	c+$80
00003D88 4800                     M 	dc.w	c
00003D8A =00004880                M c	=	c+$80
00003D8A 4880                     M 	dc.w	c
00003D8C =00004900                M c	=	c+$80
00003D8C 4900                     M 	dc.w	c
00003D8E =00004980                M c	=	c+$80
00003D8E 4980                     M 	dc.w	c
00003D90 =00004A00                M c	=	c+$80
00003D90 4A00                     M 	dc.w	c
00003D92 =00004A80                M c	=	c+$80
00003D92 4A80                     M 	dc.w	c
00003D94 =00004B00                M c	=	c+$80
00003D94 4B00                     M 	dc.w	c
00003D96 =00004B80                M c	=	c+$80
00003D96 4B80                     M 	dc.w	c
00003D98 =00004C00                M c	=	c+$80
00003D98 4C00                     M 	dc.w	c
00003D9A =00004C80                M c	=	c+$80
00003D9A 4C80                     M 	dc.w	c
00003D9C =00004D00                M c	=	c+$80
00003D9C 4D00                     M 	dc.w	c
00003D9E =00004D80                M c	=	c+$80
00003D9E 4D80                     M 	dc.w	c
00003DA0 =00004E00                M c	=	c+$80
00003DA0 4E00                     M 	dc.w	c
00003DA2 =00004E80                M c	=	c+$80
00003DA2 4E80                     M 	dc.w	c
00003DA4 =00004F00                M c	=	c+$80
00003DA4 4F00                     M 	dc.w	c
00003DA6 =00004F80                M c	=	c+$80
00003DA6 4F80                     M 	dc.w	c
00003DA8 =00005000                M c	=	c+$80
00003DA8 5000                     M 	dc.w	c
00003DAA =00005080                M c	=	c+$80
00003DAA 5080                     M 	dc.w	c
00003DAC =00005100                M c	=	c+$80
00003DAC 5100                     M 	dc.w	c
00003DAE =00005180                M c	=	c+$80
00003DAE 5180                     M 	dc.w	c
00003DB0 =00005200                M c	=	c+$80
00003DB0 5200                     M 	dc.w	c
00003DB2 =00005280                M c	=	c+$80
00003DB2 5280                     M 	dc.w	c
00003DB4 =00005300                M c	=	c+$80
00003DB4 5300                     M 	dc.w	c
00003DB6 =00005380                M c	=	c+$80
00003DB6 5380                     M 	dc.w	c
00003DB8 =00005400                M c	=	c+$80
00003DB8 5400                     M 	dc.w	c
00003DBA =00005480                M c	=	c+$80
00003DBA 5480                     M 	dc.w	c
00003DBC =00005500                M c	=	c+$80
00003DBC 5500                     M 	dc.w	c
00003DBE =00005580                M c	=	c+$80
00003DBE 5580                     M 	dc.w	c
00003DC0 =00005600                M c	=	c+$80
00003DC0 5600                     M 	dc.w	c
00003DC2 =00005680                M c	=	c+$80
00003DC2 5680                     M 	dc.w	c
00003DC4 =00005700                M c	=	c+$80
00003DC4 5700                     M 	dc.w	c
00003DC6 =00005780                M c	=	c+$80
00003DC6 5780                     M 	dc.w	c
00003DC8 =00005800                M c	=	c+$80
00003DC8 5800                     M 	dc.w	c
00003DCA =00005880                M c	=	c+$80
00003DCA 5880                     M 	dc.w	c
00003DCC =00005900                M c	=	c+$80
00003DCC 5900                     M 	dc.w	c
00003DCE =00005980                M c	=	c+$80
00003DCE 5980                     M 	dc.w	c
00003DD0 =00005A00                M c	=	c+$80
00003DD0 5A00                     M 	dc.w	c
00003DD2 =00005A80                M c	=	c+$80
00003DD2 5A80                     M 	dc.w	c
00003DD4 =00005B00                M c	=	c+$80
00003DD4 5B00                     M 	dc.w	c
00003DD6 =00005B80                M c	=	c+$80
00003DD6 5B80                     M 	dc.w	c
00003DD8 =00005C00                M c	=	c+$80
00003DD8 5C00                     M 	dc.w	c
00003DDA =00005C80                M c	=	c+$80
00003DDA 5C80                     M 	dc.w	c
00003DDC =00005D00                M c	=	c+$80
00003DDC 5D00                     M 	dc.w	c
00003DDE =00005D80                M c	=	c+$80
00003DDE 5D80                     M 	dc.w	c
00003DE0 =00005E00                M c	=	c+$80
00003DE0 5E00                     M 	dc.w	c
00003DE2 =00005E80                M c	=	c+$80
00003DE2 5E80                     M 	dc.w	c
00003DE4 =00005F00                M c	=	c+$80
00003DE4 5F00                     M 	dc.w	c
00003DE6 =00005F80                M c	=	c+$80
00003DE6 5F80                     M 	dc.w	c
00003DE8 =00006000                M c	=	c+$80
00003DE8 6000                     M 	dc.w	c
00003DEA =00006080                M c	=	c+$80
00003DEA 6080                     M 	dc.w	c
00003DEC =00006100                M c	=	c+$80
00003DEC 6100                     M 	dc.w	c
00003DEE =00006180                M c	=	c+$80
00003DEE 6180                     M 	dc.w	c
00003DF0 =00006200                M c	=	c+$80
00003DF0 6200                     M 	dc.w	c
00003DF2 =00006280                M c	=	c+$80
00003DF2 6280                     M 	dc.w	c
00003DF4 =00006300                M c	=	c+$80
00003DF4 6300                     M 	dc.w	c
00003DF6 =00006380                M c	=	c+$80
00003DF6 6380                     M 	dc.w	c
00003DF8 =00006400                M c	=	c+$80
00003DF8 6400                     M 	dc.w	c
00003DFA =00006480                M c	=	c+$80
00003DFA 6480                     M 	dc.w	c
00003DFC =00006500                M c	=	c+$80
00003DFC 6500                     M 	dc.w	c
00003DFE =00006580                M c	=	c+$80
00003DFE 6580                     M 	dc.w	c
00003E00 =00006600                M c	=	c+$80
00003E00 6600                     M 	dc.w	c
00003E02 =00006680                M c	=	c+$80
00003E02 6680                     M 	dc.w	c
00003E04 =00006700                M c	=	c+$80
00003E04 6700                     M 	dc.w	c
00003E06 =00006780                M c	=	c+$80
00003E06 6780                     M 	dc.w	c
00003E08 =00006800                M c	=	c+$80
00003E08 6800                     M 	dc.w	c
00003E0A =00006880                M c	=	c+$80
00003E0A 6880                     M 	dc.w	c
00003E0C =00006900                M c	=	c+$80
00003E0C 6900                     M 	dc.w	c
00003E0E =00006980                M c	=	c+$80
00003E0E 6980                     M 	dc.w	c
00003E10 =00006A00                M c	=	c+$80
00003E10 6A00                     M 	dc.w	c
00003E12 =00006A80                M c	=	c+$80
00003E12 6A80                     M 	dc.w	c
00003E14 =00006B00                M c	=	c+$80
00003E14 6B00                     M 	dc.w	c
00003E16 =00006B80                M c	=	c+$80
00003E16 6B80                     M 	dc.w	c
00003E18 =00006C00                M c	=	c+$80
00003E18 6C00                     M 	dc.w	c
00003E1A =00006C80                M c	=	c+$80
00003E1A 6C80                     M 	dc.w	c
00003E1C =00006D00                M c	=	c+$80
00003E1C 6D00                     M 	dc.w	c
00003E1E =00006D80                M c	=	c+$80
00003E1E 6D80                     M 	dc.w	c
00003E20 =00006E00                M c	=	c+$80
00003E20 6E00                     M 	dc.w	c
00003E22 =00006E80                M c	=	c+$80
00003E22 6E80                     M 	dc.w	c
00003E24 =00006F00                M c	=	c+$80
00003E24 6F00                     M 	dc.w	c
00003E26 =00006F80                M c	=	c+$80
00003E26 6F80                     M 	dc.w	c
00003E28 =00007000                M c	=	c+$80
00003E28 7000                     M 	dc.w	c
00003E2A =00007080                M c	=	c+$80
00003E2A 7080                     M 	dc.w	c
00003E2C =00007100                M c	=	c+$80
00003E2C 7100                     M 	dc.w	c
00003E2E =00007180                M c	=	c+$80
00003E2E 7180                     M 	dc.w	c
00003E30 =00007200                M c	=	c+$80
00003E30 7200                     M 	dc.w	c
00003E32 =00007280                M c	=	c+$80
00003E32 7280                     M 	dc.w	c
00003E34 =00007300                M c	=	c+$80
00003E34 7300                     M 	dc.w	c
00003E36 =00007380                M c	=	c+$80
00003E36 7380                     M 	dc.w	c
00003E38 =00007400                M c	=	c+$80
00003E38 7400                     M 	dc.w	c
00003E3A =00007480                M c	=	c+$80
00003E3A 7480                     M 	dc.w	c
00003E3C =00007500                M c	=	c+$80
00003E3C 7500                     M 	dc.w	c
00003E3E =00007580                M c	=	c+$80
00003E3E 7580                     M 	dc.w	c
00003E40 =00007600                M c	=	c+$80
00003E40 7600                     M 	dc.w	c
00003E42 =00007680                M c	=	c+$80
00003E42 7680                     M 	dc.w	c
00003E44 =00007700                M c	=	c+$80
00003E44 7700                     M 	dc.w	c
00003E46 =00007780                M c	=	c+$80
00003E46 7780                     M 	dc.w	c
00003E48 =00007800                M c	=	c+$80
00003E48 7800                     M 	dc.w	c
00003E4A =00007880                M c	=	c+$80
00003E4A 7880                     M 	dc.w	c
00003E4C =00007900                M c	=	c+$80
00003E4C 7900                     M 	dc.w	c
00003E4E =00007980                M c	=	c+$80
00003E4E 7980                     M 	dc.w	c
00003E50 =00007A00                M c	=	c+$80
00003E50 7A00                     M 	dc.w	c
00003E52 =00007A80                M c	=	c+$80
00003E52 7A80                     M 	dc.w	c
00003E54 =00007B00                M c	=	c+$80
00003E54 7B00                     M 	dc.w	c
00003E56 =00007B80                M c	=	c+$80
00003E56 7B80                     M 	dc.w	c
00003E58 =00007C00                M c	=	c+$80
00003E58 7C00                     M 	dc.w	c
00003E5A =00007C80                M c	=	c+$80
00003E5A 7C80                     M 	dc.w	c
00003E5C =00007D00                M c	=	c+$80
00003E5C 7D00                     M 	dc.w	c
00003E5E =00007D80                M c	=	c+$80
00003E5E 7D80                     M 	dc.w	c
00003E60 =00007E00                M c	=	c+$80
00003E60 7E00                     M 	dc.w	c
00003E62 =00007E80                M c	=	c+$80
00003E62 7E80                     M 	dc.w	c
00003E64 =00007F00                M c	=	c+$80
00003E64 7F00                     M 	dc.w	c
00003E66 =00007F80                M c	=	c+$80
00003E66 7F80                     M 	dc.w	c
00003E68 =00008000                M c	=	c+$80
00003E68                            ; =========================================================================================================================================================
00003E68                            		include	"Opmodes/Gameplay/Level Functions.asm"
00003E68                            ; =========================================================================================================================================================
00003E68                            ; General level functions
00003E68                            ; =========================================================================================================================================================
00003E68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E68                            ; Load level data
00003E68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E68                            Level_LoadData:
00003E68                            		; --- Initialize the start position and camera ---
00003E68                            
00003E68 47F9 0000 0000             		lea	Level_SizeStartPos,a3		; Get size and start position data
00003E6E 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003E72 E218                       		ror.b	#1,d0				; Turn into offset
00003E74 E848                       		lsr.w	#4,d0				; ''
00003E76 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003E7A                            
00003E7A 42B8 E8CE                  		clr.l	targetMinCamPos.w		; Set target minimum camera values
00003E7E 42B8 E8D2                  		clr.l	minCamPos.w			; Set minimum camera values
00003E82 21D3 E8C6                  		move.l	(a3),targetMaxCamPos.w		; Set target maximum camera values
00003E86 21DB E8CA                  		move.l	(a3)+,maxCamPos.w		; Set maximum camera values
00003E8A                            
00003E8A 31FC 0060 E8D8             		move.w	#(224/2)-16,panCamYPos.w	; Set camera Y distance
00003E90                            
00003E90 3078 E876                  		movea.w	playerPtrP1.w,a0		; Player object
00003E94 321B                       		move.w	(a3)+,d1			; Get starting X position
00003E96 3141 0014                  		move.w	d1,_objXPos(a0)			; Set the player's X position
00003E9A 3013                       		move.w	(a3),d0				; Get starting Y position
00003E9C 3140 0018                  		move.w	d0,_objYPos(a0)			; Set the player's Y position
00003EA0                            
00003EA0 4A38 C7B7                  		tst.b	rStartFall.w			; Should we start the level by falling?
00003EA4 6700                       		beq.s	.InitCam			; If not, branch
00003EA6 08E8 0002 000C             		bset	#2,_objFlags(a0)
00003EAC 7272                       		moveq	#$72,d1				; Reset Sonic's X position
00003EAE 3141 0014                  		move.w	d1,_objXPos(a0)			; ''
00003EB2 70E0                       		moveq	#-32,d0				; Reset Sonic's Y position
00003EB4 3140 0018                  		move.w	d0,_objYPos(a0)			; ''
00003EB8                            
00003EB8                            .InitCam:
00003EB8 4A38 C7B0                  		tst.b	chkIDLast.w		; Has a checkpoint been hit?
00003EBC 6700                       		beq.s	.SetCam				; If not, branch
00003EBE 6100 0000                  		bsr.w	Level_LoadSavedInfo		; Load data
00003EC2 3228 0014                  		move.w	_objXPos(a0),d1			; Get X position
00003EC6 3028 0018                  		move.w	_objYPos(a0),d0			; Get Y position
00003ECA                            
00003ECA                            .SetCam:
00003ECA 0441 00A0                  		subi.w	#320/2,d1			; Get camera's X position
00003ECE 6C00                       		bge.s	.ChkMaxX			; If it doesn't go beyond the left boundary, branch
00003ED0 7200                       		moveq	#0,d1				; Cap it
00003ED2                            
00003ED2                            .ChkMaxX:
00003ED2 3438 E8CA                  		move.w	maxCamXPos.w,d2		; Get max camera X position
00003ED6 B242                       		cmp.w	d2,d1				; Have we gone beyond it?
00003ED8 6500                       		bcs.s	.SetCamX			; If not, branch
00003EDA 3202                       		move.w	d2,d1				; Cap it
00003EDC                            
00003EDC                            .SetCamX:	
00003EDC 31C1 E88A                  		move.w	d1,fgCamXPos.w			; Set the camera's X position
00003EE0                            
00003EE0 0440 0060                  		subi.w	#(224/2)-16,d0			; Get camera's Y position
00003EE4 6C00                       		bge.s	.ChkMaxY			; If it doesn't go beyond the upper boundary, branch
00003EE6 7000                       		moveq	#0,d0				; Cap it
00003EE8                            
00003EE8                            .ChkMaxY:
00003EE8 3438 E8CC                  		move.w	maxCamYPos.w,d2		; Get max camera Y position
00003EEC B042                       		cmp.w	d2,d0				; Have we gone beyond it?
00003EEE 6D00                       		blt.s	.SetCamY			; If not, branch
00003EF0 3002                       		move.w	d2,d0				; Cap it
00003EF2                            
00003EF2                            .SetCamY:	
00003EF2 31C0 E892                  		move.w	d0,fgCamYPos.w			; Set the camera's Y position
00003EF6                            
00003EF6                            		; --- Load level data ---
00003EF6                            
00003EF6 47F9 0000 0000             		lea	Level_DataPointers,a3		; Level data pointers
00003EFC 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003F00 E218                       		ror.b	#1,d0				; Turn into offset
00003F02 E448                       		lsr.w	#2,d0				; ''
00003F04 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003F08                            
00003F08 205B                       		movea.l	(a3)+,a0			; Get chunk data pointer
00003F0A 43F9 00FF 0000             		lea	chunkData,a1			; Decompress into chunk table
00003F10 4EB8 0B06                  		jsr	KosDec.w			; ''
00003F14                            
00003F14 205B                       		movea.l	(a3)+,a0			; Get block data pointer
00003F16 43F8 C7D2                  		lea	blockData.w,a1			; Decompress into block table
00003F1A 4EB8 0B06                  		jsr	KosDec.w			; ''
00003F1E                            
00003F1E 225B                       		movea.l	(a3)+,a1			; Get tile data pointer
00003F20 7400                       		moveq	#0,d2				; Store in the beginning of VRAM
00003F22 4EB8 0F5C                  		jsr	QueueKosMData.w			; Queue for decompression
00003F26                            
00003F26 205B                       		movea.l	(a3)+,a0			; Get palette data pointer
00003F28 3018                       		move.w	(a0)+,d0			; Size of palette data
00003F2A 4EB8 053A                  		jsr	LoadTargetPal.w			; Load the palette
00003F2E                            
00003F2E 21DB E856                  		move.l	(a3)+,lvlLayoutFG.w		; Move layout addresses to variables
00003F32 21DB E85A                  		move.l	(a3)+,lvlLayoutBG.w
00003F36                            
00003F36 21DB C7B8                  		move.l	(a3)+,objMgrLayout.w		; Set object position data pointer
00003F3A 21DB E868                  		move.l	(a3)+,ringMgrLayout.w		; Set ring position data pointer
00003F3E 265B                       		movea.l	(a3)+,a3			; Get collision data pointers
00003F40 201B                       		move.l	(a3)+,d0			; Get collision data address
00003F42 21C0 E8EA                  		move.l	d0,currentColAddr.w			; Set collision address to primary
00003F46 21C0 E8E2                  		move.l	d0,primaryColPtr.w			; Set primary collision data pointer
00003F4A 5280                       		addq.l	#1,d0				; Increment address for secondary collision
00003F4C 21C0 E8E6                  		move.l	d0,secondaryColPtr.w			; Set secondary collision data pointer
00003F50 43F8 E8F0                  		lea	angleValPtr.w,a1		; Collision pointers
00003F54 22DB                       		move.l	(a3)+,(a1)+			; Set angle value array pointer
00003F56 22DB                       		move.l	(a3)+,(a1)+			; Set normal hiehgt map array pointer
00003F58 229B                       		move.l	(a3)+,(a1)			; Set rotated hiehgt map array pointer
00003F5A                            
00003F5A 47F9 0000 0000             		lea	Level_PLCs,a3			; Get PLC list pointer
00003F60 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003F64 E218                       		ror.b	#1,d0				; Turn into offset
00003F66 EA48                       		lsr.w	#5,d0				; ''
00003F68 2673 0000                  		movea.l	(a3,d0.w),a3			; Get pointer to the correct pointers
00003F6C 4EF8 0F4C                  		jmp	LoadKosMQueue.w			; Load the PLCs
00003F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F70                            ; Update the water surface
00003F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F70                            Level_UpdateWaterSurface:
00003F70 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
00003F74 6700                       		beq.s	.End				; If not, branch
00003F76 3238 E88A                  		move.w	fgCamXPos.w,d1			; Get camera X position
00003F7A 0838 0000 E905             		btst	#0,(lvlFrameCnt+1).w		; Are we on an odd frame?
00003F80 6700                       		beq.s	.SetXPos			; If not, branch
00003F82 0641 0020                  		addi.w	#$20,d1				; Shift X position
00003F86                            
00003F86                            .SetXPos:
00003F86 3001                       		move.w	d1,d0				; Copy X postion
00003F88 0640 0060                  		addi.w	#$60,d0				; Add surface #1's X position
00003F8C 3078 E886                  		movea.w	waterObjPtr1.w,a0
00003F90 3140 0014                  		move.w	d0,_objXPos(a0)			; Set it
00003F94 0641 0120                  		addi.w	#$120,d1			; Add surface #2's X position
00003F98 3078 E888                  		movea.w	waterObjPtr2.w,a0
00003F9C 3141 0014                  		move.w	d1,_objXPos(a0)			; Set it
00003FA0                            
00003FA0                            .End:
00003FA0 4E75                       		rts
00003FA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FA2                            ; Handle water height
00003FA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FA2                            Level_WaterHeight:
00003FA2 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
00003FA6 6700                       		beq.s	.End				; If not, branch
00003FA8 6100 0000                  		bsr.w	Level_MoveWater			; Move the water when appropriate
00003FAC 4238 E8FF                  		clr.b	waterFullscr.w		; Clear water fullscreen flag
00003FB0                            
00003FB0 7201                       		moveq	#1,d1				; Water movement speed
00003FB2 3038 E902                  		move.w	destWaterYPos.w,d0		; Get destination water level
00003FB6 9078 E900                  		sub.w	waterYPos.w,d0		; Is the current water level at that destination?
00003FBA 6700                       		beq.s	.ChkOnScr			; If so, branch
00003FBC 6400                       		bcc.s	.MoveDown			; If it needs to go down, branch
00003FBE 4441                       		neg.w	d1				; Go up
00003FC0                            
00003FC0                            .MoveDown:
00003FC0 D378 E900                  		add.w	d1,waterYPos.w		; Move water
00003FC4                            
00003FC4                            .ChkOnScr:
00003FC4 3038 E900                  		move.w	waterYPos.w,d0		; Get water height
00003FC8 9078 E892                  		sub.w	fgCamYPos.w,d0			; Get camera's Y position
00003FCC 6700                       		beq.s	.Fullscreen			; If they are the same, branch
00003FCE 6400                       		bcc.s	.ChkBottom			; If the water height is below the top of the camera, branch
00003FD0                            		
00003FD0                            .Fullscreen:
00003FD0 50F8 E8FF                  		st	waterFullscr.w		; Set water fullscreen flag
00003FD4 50F8 C761                  		st	hIntCntValue.w			; Set H-INT counter to be offscreen
00003FD8 4E75                       		rts
00003FDA                            
00003FDA                            .ChkBottom:
00003FDA 0C40 00DF                  		cmpi.w	#224-1,d0			; Is the water below the camera?
00003FDE 6500                       		blo.s	.SetCounter			; If not, branch
00003FE0 70FF                       		moveq	#-1,d0				; Set H-INT counter to be offscreen
00003FE2                            
00003FE2                            .SetCounter:
00003FE2 11C0 C761                  		move.b	d0,hIntCntValue.w			; Set H-INT counter
00003FE6                            
00003FE6                            .End:
00003FE6 4E75                       		rts
00003FE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FE8                            Level_MoveWater:
00003FE8 4E75                       		rts
00003FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FEA                            ; Do level palette cycling
00003FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FEA                            Level_PalCycle:
00003FEA 41F9 0000 0000             		lea	Level_PalCycRouts,a0		; Palette cycle routines
00003FF0 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003FF4 E218                       		ror.b	#1,d0				; Turn into offset
00003FF6 EA48                       		lsr.w	#5,d0				; ''
00003FF8 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003FFC 4ED0                       		jmp	(a0)				; Jump to it
00003FFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FFE                            ; Do level art animation
00003FFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FFE                            Level_AnimateArt:
00003FFE 41F9 0000 0000             		lea	Level_AniArtRouts,a0		; Animated art routines
00004004 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00004008 E218                       		ror.b	#1,d0				; Turn into offset
0000400A EA48                       		lsr.w	#5,d0				; ''
0000400C 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00004010 4ED0                       		jmp	(a0)				; Jump to it
00004012                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004012                            ; Do dynamic events
00004012                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004012                            Level_DynEvents:
00004012 41F9 0000 0000             		lea	Level_DynEvenRouts,a0		; Dynamic events routines
00004018 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
0000401C E218                       		ror.b	#1,d0				; Turn into offset
0000401E EA48                       		lsr.w	#5,d0				; ''
00004020 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00004024 4ED0                       		jmp	(a0)				; Jump to it
00004026                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004026                            ; Handle the camera
00004026                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004026                            Level_HandleCamera:
00004026 3078 E876                  		movea.w	playerPtrP1.w,a0		; Get player object
0000402A                            		
0000402A 4A38 E8DA                  		tst.b	camLockX.w			; Is the camera locked horizontally?
0000402E 6600                       		bne.s	.ChkY				; If so, branch
00004030 43F8 E88A                  		lea	fgCamXPos.w,a1			; Get foreground level variables
00004034 6100                       		bsr.s	Level_MoveCameraX		; Move the camera horiozntally
00004036                            		
00004036                            .ChkY:
00004036 4A38 E8DB                  		tst.b	camLockY.w			; Is the camera locked vertically?
0000403A 6600                       		bne.s	.ChkMaxY			; If not, branch
0000403C 43F8 E892                  		lea	fgCamYPos.w,a1			; Get foreground level variables
00004040 3638 E8D8                  		move.w	panCamYPos.w,d3		; Get camera Y distance
00004044 6100 0000                  		bsr.w	Level_MoveCameraY		; Move the camera vertically
00004048                            
00004048                            .ChkMaxY:
00004048 7202                       		moveq	#2,d1				; Target camera scroll speed
0000404A 3038 E8C8                  		move.w	targetMaxCamY.w,d0		; Get distance between target and actual target max camera Y position
0000404E 9078 E8CC                  		sub.w	maxCamYPos.w,d0		; ''
00004052 6700                       		beq.s	.End				; If it's 0, branch
00004054 6400                       		bcc.s	.MoveDown			; If it's positive, branch
00004056 3038 E892                  		move.w	fgCamYPos.w,d0			; Get current camera Y position
0000405A B078 E8C8                  		cmp.w	targetMaxCamY.w,d0		; Is it past the boundary?
0000405E 6300                       		bls.s	.ScrollUp			; If not, branch
00004060 31C0 E8CC                  		move.w	d0,maxCamYPos.w		; Set max camera Y position
00004064 0278 FFFE E8CC             		andi.w	#$FFFE,maxCamYPos.w		; Keep it a multiple of 2
0000406A                            
0000406A                            .ScrollUp:
0000406A 9378 E8CC                  		sub.w	d1,maxCamYPos.w		; Scroll up
0000406E 50F8 E8DC                  		st	chgCamMaxY.w			; Indicate that the max Y boundary is changing
00004072                            
00004072                            
00004072                            .End:
00004072 4E75                       		rts
00004074                            
00004074                            .MoveDown:
00004074 3038 E892                  		move.w	fgCamYPos.w,d0			; Get current camera Y position
00004078 5040                       		addq.w	#8,d0				; ''
0000407A B078 E8CC                  		cmp.w	maxCamYPos.w,d0		; Is it past the boundary?
0000407E 6500                       		bcs.s	.ScrollDown			; If not, branch
00004080 0828 0001 0028             		btst	#1,_objStatus(a0)		; Is the player in the air?
00004086 6700                       		beq.s	.ScrollDown			; If not, branch
00004088 D241                       		add.w	d1,d1				; Scroll down faster
0000408A D241                       		add.w	d1,d1				; ''
0000408C                            
0000408C                            .ScrollDown:
0000408C D378 E8CC                  		add.w	d1,maxCamYPos.w		; Scroll down
00004090 50F8 E8DC                  		st	chgCamMaxY.w			; Indicate that the max Y boundary is changing
00004094 4E75                       		rts
00004096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004096                            Level_MoveCameraX:
00004096 3028 0014                  		move.w	_objXPos(a0),d0			; Get the player's X position
0000409A 9051                       		sub.w	(a1),d0				; Get distance from the camera's X position
0000409C 9078 E8D6                  		sub.w	panCamXPos.w,d0		; Subtract center
000040A0 6D00                       		blt.s	.MoveLeft			; If we are going left, branch
000040A2 6C00                       		bge.s	.MoveRight			; If we are going right, branch
000040A4 4E75                       		rts
000040A6                            
000040A6                            .MoveLeft:
000040A6 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the camera moving more than 16 pixels per frame?
000040AA 6E00                       		bgt.s	.ChkLeftBound			; If not, branch
000040AC 303C FFF0                  		move.w	#-16,d0				; Keep the camera from moving too fast
000040B0                            
000040B0                            .ChkLeftBound:
000040B0 D051                       		add.w	(a1),d0				; Add back the camera's X position
000040B2 B078 E8D2                  		cmp.w	minCamXPos.w,d0		; Have we gone past the left boundary?
000040B6 6E00                       		bgt.s	.SetCamX			; If not, branch
000040B8 3038 E8D2                  		move.w	minCamXPos.w,d0		; Cap at the left boundary
000040BC 6000                       		bra.s	.SetCamX			; Continue
000040BE                            
000040BE                            .MoveRight:
000040BE 0C40 0010                  		cmpi.w	#16,d0				; Is the camera moving more than 16 pixels per frame?
000040C2 6500                       		blo.s	.ChkRightBound			; If not, branch
000040C4 303C 0010                  		move.w	#16,d0				; Keep the camera from moving too fast
000040C8                            
000040C8                            .ChkRightBound:
000040C8 D051                       		add.w	(a1),d0				; Add back the camera's X position
000040CA B078 E8CA                  		cmp.w	maxCamXPos.w,d0		; Has the camera gone beyond the right boundary?
000040CE 6D00                       		blt.s	.SetCamX			; If not, branch
000040D0 3038 E8CA                  		move.w	maxCamXPos.w,d0		; Cap at the right boundary
000040D4                            
000040D4                            .SetCamX:
000040D4 3280                       		move.w	d0,(a1)				; Set the new camera X position
000040D6 4E75                       		rts
000040D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040D8                            Level_MoveCameraY:
000040D8 7200                       		moveq	#0,d1
000040DA 3028 0018                  		move.w	_objYPos(a0),d0			; Get the player's Y position
000040DE 9051                       		sub.w	(a1),d0				; Get distance from the camera's Y position
000040E0                            
000040E0 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is the player rolling?
000040E6 6700                       		beq.s	.NoRoll				; If not, branch
000040E8 5B40                       		subq.w	#5,d0				; Move up some
000040EA                            
000040EA                            .NoRoll:
000040EA 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is the player in the air?
000040F0 6700                       		beq.s	.ChkBoundCross_Ground		; If not, branch
000040F2                            
000040F2                            .ChkBoundCross_Air:
000040F2 0640 0020                  		addi.w	#$20,d0				; You have 32 pixels above and below to move without disturbing the camera
000040F6 9043                       		sub.w	d3,d0				; Subtract camera Y distance
000040F8 6500                       		bcs.s	.ScrollFast			; If the player is above the boundary, branch
000040FA 0440 0040                  		subi.w	#$40,d0				; Subtract 64
000040FE 6400                       		bcc.s	.ScrollFast			; If the player is below the boundary, branch
00004100                            
00004100 4A38 E8DC                  		tst.b	chgCamMaxY.w			; Is the max Y boundary changing?
00004104 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00004106 6000                       		bra.s	.NoScroll			; Continue
00004108                            
00004108                            .ChkBoundCross_Ground:
00004108 9043                       		sub.w	d3,d0				; Subtract camera Y distance
0000410A 6600                       		bne.s	.DecideScrollType		; If the player moved, branch
0000410C 4A38 E8DC                  		tst.b	chgCamMaxY.w			; Is the max Y boundary changing?
00004110 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00004112                            
00004112                            .NoScroll:
00004112 4E75                       		rts		
00004114                            
00004114                            .DecideScrollType:
00004114 0C43 0060                  		cmpi.w	#(224/2)-16,d3			; Is the camera Y distance normal?
00004118 6600                       		bne.s	.ScrollSlow			; If not, branch
0000411A                            
0000411A 3228 0000                  		move.w	_objGVel(a0),d1			; Get the players' ground velocity
0000411E 6A00                       		bpl.s	.Positive			; If it's positive, branch
00004120 4441                       		neg.w	d1				; Force it to be positive
00004122                            
00004122                            .Positive:
00004122 0C41 0800                  		cmpi.w	#$800,d1			; Is the player travelling very fast?
00004126 6400                       		bhs.s	.ScrollFast			; If so, branch
00004128                            
00004128                            .ScrollMedium:
00004128 323C 0600                  		move.w	#6<<8,d1			; Cap camera movement at 6 if going too fast
0000412C 0C40 0006                  		cmpi.w	#6,d0				; Is the player going down too fast?
00004130 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00004132 0C40 FFFA                  		cmpi.w	#-6,d0				; Is the player going up too fast?
00004136 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00004138 6000                       		bra.s	.ScrollUpOrDown			; Continue
0000413A                            
0000413A                            .ScrollSlow:
0000413A 323C 0200                  		move.w	#2<<8,d1			; Cap camera movement at 2 if going too fast
0000413E 0C40 0002                  		cmpi.w	#2,d0				; Is the player going down too fast?
00004142 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00004144 0C40 FFFE                  		cmpi.w	#-2,d0				; Is the player going up too fast?
00004148 6D00                       		blt.s	.ScrollUpMax			; If so, branch
0000414A 6000                       		bra.s	.ScrollUpOrDown			; Continue
0000414C                            
0000414C                            .ScrollFast:
0000414C 323C 1000                  		move.w	#16<<8,d1			; Cap camera movement at 16 if going too fast
00004150 0C40 0010                  		cmpi.w	#16,d0				; Is the player going down too fast?
00004154 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00004156 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the player going up too fast?
0000415A 6D00                       		blt.s	.ScrollUpMax			; If so, branch
0000415C 6000                       		bra.s	.ScrollUpOrDown			; Continue
0000415E                            
0000415E                            .ScrollMaxYChange:
0000415E 7000                       		moveq	#0,d0				; Distance for the camera to move = 0
00004160 11C0 E8DC                  		move.b	d0,chgCamMaxY.w		; Clear the max Y boundary changing flag
00004164                            		
00004164                            .ScrollUpOrDown:
00004164 7200                       		moveq	#0,d1
00004166 3200                       		move.w	d0,d1				; Get position difference
00004168 D251                       		add.w	(a1),d1				; Add old camera Y position
0000416A 4A40                       		tst.w	d0				; Is the camera to scroll down?
0000416C 6A00                       		bpl.s	.ScrollDown			; If so, branch
0000416E 6000 0000                  		bra.w	.ScrollUp			; Scroll up
00004172                            
00004172                            .ScrollUpMax:
00004172 4441                       		neg.w	d1				; Make the value negative, since we are going up
00004174 48C1                       		ext.l	d1
00004176 E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00004178 D291                       		add.l	(a1),d1				; Add the camera's Y position
0000417A 4841                       		swap	d1				; Get the actual Y position
0000417C                            
0000417C                            .ScrollUp:
0000417C B278 E8D4                  		cmp.w	minCamYPos.w,d1		; Has the camera gone beyond the upper boundary?
00004180 6E00                       		bgt.s	.DoScroll			; If not, branch
00004182 3238 E8D4                  		move.w	minCamYPos.w,d1		; Cap at upper boundary
00004186 6000                       		bra.s	.DoScroll			; Continue
00004188                            
00004188                            .ScrollDownMax:
00004188 48C1                       		ext.l	d1
0000418A E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
0000418C D291                       		add.l	(a1),d1				; Add the camera's Y position
0000418E 4841                       		swap	d1				; Get the actual Y position
00004190                            
00004190                            .ScrollDown:
00004190 B278 E8CC                  		cmp.w	maxCamYPos.w,d1		; Has the camera gone beyond the lower boundary?
00004194 6D00                       		blt.s	.DoScroll			; If not, branch
00004196 3238 E8CC                  		move.w	maxCamYPos.w,d1		; Cap at lower boundary
0000419A                            
0000419A                            .DoScroll:
0000419A 4841                       		swap	d1				; Put Y coordinate in the higher word
0000419C 2281                       		move.l	d1,(a1)				; Set Y position
0000419E 4E75                       		rts
000041A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041A0                            ; Level ring manager
000041A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041A0                            Level_RingsManager:
000041A0 7000                       		moveq	#0,d0
000041A2 1038 E866                  		move.b	ringMgrRoutine.w,d0		; Get routine
000041A6 303B 0000                  		move.w	.Routines(pc,d0.w),d0		; Get offset
000041AA 4EFB 0000                  		jmp	.Routines(pc,d0.w)		; Jump to the right routine
000041AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041AE                            .Routines:
000041AE 0000                       		dc.w	Level_RingsManagerInit-.Routines
000041B0 0000                       		dc.w	Level_RingsManagerMain-.Routines
000041B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041B2                            ; Ring manager initialization
000041B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041B2                            Level_RingsManagerInit:
000041B2 5438 E866                  		addq.b	#2,ringMgrRoutine.w		; The next time the manager is run, only go to the main routine
000041B6                            		
000041B6 6100 0000                  		bsr.w	Level_RingsManagerSetup	; Prepare the tables and load the ring data
000041BA                            
000041BA                            		; Set up the addresses to use in the current location of the level
000041BA                            
000041BA                            		; Start at the left side of the screen
000041BA                            		; We get the location of the first ring that shows up at the left side of the screen in the data and store that
000041BA                            
000041BA 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get current ring data address for the left side of the screen
000041BE 45F8 DFD2                  		lea	ringStatus.w,a2		; Ring status table
000041C2 3838 E88A                  		move.w	fgCamXPos.w,d4			; Get camera's X position
000041C6 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
000041C8 6200                       		bhi.s	.CheckLeftSide			; Branch if not beyond 0
000041CA 7801                       		moveq	#1,d4				; Cap left side to 1
000041CC 6000                       		bra.s	.CheckLeftSide			; Start checking
000041CE                            
000041CE                            .NextLeftRing:
000041CE 5849                       		addq.w	#4,a1				; Next ring in ring data
000041D0 544A                       		addq.w	#2,a2				; Next ring in status table
000041D2                            
000041D2                            .CheckLeftSide:
000041D2 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
000041D4 62F8                       		bhi.s	.NextLeftRing			; If not, get the next ring
000041D6 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store starting ring data address
000041DA 31CA E874                  		move.w	a2,ringMgrStatPtr.w		; Store ring status address
000041DE                            
000041DE                            		; Now the right side of the screen
000041DE                            		; We get the location of the first ring that goes beyond the right side of the screen in the data and store that
000041DE                            
000041DE 0644 0150                  		addi.w	#320+16,d4			; Right boundary
000041E2 6000                       		bra.s	.CheckRightSide			; Start checking
000041E4                            
000041E4                            .NextRightRing:
000041E4 5849                       		addq.w	#4,a1				; Next ring in ring data
000041E6                            
000041E6                            .CheckRightSide:
000041E6 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
000041E8 62FA                       		bhi.s	.NextRightRing			; If not, get the next ring
000041EA 21C9 E870                  		move.l	a1,ringMgrLoadR.w		; Store ending ring data address
000041EE 4E75                       		rts
000041F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041F0                            ; Ring manager main routine
000041F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041F0                            Level_RingsManagerMain:
000041F0 6100 0000                  		bsr.w	Level_RingsManagerDoCollect	; Handle ring collection
000041F4                            
000041F4 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get the current starting address for the ring data
000041F8 3478 E874                  		movea.w	ringMgrStatPtr.w,a2		; Get the current starting address for the status table
000041FC                            		
000041FC                            		; Get the new starting addresses for ring data
000041FC                            		; This is done by getting to a point from the current starting address where there's a ring onscreen
000041FC                            		; and then going back to get the very first ring that's on screen
000041FC                            
000041FC 3838 E88A                  		move.w	fgCamXPos.w,d4			; Get camera's X position
00004200 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00004202 6200                       		bhi.s	.CheckNewLeftSide		; Branch if not beyond 0
00004204 7801                       		moveq	#1,d4				; Cap left side to 1
00004206 6000                       		bra.s	.CheckNewLeftSide		; Start checking
00004208                            
00004208                            .NextNewLeftRing:
00004208 5849                       		addq.w	#4,a1				; Next ring in ring data
0000420A 544A                       		addq.w	#2,a2				; Next ring in status table
0000420C                            
0000420C                            .CheckNewLeftSide:
0000420C B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
0000420E 62F8                       		bhi.s	.NextNewLeftRing		; If not, get the next ring
00004210 6000                       		bra.s	.CheckNewLeftSide2		; Start checking
00004212                            
00004212                            .NextNewLeftRing2:
00004212 5949                       		subq.w	#4,a1				; Previous ring in ring data
00004214 554A                       		subq.w	#2,a2				; Previous ring in status table
00004216                            
00004216                            .CheckNewLeftSide2:
00004216 B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the left boundary?
0000421A 63F6                       		bls.s	.NextNewLeftRing2		; If not, get the next ring
0000421C 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store starting ring data address
00004220 31CA E874                  		move.w	a2,ringMgrStatPtr.w		; Store ring status address
00004224                            
00004224                            		; Now get the new ending addresses for ring data
00004224                            		; This is done by getting to a point from the current starting address where there's a ring at the right of the left boundary
00004224                            		; and then going back to get the very first ring that's on screen on the left side
00004224                            
00004224 2278 E870                  		movea.l	ringMgrLoadR.w,a1		; Get the current ending address for the ring data
00004228                            
00004228 0644 0150                  		addi.w	#320+16,d4			; Right boundary
0000422C 6000                       		bra.s	.CheckNewRightSide		; Start checking
0000422E                            
0000422E                            .NextNewRightRing:
0000422E 5849                       		addq.w	#4,a1				; Next ring in ring data
00004230                            
00004230                            .CheckNewRightSide:
00004230 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00004232 62FA                       		bhi.s	.NextNewRightRing		; If not, get the next ring
00004234 6000                       		bra.s	.CheckNewRightSide2		; Start checking
00004236                            
00004236                            .NextNewRightRing2:
00004236 5949                       		subq.w	#4,a1				; Previous ring in ring data
00004238                            
00004238                            .CheckNewRightSide2:
00004238 B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the right boundary?
0000423C 63F8                       		bls.s	.NextNewRightRing2		; If not, get the next ring
0000423E 21C9 E870                  		move.l	a1,ringMgrLoadR.w		; Store ending ring data address
00004242 4E75                       		rts
00004244                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004244                            ; Handle ring collection
00004244                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004244                            Level_RingsManagerDoCollect:
00004244 45F8 E3D2                  		lea	ringCollect.w,a2			; Ring collection table
00004248 321A                       		move.w	(a2)+,d1			; Get consumed ring count
0000424A 5341                       		subq.w	#1,d1				; SutbactID 1
0000424C 6500                       		bcs.s	.End				; If there are no consumed rings to handle, branch
0000424E                            
0000424E                            .Loop:
0000424E 301A                       		move.w	(a2)+,d0			; Get ring status address
00004250 67FC                       		beq.s	.Loop				; If 0, get the next ring
00004252 3240                       		movea.w	d0,a1				; Save in a1
00004254 5311                       		subq.b	#1,(a1)				; Decrement timer
00004256 6600                       		bne.s	.Next				; If nonzero, branch
00004258 12BC 0006                  		move.b	#6,(a1)				; Reset timer
0000425C 5229 0001                  		addq.b	#1,1(a1)			; Increment frame
00004260                            							; Is it the last frame?
00004260 0C29 0000 0001             		cmpi.b	#(CMap_Ring_Sparkle_Last-CMap_Ring)/8,1(a1)
00004266 6600                       		bne.s	.Next				; If not, branch
00004268 32BC FFFF                  		move.w	#-1,(a1)			; Set timer and frame to -1
0000426C 426A FFFE                  		clr.w	-2(a2)				; Set address in collection table to 0
00004270 5378 E3D2                  		subq.w	#1,ringColCount.w		; Decrement collection table count
00004274                            
00004274                            .Next:
00004274 51C9 FFD8                  		dbf	d1,.Loop			; Loop
00004278                            
00004278                            .End:
00004278 4E75                       		rts
0000427A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000427A                            ; Set up the tables and load ring data
0000427A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000427A                            Level_RingsManagerSetup:
0000427A                            		; Clear tables
0000427A                            		clrRAM	ringStatus
0000427A                          M 	local	endaddr
0000427A                          M endaddr	equs	"ringstatus_End"
0000427A 7000                     M 	moveq	#0,d0
0000427C 43F8 DFD2                M 	lea	(ringstatus).w,a1
00004280 323C 00FF                M 	move.w	#(((ringstatus_end)-(ringstatus))-((ringstatus)&1))>>2-1,d1
00004284 22C0                     M .clear_182:	move.l	d0,(a1)+
00004286 51C9 FFFC                M 	dbf	d1,.clear_182
0000428A                            		clrRAM	ringCollect
0000428A                          M 	local	endaddr
0000428A                          M endaddr	equs	"ringcollect_End"
0000428A 7000                     M 	moveq	#0,d0
0000428C 43F8 E3D2                M 	lea	(ringcollect).w,a1
00004290 323C 001F                M 	move.w	#(((ringcollect_end)-(ringcollect))-((ringcollect)&1))>>2-1,d1
00004294 22C0                     M .clear_183:	move.l	d0,(a1)+
00004296 51C9 FFFC                M 	dbf	d1,.clear_183
0000429A                            
0000429A 2278 E868                  		movea.l	ringMgrLayout.w,a1		; Get ring data pointer
0000429E 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store address
000042A2 5849                       		addq.w	#4,a1				; Increment address by 4
000042A4 7A00                       		moveq	#0,d5				; Initialize the ring counter
000042A6 303C 01FE                  		move.w	#$1FE,d0			; Max number of ring
000042AA                            
000042AA                            .GetRingCount:
000042AA 4A99                       		tst.l	(a1)+				; Have all the ring been counted?
000042AC 6B00                       		bmi.s	.Exit				; If so, branch
000042AE 5245                       		addq.w	#1,d5				; Increment ring counter
000042B0 51C8 FFF8                  		dbf	d0,.GetRingCount		; Loop
000042B4                            
000042B4                            .Exit:
000042B4 4E75                       		rts
000042B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000042B6                            ; Do ring collision for the player
000042B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000042B6                            PlayeringCollectlision:
000042B6 0C28 0069 0000             		cmpi.b	#105,_objInvulTime(a0)		; Is the player able to collect rings while hurt?
000042BC 6400 0000                  		bhs.w	.End				; If it hasn't been long enough, branch
000042C0 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get starting address of ring data
000042C4 2478 E870                  		movea.l	ringMgrLoadR.w,a2		; Get starting address of status table
000042C8 B5C9                       		cmpa.l	a1,a2				; Are there any rings to test collision with?
000042CA 6700 0000                  		beq.w	.End				; If not, branch
000042CE 3878 E874                  		movea.w	ringMgrStatPtr.w,a4
000042D2 3428 0014                  		move.w	_objXPos(a0),d2			; Player's X position
000042D6 3628 0018                  		move.w	_objYPos(a0),d3			; Player's Y position
000042DA 5142                       		subq.w	#8,d2				; Subtract 8 from X
000042DC 7A00                       		moveq	#0,d5
000042DE 1A28 002D                  		move.b	_objColH(a0),d5			; Player's collision height
000042E2 5705                       		subq.b	#3,d5				; Subtract 3 from collision height
000042E4 9645                       		sub.w	d5,d3				; Subtract from Y
000042E6 323C 0006                  		move.w	#6,d1
000042EA 3C3C 000C                  		move.w	#$C,d6
000042EE 383C 0010                  		move.w	#$10,d4				; Width
000042F2 DA45                       		add.w	d5,d5				; Double the height
000042F4                            
000042F4                            .NextRing:
000042F4 4A54                       		tst.w	(a4)				; Is the current ring already consumed?
000042F6 6600                       		bne.s	.GetNext			; If so, get the next ring
000042F8 3011                       		move.w	(a1),d0				; Get ring's X position
000042FA 9041                       		sub.w	d1,d0				; Subtract the player's X from the ring's X
000042FC 9042                       		sub.w	d2,d0				; Check collision
000042FE 6400                       		bcc.s	.ChkCol
00004300 D046                       		add.w	d6,d0
00004302 6500                       		bcs.s	.ChkCol2
00004304 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00004308                            
00004308                            .ChkCol:
00004308 B044                       		cmp.w	d4,d0				; Check collision
0000430A 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
0000430E                            
0000430E                            .ChkCol2:
0000430E 3029 0002                  		move.w	2(a1),d0			; Do Y collision check
00004312 9041                       		sub.w	d1,d0
00004314 9043                       		sub.w	d3,d0
00004316 6400                       		bcc.s	.ChkCol3
00004318 D046                       		add.w	d6,d0
0000431A 6500                       		bcs.s	.Collect
0000431C 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00004320                            
00004320                            .ChkCol3:
00004320 B045                       		cmp.w	d5,d0
00004322 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00004326                            
00004326                            .Collect:
00004326                            							; Consume the ring
00004326 38BC 0000                  		move.w	#(6<<8)|((CMap_Ring_Sparkle-CMap_Ring)/8),(a4)
0000432A 6100                       		bsr.s	CollectRing			; Collect it
0000432C 47F8 E3D4                  		lea	ringColList.w,a3		; Get collection list
00004330                            
00004330                            .Consume:
00004330 4A5B                       		tst.w	(a3)+				; Has this slot been used up?
00004332 66FC                       		bne.s	.Consume			; If not, get the next one
00004334 370C                       		move.w	a4,-(a3)			; Save the status table RAM address for the current ring
00004336 5278 E3D2                  		addq.w	#1,ringColCount.w		; Add to the number of rings consumed
0000433A                            
0000433A                            .GetNext:
0000433A 5849                       		addq.w	#4,a1				; Next ring in ring data
0000433C 544C                       		addq.w	#2,a4				; Next ring in status table
0000433E B5C9                       		cmpa.l	a1,a2				; Have we reached the end?
00004340 6600 FFB2                  		bne.w	.NextRing			; If not, loop
00004344                            
00004344                            .End:
00004344 4E75                       		rts
00004346                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004346                            ; Collect a ring
00004346                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004346                            CollectRing:
00004346 5278 E85E                  		addq.w	#1,ringCount.w			; Incremment ring count
0000434A 50F8 E867                  		st	hudUpdateRings.w			; Update ring counter in HUD
0000434E                            		playSnd	#sRing, 2			; Play ring sound
0000434E 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00004354 4E75                       		rts
00004356                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004356                            ; Render the HUD
00004356                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004356                            Level_RenderHUDAndRings:
00004356 7C00                       		moveq	#0,d6				; Clear render flags
00004358 7802                       		moveq	#1*2,d4				; Standard frame
0000435A 4A78 E85E                  		tst.w	ringCount.w			; Do we have 0 rings?
0000435E 6600                       		bne.s	.Not0Rings			; If not, branch
00004360 0838 0003 E905             		btst	#3,(lvlFrameCnt+1).w		; Can the timer blink?
00004366 6600                       		bne.s	.Not0Rings			; If not, branch
00004368 7800                       		moveq	#0*2,d4				; Set frame to blink the timer
0000436A                            
0000436A                            .Not0Rings:
0000436A 3A3C 8680                  		move.w	#$8680,d5			; Tile properties
0000436E                            		
0000436E 303C 0090                  		move.w	#16+128,d0			; X position
00004372 323C 0088                  		move.w	#8+128,d1			; Y position
00004376 43FA 0000                  		lea	Map_HUD(pc),a1			; Mappings
0000437A D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get address of frame
0000437E 3819                       		move.w	(a1)+,d4			; Get number of sprites in the frame
00004380 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00004382 4EB8 0852                  		jsr	DrawSprite.w			; Draw the HUD frame
00004386                            
00004386                            .RenderingCount:
00004386 2078 E86C                  		movea.l	ringMgrLoadL.w,a0			; Get starting address of ring data
0000438A 2438 E870                  		move.l	ringMgrLoadR.w,d2			; Get ending address of ring data
0000438E 9488                       		sub.l	a0,d2				; Get length of the data to read
00004390 6700                       		beq.s	.End				; If zero length, branch
00004392 3878 E874                  		movea.w	ringMgrStatPtr.w,a4		; Get starting address of status table
00004396 43FA 0000                  		lea	CMap_Ring(pc),a1		; Get mappings pointer
0000439A 3A3C 00F0                  		move.w	#224+16,d5			; Get bottom screen boundary
0000439E                            		
0000439E                            .Loop:
0000439E 4A5C                       		tst.w	(a4)+				; Is this ring collected?
000043A0 6B00                       		bmi.s	.Next				; If so, branch
000043A2 3228 0002                  		move.w	2(a0),d1			; Get Y position
000043A6 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract camera's Y position to get screen position
000043AA 5041                       		addq.w	#8,d1				; Add 8
000043AC B245                       		cmp.w	d5,d1				; Is it below the bottom of the screen?
000043AE 6400                       		bhs.s	.Next				; If so, branch
000043B0 0641 0078                  		addi.w	#120,d1				; Add 120 to move it within screen space
000043B4 3010                       		move.w	(a0),d0				; Get X position
000043B6 9053                       		sub.w	cXPos(a3),d0			; Subtract camera's X position to get screen position
000043B8 0640 0080                  		addi.w	#128,d0				; Add 128 to move it within screen space
000043BC 7C00                       		moveq	#0,d6
000043BE 1C2C FFFF                  		move.b	-1(a4),d6			; Get frame
000043C2                            
000043C2                            .Draw:
000043C2 E74E                       		lsl.w	#3,d6				; Turn frame ID into offset
000043C4 45F1 6000                  		lea	(a1,d6.w),a2			; Get address of frame map data
000043C8 D25A                       		add.w	(a2)+,d1			; Add Y offset
000043CA 3CC1                       		move.w	d1,(a6)+			; Save Y position
000043CC 3C1A                       		move.w	(a2)+,d6			; Get sprite size
000043CE 1C86                       		move.b	d6,(a6)				; Save it
000043D0 544E                       		addq.w	#2,a6				; Skip link value
000043D2 3CDA                       		move.w	(a2)+,(a6)+			; Save base tile ID and properites
000043D4 D05A                       		add.w	(a2)+,d0			; Add X offset
000043D6 3CC0                       		move.w	d0,(a6)+			; Save X position
000043D8 5347                       		subq.w	#1,d7				; Decrement the number of sprites left available
000043DA                            
000043DA                            .Next:
000043DA 5848                       		addq.w	#4,a0				; Next ring in ring data
000043DC 5942                       		subq.w	#4,d2				; Decrement the ring count
000043DE 66BE                       		bne.s	.Loop				; If there are still rings to check, loop
000043E0                            
000043E0                            .End:
000043E0 4E75                       		rts
000043E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043E2                            ; Custom mappings format.
000043E2                            ; Differences include...
000043E2                            ;	No offset table (each sprite assumed to be 8 bytes)
000043E2                            ;	No 'sprite pieces per frame' value (hardcoded to 1)
000043E2                            ;	Sign-extended Y-pos value
000043E2                            ;	Sign-extended sprite size value
000043E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043E2                            CMap_Ring:
000043E2                            		; Main ring frame
000043E2 FFF8                       		dc.w	$FFF8
000043E4 0005                       		dc.w	$0005
000043E6 26BC                       		dc.w	$0000+$26BC
000043E8 FFF8                       		dc.w	$FFF8
000043EA                            
000043EA                            CMap_Ring_Sparkle:
000043EA                            		; Ring sparkle frame 1
000043EA FFF8                       		dc.w	$FFF8
000043EC 0005                       		dc.w	$0005
000043EE 26B8                       		dc.w	$0000+$26B8
000043F0 FFF8                       		dc.w	$FFF8
000043F2                            		; Ring sparkle frame 2
000043F2 FFF8                       		dc.w	$FFF8
000043F4 0005                       		dc.w	$0005
000043F6 3EB8                       		dc.w	($0000+$26B8)|$1800
000043F8 FFF8                       		dc.w	$FFF8
000043FA                            		; Ring sparkle frame 3
000043FA FFF8                       		dc.w	$FFF8
000043FC 0005                       		dc.w	$0005
000043FE 2EB8                       		dc.w	($0000+$26B8)|$800
00004400 FFF8                       		dc.w	$FFF8
00004402                            		; Ring sparkle frame 4
00004402 FFF8                       		dc.w	$FFF8
00004404 0005                       		dc.w	$0005
00004406 36B8                       		dc.w	($0000+$26B8)|$1000
00004408 FFF8                       		dc.w	$FFF8
0000440A                            CMap_Ring_Sparkle_Last:
0000440A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000440A                            ; HUD mappings
0000440A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000440A                            Map_HUD:	
0000440A 0000 0000                  		dc.w Map_HUD_4-Map_HUD, Map_HUD_18-Map_HUD	
0000440E                            
0000440E 0003                       Map_HUD_4:	dc.b 0, 3	
00004410 000D 0002 0000             		dc.b 0, $D, 0, 2, 0, 0	
00004416 0001 0000 0020             		dc.b 0, 1, 0, 0, 0, $20	
0000441C 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30
00004422                            
00004422 0003                       Map_HUD_18:	dc.b 0, 3	
00004424 000D 2002 0000             		dc.b 0, $D, $20, 2, 0, 0	
0000442A 0001 2000 0020             		dc.b 0, 1, $20, 0, 0, $20	
00004430 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00004436                            		even
00004436                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004436                            ; Update the HUD
00004436                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004436                            ; PARAMETERS:
00004436                            ;	a5.l	- VDP data port
00004436                            ;	a6.l	- VDP control port
00004436                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004436                            ; RETURNS:
00004436                            ;	Nothing
00004436                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004436                            Level_UpdateHUD:
00004436 4A38 E867                  		tst.b	hudUpdateRings.w		; Does the ring counter need to be updated?
0000443A 6700                       		beq.s	.End				; If not, branch
0000443C 6B00                       		bmi.s	.DontZero			; If the flag is negative, branch
0000443E 6100 0000                  		bsr.w	Level_HUDResetRings		; Reset the ring counter
00004442                            
00004442                            .DontZero:
00004442 4238 E867                  		clr.b	hudUpdateRings.w		; Clear update value
00004446                            		vdpCmd	move.l,$D140,VRAM,WRITE,d0	; Set VDP command
00004446 203C 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),d0
0000444C 7200                       		moveq	#0,d1
0000444E 3238 E85E                  		move.w	ringCount.w,d1			; Ring count
00004452 6000                       		bra.s	.UpdateRings			; Update the rings counter
00004454                            
00004454                            .End
00004454 4E75                       		rts
00004456                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004456                            .UpdateRings:
00004456 7800                       		moveq	#0,d4				; Reset the "draw digit" flag
00004458 45F9 0000 0000             		lea	HUDMod_100,a2			; Start with the 100s digit
0000445E 7C02                       		moveq	#3-1,d6				; Number of digits to draw
00004460 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers
00004466                            		
00004466                            .LoadDigit_Loop:
00004466 7400                       		moveq	#0,d2				; Reset the digit
00004468 261A                       		move.l	(a2)+,d3			; Get the number that's used to calculute what the current digit is
0000446A                            		
0000446A                            .GetDigit:
0000446A 9283                       		sub.l	d3,d1				; Subtract
0000446C 6500                       		bcs.s	.InitDrawDigit			; If it's gone below 0, branch
0000446E 5242                       		addq.w	#1,d2				; Increment digit
00004470 60F8                       		bra.s	.GetDigit			; Loop until the digit is corret
00004472                            
00004472                            .InitDrawDigit:
00004472 D283                       		add.l	d3,d1				; Add back
00004474 4A42                       		tst.w	d2				; Is the digit 0?
00004476 6700                       		beq.s	.DrawDigit			; If so, branch
00004478 50C4                       		st	d4				; Set the "draw digit" flag
0000447A                            
0000447A                            .DrawDigit:
0000447A 4A04                       		tst.b	d4				; Should we draw the digit?
0000447C 6700                       		beq.s	.NextDigit			; If not, branch
0000447E ED4A                       		lsl.w	#6,d2				; Multiply the digit by $40
00004480 2C80                       		move.l	d0,(a6)				; Set the VDP command
00004482 47F1 2000                  		lea	(a1,d2.w),a3			; Get address of the digit art
00004486                            		rept	16
00004486                            			move.l	(a3)+,(a5)		; Load the digit art
00004486                            		endr
00004486 2A9B                     M 	move.l	(a3)+,(a5)
00004488 2A9B                     M 	move.l	(a3)+,(a5)
0000448A 2A9B                     M 	move.l	(a3)+,(a5)
0000448C 2A9B                     M 	move.l	(a3)+,(a5)
0000448E 2A9B                     M 	move.l	(a3)+,(a5)
00004490 2A9B                     M 	move.l	(a3)+,(a5)
00004492 2A9B                     M 	move.l	(a3)+,(a5)
00004494 2A9B                     M 	move.l	(a3)+,(a5)
00004496 2A9B                     M 	move.l	(a3)+,(a5)
00004498 2A9B                     M 	move.l	(a3)+,(a5)
0000449A 2A9B                     M 	move.l	(a3)+,(a5)
0000449C 2A9B                     M 	move.l	(a3)+,(a5)
0000449E 2A9B                     M 	move.l	(a3)+,(a5)
000044A0 2A9B                     M 	move.l	(a3)+,(a5)
000044A2 2A9B                     M 	move.l	(a3)+,(a5)
000044A4 2A9B                     M 	move.l	(a3)+,(a5)
000044A6                            		
000044A6                            .NextDigit:
000044A6 0680 0040 0000             		addi.l	#$400000,d0			; Next digit
000044AC 51CE FFB8                  		dbf	d6,.LoadDigit_Loop		; Loop
000044B0 4E75                       		rts
000044B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044B2 0000 0064                  HUDMod_100:	dc.l	100
000044B6 0000 000A                  HUDMod_10:	dc.l	10
000044BA 0000 0001                  HUDMod_1:	dc.l	1
000044BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044BE                            ; Initialize the HUD
000044BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044BE                            Level_InitHUD:
000044BE 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP data port
000044C4 4BEE FFFC                  		lea	-4(a6),a5			; VDP control port
000044C8                            		
000044C8                            Level_HUDResetRings:
000044C8                            		vdpCmd	move.l,$D140,VRAM,WRITE,(a6)	; Set VDP command
000044C8 2CBC 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),(a6)
000044CE 45FA 0000                  		lea	HUD_RingsBase(pc),a2		; Tile base
000044D2 343C 0002                  		move.w	#3-1,d2				; Length
000044D6                            
000044D6 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers art
000044DC                            
000044DC                            .LoadTiles:
000044DC 101A                       		move.b	(a2)+,d0			; Get digit
000044DE 4880                       		ext.w	d0
000044E0 ED48                       		lsl.w	#6,d0				; Turn into offset
000044E2 47F1 0000                  		lea	(a1,d0.w),a3			; Get address of digit art
000044E6                            
000044E6                            		rept	8*2
000044E6                            			move.l	(a3)+,(a5)		; Load art
000044E6                            		endr
000044E6 2A9B                     M 	move.l	(a3)+,(a5)
000044E8 2A9B                     M 	move.l	(a3)+,(a5)
000044EA 2A9B                     M 	move.l	(a3)+,(a5)
000044EC 2A9B                     M 	move.l	(a3)+,(a5)
000044EE 2A9B                     M 	move.l	(a3)+,(a5)
000044F0 2A9B                     M 	move.l	(a3)+,(a5)
000044F2 2A9B                     M 	move.l	(a3)+,(a5)
000044F4 2A9B                     M 	move.l	(a3)+,(a5)
000044F6 2A9B                     M 	move.l	(a3)+,(a5)
000044F8 2A9B                     M 	move.l	(a3)+,(a5)
000044FA 2A9B                     M 	move.l	(a3)+,(a5)
000044FC 2A9B                     M 	move.l	(a3)+,(a5)
000044FE 2A9B                     M 	move.l	(a3)+,(a5)
00004500 2A9B                     M 	move.l	(a3)+,(a5)
00004502 2A9B                     M 	move.l	(a3)+,(a5)
00004504 2A9B                     M 	move.l	(a3)+,(a5)
00004506                            
00004506 51CA FFD4                  		dbf	d2,.LoadTiles			; Loop
0000450A                            
0000450A 4E75                       		rts
0000450C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000450C                            HUD_RingsBase:
0000450C 0A0A 00                    		dc.b	$A, $A, 0			; Ring count
00004510 00                         		even
00004510                            
00004510                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004510                            ; Animate the level art
00004510                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004510                            ; LEVEL ANIMATION SCRIPTS
00004510                            ;
00004510                            ; The AniArt_D_objAnimmate subroutine uses these scripts to reload certain tiles,
00004510                            ; thus animating them. All the relevant art must be uncompressed, because
00004510                            ; otherwise the subroutine would spend so much time waiting for the art to be
00004510                            ; decompressed that the VBLANK window would close before all the animating was done.
00004510                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004510                            ;	zoneanimdecl -1, ArtUnc_Flowers1, ArtTile_ArtUnc_Flowers1, 6, 2
00004510                            ;		-1			Global frame duration. If -1, then each frame will use its own duration, instead
00004510                            ;		ArtUnc_Flowers1		Source address
00004510                            ;		ArtTile_ArtUnc_Flowers1	Destination VRAM address
00004510                            ;		6			Number of frames
00004510                            ;		2			Number of tiles to load into VRAM for each frame
00004510                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004510                            ;	dc.b   0,$7F			Start of the script proper
00004510                            ;		0			Tile ID of first tile in ArtUnc_Flowers1 to transfer
00004510                            ;		$7F			Frame duration. Only here if global duration is -1
00004510                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004510                            AniArt_D_objAnimmate:
00004510 47F8 E90C                  		lea	lvlAnimCntrs.w,a3		; Level art animation counters
00004514 3C1A                       		move.w	(a2)+,d6			; Get number of scripts in list
00004516 6A00                       		bpl.s	.ListNotEmpty			; If there are any, continue
00004518 4E75                       		rts
0000451A                            
0000451A                            .ListNotEmpty:
0000451A                            .Loop:
0000451A 5313                       		subq.b	#1,(a3)				; Tick down frame duration
0000451C 6400                       		bcc.s	.NextScript			; If frame isn't over, move on to next script
0000451E                            
0000451E                            .NextFrame:
0000451E 7000                       		moveq	#0,d0
00004520 102B 0001                  		move.b	1(a3),d0			; Get current frame
00004524 B02A 0006                  		cmp.b	6(a2),d0			; Have we processed the last frame in the script?
00004528 6500                       		blo.s	.NotLastFrame			; If not, branch
0000452A 7000                       		moveq	#0,d0				; If so, reset to first frame
0000452C 1740 0001                  		move.b	d0,1(a3)			; ''
00004530                            
00004530                            .NotLastFrame:
00004530 522B 0001                  		addq.b	#1,1(a3)			; Consider this frame processed; set counter to next frame
00004534 1692                       		move.b	(a2),(a3)			; Set frame duration to global duration value
00004536 6A00                       		bpl.s	.GlobalDuration
00004538 D040                       		add.w	d0,d0				; If script uses per-frame durations, use those instead
0000453A 16B2 0009                  		move.b	9(a2,d0.w),(a3)			; Set frame duration to current frame's duration value
0000453E                            
0000453E                            .GlobalDuration:
0000453E 1032 0008                  		move.b	8(a2,d0.w),d0			; Get tile ID
00004542 EB48                       		lsl.w	#5,d0				; Turn it into an offset
00004544 342A 0004                  		move.w	4(a2),d2			; Get VRAM destination address
00004548 2212                       		move.l	(a2),d1				; Get ROM source address
0000454A 0281 00FF FFFF             		andi.l	#$FFFFFF,d1			; ''
00004550 D280                       		add.l	d0,d1				; Offset into art, to get the address of new frame
00004552 7600                       		moveq	#0,d3
00004554 162A 0007                  		move.b	7(a2),d3			; Get size of art to be transferred 
00004558 E94B                       		lsl.w	#4,d3				; Turn it into actual size (in words)
0000455A 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a DMA transfer
0000455E                            
0000455E                            .NextScript:
0000455E 102A 0006                  		move.b	6(a2),d0			; Get total size of frame data
00004562 4A12                       		tst.b	(a2)				; Is per-frame duration data present?
00004564 6A00                       		bpl.s	.GlobalDuration2		; If not, keep the current size; it's correct
00004566 D000                       		add.b	d0,d0				; Double size to account for the additional frame duration data
00004568                            
00004568                            .GlobalDuration2:
00004568 5200                       		addq.b	#1,d0
0000456A 0240 00FE                  		andi.w	#$FE,d0				; Round to next even address, if it isn't already
0000456E 45F2 0008                  		lea	8(a2,d0.w),a2			; Advance to next script in list
00004572 544B                       		addq.w	#2,a3				; Advance to next script's slot in a3 (usually Anim_Counters)
00004574 51CE FFA4                  		dbf	d6,.Loop			; Loop
00004578 4E75                       		rts
0000457A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000457A                            ; Set an object as solid and check for collision
0000457A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000457A                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For _objStatus):
0000457A                            ;	XXPXSXAX
0000457A                            ;	X	- Unused
0000457A                            ;	P	- Pushing flag
0000457A                            ;	S	- Standing on flag
0000457A                            ;	A	- In air flag (for the player)
0000457A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000457A                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For d6):
0000457A                            ;	XXXTXBXS
0000457A                            ;	X	- Unused
0000457A                            ;	T	- Touch top flag
0000457A                            ;	B	- Touch bottom flag
0000457A                            ;	S	- Touch side flag
0000457A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000457A                            ; PARAMETERS:
0000457A                            ;	d1.w	- Object width
0000457A                            ;	d2.w	- Object height / 2 (when jumping)
0000457A                            ;	d3.w	- Object height / 2 (when walking)
0000457A                            ;	d4.w	- Object x-axis position
0000457A                            ;	a0.l	- Object space pointer
0000457A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000457A                            ; RETURNS:
0000457A                            ;	See object collision return values above
0000457A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000457A                            SolidObject:
0000457A 7C00                       		moveq	#0,d6				; Clear collision flag register
0000457C 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
00004580 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
00004586 6700 0000                  		beq.w	SolidObject_ChkColOnScr		; If not, branch
0000458A 3401                       		move.w	d1,d2				; Copy object width
0000458C D442                       		add.w	d2,d2				; Double it
0000458E 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004594 6600                       		bne.s	.NotOnTop			; If so, branch
00004596 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
0000459A 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
0000459E D041                       		add.w	d1,d0				; Add width
000045A0 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000045A2 B042                       		cmp.w	d2,d0				; Compare with the width
000045A4 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000045A6                            
000045A6                            .NotOnTop:
000045A6 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
000045AC 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
000045B2 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
000045B8 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
000045BC 7800                       		moveq	#0,d4				; Set collision status to 0
000045BE 4E75                       		rts
000045C0                            
000045C0                            .IsOnTop:
000045C0 3404                       		move.w	d4,d2				; Copy X position to d2
000045C2 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
000045C6 7800                       		moveq	#0,d4				; Set collision status to 0
000045C8 4E75                       		rts
000045CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045CA                            ; Set an object as solid and check for collision (even if off screen)
000045CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045CA                            ; PARAMETERS:
000045CA                            ;	d1.w	- Object width
000045CA                            ;	d2.w	- Object height / 2 (when jumping)
000045CA                            ;	d3.w	- Object height / 2 (when walking)
000045CA                            ;	d4.w	- Object x-axis position
000045CA                            ;	a0.l	- Object space pointer
000045CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045CA                            ; RETURNS:
000045CA                            ;	See object collision return values above
000045CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045CA                            SolidObject_Always:
000045CA 7C00                       		moveq	#0,d6				; Clear collision flag register
000045CC 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
000045D0 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
000045D6 6700 0000                  		beq.w	SolidObject_ChkCollision	; If not, branch
000045DA 3401                       		move.w	d1,d2				; Copy object width
000045DC D442                       		add.w	d2,d2				; Double it
000045DE 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000045E4 6600                       		bne.s	.NotOnTop			; If so, branch
000045E6 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
000045EA 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
000045EE D041                       		add.w	d1,d0				; Add width
000045F0 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000045F2 B042                       		cmp.w	d2,d0				; Compare with the width
000045F4 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000045F6                            
000045F6                            .NotOnTop:
000045F6 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
000045FC 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
00004602 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
00004608 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
0000460C 7800                       		moveq	#0,d4				; Set collision status to 0
0000460E 4E75                       		rts
00004610                            
00004610                            .IsOnTop:
00004610 3404                       		move.w	d4,d2				; Copy X position to d2
00004612 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
00004616 7800                       		moveq	#0,d4				; Set collision status to 0
00004618 4E75                       		rts
0000461A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000461A                            ; Set an object as a solid slope and check for collision
0000461A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000461A                            ; PARAMETERS:
0000461A                            ;	d1.w	- Object width
0000461A                            ;	d2.w	- Object height / 2 (when jumping)
0000461A                            ;	d3.w	- Object height / 2 (when walking)
0000461A                            ;	d4.w	- Object x-axis position
0000461A                            ;	a0.l	- Object space pointer
0000461A                            ;	a2.l	- Slope height data pointer
0000461A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000461A                            ; RETURNS:
0000461A                            ;	See object collision return values above
0000461A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000461A                            SlopedSolid:
0000461A 7C00                       		moveq	#0,d6				; Clear collision flag register
0000461C 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
00004620 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
00004626 6700 0000                  		beq.w	SlopedSolid_ChkCollision	; If not, branch
0000462A 3401                       		move.w	d1,d2				; Copy object width
0000462C D442                       		add.w	d2,d2				; Double it
0000462E 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004634 6600                       		bne.s	.NotOnTop			; If so, branch
00004636 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
0000463A 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
0000463E D041                       		add.w	d1,d0				; Add width
00004640 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004642 B042                       		cmp.w	d2,d0				; Compare with the width
00004644 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004646                            
00004646                            .NotOnTop:
00004646 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
0000464C 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
00004652 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
00004658 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
0000465C 7800                       		moveq	#0,d4				; Set collision status to 0
0000465E 4E75                       		rts
00004660                            
00004660                            .IsOnTop:
00004660 3404                       		move.w	d4,d2				; Copy X position to d2
00004662 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Move the player on top of the current object
00004666 7800                       		moveq	#0,d4				; Set collision status to 0
00004668 4E75                       		rts
0000466A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000466A                            SlopedSolid_ChkCollision:
0000466A 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
0000466E 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract current object's X position
00004672 D041                       		add.w	d1,d0				; Add width to it
00004674 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
00004678 3601                       		move.w	d1,d3				; Copy width to d3
0000467A D643                       		add.w	d3,d3				; Double it
0000467C B043                       		cmp.w	d3,d0				; Compare to the X position
0000467E 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
00004682 3A00                       		move.w	d0,d5				; Copy the X position to d5
00004684 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X-flipped?
0000468A 6700                       		beq.s	.NoFlip				; If not, branch
0000468C 4645                       		not.w	d5				; Logical notation on d5
0000468E DA43                       		add.w	d3,d5				; Add width
00004690                            
00004690                            .NoFlip:
00004690 E24D                       		lsr.w	#1,d5				; Divide by 2
00004692 1632 5000                  		move.b	(a2,d5.w),d3			; Get height of this segment
00004696 9612                       		sub.b	(a2),d3				; Subtract first bytes from the value
00004698 4883                       		ext.w	d3				; Sign extend to word
0000469A 3A28 0018                  		move.w	_objYPos(a0),d5			; Get the current object's Y position
0000469E 9A43                       		sub.w	d3,d5				; Subtract the height from the Y position
000046A0 1629 002D                  		move.b	_objColH(a1),d3			; Get the player's collision height
000046A4 4883                       		ext.w	d3				; Sign extend to word
000046A6 D443                       		add.w	d3,d2				; Add collision height to the object height
000046A8 3629 0018                  		move.w	_objYPos(a1),d3			; Get the player's Y position
000046AC 9645                       		sub.w	d5,d3				; Subtract d5
000046AE 5843                       		addq.w	#4,d3				; Add 4
000046B0 D642                       		add.w	d2,d3				; Add height and collision height
000046B2 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
000046B6 3802                       		move.w	d2,d4				; Copy height and collision height
000046B8 D844                       		add.w	d4,d4				; Double it
000046BA B644                       		cmp.w	d4,d3				; Compare to Y position
000046BC 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
000046C0 6000 0000                  		bra.w	SolidObject_ChkBounds		; If anything else, we are colliding
000046C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046C4                            SolidObject_ChkColOnScr:
000046C4 4A28 000D                  		tst.b	_objRender(a0)			; Is the object on screen?
000046C8 6A00 0000                  		bpl.w	SolidObject_TestClearPush	; If not, branch
000046CC                            
000046CC                            SolidObject_ChkCollision:
000046CC 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
000046D0 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
000046D4 D041                       		add.w	d1,d0				; Add width
000046D6 3601                       		move.w	d1,d3				; Copy width
000046D8 D643                       		add.w	d3,d3				; Double it
000046DA B043                       		cmp.w	d3,d0				; Compare with the X position
000046DC 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
000046E0                            		
000046E0 1829 0000                  		move.b	_objInitColH(a1),d4		; Get the player's default collision height
000046E4 4884                       		ext.w	d4				; Sign extend to word
000046E6 D842                       		add.w	d2,d4				; Add height
000046E8 1629 002D                  		move.b	_objColH(a1),d3			; Get the player's collision height
000046EC 4883                       		ext.w	d3				; Sign extend to word
000046EE D443                       		add.w	d3,d2				; Add to height
000046F0 3629 0018                  		move.w	_objYPos(a1),d3			; Get player's Y position
000046F4 9668 0018                  		sub.w	_objYPos(a0),d3			; Subtract the current object's Y position
000046F8 5843                       		addq.w	#4,d3				; Add 4
000046FA D642                       		add.w	d2,d3				; Add height
000046FC 0243 0FFF                  		andi.w	#$FFF,d3			; Keep in range
00004700 D842                       		add.w	d2,d4				; Add height
00004702 B644                       		cmp.w	d4,d3				; Compare with the Y position
00004704 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
00004708                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004708                            SolidObject_ChkBounds:
00004708 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
0000470C 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If so, branch
00004710 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is the player dead?
00004716 6400 0000                  		bcc.w	SolidObject_End			; If so, branch
0000471A 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
0000471E 6600 0000                  		bne.w	SolidObject_End			; If so, branch
00004722                            
00004722 3A00                       		move.w	d0,d5				; Copy X offset
00004724 B240                       		cmp.w	d0,d1				; Check against the "middle" of the object
00004726 6400                       		bcc.s	.IsLeft				; If the player is left of the middle, branch
00004728 D241                       		add.w	d1,d1				; Double collision width
0000472A 9041                       		sub.w	d1,d0				; Subtract from X offset
0000472C 3A00                       		move.w	d0,d5				; Copy X offset
0000472E 4445                       		neg.w	d5				; Negate offset
00004730                            
00004730                            .IsLeft:
00004730 3203                       		move.w	d3,d1				; Copy Y offset
00004732 B443                       		cmp.w	d3,d2				; Check against the "middle" of the object
00004734 6400                       		bcc.s	.IsAbove			; If the player is above of the middle, branch
00004736 5943                       		subq.w	#4,d3				; Subtract 4 from the collision height
00004738 9644                       		sub.w	d4,d3				; Subtract height from the collision height
0000473A 3203                       		move.w	d3,d1				; Copy Y offset
0000473C 4441                       		neg.w	d1				; Negate offset
0000473E                            
0000473E                            .IsAbove:
0000473E BA41                       		cmp.w	d1,d5
00004740 6200 0000                  		bhi.w	SolidObject_UpDown		; Branch if we are in the object less vertically than horizontally(?)
00004744 0C41 0004                  		cmpi.w	#4,d1
00004748 6300 0000                  		bls.w	SolidObject_UpDown		; I assume this ensures the corners are not solid until some point
0000474C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000474C                            SolidObject_Sides:
0000474C 4A40                       		tst.w	d0
0000474E 6700                       		beq.s	.AlignPlayer			; Branch if we are in the middle of the object?
00004750 6B00                       		bmi.s	.ChkRight			; Branch if we are right of the object
00004752 4A69 001C                  		tst.w	_objXVel(a1)			; Is the player moving left?
00004756 6B00                       		bmi.s	.AlignPlayer			; If so, branch
00004758 6000                       		bra.s	.ClearGroundVel			; If else player is moving right, branch
0000475A                            
0000475A                            .ChkRight:
0000475A 4A69 001C                  		tst.w	_objXVel(a1)
0000475E 6A00                       		bpl.s	.AlignPlayer			; Branch if player is moving right
00004760                            
00004760                            .ClearGroundVel:
00004760 4269 0000                  		clr.w	_objGVel(a1)			; Stop the player from moving
00004764 4269 001C                  		clr.w	_objXVel(a1)			; Clear the player's X velocity
00004768                            
00004768                            .AlignPlayer:
00004768 9169 0014                  		sub.w	d0,_objXPos(a1)			; Align player to the side of the object
0000476C 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004772 6600                       		bne.s	.InAir				; If so, branch
00004774 08E8 0005 0028             		bset	#cPushBit,_objStatus(a0)		; Set the pushing bit
0000477A 08E9 0005 0028             		bset	#cPushBit,_objStatus(a1)		; Set the player's pushing bit
00004780 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
00004784 7801                       		moveq	#1,d4				; Set collision status to 1
00004786 4E75                       		rts
00004788                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004788                            .InAir:
00004788 6100                       		bsr.s	SolidObject_ClearPush		; Clear pushing bits
0000478A 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
0000478E 7801                       		moveq	#1,d4				; Set collision status to 1
00004790 4E75                       		rts
00004792                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004792                            SolidObject_TestClearPush:
00004792 0828 0005 0028             		btst	#cPushBit,_objStatus(a0)		; Is the player pushing this object?
00004798 6700                       		beq.s	SolidObject_End			; If not, branch
0000479A 0C29 0002 0020             		cmpi.b	#2,_objAnim(a1)			; Is the player jumping/rolling?
000047A0 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000047A2 0C29 0017 0020             		cmpi.b	#$17,_objAnim(a1)			; Is the player in using the drowning animation
000047A8 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000047AA 0C29 001A 0020             		cmpi.b	#$1A,_objAnim(a1)			; Is the player in using the hurt animation
000047B0 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000047B2 337C 0001 0020             		move.w	#1,_objAnim(a1)			; Make the player use the walking animation
000047B8                            
000047B8                            SolidObject_ClearPush:
000047B8 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Clear the pushing bit
000047BE 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; Clear the player's pushing bit
000047C4                            
000047C4                            SolidObject_End:
000047C4 7800                       		moveq	#0,d4				; Set collision status to 0
000047C6 4E75                       		rts
000047C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047C8                            SolidObject_UpDown:
000047C8 4A43                       		tst.w	d3				; Is the player below the middle of the object?
000047CA 6B00                       		bmi.s	SolidObject_Below		; If so, branch
000047CC 0C43 0010                  		cmpi.w	#$10,d3				; Is the player 16 pixels or less above the middle of the object?
000047D0 6500                       		bcs.s	SolidObject_Above		; If so, branch
000047D2 60BE                       		bra.s	SolidObject_TestClearPush	; If not, the player is not colliding
000047D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047D4                            SolidObject_Below:
000047D4 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving vertically?
000047D8 6700                       		beq.s	.CheckCrush			; If so, branch
000047DA 6A00                       		bpl.s	.SetY				; If the player's moving down, branch
000047DC 4A43                       		tst.w	d3				; Is the player above the middle of the object?
000047DE 6A00                       		bpl.s	.SetY				; If so, branch
000047E0 4269 001E                  		clr.w	_objYVel(a1)			; Clear the player's Y velocity
000047E4                            
000047E4                            .SetY:
000047E4 9769 0018                  		sub.w	d3,_objYPos(a1)			; Push the player below the object
000047E8 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
000047EC 78FE                       		moveq	#-2,d4				; Set the collision status to -2
000047EE 4E75                       		rts
000047F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047F0                            .CheckCrush:
000047F0 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000047F6 66EC                       		bne.s	.SetY				; If so, branch
000047F8 3800                       		move.w	d0,d4				; Get x offset
000047FA 6A00                       		bpl.s	.NoNeg				; If it's positive branch
000047FC 4444                       		neg.w	d4				; Negate it (absolute value)
000047FE                            
000047FE                            .NoNeg:
000047FE 0C44 0010                  		cmpi.w	#$10,d4				; Is the player near the edge of object collision?
00004802 6500 FF48                  		blo.w	SolidObject_Sides		; If so, branch
00004806                            		
00004806                            		push.l	a0				; Store the current object's address
00004806 2F08                     M 	move.l	a0,-(sp)
00004808 2049                       		movea.l	a1,a0				; Replace with the player's address
0000480A 4EB9 0000 0000             		jsr	ObjPlayer_GetKilled		; Kill the player
00004810                            		pop.l	a0				; Restore the current object's address
00004810 205F                     M 	move.l	(sp)+,a0
00004812 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
00004816 78FE                       		moveq	#-2,d4				; Set collision status to -2
00004818 4E75                       		rts
0000481A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000481A                            SolidObject_Above:
0000481A 5943                       		subq.w	#4,d3				; Get the sub Y offset
0000481C                            		
0000481C                            		; This next bit ensures the player does not collide with the top when next to the walls
0000481C                            		; recalculates object width.
0000481C                            
0000481C 7200                       		moveq	#0,d1
0000481E 1228 002C                  		move.b	_objColW(a0),d1			; Get the current object's width
00004822 3401                       		move.w	d1,d2				; Copy it
00004824 D442                       		add.w	d2,d2				; Double it
00004826                            		
00004826 D269 0014                  		add.w	_objXPos(a1),d1			; Add the player's X position
0000482A 9268 0014                  		sub.w	_objXPos(a0),d1			; Subtract the current object's X position
0000482E 6B00                       		bmi.s	.NoCollision			; If the player is not colliding, branch
00004830                            		
00004830 B242                       		cmp.w	d2,d1				; Is the plauer colliding from the right?
00004832 6400                       		bcc.s	.NoCollision			; If the player is not colliding, branch
00004834                            		
00004834 5369 0018                  		subq.w	#1,_objYPos(a1)			; Subtract 1 from the player's Y position
00004838 9769 0018                  		sub.w	d3,_objYPos(a1)			; Move the player above the object
0000483C 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
00004840 6B00                       		bmi.s	.NoCollision			; If so, branch
00004842 6100 0000                  		bsr.w	RideObject_SetRide		; Allow the player to stand on top (and set the "ride" bit)
00004846 08C6 0004                  		bset	#cTouchTopBit,d6		; Set "touch top" flag
0000484A 78FF                       		moveq	#-1,d4				; Set collision status to -1
0000484C 4E75                       		rts
0000484E                            
0000484E                            .NoCollision:
0000484E 7800                       		moveq	#0,d4				; Set collision status to 0
00004850 4E75                       		rts
00004852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004852                            ; Set an object as a platform and check for collision
00004852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004852                            ; PARAMETERS:
00004852                            ;	d1.w	- Object's width
00004852                            ;	d2.w	- Object's width*2 (only for Platform_ChkBridgeCol)
00004852                            ;	d3.w	- Object's height
00004852                            ;	d4.w	- Object x-axis position
00004852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004852                            ; RETURNS:
00004852                            ;	See object collision return values above (side and bottom collision doesn't apply here)
00004852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004852                            PlatformObject:
00004852 7C00                       		moveq	#0,d6				; Clear collision flag register
00004854 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get the player RAM
00004858 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the object?
0000485E 6700 0000                  		beq.w	Platform_ChkCollision		; If not, branch
00004862 3401                       		move.w	d1,d2				; Copy the object's width
00004864 D442                       		add.w	d2,d2				; Double it
00004866 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
0000486C 6600                       		bne.s	.NotOnTop			; If so, branch
0000486E 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004872 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004876 D041                       		add.w	d1,d0				; Add width
00004878 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
0000487A B042                       		cmp.w	d2,d0				; Compare with the width
0000487C 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
0000487E                            
0000487E                            .NotOnTop:
0000487E 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the player's standing on object bit
00004884 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
0000488A 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
00004890 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004894 7800                       		moveq	#0,d4				; Set the collision status to 0
00004896 4E75                       		rts
00004898                            
00004898                            .OnTop:
00004898 3404                       		move.w	d4,d2				; Copy X position
0000489A 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Make the player stand on top of this object
0000489E 7800                       		moveq	#0,d4				; Set the collision status to 0
000048A0 4E75                       		rts
000048A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048A2                            Platform_ChkBridgeCol:
000048A2 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
000048A6 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000048AA 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
000048AE 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
000048B2 D041                       		add.w	d1,d0				; Add width
000048B4 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000048B8 B042                       		cmp.w	d2,d0				; Compare with width
000048BA 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000048BE 6000                       		bra.s	Platform_ChkCol_Cont		; Continue
000048C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048C0                            Platform_ChkCollision:
000048C0 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
000048C4 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000048C8 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
000048CC 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
000048D0 D041                       		add.w	d1,d0				; Add width
000048D2 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000048D6 D241                       		add.w	d1,d1				; Double width
000048D8 B041                       		cmp.w	d1,d0				; Compare with width
000048DA 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000048DE                            
000048DE                            Platform_ChkCol_Cont:
000048DE 3028 0018                  		move.w	_objYPos(a0),d0			; Get the object's Y position
000048E2 9043                       		sub.w	d3,d0				; Subtract the height from it
000048E4                            
000048E4                            PlatformObject_ChkYRange:
000048E4 3429 0018                  		move.w	_objYPos(a1),d2			; Get the player's Y position
000048E8 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
000048EC 4881                       		ext.w	d1				; Sign extend it
000048EE D242                       		add.w	d2,d1				; Add the Y position to the collision height
000048F0 5841                       		addq.w	#4,d1				; Add 4
000048F2 9041                       		sub.w	d1,d0				; SubactID the result from the Y position
000048F4 6200 0000                  		bhi.w	PlatformObject_End		; If it's greater than 0, branch
000048F8 0C40 FFF0                  		cmpi.w	#-$10,d0			; Is the result less than -16?
000048FC 6500 0000                  		bcs.w	PlatformObject_End		; If so, branch
00004900 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
00004904 6600 0000                  		bne.w	PlatformObject_End		; If so, branch
00004908 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
0000490C 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
00004910 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)		; Is the player dead?
00004916 6400 0000                  		bcc.w	PlatformObject_End		; If so, branch
0000491A D440                       		add.w	d0,d2				; Add the previous result to the Y position
0000491C 5642                       		addq.w	#3,d2				; Add 3
0000491E 3342 0018                  		move.w	d2,_objYPos(a1)			; Add to the player's Y position
00004922                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004922                            ; Set the player on top of the object
00004922                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004922                            ; PARAMETERS:
00004922                            ;	a0.l	- Object space pointer
00004922                            ;	a1.l	- Player object space pointer
00004922                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004922                            ; RETURNS:
00004922                            ;	Nothing
00004922                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004922                            RideObject_SetRide:
00004922 0829 0003 0028             		btst	#cStandBit,_objStatus(a1)		; Is the player standing on the object?
00004928 6700                       		beq.s	.IsStanding			; If not, branch
0000492A 3669 0000                  		movea.w	_objInteract(a1),a3		; Get the object the player is standing on
0000492E 08AB 0003 0028             		bclr	#cStandBit,_objStatus(a3)		; Clear its standing on object bit
00004934 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004938                            
00004938                            .IsStanding:
00004938 3348 0000                  		move.w	a0,_objInteract(a1)		; Set it as the object the player is standing on
0000493C 4229 0000                  		clr.b	_objAngle(a1)			; Clear the player's angle
00004940 4269 001E                  		clr.w	_objYVel(a1)			; Clear the player's Y velocity
00004944 3369 001C 0000             		move.w	_objXVel(a1),_objGVel(a1)		; Set the player's X velocity as its ground velocity
0000494A 08E9 0003 0028             		bset	#cStandBit,_objStatus(a1)		; Set the player's standing on object bit
00004950 08E8 0003 0028             		bset	#cStandBit,_objStatus(a0)		; Set the player standing on this object bir
00004956 08A9 0001 0028             		bclr	#1,_objStatus(a1)			; Clear the player's in midair bit
0000495C 6700                       		beq.s	PlatformObject_End		; If it was already clear, branch
0000495E 2F08                       		move.l	a0,-(sp)			; Store the current object's address
00004960 2049                       		movea.l	a1,a0				; Replace it with the player's address
00004962 6100 E8A6                  		bsr.w	PlayerResetOnFloor		; Reset the player's variables to make it touch the floor
00004966 205F                       		movea.l	(sp)+,a0			; Restore the current object's address
00004968                            
00004968                            PlatformObject_End:
00004968 4E75                       		rts
0000496A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000496A                            ; Set an object as a solid slope and check for collision
0000496A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000496A                            ; PARAMETERS:
0000496A                            ;	d1.w	- Object width
0000496A                            ;	d3.w	- Object height
0000496A                            ;	d4.w	- Object x-axis position
0000496A                            ;	a0.l	- Object space pointer
0000496A                            ;	a2.l	- Slope height data pointer
0000496A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000496A                            ; RETURNS:
0000496A                            ;	See object collision return values above (side and bottom collision doesn't apply here)
0000496A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000496A                            SlopedPlatform:
0000496A 7C00                       		moveq	#0,d6				; Clear collision flag register
0000496C 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get the player RAM
00004970 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the object?
00004976 6700 0000                  		beq.w	SlopedPlarform_ChkCol		; If not branch
0000497A 3401                       		move.w	d1,d2				; Copy the object's width
0000497C D442                       		add.w	d2,d2				; Double it
0000497E 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004984 6600                       		bne.s	.NotOnTop			; If so, branch
00004986 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
0000498A 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
0000498E D041                       		add.w	d1,d0				; Add width
00004990 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
00004992 B042                       		cmp.w	d2,d0				; Compare with the width
00004994 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
00004996                            
00004996                            .NotOnTop:
00004996 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the player's standing on object bit
0000499C 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
000049A2 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
000049A8 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
000049AC 7800                       		moveq	#0,d4				; Set the collision status to 0
000049AE 4E75                       		rts
000049B0                            
000049B0                            .OnTop:
000049B0 3404                       		move.w	d4,d2				; Copy X position
000049B2 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Make the player stand on top of this object
000049B6 7800                       		moveq	#0,d4				; Set the collision status to 0
000049B8 4E75                       		rts
000049BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049BA                            SlopedPlarform_ChkCol:
000049BA 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
000049BE 6B00 FFA8                  		bmi.w	PlatformObject_End		; If so, branch
000049C2 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
000049C6 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
000049CA D041                       		add.w	d1,d0				; Add width
000049CC 6B00 FF9A                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000049D0 D241                       		add.w	d1,d1				; Double width
000049D2 B041                       		cmp.w	d1,d0				; Compare with width
000049D4 6400 FF92                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000049D8 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X flipped?
000049DE 6700                       		beq.s	.NoXFlip			; If not, skip
000049E0 4640                       		not.w	d0				; Logical notation
000049E2 D041                       		add.w	d1,d0				; Add width
000049E4                            
000049E4                            .NoXFlip:
000049E4 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
000049E6 1632 0000                  		move.b	(a2,d0.w),d3			; Get height of the next segment
000049EA 4883                       		ext.w	d3				; Sign extend to word
000049EC 3028 0018                  		move.w	_objYPos(a0),d0			; Get the current object's Y position
000049F0 9043                       		sub.w	d3,d0				; Subtract the height from the Y position
000049F2 6000 FEF0                  		bra.w	PlatformObject_ChkYRange	; Check the Y range
000049F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F6                            ; Move the player along a platform/solid object
000049F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F6                            ; PARAMETERS:
000049F6                            ;	d2.w	- X position of the platform
000049F6                            ;	d3.w	- Height of the platform
000049F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F6                            ; RETURNS:
000049F6                            ;	Nothing
000049F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049F6                            PlayerMoveOnPtfm:
000049F6 3028 0018                  		move.w	_objYPos(a0),d0			; Get the current object's Y position
000049FA 9043                       		sub.w	d3,d0				; Subtract height
000049FC 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
00004A00 6B00                       		bmi.s	.End				; If so, branch
00004A02 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is the player dead?
00004A08 6400                       		bcc.s	.End				; If so, branch
00004A0A 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
00004A0E 6600                       		bne.s	.End				; If so, branch
00004A10 7200                       		moveq	#0,d1
00004A12 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
00004A16 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004A18 3340 0018                  		move.w	d0,_objYPos(a1)			; Set as the player's Y position
00004A1C 9468 0014                  		sub.w	_objXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004A20 9569 0014                  		sub.w	d2,_objXPos(a1)			; Subtract the difference from the X position of the player
00004A24                            		;tst.b	(Shield_Flag).w			; Does the player have a shield?
00004A24                            		;beq.s	.End				; If not branch
00004A24                            		;move.w	d0,(Object_Space_7+oY).w	; Apply to the shield's Y position
00004A24                            		;sub.w	d2,(Object_Space_7+oX).w	; Apply to the shield's X position
00004A24                            
00004A24                            .End:
00004A24 4E75                       		rts
00004A26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A26                            ; Move the player along a sloped platform/solid object
00004A26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A26                            ; PARAMETERS:
00004A26                            ;	d3.w	- Height of the platform
00004A26                            ;	d4.w	- X position of the platform
00004A26                            ;	a2.l	- Slope height data pointer
00004A26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A26                            ; RETURNS:
00004A26                            ;	Nothing
00004A26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A26                            PlayerMoveOnSlope:
00004A26 0829 0003 0028             		btst	#cStandBit,_objStatus(a1)		; Is the player standing on the object?
00004A2C 6700                       		beq.s	.End				; If not, branch
00004A2E 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004A32 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004A36 D041                       		add.w	d1,d0				; Add width
00004A38 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004A3A 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X flipped?
00004A40 6700                       		beq.s	.NoXFlip			; If not, branch
00004A42 4640                       		not.w	d0				; Logical notation on d0
00004A44 D041                       		add.w	d1,d0				; Add width
00004A46                            
00004A46                            .NoXFlip:
00004A46 1232 0000                  		move.b	(a2,d0.w),d1			; Get Y offset
00004A4A 4881                       		ext.w	d1				; Sign extend to word
00004A4C 3028 0018                  		move.w	_objYPos(a0),d0			; Get current object's Y position
00004A50 9041                       		sub.w	d1,d0				; Subtract the Y offset
00004A52 7200                       		moveq	#0,d1
00004A54 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
00004A58 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004A5A 3340 0018                  		move.w	d0,_objYPos(a1)			; Set as the player's Y position
00004A5E 9468 0014                  		sub.w	_objXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004A62 9569 0014                  		sub.w	d2,_objXPos(a1)			; Subtract the difference from the X position of the player
00004A66                            
00004A66                            .End:
00004A66 4E75                       		rts
00004A68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A68                            ; Do object collision for the player object
00004A68                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A68                            PlayerDoObjCollision:
00004A68 4EB8 42B6                  		jsr	PlayeringCollectlision		; Do ring collision
00004A6C                            		
00004A6C 3428 0014                  		move.w	_objXPos(a0),d2			; Get X position
00004A70 3628 0018                  		move.w	_objYPos(a0),d3			; Get Y position
00004A74 5142                       		subq.w	#8,d2				; Get left sensor X
00004A76 7A00                       		moveq	#0,d5
00004A78 1A28 002D                  		move.b	_objColH(a0),d5			; Get collision height
00004A7C 5705                       		subq.b	#3,d5				; Subtract 3
00004A7E 9645                       		sub.w	d5,d3				; Get left sensor Y
00004A80 383C 0010                  		move.w	#$10,d4				; Get right sensor delta X
00004A84 DA45                       		add.w	d5,d5				; Get right sensor delta Y
00004A86                            
00004A86 49F8 E7D6                  		lea	collideList.w,a4			; Get collision response list
00004A8A 3C1C                       		move.w	(a4)+,d6			; Get count
00004A8C 6700                       		beq.s	.End				; If there are no objects to test, branch
00004A8E                            
00004A8E                            .ObjLoop:
00004A8E 325C                       		movea.w	(a4)+,a1			; Get object
00004A90 1029 002A                  		move.b	_objColType(a1),d0			; Does touching it do anything?
00004A94 6600                       		bne.s	.ChkPosition			; If so, branch
00004A96                            
00004A96                            .NextObj:
00004A96 5546                       		subq.w	#2,d6				; Decrement count
00004A98 66F4                       		bne.s	.ObjLoop			; Branch if there are still objects to check
00004A9A 7000                       		moveq	#0,d0				; Reset d0
00004A9C                            
00004A9C                            .End:
00004A9C 4278 E7D6                  		clr.w	collideList.w			; Clear the collision response list count
00004AA0 4E75                       		rts
00004AA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA2                            .ChkPosition:
00004AA2 7200                       		moveq	#0,d1
00004AA4 1229 002C                  		move.b	_objColW(a1),d1			; Get object width
00004AA8 3029 0014                  		move.w	_objXPos(a1),d0			; Get object X position
00004AAC 9041                       		sub.w	d1,d0				; Get left side of object
00004AAE 9042                       		sub.w	d2,d0				; Is the player right of the left side of the object?
00004AB0 6400                       		bcc.s	.ChkRightSide			; If so, branch
00004AB2 D241                       		add.w	d1,d1				; Get right side delta X
00004AB4 D041                       		add.w	d1,d0				; Is the player right of the right side of the object?
00004AB6 6500                       		bcs.s	.ChkHeight			; If not, branch
00004AB8 60DC                       		bra.s	.NextObj			; The player isn't touching the object horizontally; check the next object
00004ABA                            
00004ABA                            .ChkRightSide:
00004ABA B044                       		cmp.w	d4,d0				; Is the player inside the object horizontally?
00004ABC 62D8                       		bhi.s	.NextObj			; If not, branch
00004ABE                            
00004ABE                            .ChkHeight:
00004ABE 7200                       		moveq	#0,d1
00004AC0 1229 002D                  		move.b	_objColH(a1),d1			; Get object height
00004AC4 3029 0018                  		move.w	_objYPos(a1),d0			; Get object Y position
00004AC8 9041                       		sub.w	d1,d0				; Get top of object
00004ACA 9043                       		sub.w	d3,d0				; Is the player below the top of the object?
00004ACC 6400                       		bcc.s	.ChkBottom			; If so, branch
00004ACE D241                       		add.w	d1,d1				; Get bottom delta Y
00004AD0 D240                       		add.w	d0,d1				; Is the player below the bottom of the object?
00004AD2 6500                       		bcs.s	.ChkType			; If not, branch
00004AD4 60C0                       		bra.s	.NextObj			; The player isn't touching the object vertically; check the next object
00004AD6                            
00004AD6                            .ChkBottom:
00004AD6 B045                       		cmp.w	d5,d0				; Is the player inside the object vertically?
00004AD8 62BC                       		bhi.s	.NextObj			; If not, branch
00004ADA                            
00004ADA                            .ChkType:
00004ADA 7000                       		moveq	#0,d0
00004ADC 1029 002A                  		move.b	_objColType(a1),d0			; Get collision type
00004AE0 4EFB 0000                  		jmp	.CollisionTypes-2(pc,d0.w)	; Go to the appropriate routine
00004AE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AE4                            .CollisionTypes:
00004AE4 6000                       		bra.s	.Enemy				; Enemy
00004AE6 6000                       		bra.s	.Indestructable			; Indestructable
00004AE8                            
00004AE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AE8                            .Enemy:
00004AE8 0C28 0002 0020             		cmpi.b	#2,_objAnim(a0)			; Are we rolling?
00004AEE 6600 0000                  		bne.w	.ChkHurt			; If not, branch
00004AF2                            
00004AF2                            .ChkBoss:
00004AF2 4A29 002B                  		tst.b	_objHitCnt(a1)			; Do we have a hit count?
00004AF6 6700                       		beq.s	.Kill				; If not, branch
00004AF8 4468 001C                  		neg.w	_objXVel(a0)			; Bounce backwards
00004AFC 4468 001E                  		neg.w	_objYVel(a0)			; ''
00004B00 4229 002A                  		clr.b	_objColType(a1)			; Indicate that we have hit the boss
00004B04 5329 002B                  		subq.b	#1,_objHitCnt(a1)			; Decrement hit count
00004B08 6600                       		bne.s	.BossEnd			; If it hasn't reached 0, branch
00004B0A 08E9 0007 0028             		bset	#7,_objStatus(a1)			; Set the "killed" flag
00004B10                            
00004B10                            .BossEnd:
00004B10 4E75                       		rts
00004B12                            
00004B12                            .Kill:
00004B12 08E9 0007 0028             		bset	#7,_objStatus(a1)			; Set the "killed" flag
00004B18 22BC 0000 0000             		move.l	#ObjExplosion,_objAddress(a1)		; Change into an explosion
00004B1E 4229 002A                  		clr.b	_objColType(a1)			; Indicate that we have hit the boss
00004B22 4229 0025                  		clr.b	_objRoutine(a1)			; Reset the routine ID
00004B26 4A68 001E                  		tst.w	_objYVel(a0)			; Are we going up?
00004B2A 6B00                       		bmi.s	.MoveDown			; If so, branch
00004B2C 3028 0018                  		move.w	_objYPos(a0),d0			; Are we below the object?
00004B30 B069 0018                  		cmp.w	_objYPos(a1),d0			; ''
00004B34 6400                       		bhs.s	.MoveUp				; If so, branch
00004B36 4468 001E                  		neg.w	_objYVel(a0)			; Bounce up
00004B3A 4E75                       		rts
00004B3C                            
00004B3C                            .MoveDown:
00004B3C 0668 0100 001E             		addi.w	#$100,_objYVel(a0)			; Move down
00004B42 4E75                       		rts
00004B44                            
00004B44                            .MoveUp:
00004B44 0468 0100 001E             		subi.w	#$100,_objYVel(a0)			; Move up
00004B4A 4E75                       		rts
00004B4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B4C                            .Indestructable: 
00004B4C                            ;---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B4C                            .ChkHurt:
00004B4C 4A68 0000                  		tst.w	_objInvulTime(a0)			; Are we invulnerable?
00004B50 6600                       		bne.s	.NoHurt				; If so, branch
00004B52 2449                       		movea.l	a1,a2				; Copy harmful object's pointer
00004B54 4EF9 0000 0000             		jmp	ObjPlayer_GetHurt		; Get hurts
00004B5A                            
00004B5A                            .NoHurt:
00004B5A 4E75                       		rts
00004B5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B5C                            ; Add a new entry to the collision response list
00004B5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B5C                            AddToColResponse:
00004B5C 43F8 E7D6                  		lea	collideList.w,a1			; Get collision response list
00004B60 0C51 007E                  		cmpi.w	#$7E,(a1)			; Is it full?
00004B64 6400                       		bhs.s	.End				; If so, branch
00004B66 5451                       		addq.w	#2,(a1)				; Add a new entry
00004B68 D2D1                       		adda.w	(a1),a1				; Get entry pointer
00004B6A 3288                       		move.w	a0,(a1)				; Store entry
00004B6C                            
00004B6C                            .End:
00004B6C 4E75                       		rts
00004B6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6E                            ; Save some info in a level (mainly for checkpoints)
00004B6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6E                            ; PARAMETERS:
00004B6E                            ;	a0.l	- Object space pointer
00004B6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6E                            ; RETURNS:
00004B6E                            ;	Nothing
00004B6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B6E                            Level_SaveInfo:
00004B6E 31E8 0014 C7B2             		move.w	_objXPos(a0),chkSavedXPos.w		; Save X position
00004B74 31E8 0018 C7B4             		move.w	_objYPos(a0),chkSavedYPos.w		; Save Y position
00004B7A 4E75                       		rts
00004B7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B7C                            ; Load some info in a level (mainly for checkpoints)
00004B7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B7C                            ; PARAMETERS:
00004B7C                            ;	a0.l	- Object space pointer
00004B7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B7C                            ; RETURNS:
00004B7C                            ;	Nothing
00004B7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B7C                            Level_LoadSavedInfo:
00004B7C 3178 C7B2 0014             		move.w	chkSavedXPos.w,_objXPos(a0)		; Load X position
00004B82 3178 C7B4 0018             		move.w	chkSavedYPos.w,_objYPos(a0)		; Load Y position
00004B88 4E75                       		rts
00004B8A                            ; =========================================================================================================================================================
00004B8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B8A                            ; Music IDs
00004B8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B8A                            Level_MusicIDs:
00004B8A 0B0B                       		dc.b	mWWZ, mWWZ
00004B8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B8C                            ; Level water heights (-1 for no water)
00004B8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B8C                            Level_WatelevelIDs:
00004B8C                            		;dc.w	$490, -1			; Wacky Workbench
00004B8C FFFF FFFF                  		dc.w	-1, -1
00004B90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B90                            ; Level data pointers
00004B90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B90                            ; FORMAT:
00004B90                            ;	dc.l	CHUNKS, BLOCKS, TILES, PALETTE
00004B90                            ;	dc.l	FG LAYOUT, BG LAYOUT 
00004B90                            ;	dc.l	OBJECTS, RINGS, COLLISION
00004B90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B90                            Level_DataPointers:
00004B90 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks, WWZ_Tiles, WWZ_Pal
00004BA0 0000 0000 0000 0000        		dc.l	WWZ_FGLayout, WWZ_BGLayout
00004BA8 0000 0000 0000 0000 0000+  		dc.l	WWZ_Objects, WWZ_Rings, WWZ_Collision
00004BB4                            
00004BB4 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks, WWZ_Tiles, WWZ_Pal
00004BC4 0000 0000 0000 0000        		dc.l	WWZ_FGLayout, WWZ_BGLayout
00004BCC 0000 0000 0000 0000 0000+  		dc.l	WWZ_Objects, WWZ_Rings, WWZ_Collision
00004BD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD8                            ; Size and start position data
00004BD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD8                            Level_SizeStartPos:
00004BD8 3000 0580                  		dc.w	$3000, $580
00004BDC                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004BE0 3000 0580                  		dc.w	$3000, $580
00004BE4                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004BE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BE8                            ; Dynamic events routines
00004BE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BE8                            Level_DynEvenRouts:
00004BE8 0000 0000                  		dc.l	DynEv_WWZ			; Wacky Workbench
00004BEC 0000 0000                  		dc.l	DynEv_WWZ
00004BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BF0                            ; Wacky Workbench dynamic events routine
00004BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BF0                            DynEv_WWZ:
00004BF0 31FC 0000 E8CA             		move.w	#0,	maxCamXPos
00004BF6 31FC 0000 E8CC             		move.w	#0,	maxCamYPos
00004BFC 7000                       		moveq	#0,d0
00004BFE 1038 E908                  		move.b	dynEventRout.w,d0
00004C02 303B 0000                  		move.w	.Index(pc,d0.w),d0
00004C06 4EFB 0000                  		jmp	.Index(pc,d0.w)
00004C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C0A                            .Index:
00004C0A 0000                       		dc.w	.WaitBoss-.Index
00004C0C 0000                       		dc.w	.Done-.Index
00004C0E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C0E                            .WaitBoss:
00004C0E                            
00004C0E                            
00004C0E                            .Done:
00004C0E 4E75                       		rts
00004C10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C10                            ; Palette cycle routines
00004C10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C10                            Level_PalCycRouts:
00004C10 0000 0000                  		dc.l	PalCycle_WWZ			; Wacky Workbench
00004C14 0000 0000                  		dc.l	PalCycle_WWZ
00004C18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C18                            ; Wacky Workbench palette cycle routine
00004C18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C18                            PalCycle_WWZ:
00004C18 4A38 E909                  		tst.b	rFlooactIDive.w		; Is the floor active?
00004C1C 6600                       		bne.s	.Flash				; If so, branch
00004C1E                            
00004C1E 5378 E90A                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004C22 6A00                       		bpl.s	.ResetPal			; If it hasn't run out, branch
00004C24 50F8 E909                  		st	rFlooactIDive.w		; Set the floor active flag
00004C28 31FC 00B4 E90A             		move.w	#180,rFloorTimer.w		; Set the floor timer
00004C2E                            
00004C2E                            .ResetPal:
00004C2E 4278 C7D0                  		clr.w	palCycTimer.w		; Reset the palette cycle
00004C32 31FC 0C28 9930             		move.w	#$C28,(paletteBuff+$62).w		; Set the floor color to be deactivated
00004C38 31FC 0E48 98B0             		move.w	#$E48,(paletteBuffAlt+$62).w	; ''
00004C3E 4E75                       		rts
00004C40                            
00004C40                            .Flash:
00004C40 5378 E90A                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004C44 6A00                       		bpl.s	.UpdatePal			; If it hasn't run out, branch
00004C46 4238 E909                  		clr.b	rFlooactIDive.w		; Clear the floor active flag
00004C4A 31FC 001E E90A             		move.w	#30,rFloorTimer.w		; Set the floor timer
00004C50                            
00004C50                            .UpdatePal:
00004C50 5338 C7D0                  		subq.b	#1,palCycTimer.w		; Decrement the palette cycle timer
00004C54 6A00                       		bpl.s	.End				; If it hasn't run out, branch
00004C56 11FC 0001 C7D0             		move.b	#1,palCycTimer.w		; Reset the palette cycle timer
00004C5C                            
00004C5C 7000                       		moveq	#0,d0
00004C5E 1038 C7D1                  		move.b	palCycIndex.w,d0		; Get the palette cycle index
00004C62 D040                       		add.w	d0,d0				; Turn into offset
00004C64                            							; Set the floor color
00004C64 31FB 0000 9930             		move.w	PalCyc_WWZFloor(pc,d0.w),(paletteBuff+$62).w
00004C6A 31FB 0000 98B0             		move.w	PalCyc_WWZFloorUW(pc,d0.w),(paletteBuffAlt+$62).w
00004C70                            
00004C70 5238 C7D1                  		addq.b	#1,palCycIndex.w		; Increment the palette cycle index
00004C74 0C38 0005 C7D1             		cmpi.b	#5,palCycIndex.w		; Has it reached the end of the cycle?
00004C7A 6500                       		bcs.s	.End				; If not, branch
00004C7C 4238 C7D1                  		clr.b	palCycIndex.w		; Reset the palette cycle index
00004C80                            
00004C80                            .End:
00004C80 4E75                       		rts
00004C82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C82                            PalCyc_WWZFloor:
00004C82 0C28 0000 00EE 0000 0EEE   		dc.w	$C28, $000, $0EE, $000, $EEE
00004C8C                            PalCyc_WWZFloorUW:
00004C8C 0E48 0220 02EE 0220 0EEE   		dc.w	$E48, $220, $2EE, $220, $EEE
00004C96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C96                            ; Animated art routines
00004C96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C96                            Level_AniArtRouts:
00004C96 0000 0000                  		dc.l	AniArt_WWZ			; Wacky Workbench
00004C9A 0000 0000                  		dc.l	AniArt_WWZ
00004C9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C9E                            ; Wacky Workbench animated art routine
00004C9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C9E                            AniArt_WWZ:
00004C9E 45FA 0000                  		lea	.AniData(pc),a2			; Tutorial animated art data
00004CA2 6000 F86C                  		bra.w	AniArt_D_objAnimmate		; Handle animations
00004CA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CA6                            .AniData:
00004CA6 0002                       		dc.w	2
00004CA8                            
00004CA8                            		lvlAniDat 3, ArtUnc_Electricity, $162, 4, 8
00004CA8 0000 0000                M 	dc.l	(3&$ff)<<24|artunc_electricity
00004CAC 2C40                     M 	dc.w	(($162&$7ff)<<5)
00004CAE 0408                     M 	dc.b	4,8
00004CB0 0008 1018                  		dc.b	0, 8, $10, $18
00004CB4                            
00004CB4                            		lvlAniDat 1, ArtUnc_ElectricOrbs, $15E, $E, 4
00004CB4 0000 0000                M 	dc.l	(1&$ff)<<24|artunc_electricorbs
00004CB8 2BC0                     M 	dc.w	(($15e&$7ff)<<5)
00004CBA 0E04                     M 	dc.b	$e,4
00004CBC 0004 0400 0404 0804 0408+  		dc.b	0, 4, 4, 0, 4, 4, 8, 4, 4, 8, $C, 4, 4, $C
00004CCA                            
00004CCA                            		lvlAniDat 4, ArtUnc_Sirens, $A8, 8, 4
00004CCA 0000 0000                M 	dc.l	(4&$ff)<<24|artunc_sirens
00004CCE 1500                     M 	dc.w	(($a8&$7ff)<<5)
00004CD0 0804                     M 	dc.b	8,4
00004CD2 0004 0408 0C0C 0C0C        		dc.b	0, 4, 4, 8, $C, $C, $C, $C
00004CDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CDA                            ; Level drawing initialization and update routines
00004CDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CDA                            ; PARAMETERS:
00004CDA                            ;	a1.l	- Camera RAM
00004CDA                            ;	a3.l	- Row plane buffer
00004CDA                            ;	a4.l	- Column plane buffer
00004CDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CDA                            ; RETURNS:
00004CDA                            ;	Nothing
00004CDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CDA                            Level_RenderRouts:
00004CDA 0000 2B8A                  		dc.l	General_InitFG			; Wacky Workbench
00004CDE 0000 0000                  		dc.l	WWZ_InitBG
00004CE2 0000 2BAA                  		dc.l	General_UpdateFG
00004CE6 0000 0000                  		dc.l	WWZ_UpdateBG
00004CEA 0000 2B8A                  		dc.l	General_InitFG
00004CEE 0000 0000                  		dc.l	WWZ_InitBG
00004CF2 0000 2BAA                  		dc.l	General_UpdateFG
00004CF6 0000 0000                  		dc.l	WWZ_UpdateBG
00004CFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CFA                            ; Wacky Workbench background initialization
00004CFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CFA                            WWZ_InitBG:
00004CFA 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground camera RAM
00004CFE 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004D02 E440                       		asr.w	#2,d0				; Divide by $20
00004D04 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004D08                            
00004D08 6100 E1D8                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00004D0C                            
00004D0C 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004D10 6000 E230                  		bra.w	ScrollSections			; Scroll the planes
00004D14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D14                            ; Wacky Workbench background update
00004D14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D14                            WWZ_UpdateBG:
00004D14 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground camera RAM
00004D18 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004D1C E440                       		asr.w	#2,d0				; Divide by $20
00004D1E 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004D22                            
00004D22 6100 E210                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00004D26 781F                       		moveq	#(512/16)-1,d4			; Number of blocks per column
00004D28 6100 DF92                  		bsr.w	Level_UpdatePlaney		; Update the plane
00004D2C                            
00004D2C 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004D30 6000 E210                  		bra.w	ScrollSections			; Scroll the planes
00004D34                            ; --------------------------------------------------------------------------------------------------------------------------------------
00004D34                            		scrollInit WWZ_Scroll
00004D34                          M scroll_label	equs	"wwz_scroll"
00004D34 0000                     M wwz_scroll:	dc.w	((wwz_scroll_end-wwz_scroll-2)/6)-1
00004D36                            
00004D36                            		; CEILING LIGHTS
00004D36                            		scrollSection	 48, $80
00004D36 0080 0000 0030           M 	dc.w	$80,0,48
00004D3C                            		scrollSection	 32, $60
00004D3C 0060 0000 0020           M 	dc.w	$60,0,32
00004D42                            		scrollSection	 32, $50
00004D42 0050 0000 0020           M 	dc.w	$50,0,32
00004D48                            		scrollSection	 24, $40
00004D48 0040 0000 0018           M 	dc.w	$40,0,24
00004D4E                            		scrollSection	 24, $38
00004D4E 0038 0000 0018           M 	dc.w	$38,0,24
00004D54                            		scrollSection	 16, $30
00004D54 0030 0000 0010           M 	dc.w	$30,0,16
00004D5A                            		scrollSection	 16, $2C
00004D5A 002C 0000 0010           M 	dc.w	$2c,0,16
00004D60                            		scrollSection	 16, $28
00004D60 0028 0000 0010           M 	dc.w	$28,0,16
00004D66                            		scrollSection	 16, $24
00004D66 0024 0000 0010           M 	dc.w	$24,0,16
00004D6C                            		scrollSection	 16, $20
00004D6C 0020 0000 0010           M 	dc.w	$20,0,16
00004D72                            
00004D72                            		; BACK WALL
00004D72                            		scrollSection	160, $40
00004D72 0040 0000 00A0           M 	dc.w	$40,0,160
00004D78                            
00004D78                            		; FRONT WALL
00004D78                            		scrollSection	368, $80
00004D78 0080 0000 0170           M 	dc.w	$80,0,368
00004D7E                            
00004D7E                            		scrollEnd
00004D7E                          M wwz_scroll_end:
00004D7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D7E                            ; Main level PLCs
00004D7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D7E                            PLC_LevelMain:
00004D7E 000A                       		dc.w	$A
00004D80 0000 0000                  		dc.l	ArtKosM_Chkpoint
00004D84 AFC0                       		dc.w	$AFC0
00004D86 0000 0000                  		dc.l	ArtKosM_Monitor
00004D8A B100                       		dc.w	$B100
00004D8C 0000 0000                  		dc.l	ArtKosM_SpringH
00004D90 B740                       		dc.w	$B740
00004D92 0000 0000                  		dc.l	ArtKosM_SpringV
00004D96 B940                       		dc.w	$B940
00004D98 0000 0000                  		dc.l	ArtKosM_SpringD
00004D9C BB20                       		dc.w	$BB20
00004D9E 0000 0000                  		dc.l	ArtKosM_HUD
00004DA2 D000                       		dc.w	$D000
00004DA4 0000 0000                  		dc.l	ArtKosM_WaterSurface
00004DA8 D200                       		dc.w	$D200
00004DAA 0000 0000                  		dc.l	ArtKosM_SpikesN
00004DAE D500                       		dc.w	$D500
00004DB0 0000 0000                  		dc.l	ArtKosM_SpikesS
00004DB4 D580                       		dc.w	$D580
00004DB6 0000 0000                  		dc.l	ArtKosM_RingSparkle
00004DBA D700                       		dc.w	$D700
00004DBC 0000 0000                  		dc.l	ArtKosM_Explosion
00004DC0 D800                       		dc.w	$D800
00004DC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DC2                            ; Level PLCs
00004DC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DC2                            Level_PLCs:
00004DC2 0000 0000                  		dc.l	PLC_WWZ
00004DC6 0000 0000                  		dc.l	PLC_WWZ
00004DCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DCA                            ; Wacky Workbench PLCs
00004DCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DCA                            PLC_WWZ:
00004DCA 0000                       		dc.w	0
00004DCC 0000 0000                  		dc.l	ArtKosM_Bumper
00004DD0 6B60                       		dc.w	$6B60
00004DD2                            	;	dc.l	ArtKosM_Orbinaut
00004DD2                            	;	dc.w	$71A0
00004DD2                            	;	dc.l	ArtKosM_Diamond
00004DD2                            	;	dc.w	$7580
00004DD2                            	;	dc.l	ArtKosM_CNZBarrel
00004DD2                            	;	dc.w	$7A00
00004DD2                            	;	dc.l	ArtKosM_Slicer
00004DD2                            	;	dc.w	$8000
00004DD2                            	;	dc.l	ArtKosM_ShlCrker
00004DD2                            	;	dc.w	$8400
00004DD2                            	;	dc.l	ArtKosM_Asteron
00004DD2                            	;	dc.w	$8880
00004DD2                            	;	dc.l	ArtKosM_Harpoon
00004DD2                            	;	dc.w	$8A60
00004DD2                            	;	dc.l	ArtKosM_WFZBoss
00004DD2                            	;	dc.w	$9000
00004DD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD2                            ; Object index
00004DD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD2                            Level_ObjIndex:
00004DD2 0000 0000                  		dc.l	ObjEnemy
00004DD6 0000 0000                  		dc.l	ObjSpike
00004DDA 0000 0000                  		dc.l	ObjSpring
00004DDE 0000 0000                  		dc.l	ObjCheckpoint
00004DE2 0000 0000                  		dc.l	ObjNull			;ObjSlicer
00004DE6 0000 0000                  		dc.l	ObjNull			;ObjShlCrker
00004DEA 0000 0000                  		dc.l	ObjNull			;ObjAsteron
00004DEE 0000 0000                  		dc.l	ObjNull			;ObjWFZBoss
00004DF2 0000 0000                  		dc.l	ObjWallSpring
00004DF6 0000 0000                  		dc.l	ObjNull			;ObjHarpoon
00004DFA 0000 0000                  		dc.l	ObjBallMode
00004DFE 0000 0000                  		dc.l	ObjAttack
00004E02 0000 0000                  		dc.l	ObjNull			;ObjCNZBarrel
00004E06 0000 0000                  		dc.l	ObjNull			;ObjDiamond
00004E0A 0000 0000                  		dc.l	ObjNull			;ObjOrbinaut
00004E0E                            
00004E0E                            ; =========================================================================================================================================================
00004E0E                            		include	"Opmodes/Ending/Main.asm"
00004E0E                            ; =========================================================================================================================================================
00004E0E                            ; End splash screen
00004E0E                            ; =========================================================================================================================================================
00004E0E                            
00004E0E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E0E                            Ending:
00004E0E 60FE                       		bra.s	Ending
00004E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E10                            ;		playSnd	#Mus_Stop, 1			; Stop sound
00004E10                            ;
00004E10                            ;		intsOff					; Disable interrupts
00004E10                            ;
00004E10                            ;		lea	VDP_CTRL,a5
00004E10                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00004E10                            ;		move.w	#$8134,(a5)			; $8134 - Disable display, enable V-INT, enable DMA, V28
00004E10                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00004E10                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00004E10                            ;		move.w	#$9001,(a5)			; $9001 - 64x32 cell plane area
00004E10                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
00004E10                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00004E10                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00004E10                            ;		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
00004E10                            ;		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
00004E10                            ;
00004E10                            ;		jsr	ClearScreen.w			; Clear screen
00004E10                            ;
00004E10                            ;		lea	MapEni_End(pc),a0		; Decompress background mappings
00004E10                            ;		lea	miscBuff,a1			; Decompress into RAM
00004E10                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00004E10                            ;		jsr	EniDec.w			; Decompress!
00004E10                            ;
00004E10                            ;		lea	miscBuff,a1			; Load mappings
00004E10                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
00004E10                            ;		moveq	#$27,d1				; $28x$1C tiles
00004E10                            ;		moveq	#$1B,d2				; ''
00004E10                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00004E10                            ;		jsr	LoadPlaneMap.w			; Load the map
00004E10                            ;
00004E10                            ;		lea	ArtKosM_End,a1			; Load background art
00004E10                            ;		move.w	#$20,d2				; ''
00004E10                            ;		jsr	QueueKosMData.w			; ''
00004E10                            ;
00004E10                            ;.WaitPLCs:
00004E10                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00004E10                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00004E10                            ;		jsr	VSync_Routine.w			; V-SYNC
00004E10                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00004E10                            ;		tst.b	kosMModules.w			; Are there still modules left?
00004E10                            ;		bne.s	.WaitPLCs			; If so, branch
00004E10                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00004E10                            ;		jsr	VSync_Routine.w			; V-SYNC
00004E10                            ;
00004E10                            ;		lea	SampleList+$F0,a3
00004E10                            ;		jsr	PlayDAC1
00004E10                            ;
00004E10                            ;		lea	Pal_End(pc),a0			; Load palette to target buffer
00004E10                            ;		move.w	#(Pal_End_End-Pal_End)>>1-1,d0	; ''
00004E10                            ;		jsr	LoadPalette.w			; ''
00004E10                            ;
00004E10                            ;		displayOn
00004E10                            ;
00004E10                            ;.Loop:
00004E10                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
00004E10                            ;		jsr	VSync_Routine.w			; ''
00004E10                            ;		bra.s	.Loop
00004E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E10                            ; Art
00004E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E10                            ;ArtKosM_End:
00004E10                            ;		incbin	"Ending/Data/Art - Background.kosm.bin"
00004E10                            ;		even
00004E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E10                            ; Plane mappings
00004E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E10                            ;MapEni_End:
00004E10                            ;		incbin	"Ending/Data/Map - Background.eni.bin"
00004E10                            ;		even
00004E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E10                            ; Palette
00004E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E10                            ;Pal_End:
00004E10                            ;		incbin	"Ending/Data/Palette.pal.bin"
00004E10                            ;Pal_End_End:
00004E10                            ;		even
00004E10                            ; =========================================================================================================================================================
00004E10                            
00004E10                            ; =========================================================================================================================================================
00004E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E10                            ; Object Code
00004E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E10                            ObjNull:
00004E10 4EF8 1A4C                  		jmp	DeleteObject
00004E14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E14                            		include	"Objects/Player/Code.asm"		; Player object
00004E14                            ; =========================================================================================================================================================
00004E14                            ; Sonic object
00004E14                            ; =========================================================================================================================================================
00004E14 =00000300                  TOP_SPD		EQU	$300				; Top speed
00004E14 =0000000C                  ACC_SPD		EQU	$C				; Acceleration
00004E14 =00000080                  DEC_SPD		EQU	$80				; Deceleration
00004E14 =00000180                  JUMP_HEIGHT	EQU	$180				; Jump height
00004E14 =00000180                  MIN_JMP_HEIGHT	EQU	$180				; Minimum jump height
00004E14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E14                            		rsset	_objLvlSSTs
00004E14 =00000030                  _objInitColH	rs.b	1				; Initial collision height
00004E14 =00000031                  _objInitColW	rs.b	1				; Initial collision width
00004E14 =00000032                  _objTopSolid	rs.b	1				; Top solid bit
00004E14 =00000033                  _objLRBSolid	rs.b	1				; LRB solid bit
00004E14 =00000034                  _objTopSpd	rs.w	1				; Top speed
00004E14 =00000036                  _objAccel	rs.w	1				; Acceleration
00004E14 =00000038                  _objDecel	rs.w	1				; Deceleration
00004E14 =0000003A                  _objFlipDir	rs.w	0				; Flip direction
00004E14 =0000003A                  _objGVel	rs.w	1				; Ground velocity
00004E14 =0000003C                  _objInteract	rs.w	1				; Interacted object space pointer
00004E14 =0000003E                  _objAirTimer	rs.b	1				; Air timer
00004E14 =0000003F                  _objMoveLock	rs.b	1				; Move lock timer
00004E14 =00000040                  _objJumping	rs.b	1				; Jumping flag
00004E14 =00000041                  _objAngle	rs.b	1				; Angle
00004E14 =00000042                  _objInvulTime	rs.b	1				; Invulnerability timer
00004E14 =00000043                  _objDeathTimer	rs.b	1				; Death timer
00004E14 =00000044                  _objScrlDelay	rs.b	1				; Look up and down scroll delay counter
00004E14 =00000045                  _objDashFlag	rs.b	1				; Dash flags
00004E14 =00000046                  _objDashTimer	rs.b	1				; Dash timer
00004E14 =00000047                  _objFlipAngle	rs.b	1				; Flip angle about the X axis
00004E14 =00000048                  _objFlipTurned	rs.b	1				; Inverted flip flag
00004E14 =00000049                  _objFlipRemain	rs.b	1				; Remaining flips to do
00004E14 =0000004A                  _objFlipSpeed	rs.b	1				; Flip speed
00004E14 =0000004B                  _objBallMode	rs.b	1				; Ball mode flag
00004E14 =0000004C                  _objHangAniTime	rs.b	1				; Hang animation timer
00004E14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E14                            ObjPlayer:
00004E14 7000                       		moveq	#0,d0
00004E16 1028 0025                  		move.b	_objRoutine(a0),d0			; Get routine ID
00004E1A 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00004E1E                            	nextObject
00004E1E 3068 0004                M 	movea.w	_objnext(a0),a0
00004E22 2250                     M 	move.l	_objaddress(a0),a1
00004E24 4ED1                     M 	jmp	(a1)
00004E26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E26                            .Index:
00004E26 6000 0000                  		bra.w	ObjPlayer_Init			; Initialization(00)
00004E2A 6000 0000                  		bra.w	ObjPlayer_Main			; Main		(04)
00004E2E 6000 0000                  		bra.w	ObjPlayer_Hurt			; Hurt		(08)
00004E32 6000 0000                  		bra.w	ObjPlayer_Dead			; Dead		(0C)
00004E36 6000 0000                  		bra.w	ObjPlayer_Gone			; Gone		(10)
00004E3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E3A                            ; Initialization routine
00004E3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E3A                            ObjPlayer_Init:
00004E3A 5828 0025                  		addq.b	#4,_objRoutine(a0)			; Next routine
00004E3E                            
00004E3E 117C 0007 002C             		move.b	#7,_objColW(a0)			; Collision width
00004E44 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Collision height
00004E4A 1168 002C 0031             		move.b	_objColW(a0),_objInitColW(a0)		; Set initial collision width
00004E50 1168 002D 0030             		move.b	_objColH(a0),_objInitColH(a0)		; Set initial collision height
00004E56 217C 0000 0000 0010        		move.l	#Map_ObjPlayer,_objMapping(a0)		; Mappings
00004E5E 317C 0780 000E             		move.w	#$780,_objVRAM(a0)			; Sprite tile properties
00004E64                            	displaySprite	2,a0,a1,0			; Priority
00004E64 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00004E6A 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00004E6E 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00004E72 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00004E76 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00004E7A                          M .no_207
00004E7A 117C 0018 0017             		move.b	#$18,_objDrawW(a0)			; Sprite width
00004E80 117C 0018 001B             		move.b	#$18,_objDrawH(a0)			; Sprite height
00004E86 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00004E8C                            
00004E8C 117C 000C 0032             		move.b	#$C,_objTopSolid(a0)		; Top solid bit
00004E92 117C 000D 0033             		move.b	#$D,_objLRBSolid(a0)		; LRB solid bit
00004E98 117C 001E 003E             		move.b	#$1E,_objAirTimer(a0)		; Set air timer
00004E9E 50D0                       		st	_objPrevDPLC(a0)			; Reset saved DPLC frame
00004EA0 4228 0049                  		clr.b	_objFlipRemain(a0)			; No flips remaining
00004EA4 117C 0004 004A             		move.b	#4,_objFlipSpeed(a0)		; Flip speed
00004EAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EAA                            ; Main routine
00004EAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EAA                            ObjPlayer_Main:
00004EAA 4A38 C76A                  		tst.b	moveCheat.w
00004EAE 6700                       		beq.s	.NoPlacementEnter
00004EB0 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00004EB6 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00004EB8 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00004EBE 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00004EC4 4E75                       		rts
00004EC6                            
00004EC6                            .NoPlacementEnter:
00004EC6 0828 0002 000C             		btst	#2,_objFlags(a0)			; Are the controls locked?
00004ECC 6600                       		bne.s	.Update				; If so, branch
00004ECE 31F8 C742 E8DE             		move.w	ctrlDataP1.w,plrCtrlData.w		; Set the player's control data
00004ED4                            
00004ED4                            .Update:
00004ED4                            	;	btst	#1,_objStatus(a0)
00004ED4                            	;	bne.s	.NotOnGround
00004ED4                            
00004ED4                            ;.NotOnGround:
00004ED4 6100 0000                  		bsr.w	ObjPlayer_Water			; Handle Sonic in water
00004ED8 6100 0000                  		bsr.w	ObjPlayer_GetPhysics		; Update Sonic's physics
00004EDC 6100 0000                  		bsr.w	ObjPlayer_DoModes		; Do modes
00004EE0 6100 0000                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00004EE4 4EB8 4A68                  		jsr	PlayerDoObjCollision		; Do object collision
00004EE8                            
00004EE8 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00004EEC 6100 0000                  		bsr.w	ObjPlayer_Display		; Display sprite
00004EF0 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00004EF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EF4                            ; Handle the extended camera
00004EF4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EF4                            ObjPlayer_ExtendedCam:
00004EF4 3238 E8D6                  		move.w	panCamXPos.w,d1		; Get camera X center
00004EF8 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
00004EFC 6A00                       		bpl.s	.PosGVel			; Get absolute value
00004EFE 4440                       		neg.w	d0				; ''
00004F00                            
00004F00                            .PosGVel:
00004F00 0C40 0600                  		cmpi.w	#$600,d0			; Is Sonic going at 6 pixels/frame?
00004F04 6500                       		bcs.s	.ResetXShift			; If not, branch
00004F06 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving right?
00004F0A 6A00                       		bpl.s	.MoveRight			; If so, branch
00004F0C 5441                       		addq.w	#2,d1				; Move right
00004F0E 0C41 00E0                  		cmpi.w	#$E0,d1				; Cap it
00004F12 6500                       		bcs.s	.SetShift			; ''
00004F14 323C 00E0                  		move.w	#$E0,d1				; ''
00004F18 6000                       		bra.s	.SetShift			; Continue
00004F1A                            
00004F1A                            .MoveRight:
00004F1A 5541                       		subq.w	#2,d1				; Move left
00004F1C 0C41 0060                  		cmpi.w	#$60,d1				; Cap it
00004F20 6400                       		bcc.s	.SetShift			; ''
00004F22 323C 0060                  		move.w	#$60,d1				; ''
00004F26 6000                       		bra.s	.SetShift			; Continue
00004F28                            
00004F28                            .ResetXShift:
00004F28 0C41 00A0                  		cmpi.w	#$A0,d1				; Are we already back at the center?
00004F2C 6700                       		beq.s	.SetShift			; If so, branch
00004F2E 6400                       		bcc.s	.ReduceShift			; If we have to go back left, branch
00004F30 5441                       		addq.w	#2,d1				; Move back right
00004F32 6000                       		bra.s	.SetShift			; Continue
00004F34                            
00004F34                            .ReduceShift:
00004F34 5541                       		subq.w	#2,d1				; Move back left
00004F36                            
00004F36                            .SetShift:
00004F36 31C1 E8D6                  		move.w	d1,panCamXPos.w		; Set camera X center
00004F3A 4E75                       		rts
00004F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F3C                            ; Update Sonic's physics
00004F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F3C                            ObjPlayer_GetPhysics:
00004F3C 7000                       		moveq	#0,d0
00004F3E 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00004F44 6700                       		beq.s	.GetOffset			; If not, branch
00004F46 7008                       		moveq	#8,d0				; Set the underwater bit
00004F48                            
00004F48                            .GetOffset:
00004F48 43FB 0000                  		lea	ObjPlayer_Physics(pc,d0.w),a1	; Get pointer to correct physics values
00004F4C 2159 0034                  		move.l	(a1)+,_objTopSpd(a0)		; Set top speed and acceleration
00004F50 3151 0038                  		move.w	(a1),_objDecel(a0)			; Set deceleration
00004F54 4E75                       		rts
00004F56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F56                            ; Physics values
00004F56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F56                            ; FORMAT:
00004F56                            ;	dc.w	TOP SPEED, ACCELERATION, DECELERATION, 0
00004F56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F56                            ObjPlayer_Physics:
00004F56 0300 000C 0080 0000        		dc.w	TOP_SPD,     ACC_SPD,     DEC_SPD,     0; Normal
00004F5E 0180 0006 0040 0000        		dc.w	TOP_SPD/2,   ACC_SPD/2,   DEC_SPD/2,   0; Underwater
00004F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F66                            ; Handle Sonic in the water
00004F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F66                            ObjPlayer_Water:
00004F66 4A38 E8FE                  	tst.b	lvlHasWater.w			; Is there water in the level?
00004F6A 6600                       	bne.s	.HandleWater			; If so, branch
00004F6C                            
00004F6C                            .End:
00004F6C 4E75                       	rts
00004F6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F6E                            .HandleWater:
00004F6E 3038 E900                  		move.w	waterYPos.w,d0		; Get water height
00004F72 B068 0018                  		cmp.w	_objYPos(a0),d0			; Is Lover in the water?
00004F76 6C00                       		bge.s	.NotInWater			; If not, branch
00004F78                            
00004F78 08E8 0006 0028             		bset	#6,_objStatus(a0)			; Set the "in water" flag
00004F7E 66EC                       		bne.s	.End				; If Lover is already in the water, branch
00004F80                            
00004F80 E0E8 001C                  		asr.w	_objXVel(a0)			; Make Lover move slower
00004F84 E0E8 001E                  		asr.w	_objYVel(a0)
00004F88 E0E8 001E                  		asr.w	_objYVel(a0)
00004F8C 67DE                       		beq.s	.End				; If a splash doesn't need to be created, branch
00004F8E                            
00004F8E                            		playSnd	#sSplash, 2			; Play splash sound
00004F8E 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00004F94 4E75                       		rts
00004F96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F96                            .NotInWater:
00004F96 08A8 0006 0028             		bclr	#6,_objStatus(a0)			; Clear "in water" flag
00004F9C 67CE                       		beq.s	.End				; If Lover was already out of the water, branch
00004F9E                            
00004F9E 0C28 0010 0025             		cmpi.b	#$10,_objRoutine(a0)			; Is Lover falling back from getting hurt?
00004FA4 6700                       		beq.s	.ChkSplash			; If so, branch
00004FA6 E1E8 001E                  		asl	_objYVel(a0)			; Make Lover move faster vertically
00004FAA                            
00004FAA                            .ChkSplash:
00004FAA 4A68 001E                  		tst.w	_objYVel(a0)			; Does a splash need to be created?
00004FAE 67BC                       		beq.s	.End				; If not, branch
00004FB0                            
00004FB0 0C68 F000 001E             		cmpi.w	#-$1000,_objYVel(a0)		; Is Lover moving more than -$10 pixels per frame?
00004FB6 6E00                       		bgt.s	.PlaySplashSnd			; If not, branch
00004FB8 317C F000 001E             		move.w	#-$1000,_objYVel(a0)		; Cap the speed
00004FBE                            
00004FBE                            .PlaySplashSnd:
00004FBE                            		playSnd	#sSplash, 2			; Play splash sound
00004FBE 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00004FC4 4E75                       		rts
00004FC6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FC6                            ; Do Sonic's modes
00004FC6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FC6                            ObjPlayer_DoModes:
00004FC6 0828 0000 000C             		btst	#0,_objFlags(a0)			; Is running Sonic's mode disabled?
00004FCC 6600                       		bne.s	.NoMode				; If so, branch
00004FCE                            
00004FCE 7000                       		moveq	#0,d0
00004FD0 1028 0028                  		move.b	_objStatus(a0),d0			; Get status
00004FD4 0240 0006                  		andi.w	#6,d0				; Only get mode bits
00004FD8 D040                       		add.w	d0,d0
00004FDA 4EBB 0000                  		jsr	ObjPlayer_Modes(pc,d0.w)	; Jump to the right routine
00004FDE                            
00004FDE 6100 FF14                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
00004FE2 6100 0000                  		bsr.w	ObjPlayer_ChkBounce		; Check for bouncy floor collision
00004FE6 6100 0000                  		bsr.w	ObjPlayer_ChkHang		; Check for hanging
00004FEA 6000 0000                  		bra.w	ObjPlayer_ChkElectric		; Check for electricity
00004FEE                            
00004FEE                            .NoMode:
00004FEE 4E75                       		rts
00004FF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FF0                            ; Sonic's modes
00004FF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FF0                            ObjPlayer_Modes:
00004FF0 6000 0000                  		bra.w	ObjPlayer_MdGround		; Ground
00004FF4 6000 0000                  		bra.w	ObjPlayer_MdAir			; Air
00004FF8 6000 0000                  		bra.w	ObjPlayer_MdRoll		; Roll
00004FFC 6000 0000                  		bra.w	ObjPlayer_MdJump		; Jumping
00005000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005000                            ; Ground mode
00005000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005000                            ObjPlayer_MdGround:
00005000                            ;		bsr.w	ObjPlayer_Peelout		; Handle the peelout
00005000                            ;		bsr.w	ObjPlayer_Spindash		; Handle the spindash
00005000 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00005004 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
00005008                            ;		bsr.w	ObjPlayer_ChkRoll		; Check for rolling
00005008 6100 0000                  		bsr.w	ObjPlayer_MoveGround		; Do movement on the ground
0000500C 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00005010 4EB8 369A                  		jsr	PlayerAnglePos			; Update position and angle along the ground
00005014                            
00005014 6100 0000                  		bsr.w	ObjPlayer_SlopePush		; Affect Sonic's speed on a slope
00005018 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
0000501C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000501C                            ; Misc. updates
0000501C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000501C                            ObjPlayer_MiscUpdates:
0000501C 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer finished?
00005020 6700                       		beq.s	.NoMoveLock			; If so, branch
00005022 5328 003F                  		subq.b	#1,_objMoveLock(a0)		; Decrement the timer
00005026                            
00005026                            .NoMoveLock:
00005026 4EB8 33B2                  		jsr	sub_F846
0000502A 4A41                       		tst.w	d1
0000502C 6B00 0000                  		bmi.w	ObjPlayer_GetKilled
00005030 4EB8 3642                  		jsr	PlayerChkLeftWallDist		; Check for left wall collision
00005034 4A41                       		tst.w	d1				; Has Sonic entered the wall?
00005036 6A00                       		bpl.s	.ChkRight			; If not, branch
00005038 9368 0014                  		sub.w	d1,_objXPos(a0)			; Fix Sonic's X position
0000503C                            
0000503C                            .ChkRight:
0000503C 4EB8 34C6                  		jsr	PlayerChkRightWallDist		; Check for right wall collision
00005040 4A41                       		tst.w	d1				; Has Sonic entered the wall?
00005042 6A00                       		bpl.s	.End				; If not, branch
00005044 D368 0014                  		add.w	d1,_objXPos(a0)			; Fix Sonic's X position
00005048                            
00005048                            .End:
00005048 4E75                       		rts
0000504A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000504A                            ; Air and jump modes
0000504A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000504A                            ObjPlayer_MdJump:
0000504A                            ObjPlayer_MdAir:
0000504A 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
0000504E 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
00005052                            
00005052 4268 003C                  		clr.w	_objInteract(a0)			; Sonic cannot be interacting with objects while in midair
00005056 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; ''
0000505C                            
0000505C 0828 0003 000C             		btst	#3,_objFlags(a0)			; Is Sonic hanging?
00005062 6700                       		beq.s	.DoModes			; If not, branch
00005064 6100 0000                  		bsr.w	ObjPlayer_Hang			; Hang
00005068 6000                       		bra.s	.DoCol				; Continue
0000506A                            
0000506A                            .DoModes:
0000506A 6100 0000                  		bsr.w	ObjPlayer_JumpHeight		; Handle jump height
0000506E 6100 0000                  		bsr.w	ObjPlayer_MoveAir		; Do movement
00005072 4EB8 1D42                  		jsr	ObjectMoveAndFall.w		; Allow movement
00005076 0C68 1000 001E             		cmpi.w	#$1000,_objYVel(a0)		; Is Sonic moving down too fasr?
0000507C 6F00                       		ble.s	.NoCap				; If not, branch
0000507E 317C 1000 001E             		move.w	#$1000,_objYVel(a0)		; Cap the downward speed
00005084                            
00005084                            .NoCap:
00005084 6100 0000                  		bsr.w	ObjPlayer_JumpAngle		; Reset Sonic's angle in mid air
00005088                            
00005088                            .DoCol:
00005088 0828 0006 0028             		btst	#6,_objStatus(a0)
0000508E 6700                       		beq.s	.NoWater
00005090 0468 0028 001E             		subi.w	#$28,_objYVel(a0)
00005096                            
00005096                            .NoWater:
00005096 4EB8 301E                  		jsr	PlayerChkCollision		; Check for level collision
0000509A 6080                       		bra.s	ObjPlayer_MiscUpdates
0000509C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000509C                            ; Roll mode
0000509C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000509C                            ObjPlayer_MdRoll:
0000509C 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
000050A0 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
000050A4                            
000050A4                            .NoJump:
000050A4 6100 0000                  		bsr.w	ObjPlayer_RollSlopePush		; Push Sonic on a slope while rolling
000050A8 6100 0000                  		bsr.w	ObjPlayer_MoveRoll		; Do movement
000050AC 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
000050B0 4EB8 369A                  		jsr	PlayerAnglePos			; Update position and angle along the ground
000050B4                            
000050B4 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
000050B8 6000 FF62                  		bra.w	ObjPlayer_MiscUpdates		; Do misc. updates
000050BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050BC                            ; Do movement on the ground
000050BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050BC                            ObjPlayer_MoveGround:
000050BC 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
000050C0 3A28 0036                  		move.w	_objAccel(a0),d5			; Get acceleration
000050C4 3828 0038                  		move.w	_objDecel(a0),d4			; Get deceleration
000050C8                            
000050C8 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer active?
000050CC 6600 0000                  		bne.w	.ResetScr			; If so, branch
000050D0                            
000050D0 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left held?
000050D6 6700                       		beq.s	.NotLeft			; If so, branch
000050D8 6100 0000                  		bsr.w	ObjPlayer_MoveLeft		; Move left
000050DC                            
000050DC                            .NotLeft:
000050DC 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right held?
000050E2 6700                       		beq.s	.NotRight			; If so, branch
000050E4 6100 0000                  		bsr.w	ObjPlayer_MoveRight		; Move right
000050E8                            
000050E8                            .NotRight:
000050E8 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000050EC 0600 0020                  		addi.b	#$20,d0				; Shift it
000050F0 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
000050F4 6600 0000                  		bne.w	.ResetScr			; If Sonic is not on the floor, branch
000050F8 4A68 003A                  		tst.w	_objGVel(a0)			; Has Sonic already been halted?
000050FC 6600 0000                  		bne.w	.ResetScr			; If not, branch
00005100                            
00005100 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
00005106 117C 0005 0020             		move.b	#5,_objAnim(a0)			; Set to ducking animation
0000510C                            
0000510C 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is Sonic standing on an object?
00005112 6700 0000                  		beq.w	.ChkBalance			; If not, branch
00005116 3268 003C                  		movea.w	_objInteract(a0),a1		; Get interacted object
0000511A 4A29 0028                  		tst.b	_objStatus(a1)			; Is Sonic standing on it?
0000511E 6B00                       		bmi.s	.ChkLookUp			; If not, branch
00005120 7200                       		moveq	#0,d1
00005122 1229 002C                  		move.b	_objColW(a1),d1			; Get width of object
00005126 3401                       		move.w	d1,d2				; Copy it
00005128 D442                       		add.w	d2,d2				; Double the copy
0000512A 5942                       		subq.w	#4,d2				; Subtract 4 from the copy
0000512C D268 0014                  		add.w	_objXPos(a0),d1			; Add Sonic's X position
00005130 9269 0014                  		sub.w	_objXPos(a1),d1			; Subtract the object's X position
00005134 0C41 0004                  		cmpi.w	#4,d1				; Is Sonic balancing on the left side of it?
00005138 6D00                       		blt.s	.BalanceOnObjLeft		; If so, branch
0000513A B242                       		cmp.w	d2,d1				; Is Sonic balacning on the right side of it?
0000513C 6C00                       		bge.s	.BalanceOnObjRight		; If so, branch
0000513E 6000                       		bra.s	.ChkLookUp			; Continue
00005140                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005140                            .ChkBalance:
00005140 4EB8 3388                  		jsr	PlayerChkFloorDist		; Get floor distance
00005144 0C41 000C                  		cmpi.w	#$C,d1				; Is Sonic balancing?
00005148 6D00                       		blt.s	.ChkLookUp			; If not, branch
0000514A 0C28 0003 002E             		cmpi.b	#3,_objNextTilt(a0)		; Is Sonic balancing on the right side?
00005150 6600                       		bne.s	.ChkLeftBalance			; If not, branch
00005152                            
00005152                            .BalanceOnObjRight:
00005152 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
00005158 6000                       		bra.s	.SetBalanceAnim			; Set the animation
0000515A                            
0000515A                            .ChkLeftBalance:
0000515A 0C28 0003 002F             		cmpi.b	#3,_objTilt(a0)			; Is Sonic balancing on the left side?
00005160 6600                       		bne.s	.ChkLookUp			; If not, branch
00005162                            
00005162                            .BalanceOnObjLeft:
00005162 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
00005168                            
00005168                            .SetBalanceAnim:
00005168 117C 0006 0020             		move.b	#6,_objAnim(a0)			; Set balancing animation
0000516E 6000                       		bra.s	.ResetScr			; Continue
00005170                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005170                            .ChkLookUp:
00005170 0838 0000 E8DE             		btst	#0,plrCtrlHold.w		; Is the up button being held?
00005176 6700                       		beq.s	.ChkDown			; If not, branch
00005178 117C 0007 0020             		move.b	#7,_objAnim(a0)			; Set to looking up animation
0000517E                            
0000517E 5228 0044                  		addq.b	#1,_objScrlDelay(a0)		; Increment scroll delay counter
00005182 0C28 0078 0044             		cmpi.b	#$78,_objScrlDelay(a0)		; Has it reached $78?
00005188 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000518A 117C 0078 0044             		move.b	#$78,_objScrlDelay(a0)		; Cap at $78
00005190 0C78 00C8 E8D8             		cmpi.w	#200,panCamYPos.w		; Has the camera finished scrolling?
00005196 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
00005198 5478 E8D8                  		addq.w	#2,panCamYPos.w		; Scroll the camera
0000519C 6000                       		bra.s	.UpdateSpdOnGround		; Continue
0000519E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000519E                            .ChkDown:
0000519E 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is the down button being held?
000051A4 6700                       		beq.s	.ResetScr			; If not, branch
000051A6 117C 0008 0020             		move.b	#8,_objAnim(a0)			; Set to ducking animation
000051AC                            
000051AC 5228 0044                  		addq.b	#1,_objScrlDelay(a0)		; Increment scroll delay counter
000051B0 0C28 0078 0044             		cmpi.b	#$78,_objScrlDelay(a0)		; Has it reached $78?
000051B6 6500                       		blo.s	.ResetScrPart2			; If not, branch
000051B8 117C 0078 0044             		move.b	#$78,_objScrlDelay(a0)		; Cap at $78
000051BE 0C78 0008 E8D8             		cmpi.w	#8,panCamYPos.w		; Has the camera finished scrolling?
000051C4 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
000051C6 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera
000051CA 6000                       		bra.s	.UpdateSpdOnGround		; Continue
000051CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000051CC                            .ResetScr:
000051CC 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
000051D0                            
000051D0                            .ResetScrPart2:
000051D0 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
000051D6 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
000051D8 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
000051DA 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
000051DE                            
000051DE                            .ScrollUp:
000051DE 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
000051E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000051E2                            .UpdateSpdOnGround:
000051E2 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
000051E6 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
000051EA 6600                       		bne.s	.ApplySpeed			; If so, branch
000051EC                            
000051EC 3028 003A                  		move.w	_objGVel(a0),d0			; Get current ground velocity
000051F0 6700                       		beq.s	.ApplySpeed			; If it's already 0, branch
000051F2 6B00                       		bmi.s	.SettleLeft			; Settle left if going left
000051F4                            
000051F4                            .SettleRight:
000051F4 9045                       		sub.w	d5,d0				; Slow down
000051F6 6A00                       		bpl.s	.SetSpeed			; If it's not done, branch
000051F8 7000                       		moveq	#0,d0				; Stop the movement
000051FA 6000                       		bra.s	.SetSpeed			; Continue
000051FC                            
000051FC                            .SettleLeft:
000051FC D045                       		add.w	d5,d0				; Slow down
000051FE 6B00                       		bmi.s	.SetSpeed			; If it's not done, branch
00005200 7000                       		moveq	#0,d0				; Stop the movement
00005202                            
00005202                            .SetSpeed:
00005202 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
00005206                            
00005206                            .ApplySpeed:
00005206 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000520A 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
0000520E C3E8 003A                  		muls.w	_objGVel(a0),d1			; Multiply cosine with ground velocity
00005212 C1E8 003A                  		muls.w	_objGVel(a0),d0			; Multiply sine with ground velocity
00005216 E081                       		asr.l	#8,d1				; Shift the values over
00005218 E080                       		asr.l	#8,d0				; ''
0000521A 3141 001C                  		move.w	d1,_objXVel(a0)			; Set the X velocity
0000521E 3140 001E                  		move.w	d0,_objYVel(a0)			; Set the Y velocity
00005222                            
00005222                            ObjPlayer_CheckWalls:
00005222 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005226 0200 003F                  		andi.b	#$3F,d0				; Is Sonic on an angle?
0000522A 6700                       		beq.s	.Skip				; If not, branch
0000522C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005230 0600 0040                  		addi.b	#$40,d0				; Is Sonic on an upwards wall or ceiling?
00005234 6B00                       		bmi.s	.End				; If so, branch
00005236                            
00005236                            .Skip:
00005236 7240                       		moveq	#$40,d1				; If going left, make the modifier $40
00005238 4A68 003A                  		tst.w	_objGVel(a0)			; Check speed
0000523C 6700                       		beq.s	.End				; Branch if not moving
0000523E 6B00                       		bmi.s	.CheckPush			; Branch if going left
00005240 4441                       		neg.w	d1				; Negate the modifier
00005242                            
00005242                            .CheckPush:
00005242 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005246 D001                       		add.b	d1,d0				; Add modifier
00005248                            		push.w	d0				; Save it
00005248 3F00                     M 	move.w	d0,-(sp)
0000524A 4EB8 3250                  		jsr	PlayerCalcRoomInFront		; Calculate the distance in front of Sonic
0000524E                            		pop.w	d0				; Restore angle
0000524E 301F                     M 	move.w	(sp)+,d0
00005250 4A41                       		tst.w	d1				; Is Sonic pushing into anything?
00005252 6A00                       		bpl.s	.End				; If not, branch
00005254 E141                       		asl.w	#8,d1				; Shift distance inside the collision
00005256 0600 0020                  		addi.b	#$20,d0				; Add $20 to the angle
0000525A 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic pushing on a ceiling?
0000525E 6700                       		beq.s	.PushCeiling			; If so, branch
00005260 0C00 0040                  		cmpi.b	#$40,d0				; Is Sonic pushing on a right wall?
00005264 6700                       		beq.s	.PushRightWall			; If so, branch
00005266 0C00 0080                  		cmpi.b	#$80,d0				; Is Sonic pushing on a floor?
0000526A 6700                       		beq.s	.PushFloor			; If so, branch
0000526C D368 001C                  		add.w	d1,_objXVel(a0)			; Push out to the right
00005270 4268 003A                  		clr.w	_objGVel(a0)			; Stop moving
00005274 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing right?
0000527A 6600                       		bne.s	.End				; If not, branch
0000527C 08E8 0005 0028             		bset	#5,_objStatus(a0)			; Start pushing
00005282 4E75                       		rts
00005284                            
00005284                            .PushFloor:
00005284 9368 001E                  		sub.w	d1,_objYVel(a0)			; Push out upwards
00005288 4E75                       		rts
0000528A                            
0000528A                            .PushRightWall:
0000528A 9368 001C                  		sub.w	d1,_objXVel(a0)			; Push out to the left
0000528E 4268 003A                  		clr.w	_objGVel(a0)			; Stop moving
00005292 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005298 6700                       		beq.s	.End				; If not, branch
0000529A 08E8 0005 0028             		bset	#5,_objStatus(a0)			; Start pushing
000052A0 4E75                       		rts
000052A2                            
000052A2                            .PushCeiling:
000052A2 D368 001E                  		add.w	d1,_objYVel(a0)			; Push out downwards
000052A6                            
000052A6                            .End:
000052A6 4E75                       		rts
000052A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052A8                            ; Move left on the ground
000052A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052A8                            ObjPlayer_MoveLeft:
000052A8 3028 003A                  		move.w	_objGVel(a0),d0			; Get current speed
000052AC 6700                       		beq.s	.SetFlip			; If not moving yet, branch
000052AE 6A00                       		bpl.s	.Skid				; If moving right, check for skidding
000052B0                            
000052B0                            .SetFlip:
000052B0 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Set flip flag
000052B6 6600                       		bne.s	.MoveLeft			; If it was already set, branch
000052B8 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
000052BE 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
000052C4                            
000052C4                            .MoveLeft:
000052C4 9045                       		sub.w	d5,d0				; Subtract acceleration
000052C6 3206                       		move.w	d6,d1				; Get top speed
000052C8 4441                       		neg.w	d1				; Negate it
000052CA B041                       		cmp.w	d1,d0				; Is Sonic moving faster than the top speed?
000052CC 6E00                       		bgt.s	.SetSpeed			; If not, branch
000052CE D045                       		add.w	d5,d0				; Add acceleration back
000052D0 B041                       		cmp.w	d1,d0				; Is Sonic still moving faster than the top speed?
000052D2 6F00                       		ble.s	.SetSpeed			; If not, branch
000052D4 3001                       		move.w	d1,d0				; Cap at the top speed
000052D6                            
000052D6                            .SetSpeed:
000052D6 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
000052DA 4228 0020                  		clr.b	_objAnim(a0)			; Set animation to moving
000052DE                            
000052DE                            .End:
000052DE 4E75                       		rts
000052E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052E0                            .Skid:
000052E0 9044                       		sub.w	d4,d0				; Subtract deceleration
000052E2 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
000052E4                            
000052E4                            .Compare:
000052E4 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
000052E6 6C00                       		bge.s	.SetSkidSpeed			; If not branch
000052E8 7080                       		moveq	#-$80,d0			; Set speed to -$80
000052EA                            
000052EA                            .SetSkidSpeed:
000052EA 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
000052EE 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000052F2 0600 0020                  		addi.b	#$20,d0				; Shift it
000052F6 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
000052FA 66E2                       		bne.s	.End				; If so, branch
000052FC 0C40 0400                  		cmpi.w	#$400,d0			; Is Sonic's speed at least 4 pixels per frame?
00005300 6DDC                       		blt.s	.End				; If not, branch
00005302 117C 000D 0020             		move.b	#$D,_objAnim(a0)			; Set animation to skidding
00005308 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Clear flip flag
0000530E                            		playSnd	#sSkid, 2			; Play skid sound
0000530E 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
00005314 4E75                       		rts
00005316                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005316                            ; Move right on the ground
00005316                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005316                            ObjPlayer_MoveRight:
00005316 3028 003A                  		move.w	_objGVel(a0),d0			; Get current speed
0000531A 6B00                       		bmi.s	.Skid				; If it's negative, skid
0000531C 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Clear flip flag
00005322 6700                       		beq.s	.MoveRight			; Branch if it was already cleared
00005324 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
0000532A 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00005330                            
00005330                            .MoveRight:
00005330 D045                       		add.w	d5,d0				; Add acceleration
00005332 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
00005334 6D00                       		blt.s	.SetSpeed			; If not, branch
00005336 9045                       		sub.w	d5,d0				; Subtract acceleration back
00005338 B046                       		cmp.w	d6,d0				; Is Sonic still going at the top speed?
0000533A 6C00                       		bge.s	.SetSpeed			; If not, branch
0000533C 3006                       		move.w	d6,d0				; Cap at top speed
0000533E                            
0000533E                            .SetSpeed:
0000533E 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
00005342 4228 0020                  		clr.b	_objAnim(a0)			; Set animation to moving
00005346                            
00005346                            .End:
00005346 4E75                       		rts
00005348                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005348                            .Skid:
00005348 D044                       		add.w	d4,d0				; Add deceleration
0000534A 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
0000534C                            
0000534C                            .Compare:
0000534C B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
0000534E 6F00                       		ble.s	.SetSkidSpeed			; If not, branch
00005350 303C 0080                  		move.w	#$80,d0				; Set speed to $80
00005354                            
00005354                            .SetSkidSpeed:
00005354 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
00005358 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000535C 0600 0020                  		addi.b	#$20,d0				; Shift it
00005360 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
00005364 66E0                       		bne.s	.End				; If so, branch
00005366 0C40 FC00                  		cmpi.w	#-$400,d0			; Is Sonic's speed at least -4 pixels per frame?
0000536A 6EDA                       		bgt.s	.End				; If not, branch
0000536C 117C 000D 0020             		move.b	#$D,_objAnim(a0)			; Set animation to skidding
00005372 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Set flip flag
00005378                            
00005378 4E75                       		rts
0000537A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000537A                            ; Do movement while rolling
0000537A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000537A                            ObjPlayer_MoveRoll:
0000537A 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
0000537E E346                       		asl.w	#1,d6				; ''
00005380 3A28 0036                  		move.w	_objAccel(a0),d5			; Get acceleration
00005384 E245                       		asr.w	#1,d5				; ''
00005386 3828 0038                  		move.w	_objDecel(a0),d4			; Get deceleration
0000538A E444                       		asr.w	#2,d4				; ''
0000538C                            
0000538C 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer active?
00005390 6600 0000                  		bne.w	.UpdateSpd			; If so, branch
00005394                            
00005394 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left being held?
0000539A 6700                       		beq.s	.ChkRight			; If not, branch
0000539C 6100 0000                  		bsr.w	ObjPlayer_RollLeft		; Handle left movement
000053A0                            
000053A0                            .ChkRight:
000053A0 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right being held?
000053A6 6700                       		beq.s	.Decelerate			; If not, branch
000053A8 6100 0000                  		bsr.w	ObjPlayer_RollRight		; Handle right movement
000053AC                            
000053AC                            .Decelerate:
000053AC 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
000053B0 6700                       		beq.s	.ChkStop			; If Sonic isn't moving, branch
000053B2 6B00                       		bmi.s	.DecLeft			; If Sonic is moving left, branch
000053B4                            
000053B4 9045                       		sub.w	d5,d0				; Decelerate
000053B6 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
000053B8 7000                       		moveq	#0,d0				; Cap at 0
000053BA                            
000053BA                            .SetGVel:
000053BA 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
000053BE 6000                       		bra.s	.ChkStop			; Continue
000053C0                            
000053C0                            .DecLeft:
000053C0 D045                       		add.w	d5,d0				; Decelerate
000053C2 6400                       		bcc.s	.SetGVel2			; If Sonic hasn't stopped yet, branch
000053C4 7000                       		moveq	#0,d0				; Cap at 0
000053C6                            
000053C6                            .SetGVel2:
000053C6 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
000053CA                            
000053CA                            .ChkStop:
000053CA 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic still moving?
000053CE 6600                       		bne.s	.UpdateSpd			; If so, branch
000053D0                            
000053D0 4A28 004B                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
000053D4 6600                       		bne.s	.KeepRoll			; If so, branch
000053D6 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Stop rolling
000053DC 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
000053E2 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
000053E8 117C 0005 0020             		move.b	#5,_objAnim(a0)			; Use standing animation
000053EE                            	;	subq.w	#5,_objYPos(a0)			; Align Sonic with the ground
000053EE 6000                       		bra.s	.UpdateSpd			; Continue
000053F0                            
000053F0                            .KeepRoll:
000053F0 317C 0400 003A             		move.w	#$400,_objGVel(a0)			; Speed up again
000053F6 0828 0000 0028             		btst	#0,_objStatus(a0)			; Are we facing right?
000053FC 6700                       		beq.s	.UpdateSpd			; If so, branch
000053FE 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005402                            
00005402                            .UpdateSpd:
00005402 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005406 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
0000540A C1E8 003A                  		muls.w	_objGVel(a0),d0			; Multiply sine with ground velocity
0000540E E080                       		asr.l	#8,d0				; Shift over
00005410 3140 001E                  		move.w	d0,_objYVel(a0)			; Set Y velocity
00005414 C3E8 003A                  		muls.w	_objGVel(a0),d1			; Multiply cosine with ground velocity
00005418 E081                       		asr.l	#8,d1				; Shift over
0000541A                            
0000541A 0C41 1000                  		cmpi.w	#$1000,d1			; Is the speed > $10 pixels per frame?
0000541E 6F00                       		ble.s	.ChkLeftSpd			; If not, branch
00005420 323C 1000                  		move.w	#$1000,d1			; Cap the speed
00005424                            
00005424                            .ChkLeftSpd:
00005424 0C41 F000                  		cmpi.w	#-$1000,d1			; Is the speed < -$10 pixels per frame?
00005428 6C00                       		bge.s	.SetXVel			; If not, branch
0000542A 323C F000                  		move.w	#-$1000,d1			; Cap the speed
0000542E                            
0000542E                            .SetXVel:
0000542E 3141 001C                  		move.w	d1,_objXVel(a0)			; Set X velocity
00005432 6000 FDEE                  		bra.w	ObjPlayer_CheckWalls		; Check wall collision
00005436                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005436                            ; Handle left movement for rolling
00005436                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005436                            ObjPlayer_RollLeft:
00005436 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
0000543A 6700                       		beq.s	.SetLeft			; If Sonic isn't moving, branch
0000543C 6A00                       		bpl.s	.Dec				; If Sonic is moving right, branch
0000543E                            
0000543E                            .SetLeft:
0000543E 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
00005444 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use rolling animation
0000544A 4E75                       		rts
0000544C                            
0000544C                            .Dec:
0000544C 9044                       		sub.w	d4,d0				; Decelerate
0000544E 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
00005450 303C FF80                  		move.w	#-$80,d0			; Set new speed
00005454                            
00005454                            .SetGVel:
00005454 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
00005458 4E75                       		rts
0000545A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000545A                            ; Handle left movement for rolling
0000545A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000545A                            ObjPlayer_RollRight:
0000545A 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
0000545E 6B00                       		bmi.s	.Dec				; If Sonic is moving left, branch
00005460 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
00005466 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use rolling animation
0000546C 4E75                       		rts
0000546E                            
0000546E                            .Dec:
0000546E D044                       		add.w	d4,d0				; Decelerate
00005470 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
00005472 303C 0080                  		move.w	#$80,d0				; Set new speed
00005476                            
00005476                            .SetGVel:
00005476 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
0000547A 4E75                       		rts
0000547C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000547C                            ; Do movement in the air
0000547C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000547C                            ObjPlayer_MoveAir:
0000547C 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
00005480 3A28 0036                  		move.w	_objAccel(a0),d5			; Get accleration
00005484 DA45                       		add.w	d5,d5				; Double it
00005486 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
0000548A                            
0000548A 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left being held?
00005490 6700                       		beq.s	.NotLeft			; If not, branch
00005492 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
00005498 9045                       		sub.w	d5,d0				; Subtract acceleration
0000549A 3206                       		move.w	d6,d1				; Get top speed
0000549C 4441                       		neg.w	d1				; Negate it
0000549E B041                       		cmp.w	d1,d0				; Has Sonic reached the top speed?
000054A0 6E00                       		bgt.s	.NotLeft			; If not, branch
000054A2 D045                       		add.w	d5,d0				; Add acceleration back
000054A4 B041                       		cmp.w	d1,d0				; Is Sonic still at top speed?
000054A6 6F00                       		ble.s	.NotLeft			; If not, branch
000054A8 3001                       		move.w	d1,d0				; Cap at top speed
000054AA                            
000054AA                            .NotLeft:
000054AA 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right being held?
000054B0 6700                       		beq.s	.NotRight			; If not, branch
000054B2 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
000054B8 D045                       		add.w	d5,d0				; Add acceleration
000054BA B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
000054BC 6D00                       		blt.s	.NotRight			; If not, branch
000054BE 9045                       		sub.w	d5,d0				; Subtract acceleration back
000054C0 B046                       		cmp.w	d6,d0				; Is Sonic still at top speed?
000054C2 6C00                       		bge.s	.NotRight			; If not, branch
000054C4 3006                       		move.w	d6,d0				; Cap at top speed
000054C6                            
000054C6                            .NotRight:
000054C6 3140 001C                  		move.w	d0,_objXVel(a0)			; Set X velocity
000054CA                            
000054CA                            .ResetScr
000054CA 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
000054D0 6700                       		beq.s	.DecelerateAtPeak		; If so, branch
000054D2 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
000054D4 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
000054D8                            
000054D8                            .ScrollUp:
000054D8 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
000054DC                            
000054DC                            .DecelerateAtPeak:
000054DC 0C68 FC00 001E             		cmpi.w	#-$400,_objYVel(a0)		; Is Sonic at least going -4 pixels per frame up?
000054E2 6500                       		bcs.s	.End				; If not, branch
000054E4 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
000054E8 3200                       		move.w	d0,d1				; Save it
000054EA EA41                       		asr.w	#5,d1				; Turn it into the acceleration
000054EC 6700                       		beq.s	.End				; If it's 0, branch
000054EE 6B00                       		bmi.s	.DecLeft			; If it's negative, branch
000054F0                            
000054F0                            .DecRight:
000054F0 9041                       		sub.w	d1,d0				; Subtract accleration
000054F2 6400                       		bcc.s	.DecSetSpeed			; If it's not negative, branch
000054F4 7000                       		moveq	#0,d0				; Cap at 0
000054F6 6000                       		bra.s	.DecSetSpeed			; Continue
000054F8                            
000054F8                            .DecLeft:
000054F8 9041                       		sub.w	d1,d0				; Subtract acceleration
000054FA 6500                       		bcs.s	.DecSetSpeed			; If it's not positive, branch
000054FC 7000                       		moveq	#0,d0				; Cap at 0
000054FE                            
000054FE                            .DecSetSpeed:
000054FE 3140 001C                  		move.w	d0,_objXVel(a0)			; Set thhe X velocity
00005502                            
00005502                            .End:
00005502 4E75                       		rts
00005504                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005504                            ; Handle level boundaries
00005504                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005504                            ObjPlayer_LvlBound:
00005504 4A68 001E                  		tst.w	_objYVel(a0)
00005508 6A00                       		bpl.s	.XBound
0000550A 3228 0018                  		move.w	_objYPos(a0),d1
0000550E 0641 0010                  		addi.w	#$10,d1
00005512 3038 E8D4                  		move.w	minCamYPos.w,d0		; Get upper boundary position
00005516 B041                       		cmp.w	d1,d0				; Has Sonic touched the upper boundary?
00005518 6F00                       		ble.s	.XBound				; If so, branch
0000551A 3140 0018                  		move.w	d0,_objYPos(a0)
0000551E 4268 001E                  		clr.w	_objYVel(a0)
00005522 4268 003A                  		clr.w	_objGVel(a0)
00005526                            
00005526                            .XBound:
00005526 2228 0014                  		move.l	_objXPos(a0),d1			; Get X position
0000552A 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
0000552E 48C0                       		ext.l	d0
00005530 E180                       		asl.l	#8,d0				; Shift it
00005532 D280                       		add.l	d0,d1				; Add to X position
00005534 4841                       		swap	d1				; Get actual X position
00005536 3038 E8D2                  		move.w	minCamXPos.w,d0		; Get left boundary position
0000553A 0640 0010                  		addi.w	#$10,d0				; ''
0000553E B041                       		cmp.w	d1,d0				; Has Sonic touched the left boundary?
00005540 6E00                       		bgt.s	.TouchedSide			; If so, branch
00005542 3038 E8CA                  		move.w	maxCamXPos.w,d0		; Get max camera X position
00005546 0640 0128                  		addi.w	#320-24,d0			; Get right boundary position
0000554A B041                       		cmp.w	d1,d0				; Has Sonic touched the right boundary?
0000554C 6F00                       		ble.s	.TouchedSide			; If so, branch
0000554E                            
0000554E                            .ChkBottom:
0000554E 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get max camera Y position
00005552 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
00005556 B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic touched the bottom boundary?
0000555A 6D00                       		blt.s	.TouchedBottom			; If so, branch
0000555C 4E75                       		rts
0000555E                            
0000555E                            .TouchedBottom:
0000555E 3038 E8C8                  		move.w	targetMaxCamY.w,d0		; Get target max camera Y position
00005562 3238 E8CC                  		move.w	maxCamYPos.w,d1		; Get current max camera Y position
00005566 B240                       		cmp.w	d0,d1				; Are they the same?
00005568 6D00                       		blt.s	.NoKill				; If not, branch
0000556A 6000 0000                  		bra.w	ObjPlayer_GetKilled		; Get Sonic killed
0000556E                            
0000556E                            .NoKill:
0000556E 4E75                       		rts
00005570                            
00005570                            .TouchedSide:
00005570 4268 001C                  		clr.w	_objXVel(a0)			; Stop X movement
00005574 3140 0014                  		move.w	d0,_objXPos(a0)			; Move Sonic out of the boundary
00005578 4228 0016                  		clr.b	_objXPos+2(a0)			; Clear the subpixel of the X position
0000557C 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
00005580 60CC                       		bra.s	.ChkBottom			; Continue
00005582                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005582                            ; Handle peelout
00005582                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005582                            ObjPlayer_Peelout:
00005582 4A28 0045                  		tst.b	_objDashFlag(a0)			; Is Sonic doing the peelout?
00005586 6700                       		beq.s	.ChkUp				; If not, branch
00005588 6B00                       		bmi.s	.ChkLaunch			; If so, branch
0000558A 4E75                       		rts
0000558C                            
0000558C                            .ChkUp:
0000558C 0C28 0007 0020             		cmpi.b	#7,_objAnim(a0)			; Is Sonic looking up?
00005592 6600 0000                  		bne.w	.End				; If not, branch
00005596 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get controller bits
0000559A 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000559E 6700 0000                  		beq.w	.End				; If not, branch
000055A2                            
000055A2 4228 0020                  		clr.b	_objAnim(a0)			; Set to peelout charge animation
000055A6 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset the dash timer
000055AA 317C 000C 003A             		move.w	#$C,_objGVel(a0)			; Reset ground velocity
000055B0 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000055B6 6700                       		beq.s	.SetAni				; If so, branch
000055B8 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
000055BC                            
000055BC                            .SetAni:
000055BC                            		playSnd	#sCharge, 2			; Play charge sound
000055BC 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
000055C2                            
000055C2 588F                       		addq.l	#4,sp				; Don't return to caller
000055C4 50E8 0045                  		st	_objDashFlag(a0)			; Set the peelout flag
000055C8 4EF8 369A                  		jmp	PlayerAnglePos			; Update position and angle along the ground
000055CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000055CC                            .ChkLaunch:
000055CC 0838 0000 E8DE             		btst	#0,plrCtrlHold.w		; Is up being held?
000055D2 6600 0000                  		bne.w	.Charge				; If so, branch
000055D6 4228 0045                  		clr.b	_objDashFlag(a0)			; Clear the dash flag
000055DA                            
000055DA 0C28 001E 0046             		cmpi.b	#30,_objDashTimer(a0)		; Has Sonic charged up enough?
000055E0 6600                       		bne.s	.StopSound			; If not, branch
000055E2                            
000055E2 4228 0020                  		clr.b	_objAnim(a0)			; Reset animation
000055E6 317C 0C00 003A             		move.w	#$C00,_objGVel(a0)			; Set ground velocity
000055EC 0828 0006 0028             		btst	#6,_objStatus(a0)
000055F2 6700                       		beq.s	.NoWater
000055F4 E2E8 003A                  		lsr.w	_objGVel(a0)
000055F8                            
000055F8                            .NoWater:
000055F8 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000055FE 6700                       		beq.s	.FinishDash			; If not, branch
00005600 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005604                            
00005604                            .FinishDash:
00005604                            		playSnd	#sChargeRelease, 2		; Play charge release sound
00005604 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000560A                            
0000560A 6000                       		bra.s	.DoUpdates			; Continue
0000560C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000560C                            .Charge:
0000560C 0C28 001E 0046             		cmpi.b	#30,_objDashTimer(a0)		; Has Sonic charged enough?
00005612 6700                       		beq.s	.DoUpdates			; If so, branch
00005614 5228 0046                  		addq.b	#1,_objDashTimer(a0)		; Increment the timer
00005618 0668 0066 003A             		addi.w	#$66,_objGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000561E 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005624 6700                       		beq.s	.DoUpdates			; If so, branch
00005626 0468 00CC 003A             		subi.w	#$66*2,_objGVel(a0)		; Go the other way
0000562C 6000                       		bra.s	.DoUpdates			; Continue
0000562E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000562E                            .StopSound:
0000562E 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
00005632                            
00005632                            		playSnd	#sChargeStop, 2			; Play charge stop sound
00005632 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
00005638                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005638                            .DoUpdates:
00005638 588F                       		addq.l	#4,sp				; Don't return to caller
0000563A 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005640 6700                       		beq.s	.FinishUpdates			; If so, branch
00005642 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005644 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005648                            
00005648                            .ScrollUp:
00005648 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
0000564C                            
0000564C                            .FinishUpdates:
0000564C 4EF8 369A                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005650                            
00005650                            .End:
00005650 4E75                       		rts
00005652                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005652                            ; Handle spindash
00005652                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005652                            ObjPlayer_Spindash:
00005652 4A28 0045                  		tst.b	_objDashFlag(a0)			; Is Sonic doing the spindash?
00005656 6700                       		beq.s	.ChkDown			; If not, branch
00005658 6A00                       		bpl.s	.ChkLaunch			; If so, branch
0000565A 4E75                       		rts
0000565C                            
0000565C                            .ChkDown:
0000565C 0C28 0008 0020             		cmpi.b	#8,_objAnim(a0)			; Is Sonic ducking?
00005662 6600 0000                  		bne.w	.End				; If not, branch
00005666 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get controller bits
0000566A 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
0000566E 6700 0000                  		beq.w	.End				; If not, branch
00005672                            
00005672 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset the dash timer
00005676 317C 000C 003A             		move.w	#$C,_objGVel(a0)			; Reset ground velocity
0000567C 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005682 6700                       		beq.s	.SetAni				; If so, branch
00005684 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005688                            
00005688                            .SetAni:
00005688 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
0000568E 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005694                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005694 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set to spin animation
0000569A                            
0000569A                            		playSnd	#sCharge, 2			; Play charge sound
0000569A 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
000056A0                            
000056A0 588F                       		addq.l	#4,sp				; Don't return to caller
000056A2 117C 0001 0045             		move.b	#1,_objDashFlag(a0)		; Set the spindash flag
000056A8 4EF8 369A                  		jmp	PlayerAnglePos			; Update position and angle along the ground
000056AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056AC                            .ChkLaunch:
000056AC 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is down being held?
000056B2 6600 0000                  		bne.w	.Charge				; If so, branch
000056B6 4228 0045                  		clr.b	_objDashFlag(a0)			; Clear the dash flag
000056BA                            
000056BA 0C28 002D 0046             		cmpi.b	#45,_objDashTimer(a0)		; Has Sonic charged up enough?
000056C0 6600                       		bne.s	.StopSound			; If not, branch
000056C2                            
000056C2 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set the roll flag
000056C8 317C 0C00 003A             		move.w	#$C00,_objGVel(a0)			; Set ground velocity
000056CE 0828 0006 0028             		btst	#6,_objStatus(a0)
000056D4 6700                       		beq.s	.NoWater
000056D6 E2E8 003A                  		lsr.w	_objGVel(a0)
000056DA                            
000056DA                            .NoWater:
000056DA 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000056E0 6700                       		beq.s	.FinishDash			; If not, branch
000056E2 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
000056E6                            
000056E6                            .FinishDash:
000056E6                            		playSnd	#sChargeRelease, 2		; Play charge release sound
000056E6 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
000056EC                            
000056EC 6000                       		bra.s	.DoUpdates			; Continue
000056EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056EE                            .Charge:
000056EE 0C28 002D 0046             		cmpi.b	#45,_objDashTimer(a0)		; Has Sonic charged enough?
000056F4 6700                       		beq.s	.DoUpdates			; If so, branch
000056F6 5228 0046                  		addq.b	#1,_objDashTimer(a0)		; Increment the timer
000056FA 0668 0046 003A             		addi.w	#$46,_objGVel(a0)			; Increment ground velocity to handle animation and extended camera
00005700 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005706 6700                       		beq.s	.DoUpdates			; If so, branch
00005708 0468 008C 003A             		subi.w	#$46*2,_objGVel(a0)		; Go the other way
0000570E 6000                       		bra.s	.DoUpdates			; Continue
00005710                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005710                            .StopSound:
00005710 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
00005714 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
0000571A 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
00005720                            	;	subq.w	#5,_objYPos(a0)			; Align Sonic with the ground
00005720                            
00005720                            		playSnd	#sChargeStop, 2			; Play charge stop sound
00005720 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
00005726                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005726                            .DoUpdates:
00005726 588F                       		addq.l	#4,sp				; Don't return to caller
00005728 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
0000572E 6700                       		beq.s	.FinishUpdates			; If so, branch
00005730 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005732 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005736                            
00005736                            .ScrollUp:
00005736 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
0000573A                            
0000573A                            .FinishUpdates:
0000573A 4EF8 369A                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000573E                            
0000573E                            .End:
0000573E 4E75                       		rts
00005740                            		
00005740                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005740                            ; Check for fire attack
00005740                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005740                            ObjPlayer_ChkAttack:
00005740 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get pressed buttons
00005744 0200 0010                  		andi.b	#$10,d0				; Are B pressed?
00005748 4A00                       		tst.b	d0
0000574A 6700 0000                  		beq.w	.End				; If not, branch
0000574E                            		
0000574E 4EB8 1A1C                  		jsr	FindFreeObj.w
00005752 6700                       		beq.s	.End
00005754 22BC 0000 0000             		move.l	#ObjAttack,_objAddress(a1)
0000575A 137C 001E 0017             		move.b	#30,_objDrawW(a1)
00005760 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005766 6700                       		beq.s	.cont			; If so, branch
00005768 337C 0001 0024             		move.w	#1,	_objSubtype(a1)
0000576E                            	.cont:
0000576E 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
00005774 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
0000577A                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
0000577A 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
00005780                            		
00005780                            .End:
00005780 4E75                       		rts
00005782                            		
00005782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005782                            ; Check for jumping
00005782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005782                            ObjPlayer_ChkJump:
00005782 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get pressed buttons
00005786 0200 0020                  		andi.b	#$20,d0				; Are C pressed?
0000578A 4A38 C76A                  		tst.b	moveCheat.w
0000578E 6700                       		beq.s	.NoDebug
00005790 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
00005794                            
00005794                            .NoDebug:
00005794 4A00                       		tst.b	d0
00005796 6700 0000                  		beq.w	.End				; If not, branch
0000579A                            
0000579A 7000                       		moveq	#0,d0
0000579C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000057A0 0600 0080                  		addi.b	#$80,d0				; Shift it to check the ceiling
000057A4 4EB8 32C2                  		jsr	PlayerCalcRoomOverHead		; Get room over Sonic's head
000057A8 0C41 0006                  		cmpi.w	#6,d1				; Is it at least 6 pixels?
000057AC 6D00 0000                  		blt.w	.End				; If not, branch
000057B0                            
000057B0 343C 0180                  		move.w	#JUMP_HEIGHT,d2			; Standard jump height
000057B4 0828 0006 0028             		btst	#6,_objStatus(a0)
000057BA 6700                       		beq.s	.NoWater
000057BC 0442 0300                  		subi.w	#$300,d2
000057C0                            
000057C0                            .NoWater:
000057C0 7000                       		moveq	#0,d0
000057C2 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000057C6 0400 0040                  		subi.b	#$40,d0				; Shift it
000057CA 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
000057CE C3C2                       		muls.w	d2,d1				; Mutliply cosine with jump height
000057D0 C1C2                       		muls.w	d2,d0				; Mutliply sine with jump height
000057D2 E081                       		asr.l	#8,d1				; Shift the values over
000057D4 E080                       		asr.l	#8,d0				; ''
000057D6 D368 001C                  		add.w	d1,_objXVel(a0)			; Add to X velocity
000057DA D168 001E                  		add.w	d0,_objYVel(a0)			; Add to Y velocity
000057DE 0028 0006 0028             		ori.b	#6,_objStatus(a0)			; Set "in air" and roll flags
000057E4 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
000057EA 584F                       		addq.w	#4,sp				; Do not return to collaer
000057EC 50E8 0040                  		st	_objJumping(a0)			; Set the jumping flag
000057F0                            		playSnd	#sLeap, 2			; Play jump sound
000057F0 11FC 0082 C4BD           M 	move.b	#sleap,(mqueue+((2)-1)).w
000057F6 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
000057FC 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005802                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005802 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set jumping animation
00005808                            
00005808                            .End:
00005808 4E75                       		rts
0000580A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000580A                            ; Handle variable jumping
0000580A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000580A                            ObjPlayer_JumpHeight:
0000580A                            	;	tst.b	_objJumping(a0)			; Is Sonic jumping?
0000580A                            	;	beq.s	.UpVelCap			; If not, branch
0000580A                            
0000580A 323C FE80                  		move.w	#-MIN_JMP_HEIGHT,d1		; Standard minimum height
0000580E B268 001E                  		cmp.w	_objYVel(a0),d1			; Is Sonic jumping at least hte minimum height?
00005812 6F00                       		ble.s	.End				; If not, branch
00005814 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
00005818 0200 0020                  		andi.b	#$20,d0				; Are A, B, or C pressed?
0000581C 4A38 C76A                  		tst.b	moveCheat.w
00005820 6700                       		beq.s	.NoDebug
00005822 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
00005826                            
00005826                            .NoDebug:
00005826 4A00                       		tst.b	d0
00005828 6600                       		bne.s	.End				; If not, branch
0000582A 3141 001E                  		move.w	d1,_objYVel(a0)			; Set to minimum height
0000582E                            
0000582E                            .End:
0000582E 4E75                       		rts
00005830                            
00005830                            .UpVelCap:
00005830 4A28 004B                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
00005834 66F8                       		bne.s	.End				; If so, branch
00005836 0C68 F040 001E             		cmpi.w	#-$FC0,_objYVel(a0)		; Cap Y velocity at -$FC0 when going up
0000583C 6CF0                       		bge.s	.End				; ''
0000583E 317C F040 001E             		move.w	#-$FC0,_objYVel(a0)		; ''
00005844 4E75                       		rts
00005846                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005846                            ; Gradually reset Sonic's angle in mid air
00005846                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005846                            ObjPlayer_JumpAngle:
00005846 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000584A 6700                       		beq.s	ObjPlayer_JumpFlip		; If it's already reset, branch
0000584C 6A00                       		bpl.s	.Decrease			; If it's positive, branch
0000584E                            
0000584E                            .Increase:
0000584E 5400                       		addq.b	#2,d0				; Increase angle
00005850 6B00                       		bmi.s	.SetAngle			; If it's not reset, branch
00005852 7000                       		moveq	#0,d0				; Reset the angle
00005854 6000                       		bra.s	.SetAngle
00005856                            
00005856                            .Decrease:
00005856 5500                       		subq.b	#2,d0				; Decrease angle
00005858 6A00                       		bpl.s	.SetAngle			; If it's not reset, branch
0000585A 7000                       		moveq	#0,d0				; Reset the angle
0000585C                            
0000585C                            .SetAngle:
0000585C 1140 0041                  		move.b	d0,_objAngle(a0)			; Set the new angle
00005860                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005860                            ; Update Sonic's angle while he's tumbling in the air
00005860                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005860                            ObjPlayer_JumpFlip:
00005860 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Get flip angle
00005864 6700                       		beq.s	.End				; If it's 0, branch
00005866 4A68 003A                  		tst.w	_objFlipDir(a0)			; Is Sonic flipping left?
0000586A 6B00                       		bmi.s	.FlipLeft			; IF so, branch
0000586C                            
0000586C                            .FlipRight:
0000586C 1228 004A                  		move.b	_objFlipSpeed(a0),d1		; Get flip speed
00005870 D001                       		add.b	d1,d0				; Add to angle
00005872 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
00005874 5328 0049                  		subq.b	#1,_objFlipRemain(a0)		; Decrement flips remaining
00005878 6400                       		bcc.s	.FlipSet			; If there are still some left
0000587A 4228 0049                  		clr.b	_objFlipRemain(a0)			; Clear flips remaining
0000587E 7000                       		moveq	#0,d0				; Reset angle
00005880 6000                       		bra.s	.FlipSet			; Continue
00005882                            
00005882                            .FlipLeft:
00005882 4A28 0048                  		tst.b	_objFlipTurned(a0)			; Is the flipping inverted?
00005886 66E4                       		bne.s	.FlipRight			; If so, branch
00005888 1228 004A                  		move.b	_objFlipSpeed(a0),d1		; Get flip speed
0000588C 9001                       		sub.b	d1,d0				; Subtract from angle
0000588E 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
00005890 5328 0049                  		subq.b	#1,_objFlipRemain(a0)		; Decrement flips remaining
00005894 6400                       		bcc.s	.FlipSet			; If there are still some left
00005896 4228 0049                  		clr.b	_objFlipRemain(a0)			; Clear flips remaining
0000589A 7000                       		moveq	#0,d0				; Reset angle
0000589C                            
0000589C                            .FlipSet:
0000589C 1140 0047                  		move.b	d0,_objFlipAngle(a0)		; Update the angle
000058A0                            
000058A0                            .End:
000058A0 4E75                       		rts
000058A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058A2                            ; Check for rolling
000058A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058A2                            ObjPlayer_ChkRoll:
000058A2 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
000058A6 6A00                       		bpl.s	.ChkSpd				; Get absolute value
000058A8 4440                       		neg.w	d0				; ''
000058AA                            
000058AA                            .ChkSpd:
000058AA 0C40 0080                  		cmpi.w	#$80,d0				; Is Sonic going fast enough?
000058AE 6500                       		bcs.s	.NoRoll				; If not, branch
000058B0 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
000058B4 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
000058B8 6600                       		bne.s	.NoRoll				; If not, branch
000058BA 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is down being held?
000058C0 6600                       		bne.s	ObjPlayer_DoRoll			; If so, branch
000058C2                            
000058C2                            .NoRoll:
000058C2 4E75                       		rts
000058C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058C4                            ; Make Sonic roll
000058C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058C4                            ObjPlayer_DoRoll:
000058C4 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
000058CA 6600                       		bne.s	.End				; If so, branch
000058CC 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
000058D2                            
000058D2 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
000058D8 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
000058DE                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
000058DE 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
000058E4                            
000058E4 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving already?
000058E8 6600                       		bne.s	.End				; IF not, branch
000058EA 317C 0200 003A             		move.w	#$200,_objGVel(a0)			; Set speed
000058F0                            
000058F0                            .End:
000058F0 4E75                       		rts
000058F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058F2                            ; Slow Sonic down as he goes up a slope or speed him up when he does down one
000058F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058F2                            ObjPlayer_SlopePush:
000058F2 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000058F6 0600 0060                  		addi.b	#$60,d0				; Shift it
000058FA 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep slope or ceiling?
000058FE 6400                       		bcc.s	.End				; If not, branch
00005900 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005904 4EB8 1374                  		jsr	CalcSine.w			; Get the sine of it
00005908 C1FC 0020                  		muls.w	#$20,d0				; Multiple it by $20
0000590C E080                       		asr.l	#8,d0				; Shift it
0000590E 4A68 003A                  		tst.w	_objGVel(a0)			; Check speed
00005912 6700                       		beq.s	.End				; If Sonic is not moving, branch
00005914 D168 003A                  		add.w	d0,_objGVel(a0)			; Add to ground velocity
00005918                            
00005918                            .End:
00005918 4E75                       		rts
0000591A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000591A                            ; Check if Sonic is to fall off a slope
0000591A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000591A                            ObjPlayer_FallOffSlope:
0000591A 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer, active?
0000591E 6600                       		bne.s	.End				; If so, branch
00005920 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005924 0600 0020                  		addi.b	#$20,d0				; Shift it
00005928 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000592C 6700                       		beq.s	.End				; If Sonic is on the floor, branch
0000592E 3028 003A                  		move.w	_objGVel(a0),d0			; Get speed
00005932 6A00                       		bpl.s	.ChkSpeed			; If it's already positive, branch
00005934 4440                       		neg.w	d0				; Force it to be positive
00005936                            
00005936                            .ChkSpeed:
00005936 0C40 0280                  		cmpi.w	#$280,d0			; Is Sonic going at least 2.5 pixels per frame?
0000593A 6400                       		bcc.s	.End				; If so, branch
0000593C 4268 003A                  		clr.w	_objGVel(a0)			; Stop movement
00005940 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00005946 117C 001E 003F             		move.b	#$1E,_objMoveLock(a0)		; Set move lock timer
0000594C                            
0000594C                            .End:
0000594C 4E75                       		rts
0000594E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000594E                            ; Affect Sonic's speed on slopes while rolling
0000594E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000594E                            ObjPlayer_RollSlopePush:
0000594E 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005952 0600 0060                  		addi.b	#$60,d0				; ''
00005956 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep enough slope?
0000595A 6400                       		bcc.s	.End				; If not, branch
0000595C                            
0000595C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005960 4EB8 1374                  		jsr	CalcSine.w			; Get sine
00005964 C1FC 0050                  		muls.w	#$50,d0				; Multiply sine by $50
00005968 E080                       		asr.l	#8,d0				; Shift over
0000596A                            
0000596A 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving right?
0000596E 6B00                       		bmi.s	.PushLeft			; If not, branch
00005970 4A40                       		tst.w	d0				; Is the push speed positive?
00005972 6A00                       		bpl.s	.Push				; If so, branch
00005974 E480                       		asr.l	#2,d0				; Shift over more
00005976                            
00005976                            .Push:
00005976 D168 003A                  		add.w	d0,_objGVel(a0)			; Add push speed
0000597A 4E75                       		rts
0000597C                            
0000597C                            .PushLeft:
0000597C 4A40                       		tst.w	d0				; Is the push speed negative?
0000597E 6B00                       		bmi.s	.Push2				; If so, branch
00005980 E480                       		asr.l	#2,d0				; Shift over more
00005982                            
00005982                            .Push2:
00005982 D168 003A                  		add.w	d0,_objGVel(a0)			; Add push speed
00005986                            
00005986                            .End:
00005986 4E75                       		rts
00005988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005988                            ; Check for bouncy floor collision
00005988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005988                            ObjPlayer_ChkBounce:
00005988 4A38 E909                  		tst.b	rFlooactIDive.w		; Is the floor active?
0000598C 6700 0000                  		beq.w	.End				; If so, branch
00005990                            
00005990 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is Sonic in the air?
00005996 6700                       		beq.s	.ChkDown			; If not, branch
00005998                            
00005998 4A68 001E                  		tst.w	_objYVel(a0)			; Is Sonic falling?
0000599C 6700 0000                  		beq.w	.ChkBounceUp			; If not, branch
000059A0 6B00 0000                  		bmi.w	.ChkBounceUp			; ''
000059A4                            
000059A4                            .ChkDown:
000059A4 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of left sensor
000059A8 1028 002D                  		move.b	_objColH(a0),d0			; ''
000059AC 4880                       		ext.w	d0				; ''
000059AE D440                       		add.w	d0,d2				; ''
000059B0 5442                       		addq.w	#2,d2				; ''
000059B2 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of left sensor
000059B6 1028 002C                  		move.b	_objColW(a0),d0			; ''
000059BA 4880                       		ext.w	d0				; ''
000059BC 9640                       		sub.w	d0,d3				; ''
000059BE 4EB8 3C2A                  		jsr	Level_FindBlock			; Get the block located there
000059C2 3011                       		move.w	(a1),d0				; ''
000059C4 0240 03FF                  		andi.w	#$3FF,d0			; ''
000059C8 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
000059CC 6700                       		beq.s	.Bounce				; If so, branch
000059CE                            
000059CE 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of right sensor
000059D2 1028 002D                  		move.b	_objColH(a0),d0			; ''
000059D6 4880                       		ext.w	d0				; ''
000059D8 D440                       		add.w	d0,d2				; ''
000059DA 5442                       		addq.w	#2,d2				; ''
000059DC 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of right sensor
000059E0 1028 002C                  		move.b	_objColW(a0),d0			; ''
000059E4 4880                       		ext.w	d0				; ''
000059E6 D640                       		add.w	d0,d3				; ''
000059E8 4EB8 3C2A                  		jsr	Level_FindBlock			; Get the block located there
000059EC 3011                       		move.w	(a1),d0				; ''
000059EE 0240 03FF                  		andi.w	#$3FF,d0			; ''
000059F2 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
000059F6 6600                       		bne.s	.End				; If not, branch
000059F8                            
000059F8                            .Bounce:
000059F8 317C EA00 001E             		move.w	#-$1600,_objYVel(a0)		; Bounce Sonic up
000059FE 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set in air flag
00005A04 4228 0040                  		clr.b	_objJumping(a0)			; Clear jump flag
00005A08 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset dash timer
00005A0C 4228 0045                  		clr.b	_objDashFlag(a0)			; Reset dash flag
00005A10                            
00005A10                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
00005A10 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
00005A16                            
00005A16 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
00005A1C 6600                       		bne.s	.End				; If so, branch
00005A1E 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
00005A24 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005A2A 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005A30                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005A30 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
00005A36                            
00005A36                            .End:
00005A36 4E75                       		rts
00005A38                            
00005A38                            .ChkBounceUp:
00005A38 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of left sensor
00005A3C 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005A40 4880                       		ext.w	d0				; ''
00005A42 9440                       		sub.w	d0,d2				; ''
00005A44 5542                       		subq.w	#2,d2				; ''
00005A46 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of left sensor
00005A4A 1028 002C                  		move.b	_objColW(a0),d0			; ''
00005A4E 4880                       		ext.w	d0				; ''
00005A50 9640                       		sub.w	d0,d3				; ''
00005A52 4EB8 3C2A                  		jsr	Level_FindBlock			; Get the block located there
00005A56 3011                       		move.w	(a1),d0				; ''
00005A58 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005A5C 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005A60 6700                       		beq.s	.BounceUp			; If so, branch
00005A62                            
00005A62 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of right sensor
00005A66 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005A6A 4880                       		ext.w	d0				; ''
00005A6C 9440                       		sub.w	d0,d2				; ''
00005A6E 5542                       		subq.w	#2,d2				; ''
00005A70 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of right sensor
00005A74 1028 002C                  		move.b	_objColW(a0),d0			; ''
00005A78 4880                       		ext.w	d0				; ''
00005A7A D640                       		add.w	d0,d3				; ''
00005A7C 4EB8 3C2A                  		jsr	Level_FindBlock			; Get the block located there
00005A80 3011                       		move.w	(a1),d0				; ''
00005A82 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005A86 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005A8A 66AA                       		bne.s	.End				; If not, branch
00005A8C                            
00005A8C                            .BounceUp:
00005A8C 588F                       		addq.l	#4,sp				; Don't return to caller
00005A8E                            
00005A8E 317C 1600 001E             		move.w	#$1600,_objYVel(a0)		; Bounce Sonic up
00005A94 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set in air flag
00005A9A 4228 0040                  		clr.b	_objJumping(a0)			; Clear jump flag
00005A9E 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset dash timer
00005AA2 4228 0045                  		clr.b	_objDashFlag(a0)			; Reset dash flag
00005AA6                            
00005AA6                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
00005AA6 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
00005AAC                            
00005AAC 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
00005AB2 6600                       		bne.s	.End2				; If so, branch
00005AB4 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
00005ABA 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005AC0 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005AC6                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005AC6 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
00005ACC                            
00005ACC                            .End2:
00005ACC 4E75                       		rts
00005ACE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005ACE                            ; Check for bars to hang on to
00005ACE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005ACE                            ObjPlayer_ChkHang:
00005ACE 0828 0003 000C             		btst	#3,_objFlags(a0)			; Are we already hanging?
00005AD4 6600                       		bne.s	.End				; If so, branch
00005AD6                            
00005AD6 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005ADA 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005ADE 0442 0018                  		subi.w	#$18,d2				; ''
00005AE2 4EB8 3C2A                  		jsr	Level_FindBlock			; Get the block located there
00005AE6 3011                       		move.w	(a1),d0				; ''
00005AE8 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005AEC 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
00005AF0 6600                       		bne.s	.End				; If not, branch
00005AF2                            
00005AF2 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Clear roll flag
00005AF8 42A8 001C                  		clr.l	_objXVel(a0)			; Stop movement
00005AFC 4268 003A                  		clr.w	_objGVel(a0)			; ''
00005B00 08E8 0003 000C             		bset	#3,_objFlags(a0)			; Set hanging flag
00005B06 117C 000A 0020             		move.b	#$A,_objAnim(a0)			; Set hanging animation
00005B0C 117C 0007 004C             		move.b	#7,_objHangAniTime(a0)		; Animation timer
00005B12                            	;	move.w	_objYPos(a0),d0			; Align with bar
00005B12 0440 0018                  		subi.w	#$18,d0				; ''
00005B16 0240 FFF0                  		andi.w	#$FFF0,d0			; ''
00005B1A 0640 0018                  		addi.w	#$18,d0				; ''
00005B1E 3140 0018                  		move.w	d0,_objYPos(a0)			; ''
00005B22 4228 0041                  		clr.b	_objAngle(a0)			; Reset angle
00005B26 08A8 0001 000D             		bclr	#1,_objRender(a0)			; ''
00005B2C                            
00005B2C                            .End:
00005B2C 4E75                       		rts
00005B2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B2E                            ; Hang onto the bars
00005B2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B2E                            ObjPlayer_Hang:
00005B2E 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005B32 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005B36 0442 0018                  		subi.w	#$18,d2				; ''
00005B3A 4EB8 3C2A                  		jsr	Level_FindBlock			; Get the block located there
00005B3E 3011                       		move.w	(a1),d0				; ''
00005B40 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005B44 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
00005B48 6600                       		bne.s	.FallOff			; If not, branch
00005B4A 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get control press bits
00005B4E 0200 0070                  		andi.b	#$70,d0				; Are we jumping off?
00005B52 6700                       		beq.s	.MoveX				; If not, branch
00005B54                            
00005B54                            .FallOff:
00005B54 08A8 0003 000C             		bclr	#3,_objFlags(a0)			; Stop hanging
00005B5A 0668 0010 0018             		addi.w	#$10,_objYPos(a0)			; Fall off
00005B60 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00005B66 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
00005B6C 4E75                       		rts
00005B6E                            
00005B6E                            .MoveX:
00005B6E 7002                       		moveq	#2,d0				; X speed
00005B70 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Are we going left?
00005B76 6700                       		beq.s	.ChkRight			; If not, branch
00005B78 4440                       		neg.w	d0				; Go the other way
00005B7A 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face to the left
00005B80 08E8 0000 000D             		bset	#0,_objRender(a0)			; ''
00005B86 6000                       		bra.s	.DoMove				; Continue
00005B88                            
00005B88                            .ChkRight:
00005B88 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Are we going left?
00005B8E 6700                       		beq.s	.ResetScr			; If not, branch
00005B90 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face to the right
00005B96 08A8 0000 000D             		bclr	#0,_objRender(a0)			; ''
00005B9C                            
00005B9C                            .DoMove:
00005B9C D168 0014                  		add.w	d0,_objXPos(a0)			; Move
00005BA0 5328 004C                  		subq.b	#1,_objHangAniTime(a0)		; Decrement animation timer
00005BA4 6A00                       		bpl.s	.ResetScr			; If it hasn't run out, branch
00005BA6 117C 0007 004C             		move.b	#7,_objHangAniTime(a0)		; Reset timer
00005BAC 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Increment animation frame
00005BB0 0C28 0004 0022             		cmpi.b	#4,_objAnimFrame(a0)		; Have we reached the last one?
00005BB6 6500                       		bcs.s	.ResetScr			; If not, branch
00005BB8 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation frame
00005BBC                            
00005BBC                            .ResetScr:
00005BBC 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005BC0 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005BC6 6700                       		beq.s	.End				; If so, branch
00005BC8 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005BCA 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005BCE                            
00005BCE                            .ScrollUp:
00005BCE 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005BD2                            
00005BD2                            .End:
00005BD2 4E75                       		rts
00005BD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BD4                            ; Check for electricity
00005BD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BD4                            ObjPlayer_ChkElectric:
00005BD4 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005BD8 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005BDC 4EB8 3C2A                  		jsr	Level_FindBlock			; Get the block located there
00005BE0 3011                       		move.w	(a1),d0				; ''
00005BE2 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005BE6                            
00005BE6 43FA 0000                  		lea	.Blocks(pc),a1			; BLocks to check
00005BEA 7C02                       		moveq	#2,d6				; ''
00005BEC                            
00005BEC                            .ChkBlocks:
00005BEC B059                       		cmp.w	(a1)+,d0			; have we touched this block?
00005BEE 6700                       		beq.s	ObjPlayer_GetHurt		; If so, branch
00005BF0 51CE FFFA                  		dbf	d6,.ChkBlocks			; Loop
00005BF4 4E75                       		rts
00005BF6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BF6 0082 0083 0084             .Blocks:	dc.w	$82, $83, $84
00005BFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BFC                            ; Get Sonic hurt
00005BFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BFC                            ObjPlayer_GetHurt:
00005BFC                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
00005BFC 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005C00 6600                     M 	bne.s	.no_223
00005C02 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005C08 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005C0C 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005C10 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005C14 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005C18                          M .no_223
00005C18 4A28 0042                  		tst.b	_objInvulTime(a0)			; Are we invulnerable?
00005C1C 6600 0000                  		bne.w	.End				; If so, branch
00005C20 4A78 E85E                  		tst.w	ringCount.w			; Does Sonic have any rings?
00005C24 6700 0000                  		beq.w	ObjPlayer_GetKilled		; If not, branch
00005C28 4EB8 1A1C                  		jsr	FindFreeObj.w
00005C2C 6700                       		beq.s	.Hurt
00005C2E 22BC 0000 0000             		move.l	#ObjRingLoss,_objAddress(a1)
00005C34 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
00005C3A 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
00005C40                            
00005C40                            .Hurt:
00005C40 117C 0008 0025             		move.b	#8,_objRoutine(a0)			; Set to hurt routine
00005C46 4EB8 321A                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
00005C4A 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005C4E 08A8 0000 000C             		bclr	#0,_objFlags(a0)			; Allow modes
00005C54 08A8 0003 000C             		bclr	#3,_objFlags(a0)			; Stop hanging
00005C5A 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set the "in air" flag
00005C60 117C 001A 0020             		move.b	#$1A,_objAnim(a0)			; Set to hurt animation
00005C66 117C 0078 0042             		move.b	#$78,_objInvulTime(a0)		; Set invulnerable timer
00005C6C                            
00005C6C 317C FC00 001E             		move.w	#-$400,_objYVel(a0)		; Make Sonic bounce away
00005C72 317C FE00 001C             		move.w	#-$200,_objXVel(a0)		; ''
00005C78 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00005C7E 6700                       		beq.s	.ChkReverse			; If not, branch
00005C80 317C FE00 001E             		move.w	#-$200,_objYVel(a0)		; Make Sonic bounce away slower
00005C86 317C FF00 001C             		move.w	#-$100,_objXVel(a0)
00005C8C                            
00005C8C                            .ChkReverse:
00005C8C 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00005C90 B06A 0014                  		cmp.w	_objXPos(a2),d0			; Is Sonic left of the object that hurt him?
00005C94 6500                       		bcs.s	.ChkSnd				; If so, branch
00005C96 4468 001C                  		neg.w	_objXVel(a0)			; Make Sonic bounce the other way if on the right side
00005C9A                            
00005C9A                            .ChkSnd:
00005C9A 4268 003A                  		clr.w	_objGVel(a0)			; Reset ground velocity
00005C9E                            
00005C9E                            	;	cmpi.l	#ObjSpike,_objAddress(a2)		; Did Sonic hit a spike?
00005C9E                            	;	beq.s	.End				; If not, branch
00005C9E                            		playSnd	#sHurt, 2			; Play hurt sound
00005C9E 11FC 0084 C4BD           M 	move.b	#shurt,(mqueue+((2)-1)).w
00005CA4                            
00005CA4                            .End:
00005CA4 70FF                       		moveq	#-1,d0				; Set return status
00005CA6 4E75                       		rts
00005CA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CA8                            ; Hurt routine
00005CA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CA8                            ObjPlayer_Hurt:
00005CA8 4A38 C76A                  		tst.b	moveCheat.w
00005CAC 6700                       		beq.s	.NoPlacementEnter
00005CAE 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00005CB4 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00005CB6 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00005CBC 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00005CC2 4E75                       		rts
00005CC4                            
00005CC4                            .NoPlacementEnter:
00005CC4 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00005CC8 0668 0030 001E             		addi.w	#$30,_objYVel(a0)			; Apply gravity
00005CCE 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00005CD4 6700                       		beq.s	.NotWater			; If not, branch
00005CD6 0468 0020 001E             		subi.w	#$20,_objYVel(a0)			; Reduce gravity underwater
00005CDC                            
00005CDC                            .NotWater:
00005CDC 117C 001A 0020             		move.b	#$1A,_objAnim(a0)			; Force the hurt animation
00005CE2 6100                       		bsr.s	.ChkStop			; Check if Sonic has hit the ground or the bottom boundary
00005CE4                            
00005CE4 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005CEA 6700                       		beq.s	.Cont				; If so, branch
00005CEC 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005CEE 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005CF2                            
00005CF2                            .ScrollUp:
00005CF2 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005CF6                            
00005CF6                            .Cont:
00005CF6 6100 F80C                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00005CFA 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005CFE 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005D02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D02                            .ChkStop:
00005D02 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get bottom boundary
00005D06 0640 00E0                  		addi.w	#224,d0				; ''
00005D0A B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic hit it?
00005D0E 6D00                       		blt.s	ObjPlayer_GetKilled		; If so, branch
00005D10                            
00005D10 4EB8 301E                  		jsr	PlayerChkCollision		; Check for level collision
00005D14 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is Sonic still in midair?
00005D1A 6600                       		bne.s	.End				; If so, branch
00005D1C                            
00005D1C 7000                       		moveq	#0,d0
00005D1E 3140 001E                  		move.w	d0,_objYVel(a0)			; Stop Sonic's movement
00005D22 3140 001C                  		move.w	d0,_objXVel(a0)			; ''
00005D26 3140 003A                  		move.w	d0,_objGVel(a0)			; ''
00005D2A 1140 000C                  		move.b	d0,_objFlags(a0)			; Allow Sonic to move
00005D2E 1140 0020                  		move.b	d0,_objAnim(a0)			; Reset animation
00005D32 117C 0004 0025             		move.b	#4,_objRoutine(a0)			; Set back to main routine
00005D38                            
00005D38                            .End:
00005D38 4E75                       		rts
00005D3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D3A                            ; Get Sonic killed
00005D3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D3A                            ObjPlayer_GetKilled:
00005D3A                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
00005D3A 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005D3E 6600                     M 	bne.s	.no_225
00005D40 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005D46 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005D4A 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005D4E 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005D52 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005D56                          M .no_225
00005D56 117C 000C 0025             		move.b	#$C,_objRoutine(a0)			; Set to the death routine
00005D5C 4EB8 321A                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
00005D60 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005D64 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set the "in air" flag
00005D6A 117C 0018 0020             		move.b	#$18,_objAnim(a0)			; Set to death animation
00005D70                            
00005D70 317C F900 001E             		move.w	#-$700,_objYVel(a0)		; Make Sonic bounce up
00005D76 4268 001C                  		clr.w	_objXVel(a0)			; Lock Sonic horizontally
00005D7A 4268 003A                  		clr.w	_objGVel(a0)			; ''
00005D7E 31FC FFFF E8DA             		move.w	#$FFFF,camLocked.w		; Lock the camera
00005D84                            
00005D84                            	;	cmpi.l	#ObjSpike,_objAddress(a2)		; Did Sonic hit a spike?
00005D84                            	;	beq.s	.End				; If not, branch
00005D84                            		playSnd	#sDeath,2			; Play death sound
00005D84 11FC 0084 C4BD           M 	move.b	#sdeath,(mqueue+((2)-1)).w
00005D8A                            
00005D8A                            .End:
00005D8A 70FF                       		moveq	#-1,d0				; Set return status
00005D8C 4E75                       		rts
00005D8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D8E                            ; Death routine
00005D8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D8E                            ObjPlayer_Dead:
00005D8E 4A38 C76A                  		tst.b	moveCheat.w
00005D92 6700                       		beq.s	.NoPlacementEnter
00005D94 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00005D9A 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00005D9C 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00005DA2 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00005DA8 4E75                       		rts
00005DAA                            
00005DAA                            .NoPlacementEnter:
00005DAA 117C 0018 0020             		move.b	#$18,_objAnim(a0)			; Force the death animation
00005DB0 0068 8000 000E             		ori.w	#$8000,_objVRAM(a0)		; Force high priority
00005DB6 6100                       		bsr.s	ObjPlayer_ChkBound		; Check for when Sonic goes off screen
00005DB8 4EB8 1D42                  		jsr	ObjectMoveAndFall.w		; Allow movement
00005DBC 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005DC0 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005DC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DC4                            ObjPlayer_ChkBound:
00005DC4 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get bottom boundary
00005DC8 0640 0100                  		addi.w	#$100,d0			; ''
00005DCC B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic hit it?
00005DD0 6C00                       		bge.s	.End				; If not, branch
00005DD2                            
00005DD2 117C 0010 0025             		move.b	#$10,_objRoutine(a0)			; Go to gone routine
00005DD8 117C 003C 0043             		move.b	#60,_objDeathTimer(a0)		; Set death timer to 1 second
00005DDE                            
00005DDE                            .End:
00005DDE 4E75                       		rts
00005DE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DE0                            ; Wait for level reload or game/time over
00005DE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DE0                            ObjPlayer_Gone:
00005DE0 4A28 0043                  		tst.b	_objDeathTimer(a0)
00005DE4 6700                       		beq.s	.End
00005DE6 5328 0043                  		subq.b	#1,_objDeathTimer(a0)		; Decrement the death counter
00005DEA 6600                       		bne.s	.End				; If it hasn't run out, branch
00005DEC 50F8 E906                  		st	lvlReload.w			; Reload the level
00005DF0                            
00005DF0                            .End:
00005DF0 4E75                       		rts
00005DF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DF2                            ; Display Sonic's sprite
00005DF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DF2                            ObjPlayer_Display:
00005DF2 1028 0042                  		move.b	_objInvulTime(a0),d0		; Get invulnerability timer
00005DF6 6700                       		beq.s	.Display			; If it's 0, branch
00005DF8 5328 0042                  		subq.b	#1,_objInvulTime(a0)		; Decrement invulnerability timer
00005DFC E648                       		lsr.w	#3,d0				; Can Sonic's sprite be displayed?
00005DFE 6500                       		bcs.s	.Display			; If so, branch
00005E00                            	removeSprite	a0,a1,1				; Remove sprite if displayed
00005E00 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005E04 6700                     M 	beq.s	.yes_227
00005E06 3268 000A                M 	move.w	_objdrawprev(a0),a1
00005E0A 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00005E10 3268 0008                M 	move.w	_objdrawnext(a0),a1
00005E14 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
00005E1A                          M .no_227
00005E1A 42A8 0008                M 	clr.l	_objdrawnext(a0)
00005E1E                          M .yes_227
00005E1E 4E75                       		rts
00005E20                            
00005E20                            .Display:
00005E20                            	displaySprite	2,a0,a1,1			; Add sprite if not already being displayed
00005E20 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005E24 6600                     M 	bne.s	.no_228
00005E26 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005E2C 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005E30 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005E34 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005E38 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005E3C                          M .no_228
00005E3C 4E75                       		rts
00005E3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E3E                            ; Load Sonic's DPLCs
00005E3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E3E                            ObjPlayer_LoadDPLCs:
00005E3E 45F9 0000 0000             		lea	DPLC_ObjPlayer,a2		; DPLCs
00005E44 383C F000                  		move.w	#$F000,d4			; VRAM location
00005E48 2C3C 0000 0000             		move.l	#ArtUnc_Sonic,d6		; Art
00005E4E 4EF8 1CE8                  		jmp	LoadObjDPLCs.w			; Load DPLCs
00005E52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E52                            ; Animate Sonic's sprite
00005E52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E52                            ObjPlayer_Animate:
00005E52 43F9 0000 0000             		lea	Ani_ObjPlayer,a1			; Animation script
00005E58 7000                       		moveq	#0,d0
00005E5A 1028 0020                  		move.b	_objAnim(a0),d0			; Get animation ID
00005E5E B028 0021                  		cmp.b	_objPrevAnim(a0),d0			; Has it changed?
00005E62 6700                       		beq.s	.Run				; If not, branch
00005E64 1140 0021                  		move.b	d0,_objPrevAnim(a0)			; Save the new ID
00005E68 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00005E6C 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005E70 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00005E76                            
00005E76                            .Run:
00005E76 D040                       		add.w	d0,d0				; Turn ID into offset
00005E78 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00005E7C 1011                       		move.b	(a1),d0				; Get first byte
00005E7E 6B00                       		bmi.s	.WalkRunAnim			; If this is a special animation, branch
00005E80 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00005E84 0201 0001                  		andi.b	#1,d1				; Only get horizontal flip bit
00005E88 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
00005E8E 8328 000D                  		or.b	d1,_objRender(a0)			; Set flip bits
00005E92 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00005E96 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00005E98 1140 0023                  		move.b	d0,_objAnimTimer(a0)		; Set new animation timer
00005E9C                            
00005E9C                            .GetFrame:
00005E9C 7200                       		moveq	#0,d1
00005E9E 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get current value in the script
00005EA2 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00005EA6 0C00 00FD                  		cmpi.b	#$FD,d0				; Is it a command value?
00005EAA 6400                       		bhs.s	.CmdReset			; If so, branch
00005EAC                            
00005EAC                            .Next:
00005EAC 1140 0010                  		move.b	d0,_objFrame(a0)			; Set mapping frame ID
00005EB0 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Advance into the animation script
00005EB4                            
00005EB4                            .Wait:
00005EB4 4E75                       		rts
00005EB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005EB6                            .CmdReset:
00005EB6 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00005EB8 6600                       		bne.s	.CmdJump			; If not, branch
00005EBA 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00005EBE 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00005EC2 60E8                       		bra.s	.Next				; Continue
00005EC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005EC4                            .CmdJump:
00005EC4 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00005EC6 6600                       		bne.s	.CmdSetAnim			; If not, branch
00005EC8 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00005ECC 9128 0022                  		sub.b	d0,_objAnimFrame(a0)		; Go back
00005ED0 9200                       		sub.b	d0,d1				; ''
00005ED2 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00005ED6 60D4                       		bra.s	.Next				; Continue
00005ED8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005ED8                            .CmdSetAnim:
00005ED8 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00005EDA 6600                       		bne.s	.CmdEnd				; If not, branch
00005EDC 1171 1002 0020             		move.b	2(a1,d1.w),_objAnim(a0)		; Set new animation ID
00005EE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005EE2                            .CmdEnd:
00005EE2 4E75                       		rts
00005EE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005EE4                            .WalkRunAnim:
00005EE4 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00005EE8 6ACA                       		bpl.s	.Wait				; If it hasn't run out, branch
00005EEA 5200                       		addq.b	#1,d0				; Is the animation walking/running?
00005EEC 6600 0000                  		bne.w	.RollAnim			; If not, branch
00005EF0                            
00005EF0 7000                       		moveq	#0,d0
00005EF2 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Is Sonic tumbling in the air?
00005EF6 6600 0000                  		bne.w	.TumbleAnim			; If so, branch
00005EFA                            
00005EFA 7200                       		moveq	#0,d1				; Intial flip bits
00005EFC 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005F00 6B00                       		bmi.s	.ChkStatus			; If it's negative, branch
00005F02 6700                       		beq.s	.ChkStatus			; If it's zero, branch
00005F04 5300                       		subq.b	#1,d0				; Decrement angle if it's positive
00005F06                            
00005F06                            .ChkStatus:
00005F06 1428 0028                  		move.b	_objStatus(a0),d2			; Get status
00005F0A 0202 0001                  		andi.b	#1,d2				; Is Sonic mirrored horizontally?
00005F0E 6600                       		bne.s	.ChkFlip			; If so, branch
00005F10 4600                       		not.b	d0				; Reverse angle
00005F12                            
00005F12                            .ChkFlip:
00005F12 0600 0010                  		addi.b	#$10,d0				; Shift angle
00005F16 6A00                       		bpl.s	.SetFlags			; If it's positive, branch
00005F18 7203                       		moveq	#3,d1				; Flags to flip Sonic's sprite
00005F1A                            
00005F1A                            .SetFlags:
00005F1A 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits
00005F20 B302                       		eor.b	d1,d2				; Flip
00005F22 8528 000D                  		or.b	d2,_objRender(a0)			; Set in render flags
00005F26                            
00005F26 0828 0005 0028             		btst	#5,_objStatus(a0)			; Is Sonic pushing?
00005F2C 6600 0000                  		bne.w	.DoPushAnim			; If so, branch
00005F30                            
00005F30 E808                       		lsr.b	#4,d0				; Divide angle by $10
00005F32 0200 0006                  		andi.b	#6,d0				; Get angle section
00005F36                            
00005F36 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00005F3A 6A00                       		bpl.s	.GetAnim			; If it's already positive, branch
00005F3C 4442                       		neg.w	d2				; Force it to be positive
00005F3E                            
00005F3E                            .GetAnim:
00005F3E 43F9 0000 0000             		lea	SonicAni_Sprint,a1		; Sprinting animation
00005F44 4A00                       		tst.b	d0
00005F46 6600                       		bne.s	.ChkRun
00005F48 0C42 0C00                  		cmpi.w	#$C00,d2			; Is Sonic sprinting?
00005F4C 6400                       		bcc.s	.SkipWalk			; If so, branch
00005F4E                            
00005F4E                            .ChkRun:
00005F4E 43F9 0000 0000             		lea	SonicAni_Run,a1			; Running animation
00005F54 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic running?
00005F58 6400                       		bcc.s	.SkipWalk			; If so, branch
00005F5A 43F9 0000 0000             		lea	SonicAni_Walk,a1		; Walking animation
00005F60 1200                       		move.b	d0,d1				; Multiply angle section ID by 3
00005F62 E209                       		lsr.b	#1,d1				; ''
00005F64 D001                       		add.b	d1,d0				; ''
00005F66                            
00005F66                            .SkipWalk:
00005F66 D000                       		add.b	d0,d0				; Double the offset
00005F68 1600                       		move.b	d0,d3				; Copy the oofset
00005F6A 4442                       		neg.w	d2				; Get animation speed
00005F6C 0642 0800                  		addi.w	#$800,d2			; ''
00005F70 6A00                       		bpl.s	.SetTimer			; ''
00005F72 7400                       		moveq	#0,d2				; ''
00005F74                            
00005F74                            .SetTimer:
00005F74 E04A                       		lsr.w	#8,d2				; ''
00005F76 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
00005F7A 6100 FF20                  		bsr.w	.GetFrame			; Get the next frame
00005F7E D728 0010                  		add.b	d3,_objFrame(a0)			; Add angle offset
00005F82 4E75                       		rts
00005F84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F84                            .TumbleAnim:
00005F84 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Get flip angle
00005F88 7200                       		moveq	#0,d1
00005F8A 1428 0028                  		move.b	_objStatus(a0),d2			; Get status
00005F8E 0202 0001                  		andi.b	#1,d2				; Are we are facing left?
00005F92 6600                       		bne.s	.TumbleLeft			; If so, branch
00005F94                            
00005F94 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits
00005F9A 0600 000B                  		addi.b	#$B,d0				; Get map frame
00005F9E 80FC 0016                  		divu.w	#$16,d0				; ''
00005FA2 0600 0068                  		addi.b	#$68,d0				; ''
00005FA6 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00005FAA 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005FAE 4E75                       		rts
00005FB0                            
00005FB0                            .TumbleLeft:
00005FB0 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits
00005FB6 4A28 0048                  		tst.b	_objFlipTurned(a0)			; Is flipping inverted?
00005FBA 6700                       		beq.s	.NotInverted			; If not, branch
00005FBC 0028 0001 000D             		ori.b	#1,_objRender(a0)			; Face left
00005FC2 0600 000B                  		addi.b	#$B,d0				; Get map frame
00005FC6 6000                       		bra.s	.SetLeftFrame			; Continue
00005FC8                            
00005FC8                            .NotInverted:
00005FC8 0028 0003 000D             		ori.b	#3,_objRender(a0)			; Face left and be upside down
00005FCE 4400                       		neg.b	d0				; Get map frame
00005FD0 0600 008F                  		addi.b	#$8F,d0				; ''
00005FD4                            
00005FD4                            .SetLeftFrame:
00005FD4 80FC 0016                  		divu.w	#$16,d0				; Continue getting map frame
00005FD8 0600 0068                  		addi.b	#$68,d0				; ''
00005FDC 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00005FE0 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005FE4 4E75                       		rts
00005FE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005FE6                            .RollAnim:
00005FE6 5200                       		addq.b	#1,d0				; Is the animation rolling?
00005FE8 6600                       		bne.s	.PushAnim			; If not, branch
00005FEA                            
00005FEA 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00005FEE 6A00                       		bpl.s	.GetAnim2			; If it's already negative, branch
00005FF0 4442                       		neg.w	d2				; Force it to be negative
00005FF2                            
00005FF2                            .GetAnim2:
00005FF2 43F9 0000 0000             		lea	SonicAni_Roll2,a1		; Use fast animation
00005FF8 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic rolling fast enough?
00005FFC 6400                       		bcc.s	.PrepareTimer			; If so, branch
00005FFE 43F9 0000 0000             		lea	SonicAni_Roll,a1		; Use slower animation
00006004                            
00006004                            .PrepareTimer:
00006004 4442                       		neg.w	d2				; Get animation speed
00006006 0642 0400                  		addi.w	#$400,d2			; ''
0000600A 6A00                       		bpl.s	.SetTimer2			; ''
0000600C 7400                       		moveq	#0,d2				; ''
0000600E                            
0000600E                            .SetTimer2:
0000600E E04A                       		lsr.w	#8,d2				; ''
00006010 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
00006014                            
00006014 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00006018 0201 0001                  		andi.b	#1,d1				; Get horizontal flip flag only
0000601C 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits in render flags
00006022 8328 000D                  		or.b	d1,_objRender(a0)			; Set new flip bits
00006026                            
00006026 6000 FE74                  		bra.w	.GetFrame			; Get the next frame
0000602A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000602A                            .PushAnim:
0000602A 5200                       		addq.b	#1,d0				; Is the animation rolling?
0000602C 6600                       		bne.s	.HangAnim			; If not, branch
0000602E                            
0000602E                            .DoPushAnim:
0000602E 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00006032 6B00                       		bmi.s	.GetAnim3			; If it's already negative, branch
00006034 4442                       		neg.w	d2				; Force it to be negative
00006036                            
00006036                            .GetAnim3:
00006036 0642 0800                  		addi.w	#$800,d2			; Get animation speed
0000603A 6A00                       		bpl.s	.SetTimer3			; ''
0000603C 7400                       		moveq	#0,d2				; ''
0000603E                            
0000603E                            .SetTimer3:
0000603E EC4A                       		lsr.w	#6,d2				; ''
00006040 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
00006044 43F9 0000 0000             		lea	SonicAni_Push,a1		; Pushing animation
0000604A 6000 FE50                  		bra.w	.GetFrame			; Get the next frame
0000604E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000604E                            .HangAnim:
0000604E 7200                       		moveq	#0,d1
00006050 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get animation frame
00006054 1171 1001 0010             		move.b	1(a1,d1.w),_objFrame(a0)		; Set map frame
0000605A 4228 0023                  		clr.b	_objAnimTimer(a0)			; Clear animation timer
0000605E 4E75                       		rts
00006060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006060                            ; Handle debug placement mode
00006060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006060                            DebugPlacement:
00006060 7000                       		moveq	#0,d0
00006062 1038 E8DD                  		move.b	debugMode.w,d0		; Get debug placement mode routine
00006066 0240 0002                  		andi.w	#2,d0				; Only allow 0, 2, 4, and 6
0000606A D040                       		add.w	d0,d0				; Double it
0000606C 4EBB 0000                  		jsr	.Routines(pc,d0.w)		; Go to the correct routine
00006070                            	nextObject
00006070 3068 0004                M 	movea.w	_objnext(a0),a0
00006074 2250                     M 	move.l	_objaddress(a0),a1
00006076 4ED1                     M 	jmp	(a1)
00006078                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006078                            .Routines:
00006078 6000 0000                  		bra.w	Debug_Init			; Initialization(00*2)
0000607C 6000 0000                  		bra.w	Debug_Main			; Main		(02*2)
00006080                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006080                            Debug_Init:
00006080 5438 E8DD                  		addq.b	#2,debugMode.w		; Next routine
00006084 4228 0010                  		clr.b	_objFrame(a0)			; Reset mapping frame
00006088 4228 0020                  		clr.b	_objAnim(a0)			; Reset animation
0000608C 4268 003A                  		clr.w	_objGVel(a0)			; Reset ground velocity
00006090 4278 E8DA                  		clr.w	camLocked.w			; Unlock the camera
00006094 4228 004B                  		clr.b	_objBallMode(a0)			; Reset ball mode
00006098 4228 0041                  		clr.b	_objAngle(a0)			; Reset angle
0000609C 117C 0004 0025             		move.b	#4,_objRoutine(a0)			; Set routine to main
000060A2                            
000060A2 3028 003C                  		move.w	_objInteract(a0),d0		; Get object interacted with last
000060A6 6700                       		beq.s	.NoInteract			; If there is none, branch
000060A8 3240                       		movea.w	d0,a1
000060AA 08A9 0003 0028             		bclr	#3,_objStatus(a1)			; Clear flags
000060B0 08A9 0005 0028             		bclr	#5,_objStatus(a1)			; ''
000060B6 4268 003C                  		clr.w	_objInteract(a0)			; No more interaction
000060BA                            
000060BA                            .NoInteract:
000060BA 4228 000C                  		clr.b	_objFlags(a0)			; Reset flags
000060BE 4228 0028                  		clr.b	_objStatus(a0)			; Reset status
000060C2 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
000060C8 117C 0001 0010             		move.b	#1,_objFrame(a0)			; Display the standing frame
000060CE 6100 FD6E                  		bsr.w	ObjPlayer_LoadDPLCs		; Load DPLCs
000060D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000060D2                            Debug_Main:
000060D2 6100 EE20                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
000060D6 6100                       		bsr.s	Debug_Control			; Control
000060D8                            	displaySprite	2,a0,a2,1
000060D8 4A68 0008                M 	tst.w	_objdrawnext(a0)
000060DC 6600                     M 	bne.s	.no_230
000060DE 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
000060E4 3478 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a2
000060E8 314A 000A                M 	move.w	a2,_objdrawprev(a0)
000060EC 3548 0008                M 	move.w	a0,_objdrawnext(a2)
000060F0 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
000060F4                          M .no_230
000060F4 4E75                       		rts
000060F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000060F6                            Debug_Control:
000060F6 7006                       		moveq	#6,d0				; Speed
000060F8 0838 0000 C742             		btst	#0,ctrlHoldP1.w			; Is up being held?
000060FE 6700                       		beq.s	.NoUp				; If not, branch
00006100 9168 0018                  		sub.w	d0,_objYPos(a0)			; Move up
00006104                            
00006104                            .NoUp:
00006104 0838 0001 C742             		btst	#1,ctrlHoldP1.w			; Is down being held?
0000610A 6700                       		beq.s	.NoDown				; If not, branch
0000610C D168 0018                  		add.w	d0,_objYPos(a0)			; Move down
00006110                            
00006110                            .NoDown:
00006110 0838 0002 C742             		btst	#2,ctrlHoldP1.w			; Is left being held?
00006116 6700                       		beq.s	.NoLeft				; If not, branch
00006118 9168 0014                  		sub.w	d0,_objXPos(a0)			; Move left
0000611C                            
0000611C                            .NoLeft:
0000611C 0838 0003 C742             		btst	#3,ctrlHoldP1.w			; Is right being held?
00006122 6700                       		beq.s	.NoRight			; If not, branch
00006124 D168 0014                  		add.w	d0,_objXPos(a0)			; Move right
00006128                            
00006128                            .NoRight:
00006128 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
0000612E 6700                       		beq.s	.ChkWrap			; If not, branch
00006130 7000                       		moveq	#0,d0
00006132 11C0 E8DD                  		move.b	d0,debugMode.w		; Disable debug placement mode
00006136 1140 0016                  		move.b	d0,_objXPos+2(a0)			; Reset X subpixel
0000613A 1140 001A                  		move.b	d0,_objYPos+2(a0)			; Reset Y subpixel
0000613E 3140 001C                  		move.w	d0,_objXVel(a0)			; Reset X velocity
00006142 3140 001E                  		move.w	d0,_objYVel(a0)			; Reset Y velocity
00006146 3140 003A                  		move.w	d0,_objGVel(a0)			; Reset ground velocity
0000614A 0228 0001 0028             		andi.b	#1,_objStatus(a0)			; Reset status
00006150 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00006156 20BC 0000 4E14             		move.l	#ObjPlayer,_objAddress(a0)		; Use normal Sonic object
0000615C 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00006162 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
00006168                            
00006168                            .ChkWrap:
00006168 4E75                       		rts
0000616A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000616A                            ; Data
0000616A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000616A                            Map_ObjPlayer:
0000616A                            		include	"Objects/Player/Mappings.asm"
0000616A                            Map_79b3:
0000616A 0000                       Map_79b3_0: 	dc.w Map_79b3_8-Map_79b3
0000616C 0000                       Map_79b3_2: 	dc.w Map_79b3_A-Map_79b3
0000616E 0000                       Map_79b3_4: 	dc.w Map_79b3_12-Map_79b3
00006170 0000                       Map_79b3_6: 	dc.w Map_79b3_1A-Map_79b3
00006172 0000                       Map_79b3_8: 	dc.b $0, $0
00006174 0001                       Map_79b3_A: 	dc.b $0, $1
00006176 FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
0000617C 0001                       Map_79b3_12: 	dc.b $0, $1
0000617E FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00006184 0001                       Map_79b3_1A: 	dc.b $0, $1
00006186 FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
0000618C                            	even
0000618C                            		even
0000618C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000618C                            DPLC_ObjPlayer:
0000618C                            		include	"Objects/Player/DPLCs.asm"
0000618C                            DPLC_bf0f:
0000618C 0000                       DPLC_bf0f_0: 	dc.w DPLC_bf0f_8-DPLC_bf0f
0000618E 0000                       DPLC_bf0f_2: 	dc.w DPLC_bf0f_A-DPLC_bf0f
00006190 0000                       DPLC_bf0f_4: 	dc.w DPLC_bf0f_E-DPLC_bf0f
00006192 0000                       DPLC_bf0f_6: 	dc.w DPLC_bf0f_12-DPLC_bf0f
00006194 0000                       DPLC_bf0f_8: 	dc.b $0, $0
00006196 0001                       DPLC_bf0f_A: 	dc.b $0, $1
00006198 3000                       	dc.b $30, $0
0000619A 0001                       DPLC_bf0f_E: 	dc.b $0, $1
0000619C 3008                       	dc.b $30, $8
0000619E 0001                       DPLC_bf0f_12: 	dc.b $0, $1
000061A0 3004                       	dc.b $30, $4
000061A2                            	even
000061A2                            		even
000061A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000061A2                            Ani_ObjPlayer:
000061A2                            		include	"Objects/Player/Animations.asm"
000061A2                            ; ---------------------------------------------------------------------------
000061A2                            ; Animation script - Sonic
000061A2                            ; ---------------------------------------------------------------------------
000061A2                            SonicAniData:
000061A2 0000                       		dc.w SonicAni_Blank-SonicAniData
000061A4 0000                       		dc.w SonicANi_Blank-SonicAniData
000061A6 0000                       		dc.w SonicANi_Flap-SonicAniData
000061A8 0000                       		dc.w SonicANi_Flap-SonicAniData
000061AA 0000                       		dc.w SonicANi_Blank-SonicAniData
000061AC 0000                       		dc.w SonicANi_Blank-SonicAniData
000061AE 0000                       		dc.w SonicANi_Blank-SonicAniData
000061B0 0000                       		dc.w SonicANi_Blank-SonicAniData
000061B2 0000                       		dc.w SonicANi_Blank-SonicAniData
000061B4 0000                       		dc.w SonicANi_Blank-SonicAniData
000061B6 0000                       		dc.w SonicANi_Blank-SonicAniData
000061B8 0000                       		dc.w SonicANi_Blank-SonicAniData
000061BA 0000                       		dc.w SonicANi_Blank-SonicAniData
000061BC 0000                       		dc.w SonicANi_Blank-SonicAniData
000061BE 0000                       		dc.w SonicANi_Blank-SonicAniData
000061C0 0000                       		dc.w SonicANi_Blank-SonicAniData
000061C2 0000                       		dc.w SonicANi_Blank-SonicAniData
000061C4 0000                       		dc.w SonicANi_Blank-SonicAniData
000061C6 0000                       		dc.w SonicANi_Blank-SonicAniData
000061C8 0000                       		dc.w SonicANi_Blank-SonicAniData
000061CA 0000                       		dc.w SonicANi_Blank-SonicAniData
000061CC 0000                       		dc.w SonicANi_Blank-SonicAniData
000061CE 0000                       		dc.w SonicANi_Blank-SonicAniData
000061D0 0000                       		dc.w SonicANi_Blank-SonicAniData
000061D2 0000                       		dc.w SonicANi_Blank-SonicAniData
000061D4 0000                       		dc.w SonicANi_Blank-SonicAniData
000061D6 0000                       		dc.w SonicANi_Blank-SonicAniData
000061D8 0000                       		dc.w SonicANi_Blank-SonicAniData
000061DA 0000                       		dc.w SonicANi_Blank-SonicAniData
000061DC 0000                       		dc.w SonicANi_Blank-SonicAniData
000061DE 0000                       		dc.w SonicANi_FlapB-SonicAniData
000061E0 0101 FD00                  SonicAni_Blank:		dc.b 1, 1, $FD, 0
000061E4                            		even
000061E4 03FD 1E                    SonicANi_Flap:		dc.b	3,	$FD,	$1E
000061E7 0301 0203 0201 FD00        SonicANi_FlapB:		dc.b	3,	1,	2,	3,	2,	1, $FD,	0
000061EF                            sonicani_sprint:
000061EF                            sonicani_run:
000061EF                            sonicani_walk:
000061EF                            sonicani_roll2:
000061EF                            sonicani_roll:
000061EF                            sonicani_push:
000061F0 00                         		even
000061F0                            ; =========================================================================================================================================================
000061F0                            		include	"Objects/Ring/Code.asm"		; Ring loss object
000061F0                            ; =========================================================================================================================================================
000061F0                            ; Water surface object
000061F0                            ; =========================================================================================================================================================
000061F0                            		rsset	_objLvlSSTs
000061F0                            
000061F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000061F0                            ObjRingLoss:
000061F0 2248                       		movea.l	a0,a1
000061F2 7A00                       		moveq	#0,d5
000061F4 3A3C 0001                  		move.w	#1,d5
000061F8 7020                       		moveq	#32,d0
000061FA BA40                       		cmp.w	d0,d5
000061FC 6500                       		bcs.s	.BelowMax
000061FE 3A00                       		move.w	d0,d5
00006200                            
00006200                            .BelowMax:
00006200 5345                       		subq.w	#1,d5
00006202 47F9 0000 0000             		lea	ObjLostRing_Speeds,a3
00006208 6000                       		bra.s	.MakeRings
0000620A                            
0000620A                            .Loop:
0000620A 4EB8 1A1C                  		jsr	FindFreeObj.w
0000620E 6700                       		beq.s	.ResetCounter
00006210                            
00006210                            .MakeRings:
00006210 22BC 0000 0000             		move.l	#ObjLostRing,_objAddress(a1)
00006216 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
0000621C 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
00006222 237C 0000 0000 0010        		move.l	#Map_ObjLostRing,_objMapping(a1)	; Mappings
0000622A 337C 26B4 000E             		move.w	#$26B4,_objVRAM(a1)		; Tile properties
00006230 137C 0004 000D             		move.b	#4,_objRender(a1)			; Render flags
00006236                            	displaySprite	3,a1,a2,0			; Priority
00006236 337C C172 0008           M 	move.w	#objdisplay+(3*dsize),_objdrawnext(a1)
0000623C 3478 C17C                M 	move.w	objdisplay+dprev+(3*dsize).w,a2
00006240 334A 000A                M 	move.w	a2,_objdrawprev(a1)
00006244 3549 0008                M 	move.w	a1,_objdrawnext(a2)
00006248 31C9 C17C                M 	move.w	a1,objdisplay+dprev+(3*dsize).w
0000624C                          M .no_231
0000624C 137C 0008 0017             		move.b	#8,_objDrawW(a1)			; Sprite width
00006252 137C 0008 001B             		move.b	#8,_objDrawH(a1)			; Sprite height
00006258 137C 0008 002C             		move.b	#8,_objColW(a1)			; Collision width
0000625E 137C 0008 002D             		move.b	#8,_objColH(a1)			; Collision height
00006264 335B 001C                  		move.w	(a3)+,_objXVel(a1)
00006268 335B 001E                  		move.w	(a3)+,_objYVel(a1)
0000626C 51CD FF9C                  		dbf	d5,.Loop
00006270 11FC 00FF E864             		move.b	#-1,ringLossAnimT.w
00006276                            
00006276                            .ResetCounter:
00006276 4278 E85E                  		clr.w	ringCount.w
0000627A 11FC 0001 E867             		move.b	#1,hudUpdateRings.w
00006280                            		playSnd	#sRingLoss, 2
00006280 11FC 008D C4BD           M 	move.b	#sringloss,(mqueue+((2)-1)).w
00006286                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006286                            ObjLostRing:
00006286 4EB8 1D28                  		jsr	ObjectMove.w
0000628A 0668 0018 001E             		addi.w	#$18,_objYVel(a0)
00006290 6B00                       		bmi.s	.ChkCol
00006292 1038 C75B                  		move.b	(frameCounter+3).w,d0
00006296 D048                       		add.w	a0,d0
00006298 0200 0006                  		andi.b	#6,d0
0000629C 6600                       		bne.s	.ChkCol
0000629E 4EB8 343A                  		jsr	ObjCheckFloorDist
000062A2 4A41                       		tst.w	d1
000062A4 6A00                       		bpl.s	.ChkCol
000062A6 D368 0018                  		add.w	d1,_objYPos(a0)
000062AA 3028 001E                  		move.w	_objYVel(a0),d0
000062AE E440                       		asr.w	#2,d0
000062B0 9168 001E                  		sub.w	d0,_objYVel(a0)
000062B4 4468 001E                  		neg.w	_objYVel(a0)
000062B8                            
000062B8                            .ChkCol:
000062B8 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
000062BC 3478 E876                  		movea.w	playerPtrP1.w,a2		; Player object
000062C0 4EB8 1D62                  		jsr	CheckObjInRange.w		; Is the player in range?
000062C4 4A40                       		tst.w	d0				; ''
000062C6 6700                       		beq.s	.ChkDel				; If not, branch
000062C8 0C2A 0069 0042             		cmpi.b	#105,_objInvulTime(a2)
000062CE 6400                       		bhs.s	.ChkDel
000062D0 6000                       		bra.s	ObjLostRing_Collect
000062D2                            
000062D2                            .ChkDel:
000062D2 4A38 E864                  		tst.b	ringLossAnimT.w
000062D6 6700 0000                  		beq.w	ObjLostRing_Delete
000062DA 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get max camera Y position
000062DE 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
000062E2 B068 0018                  		cmp.w	_objYPos(a0),d0			; Have we touched the bottom boundary?
000062E6 6D00                       		blt.s	ObjLostRing_Delete		; If so, branch
000062E8                            	nextObject
000062E8 3068 0004                M 	movea.w	_objnext(a0),a0
000062EC 2250                     M 	move.l	_objaddress(a0),a1
000062EE 4ED1                     M 	jmp	(a1)
000062F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000062F0                            .RangeData:
000062F0 FFF0 0020                  		dc.w	-$10, $20
000062F4 FFF0 0020                  		dc.w	-$10, $20
000062F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000062F8                            ObjLostRing_Collect:
000062F8                            	removeSprite	a0,a1,0
000062F8 3268 000A                M 	move.w	_objdrawprev(a0),a1
000062FC 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00006302 3268 0008                M 	move.w	_objdrawnext(a0),a1
00006306 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
0000630C                          M .no_234
0000630C 42A8 0008                M 	clr.l	_objdrawnext(a0)
00006310                          M .yes_234
00006310                            	displaySprite	1,a0,a1,0
00006310 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
00006316 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
0000631A 3149 000A                M 	move.w	a1,_objdrawprev(a0)
0000631E 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006322 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
00006326                          M .no_235
00006326 4EB8 4346                  		jsr	CollectRing
0000632A 20BC 0000 0000             		move.l	#ObjLostRing_Sparkle,(a0)
00006330                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006330                            ObjLostRing_Sparkle:
00006330 43F9 0000 0000             		lea	Ani_ObjRing,a1
00006336 4EB8 1C42                  		jsr	AnimateObject.w
0000633A 4A28 0025                  		tst.b	_objRoutine(a0)
0000633E 6600                       		bne.s	ObjLostRing_Delete
00006340                            	nextObject
00006340 3068 0004                M 	movea.w	_objnext(a0),a0
00006344 2250                     M 	move.l	_objaddress(a0),a1
00006346 4ED1                     M 	jmp	(a1)
00006348                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006348                            ObjLostRing_Delete:
00006348 4EB8 1A4C                  		jsr	DeleteObject.w
0000634C                            	nextObject
0000634C 3068 0004                M 	movea.w	_objnext(a0),a0
00006350 2250                     M 	move.l	_objaddress(a0),a1
00006352 4ED1                     M 	jmp	(a1)
00006354                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006354                            ; Ring Spawn Array
00006354                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006354                            ObjLostRing_Speeds:
00006354 FF3C FC14 00C4 FC14 FDC8+  		dc.w	$FF3C,$FC14,$00C4,$FC14,$FDC8,$FCB0,$0238,$FCB0
00006364 FCB0 FDC8 0350 FDC8 FC14+  		dc.w	$FCB0,$FDC8,$0350,$FDC8,$FC14,$FF3C,$03EC,$FF3C
00006374 FC14 00C4 03EC 00C4 FCB0+  		dc.w	$FC14,$00C4,$03EC,$00C4,$FCB0,$0238,$0350,$0238
00006384 FDC8 0350 0238 0350 FF3C+  		dc.w	$FDC8,$0350,$0238,$0350,$FF3C,$03EC,$00C4,$03EC
00006394 FF9E FE0A 0062 FE0A FEE4+  		dc.w	$FF9E,$FE0A,$0062,$FE0A,$FEE4,$FE58,$011C,$FE58
000063A4 FE58 FEE4 01A8 FEE4 FE0A+  		dc.w	$FE58,$FEE4,$01A8,$FEE4,$FE0A,$FF9E,$01F6,$FF9E
000063B4 FE0A 0062 01F6 0062 FE58+  		dc.w	$FE0A,$0062,$01F6,$0062,$FE58,$011C,$01A8,$011C
000063C4 FEE4 01A8 011C 01A8 FF9E+  		dc.w	$FEE4,$01A8,$011C,$01A8,$FF9E,$01F6,$0062,$01F6
000063D4                            		even
000063D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000063D4                            ; Data
000063D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000063D4                            Map_ObjLostRing:
000063D4                            		include	"Objects/Ring/Mappings.asm"
000063D4                            ; --------------------------------------------------------------------------------
000063D4                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
000063D4                            ; --------------------------------------------------------------------------------
000063D4                            
000063D4                            SME_k4ulR:	
000063D4 0000 0000                  		dc.w SME_k4ulrA-SME_k4ulR, SME_k4ulrC-SME_k4ulR	
000063D8 0000 0000                  		dc.w SME_k4ulr14-SME_k4ulR, SME_k4ulr1C-SME_k4ulR	
000063DC 0000                       		dc.w SME_k4ulr24-SME_k4ulR	
000063DE 0001                       SME_k4ulrA:	dc.b 0, 1	
000063E0 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8
000063E6 0001                       SME_k4ulrC:	dc.b 0, 1	
000063E8 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
000063EE 0001                       SME_k4ulr14:	dc.b 0, 1	
000063F0 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
000063F6 0001                       SME_k4ulr1C:	dc.b 0, 1	
000063F8 F805 0804 FFF8             		dc.b $F8, 5, 8, 4, $FF, $F8	
000063FE 0001                       SME_k4ulr24:	dc.b 0, 1	
00006400 F805 1004 FFF8             		dc.b $F8, 5, $10, 4, $FF, $F8	
00006406                            		even
00006406                            		even
00006406                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006406                            Ani_ObjRing:
00006406 0000                       		dc.w	.Ani0-Ani_ObjRing
00006408 0501 0203 04FC             .Ani0:		dc.b	5, 1, 2, 3, 4, $FC
0000640E                            		even
0000640E                            ; =========================================================================================================================================================
0000640E                            		include	"Objects/Explosion/Code.asm"	; Explosion object
0000640E                            ; =========================================================================================================================================================
0000640E                            ; Explosion object
0000640E                            ; =========================================================================================================================================================
0000640E =00000003                  EXPLODE_ANI	EQU	3
0000640E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000640E                            ObjBossExplode:
0000640E                            		playSnd	#sBomb, 2			; Play explosion sound
0000640E 11FC 0099 C4BD           M 	move.b	#sbomb,(mqueue+((2)-1)).w
00006414 6000                       		bra.s	ObjExplosion_Init		; Continue
00006416                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006416                            ObjExplosion:
00006416                            		playSnd	#sBreakItem, 2			; Play explosion sound
00006416 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
0000641C                            
0000641C                            ObjExplosion_Init:
0000641C 20BC 0000 0000             		move.l	#ObjExplosion_Main,_objAddress(a0)	; Next routine
00006422 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00006428 317C 86C0 000E             		move.w	#$86C0,_objVRAM(a0)		; Tile properties
0000642E 217C 0000 0000 0010        		move.l	#Map_ObjExplosion,_objMapping(a0)	; Mappings
00006436                            	displaySprite	1,a0,a1,0			; Priority
00006436 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
0000643C 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
00006440 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006444 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006448 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
0000644C                          M .no_240
0000644C 117C 000C 0017             		move.b	#$C,_objDrawW(a0)			; Sprite width
00006452 117C 000C 001B             		move.b	#$C,_objDrawH(a0)			; Sprite height
00006458 117C 0003 0023             		move.b	#EXPLODE_ANI,_objAnimTimer(a0)	; Animation timer
0000645E 4228 0010                  		clr.b	_objFrame(a0)			; Mapping frame
00006462                            		
00006462                            ObjExplosion_Main:
00006462 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00006466 6A00                       		bpl.s	.Display			; If it hasn't run out, branch
00006468 117C 0003 0023             		move.b	#EXPLODE_ANI,_objAnimTimer(a0)	; Reset animation timer
0000646E 5228 0010                  		addq.b	#1,_objFrame(a0)			; Next frame
00006472 0C28 0005 0010             		cmpi.b	#5,_objFrame(a0)			; Has it reached the last frame?
00006478 6600                       		bne.s	.Display			; If not, branch
0000647A 4EB8 1A4C                  		jsr	DeleteObject.w
0000647E                            		
0000647E                            .Display:
0000647E                            	nextObject
0000647E 3068 0004                M 	movea.w	_objnext(a0),a0
00006482 2250                     M 	move.l	_objaddress(a0),a1
00006484 4ED1                     M 	jmp	(a1)
00006486                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006486                            ; Data
00006486                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006486                            Map_ObjExplosion:
00006486                            		include	"Objects/Explosion/Mappings.asm"
00006486                            ; --------------------------------------------------------------------------------
00006486                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006486                            ; --------------------------------------------------------------------------------
00006486                            
00006486                            SME_PS_OI:	
00006486 0000 0000                  		dc.w SME_PS_OI_A-SME_PS_OI, SME_PS_OI_12-SME_PS_OI	
0000648A 0000 0000                  		dc.w SME_PS_OI_1A-SME_PS_OI, SME_PS_OI_22-SME_PS_OI	
0000648E 0000                       		dc.w SME_PS_OI_3C-SME_PS_OI	
00006490 0001                       SME_PS_OI_A:	dc.b 0, 1	
00006492 F809 0000 FFF4             		dc.b $F8, 9, 0, 0, $FF, $F4	
00006498 0001                       SME_PS_OI_12:	dc.b 0, 1	
0000649A F00F 0020 FFF0             		dc.b $F0, $F, 0, $20, $FF, $F0	
000064A0 0001                       SME_PS_OI_1A:	dc.b 0, 1	
000064A2 F00F 0030 FFF0             		dc.b $F0, $F, 0, $30, $FF, $F0	
000064A8 0004                       SME_PS_OI_22:	dc.b 0, 4	
000064AA EC0A 0006 FFEC             		dc.b $EC, $A, 0, 6, $FF, $EC	
000064B0 EC05 000F 0004             		dc.b $EC, 5, 0, $F, 0, 4	
000064B6 0405 180F FFEC             		dc.b 4, 5, $18, $F, $FF, $EC	
000064BC FC0A 1806 FFFC             		dc.b $FC, $A, $18, 6, $FF, $FC	
000064C2 0004                       SME_PS_OI_3C:	dc.b 0, 4	
000064C4 EC0A 0013 FFEC             		dc.b $EC, $A, 0, $13, $FF, $EC	
000064CA EC05 001C 0004             		dc.b $EC, 5, 0, $1C, 0, 4	
000064D0 0405 181C FFEC             		dc.b 4, 5, $18, $1C, $FF, $EC	
000064D6 FC0A 1813 FFFC             		dc.b $FC, $A, $18, $13, $FF, $FC	
000064DC                            		even
000064DC                            		even
000064DC                            ; =========================================================================================================================================================
000064DC                            		include	"Objects/Water Surface/Code.asm"	; Water surface object
000064DC                            ; =========================================================================================================================================================
000064DC                            ; Water surface object
000064DC                            ; =========================================================================================================================================================
000064DC                            		rsset	_objLvlSSTs
000064DC =00000030                  _objSurfPause	rs.b	1			; Animation stop flag
000064DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000064DC                            ObjWaterSurface:
000064DC 20BC 0000 0000             		move.l	#ObjWaterSurface_Main,_objAddress(a0)	; Next routine
000064E2 217C 0000 0000 0010        		move.l	#Map_ObjWaterSurface,_objMapping(a0)	; Mappings
000064EA 317C 8690 000E             		move.w	#$8690,_objVRAM(a0)		; Tile properties
000064F0 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
000064F6                            	displaySprite	0,a0,a1,0			; Priority
000064F6 317C C15A 0008           M 	move.w	#objdisplay+(0*dsize),_objdrawnext(a0)
000064FC 3278 C164                M 	move.w	objdisplay+dprev+(0*dsize).w,a1
00006500 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006504 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006508 31C8 C164                M 	move.w	a0,objdisplay+dprev+(0*dsize).w
0000650C                          M .no_242
0000650C 117C 0080 0017             		move.b	#$80,_objDrawW(a0)			; Sprite width
00006512 117C 0020 001B             		move.b	#$20,_objDrawH(a0)			; Sprite height
00006518                            
00006518                            ObjWaterSurface_Main:
00006518 3238 E900                  		move.w	waterYPos.w,d1		; Get water height
0000651C 5D41                       		subq.w	#6,d1				; Shift it
0000651E 3141 0018                  		move.w	d1,_objYPos(a0)			; Set Y position
00006522                            
00006522 4A28 0030                  		tst.b	_objSurfPause(a0)			; Is the animation paused?
00006526 6600                       		bne.s	.ChkUnpause			; If so, branch
00006528 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
0000652E 6700                       		beq.s	.Animate			; If not, branch
00006530 5628 0010                  		addq.b	#3,_objFrame(a0)			; Use different frames
00006534 50E8 0030                  		st	_objSurfPause(a0)			; Pause the animation
00006538 6000                       		bra.s	.Animate			; Continue
0000653A                            
0000653A                            .ChkUnpause:
0000653A 4A38 C75E                  		tst.b	pauseFlag.w			; Is the game paused?
0000653E 6600                       		bne.s	.Animate			; If so, branch
00006540 4228 0030                  		clr.b	_objSurfPause(a0)			; Resume animation
00006544 5728 0010                  		subq.b	#3,_objFrame(a0)			; Use normal frames
00006548                            
00006548                            .Animate:
00006548 43FA 0000                  		lea	.AniScript(pc),a1		; Get animation script
0000654C 7200                       		moveq	#0,d1
0000654E 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get animation script frame
00006552 1171 1000 0010             		move.b	(a1,d1.w),_objFrame(a0)		; Set mapping frame
00006558 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Next frame in animation script
0000655C 0228 003F 0022             		andi.b	#$3F,_objAnimFrame(a0)		; Loop in necessary
00006562                            	nextObject
00006562 3068 0004                M 	movea.w	_objnext(a0),a0
00006566 2250                     M 	move.l	_objaddress(a0),a1
00006568 4ED1                     M 	jmp	(a1)
0000656A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000656A                            .AniScript:
0000656A 0001 0001 0001 0001 0001+  		dc.b	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
0000657A 0102 0102 0102 0102 0102+  		dc.b	1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2
0000658A 0201 0201 0201 0201 0201+  		dc.b	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1
0000659A 0100 0100 0100 0100 0100+  		dc.b	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
000065AA 00                         		even
000065AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000065AA                            ; Data
000065AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000065AA                            Map_ObjWaterSurface:
000065AA                            		include	"Objects/Water Surface/Mappings.asm"
000065AA                            MapConv_obj1B:
000065AA 0000                       	dc.w	byte_11178-MapConv_obj1B
000065AC 0000                       	dc.w	byte_11188-MapConv_obj1B
000065AE 0000                       	dc.w	byte_11198-MapConv_obj1B
000065B0 0000                       	dc.w	byte_111A8-MapConv_obj1B
000065B2 0000                       	dc.w	byte_111C7-MapConv_obj1B
000065B4 0000                       	dc.w	byte_111E6-MapConv_obj1B
000065B6                            
000065B6 0003                       byte_11178:	dc.w 3
000065B8 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
000065BE FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
000065C4 FD0D 0000 0020             	dc.w $FD0D, 0, $20
000065CA                            
000065CA 0003                       byte_11188:	dc.w 3
000065CC FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
000065D2 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
000065D8 FD0D 0008 0020             	dc.w $FD0D, 8, $20
000065DE                            
000065DE 0003                       byte_11198:	dc.w 3
000065E0 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
000065E6 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
000065EC FD0D 0800 0020             	dc.w $FD0D, $800, $20
000065F2                            
000065F2 0006                       byte_111A8:	dc.w 6
000065F4 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
000065FA FD0D 0000 FFC0             	dc.w $FD0D, 0, $FFC0
00006600 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00006606 FD0D 0000 0000             	dc.w $FD0D, 0, 0
0000660C FD0D 0000 0020             	dc.w $FD0D, 0, $20
00006612 FD0D 0000 0040             	dc.w $FD0D, 0, $40
00006618                            
00006618 0006                       byte_111C7:	dc.w 6
0000661A FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
00006620 FD0D 0008 FFC0             	dc.w $FD0D, 8, $FFC0
00006626 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
0000662C FD0D 0008 0000             	dc.w $FD0D, 8, 0
00006632 FD0D 0008 0020             	dc.w $FD0D, 8, $20
00006638 FD0D 0008 0040             	dc.w $FD0D, 8, $40
0000663E                            
0000663E 0006                       byte_111E6:	dc.w 6
00006640 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
00006646 FD0D 0800 FFC0             	dc.w $FD0D, $800, $FFC0
0000664C FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
00006652 FD0D 0800 0000             	dc.w $FD0D, $800, 0
00006658 FD0D 0800 0020             	dc.w $FD0D, $800, $20
0000665E FD0D 0800 0040             	dc.w $FD0D, $800, $40
00006664                            
00006664                            	even
00006664                            		even
00006664                            ; =========================================================================================================================================================
00006664                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006664                            		include	"Objects/Monitor/Code.asm"	; Monitor object
00006664                            ; =========================================================================================================================================================
00006664                            ; Monitor object
00006664                            ; =========================================================================================================================================================
00006664                            		rsset	_objLvlSSTs
00006664 =00000030                  _objMonFall	rs.b	1				; Fall flag
00006664                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006664                            ObjEnemy:
00006664 7000                               moveq   #0, d0
00006666 1028 0025                          move.b  _objRoutine(a0),d0
0000666A 303B 0000                          move.w  .Index(pc,d0.w),d0
0000666E 4EFB 0000                          jmp     .Index(pc,d0.w)
00006672                            
00006672                            .Index:
00006672 0000                               dc.w    ObjEnemy_Init-.Index
00006674 0000                               dc.w    ObjEnemy_Down-.Index
00006676 0000                               dc.w    ObjEnemy_Up-.Index
00006678                            
00006678                            ObjEnemy_Init:
00006678 5428 0025                          addq.b  #2, _objRoutine(a0)
0000667C 217C 0000 0000 0010                move.l  #Map_ObjMonitor,_objMapping(a0)
00006684 317C 0588 000E                     move.w	#$588,_objVRAM(a0)
0000668A 117C 0004 000D             		move.b	#4,_objRender(a0)
00006690                                    displaySprite	3,a0,a1,0			; Priority
00006690 317C C172 0008           M 	move.w	#objdisplay+(3*dsize),_objdrawnext(a0)
00006696 3278 C17C                M 	move.w	objdisplay+dprev+(3*dsize).w,a1
0000669A 3149 000A                M 	move.w	a1,_objdrawprev(a0)
0000669E 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000066A2 31C8 C17C                M 	move.w	a0,objdisplay+dprev+(3*dsize).w
000066A6                          M .no_244
000066A6                            
000066A6                            ObjEnemy_Down:
000066A6 0C68 00C8 0018                     cmpi.w  #200,   _objYPos(a0)
000066AC 6500                               blo.s   .cont
000066AE 5428 0025                          addq.b  #2, _ObjRoutine(a0)
000066B2                                .cont:
000066B2 5268 0018                          add.w   #1, _objYPos(a0)
000066B6                                    nextObject
000066B6 3068 0004                M 	movea.w	_objnext(a0),a0
000066BA 2250                     M 	move.l	_objaddress(a0),a1
000066BC 4ED1                     M 	jmp	(a1)
000066BE                            
000066BE                            ObjEnemy_Up:
000066BE 0C68 0018 0018                     cmpi.w  #24,   _objYPos(a0)
000066C4 6200                               bhi.s   .cont
000066C6 5528 0025                          subq.b  #2, _ObjRoutine(a0)
000066CA                                .cont:
000066CA 5368 0018                          sub.w   #1, _objYPos(a0)
000066CE                                    nextObject
000066CE 3068 0004                M 	movea.w	_objnext(a0),a0
000066D2 2250                     M 	move.l	_objaddress(a0),a1
000066D4 4ED1                     M 	jmp	(a1)
000066D6                            
000066D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000066D6                            ; Data
000066D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000066D6                            Map_ObjMonitor:
000066D6                            		include	"Objects/Monitor/Mappings.asm"
000066D6                            ; --------------------------------------------------------------------------------
000066D6                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
000066D6                            ; --------------------------------------------------------------------------------
000066D6                            
000066D6                            SME_7TKK1:	
000066D6 0000 0000                  		dc.w SME_7TKK1_10-SME_7TKK1, SME_7TKK1_18-SME_7TKK1	
000066DA 0000 0000                  		dc.w SME_7TKK1_26-SME_7TKK1, SME_7TKK1_34-SME_7TKK1	
000066DE 0000 0000                  		dc.w SME_7TKK1_42-SME_7TKK1, SME_7TKK1_50-SME_7TKK1	
000066E2 0000 0000                  		dc.w SME_7TKK1_5E-SME_7TKK1, SME_7TKK1_6C-SME_7TKK1	
000066E6 0001                       SME_7TKK1_10:	dc.b 0, 1	
000066E8 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000066EE 0002                       SME_7TKK1_18:	dc.b 0, 2	
000066F0 F505 0018 FFF8             		dc.b $F5, 5, 0, $18, $FF, $F8	
000066F6 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000066FC 0002                       SME_7TKK1_26:	dc.b 0, 2	
000066FE F505 001C FFF8             		dc.b $F5, 5, 0, $1C, $FF, $F8	
00006704 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
0000670A 0002                       SME_7TKK1_34:	dc.b 0, 2	
0000670C F505 2020 FFF8             		dc.b $F5, 5, $20, $20, $FF, $F8	
00006712 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006718 0002                       SME_7TKK1_42:	dc.b 0, 2	
0000671A F505 0024 FFF8             		dc.b $F5, 5, 0, $24, $FF, $F8	
00006720 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006726 0002                       SME_7TKK1_50:	dc.b 0, 2	
00006728 F505 0028 FFF8             		dc.b $F5, 5, 0, $28, $FF, $F8	
0000672E EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006734 0002                       SME_7TKK1_5E:	dc.b 0, 2	
00006736 F505 002C FFF8             		dc.b $F5, 5, 0, $2C, $FF, $F8	
0000673C EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006742 0001                       SME_7TKK1_6C:	dc.b 0, 1	
00006744 FF0D 0010 FFF0             		dc.b $FF, $D, 0, $10, $FF, $F0	
0000674A                            		even
0000674A                            Ani_ObjMonitor:
0000674A                            		include	"Objects/Monitor/Animations.asm"
0000674A                            ; ---------------------------------------------------------------------------
0000674A                            ; Animation script - monitors
0000674A                            ; ---------------------------------------------------------------------------
0000674A 0000                       		dc.w .Static-Ani_ObjMonitor
0000674C 0000                       		dc.w .Eggman-Ani_ObjMonitor
0000674E 0000                       		dc.w .Rings-Ani_ObjMonitor
00006750 0000                       		dc.w .Shoes-Ani_ObjMonitor
00006752 0000                       		dc.w .Shield-Ani_ObjMonitor
00006754 0000                       		dc.w .Stars-Ani_ObjMonitor
00006756 0000                       		dc.w .Destroyed-Ani_ObjMonitor
00006758 0100 01FF 00               .Static:	dc.b 1, 0, 1, $FF, 0
0000675D 0100 0202 0102 02FF 00     .Eggman:	dc.b 1, 0, 2, 2, 1, 2, 2, $FF, 0
00006766 0100 0303 0103 03FF 00     .Rings:		dc.b 1, 0, 3, 3, 1, 3, 3, $FF, 0
0000676F 0100 0404 0104 04FF 00     .Shoes:		dc.b 1, 0, 4, 4, 1, 4, 4, $FF, 0
00006778 0100 0505 0105 05FF 00     .Shield:	dc.b 1, 0, 5, 5, 1, 5, 5, $FF, 0
00006781 0100 0606 0106 06FF 00     .Stars:		dc.b 1, 0, 6, 6, 1, 6, 6, $FF, 0
0000678A 0100 0107 FE01 00          .Destroyed:	dc.b 1, 0, 1, 7, $FE, 1, 0
00006792 00                         		even
00006792                            ; =========================================================================================================================================================
00006792                            		include	"Objects/Spikes/Code.asm"		; Spike object
00006792                            ; ===========================================================================
00006792                            ; Spike object
00006792                            ; ===========================================================================
00006792                            		rsset	_objLvlSSTs
00006792 =00000030                  _objSpikeX	rs.w	1
00006792 =00000032                  _objSpikeY	rs.w	1
00006792 =00000034                  _objSpkMvOff	rs.w	1
00006792 =00000036                  _objSpkMvState	rs.w	1
00006792 =00000038                  _objSpkMvTime	rs.w	1
00006792                            ; ===========================================================================
00006792                            ObjSpike:
00006792 7000                       		moveq	#0,d0
00006794 1028 0025                  		move.b	_objRoutine(a0),d0
00006798 4EBB 0000                  		jsr	ObjSpike_Index(pc,d0.w)
0000679C                            	nextObject
0000679C 3068 0004                M 	movea.w	_objnext(a0),a0
000067A0 2250                     M 	move.l	_objaddress(a0),a1
000067A2 4ED1                     M 	jmp	(a1)
000067A4                            ; ===========================================================================
000067A4                            ObjSpike_Index:
000067A4 6000 0000                  		bra.w ObjSpike_Init
000067A8 6000 0000                  		bra.w ObjSpike_Upright
000067AC 6000 0000                  		bra.w ObjSpike_Sideways
000067B0 6000 0000                  		bra.w ObjSpike_UpsideDown
000067B4                            ; ===========================================================================
000067B4                            ;ObjSpike_InitData:
000067B4                            ;		dc.b $10,$10	; 0	- Upright or ceiling spikes
000067B4                            ;		dc.b $10,$10	; 2	- Sideways spikes
000067B4                            ; ===========================================================================
000067B4                            ObjSpike_Init:
000067B4 5828 0025                  		addq.b	#4,_objRoutine(a0)
000067B8 217C 0000 0000 0010        		move.l	#Map_ObjSpike,_objMapping(a0)
000067C0 317C 06A8 000E             		move.w	#$6A8,_objVRAM(a0)
000067C6 0028 0004 000D             		ori.b	#4,_objRender(a0)
000067CC                            	displaySprite	4,a0,a1,0			; Priority
000067CC 317C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a0)
000067D2 3278 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a1
000067D6 3149 000A                M 	move.w	a1,_objdrawprev(a0)
000067DA 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000067DE 31C8 C184                M 	move.w	a0,objdisplay+dprev+(4*dsize).w
000067E2                          M .no_248
000067E2 1028 0024                  		move.b	_objSubtype(a0),d0
000067E6 0228 000F 0024             		andi.b	#$F,_objSubtype(a0)
000067EC 0240 00F0                  		andi.w	#$F0,d0
000067F0 7210                       		moveq	#$10,d1
000067F2 1141 0017                  		move.b	d1,_objDrawW(a0)
000067F6 1141 002C                  		move.b	d1,_objColW(a0)
000067FA 1141 001B                  		move.b	d1,_objDrawH(a0)
000067FE 1141 002D                  		move.b	d1,_objColH(a0)
00006802 E848                       		lsr.w	#4,d0
00006804 1140 0010                  		move.b	d0,_objFrame(a0)
00006808 0C00 0001                  		cmpi.b	#1,d0
0000680C 6600                       		bne.s	.ChkUpsideDown
0000680E 5828 0025                  		addq.b	#4,_objRoutine(a0)
00006812 317C 06AC 000E             		move.w	#$6AC,_objVRAM(a0)
00006818                            
00006818                            .ChkUpsideDown:
00006818 0828 0001 0028             		btst	#1,_objStatus(a0)
0000681E 6700                       		beq.s	.SavePos
00006820 117C 000C 0025             		move.b	#$C,_objRoutine(a0)
00006826                            
00006826                            .SavePos:
00006826 3168 0014 0030             		move.w	_objXPos(a0),_objSpikeX(a0)
0000682C 3168 0018 0032             		move.w	_objYPos(a0),_objSpikeY(a0)
00006832                            
00006832 6100 0000                  		bsr.w	MoveSpikes		; make the object move
00006836 0C28 0001 0010             		cmpi.b	#1,_objFrame(a0)		; is object type $1x ?
0000683C 6700                       		beq.s	ObjSpike_SideWays	; if yes, branch
0000683E                            ; ===========================================================================
0000683E                            ; Upright spikes
0000683E                            ; ===========================================================================
0000683E                            ObjSpike_Upright:
0000683E 6100 0000                  		bsr.w	MoveSpikes
00006842 7200                       		moveq	#0,d1
00006844 1228 0017                  		move.b	_objDrawW(a0),d1
00006848 0641 000B                  		addi.w	#$B,d1
0000684C 7400                       		moveq	#0,d2
0000684E 1428 001B                  		move.b	_objDrawH(a0),d2
00006852 3602                       		move.w	d2,d3
00006854 5243                       		addq.w	#1,d3
00006856 3828 0014                  		move.w	_objXPos(a0),d4
0000685A 4EB8 457A                  		jsr	SolidObject
0000685E 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)
00006864 6700                       		beq.s	ObjSpike_UprightEnd
00006866 3278 E876                  		movea.w	playerPtrP1.w,a1
0000686A 6100 0000                  		bsr.w	Touch_ChkHurt2
0000686E                            
0000686E                            ObjSpike_UprightEnd:
0000686E 3028 0030                  		move.w	_objSpikeX(a0),d0
00006872 4EF8 2000                  		jmp	CheckObjActive.w
00006876                            ; ===========================================================================
00006876                            ; Sideways spikes
00006876                            ; ===========================================================================
00006876                            ObjSpike_Sideways:
00006876 3F28 0014                  		move.w	_objXPos(a0),-(sp)	
0000687A 6100 0000                  		bsr.w	MoveSpikes
0000687E 7200                       		moveq	#0,d1
00006880 1228 0017                  		move.b	_objDrawW(a0),d1
00006884 0641 000B                  		addi.w	#$B,d1
00006888 7400                       		moveq	#0,d2
0000688A 1428 001B                  		move.b	_objDrawH(a0),d2
0000688E 3602                       		move.w	d2,d3
00006890 5243                       		addq.w	#1,d3
00006892 381F                       		move.w	(sp)+,d4
00006894 4EB8 457A                  		jsr	SolidObject
00006898 0806 0000                  		btst	#cTouchSideBit,d6
0000689C 6700                       		beq.s	ObjSpike_SidewaysEnd
0000689E 3278 E876                  		movea.w	playerPtrP1.w,a1
000068A2 6100 0000                  		bsr.w	Touch_ChkHurt2
000068A6                            
000068A6                            ObjSpike_SidewaysEnd:
000068A6 3028 0030                  		move.w	_objSpikeX(a0),d0
000068AA 4EF8 2000                  		jmp	CheckObjActive.w
000068AE                            ; ===========================================================================
000068AE                            ; Upside down spikes
000068AE                            ; ===========================================================================
000068AE                            ObjSpike_UpsideDown:
000068AE 6100 0000                  		bsr.w	MoveSpikes
000068B2 7200                       		moveq	#0,d1
000068B4 1228 0017                  		move.b	_objDrawW(a0),d1
000068B8 0641 000B                  		addi.w	#$B,d1
000068BC 7400                       		moveq	#0,d2
000068BE 1428 001B                  		move.b	_objDrawH(a0),d2
000068C2 3602                       		move.w	d2,d3
000068C4 5243                       		addq.w	#1,d3
000068C6 3828 0014                  		move.w	_objXPos(a0),d4
000068CA 4EB8 457A                  		jsr	SolidObject
000068CE 0806 0002                  		btst	#cTouchBtmBit,d6
000068D2 6700                       		beq.s	ObjSpike_UpsideDownEnd
000068D4 3278 E876                  		movea.w	playerPtrP1.w,a1
000068D8 6100 0000                  		bsr.w	Touch_ChkHurt2
000068DC                            
000068DC                            ObjSpike_UpsideDownEnd:
000068DC 3028 0030                  		move.w	_objSpikeX(a0),d0
000068E0 4EF8 2000                  		jmp	CheckObjActive.w
000068E4                            ; ===========================================================================
000068E4                            Touch_ChkHurt2:
000068E4 4A29 0042                  		tst.b	_objInvulTime(a1)			; is Sonic invincible?
000068E8 6600                       		bne.s	.End				; if yes, branch
000068EA 0C29 0008 0025             		cmpi.b	#8,_objRoutine(a1)
000068F0 6700                       		beq.s	.End
000068F2 2629 0018                  		move.l	_objYPos(a1),d3
000068F6 3029 001E                  		move.w	_objYVel(a1),d0
000068FA 48C0                       		ext.l	d0
000068FC E180                       		asl.l	#8,d0
000068FE 9680                       		sub.l	d0,d3
00006900 2343 0018                  		move.l	d3,_objYPos(a1)
00006904 2448                       		movea.l	a0,a2
00006906 2049                       		movea.l	a1,a0
00006908 4EB8 5BFC                  		jsr	ObjPlayer_GetHurt
0000690C 204A                       		movea.l	a2,a0
0000690E                            
0000690E                            .End:
0000690E 4E75                       		rts
00006910                            ; ===========================================================================
00006910                            MoveSpikes:	
00006910 7000                       		moveq	#0,d0
00006912 1028 0024                  		move.b	_objSubtype(a0),d0
00006916 D040                       		add.w	d0,d0
00006918 4EFB 0000                  		jmp	MoveSpikes_Behaviors(pc,d0.w)
0000691C                            ; ===========================================================================
0000691C                            MoveSpikes_Behaviors:
0000691C 6000                       		bra.s MoveSpikes_Still
0000691E 6000                       		bra.s MoveSpikes_Vertical
00006920 6000                       		bra.s MoveSpikes_Horizontal
00006922                            ; ===========================================================================
00006922                            MoveSpikes_Still:
00006922 4E75                       		rts			; don't move the object
00006924                            ; ===========================================================================
00006924                            MoveSpikes_Vertical:
00006924 6100 0000                  		bsr.w	MoveSpikes_Delay
00006928 7000                       		moveq	#0,d0
0000692A 1028 0034                  		move.b	_objSpkMvOff(a0),d0
0000692E D068 0032                  		add.w	_objSpikeY(a0),d0
00006932 3140 0018                  		move.w	d0,_objYPos(a0)	; move the object vertically
00006936 4E75                       		rts
00006938                            ; ===========================================================================
00006938                            MoveSpikes_Horizontal:
00006938 6100 0000                  		bsr.w	MoveSpikes_Delay
0000693C 7000                       		moveq	#0,d0
0000693E 1028 0034                  		move.b	_objSpkMvOff(a0),d0
00006942 D068 0030                  		add.w	_objSpikeX(a0),d0
00006946 3140 0014                  		move.w	d0,_objXPos(a0)	; move the object horizontally
0000694A 4E75                       		rts
0000694C                            ; ===========================================================================
0000694C                            MoveSpikes_Delay:
0000694C 4A68 0038                  		tst.w	_objSpkMvTime(a0)		; is time delay	= zero?
00006950 6700                       		beq.s	MoveSpikes_ChkDir		; if yes, branch
00006952 5368 0038                  		subq.w	#1,_objSpkMvTime(a0)	; subtract 1 from time delay
00006956 6600                       		bne.s	locret_CFE6
00006958 4A28 000D                  		tst.b	_objRender(a0)
0000695C 6A00                       		bpl.s	locret_CFE6
0000695E                            		playSnd	#sSpikeMove, 2		; Play spike move sound
0000695E 11FC 008B C4BD           M 	move.b	#sspikemove,(mqueue+((2)-1)).w
00006964 6000                       		bra.s	locret_CFE6
00006966                            ; ===========================================================================
00006966                            MoveSpikes_ChkDir:
00006966 4A68 0036                  		tst.w	_objSpkMvState(a0)
0000696A 6700                       		beq.s	MoveSpikes_Retract
0000696C 0468 0800 0034             		subi.w	#$800,_objSpkMvOff(a0)
00006972 6400                       		bcc.s	locret_CFE6
00006974 317C 0000 0034             		move.w	#0,_objSpkMvOff(a0)
0000697A 317C 0000 0036             		move.w	#0,_objSpkMvState(a0)
00006980 317C 003C 0038             		move.w	#60,_objSpkMvTime(a0)	; set time delay to 1 second
00006986 6000                       		bra.s	locret_CFE6
00006988                            ; ===========================================================================
00006988                            MoveSpikes_Retract:
00006988 0668 0800 0034             		addi.w	#$800,_objSpkMvOff(a0)
0000698E 0C68 2000 0034             		cmpi.w	#$2000,_objSpkMvOff(a0)
00006994 6500                       		bcs.s	locret_CFE6
00006996 317C 2000 0034             		move.w	#$2000,_objSpkMvOff(a0)
0000699C 317C 0001 0036             		move.w	#1,_objSpkMvState(a0)
000069A2 317C 003C 0038             		move.w	#60,_objSpkMvTime(a0)	; set time delay to 1 second
000069A8                            
000069A8                            locret_CFE6:
000069A8 4E75                       		rts
000069AA                            ; ===========================================================================
000069AA                            ; Spike object mappings
000069AA                            ; ===========================================================================
000069AA                            Map_ObjSpike:
000069AA                            	include "Objects/Spikes/Mappings.asm"
000069AA                            ; --------------------------------------------------------------------------------
000069AA                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
000069AA                            ; --------------------------------------------------------------------------------
000069AA                            
000069AA                            SME_5AG23:	
000069AA 0000 0000                  		dc.w SME_5AG23_4-SME_5AG23, SME_5AG23_1E-SME_5AG23	
000069AE 0004                       SME_5AG23_4:	dc.b 0, 4	
000069B0 F003 0000 FFF0             		dc.b $F0, 3, 0, 0, $FF, $F0	
000069B6 F003 0000 FFF8             		dc.b $F0, 3, 0, 0, $FF, $F8	
000069BC F003 0000 0000             		dc.b $F0, 3, 0, 0, 0, 0	
000069C2 F003 0000 0008             		dc.b $F0, 3, 0, 0, 0, 8	
000069C8 0004                       SME_5AG23_1E:	dc.b 0, 4	
000069CA F00C 0000 FFF0             		dc.b $F0, $C, 0, 0, $FF, $F0	
000069D0 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
000069D6 000C 0000 FFF0             		dc.b 0, $C, 0, 0, $FF, $F0	
000069DC 080C 0000 FFF0             		dc.b 8, $C, 0, 0, $FF, $F0	
000069E2                            		even
000069E2                            ; ===========================================================================
000069E2                            		include	"Objects/Spring/Code.asm"		; Spring object
000069E2                            ; =========================================================================================================================================================
000069E2                            ; Spring object
000069E2                            ; =========================================================================================================================================================
000069E2                            		rsset	_objLvlSSTs
000069E2 =00000030                  _objSprSpd		rs.w	1				; Spring strength
000069E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000069E2                            ObjSpring:
000069E2 217C 0000 0000 0010        		move.l	#Map_ObjSpring,_objMapping(a0)		; Mappings
000069EA 317C 05BA 000E             		move.w	#$5BA,_objVRAM(a0)			; Tile properties
000069F0 0028 0004 000D             		ori.b	#4,_objRender(a0)			; Render flags
000069F6 117C 0010 0017             		move.b	#$10,_objDrawW(a0)			; Sprite width
000069FC 117C 0008 001B             		move.b	#8,_objDrawH(a0)			; Sprite height
00006A02 117C 000E 002C             		move.b	#$1C/2,_objColW(a0)		; Collision width
00006A08                            	displaySprite	4,a0,a1,0			; Priority
00006A08 317C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a0)
00006A0E 3278 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a1
00006A12 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006A16 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006A1A 31C8 C184                M 	move.w	a0,objdisplay+dprev+(4*dsize).w
00006A1E                          M .no_250
00006A1E                            		
00006A1E 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006A22 E648                       		lsr.w	#3,d0				; Turn into offset
00006A24 0240 000E                  		andi.w	#$E,d0				; ''
00006A28 4EFB 0000                  		jmp	.Subtypes(pc,d0.w)		; Jump to it
00006A2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A2C                            .Subtypes:
00006A2C 6000                       		bra.s .Init_Up				; Up
00006A2E 6000                       		bra.s .Init_Horizontal			; Horizontal
00006A30 6000                       		bra.s .Init_Down			; Down
00006A32 6000                       		bra.s .Init_DiagonallyUp		; Diagonally up
00006A34 6000                       		bra.s .Init_DiagonallyDown		; Diagonally down
00006A36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A36                            .Init_Horizontal:
00006A36 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Animation
00006A3C 117C 0002 0010             		move.b	#2,_objFrame(a0)			; Mapping frame
00006A42 317C 05CA 000E             		move.w	#$5CA,_objVRAM(a0)			; Tile properties
00006A48 117C 0008 0017             		move.b	#8,_objDrawW(a0)			; Sprite width
00006A4E 117C 0010 001B             		move.b	#$10,_objDrawH(a0)			; Sprite height
00006A54 117C 000E 002C             		move.b	#$1C/2,_objColW(a0)		; Collision width
00006A5A 20BC 0000 0000             		move.l	#ObjSpring_Horizontal,_objAddress(a0)	; Next routine
00006A60 6000                       		bra.s	.Init_Common			; Continue
00006A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A62                            .Init_Down:
00006A62 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Flip vertically
00006A68 20BC 0000 0000             		move.l	#ObjSpring_Down,_objAddress(a0)	; Next routine
00006A6E 6000                       		bra.s	.Init_Common			; Continue
00006A70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A70                            .Init_DiagonallyUp:
00006A70 117C 0004 0020             		move.b	#4,_objAnim(a0)			; Animation
00006A76 117C 0004 0010             		move.b	#4,_objFrame(a0)			; Map frame
00006A7C 317C 05D9 000E             		move.w	#$5D9,_objVRAM(a0)			; Tile properties
00006A82 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyUp,_objAddress(a0); Next routine
00006A88 6000                       		bra.s	.Init_Common			; Continue
00006A8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A8A                            .Init_DiagonallyDown:
00006A8A 117C 0004 0020             		move.b	#4,_objAnim(a0)			; Animation
00006A90 117C 0006 0010             		move.b	#6,_objFrame(a0)			; Map frame
00006A96 317C 05D9 000E             		move.w	#$5D9,_objVRAM(a0)			; Tile properties
00006A9C 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Flip vertically
00006AA2 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyDown,_objAddress(a0); Next routine
00006AA8 6000                       		bra.s	.Init_Common			; Continue
00006AAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006AAA                            .Init_Up:
00006AAA 20BC 0000 0000             		move.l	#ObjSpring_Up,_objAddress(a0)		; Next routine
00006AB0                            
00006AB0                            .Init_Common:
00006AB0 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006AB4 0240 0002                  		andi.w	#2,d0				; Turn into offset
00006AB8 317B 0000 0030             		move.w	.Strengths(pc,d0.w),_objSprSpd(a0)	; Get spring strength
00006ABE 0800 0001                  		btst	#1,d0				; Is the spring supposed to be yellow?
00006AC2 6700                       		beq.s	.NotYellow			; If not, branch
00006AC4 08E8 0005 000E             		bset	#5,_objVRAM(a0)			; Make the spring yellow
00006ACA                            
00006ACA                            .NotYellow:
00006ACA                            	nextObject
00006ACA 3068 0004                M 	movea.w	_objnext(a0),a0
00006ACE 2250                     M 	move.l	_objaddress(a0),a1
00006AD0 4ED1                     M 	jmp	(a1)
00006AD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006AD2                            .Strengths:
00006AD2 F000                       		dc.w	-$1000				; Strength of red spring
00006AD4 F600                       		dc.w	-$A00				; Strength of yellow spring
00006AD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006AD6                            ObjSpring_Up:
00006AD6 323C 001A                  		move.w	#27-1,d1			; Width
00006ADA 343C 0008                  		move.w	#16/2,d2			; Height
00006ADE 3602                       		move.w	d2,d3				; ''
00006AE0 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006AE4 4EB8 45CA                  		jsr	SolidObject_Always		; Set object as solid
00006AE8 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Has the player touched the top of the of spring?
00006AEE 6700                       		beq.s	.Display			; If not, branch
00006AF0 6100                       		bsr.s	.Bounce				; Bounce the player up
00006AF2                            
00006AF2                            .Display:
00006AF2 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006AF6 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006AFA 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006AFE                            	nextObject
00006AFE 3068 0004                M 	movea.w	_objnext(a0),a0
00006B02 2250                     M 	move.l	_objaddress(a0),a1
00006B04 4ED1                     M 	jmp	(a1)
00006B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B06                            .Bounce:
00006B06 317C 0100 0020             		move.w	#$100,_objAnim(a0)			; Reset animation
00006B0C 5069 0018                  		addq.w	#8,_objYPos(a1)			; Align player to spring
00006B10 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)		; Set the player's Y velocity
00006B16 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set the player's "in air" flag
00006B1C 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Make the player no longer be on the spring
00006B22 4229 0040                  		clr.b	_objJumping(a1)			; Clear the player's jump flag
00006B26 137C 0010 0020             		move.b	#$10,_objAnim(a1)			; Set the player's animation to the spring animation
00006B2C 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Reset the player's routine
00006B32                            		
00006B32 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006B36 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
00006B38 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's X movement
00006B3C                            
00006B3C                            .ChkPath1:
00006B3C 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006B40 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006B44 6600                       		bne.s	.ChkPath2			; If not, branch
00006B46 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006B4C 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006B52                            
00006B52                            .ChkPath2:
00006B52 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006B56 6600                       		bne.s	.PlaySound			; If not, branch
00006B58 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006B5E 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006B64                            
00006B64                            .PlaySound:
00006B64                            		playSnd	#sSpring, 2			; Play spring sound
00006B64 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006B6A 4E75                       		rts
00006B6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B6C                            ObjSpring_Horizontal:
00006B6C 323C 0013                  		move.w	#20-1,d1			; Width
00006B70 343C 000E                  		move.w	#28/2,d2			; Height
00006B74 3602                       		move.w	d2,d3				; ''
00006B76 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006B7A 4EB8 45CA                  		jsr	SolidObject_Always		; Set object as solid
00006B7E 0806 0000                  		btst	#cTouchSideBit,d6		; Has the player touched the side of the spring?
00006B82 6700                       		beq.s	.Display			; If not, branch
00006B84 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00006B88 3028 0014                  		move.w	_objXPos(a0),d0			; Get which side of the spring the player is facing
00006B8C 9069 0014                  		sub.w	_objXPos(a1),d0			; ''
00006B90 6500                       		bcs.s	.NoFlip				; If the player is on the left side of the spring, branch
00006B92 0A01 0001                  		eori.b	#1,d1				; Flip so that we check for the other side of the spring
00006B96                            
00006B96                            .NoFlip:
00006B96 0201 0001                  		andi.b	#1,d1				; Is the player touching the bouncy side of the spring?
00006B9A 6600                       		bne.s	.Display			; If not, branch
00006B9C 6100                       		bsr.s	.Bounce				; Bounce the player
00006B9E                            
00006B9E                            .Display:
00006B9E 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006BA2 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006BA6 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006BAA                            	nextObject
00006BAA 3068 0004                M 	movea.w	_objnext(a0),a0
00006BAE 2250                     M 	move.l	_objaddress(a0),a1
00006BB0 4ED1                     M 	jmp	(a1)
00006BB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006BB2                            .Bounce:	
00006BB2 317C 0300 0020             		move.w	#$300,_objAnim(a0)			; Reset animation
00006BB8 5069 0014                  		addq.w	#8,_objXPos(a1)			; Align player to spring
00006BBC 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)		; Set the player's X velocity
00006BC2 08E9 0000 0028             		bset	#0,_objStatus(a1)			; Make the player face the left
00006BC8 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is this spring facing the left?
00006BCE 6600                       		bne.s	.SetMoveLock			; If so, branch
00006BD0 08A9 0000 0028             		bclr	#0,_objStatus(a1)			; Make the player face the right
00006BD6 0469 0010 0014             		subi.w	#$10,_objXPos(a1)			; Align player to spring
00006BDC 4469 001C                  		neg.w	_objXVel(a1)			; Move the player to the right
00006BE0                            
00006BE0                            .SetMoveLock:
00006BE0 137C 000F 003F             		move.b	#$F,_objMoveLock(a1)		; Lock the player's movement for a bit
00006BE6 3369 001C 003A             		move.w	_objXVel(a1),_objGVel(a1)		; Set the player's ground velocity
00006BEC                            		
00006BEC 0829 0002 0028             		btst	#2,_objStatus(a1)			; Is the player jumping?
00006BF2 6600                       		bne.s	.ChkYStop			; If so, branch
00006BF4 4229 0020                  		clr.b	_objAnim(a1)			; Set the animation to the walking animation
00006BF8                            		
00006BF8                            .ChkYStop:
00006BF8 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006BFC 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move vertically
00006BFE 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's Y movement
00006C02                            
00006C02                            .ChkPath1:
00006C02 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006C06 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006C0A 6600                       		bne.s	.ChkPath2			; If not, branch
00006C0C 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006C12 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006C18                            
00006C18                            .ChkPath2:
00006C18 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006C1C 6600                       		bne.s	.PlaySound			; If not, branch
00006C1E 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006C24 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006C2A                            
00006C2A                            .PlaySound:
00006C2A 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Clear "push" flags
00006C30 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; ''
00006C36                            		playSnd	#sSpring, 2			; Play spring sound
00006C36 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006C3C 4E75                       		rts
00006C3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C3E                            ObjSpring_Down:
00006C3E 323C 0012                  		move.w	#19-1,d1			; Width
00006C42 343C 0008                  		move.w	#16/2,d2			; Height
00006C46 3602                       		move.w	d2,d3				; ''
00006C48 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006C4C 4EB8 45CA                  		jsr	SolidObject_Always		; Set object as solid
00006C50 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the bottom of the spring?
00006C54 6600                       		bne.s	.Display			; If not, branch
00006C56 6100                       		bsr.s	.Bounce				; Bounce the player
00006C58                            
00006C58                            .Display:
00006C58 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006C5C 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006C60 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006C64                            	nextObject
00006C64 3068 0004                M 	movea.w	_objnext(a0),a0
00006C68 2250                     M 	move.l	_objaddress(a0),a1
00006C6A 4ED1                     M 	jmp	(a1)
00006C6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C6C                            .Bounce:
00006C6C 317C 0100 0020             		move.w	#$100,_objAnim(a0)			; Reset animation
00006C72 5169 0018                  		subq.w	#8,_objYPos(a1)			; Align player with the spring
00006C76 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)		; Set the player's Y velocity
00006C7C 4469 001E                  		neg.w	_objYVel(a1)			; Move the player down
00006C80                            		
00006C80 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006C84 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
00006C86 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's X movement
00006C8A                            
00006C8A                            .ChkPath1:
00006C8A 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006C8E 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006C92 6600                       		bne.s	.ChkPath2			; If not, branch
00006C94 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006C9A 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006CA0                            
00006CA0                            .ChkPath2:
00006CA0 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006CA4 6600                       		bne.s	.PlaySound			; If not, branch
00006CA6 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006CAC 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006CB2                            
00006CB2                            .PlaySound:
00006CB2 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set the player's "in air" flag
00006CB8 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Make the player no longer be on the spring
00006CBE 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Reset the player's routine
00006CC4                            		playSnd	#sSpring, 2			; Play spring sound
00006CC4 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006CCA 4E75                       		rts
00006CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006CCC                            ObjSpring_DiagonallyUp:
00006CCC 323C 0019                  		move.w	#26-1,d1			; Width
00006CD0 343C 0010                  		move.w	#32/2,d2			; Height
00006CD4 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006CD8 45FA 0000                  		lea	.SlopeData(pc),a2		; Slope Data
00006CDC 4EB8 461A                  		jsr	SlopedSolid			; Set object as a solid slope
00006CE0                            		
00006CE0 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Has the player touched the spring?
00006CE6 6700                       		beq.s	.End				; If not, branch
00006CE8 6100                       		bsr.s	.Bounce				; Bounce the player
00006CEA                            
00006CEA                            .End:
00006CEA 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006CEE 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006CF2 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006CF6                            	nextObject
00006CF6 3068 0004                M 	movea.w	_objnext(a0),a0
00006CFA 2250                     M 	move.l	_objaddress(a0),a1
00006CFC 4ED1                     M 	jmp	(a1)
00006CFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006CFE                            .Bounce:
00006CFE 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is the spring facing left?
00006D04 6600                       		bne.s	.FaceLeft			; If so, branch
00006D06 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00006D0A 5940                       		subq.w	#4,d0				; Subtract 4
00006D0C B069 0014                  		cmp.w	_objXPos(a1),d0			; Is the player
00006D10 6500                       		blo.s	.DoBounce
00006D12 4E75                       		rts
00006D14                            
00006D14                            .FaceLeft:
00006D14 3028 0014                  		move.w	_objXPos(a0),d0
00006D18 5840                       		addq.w	#4,d0
00006D1A B069 0014                  		cmp.w	_objXPos(a1),d0
00006D1E 6400                       		bhs.s	.DoBounce
00006D20 4E75                       		rts
00006D22                            
00006D22                            .DoBounce:
00006D22 317C 0500 0020             		move.w	#$500,_objAnim(a0)
00006D28 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)
00006D2E 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)
00006D34 5C69 0018                  		addq.w	#6,_objYPos(a1)
00006D38 5C69 0014                  		addq.w	#6,_objXPos(a1)
00006D3C 08E9 0000 0028             		bset	#0,_objStatus(a1)
00006D42 0828 0000 0028             		btst	#0,_objStatus(a0)
00006D48 6600                       		bne.s	.SetAni
00006D4A 08A9 0000 0028             		bclr	#0,_objStatus(a1)
00006D50 0469 000C 0014             		subi.w	#$C,_objXPos(a1)
00006D56 4469 001C                  		neg.w	_objXVel(a1)
00006D5A                            
00006D5A                            .SetAni:
00006D5A 08E9 0001 0028             		bset	#1,_objStatus(a1)
00006D60 08A9 0003 0028             		bclr	#3,_objStatus(a1)
00006D66 137C 0010 0020             		move.b	#$10,_objAnim(a1)
00006D6C 137C 0004 0025             		move.b	#4,_objRoutine(a1)
00006D72                            
00006D72 1028 0024                  		move.b	_objSubtype(a0),d0
00006D76 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006D7A 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006D7E 6600                       		bne.s	.ChkPath2			; If not, branch
00006D80 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006D86 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006D8C                            
00006D8C                            .ChkPath2:
00006D8C 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006D90 6600                       		bne.s	.PlaySound			; If not, branch
00006D92 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006D98 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006D9E                            
00006D9E                            .PlaySound:
00006D9E                            		playSnd	#sSpring, 2			; Play spring sound
00006D9E 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006DA4 4E75                       		rts
00006DA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DA6                            .SlopeData:
00006DA6 1010 1010 1010 10          		dc.b	$10, $10, $10, $10, $10, $10, $10
00006DAD 1010 1010 100E 0C          		dc.b	$10, $10, $10, $10, $10, $0E, $0C
00006DB4 0A08 0604 0200 FE          		dc.b	$0A, $08, $06, $04, $02, $00, $FE
00006DBB FCFC FCFC FCFC FC          		dc.b	$FC, $FC, $FC, $FC, $FC, $FC, $FC
00006DC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DC2                            ObjSpring_DiagonallyDown:
00006DC2 323C 0019                  		move.w	#26-1,d1			; Width
00006DC6 343C 0010                  		move.w	#32/2,d2
00006DCA 3828 0014                  		move.w	_objXPos(a0),d4
00006DCE 45FA 0000                  		lea	.SlopeData(pc),a2
00006DD2 4EB8 461A                  		jsr	SlopedSolid			; Set object as a solid slope
00006DD6 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the spring?
00006DDA 6600                       		bne.s	.End				; If not, branch
00006DDC 6100                       		bsr.s	.Bounce				; Bounce the player
00006DDE                            
00006DDE                            .End:
00006DDE 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006DE2 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006DE6 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006DEA                            	nextObject
00006DEA 3068 0004                M 	movea.w	_objnext(a0),a0
00006DEE 2250                     M 	move.l	_objaddress(a0),a1
00006DF0 4ED1                     M 	jmp	(a1)
00006DF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DF2                            .Bounce:
00006DF2 317C 0500 0020             		move.w	#$500,_objAnim(a0)
00006DF8 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)
00006DFE 4469 001E                  		neg.w	_objYVel(a1)
00006E02 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)
00006E08 5C69 0018                  		addq.w	#6,_objYPos(a1)
00006E0C 5C69 0014                  		addq.w	#6,_objXPos(a1)
00006E10 08E9 0000 0028             		bset	#0,_objStatus(a1)
00006E16 0828 0000 0028             		btst	#0,_objStatus(a0)
00006E1C 6600                       		bne.s	.SetAni
00006E1E 08A9 0000 0028             		bclr	#0,_objStatus(a1)
00006E24 0469 000C 0014             		subi.w	#$C,_objXPos(a1)
00006E2A 4469 001C                  		neg.w	_objXVel(a1)
00006E2E                            
00006E2E                            .SetAni:
00006E2E 08E9 0001 0028             		bset	#1,_objStatus(a1)
00006E34 08A9 0003 0028             		bclr	#3,_objStatus(a1)
00006E3A 137C 0004 0025             		move.b	#4,_objRoutine(a1)
00006E40                            
00006E40 1028 0024                  		move.b	_objSubtype(a0),d0
00006E44 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006E48 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006E4C 6600                       		bne.s	.ChkPath2			; If not, branch
00006E4E 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006E54 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006E5A                            
00006E5A                            .ChkPath2:
00006E5A 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006E5E 6600                       		bne.s	.PlaySound			; If not, branch
00006E60 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006E66 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006E6C                            
00006E6C                            .PlaySound:
00006E6C                            		playSnd	#sSpring, 2			; Play spring sound
00006E6C 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006E72 4E75                       		rts
00006E74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E74                            .SlopeData:
00006E74 F4F0 F0F0 F0F0 F0          		dc.b	$F4, $F0, $F0, $F0, $F0, $F0, $F0
00006E7B F0F0 F0F0 F0F2 F4          		dc.b	$F0, $F0, $F0, $F0, $F0, $F2, $F4
00006E82 F6F8 FAFC FE00 02          		dc.b	$F6, $F8, $FA, $FC, $FE, $00, $02
00006E89 0404 0404 0404 04          		dc.b	$04, $04, $04, $04, $04, $04, $04
00006E90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E90                            ; Data
00006E90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E90                            Ani_ObjSpring:
00006E90                            		include	"Objects/Spring/Animations.asm"
00006E90                            ; ---------------------------------------------------------------------------
00006E90                            ; Animation script - springs
00006E90                            ; ---------------------------------------------------------------------------
00006E90 0000                       		dc.w byte_18FEE-Ani_ObjSpring
00006E92 0000                       		dc.w byte_18FF1-Ani_ObjSpring
00006E94 0000                       		dc.w byte_18FFD-Ani_ObjSpring
00006E96 0000                       		dc.w byte_19000-Ani_ObjSpring
00006E98 0000                       		dc.w byte_1900C-Ani_ObjSpring
00006E9A 0000                       		dc.w byte_1900F-Ani_ObjSpring
00006E9C                            byte_18FEE:
00006E9C 0F00 FF                    		dc.b  $F, 0, $FF
00006EA0 00                         		even
00006EA0                            byte_18FF1:
00006EA0 0001 0101 0101 01FD 00     		dc.b 0, 1, 1, 1, 1, 1, 1, $FD, 0
00006EAA 00                         		even
00006EAA                            byte_18FFD:
00006EAA 0F02 FF                    		dc.b $F, 2, $FF
00006EAE 00                         		even
00006EAE                            byte_19000:
00006EAE 0003 0303 0303 03FD 02     		dc.b 0, 3, 3, 3, 3, 3, 3, $FD, 2
00006EB8 00                         		even
00006EB8                            byte_1900C:
00006EB8 0F04 FF                    		dc.b $F, 4, $FF
00006EBC 00                         		even
00006EBC                            byte_1900F:
00006EBC 0005 0505 0505 05FD 04     		dc.b 0, 5, 5, 5, 5, 5, 5, $FD, 4
00006EC6 00                         		even
00006EC6                            Map_ObjSpring:
00006EC6                            		include	"Objects/Spring/Mappings.asm"
00006EC6                            ; --------------------------------------------------------------------------------
00006EC6                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006EC6                            ; --------------------------------------------------------------------------------
00006EC6                            
00006EC6                            SME_q_6K9:	
00006EC6 0000 0000                  		dc.w SME_q_6K9_E-SME_q_6K9, SME_q_6K9_1C-SME_q_6K9	
00006ECA 0000 0000                  		dc.w SME_q_6K9_3C-SME_q_6K9, SME_q_6K9_44-SME_q_6K9	
00006ECE 0000 0000                  		dc.w SME_q_6K9_70-SME_q_6K9, SME_q_6K9_7E-SME_q_6K9	
00006ED2 0000                       		dc.w SME_q_6K9_9E-SME_q_6K9	
00006ED4 0002                       SME_q_6K9_E:	dc.b 0, 2	
00006ED6 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00006EDC 000C 0004 FFF0             		dc.b 0, $C, 0, 4, $FF, $F0	
00006EE2 0005                       SME_q_6K9_1C:	dc.b 0, 5	
00006EE4 E00C 0000 FFF0             		dc.b $E0, $C, 0, 0, $FF, $F0	
00006EEA E804 0008 FFF8             		dc.b $E8, 4, 0, 8, $FF, $F8	
00006EF0 F004 000A FFF8             		dc.b $F0, 4, 0, $A, $FF, $F8	
00006EF6 F804 000A FFF8             		dc.b $F8, 4, 0, $A, $FF, $F8	
00006EFC 000C 000C FFF0             		dc.b 0, $C, 0, $C, $FF, $F0	
00006F02 0001                       SME_q_6K9_3C:	dc.b 0, 1	
00006F04 E807 0000 FFF7             		dc.b $E8, 7, 0, 0, $FF, $F7	
00006F0A 0007                       SME_q_6K9_44:	dc.b 0, 7	
00006F0C E803 0004 0017             		dc.b $E8, 3, 0, 4, 0, $17	
00006F12 F001 0008 000F             		dc.b $F0, 1, 0, 8, 0, $F	
00006F18 F001 000A 0007             		dc.b $F0, 1, 0, $A, 0, 7	
00006F1E F001 000A FFFF             		dc.b $F0, 1, 0, $A, $FF, $FF	
00006F24 F001 000C FFF7             		dc.b $F0, 1, 0, $C, $FF, $F7	
00006F2A E800 000E FFF7             		dc.b $E8, 0, 0, $E, $FF, $F7	
00006F30 0000 100E FFF7             		dc.b 0, 0, $10, $E, $FF, $F7	
00006F36 0002                       SME_q_6K9_70:	dc.b 0, 2	
00006F38 F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
00006F3E FA02 000C 0008             		dc.b $FA, 2, 0, $C, 0, 8	
00006F44 0005                       SME_q_6K9_7E:	dc.b 0, 5	
00006F46 E20B 000F 0000             		dc.b $E2, $B, 0, $F, 0, 0	
00006F4C EA02 001B 0018             		dc.b $EA, 2, 0, $1B, 0, $18	
00006F52 F201 201E FFF8             		dc.b $F2, 1, $20, $1E, $FF, $F8	
00006F58 FA00 0020 FFF0             		dc.b $FA, 0, 0, $20, $FF, $F0	
00006F5E 0209 0021 FFF0             		dc.b 2, 9, 0, $21, $FF, $F0	
00006F64 0002                       SME_q_6K9_9E:	dc.b 0, 2	
00006F66 020B 1000 FFF0             		dc.b 2, $B, $10, 0, $FF, $F0	
00006F6C 0202 100C 0008             		dc.b 2, 2, $10, $C, 0, 8	
00006F72                            		even
00006F72                            ; =========================================================================================================================================================
00006F72                            		include	"Objects/Checkpoint/Code.asm"	; Checkpoint object
00006F72                            ; =========================================================================================================================================================
00006F72                            ; Checkpoint object
00006F72                            ; =========================================================================================================================================================
00006F72                            		rsset	_objLvlSSTs
00006F72 =00000030                  _objDongleX	rs.w	1				; Ball dongle X
00006F72 =00000032                  _objDongleY	rs.w	1				; Ball dongle Y
00006F72 =00000034                  _objDongleTime	rs.w	1				; Ball dongle timer
00006F72 =00000036                  _objDonglePar	rs.w	1				; Ball dongle parent
00006F72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F72                            ObjCheckpoint:
00006F72 7000                       		moveq	#0,d0
00006F74 1028 0025                  		move.b	_objRoutine(a0),d0			; Get routine ID
00006F78 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00006F7C                            	nextObject
00006F7C 3068 0004                M 	movea.w	_objnext(a0),a0
00006F80 2250                     M 	move.l	_objaddress(a0),a1
00006F82 4ED1                     M 	jmp	(a1)
00006F84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F84                            .Index:
00006F84 6000 0000                  		bra.w	ObjChkpoint_Init
00006F88 6000 0000                  		bra.w	ObjChkpoint_Main
00006F8C 6000 0000                  		bra.w	ObjChkpoint_Animate
00006F90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F90                            ObjChkpoint_Init:
00006F90 5828 0025                  		addq.b	#4,_objRoutine(a0)			; Next routine
00006F94                            		
00006F94 217C 0000 0000 0010        		move.l	#Map_ObjChkpoint,_objMapping(a0)	; Mappings
00006F9C 317C 057E 000E             		move.w	#$57E,_objVRAM(a0)			; Tile properties
00006FA2 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00006FA8 117C 0008 0017             		move.b	#8,_objDrawW(a0)			; Sprite width
00006FAE 117C 0020 001B             		move.b	#$20,_objDrawH(a0)			; Sprite height
00006FB4                            	displaySprite	5,a0,a1,0			; Priority
00006FB4 317C C182 0008           M 	move.w	#objdisplay+(5*dsize),_objdrawnext(a0)
00006FBA 3278 C18C                M 	move.w	objdisplay+dprev+(5*dsize).w,a1
00006FBE 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006FC2 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006FC6 31C8 C18C                M 	move.w	a0,objdisplay+dprev+(5*dsize).w
00006FCA                          M .no_263
00006FCA                            		
00006FCA 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table address
00006FCE 3440                       		movea.w	d0,a2				; ''
00006FD0 0812 0000                  		btst	#0,(a2)				; Is it already set?
00006FD4 6600                       		bne.s	.AlreadySet			; If so, branch
00006FD6                            
00006FD6 1228 0024                  		move.b	_objSubtype(a0),d1			; Get checkpoint ID
00006FDA B238 C7B0                  		cmp.b	chkIDLast.w,d1		; Has a later checkpoint already been hit?
00006FDE 6E00                       		bgt.s	ObjChkpoint_Main		; If not, branch
00006FE0                            
00006FE0                            .AlreadySet:
00006FE0 08D2 0000                  		bset	#0,(a2)				; Mark as set
00006FE4 117C 0002 0020             		move.b	#2,_objAnim(a0)			; ''
00006FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006FEA                            ObjChkpoint_Main:
00006FEA 4A38 E8DD                  		tst.b	debugMode.w			; Are we in debug placement mode?
00006FEE 6600 0000                  		bne.w	ObjChkpoint_Animate		; If so, branch
00006FF2                            		
00006FF2 3278 E876                  		movea.w	playerPtrP1.w,a1		; Player object
00006FF6 1238 C7B0                  		move.b	chkIDLast.w,d1		; Get last checkpoint hit
00006FFA B228 0024                  		cmp.b	_objSubtype(a0),d1			; Has a later checkpoint already been hit?
00006FFE 6400 0000                  		bhs.w	.ChkSetAnim			; If so, branch
00007002                            
00007002 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
00007006 9068 0014                  		sub.w	_objXPos(a0),d0			; Get delta X from current position
0000700A 5040                       		addq.w	#8,d0				; Add 8
0000700C 0C40 0010                  		cmpi.w	#$10,d0				; Is the player within horizontal boundaries?
00007010 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
00007014 3029 0018                  		move.w	_objYPos(a1),d0			; Get player's Y position
00007018 9068 0018                  		sub.w	_objYPos(a0),d0			; Get delta Y from current position
0000701C 0640 0040                  		addi.w	#$40,d0				; Add $40
00007020 0C40 0068                  		cmpi.w	#$68,d0				; Is the player within vertical boundaries?
00007024 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
00007028                            		
00007028                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
00007028 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
0000702E                            
0000702E 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00007032 6700                       		beq.s	.SetPoint			; If there is none, branch
00007034 22BC 0000 0000             		move.l	#ObjChkPoint_Dongle,_objAddress(a1)	; Load the checkpoint ball dongle object
0000703A 3368 0014 0030             		move.w	_objXPos(a0),_objDongleX(a1)		; Dongle X
00007040 3368 0018 0032             		move.w	_objYPos(a0),_objDongleY(a1)		; Dongle Y
00007046 0469 0014 0032             		subi.w	#$14,_objDongleY(a1)		; ''
0000704C 2368 0010 0010             		move.l	_objMapping(a0),_objMapping(a1)		; Mappings
00007052 3368 000E 000E             		move.w	_objVRAM(a0),_objVRAM(a1)		; Tile properties
00007058 137C 0004 000D             		move.b	#4,_objRender(a1)			; Render flags
0000705E 137C 0008 0017             		move.b	#8,_objDrawW(a1)			; Sprite width
00007064 137C 0008 001B             		move.b	#8,_objDrawH(a1)			; Sprite height
0000706A                            	displaySprite	4,a1,a2,0			; Priority
0000706A 337C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a1)
00007070 3478 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a2
00007074 334A 000A                M 	move.w	a2,_objdrawprev(a1)
00007078 3549 0008                M 	move.w	a1,_objdrawnext(a2)
0000707C 31C9 C184                M 	move.w	a1,objdisplay+dprev+(4*dsize).w
00007080                          M .no_265
00007080 137C 0002 0010             		move.b	#2,_objFrame(a1)			; Map frame
00007086 337C 0020 0034             		move.w	#$20,_objDongleTime(a1)		; Dongle timer
0000708C 3348 0036                  		move.w	a0,_objDonglePar(a1)		; Dongle parent
00007090                            
00007090                            .SetPoint:
00007090 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table address
00007094 3440                       		movea.w	d0,a2				; ''
00007096 08D2 0000                  		bset	#0,(a2)				; Mark as set
0000709A                            		
0000709A 117C 0001 0020             		move.b	#1,_objAnim(a0)			; Use dongling animation
000070A0 11E8 0024 C7B0             		move.b	_objSubtype(a0),chkIDLast.w	; Set checkpoint ID
000070A6                            
000070A6 5828 0025                  		addq.b	#4,_objRoutine(a0)
000070AA 4879 0000 0000             		pea	ObjChkpoint_Animate		; Animate
000070B0 4EF8 4B6E                  		jmp	Level_SaveInfo			; Save data
000070B4                            		
000070B4                            .ChkSetAnim:
000070B4 5828 0025                  		addq.b	#4,_objRoutine(a0)
000070B8 4A28 0020                  		tst.b	_objAnim(a0)			; Are we still unset?
000070BC 6600                       		bne.s	ObjChkpoint_Animate		; If not, branch
000070BE 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use the set animation
000070C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
000070C4                            ObjChkpoint_Animate:
000070C4 43F9 0000 0000             		lea	Ani_ObjChkpoint,a1		; Animate
000070CA 4EB8 1C42                  		jsr	AnimateObject.w			; ''
000070CE 4EF8 2000                  		jmp	CheckObjActive.w		; Display
000070D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
000070D2                            ; Ball dongle object
000070D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
000070D2                            ObjChkPoint_Dongle:
000070D2 5368 0034                  		subq.w	#1,_objDongleTime(a0)		; Decrement timer
000070D6 6A00                       		bpl.s	.MoveDongle			; If it hasn't run out, branch
000070D8 3268 0036                  		movea.w	_objDonglePar(a0),a1		; Get parent
000070DC 137C 0002 0020             		move.b	#2,_objAnim(a1)			; Set set animation for parent
000070E2 4229 0010                  		clr.b	_objFrame(a1)			; Reset map frame for parent
000070E6 4EB8 1A4C                  		jsr	DeleteObject.w			; Delete ourselves
000070EA                            	nextObject
000070EA 3068 0004                M 	movea.w	_objnext(a0),a0
000070EE 2250                     M 	move.l	_objaddress(a0),a1
000070F0 4ED1                     M 	jmp	(a1)
000070F2                            
000070F2                            .MoveDongle:
000070F2 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000070F6 0428 0010 0041             		subi.b	#$10,_objAngle(a0)			; Decrement angle
000070FC 0400 0040                  		subi.b	#$40,d0				; Subtract $40
00007100 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
00007104 C3FC 0C00                  		muls.w	#$C00,d1			; Multiply cosine with $C00
00007108 4841                       		swap	d1				; Get high word
0000710A D268 0030                  		add.w	_objDongleX(a0),d1			; Add dongle X
0000710E 3141 0014                  		move.w	d1,_objXPos(a0)			; Set actual X
00007112 C1FC 0C00                  		muls.w	#$C00,d0			; Multiply sine with $C00
00007116 4840                       		swap	d0				; Get high word
00007118 D068 0032                  		add.w	_objDongleY(a0),d0			; Add dongle X
0000711C 3140 0018                  		move.w	d0,_objYPos(a0)			; Set actual X
00007120 4EB8 2000                  		jsr	CheckObjActive.w		; Display
00007124                            	nextObject
00007124 3068 0004                M 	movea.w	_objnext(a0),a0
00007128 2250                     M 	move.l	_objaddress(a0),a1
0000712A 4ED1                     M 	jmp	(a1)
0000712C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000712C                            ; Data
0000712C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000712C                            Ani_ObjChkpoint:
0000712C 0000                       		dc.w	.Ani0-Ani_ObjChkpoint
0000712E 0000                       		dc.w	.Ani1-Ani_ObjChkpoint
00007130 0000                       		dc.w	.Ani2-Ani_ObjChkpoint
00007132 0F00 FF                    .Ani0:		dc.b	$F, 0, $FF
00007136 00                         		even
00007136 0F01 FF                    .Ani1:		dc.b	$F, 1, $FF
0000713A 00                         		even
0000713A 0300 04FF                  .Ani2:		dc.b	3, 0, 4, $FF
0000713E                            		even
0000713E                            Map_ObjChkpoint:
0000713E                            		include	"Objects/Checkpoint/Mappings.asm"
0000713E                            ; --------------------------------------------------------------------------------
0000713E                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0000713E                            ; --------------------------------------------------------------------------------
0000713E                            
0000713E                            SME_JjCUP:	
0000713E 0000 0000                  		dc.w SME_JjCUP_A-SME_JjCUP, SME_JjCUP_24-SME_JjCUP	
00007142 0000 0000                  		dc.w SME_JjCUP_38-SME_JjCUP, SME_JjCUP_40-SME_JjCUP	
00007146 0000                       		dc.w SME_JjCUP_48-SME_JjCUP	
00007148 0004                       SME_JjCUP_A:	dc.b 0, 4	
0000714A E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00007150 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007156 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0000715C D805 0000 FFF8             		dc.b $D8, 5, 0, 0, $FF, $F8	
00007162 0003                       SME_JjCUP_24:	dc.b 0, 3	
00007164 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0000716A F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007170 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
00007176 0001                       SME_JjCUP_38:	dc.b 0, 1	
00007178 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8	
0000717E 0001                       SME_JjCUP_40:	dc.b 0, 1	
00007180 F805 2000 FFF8             		dc.b $F8, 5, $20, 0, $FF, $F8	
00007186 0004                       SME_JjCUP_48:	dc.b 0, 4	
00007188 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0000718E F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007194 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0000719A D805 2000 FFF8             		dc.b $D8, 5, $20, 0, $FF, $F8	
000071A0                            		even
000071A0                            ; =========================================================================================================================================================
000071A0                            		include	"Objects/Wall Spring/Code.asm"	; Wall spring object
000071A0                            ; =========================================================================================================================================================
000071A0                            ; Wall spring object
000071A0                            ; =========================================================================================================================================================
000071A0                            ObjWallSpring:
000071A0 20BC 0000 0000             		move.l	#ObjWallSpring_Main,_objAddress(a0)	; Next routine
000071A6                            	;	move.l	#Map_ObjWallSpring,_objMapping(a0)	; Mappings
000071A6                            	;	clr.w	_objVRAM(a0)			; Tile properties
000071A6                            	;	ori.b	#4,_objRender(a0)			; Render flags
000071A6                            	;	move.w	#rSprInput+$200,oPrio(a0)	; Priority
000071A6                            	;	move.b	#8,_objDrawW(a0)			; Sprite width
000071A6                            	;	move.b	#$40,_objDrawH(a0)			; Sprite height
000071A6 117C 0008 002C             		move.b	#8,_objColW(a0)			; Collision width
000071AC 117C 0040 002D             		move.b	#$40,_objColH(a0)			; Collision height
000071B2                            
000071B2 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
000071B6 E808                       		lsr.b	#4,d0				; Get map frame
000071B8 0200 0007                  		andi.b	#7,d0				; ''
000071BC 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
000071C0 6700                       		beq.s	ObjWallSpring_Main		; If it was 0, branch
000071C2                            	;	move.b	#$80,_objDrawH(a0)			; Larger sprite height
000071C2 117C 0080 002D             		move.b	#$80,_objColH(a0)			; Larger collision height
000071C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000071C8                            ObjWallSpring_Main:
000071C8 7208                       		moveq	#8,d1				; Width
000071CA 7400                       		moveq	#0,d2
000071CC 1428 002D                  		move.b	_objColH(a0),d2			; Height
000071D0 3602                       		move.w	d2,d3				; ''
000071D2 5243                       		addq.w	#1,d3				; ''
000071D4 3828 0014                  		move.w	_objXPos(a0),d4			; X position
000071D8 4EB8 45CA                  		jsr	SolidObject_Always		; Make us solid
000071DC                            
000071DC 0806 0000                  		btst	#cTouchSideBit,d6		; Has Sonic touched the side of the spring?
000071E0 6700                       		beq.s	.Display			; If not, branch
000071E2 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set in air
000071E8 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
000071EC 3028 0014                  		move.w	_objXPos(a0),d0			; Get distance between us and Sonic
000071F0 9069 0014                  		sub.w	_objXPos(a1),d0			; ''
000071F4 6500                       		bcs.s	.ChkXStat			; If Sonic is towards the right of the spring, branch
000071F6 0A01 0001                  		eori.b	#1,d1				; Go the other way
000071FA                            
000071FA                            .ChkXStat:
000071FA 0201 0001                  		andi.b	#1,d1				; Has Sonic touched the front of spring?
000071FE 6600                       		bne.s	.Display			; If not, branch
00007200 6100                       		bsr.s	.Bounce
00007202                            
00007202                            .Display:
00007202 4EB8 2000                  		jsr	CheckObjActive.w		; Delete if inactive
00007206                            	nextObject
00007206 3068 0004                M 	movea.w	_objnext(a0),a0
0000720A 2250                     M 	move.l	_objaddress(a0),a1
0000720C 4ED1                     M 	jmp	(a1)
0000720E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000720E                            .Bounce:
0000720E 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is Sonic dead?
00007214 6500                       		blo.s	.DoBounce			; If not, branch
00007216 4E75                       		rts
00007218                            
00007218                            .DoBounce:
00007218 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Make Sonic not hurt if he is
0000721E 337C F800 001C             		move.w	#-$800,_objXVel(a1)		; Bounce left
00007224 337C F800 001E             		move.w	#-$800,_objYVel(a1)		; Bounce up
0000722A 08E9 0000 0028             		bset	#0,_objStatus(a1)			; Face left
00007230 0828 0000 0028             		btst	#0,_objStatus(a0)			; Are we facing left?
00007236 6600                       		bne.s	.MoveLock			; If so, branch
00007238 08A9 0000 0028             		bclr	#0,_objStatus(a1)			; Face right
0000723E 4469 001C                  		neg.w	_objXVel(a1)			; Go right
00007242                            
00007242                            .MoveLock:
00007242 137C 000F 003F             		move.b	#$F,_objMoveLock(a1)		; Set move lock timer
00007248 0829 0002 0028             		btst	#2,_objStatus(a1)			; Was Sonic jumping?
0000724E 6600                       		bne.s	.ChkN_objYVel			; If so, branch
00007250 4229 0020                  		clr.b	_objAnim(a1)			; Reset animation
00007254                            
00007254                            .ChkN_objYVel:
00007254 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00007258 6A00                       		bpl.s	.ChkFlip			; If Sonic should still bounce up, branch
0000725A 4229 001E                  		clr.b	_objYVel(a1)			; Stop Y velocity
0000725E                            
0000725E                            .ChkFlip:
0000725E 0800 0000                  		btst	#0,d0				; Should Sonic tumble?
00007262 6700                       		beq.s	.PlaySnd			; If not, branch
00007264 337C 0001 003A             		move.w	#1,_objFlipDir(a1)			; Set flip direction
0000726A 137C 0001 0047             		move.b	#1,_objFlipAngle(a1)		; Set flip angle
00007270 4229 0020                  		clr.b	_objAnim(a1)			; Reset animation
00007274 137C 0001 0049             		move.b	#1,_objFlipRemain(a1)		; Set flips remaining
0000727A 137C 0008 004A             		move.b	#8,_objFlipSpeed(a1)		; Set flip speed
00007280 0800 0001                  		btst	#1,d0				; Should Sonic do 3 flips?
00007284 6600                       		bne.s	.ChkDir				; If not, branch
00007286 137C 0003 0049             		move.b	#3,_objFlipRemain(a1)		; Do 3 flips isntead
0000728C                            
0000728C                            .ChkDir:
0000728C 0829 0000 0028             		btst	#0,_objStatus(a1)			; Was Sonic facing left?
00007292 6700                       		beq.s	.PlaySnd			; If not, branch
00007294 4429 0047                  		neg.b	_objFlipAngle(a1)			; Flip the other way
00007298 4469 003A                  		neg.w	_objFlipDir(a1)			; ''
0000729C                            
0000729C                            .PlaySnd:
0000729C 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Stop pushing
000072A2 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; ''
000072A8                            		playSnd	#sSpring, 2			; Play spring sound
000072A8 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
000072AE 4E75                       		rts
000072B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072B0                            ; Data
000072B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072B0                            Map_ObjWallSpring:
000072B0                            		include	"Objects/Wall Spring/Mappings.asm"
000072B0                            ; --------------------------------------------------------------------------------
000072B0                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
000072B0                            ; --------------------------------------------------------------------------------
000072B0                            
000072B0                            SME_ReVf5:	
000072B0 0000 0000                  		dc.w SME_ReVf5_4-SME_ReVf5, SME_ReVf5_12-SME_ReVf5	
000072B4 0002                       SME_ReVf5_4:	dc.b 0, 2	
000072B6 C005 0034 FFF8             		dc.b $C0, 5, 0, $34, $FF, $F8	
000072BC 3005 0034 FFF8             		dc.b $30, 5, 0, $34, $FF, $F8	
000072C2 0002                       SME_ReVf5_12:	dc.b 0, 2	
000072C4 8005 0034 FFF8             		dc.b $80, 5, 0, $34, $FF, $F8	
000072CA 7005 0034 FFF8             		dc.b $70, 5, 0, $34, $FF, $F8	
000072D0                            		even
000072D0                            		even
000072D0                            ; =========================================================================================================================================================
000072D0                            		include	"Objects/Ball Mode/Code.asm"	; Ball mode switch object
000072D0                            ; =========================================================================================================================================================
000072D0                            ; Ball mode enable/disable object
000072D0                            ; =========================================================================================================================================================
000072D0                            		rsset	_objLvlSSTs
000072D0 =00000030                  _objBModeTouch	rs.b	1				; Touched flag
000072D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072D0                            ObjBallMode:
000072D0                            	;	move.l	#ObjBallMode_Main,_objAddress(a0)	; Next routine
000072D0                            	;	move.l	#Map_ObjMonitor,_objMapping(a0)	; Mappings
000072D0                            	;	clr.w	_objVRAM(a0)			; Tile properties
000072D0                            	;	ori.b	#4,_objRender(a0)			; Render flags
000072D0                            	;	move.w	#rSprInput+$280,oPrio(a0)	; Priority
000072D0                            	;	move.b	#$10,_objDrawW(a0)			; Sprite width
000072D0                            	;	move.b	#$10,_objDrawH(a0)			; Sprite height
000072D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072D0                            ObjBallMode_Main:
000072D0 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
000072D4 3478 E876                  		movea.w	playerPtrP1.w,a2		; Player object
000072D8 4EB8 1D62                  		jsr	CheckObjInRange.w		; Is the player in range?
000072DC 4A40                       		tst.w	d0				; ''
000072DE 6700                       		beq.s	.NotTouched			; If not, branch
000072E0                            
000072E0 08AA 0002 000C             		bclr	#2,_objFlags(a2)
000072E6                            		
000072E6 4A28 0024                  		tst.b	_objSubtype(a0)			; Should we force Sonic out of ball mode?
000072EA 6B00                       		bmi.s	.NoBallMode			; If so, branch
000072EC 6600                       		bne.s	.BallMode			; Branch if we should force Sonic in to ball mode
000072EE                            
000072EE 4A28 0030                  		tst.b	_objBModeTouch(a0)		; Have we already been touched?
000072F2 6600                       		bne.s	.End				; If so, branch
000072F4 50E8 0030                  		st	_objBModeTouch(a0)		; Touched
000072F8                            
000072F8 462A 004B                  		not.b	_objBallMode(a2)		; Switch ball mode for Sonic
000072FC 6700                       		beq.s	.End				; If it's not set, branch
000072FE                            
000072FE                            .MakeSonicRoll:
000072FE 2248                       		movea.l	a0,a1				; Save a0
00007300 204A                       		movea.l	a2,a0				; Make Sonic roll
00007302 4EB8 58C4                  		jsr	ObjPlayer_DoRoll		; ''
00007306 2049                       		movea.l	a1,a0				; Restore a0
00007308                            	nextObject
00007308 3068 0004                M 	movea.w	_objnext(a0),a0
0000730C 2250                     M 	move.l	_objaddress(a0),a1
0000730E 4ED1                     M 	jmp	(a1)
00007310                            
00007310                            .NotTouched:
00007310 4228 0030                  		clr.b	_objBModeTouch(a0)		; Not touched
00007314                            	nextObject
00007314 3068 0004                M 	movea.w	_objnext(a0),a0
00007318 2250                     M 	move.l	_objaddress(a0),a1
0000731A 4ED1                     M 	jmp	(a1)
0000731C                            
0000731C                            .BallMode:
0000731C 50EA 004B                  		st	_objBallMode(a2)		; Get in to ball mode
00007320 60DC                       		bra.s	.MakeSonicRoll			; ''
00007322                            
00007322                            .NoBallMode:
00007322 422A 004B                  		clr.b	_objBallMode(a2)		; Get out of ball mode
00007326                            
00007326                            .End:
00007326                            	nextObject
00007326 3068 0004                M 	movea.w	_objnext(a0),a0
0000732A 2250                     M 	move.l	_objaddress(a0),a1
0000732C 4ED1                     M 	jmp	(a1)
0000732E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000732E                            .RangeData:
0000732E FFF0 0020                  		dc.w	-$10, $20
00007332 FFF0 0020                  		dc.w	-$10, $20
00007336                            ; =========================================================================================================================================================
00007336                            		include	"Objects/Bumper/Code.asm"		; Bumper object
00007336                            ; =========================================================================================================================================================
00007336                            ; Water surface object
00007336                            ; =========================================================================================================================================================
00007336                            		rsset	_objLvlSSTs
00007336                            
00007336                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007336                            ObjAttack:
00007336 20BC 0000 0000             		move.l	#ObjBumperMain,_objAddress(a0)	; Next routine
0000733C 217C 0000 0000 0010        		move.l	#Map_ObjBumper,_objMapping(a0)		; Mappings
00007344 317C 035B 000E             		move.w	#$35B,_objVRAM(a0)			; Tile properties
0000734A 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00007350                            		displaySprite	1,a0,a1,0			; Priority
00007350 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
00007356 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
0000735A 3149 000A                M 	move.w	a1,_objdrawprev(a0)
0000735E 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00007362 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
00007366                          M .no_273
00007366 7210                       		moveq	#$10,d1
00007368                            	;	move.b	d1,_objDrawW(a0)
00007368                            	;	move.b	d1,_objColW(a0)
00007368                            	;	move.b	d1,_objDrawH(a0)
00007368                            	;	move.b	d1,_objColH(a0)
00007368                            		
00007368                            
00007368                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007368                            ObjBumperMain:
00007368 0C68 0000 0024             		cmpi.w	#0,	_objSubtype(a0)
0000736E 6700                       		beq.s	.AttackX
00007370                            		
00007370 0668 FFF6 0014             		add.w	#-10,_objXPos(a0)
00007376 6000                       		bra.s	.cont
00007378                            		
00007378                            	.AttackX:
00007378 0668 000A 0014             		add.w	#10,_objXPos(a0)
0000737E                            	.cont:
0000737E 5328 0017                  		subq.b	#1,	_objDrawW(a0)
00007382 4A28 0017                  		tst.b	_objDrawW(a0)
00007386 6700 0000                  		beq.w	ObjAttack_Delete
0000738A                            		
0000738A                            	nextObject
0000738A 3068 0004                M 	movea.w	_objnext(a0),a0
0000738E 2250                     M 	move.l	_objaddress(a0),a1
00007390 4ED1                     M 	jmp	(a1)
00007392                            
00007392                            ObjAttack_Delete:
00007392                            	;	playSnd	#sCheckpoint, 2			; Play checkpoint sound
00007392 4EB8 1A4C                  		jsr	DeleteObject.w
00007396                            	nextObject
00007396 3068 0004                M 	movea.w	_objnext(a0),a0
0000739A 2250                     M 	move.l	_objaddress(a0),a1
0000739C 4ED1                     M 	jmp	(a1)
0000739E                            
0000739E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000739E                            ; Data
0000739E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000739E                            Map_ObjBumper:
0000739E                            		include	"Objects/Bumper/Mappings.asm"
0000739E                            Map_eb08:
0000739E 0000                       Map_eb08_0: 	dc.w Map_eb08_2-Map_eb08
000073A0 0001                       Map_eb08_2: 	dc.b $0, $1
000073A2 FC04 0000 FFF8             	dc.b $FC, $4, $0, $0, $FF, $F8
000073A8                            	even
000073A8                            		even
000073A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000073A8                            Ani_ObjBumper:
000073A8 0000                       		dc.w	.Ani0-Ani_ObjBumper
000073AA 0000                       		dc.w	.Ani1-Ani_ObjBumper
000073AC 0500 FF00                  .Ani0:		dc.b	5, 0, $FF, 0
000073B0 0501 0201 02FD 00          .Ani1:		dc.b	5, 1, 2, 1, 2, $FD, 0
000073B8 00                         		even
000073B8                            ; =========================================================================================================================================================
000073B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000073B8                            ; Unused/Temporary
000073B8                            ;		include	"Objects/Slicer/Code.asm"		; Slicer object
000073B8                            ;		include	"Objects/Shellcracker/Code.asm"	; Shellcracker object
000073B8                            ;		include	"Objects/Asteron/Code.asm"	; Asteron object
000073B8                            ;		include	"Objects/Boss - WFZ/Code.asm"	; WFZ boss object
000073B8                            ;		include	"Objects/Harpoon/Code.asm"	; Harpoon object
000073B8                            ;		include	"Objects/CNZ Barrel/Code.asm"	; CNZ barrel object
000073B8                            ;		include	"Objects/Diamond/Code.asm"	; Diamond object
000073B8                            ;		include	"Objects/Orbinaut/Code.asm"	; Orbinaut object
000073B8                            
000073B8                            ; =========================================================================================================================================================
000073B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000073B8                            ; Object Art
000073B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000073B8                            ArtUnc_Sonic:
000073B8                            		incbin	"Graphics/Sprites/Sonic/Art.unc"
00007538                            		even
00007538                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007538                            ArtKosM_Bumper:
00007538                            		incbin	"Graphics/Sprites/Bumper/Art.kosm"
00007556                            		even
00007556                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007556                            ArtKosM_Chkpoint:
00007556                            		incbin	"Graphics/Sprites/Checkpoint/Art.kosm"
00007656 00                         		even
00007656                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007656                            ArtKosM_DrownCnt:
00007656                            		incbin	"Graphics/Sprites/Drown Countdown/Art.kosm"
00007C28 00                         		even
00007C28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007C28                            ArtKosM_Explosion:
00007C28                            		incbin	"Graphics/Sprites/Explosion/Art.kosm"
000080BA                            		even
000080BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000080BA                            ArtKosM_Monitor:
000080BA                            		incbin	"Graphics/Sprites/Monitor/Art.kosm"
000083DC 00                         		even
000083DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000083DC                            ArtUnc_Ring:
000083DC                            		incbin	"Graphics/Sprites/Ring/Art - Ring.unc"
000087DC                            		even
000087DC                            
000087DC                            ArtKosM_RingSparkle:
000087DC                            		incbin	"Graphics/Sprites/Ring/Art - Sparkle.kosm"
00008828 00                         		even
00008828                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008828                            ArtKosM_SpikesN:
00008828                            		incbin	"Graphics/Sprites/Spikes/Art - Normal.kosm"
00008868                            		even
00008868                            
00008868                            ArtKosM_SpikesS:
00008868                            		incbin	"Graphics/Sprites/Spikes/Art - Sideways.kosm"
000088AA 00                         		even
000088AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000088AA                            ArtKosM_SpringH:
000088AA                            		incbin	"Graphics/Sprites/Spring/Art - Horizontal.kosm"
00008986 00                         		even
00008986                            
00008986                            ArtKosM_SpringV:
00008986                            		incbin	"Graphics/Sprites/Spring/Art - Vertical.kosm"
00008A6C 00                         		even
00008A6C                            
00008A6C                            ArtKosM_SpringD:
00008A6C                            		incbin	"Graphics/Sprites/Spring/Art - Diagonal.kosm"
00008C86 00                         		even
00008C86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008C86                            ArtKosM_WaterSplash:
00008C86                            		incbin	"Graphics/Sprites/Water Splash/Art.kosm"
0000949A                            		even
0000949A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000949A                            ArtKosM_WaterSurface:
0000949A                            		incbin	"Graphics/Sprites/Water Surface/Art.kosm"
000095F4                            		even
000095F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000095F4                            ArtKosM_HUD:
000095F4                            		incbin	"Graphics/Sprites/HUD/Art - HUD Base.kosm"
0000966A                            		even
0000966A                            
0000966A                            ArtUnc_HUDNumbers:
0000966A                            		incbin	"Graphics/Sprites/HUD/Art - HUD Numbers.unc"
000098EA 0000 0000 0000 0000 0000+  		dcb.l	16, 0
0000992A                            		even
0000992A                            
0000992A                            ; =========================================================================================================================================================
0000992A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000992A                            ; Level data
0000992A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000992A                            ; Wacky Workbench Zone
0000992A                            
0000992A                            WWZ_FGLayout:
0000992A                            		incbin	"Zones/Wacky Workbench/Foreground.lvl"
0000A14C                            		even
0000A14C                            WWZ_BGLayout:
0000A14C                            		incbin	"Zones/Wacky Workbench/Background.lvl"
0000A172                            		even
0000A172                            
0000A172 FFFF 0000 0000             		dc.w	$FFFF, 0, 0				; Null object list entry
0000A178                            WWZ_Objects:
0000A178                            		incbin	"Zones/Wacky Workbench/Objects.bin"
0000A184                            		even
0000A184                            WWZ_Rings:
0000A184                            		incbin	"Zones/Wacky Workbench/Rings.bin"
0000A188                            		even
0000A188                            WWZ_Collision:
0000A188 0000 0000 0000 0000 0000+  		dc.l	.ColData, .Angles, .Heights, .HeightsR
0000A198                            .ColData:
0000A198                            		incbin	"Zones/Wacky Workbench/Collision.bin"
0000A798                            		even
0000A798                            .Angles:
0000A798                            		incbin	"Zones/Wacky Workbench/Angle Values.bin"
0000A898                            		even
0000A898                            .Heights:
0000A898                            		incbin	"Zones/Wacky Workbench/Height Values.bin"
0000B898                            		even
0000B898                            .HeightsR:
0000B898                            		incbin	"Zones/Wacky Workbench/Height Values (Rotated).bin"
0000C898                            		even
0000C898                            WWZ_Chunks:
0000C898                            		incbin	"Zones/Wacky Workbench/Chunks.bin"
0000C902                            		even
0000C902                            WWZ_Blocks:
0000C902                            		incbin	"Zones/Wacky Workbench/Blocks.bin"
0000C92C                            		even
0000C92C                            WWZ_Pal:
0000C92C 007F                       		dc.w	$100>>1-1
0000C92E                            		incbin	"Graphics/Palettes/Wacky Workbench/Normal.pal"
0000C9AE                                    WWZ_Pal_End:
0000C9AE                            		incbin	"Graphics/Palettes/Wacky Workbench/Water.pal"
0000CA2E                            		even
0000CA2E                            WWZ_Tiles:
0000CA2E                            		incbin	"Graphics/Tilesets/Wacky Workbench/Tiles.kosm"
0000CAB8                            		even
0000CAB8                            ArtUnc_Electricity:
0000CAB8                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electricity.unc"
0000CEB8                            		even
0000CEB8                            ArtUnc_ElectricOrbs:
0000CEB8                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electric Orbs.unc"
0000D0B8                            		even
0000D0B8                            ArtUnc_Sirens:
0000D0B8                            		incbin	"Graphics/Tilesets/Wacky Workbench/Sirens.unc"
0000D2B8                            		even
0000D2B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            ; =========================================================================================================================================================
0000D2B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000D2B8                            ; Sound driver
0000D2B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000D2B8                            		include	"Sound/amps/code/68k.asm"
0000D2B8                            	opt oz+					; enable zero-offset optimization
0000D2B8                            	opt l.					; local lables are dots
0000D2B8                            	opt ae+					; enable automatic even's
0000D2B8                            
0000D2B8                            	include "Sound/amps/code/routines.asm"	; include macro'd routines
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Note timout handler macro
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dNoteToutHandler	macro
0000D2B8                            		tst.b	cNoteTimeCur(a5)	; check if timer is 0
0000D2B8                            		beq.s	.endt			; if is, do not timeout
0000D2B8                            		subq.b	#1,cNoteTimeCur(a5)	; decrease delay by 1
0000D2B8                            		bne.s	.endt			; if still not 0, branch
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Note timout handler macro for DAC
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dNoteToutDAC	macro
0000D2B8                            	dNoteToutHandler			; include timeout handler
0000D2B8                            		moveq	#0,d0			; play stop sample
0000D2B8                            		bra.w	dNoteOnDAC2		; ''
0000D2B8                            .endt
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Note timout handler macro for FM
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dNoteToutFM	macro
0000D2B8                            	dNoteToutHandler			; include timeout handler
0000D2B8                            		bset	#cfbRest,(a5)		; set track to resting
0000D2B8                            		bsr.w	dKeyOffFM		; key off FM
0000D2B8                            		bra.\0	.next			; jump to next track
0000D2B8                            .endt
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Note timout handler macro for PSG
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dNoteToutPSG	macro
0000D2B8                            	dNoteToutHandler			; include timeout handler
0000D2B8                            		bset	#cfbRest,(a5)		; set track to resting
0000D2B8                            		bsr.w	dMutePSGmus		; mute PSG channel
0000D2B8                            		bra.s	.next			; jump to next track
0000D2B8                            .endt
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Macro for calculating the current frequency (without modulation) into d6.
0000D2B8                            ; Used if user wants to add extra pitch effects such as pitch slides.
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dCalcFreq	macro
0000D2B8                            		move.b	cDetune(a5),d6		; get detune value to d6
0000D2B8                            		ext.w	d6			; extend to word
0000D2B8                            		add.w	cFreq(a5),d6		; add channel base frequency to it
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Macro for generating frequency modulation code
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dModulate	macro jump,loop,type
0000D2B8                            		btst	#cfbMod,(a5)		; check if modulation is active
0000D2B8                            		beq.s	.noret			; if not, update volume and return
0000D2B8                            		tst.b	cModDelay(a5)		; check if there is delay left
0000D2B8                            		beq.s	.started		; if not, modulate!
0000D2B8                            		subq.b	#1,cModDelay(a5)	; decrease delay
0000D2B8                            .noret
0000D2B8                            	if narg>0
0000D2B8                            		if narg=3
0000D2B8                            			if type<2
0000D2B8                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000D2B8                            				beq.s	.noupdatevol		; if not, skip
0000D2B8                            				jsr	dUpdateVolFM(pc)	; update FM volume
0000D2B8                            			.noupdatevol:
0000D2B8                            			endif
0000D2B8                            			if type>=4
0000D2B8                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000D2B8                            				beq.s	.noupdatevol		; if not, skip
0000D2B8                            				jsr	dUpdateVolDAC(pc)	; update DAC volume
0000D2B8                            			.noupdatevol:
0000D2B8                            			endif
0000D2B8                            			if \type<>5
0000D2B8                            				dbf	d7,\loop		; loop for all channels
0000D2B8                            			endif
0000D2B8                            		endif
0000D2B8                            		bra.w	\jump			; jump to next routine
0000D2B8                            	else
0000D2B8                            		bra.s	.endm			; jump to the next .endm routine
0000D2B8                            	endif
0000D2B8                            .started
0000D2B8                            		subq.b	#1,cModSpeed(a5)	; decrease modulation speed counter
0000D2B8                            		bne.s	.noret			; if there's still delay left, update vol and return
0000D2B8                            		movea.l	cMod(a5),a1		; get modulation data offset to a1
0000D2B8                            		move.b	1(a1),cModSpeed(a5)	; reset modulation speed counter
0000D2B8                            		tst.b	cModCount(a5)		; check if this was the last step
0000D2B8                            		bne.s	.norev			; if was not, do not reverse
0000D2B8                            		move.b	3(a1),cModCount(a5)	; reset steps counter
0000D2B8                            		neg.b	cModStep(a5)		; negate step amount
0000D2B8                            .norev
0000D2B8                            		subq.b	#1,cModCount(a5)	; decrease step counter
0000D2B8                            		move.b	cModStep(a5),d5		; get step offset into d5
0000D2B8                            		ext.w	d5			; extend to word
0000D2B8                            		add.w	cModFreq(a5),d5		; add modulation frequency to it
0000D2B8                            		move.w	d5,cModFreq(a5)		; save as the modulation frequency
0000D2B8                            		add.w	d5,d6			; add to channel base frequency
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Macro for processing the tracker
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dDoTracker	macro
0000D2B8                            		movea.l	cData(a5),a4		; grab tracker address
0000D2B8                            	if safe=1
0000D2B8                            		AMPS_Debug_TrackUpd		; check if this address is valid
0000D2B8                            	endif
0000D2B8                            .data
0000D2B8                            		moveq	#0,d5
0000D2B8                            		move.b	(a4)+,d5		; get a byte from tracker
0000D2B8                            		cmpi.b	#$E0,d5			; is this a command?
0000D2B8                            		blo.s	.notcomm		; if not, continue
0000D2B8                            		jsr	dCommands(pc)		; run the condition flag
0000D2B8                            		bra.s	.data			; for most commands, use this branch to loop
0000D2B8                            		bra.s	.next			; however, for example sStop will make us return here.
0000D2B8                            .notcomm
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Macro for playing a note, and setting up for it (software updates only)
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dProcNote	macro sfx, psg
0000D2B8                            		move.l	a4,cData(a5)		; save tracker address
0000D2B8                            		move.b	cLastDur(a5),cDuration(a5); copy stored duration
0000D2B8                            		btst	#cfbHold,(a5)		; check if we are holding
0000D2B8                            		bne.s	.endpn			; if we are, branch
0000D2B8                            	if sfx=0
0000D2B8                            		move.b	cNoteTimeMain(a5),cNoteTimeCur(a5); copy note timeout value
0000D2B8                            	endif
0000D2B8                            	if psg<>0
0000D2B8                            		clr.b	cEnvPos(a5)		; clear envelope position if PSG channel
0000D2B8                            	endif
0000D2B8                            		btst	#cfbMod,(a5)		; check if modulation is enabled
0000D2B8                            		beq.s	.endpn			; if not, branch
0000D2B8                            		movea.l	cMod(a5),a1		; get modulation data address
0000D2B8                            		move.b	(a1)+,cModDelay(a5)	; copy delay
0000D2B8                            		move.b	(a1)+,cModSpeed(a5)	; copy speed
0000D2B8                            		move.b	(a1)+,cModStep(a5)	; copy step offset
0000D2B8                            		move.b	(a1),d0			; get number of steps
0000D2B8                            		lsr.b	#1,d0			; halve it
0000D2B8                            		move.b	d0,cModCount(a5)	; save as the current number of steps
0000D2B8                            		clr.w	cModFreq(a5)		; clear frequency offset
0000D2B8                            .endpn
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Macro for processing a note in DAC channel
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dTrackNoteDAC	macro
0000D2B8                            		btst	#cfbMode,(a5)		; check if we are on pitch mode
0000D2B8                            		bne.s	.pitch			; if so, load pitch
0000D2B8                            		move.b	d5,cSample(a5)		; else, save as a sample
0000D2B8                            		bra.s	.cont
0000D2B8                            .pitch
0000D2B8                            		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0000D2B8                            		bne.s	.noprest		; branch if note wasnt $80 (rest)
0000D2B8                            		moveq	#0,d0			; play stop sample
0000D2B8                            		bsr.w	dNoteOnDAC2		; ''
0000D2B8                            		moveq	#-$80,d6		; tell the code we are resting
0000D2B8                            		bra.s	.cont
0000D2B8                            .noprest
0000D2B8                            		add.b	cPitch(a5),d5		; add pitch offset to note
0000D2B8                            		add.w	d5,d5			; double offset (each entry is a word)
0000D2B8                            		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0000D2B8                            		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0000D2B8                            .cont
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Macro for doing keying-on FM channel
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dKeyOnFM	macro
0000D2B8                            		btst	#cfbHold,(a5)		; check if note is held
0000D2B8                            		bne.s	.k			; if so, do not note on
0000D2B8                            		btst	#cfbRest,(a5)		; check if channel is resting
0000D2B8                            		bne.s	.k			; if so, do not note on
0000D2B8                            	if narg=0
0000D2B8                            		btst	#cfbInt,(a5)		; check if overridden by sfx
0000D2B8                            		bne.s	.k			; if so, do not note on
0000D2B8                            	endif
0000D2B8                            		moveq	#$28,d0			; YM command: Key on
0000D2B8                            		move.b	cType(a5),d1		; get channel type bits
0000D2B8                            		ori.b	#$F0,d1			; turn all FM operators on
0000D2B8                            		bsr.w	WriteYM_Pt1		; send note-on event
0000D2B8                            .k
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Macro for processing a note in PSG channel
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            dGetFreqPSG	macro
0000D2B8                            		subi.b	#$81,d5			; sub $81 from the note (notes start at $80)
0000D2B8                            		bhs.s	.norest			; branch if note wasnt $80 (rest)
0000D2B8                            		bset	#cfbRest,(a5)		; set channel to resting
0000D2B8                            		move.w	#-1,cFreq(a5)		; set invalid PSG frequency
0000D2B8                            		jsr	dMutePSGmus(pc)		; mute this PSG channel
0000D2B8                            		bra.s	.freqgot
0000D2B8                            .norest
0000D2B8                            		add.b	cPitch(a5),d5		; add pitch offset to note
0000D2B8                            		andi.w	#$7F,d5			; keep within $80 notes
0000D2B8                            		add.w	d5,d5			; double offset (each entry is a word)
0000D2B8                            		move.w	(a6,d5.w),cFreq(a5)	; load and save the requested frequency
0000D2B8                            	if safe=1
0000D2B8                            		AMPS_Debug_NotePSG		; check if the note was valid
0000D2B8                            	endif
0000D2B8                            .freqgot
0000D2B8                                endm
0000D2B8                            ; ===========================================================================
0000D2B8                            	include "Sound/amps/code/debug.asm"	; debug data blob
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; write channel string to console
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            AMPS_Debug_GetChannel	macro
0000D2B8                            	cmp.w	#mPSG1,a5
0000D2B8                            	bne.s	AMPS_Debug_Writepsg2
0000D2B8                            	Console.Write "PSG1"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writepsg2
0000D2B8                            	cmp.w	#mPSG2,a5
0000D2B8                            	bne.s	AMPS_Debug_Writepsg3
0000D2B8                            	Console.Write "PSG2"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writepsg3
0000D2B8                            	cmp.w	#mPSG3,a5
0000D2B8                            	bne.s	AMPS_Debug_Writepsgs1
0000D2B8                            	Console.Write "PSG3"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writepsgs1
0000D2B8                            	cmp.w	#mSFXPSG1,a5
0000D2B8                            	bne.s	AMPS_Debug_Writepsgs2
0000D2B8                            	Console.Write "SFX PSG1"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writepsgs2
0000D2B8                            	cmp.w	#mSFXPSG2,a5
0000D2B8                            	bne.s	AMPS_Debug_Writepsgs3
0000D2B8                            	Console.Write "SFX PSG2"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writepsgs3
0000D2B8                            	cmp.w	#mSFXPSG3,a5
0000D2B8                            	bne.s	AMPS_Debug_Writedacs1
0000D2B8                            	Console.Write "SFX PSG3"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writedacs1
0000D2B8                            	cmp.w	#mSFXDAC1,a5
0000D2B8                            	bne.s	AMPS_Debug_Writedac1
0000D2B8                            	Console.Write "SFX DAC1"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writedac1
0000D2B8                            	cmp.w	#mDAC1,a5
0000D2B8                            	bne.s	AMPS_Debug_Writedac2
0000D2B8                            	Console.Write "DAC1"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writedac2
0000D2B8                            	cmp.w	#mDAC2,a5
0000D2B8                            	bne.s	AMPS_Debug_Writefm1
0000D2B8                            	Console.Write "DAC2"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writefm1
0000D2B8                            	cmp.w	#mFM1,a5
0000D2B8                            	bne.s	AMPS_Debug_Writefm2
0000D2B8                            	Console.Write "FM1"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writefm2
0000D2B8                            	cmp.w	#mFM2,a5
0000D2B8                            	bne.s	AMPS_Debug_Writefm3
0000D2B8                            	Console.Write "FM2"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writefm3
0000D2B8                            	cmp.w	#mFM3,a5
0000D2B8                            	bne.s	AMPS_Debug_Writefm4
0000D2B8                            	Console.Write "FM3"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writefm4
0000D2B8                            	cmp.w	#mFM4,a5
0000D2B8                            	bne.s	AMPS_Debug_Writefm5
0000D2B8                            	Console.Write "FM4"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writefm5
0000D2B8                            	cmp.w	#mFM5,a5
0000D2B8                            	bne.s	AMPS_Debug_Writefms3
0000D2B8                            	Console.Write "FM5"
0000D2B8                            	bra.w	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writefms3
0000D2B8                            	cmp.w	#mSFXFM3,a5
0000D2B8                            	bne.s	AMPS_Debug_Writefms4
0000D2B8                            	Console.Write "SFX FM3"
0000D2B8                            	rts
0000D2B8                            AMPS_Debug_Writefms4
0000D2B8                            	cmp.w	#mSFXFM4,a5
0000D2B8                            	bne.s	AMPS_Debug_Writefms5
0000D2B8                            	Console.Write "SFX FM4"
0000D2B8                            	bra.s	AMPS_Debug_Writeend
0000D2B8                            AMPS_Debug_Writefms5
0000D2B8                            	cmp.w	#mSFXFM5,a5
0000D2B8                            	beq.s	AMPS_Debug_Writefms5_
0000D2B8                            AMPS_Debug_Writeaddr
0000D2B8                            	Console.Write "%<fpal2>%<.l a5>"
0000D2B8                            	rts
0000D2B8                            AMPS_Debug_Writefms5_
0000D2B8                            	Console.Write "SFX FM5"
0000D2B8                            AMPS_Debug_Writeend
0000D2B8                            	endm
0000D2B8                            ; ===========================================================================
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            ; Channel console code
0000D2B8                            ; ---------------------------------------------------------------------------
0000D2B8                            
0000D2B8                            AMPS_Debug_Console_Channel:
0000D2B8                            	Console.WriteLine "  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2B8 40E7                     M 	move.w	sr,-(sp)
0000D2BA                          M 	__fstring_generateargumentscode	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2BA =00000000                M 	__stack:set	0
0000D2BA =00000000                M 	__sp:	set 0
0000D2BA                          M 	while	(__pos)
0000D2BA =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2BA =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2BA =0000000A                M 	__midpos:	= __endpos
0000D2BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2BA =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2BA =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2BA =00000016                M 	__midpos:	= __endpos
0000D2BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2BA =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2BA =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2BA =0000001E                M 	__midpos:	= __endpos
0000D2BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	pushp	"move.l d0,-(sp)"
0000D2BA =00000001                M 	__stack:	= __stack+1
0000D2BA =00000004                M 	__sp:	= __sp+4
0000D2BA =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2BA =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2BA =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2BA =00000028                M 	__midpos:	= __endpos
0000D2BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2BA =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2BA =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2BA =00000034                M 	__midpos:	= __endpos
0000D2BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2BA =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2BA =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2BA =0000003C                M 	__midpos:	= __endpos
0000D2BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2BA                          M 	pushp	"move.l a0,-(sp)"
0000D2BA =00000002                M 	__stack:	= __stack+1
0000D2BA =00000008                M 	__sp:	= __sp+4
0000D2BA =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2BA                          M 	rept	__stack
0000D2BA                          M 	popp	__command
0000D2BA 2F08                     M 	move.l	a0,-(sp)
0000D2BC                          M 	popp	__command
0000D2BC 2F00                     M 	move.l	d0,-(sp)
0000D2BE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D2C2 45EF 0010                M 	lea	4*4(sp),a2
0000D2C6 43FA 0000                M 	lea	.str_276(pc),a1
0000D2CA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D2D0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D2D4 504F                     M 	addq.w	#__sp,sp
0000D2D6 46DF                     M 	move.w	(sp)+,sr
0000D2D8 6000 0000                M 	bra.w	.instr_end_276
0000D2DC                          M 	.str_276:
0000D2DC                          M 	__fstring_generatedecodedstring	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2DC =00000001                M 	__lpos:	set 1
0000D2DC =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2DC                          M 	while	(__pos)
0000D2DC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2DC 2020                     M 	dc.b	"  "
0000D2DE =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2DE =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2DE =0000000A                M 	__midpos:	= __endpos
0000D2DE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2DE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2DE E8                       M 	dc.b	fpal0
0000D2DF =0000000B                M 	__lpos:	set __endpos+1
0000D2DF =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2DF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2DF 6430 3A20                M 	dc.b	"d0: "
0000D2E3 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2E3 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2E3 =00000016                M 	__midpos:	= __endpos
0000D2E3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2E3                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2E3 EC                       M 	dc.b	fpal2
0000D2E4 =00000017                M 	__lpos:	set __endpos+1
0000D2E4 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2E4                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2E4                          M 	dc.b	""
0000D2E4 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2E4 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2E4 =0000001E                M 	__midpos:	= __endpos
0000D2E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2E4                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2E4                          M 	__param:	substr ,,"hex"
0000D2E4 83                       M 	dc.b	hex|3
0000D2E5 =0000001F                M 	__lpos:	set __endpos+1
0000D2E5 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2E5                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2E5 2020                     M 	dc.b	"  "
0000D2E7 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2E7 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2E7 =00000028                M 	__midpos:	= __endpos
0000D2E7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2E7                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2E7 E8                       M 	dc.b	fpal0
0000D2E8 =00000029                M 	__lpos:	set __endpos+1
0000D2E8 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2E8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2E8 6130 3A20                M 	dc.b	"a0: "
0000D2EC =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2EC =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2EC =00000034                M 	__midpos:	= __endpos
0000D2EC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2EC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2EC EC                       M 	dc.b	fpal2
0000D2ED =00000035                M 	__lpos:	set __endpos+1
0000D2ED =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2ED                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2ED                          M 	dc.b	""
0000D2ED =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2ED =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2ED =0000003C                M 	__midpos:	= __endpos
0000D2ED                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2ED                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2ED                          M 	__param:	substr ,,"hex"
0000D2ED 83                       M 	dc.b	hex|3
0000D2EE =0000003D                M 	__lpos:	set __endpos+1
0000D2EE =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2EE                          M 	__substr:	substr __lpos,,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2EE                          M 	dc.b	""
0000D2EE 00                       M 	dc.b	0
0000D2F0 00                       M 	even
0000D2F0                          M 	.instr_end_276:
0000D2F0                            	Console.WriteLine "  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F0 40E7                     M 	move.w	sr,-(sp)
0000D2F2                          M 	__fstring_generateargumentscode	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2 =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2F2 =00000000                M 	__stack:set	0
0000D2F2 =00000000                M 	__sp:	set 0
0000D2F2                          M 	while	(__pos)
0000D2F2 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2F2 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2F2 =0000000A                M 	__midpos:	= __endpos
0000D2F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2F2 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2F2 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2F2 =00000016                M 	__midpos:	= __endpos
0000D2F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2F2 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2F2 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2F2 =0000001E                M 	__midpos:	= __endpos
0000D2F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	pushp	"move.l d1,-(sp)"
0000D2F2 =00000001                M 	__stack:	= __stack+1
0000D2F2 =00000004                M 	__sp:	= __sp+4
0000D2F2 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2F2 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2F2 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2F2 =00000028                M 	__midpos:	= __endpos
0000D2F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2F2 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2F2 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2F2 =00000034                M 	__midpos:	= __endpos
0000D2F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2F2 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2F2 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2F2 =0000003C                M 	__midpos:	= __endpos
0000D2F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2F2                          M 	pushp	"move.l a1,-(sp)"
0000D2F2 =00000002                M 	__stack:	= __stack+1
0000D2F2 =00000008                M 	__sp:	= __sp+4
0000D2F2 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2F2                          M 	rept	__stack
0000D2F2                          M 	popp	__command
0000D2F2 2F09                     M 	move.l	a1,-(sp)
0000D2F4                          M 	popp	__command
0000D2F4 2F01                     M 	move.l	d1,-(sp)
0000D2F6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D2FA 45EF 0010                M 	lea	4*4(sp),a2
0000D2FE 43FA 0000                M 	lea	.str_279(pc),a1
0000D302 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D308 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D30C 504F                     M 	addq.w	#__sp,sp
0000D30E 46DF                     M 	move.w	(sp)+,sr
0000D310 6000 0000                M 	bra.w	.instr_end_279
0000D314                          M 	.str_279:
0000D314                          M 	__fstring_generatedecodedstring	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D314 =00000001                M 	__lpos:	set 1
0000D314 =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D314                          M 	while	(__pos)
0000D314                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D314 2020                     M 	dc.b	"  "
0000D316 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D316 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D316 =0000000A                M 	__midpos:	= __endpos
0000D316                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D316                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D316 E8                       M 	dc.b	fpal0
0000D317 =0000000B                M 	__lpos:	set __endpos+1
0000D317 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D317                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D317 6431 3A20                M 	dc.b	"d1: "
0000D31B =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D31B =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D31B =00000016                M 	__midpos:	= __endpos
0000D31B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D31B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D31B EC                       M 	dc.b	fpal2
0000D31C =00000017                M 	__lpos:	set __endpos+1
0000D31C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D31C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D31C                          M 	dc.b	""
0000D31C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D31C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D31C =0000001E                M 	__midpos:	= __endpos
0000D31C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D31C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D31C                          M 	__param:	substr ,,"hex"
0000D31C 83                       M 	dc.b	hex|3
0000D31D =0000001F                M 	__lpos:	set __endpos+1
0000D31D =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D31D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D31D 2020                     M 	dc.b	"  "
0000D31F =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D31F =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D31F =00000028                M 	__midpos:	= __endpos
0000D31F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D31F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D31F E8                       M 	dc.b	fpal0
0000D320 =00000029                M 	__lpos:	set __endpos+1
0000D320 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D320                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D320 6131 3A20                M 	dc.b	"a1: "
0000D324 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D324 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D324 =00000034                M 	__midpos:	= __endpos
0000D324                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D324                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D324 EC                       M 	dc.b	fpal2
0000D325 =00000035                M 	__lpos:	set __endpos+1
0000D325 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D325                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D325                          M 	dc.b	""
0000D325 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D325 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D325 =0000003C                M 	__midpos:	= __endpos
0000D325                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D325                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D325                          M 	__param:	substr ,,"hex"
0000D325 83                       M 	dc.b	hex|3
0000D326 =0000003D                M 	__lpos:	set __endpos+1
0000D326 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D326                          M 	__substr:	substr __lpos,,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D326                          M 	dc.b	""
0000D326 00                       M 	dc.b	0
0000D328 00                       M 	even
0000D328                          M 	.instr_end_279:
0000D328                            	Console.WriteLine "  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D328 40E7                     M 	move.w	sr,-(sp)
0000D32A                          M 	__fstring_generateargumentscode	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D32A =00000000                M 	__stack:set	0
0000D32A =00000000                M 	__sp:	set 0
0000D32A                          M 	while	(__pos)
0000D32A =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D32A =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D32A =0000000A                M 	__midpos:	= __endpos
0000D32A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D32A =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D32A =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D32A =00000016                M 	__midpos:	= __endpos
0000D32A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D32A =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D32A =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D32A =0000001E                M 	__midpos:	= __endpos
0000D32A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	pushp	"move.l d2,-(sp)"
0000D32A =00000001                M 	__stack:	= __stack+1
0000D32A =00000004                M 	__sp:	= __sp+4
0000D32A =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D32A =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D32A =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D32A =00000028                M 	__midpos:	= __endpos
0000D32A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D32A =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D32A =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D32A =00000034                M 	__midpos:	= __endpos
0000D32A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D32A =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D32A =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D32A =0000003C                M 	__midpos:	= __endpos
0000D32A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D32A                          M 	pushp	"move.l a2,-(sp)"
0000D32A =00000002                M 	__stack:	= __stack+1
0000D32A =00000008                M 	__sp:	= __sp+4
0000D32A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D32A                          M 	rept	__stack
0000D32A                          M 	popp	__command
0000D32A 2F0A                     M 	move.l	a2,-(sp)
0000D32C                          M 	popp	__command
0000D32C 2F02                     M 	move.l	d2,-(sp)
0000D32E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D332 45EF 0010                M 	lea	4*4(sp),a2
0000D336 43FA 0000                M 	lea	.str_282(pc),a1
0000D33A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D340 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D344 504F                     M 	addq.w	#__sp,sp
0000D346 46DF                     M 	move.w	(sp)+,sr
0000D348 6000 0000                M 	bra.w	.instr_end_282
0000D34C                          M 	.str_282:
0000D34C                          M 	__fstring_generatedecodedstring	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D34C =00000001                M 	__lpos:	set 1
0000D34C =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D34C                          M 	while	(__pos)
0000D34C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D34C 2020                     M 	dc.b	"  "
0000D34E =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D34E =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D34E =0000000A                M 	__midpos:	= __endpos
0000D34E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D34E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D34E E8                       M 	dc.b	fpal0
0000D34F =0000000B                M 	__lpos:	set __endpos+1
0000D34F =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D34F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D34F 6432 3A20                M 	dc.b	"d2: "
0000D353 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D353 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D353 =00000016                M 	__midpos:	= __endpos
0000D353                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D353                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D353 EC                       M 	dc.b	fpal2
0000D354 =00000017                M 	__lpos:	set __endpos+1
0000D354 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D354                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D354                          M 	dc.b	""
0000D354 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D354 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D354 =0000001E                M 	__midpos:	= __endpos
0000D354                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D354                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D354                          M 	__param:	substr ,,"hex"
0000D354 83                       M 	dc.b	hex|3
0000D355 =0000001F                M 	__lpos:	set __endpos+1
0000D355 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D355                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D355 2020                     M 	dc.b	"  "
0000D357 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D357 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D357 =00000028                M 	__midpos:	= __endpos
0000D357                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D357                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D357 E8                       M 	dc.b	fpal0
0000D358 =00000029                M 	__lpos:	set __endpos+1
0000D358 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D358                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D358 6132 3A20                M 	dc.b	"a2: "
0000D35C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D35C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D35C =00000034                M 	__midpos:	= __endpos
0000D35C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D35C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D35C EC                       M 	dc.b	fpal2
0000D35D =00000035                M 	__lpos:	set __endpos+1
0000D35D =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D35D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D35D                          M 	dc.b	""
0000D35D =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D35D =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D35D =0000003C                M 	__midpos:	= __endpos
0000D35D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D35D                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D35D                          M 	__param:	substr ,,"hex"
0000D35D 83                       M 	dc.b	hex|3
0000D35E =0000003D                M 	__lpos:	set __endpos+1
0000D35E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D35E                          M 	__substr:	substr __lpos,,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D35E                          M 	dc.b	""
0000D35E 00                       M 	dc.b	0
0000D360 00                       M 	even
0000D360                          M 	.instr_end_282:
0000D360                            	Console.WriteLine "  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D360 40E7                     M 	move.w	sr,-(sp)
0000D362                          M 	__fstring_generateargumentscode	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362 =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D362 =00000000                M 	__stack:set	0
0000D362 =00000000                M 	__sp:	set 0
0000D362                          M 	while	(__pos)
0000D362 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D362 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D362 =0000000A                M 	__midpos:	= __endpos
0000D362                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D362 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D362 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D362 =00000016                M 	__midpos:	= __endpos
0000D362                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D362 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D362 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D362 =0000001E                M 	__midpos:	= __endpos
0000D362                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	pushp	"move.l d3,-(sp)"
0000D362 =00000001                M 	__stack:	= __stack+1
0000D362 =00000004                M 	__sp:	= __sp+4
0000D362 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D362 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D362 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D362 =00000028                M 	__midpos:	= __endpos
0000D362                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D362 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D362 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D362 =00000034                M 	__midpos:	= __endpos
0000D362                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D362 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D362 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D362 =0000003C                M 	__midpos:	= __endpos
0000D362                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D362                          M 	pushp	"move.l a3,-(sp)"
0000D362 =00000002                M 	__stack:	= __stack+1
0000D362 =00000008                M 	__sp:	= __sp+4
0000D362 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D362                          M 	rept	__stack
0000D362                          M 	popp	__command
0000D362 2F0B                     M 	move.l	a3,-(sp)
0000D364                          M 	popp	__command
0000D364 2F03                     M 	move.l	d3,-(sp)
0000D366 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D36A 45EF 0010                M 	lea	4*4(sp),a2
0000D36E 43FA 0000                M 	lea	.str_285(pc),a1
0000D372 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D378 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D37C 504F                     M 	addq.w	#__sp,sp
0000D37E 46DF                     M 	move.w	(sp)+,sr
0000D380 6000 0000                M 	bra.w	.instr_end_285
0000D384                          M 	.str_285:
0000D384                          M 	__fstring_generatedecodedstring	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D384 =00000001                M 	__lpos:	set 1
0000D384 =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D384                          M 	while	(__pos)
0000D384                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D384 2020                     M 	dc.b	"  "
0000D386 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D386 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D386 =0000000A                M 	__midpos:	= __endpos
0000D386                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D386                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D386 E8                       M 	dc.b	fpal0
0000D387 =0000000B                M 	__lpos:	set __endpos+1
0000D387 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D387                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D387 6433 3A20                M 	dc.b	"d3: "
0000D38B =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D38B =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D38B =00000016                M 	__midpos:	= __endpos
0000D38B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D38B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D38B EC                       M 	dc.b	fpal2
0000D38C =00000017                M 	__lpos:	set __endpos+1
0000D38C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D38C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D38C                          M 	dc.b	""
0000D38C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D38C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D38C =0000001E                M 	__midpos:	= __endpos
0000D38C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D38C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D38C                          M 	__param:	substr ,,"hex"
0000D38C 83                       M 	dc.b	hex|3
0000D38D =0000001F                M 	__lpos:	set __endpos+1
0000D38D =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D38D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D38D 2020                     M 	dc.b	"  "
0000D38F =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D38F =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D38F =00000028                M 	__midpos:	= __endpos
0000D38F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D38F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D38F E8                       M 	dc.b	fpal0
0000D390 =00000029                M 	__lpos:	set __endpos+1
0000D390 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D390                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D390 6133 3A20                M 	dc.b	"a3: "
0000D394 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D394 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D394 =00000034                M 	__midpos:	= __endpos
0000D394                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D394                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D394 EC                       M 	dc.b	fpal2
0000D395 =00000035                M 	__lpos:	set __endpos+1
0000D395 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D395                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D395                          M 	dc.b	""
0000D395 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D395 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D395 =0000003C                M 	__midpos:	= __endpos
0000D395                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D395                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D395                          M 	__param:	substr ,,"hex"
0000D395 83                       M 	dc.b	hex|3
0000D396 =0000003D                M 	__lpos:	set __endpos+1
0000D396 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D396                          M 	__substr:	substr __lpos,,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D396                          M 	dc.b	""
0000D396 00                       M 	dc.b	0
0000D398 00                       M 	even
0000D398                          M 	.instr_end_285:
0000D398                            	Console.WriteLine "  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D398 40E7                     M 	move.w	sr,-(sp)
0000D39A                          M 	__fstring_generateargumentscode	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D39A =00000000                M 	__stack:set	0
0000D39A =00000000                M 	__sp:	set 0
0000D39A                          M 	while	(__pos)
0000D39A =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D39A =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D39A =0000000A                M 	__midpos:	= __endpos
0000D39A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D39A =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D39A =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D39A =00000016                M 	__midpos:	= __endpos
0000D39A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D39A =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D39A =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D39A =0000001E                M 	__midpos:	= __endpos
0000D39A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	pushp	"move.l d4,-(sp)"
0000D39A =00000001                M 	__stack:	= __stack+1
0000D39A =00000004                M 	__sp:	= __sp+4
0000D39A =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D39A =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D39A =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D39A =00000028                M 	__midpos:	= __endpos
0000D39A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D39A =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D39A =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D39A =00000034                M 	__midpos:	= __endpos
0000D39A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D39A =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D39A =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D39A =0000003C                M 	__midpos:	= __endpos
0000D39A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D39A                          M 	pushp	"move.l a4,-(sp)"
0000D39A =00000002                M 	__stack:	= __stack+1
0000D39A =00000008                M 	__sp:	= __sp+4
0000D39A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D39A                          M 	rept	__stack
0000D39A                          M 	popp	__command
0000D39A 2F0C                     M 	move.l	a4,-(sp)
0000D39C                          M 	popp	__command
0000D39C 2F04                     M 	move.l	d4,-(sp)
0000D39E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D3A2 45EF 0010                M 	lea	4*4(sp),a2
0000D3A6 43FA 0000                M 	lea	.str_288(pc),a1
0000D3AA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D3B0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D3B4 504F                     M 	addq.w	#__sp,sp
0000D3B6 46DF                     M 	move.w	(sp)+,sr
0000D3B8 6000 0000                M 	bra.w	.instr_end_288
0000D3BC                          M 	.str_288:
0000D3BC                          M 	__fstring_generatedecodedstring	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3BC =00000001                M 	__lpos:	set 1
0000D3BC =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D3BC                          M 	while	(__pos)
0000D3BC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3BC 2020                     M 	dc.b	"  "
0000D3BE =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D3BE =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D3BE =0000000A                M 	__midpos:	= __endpos
0000D3BE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3BE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3BE E8                       M 	dc.b	fpal0
0000D3BF =0000000B                M 	__lpos:	set __endpos+1
0000D3BF =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D3BF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3BF 6434 3A20                M 	dc.b	"d4: "
0000D3C3 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D3C3 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D3C3 =00000016                M 	__midpos:	= __endpos
0000D3C3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3C3                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3C3 EC                       M 	dc.b	fpal2
0000D3C4 =00000017                M 	__lpos:	set __endpos+1
0000D3C4 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D3C4                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3C4                          M 	dc.b	""
0000D3C4 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D3C4 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D3C4 =0000001E                M 	__midpos:	= __endpos
0000D3C4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3C4                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3C4                          M 	__param:	substr ,,"hex"
0000D3C4 83                       M 	dc.b	hex|3
0000D3C5 =0000001F                M 	__lpos:	set __endpos+1
0000D3C5 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D3C5                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3C5 2020                     M 	dc.b	"  "
0000D3C7 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D3C7 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D3C7 =00000028                M 	__midpos:	= __endpos
0000D3C7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3C7                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3C7 E8                       M 	dc.b	fpal0
0000D3C8 =00000029                M 	__lpos:	set __endpos+1
0000D3C8 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D3C8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3C8 6134 3A20                M 	dc.b	"a4: "
0000D3CC =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D3CC =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D3CC =00000034                M 	__midpos:	= __endpos
0000D3CC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3CC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3CC EC                       M 	dc.b	fpal2
0000D3CD =00000035                M 	__lpos:	set __endpos+1
0000D3CD =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D3CD                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3CD                          M 	dc.b	""
0000D3CD =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D3CD =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D3CD =0000003C                M 	__midpos:	= __endpos
0000D3CD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3CD                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3CD                          M 	__param:	substr ,,"hex"
0000D3CD 83                       M 	dc.b	hex|3
0000D3CE =0000003D                M 	__lpos:	set __endpos+1
0000D3CE =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D3CE                          M 	__substr:	substr __lpos,,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D3CE                          M 	dc.b	""
0000D3CE 00                       M 	dc.b	0
0000D3D0 00                       M 	even
0000D3D0                          M 	.instr_end_288:
0000D3D0                            	Console.WriteLine "  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D0 40E7                     M 	move.w	sr,-(sp)
0000D3D2                          M 	__fstring_generateargumentscode	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2 =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3D2 =00000000                M 	__stack:set	0
0000D3D2 =00000000                M 	__sp:	set 0
0000D3D2                          M 	while	(__pos)
0000D3D2 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3D2 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3D2 =0000000A                M 	__midpos:	= __endpos
0000D3D2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3D2 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3D2 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3D2 =00000016                M 	__midpos:	= __endpos
0000D3D2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3D2 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3D2 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3D2 =0000001E                M 	__midpos:	= __endpos
0000D3D2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	pushp	"move.l d5,-(sp)"
0000D3D2 =00000001                M 	__stack:	= __stack+1
0000D3D2 =00000004                M 	__sp:	= __sp+4
0000D3D2 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3D2 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3D2 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3D2 =00000028                M 	__midpos:	= __endpos
0000D3D2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3D2 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3D2 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3D2 =00000034                M 	__midpos:	= __endpos
0000D3D2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3D2 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3D2 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3D2 =0000003C                M 	__midpos:	= __endpos
0000D3D2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3D2                          M 	pushp	"move.l a5,-(sp)"
0000D3D2 =00000002                M 	__stack:	= __stack+1
0000D3D2 =00000008                M 	__sp:	= __sp+4
0000D3D2 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3D2                          M 	rept	__stack
0000D3D2                          M 	popp	__command
0000D3D2 2F0D                     M 	move.l	a5,-(sp)
0000D3D4                          M 	popp	__command
0000D3D4 2F05                     M 	move.l	d5,-(sp)
0000D3D6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D3DA 45EF 0010                M 	lea	4*4(sp),a2
0000D3DE 43FA 0000                M 	lea	.str_291(pc),a1
0000D3E2 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D3E8 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D3EC 504F                     M 	addq.w	#__sp,sp
0000D3EE 46DF                     M 	move.w	(sp)+,sr
0000D3F0 6000 0000                M 	bra.w	.instr_end_291
0000D3F4                          M 	.str_291:
0000D3F4                          M 	__fstring_generatedecodedstring	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3F4 =00000001                M 	__lpos:	set 1
0000D3F4 =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3F4                          M 	while	(__pos)
0000D3F4                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3F4 2020                     M 	dc.b	"  "
0000D3F6 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3F6 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3F6 =0000000A                M 	__midpos:	= __endpos
0000D3F6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3F6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3F6 E8                       M 	dc.b	fpal0
0000D3F7 =0000000B                M 	__lpos:	set __endpos+1
0000D3F7 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3F7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3F7 6435 3A20                M 	dc.b	"d5: "
0000D3FB =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3FB =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3FB =00000016                M 	__midpos:	= __endpos
0000D3FB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3FB                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3FB EC                       M 	dc.b	fpal2
0000D3FC =00000017                M 	__lpos:	set __endpos+1
0000D3FC =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3FC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3FC                          M 	dc.b	""
0000D3FC =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3FC =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3FC =0000001E                M 	__midpos:	= __endpos
0000D3FC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3FC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3FC                          M 	__param:	substr ,,"hex"
0000D3FC 83                       M 	dc.b	hex|3
0000D3FD =0000001F                M 	__lpos:	set __endpos+1
0000D3FD =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3FD                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3FD 2020                     M 	dc.b	"  "
0000D3FF =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3FF =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3FF =00000028                M 	__midpos:	= __endpos
0000D3FF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3FF                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3FF E8                       M 	dc.b	fpal0
0000D400 =00000029                M 	__lpos:	set __endpos+1
0000D400 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D400                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D400 6135 3A20                M 	dc.b	"a5: "
0000D404 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D404 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D404 =00000034                M 	__midpos:	= __endpos
0000D404                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D404                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D404 EC                       M 	dc.b	fpal2
0000D405 =00000035                M 	__lpos:	set __endpos+1
0000D405 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D405                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D405                          M 	dc.b	""
0000D405 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D405 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D405 =0000003C                M 	__midpos:	= __endpos
0000D405                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D405                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D405                          M 	__param:	substr ,,"hex"
0000D405 83                       M 	dc.b	hex|3
0000D406 =0000003D                M 	__lpos:	set __endpos+1
0000D406 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D406                          M 	__substr:	substr __lpos,,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D406                          M 	dc.b	""
0000D406 00                       M 	dc.b	0
0000D408 00                       M 	even
0000D408                          M 	.instr_end_291:
0000D408                            	Console.WriteLine "  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D408 40E7                     M 	move.w	sr,-(sp)
0000D40A                          M 	__fstring_generateargumentscode	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D40A =00000000                M 	__stack:set	0
0000D40A =00000000                M 	__sp:	set 0
0000D40A                          M 	while	(__pos)
0000D40A =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D40A =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D40A =0000000A                M 	__midpos:	= __endpos
0000D40A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D40A =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D40A =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D40A =00000016                M 	__midpos:	= __endpos
0000D40A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D40A =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D40A =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D40A =0000001E                M 	__midpos:	= __endpos
0000D40A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	pushp	"move.l d6,-(sp)"
0000D40A =00000001                M 	__stack:	= __stack+1
0000D40A =00000004                M 	__sp:	= __sp+4
0000D40A =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D40A =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D40A =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D40A =00000028                M 	__midpos:	= __endpos
0000D40A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D40A =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D40A =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D40A =00000034                M 	__midpos:	= __endpos
0000D40A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D40A =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D40A =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D40A =0000003C                M 	__midpos:	= __endpos
0000D40A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D40A                          M 	pushp	"move.l a6,-(sp)"
0000D40A =00000002                M 	__stack:	= __stack+1
0000D40A =00000008                M 	__sp:	= __sp+4
0000D40A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D40A                          M 	rept	__stack
0000D40A                          M 	popp	__command
0000D40A 2F0E                     M 	move.l	a6,-(sp)
0000D40C                          M 	popp	__command
0000D40C 2F06                     M 	move.l	d6,-(sp)
0000D40E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D412 45EF 0010                M 	lea	4*4(sp),a2
0000D416 43FA 0000                M 	lea	.str_294(pc),a1
0000D41A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D420 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D424 504F                     M 	addq.w	#__sp,sp
0000D426 46DF                     M 	move.w	(sp)+,sr
0000D428 6000 0000                M 	bra.w	.instr_end_294
0000D42C                          M 	.str_294:
0000D42C                          M 	__fstring_generatedecodedstring	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D42C =00000001                M 	__lpos:	set 1
0000D42C =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D42C                          M 	while	(__pos)
0000D42C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D42C 2020                     M 	dc.b	"  "
0000D42E =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D42E =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D42E =0000000A                M 	__midpos:	= __endpos
0000D42E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D42E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D42E E8                       M 	dc.b	fpal0
0000D42F =0000000B                M 	__lpos:	set __endpos+1
0000D42F =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D42F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D42F 6436 3A20                M 	dc.b	"d6: "
0000D433 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D433 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D433 =00000016                M 	__midpos:	= __endpos
0000D433                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D433                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D433 EC                       M 	dc.b	fpal2
0000D434 =00000017                M 	__lpos:	set __endpos+1
0000D434 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D434                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D434                          M 	dc.b	""
0000D434 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D434 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D434 =0000001E                M 	__midpos:	= __endpos
0000D434                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D434                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D434                          M 	__param:	substr ,,"hex"
0000D434 83                       M 	dc.b	hex|3
0000D435 =0000001F                M 	__lpos:	set __endpos+1
0000D435 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D435                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D435 2020                     M 	dc.b	"  "
0000D437 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D437 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D437 =00000028                M 	__midpos:	= __endpos
0000D437                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D437                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D437 E8                       M 	dc.b	fpal0
0000D438 =00000029                M 	__lpos:	set __endpos+1
0000D438 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D438                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D438 6136 3A20                M 	dc.b	"a6: "
0000D43C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D43C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D43C =00000034                M 	__midpos:	= __endpos
0000D43C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D43C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D43C EC                       M 	dc.b	fpal2
0000D43D =00000035                M 	__lpos:	set __endpos+1
0000D43D =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D43D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D43D                          M 	dc.b	""
0000D43D =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D43D =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D43D =0000003C                M 	__midpos:	= __endpos
0000D43D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D43D                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D43D                          M 	__param:	substr ,,"hex"
0000D43D 83                       M 	dc.b	hex|3
0000D43E =0000003D                M 	__lpos:	set __endpos+1
0000D43E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D43E                          M 	__substr:	substr __lpos,,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D43E                          M 	dc.b	""
0000D43E 00                       M 	dc.b	0
0000D440 00                       M 	even
0000D440                          M 	.instr_end_294:
0000D440                            	Console.WriteLine "  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D440 40E7                     M 	move.w	sr,-(sp)
0000D442                          M 	__fstring_generateargumentscode	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442 =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D442 =00000000                M 	__stack:set	0
0000D442 =00000000                M 	__sp:	set 0
0000D442                          M 	while	(__pos)
0000D442 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D442 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D442 =0000000A                M 	__midpos:	= __endpos
0000D442                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D442 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D442 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D442 =00000016                M 	__midpos:	= __endpos
0000D442                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D442 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D442 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D442 =0000001E                M 	__midpos:	= __endpos
0000D442                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	pushp	"move.l d7,-(sp)"
0000D442 =00000001                M 	__stack:	= __stack+1
0000D442 =00000004                M 	__sp:	= __sp+4
0000D442 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D442 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D442 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D442 =00000028                M 	__midpos:	= __endpos
0000D442                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D442 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D442 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D442 =00000034                M 	__midpos:	= __endpos
0000D442                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D442 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D442 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D442 =0000003C                M 	__midpos:	= __endpos
0000D442                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D442                          M 	pushp	"move.l a7,-(sp)"
0000D442 =00000002                M 	__stack:	= __stack+1
0000D442 =00000008                M 	__sp:	= __sp+4
0000D442 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D442                          M 	rept	__stack
0000D442                          M 	popp	__command
0000D442 2F0F                     M 	move.l	a7,-(sp)
0000D444                          M 	popp	__command
0000D444 2F07                     M 	move.l	d7,-(sp)
0000D446 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D44A 45EF 0010                M 	lea	4*4(sp),a2
0000D44E 43FA 0000                M 	lea	.str_297(pc),a1
0000D452 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D458 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D45C 504F                     M 	addq.w	#__sp,sp
0000D45E 46DF                     M 	move.w	(sp)+,sr
0000D460 6000 0000                M 	bra.w	.instr_end_297
0000D464                          M 	.str_297:
0000D464                          M 	__fstring_generatedecodedstring	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D464 =00000001                M 	__lpos:	set 1
0000D464 =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D464                          M 	while	(__pos)
0000D464                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D464 2020                     M 	dc.b	"  "
0000D466 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D466 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D466 =0000000A                M 	__midpos:	= __endpos
0000D466                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D466                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D466 E8                       M 	dc.b	fpal0
0000D467 =0000000B                M 	__lpos:	set __endpos+1
0000D467 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D467                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D467 6437 3A20                M 	dc.b	"d7: "
0000D46B =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D46B =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D46B =00000016                M 	__midpos:	= __endpos
0000D46B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D46B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D46B EC                       M 	dc.b	fpal2
0000D46C =00000017                M 	__lpos:	set __endpos+1
0000D46C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D46C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D46C                          M 	dc.b	""
0000D46C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D46C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D46C =0000001E                M 	__midpos:	= __endpos
0000D46C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D46C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D46C                          M 	__param:	substr ,,"hex"
0000D46C 83                       M 	dc.b	hex|3
0000D46D =0000001F                M 	__lpos:	set __endpos+1
0000D46D =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D46D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D46D 2020                     M 	dc.b	"  "
0000D46F =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D46F =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D46F =00000028                M 	__midpos:	= __endpos
0000D46F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D46F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D46F E8                       M 	dc.b	fpal0
0000D470 =00000029                M 	__lpos:	set __endpos+1
0000D470 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D470                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D470 7370 3A20                M 	dc.b	"sp: "
0000D474 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D474 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D474 =00000034                M 	__midpos:	= __endpos
0000D474                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D474                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D474 EC                       M 	dc.b	fpal2
0000D475 =00000035                M 	__lpos:	set __endpos+1
0000D475 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D475                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D475                          M 	dc.b	""
0000D475 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D475 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D475 =0000003C                M 	__midpos:	= __endpos
0000D475                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D475                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D475                          M 	__param:	substr ,,"hex"
0000D475 83                       M 	dc.b	hex|3
0000D476 =0000003D                M 	__lpos:	set __endpos+1
0000D476 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D476                          M 	__substr:	substr __lpos,,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D476                          M 	dc.b	""
0000D476 00                       M 	dc.b	0
0000D478 00                       M 	even
0000D478                          M 	.instr_end_297:
0000D478                            	Console.BreakLine
0000D478 40E7                     M 	move.w	sr,-(sp)
0000D47A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D480 46DF                     M 	move.w	(sp)+,sr
0000D482                            
0000D482                            	Console.Write "%<fpal1>Channel: %<fpal0>"
0000D482 40E7                     M 	move.w	sr,-(sp)
0000D484                          M 	__fstring_generateargumentscode	"%<fpal1>Channel: %<fpal0>"
0000D484 =00000001                M 	__pos:	set instr("%<fpal1>Channel: %<fpal0>",'%<')
0000D484 =00000000                M 	__stack:set	0
0000D484 =00000000                M 	__sp:	set 0
0000D484                          M 	while	(__pos)
0000D484 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D484 =00000011                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D484 =00000008                M 	__midpos:	= __endpos
0000D484                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D484                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D484 =00000012                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D484 =00000019                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D484 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D484 =00000019                M 	__midpos:	= __endpos
0000D484                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D484                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D484 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D484                          M 	rept	__stack
0000D484 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D488 43FA 0000                M 	lea	.str_301(pc),a1
0000D48C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D492 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D496 46DF                     M 	move.w	(sp)+,sr
0000D498 6000 0000                M 	bra.w	.instr_end_301
0000D49C                          M 	.str_301:
0000D49C                          M 	__fstring_generatedecodedstring	"%<fpal1>Channel: %<fpal0>"
0000D49C =00000001                M 	__lpos:	set 1
0000D49C =00000001                M 	__pos:	set instr("%<fpal1>Channel: %<fpal0>",'%<')
0000D49C                          M 	while	(__pos)
0000D49C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Channel: %<fpal0>"
0000D49C                          M 	dc.b	""
0000D49C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D49C =00000011                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D49C =00000008                M 	__midpos:	= __endpos
0000D49C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D49C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D49C EA                       M 	dc.b	fpal1
0000D49D =00000009                M 	__lpos:	set __endpos+1
0000D49D =00000012                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D49D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Channel: %<fpal0>"
0000D49D 4368 616E 6E65 6C3A 20   M 	dc.b	"Channel: "
0000D4A6 =00000019                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D4A6 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D4A6 =00000019                M 	__midpos:	= __endpos
0000D4A6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D4A6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D4A6 E8                       M 	dc.b	fpal0
0000D4A7 =0000001A                M 	__lpos:	set __endpos+1
0000D4A7 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D4A7                          M 	__substr:	substr __lpos,,"%<fpal1>Channel: %<fpal0>"
0000D4A7                          M 	dc.b	""
0000D4A7 00                       M 	dc.b	0
0000D4A8                          M 	even
0000D4A8                          M 	.instr_end_301:
0000D4A8                            	AMPS_Debug_GetChannel
0000D4A8 BAFC C5F8                M 	cmp.w	#mpsg1,a5
0000D4AC 6600                     M 	bne.s	amps_debug_writepsg2
0000D4AE                          M 	console.write	"PSG1"
0000D4AE 40E7                     M 	move.w	sr,-(sp)
0000D4B0                          M 	__fstring_generateargumentscode	"PSG1"
0000D4B0 =00000000                M 	__pos:	set instr("PSG1",'%<')
0000D4B0 =00000000                M 	__stack:set	0
0000D4B0 =00000000                M 	__sp:	set 0
0000D4B0                          M 	while	(__pos)
0000D4B0                          M 	rept	__stack
0000D4B0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D4B4 43FA 0000                M 	lea	.str_305(pc),a1
0000D4B8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D4BE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D4C2 46DF                     M 	move.w	(sp)+,sr
0000D4C4 6000 0000                M 	bra.w	.instr_end_305
0000D4C8                          M 	.str_305:
0000D4C8                          M 	__fstring_generatedecodedstring	"PSG1"
0000D4C8 =00000001                M 	__lpos:	set 1
0000D4C8 =00000000                M 	__pos:	set instr("PSG1",'%<')
0000D4C8                          M 	while	(__pos)
0000D4C8                          M 	__substr:	substr __lpos,,"PSG1"
0000D4C8 5053 4731                M 	dc.b	"PSG1"
0000D4CC 00                       M 	dc.b	0
0000D4CE 00                       M 	even
0000D4CE                          M 	.instr_end_305:
0000D4CE 6000 0000                M 	bra.w	amps_debug_writeend
0000D4D2                          M amps_debug_writepsg2
0000D4D2 BAFC C624                M 	cmp.w	#mpsg2,a5
0000D4D6 6600                     M 	bne.s	amps_debug_writepsg3
0000D4D8                          M 	console.write	"PSG2"
0000D4D8 40E7                     M 	move.w	sr,-(sp)
0000D4DA                          M 	__fstring_generateargumentscode	"PSG2"
0000D4DA =00000000                M 	__pos:	set instr("PSG2",'%<')
0000D4DA =00000000                M 	__stack:set	0
0000D4DA =00000000                M 	__sp:	set 0
0000D4DA                          M 	while	(__pos)
0000D4DA                          M 	rept	__stack
0000D4DA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D4DE 43FA 0000                M 	lea	.str_308(pc),a1
0000D4E2 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D4E8 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D4EC 46DF                     M 	move.w	(sp)+,sr
0000D4EE 6000 0000                M 	bra.w	.instr_end_308
0000D4F2                          M 	.str_308:
0000D4F2                          M 	__fstring_generatedecodedstring	"PSG2"
0000D4F2 =00000001                M 	__lpos:	set 1
0000D4F2 =00000000                M 	__pos:	set instr("PSG2",'%<')
0000D4F2                          M 	while	(__pos)
0000D4F2                          M 	__substr:	substr __lpos,,"PSG2"
0000D4F2 5053 4732                M 	dc.b	"PSG2"
0000D4F6 00                       M 	dc.b	0
0000D4F8 00                       M 	even
0000D4F8                          M 	.instr_end_308:
0000D4F8 6000 0000                M 	bra.w	amps_debug_writeend
0000D4FC                          M amps_debug_writepsg3
0000D4FC BAFC C650                M 	cmp.w	#mpsg3,a5
0000D500 6600                     M 	bne.s	amps_debug_writepsgs1
0000D502                          M 	console.write	"PSG3"
0000D502 40E7                     M 	move.w	sr,-(sp)
0000D504                          M 	__fstring_generateargumentscode	"PSG3"
0000D504 =00000000                M 	__pos:	set instr("PSG3",'%<')
0000D504 =00000000                M 	__stack:set	0
0000D504 =00000000                M 	__sp:	set 0
0000D504                          M 	while	(__pos)
0000D504                          M 	rept	__stack
0000D504 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D508 43FA 0000                M 	lea	.str_311(pc),a1
0000D50C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D512 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D516 46DF                     M 	move.w	(sp)+,sr
0000D518 6000 0000                M 	bra.w	.instr_end_311
0000D51C                          M 	.str_311:
0000D51C                          M 	__fstring_generatedecodedstring	"PSG3"
0000D51C =00000001                M 	__lpos:	set 1
0000D51C =00000000                M 	__pos:	set instr("PSG3",'%<')
0000D51C                          M 	while	(__pos)
0000D51C                          M 	__substr:	substr __lpos,,"PSG3"
0000D51C 5053 4733                M 	dc.b	"PSG3"
0000D520 00                       M 	dc.b	0
0000D522 00                       M 	even
0000D522                          M 	.instr_end_311:
0000D522 6000 0000                M 	bra.w	amps_debug_writeend
0000D526                          M amps_debug_writepsgs1
0000D526 BAFC C6EC                M 	cmp.w	#msfxpsg1,a5
0000D52A 6600                     M 	bne.s	amps_debug_writepsgs2
0000D52C                          M 	console.write	"SFX PSG1"
0000D52C 40E7                     M 	move.w	sr,-(sp)
0000D52E                          M 	__fstring_generateargumentscode	"SFX PSG1"
0000D52E =00000000                M 	__pos:	set instr("SFX PSG1",'%<')
0000D52E =00000000                M 	__stack:set	0
0000D52E =00000000                M 	__sp:	set 0
0000D52E                          M 	while	(__pos)
0000D52E                          M 	rept	__stack
0000D52E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D532 43FA 0000                M 	lea	.str_314(pc),a1
0000D536 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D53C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D540 46DF                     M 	move.w	(sp)+,sr
0000D542 6000 0000                M 	bra.w	.instr_end_314
0000D546                          M 	.str_314:
0000D546                          M 	__fstring_generatedecodedstring	"SFX PSG1"
0000D546 =00000001                M 	__lpos:	set 1
0000D546 =00000000                M 	__pos:	set instr("SFX PSG1",'%<')
0000D546                          M 	while	(__pos)
0000D546                          M 	__substr:	substr __lpos,,"SFX PSG1"
0000D546 5346 5820 5053 4731      M 	dc.b	"SFX PSG1"
0000D54E 00                       M 	dc.b	0
0000D550 00                       M 	even
0000D550                          M 	.instr_end_314:
0000D550 6000 0000                M 	bra.w	amps_debug_writeend
0000D554                          M amps_debug_writepsgs2
0000D554 BAFC C708                M 	cmp.w	#msfxpsg2,a5
0000D558 6600                     M 	bne.s	amps_debug_writepsgs3
0000D55A                          M 	console.write	"SFX PSG2"
0000D55A 40E7                     M 	move.w	sr,-(sp)
0000D55C                          M 	__fstring_generateargumentscode	"SFX PSG2"
0000D55C =00000000                M 	__pos:	set instr("SFX PSG2",'%<')
0000D55C =00000000                M 	__stack:set	0
0000D55C =00000000                M 	__sp:	set 0
0000D55C                          M 	while	(__pos)
0000D55C                          M 	rept	__stack
0000D55C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D560 43FA 0000                M 	lea	.str_317(pc),a1
0000D564 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D56A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D56E 46DF                     M 	move.w	(sp)+,sr
0000D570 6000 0000                M 	bra.w	.instr_end_317
0000D574                          M 	.str_317:
0000D574                          M 	__fstring_generatedecodedstring	"SFX PSG2"
0000D574 =00000001                M 	__lpos:	set 1
0000D574 =00000000                M 	__pos:	set instr("SFX PSG2",'%<')
0000D574                          M 	while	(__pos)
0000D574                          M 	__substr:	substr __lpos,,"SFX PSG2"
0000D574 5346 5820 5053 4732      M 	dc.b	"SFX PSG2"
0000D57C 00                       M 	dc.b	0
0000D57E 00                       M 	even
0000D57E                          M 	.instr_end_317:
0000D57E 6000 0000                M 	bra.w	amps_debug_writeend
0000D582                          M amps_debug_writepsgs3
0000D582 BAFC C724                M 	cmp.w	#msfxpsg3,a5
0000D586 6600                     M 	bne.s	amps_debug_writedacs1
0000D588                          M 	console.write	"SFX PSG3"
0000D588 40E7                     M 	move.w	sr,-(sp)
0000D58A                          M 	__fstring_generateargumentscode	"SFX PSG3"
0000D58A =00000000                M 	__pos:	set instr("SFX PSG3",'%<')
0000D58A =00000000                M 	__stack:set	0
0000D58A =00000000                M 	__sp:	set 0
0000D58A                          M 	while	(__pos)
0000D58A                          M 	rept	__stack
0000D58A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D58E 43FA 0000                M 	lea	.str_320(pc),a1
0000D592 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D598 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D59C 46DF                     M 	move.w	(sp)+,sr
0000D59E 6000 0000                M 	bra.w	.instr_end_320
0000D5A2                          M 	.str_320:
0000D5A2                          M 	__fstring_generatedecodedstring	"SFX PSG3"
0000D5A2 =00000001                M 	__lpos:	set 1
0000D5A2 =00000000                M 	__pos:	set instr("SFX PSG3",'%<')
0000D5A2                          M 	while	(__pos)
0000D5A2                          M 	__substr:	substr __lpos,,"SFX PSG3"
0000D5A2 5346 5820 5053 4733      M 	dc.b	"SFX PSG3"
0000D5AA 00                       M 	dc.b	0
0000D5AC 00                       M 	even
0000D5AC                          M 	.instr_end_320:
0000D5AC 6000 0000                M 	bra.w	amps_debug_writeend
0000D5B0                          M amps_debug_writedacs1
0000D5B0 BAFC C67C                M 	cmp.w	#msfxdac1,a5
0000D5B4 6600                     M 	bne.s	amps_debug_writedac1
0000D5B6                          M 	console.write	"SFX DAC1"
0000D5B6 40E7                     M 	move.w	sr,-(sp)
0000D5B8                          M 	__fstring_generateargumentscode	"SFX DAC1"
0000D5B8 =00000000                M 	__pos:	set instr("SFX DAC1",'%<')
0000D5B8 =00000000                M 	__stack:set	0
0000D5B8 =00000000                M 	__sp:	set 0
0000D5B8                          M 	while	(__pos)
0000D5B8                          M 	rept	__stack
0000D5B8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D5BC 43FA 0000                M 	lea	.str_323(pc),a1
0000D5C0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D5C6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D5CA 46DF                     M 	move.w	(sp)+,sr
0000D5CC 6000 0000                M 	bra.w	.instr_end_323
0000D5D0                          M 	.str_323:
0000D5D0                          M 	__fstring_generatedecodedstring	"SFX DAC1"
0000D5D0 =00000001                M 	__lpos:	set 1
0000D5D0 =00000000                M 	__pos:	set instr("SFX DAC1",'%<')
0000D5D0                          M 	while	(__pos)
0000D5D0                          M 	__substr:	substr __lpos,,"SFX DAC1"
0000D5D0 5346 5820 4441 4331      M 	dc.b	"SFX DAC1"
0000D5D8 00                       M 	dc.b	0
0000D5DA 00                       M 	even
0000D5DA                          M 	.instr_end_323:
0000D5DA 6000 0000                M 	bra.w	amps_debug_writeend
0000D5DE                          M amps_debug_writedac1
0000D5DE BAFC C4C4                M 	cmp.w	#mdac1,a5
0000D5E2 6600                     M 	bne.s	amps_debug_writedac2
0000D5E4                          M 	console.write	"DAC1"
0000D5E4 40E7                     M 	move.w	sr,-(sp)
0000D5E6                          M 	__fstring_generateargumentscode	"DAC1"
0000D5E6 =00000000                M 	__pos:	set instr("DAC1",'%<')
0000D5E6 =00000000                M 	__stack:set	0
0000D5E6 =00000000                M 	__sp:	set 0
0000D5E6                          M 	while	(__pos)
0000D5E6                          M 	rept	__stack
0000D5E6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D5EA 43FA 0000                M 	lea	.str_326(pc),a1
0000D5EE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D5F4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D5F8 46DF                     M 	move.w	(sp)+,sr
0000D5FA 6000 0000                M 	bra.w	.instr_end_326
0000D5FE                          M 	.str_326:
0000D5FE                          M 	__fstring_generatedecodedstring	"DAC1"
0000D5FE =00000001                M 	__lpos:	set 1
0000D5FE =00000000                M 	__pos:	set instr("DAC1",'%<')
0000D5FE                          M 	while	(__pos)
0000D5FE                          M 	__substr:	substr __lpos,,"DAC1"
0000D5FE 4441 4331                M 	dc.b	"DAC1"
0000D602 00                       M 	dc.b	0
0000D604 00                       M 	even
0000D604                          M 	.instr_end_326:
0000D604 6000 0000                M 	bra.w	amps_debug_writeend
0000D608                          M amps_debug_writedac2
0000D608 BAFC C4F0                M 	cmp.w	#mdac2,a5
0000D60C 6600                     M 	bne.s	amps_debug_writefm1
0000D60E                          M 	console.write	"DAC2"
0000D60E 40E7                     M 	move.w	sr,-(sp)
0000D610                          M 	__fstring_generateargumentscode	"DAC2"
0000D610 =00000000                M 	__pos:	set instr("DAC2",'%<')
0000D610 =00000000                M 	__stack:set	0
0000D610 =00000000                M 	__sp:	set 0
0000D610                          M 	while	(__pos)
0000D610                          M 	rept	__stack
0000D610 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D614 43FA 0000                M 	lea	.str_329(pc),a1
0000D618 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D61E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D622 46DF                     M 	move.w	(sp)+,sr
0000D624 6000 0000                M 	bra.w	.instr_end_329
0000D628                          M 	.str_329:
0000D628                          M 	__fstring_generatedecodedstring	"DAC2"
0000D628 =00000001                M 	__lpos:	set 1
0000D628 =00000000                M 	__pos:	set instr("DAC2",'%<')
0000D628                          M 	while	(__pos)
0000D628                          M 	__substr:	substr __lpos,,"DAC2"
0000D628 4441 4332                M 	dc.b	"DAC2"
0000D62C 00                       M 	dc.b	0
0000D62E 00                       M 	even
0000D62E                          M 	.instr_end_329:
0000D62E 6000 0000                M 	bra.w	amps_debug_writeend
0000D632                          M amps_debug_writefm1
0000D632 BAFC C51C                M 	cmp.w	#mfm1,a5
0000D636 6600                     M 	bne.s	amps_debug_writefm2
0000D638                          M 	console.write	"FM1"
0000D638 40E7                     M 	move.w	sr,-(sp)
0000D63A                          M 	__fstring_generateargumentscode	"FM1"
0000D63A =00000000                M 	__pos:	set instr("FM1",'%<')
0000D63A =00000000                M 	__stack:set	0
0000D63A =00000000                M 	__sp:	set 0
0000D63A                          M 	while	(__pos)
0000D63A                          M 	rept	__stack
0000D63A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D63E 43FA 0000                M 	lea	.str_332(pc),a1
0000D642 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D648 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D64C 46DF                     M 	move.w	(sp)+,sr
0000D64E 6000 0000                M 	bra.w	.instr_end_332
0000D652                          M 	.str_332:
0000D652                          M 	__fstring_generatedecodedstring	"FM1"
0000D652 =00000001                M 	__lpos:	set 1
0000D652 =00000000                M 	__pos:	set instr("FM1",'%<')
0000D652                          M 	while	(__pos)
0000D652                          M 	__substr:	substr __lpos,,"FM1"
0000D652 464D 31                  M 	dc.b	"FM1"
0000D655 00                       M 	dc.b	0
0000D656                          M 	even
0000D656                          M 	.instr_end_332:
0000D656 6000 0000                M 	bra.w	amps_debug_writeend
0000D65A                          M amps_debug_writefm2
0000D65A BAFC C548                M 	cmp.w	#mfm2,a5
0000D65E 6600                     M 	bne.s	amps_debug_writefm3
0000D660                          M 	console.write	"FM2"
0000D660 40E7                     M 	move.w	sr,-(sp)
0000D662                          M 	__fstring_generateargumentscode	"FM2"
0000D662 =00000000                M 	__pos:	set instr("FM2",'%<')
0000D662 =00000000                M 	__stack:set	0
0000D662 =00000000                M 	__sp:	set 0
0000D662                          M 	while	(__pos)
0000D662                          M 	rept	__stack
0000D662 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D666 43FA 0000                M 	lea	.str_335(pc),a1
0000D66A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D670 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D674 46DF                     M 	move.w	(sp)+,sr
0000D676 6000 0000                M 	bra.w	.instr_end_335
0000D67A                          M 	.str_335:
0000D67A                          M 	__fstring_generatedecodedstring	"FM2"
0000D67A =00000001                M 	__lpos:	set 1
0000D67A =00000000                M 	__pos:	set instr("FM2",'%<')
0000D67A                          M 	while	(__pos)
0000D67A                          M 	__substr:	substr __lpos,,"FM2"
0000D67A 464D 32                  M 	dc.b	"FM2"
0000D67D 00                       M 	dc.b	0
0000D67E                          M 	even
0000D67E                          M 	.instr_end_335:
0000D67E 6000 0000                M 	bra.w	amps_debug_writeend
0000D682                          M amps_debug_writefm3
0000D682 BAFC C574                M 	cmp.w	#mfm3,a5
0000D686 6600                     M 	bne.s	amps_debug_writefm4
0000D688                          M 	console.write	"FM3"
0000D688 40E7                     M 	move.w	sr,-(sp)
0000D68A                          M 	__fstring_generateargumentscode	"FM3"
0000D68A =00000000                M 	__pos:	set instr("FM3",'%<')
0000D68A =00000000                M 	__stack:set	0
0000D68A =00000000                M 	__sp:	set 0
0000D68A                          M 	while	(__pos)
0000D68A                          M 	rept	__stack
0000D68A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D68E 43FA 0000                M 	lea	.str_338(pc),a1
0000D692 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D698 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D69C 46DF                     M 	move.w	(sp)+,sr
0000D69E 6000 0000                M 	bra.w	.instr_end_338
0000D6A2                          M 	.str_338:
0000D6A2                          M 	__fstring_generatedecodedstring	"FM3"
0000D6A2 =00000001                M 	__lpos:	set 1
0000D6A2 =00000000                M 	__pos:	set instr("FM3",'%<')
0000D6A2                          M 	while	(__pos)
0000D6A2                          M 	__substr:	substr __lpos,,"FM3"
0000D6A2 464D 33                  M 	dc.b	"FM3"
0000D6A5 00                       M 	dc.b	0
0000D6A6                          M 	even
0000D6A6                          M 	.instr_end_338:
0000D6A6 6000 0000                M 	bra.w	amps_debug_writeend
0000D6AA                          M amps_debug_writefm4
0000D6AA BAFC C5A0                M 	cmp.w	#mfm4,a5
0000D6AE 6600                     M 	bne.s	amps_debug_writefm5
0000D6B0                          M 	console.write	"FM4"
0000D6B0 40E7                     M 	move.w	sr,-(sp)
0000D6B2                          M 	__fstring_generateargumentscode	"FM4"
0000D6B2 =00000000                M 	__pos:	set instr("FM4",'%<')
0000D6B2 =00000000                M 	__stack:set	0
0000D6B2 =00000000                M 	__sp:	set 0
0000D6B2                          M 	while	(__pos)
0000D6B2                          M 	rept	__stack
0000D6B2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6B6 43FA 0000                M 	lea	.str_341(pc),a1
0000D6BA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D6C0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D6C4 46DF                     M 	move.w	(sp)+,sr
0000D6C6 6000 0000                M 	bra.w	.instr_end_341
0000D6CA                          M 	.str_341:
0000D6CA                          M 	__fstring_generatedecodedstring	"FM4"
0000D6CA =00000001                M 	__lpos:	set 1
0000D6CA =00000000                M 	__pos:	set instr("FM4",'%<')
0000D6CA                          M 	while	(__pos)
0000D6CA                          M 	__substr:	substr __lpos,,"FM4"
0000D6CA 464D 34                  M 	dc.b	"FM4"
0000D6CD 00                       M 	dc.b	0
0000D6CE                          M 	even
0000D6CE                          M 	.instr_end_341:
0000D6CE 6000 0000                M 	bra.w	amps_debug_writeend
0000D6D2                          M amps_debug_writefm5
0000D6D2 BAFC C5CC                M 	cmp.w	#mfm5,a5
0000D6D6 6600                     M 	bne.s	amps_debug_writefms3
0000D6D8                          M 	console.write	"FM5"
0000D6D8 40E7                     M 	move.w	sr,-(sp)
0000D6DA                          M 	__fstring_generateargumentscode	"FM5"
0000D6DA =00000000                M 	__pos:	set instr("FM5",'%<')
0000D6DA =00000000                M 	__stack:set	0
0000D6DA =00000000                M 	__sp:	set 0
0000D6DA                          M 	while	(__pos)
0000D6DA                          M 	rept	__stack
0000D6DA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6DE 43FA 0000                M 	lea	.str_344(pc),a1
0000D6E2 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D6E8 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D6EC 46DF                     M 	move.w	(sp)+,sr
0000D6EE 6000 0000                M 	bra.w	.instr_end_344
0000D6F2                          M 	.str_344:
0000D6F2                          M 	__fstring_generatedecodedstring	"FM5"
0000D6F2 =00000001                M 	__lpos:	set 1
0000D6F2 =00000000                M 	__pos:	set instr("FM5",'%<')
0000D6F2                          M 	while	(__pos)
0000D6F2                          M 	__substr:	substr __lpos,,"FM5"
0000D6F2 464D 35                  M 	dc.b	"FM5"
0000D6F5 00                       M 	dc.b	0
0000D6F6                          M 	even
0000D6F6                          M 	.instr_end_344:
0000D6F6 6000 0000                M 	bra.w	amps_debug_writeend
0000D6FA                          M amps_debug_writefms3
0000D6FA BAFC C698                M 	cmp.w	#msfxfm3,a5
0000D6FE 6600                     M 	bne.s	amps_debug_writefms4
0000D700                          M 	console.write	"SFX FM3"
0000D700 40E7                     M 	move.w	sr,-(sp)
0000D702                          M 	__fstring_generateargumentscode	"SFX FM3"
0000D702 =00000000                M 	__pos:	set instr("SFX FM3",'%<')
0000D702 =00000000                M 	__stack:set	0
0000D702 =00000000                M 	__sp:	set 0
0000D702                          M 	while	(__pos)
0000D702                          M 	rept	__stack
0000D702 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D706 43FA 0000                M 	lea	.str_347(pc),a1
0000D70A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D710 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D714 46DF                     M 	move.w	(sp)+,sr
0000D716 6000 0000                M 	bra.w	.instr_end_347
0000D71A                          M 	.str_347:
0000D71A                          M 	__fstring_generatedecodedstring	"SFX FM3"
0000D71A =00000001                M 	__lpos:	set 1
0000D71A =00000000                M 	__pos:	set instr("SFX FM3",'%<')
0000D71A                          M 	while	(__pos)
0000D71A                          M 	__substr:	substr __lpos,,"SFX FM3"
0000D71A 5346 5820 464D 33        M 	dc.b	"SFX FM3"
0000D721 00                       M 	dc.b	0
0000D722                          M 	even
0000D722                          M 	.instr_end_347:
0000D722 4E75                     M 	rts
0000D724                          M amps_debug_writefms4
0000D724 BAFC C6B4                M 	cmp.w	#msfxfm4,a5
0000D728 6600                     M 	bne.s	amps_debug_writefms5
0000D72A                          M 	console.write	"SFX FM4"
0000D72A 40E7                     M 	move.w	sr,-(sp)
0000D72C                          M 	__fstring_generateargumentscode	"SFX FM4"
0000D72C =00000000                M 	__pos:	set instr("SFX FM4",'%<')
0000D72C =00000000                M 	__stack:set	0
0000D72C =00000000                M 	__sp:	set 0
0000D72C                          M 	while	(__pos)
0000D72C                          M 	rept	__stack
0000D72C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D730 43FA 0000                M 	lea	.str_350(pc),a1
0000D734 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D73A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D73E 46DF                     M 	move.w	(sp)+,sr
0000D740 6000 0000                M 	bra.w	.instr_end_350
0000D744                          M 	.str_350:
0000D744                          M 	__fstring_generatedecodedstring	"SFX FM4"
0000D744 =00000001                M 	__lpos:	set 1
0000D744 =00000000                M 	__pos:	set instr("SFX FM4",'%<')
0000D744                          M 	while	(__pos)
0000D744                          M 	__substr:	substr __lpos,,"SFX FM4"
0000D744 5346 5820 464D 34        M 	dc.b	"SFX FM4"
0000D74B 00                       M 	dc.b	0
0000D74C                          M 	even
0000D74C                          M 	.instr_end_350:
0000D74C 6000                     M 	bra.s	amps_debug_writeend
0000D74E                          M amps_debug_writefms5
0000D74E BAFC C6D0                M 	cmp.w	#msfxfm5,a5
0000D752 6700                     M 	beq.s	amps_debug_writefms5_
0000D754                          M amps_debug_writeaddr
0000D754                          M 	console.write	"%<fpal2>%<.l a5>"
0000D754 40E7                     M 	move.w	sr,-(sp)
0000D756                          M 	__fstring_generateargumentscode	"%<fpal2>%<.l a5>"
0000D756 =00000001                M 	__pos:	set instr("%<fpal2>%<.l a5>",'%<')
0000D756 =00000000                M 	__stack:set	0
0000D756 =00000000                M 	__sp:	set 0
0000D756                          M 	while	(__pos)
0000D756 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D756 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D756 =00000008                M 	__midpos:	= __endpos
0000D756                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D756                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D756 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D756 =00000010                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D756 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D756 =00000010                M 	__midpos:	= __endpos
0000D756                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D756                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D756                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal2>%<.l a5>"
0000D756                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D756                          M 	pushp	"move.l a5,-(sp)"
0000D756 =00000001                M 	__stack:	= __stack+1
0000D756 =00000004                M 	__sp:	= __sp+4
0000D756 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D756                          M 	rept	__stack
0000D756                          M 	popp	__command
0000D756 2F0D                     M 	move.l	a5,-(sp)
0000D758 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D75C 45EF 0010                M 	lea	4*4(sp),a2
0000D760 43FA 0000                M 	lea	.str_353(pc),a1
0000D764 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D76A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D76E 584F                     M 	addq.w	#__sp,sp
0000D770 46DF                     M 	move.w	(sp)+,sr
0000D772 6000 0000                M 	bra.w	.instr_end_353
0000D776                          M 	.str_353:
0000D776                          M 	__fstring_generatedecodedstring	"%<fpal2>%<.l a5>"
0000D776 =00000001                M 	__lpos:	set 1
0000D776 =00000001                M 	__pos:	set instr("%<fpal2>%<.l a5>",'%<')
0000D776                          M 	while	(__pos)
0000D776                          M 	__substr:	substr __lpos,__pos-1,"%<fpal2>%<.l a5>"
0000D776                          M 	dc.b	""
0000D776 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D776 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D776 =00000008                M 	__midpos:	= __endpos
0000D776                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D776                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D776 EC                       M 	dc.b	fpal2
0000D777 =00000009                M 	__lpos:	set __endpos+1
0000D777 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D777                          M 	__substr:	substr __lpos,__pos-1,"%<fpal2>%<.l a5>"
0000D777                          M 	dc.b	""
0000D777 =00000010                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D777 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D777 =00000010                M 	__midpos:	= __endpos
0000D777                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D777                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D777                          M 	__param:	substr ,,"hex"
0000D777 83                       M 	dc.b	hex|3
0000D778 =00000011                M 	__lpos:	set __endpos+1
0000D778 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D778                          M 	__substr:	substr __lpos,,"%<fpal2>%<.l a5>"
0000D778                          M 	dc.b	""
0000D778 00                       M 	dc.b	0
0000D77A 00                       M 	even
0000D77A                          M 	.instr_end_353:
0000D77A 4E75                     M 	rts
0000D77C                          M amps_debug_writefms5_
0000D77C                          M 	console.write	"SFX FM5"
0000D77C 40E7                     M 	move.w	sr,-(sp)
0000D77E                          M 	__fstring_generateargumentscode	"SFX FM5"
0000D77E =00000000                M 	__pos:	set instr("SFX FM5",'%<')
0000D77E =00000000                M 	__stack:set	0
0000D77E =00000000                M 	__sp:	set 0
0000D77E                          M 	while	(__pos)
0000D77E                          M 	rept	__stack
0000D77E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D782 43FA 0000                M 	lea	.str_356(pc),a1
0000D786 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D78C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D790 46DF                     M 	move.w	(sp)+,sr
0000D792 6000 0000                M 	bra.w	.instr_end_356
0000D796                          M 	.str_356:
0000D796                          M 	__fstring_generatedecodedstring	"SFX FM5"
0000D796 =00000001                M 	__lpos:	set 1
0000D796 =00000000                M 	__pos:	set instr("SFX FM5",'%<')
0000D796                          M 	while	(__pos)
0000D796                          M 	__substr:	substr __lpos,,"SFX FM5"
0000D796 5346 5820 464D 35        M 	dc.b	"SFX FM5"
0000D79D 00                       M 	dc.b	0
0000D79E                          M 	even
0000D79E                          M 	.instr_end_356:
0000D79E                          M amps_debug_writeend
0000D79E                            	Console.BreakLine
0000D79E 40E7                     M 	move.w	sr,-(sp)
0000D7A0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D7A6 46DF                     M 	move.w	(sp)+,sr
0000D7A8                            
0000D7A8                            	Console.WriteLine "%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7A8 40E7                     M 	move.w	sr,-(sp)
0000D7AA                          M 	__fstring_generateargumentscode	"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA =00000001                M 	__pos:	set instr("%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7AA =00000000                M 	__stack:set	0
0000D7AA =00000000                M 	__sp:	set 0
0000D7AA                          M 	while	(__pos)
0000D7AA =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D7AA =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D7AA =00000008                M 	__midpos:	= __endpos
0000D7AA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7AA =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D7AA =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D7AA =00000016                M 	__midpos:	= __endpos
0000D7AA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7AA =00000029                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D7AA =0000001E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D7AA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA                          M 	pushp	"move.l a4,-(sp)"
0000D7AA =00000001                M 	__stack:	= __stack+1
0000D7AA =00000004                M 	__sp:	= __sp+4
0000D7AA =0000002A                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7AA =0000003A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D7AA =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D7AA =0000003A                M 	__midpos:	= __endpos
0000D7AA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7AA =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7AA                          M 	rept	__stack
0000D7AA                          M 	popp	__command
0000D7AA 2F0C                     M 	move.l	a4,-(sp)
0000D7AC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D7B0 45EF 0010                M 	lea	4*4(sp),a2
0000D7B4 43FA 0000                M 	lea	.str_360(pc),a1
0000D7B8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D7BE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D7C2 584F                     M 	addq.w	#__sp,sp
0000D7C4 46DF                     M 	move.w	(sp)+,sr
0000D7C6 6000 0000                M 	bra.w	.instr_end_360
0000D7CA                          M 	.str_360:
0000D7CA                          M 	__fstring_generatedecodedstring	"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7CA =00000001                M 	__lpos:	set 1
0000D7CA =00000001                M 	__pos:	set instr("%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7CA                          M 	while	(__pos)
0000D7CA                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7CA                          M 	dc.b	""
0000D7CA =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D7CA =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D7CA =00000008                M 	__midpos:	= __endpos
0000D7CA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7CA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7CA EA                       M 	dc.b	fpal1
0000D7CB =00000009                M 	__lpos:	set __endpos+1
0000D7CB =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7CB                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7CB 4164 6472 3A20           M 	dc.b	"Addr: "
0000D7D1 =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D7D1 =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D7D1 =00000016                M 	__midpos:	= __endpos
0000D7D1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7D1                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7D1 E8                       M 	dc.b	fpal0
0000D7D2 =00000017                M 	__lpos:	set __endpos+1
0000D7D2 =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7D2                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7D2                          M 	dc.b	""
0000D7D2 =00000029                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D7D2 =0000001E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D7D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7D2                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7D2 BB                       M 	dc.b	sym|fsplit|3
0000D7D3 =0000002A                M 	__lpos:	set __endpos+1
0000D7D3 =0000002A                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7D3                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7D3                          M 	dc.b	""
0000D7D3 =0000003A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D7D3 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D7D3 =0000003A                M 	__midpos:	= __endpos
0000D7D3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7D3                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7D3 ECC0                     M 	dc.b	fpal2,fsymdisp
0000D7D5 =0000003B                M 	__lpos:	set __endpos+1
0000D7D5 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D7D5                          M 	__substr:	substr __lpos,,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D7D5                          M 	dc.b	""
0000D7D5 00                       M 	dc.b	0
0000D7D6                          M 	even
0000D7D6                          M 	.instr_end_360:
0000D7D6                            ; fmt: flag, type, pan, det, pitch, vol, tick, sample/voice, dur, lastdur, freq
0000D7D6                            	Console.Write	  "%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D6 40E7                     M 	move.w	sr,-(sp)
0000D7D8                          M 	__fstring_generateargumentscode	"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8 =00000001                M 	__pos:	set instr("%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D8 =00000000                M 	__stack:set	0
0000D7D8 =00000000                M 	__sp:	set 0
0000D7D8                          M 	while	(__pos)
0000D7D8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7D8 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7D8 =00000008                M 	__midpos:	= __endpos
0000D7D8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8 =0000000D                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D8 =00000014                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7D8 =00000019                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7D8 =00000014                M 	__midpos:	= __endpos
0000D7D8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8 =00000015                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D8 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7D8 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7D8 =0000001E                M 	__midpos:	= __endpos
0000D7D8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	pushp	"move.b (a5),1(sp)"
0000D7D8                          M 	pushp	"subq.w	#2, sp"
0000D7D8 =00000002                M 	__stack:	= __stack+2
0000D7D8 =00000002                M 	__sp:	= __sp+2
0000D7D8 =00000020                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D8 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7D8 =0000002F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7D8 =0000002E                M 	__midpos:	= __endpos
0000D7D8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	pushp	"move.b cType(a5),1(sp)"
0000D7D8                          M 	pushp	"subq.w	#2, sp"
0000D7D8 =00000004                M 	__stack:	= __stack+2
0000D7D8 =00000004                M 	__sp:	= __sp+2
0000D7D8 =00000030                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D8 =00000041                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7D8 =00000042                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7D8 =00000041                M 	__midpos:	= __endpos
0000D7D8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	pushp	"move.b cPanning(a5),1(sp)"
0000D7D8                          M 	pushp	"subq.w	#2, sp"
0000D7D8 =00000006                M 	__stack:	= __stack+2
0000D7D8 =00000006                M 	__sp:	= __sp+2
0000D7D8 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D8                          M 	rept	__stack
0000D7D8                          M 	popp	__command
0000D7D8 554F                     M 	subq.w	#2,sp
0000D7DA                          M 	popp	__command
0000D7DA 1F6D 0006 0001           M 	move.b	cpanning(a5),1(sp)
0000D7E0                          M 	popp	__command
0000D7E0 554F                     M 	subq.w	#2,sp
0000D7E2                          M 	popp	__command
0000D7E2 1F6D 0001 0001           M 	move.b	ctype(a5),1(sp)
0000D7E8                          M 	popp	__command
0000D7E8 554F                     M 	subq.w	#2,sp
0000D7EA                          M 	popp	__command
0000D7EA 1F55 0001                M 	move.b	(a5),1(sp)
0000D7EE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D7F2 45EF 0010                M 	lea	4*4(sp),a2
0000D7F6 43FA 0000                M 	lea	.str_363(pc),a1
0000D7FA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D800 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D804 5C4F                     M 	addq.w	#__sp,sp
0000D806 46DF                     M 	move.w	(sp)+,sr
0000D808 6000 0000                M 	bra.w	.instr_end_363
0000D80C                          M 	.str_363:
0000D80C                          M 	__fstring_generatedecodedstring	"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D80C =00000001                M 	__lpos:	set 1
0000D80C =00000001                M 	__pos:	set instr("%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D80C                          M 	while	(__pos)
0000D80C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D80C                          M 	dc.b	""
0000D80C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D80C =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D80C =00000008                M 	__midpos:	= __endpos
0000D80C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D80C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D80C EA                       M 	dc.b	fpal1
0000D80D =00000009                M 	__lpos:	set __endpos+1
0000D80D =0000000D                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D80D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D80D 4348 3A20                M 	dc.b	"CH: "
0000D811 =00000014                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D811 =00000019                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D811 =00000014                M 	__midpos:	= __endpos
0000D811                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D811                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D811 EC                       M 	dc.b	fpal2
0000D812 =00000015                M 	__lpos:	set __endpos+1
0000D812 =00000015                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D812                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D812                          M 	dc.b	""
0000D812 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D812 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D812 =0000001E                M 	__midpos:	= __endpos
0000D812                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D812                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D812                          M 	__param:	substr ,,"hex"
0000D812 80                       M 	dc.b	hex
0000D813 =0000001F                M 	__lpos:	set __endpos+1
0000D813 =00000020                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D813                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D813 20                       M 	dc.b	" "
0000D814 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D814 =0000002F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D814 =0000002E                M 	__midpos:	= __endpos
0000D814                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D814                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D814                          M 	__param:	substr ,,"hex"
0000D814 80                       M 	dc.b	hex
0000D815 =0000002F                M 	__lpos:	set __endpos+1
0000D815 =00000030                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D815                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D815 20                       M 	dc.b	" "
0000D816 =00000041                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D816 =00000042                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D816 =00000041                M 	__midpos:	= __endpos
0000D816                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D816                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D816                          M 	__param:	substr ,,"hex"
0000D816 80                       M 	dc.b	hex
0000D817 =00000042                M 	__lpos:	set __endpos+1
0000D817 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D817                          M 	__substr:	substr __lpos,,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D817 20                       M 	dc.b	" "
0000D818 00                       M 	dc.b	0
0000D81A 00                       M 	even
0000D81A                          M 	.instr_end_363:
0000D81A                            	Console.Write	  "%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81A 40E7                     M 	move.w	sr,-(sp)
0000D81C                          M 	__fstring_generateargumentscode	"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C =00000001                M 	__pos:	set instr("%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D81C =00000000                M 	__stack:set	0
0000D81C =00000000                M 	__sp:	set 0
0000D81C                          M 	while	(__pos)
0000D81C =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D81C =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D81C =00000011                M 	__midpos:	= __endpos
0000D81C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	pushp	"move.b cDetune(a5),1(sp)"
0000D81C                          M 	pushp	"subq.w	#2, sp"
0000D81C =00000002                M 	__stack:	= __stack+2
0000D81C =00000002                M 	__sp:	= __sp+2
0000D81C =00000013                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D81C =00000022                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D81C =00000023                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D81C =00000022                M 	__midpos:	= __endpos
0000D81C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	pushp	"move.b cPitch(a5),1(sp)"
0000D81C                          M 	pushp	"subq.w	#2, sp"
0000D81C =00000004                M 	__stack:	= __stack+2
0000D81C =00000004                M 	__sp:	= __sp+2
0000D81C =00000024                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D81C =00000034                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D81C =00000035                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D81C =00000034                M 	__midpos:	= __endpos
0000D81C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	pushp	"move.b cVolume(a5),1(sp)"
0000D81C                          M 	pushp	"subq.w	#2, sp"
0000D81C =00000006                M 	__stack:	= __stack+2
0000D81C =00000006                M 	__sp:	= __sp+2
0000D81C =00000036                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D81C =00000044                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D81C =00000045                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D81C =00000044                M 	__midpos:	= __endpos
0000D81C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81C                          M 	pushp	"move.b cTick(a5),1(sp)"
0000D81C                          M 	pushp	"subq.w	#2, sp"
0000D81C =00000008                M 	__stack:	= __stack+2
0000D81C =00000008                M 	__sp:	= __sp+2
0000D81C =00000000                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D81C                          M 	rept	__stack
0000D81C                          M 	popp	__command
0000D81C 554F                     M 	subq.w	#2,sp
0000D81E                          M 	popp	__command
0000D81E 1F6D 000A 0001           M 	move.b	ctick(a5),1(sp)
0000D824                          M 	popp	__command
0000D824 554F                     M 	subq.w	#2,sp
0000D826                          M 	popp	__command
0000D826 1F6D 0009 0001           M 	move.b	cvolume(a5),1(sp)
0000D82C                          M 	popp	__command
0000D82C 554F                     M 	subq.w	#2,sp
0000D82E                          M 	popp	__command
0000D82E 1F6D 0008 0001           M 	move.b	cpitch(a5),1(sp)
0000D834                          M 	popp	__command
0000D834 554F                     M 	subq.w	#2,sp
0000D836                          M 	popp	__command
0000D836 1F6D 0007 0001           M 	move.b	cdetune(a5),1(sp)
0000D83C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D840 45EF 0010                M 	lea	4*4(sp),a2
0000D844 43FA 0000                M 	lea	.str_366(pc),a1
0000D848 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D84E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D852 504F                     M 	addq.w	#__sp,sp
0000D854 46DF                     M 	move.w	(sp)+,sr
0000D856 6000 0000                M 	bra.w	.instr_end_366
0000D85A                          M 	.str_366:
0000D85A                          M 	__fstring_generatedecodedstring	"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85A =00000001                M 	__lpos:	set 1
0000D85A =00000001                M 	__pos:	set instr("%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D85A                          M 	while	(__pos)
0000D85A                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85A                          M 	dc.b	""
0000D85A =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D85A =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D85A =00000011                M 	__midpos:	= __endpos
0000D85A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85A                          M 	__param:	substr ,,"hex"
0000D85A 80                       M 	dc.b	hex
0000D85B =00000012                M 	__lpos:	set __endpos+1
0000D85B =00000013                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D85B                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85B 20                       M 	dc.b	" "
0000D85C =00000022                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D85C =00000023                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D85C =00000022                M 	__midpos:	= __endpos
0000D85C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85C                          M 	__param:	substr ,,"hex"
0000D85C 80                       M 	dc.b	hex
0000D85D =00000023                M 	__lpos:	set __endpos+1
0000D85D =00000024                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D85D                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85D 20                       M 	dc.b	" "
0000D85E =00000034                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D85E =00000035                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D85E =00000034                M 	__midpos:	= __endpos
0000D85E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85E                          M 	__param:	substr ,,"hex"
0000D85E 80                       M 	dc.b	hex
0000D85F =00000035                M 	__lpos:	set __endpos+1
0000D85F =00000036                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D85F                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D85F 20                       M 	dc.b	" "
0000D860 =00000044                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D860 =00000045                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D860 =00000044                M 	__midpos:	= __endpos
0000D860                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D860                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D860                          M 	__param:	substr ,,"hex"
0000D860 80                       M 	dc.b	hex
0000D861 =00000045                M 	__lpos:	set __endpos+1
0000D861 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D861                          M 	__substr:	substr __lpos,,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D861 20                       M 	dc.b	" "
0000D862 00                       M 	dc.b	0
0000D864 00                       M 	even
0000D864                          M 	.instr_end_366:
0000D864                            	Console.WriteLine "%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D864 40E7                     M 	move.w	sr,-(sp)
0000D866                          M 	__fstring_generateargumentscode	"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866 =00000001                M 	__pos:	set instr("%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D866 =00000000                M 	__stack:set	0
0000D866 =00000000                M 	__sp:	set 0
0000D866                          M 	while	(__pos)
0000D866 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D866 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D866 =00000011                M 	__midpos:	= __endpos
0000D866                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	pushp	"move.b cSample(a5),1(sp)"
0000D866                          M 	pushp	"subq.w	#2, sp"
0000D866 =00000002                M 	__stack:	= __stack+2
0000D866 =00000002                M 	__sp:	= __sp+2
0000D866 =00000013                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D866 =00000025                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D866 =00000026                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D866 =00000025                M 	__midpos:	= __endpos
0000D866                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	pushp	"move.b cDuration(a5),1(sp)"
0000D866                          M 	pushp	"subq.w	#2, sp"
0000D866 =00000004                M 	__stack:	= __stack+2
0000D866 =00000004                M 	__sp:	= __sp+2
0000D866 =00000027                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D866 =00000038                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D866 =00000039                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D866 =00000038                M 	__midpos:	= __endpos
0000D866                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	pushp	"move.b cLastDur(a5),1(sp)"
0000D866                          M 	pushp	"subq.w	#2, sp"
0000D866 =00000006                M 	__stack:	= __stack+2
0000D866 =00000006                M 	__sp:	= __sp+2
0000D866 =0000003A                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D866 =00000048                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D866 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D866 =00000048                M 	__midpos:	= __endpos
0000D866                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	pushp	"move.w cFreq(a5),-(sp)"
0000D866 =00000007                M 	__stack:	= __stack+1
0000D866 =00000008                M 	__sp:	= __sp+2
0000D866 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D866                          M 	rept	__stack
0000D866                          M 	popp	__command
0000D866 3F2D 000E                M 	move.w	cfreq(a5),-(sp)
0000D86A                          M 	popp	__command
0000D86A 554F                     M 	subq.w	#2,sp
0000D86C                          M 	popp	__command
0000D86C 1F6D 000D 0001           M 	move.b	clastdur(a5),1(sp)
0000D872                          M 	popp	__command
0000D872 554F                     M 	subq.w	#2,sp
0000D874                          M 	popp	__command
0000D874 1F6D 000C 0001           M 	move.b	cduration(a5),1(sp)
0000D87A                          M 	popp	__command
0000D87A 554F                     M 	subq.w	#2,sp
0000D87C                          M 	popp	__command
0000D87C 1F6D 000B 0001           M 	move.b	csample(a5),1(sp)
0000D882 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D886 45EF 0010                M 	lea	4*4(sp),a2
0000D88A 43FA 0000                M 	lea	.str_369(pc),a1
0000D88E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D894 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D898 504F                     M 	addq.w	#__sp,sp
0000D89A 46DF                     M 	move.w	(sp)+,sr
0000D89C 6000 0000                M 	bra.w	.instr_end_369
0000D8A0                          M 	.str_369:
0000D8A0                          M 	__fstring_generatedecodedstring	"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A0 =00000001                M 	__lpos:	set 1
0000D8A0 =00000001                M 	__pos:	set instr("%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8A0                          M 	while	(__pos)
0000D8A0                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A0                          M 	dc.b	""
0000D8A0 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D8A0 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D8A0 =00000011                M 	__midpos:	= __endpos
0000D8A0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A0                          M 	__param:	substr ,,"hex"
0000D8A0 80                       M 	dc.b	hex
0000D8A1 =00000012                M 	__lpos:	set __endpos+1
0000D8A1 =00000013                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8A1                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A1 20                       M 	dc.b	" "
0000D8A2 =00000025                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D8A2 =00000026                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D8A2 =00000025                M 	__midpos:	= __endpos
0000D8A2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A2                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A2                          M 	__param:	substr ,,"hex"
0000D8A2 80                       M 	dc.b	hex
0000D8A3 =00000026                M 	__lpos:	set __endpos+1
0000D8A3 =00000027                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8A3                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A3 20                       M 	dc.b	" "
0000D8A4 =00000038                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D8A4 =00000039                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D8A4 =00000038                M 	__midpos:	= __endpos
0000D8A4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A4                          M 	__param:	substr ,,"hex"
0000D8A4 80                       M 	dc.b	hex
0000D8A5 =00000039                M 	__lpos:	set __endpos+1
0000D8A5 =0000003A                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8A5                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A5 20                       M 	dc.b	" "
0000D8A6 =00000048                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D8A6 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D8A6 =00000048                M 	__midpos:	= __endpos
0000D8A6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A6                          M 	__param:	substr ,,"hex"
0000D8A6 81                       M 	dc.b	hex|1
0000D8A7 =00000049                M 	__lpos:	set __endpos+1
0000D8A7 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D8A7                          M 	__substr:	substr __lpos,,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D8A7                          M 	dc.b	""
0000D8A7 00                       M 	dc.b	0
0000D8A8                          M 	even
0000D8A8                          M 	.instr_end_369:
0000D8A8                            	Console.BreakLine
0000D8A8 40E7                     M 	move.w	sr,-(sp)
0000D8AA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D8B0 46DF                     M 	move.w	(sp)+,sr
0000D8B2                            
0000D8B2                            	Console.WriteLine "%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B2 40E7                     M 	move.w	sr,-(sp)
0000D8B4                          M 	__fstring_generateargumentscode	"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4 =00000001                M 	__pos:	set instr("%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8B4 =00000000                M 	__stack:set	0
0000D8B4 =00000000                M 	__sp:	set 0
0000D8B4                          M 	while	(__pos)
0000D8B4 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8B4 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8B4 =00000008                M 	__midpos:	= __endpos
0000D8B4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4 =0000000E                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8B4 =00000015                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8B4 =0000001A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8B4 =00000015                M 	__midpos:	= __endpos
0000D8B4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4 =00000016                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8B4 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8B4 =00000023                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8B4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4                          M 	pushp	"move.l cMod(a5),-(sp)"
0000D8B4 =00000001                M 	__stack:	= __stack+1
0000D8B4 =00000004                M 	__sp:	= __sp+4
0000D8B4 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8B4 =0000003F                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8B4 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8B4 =0000003F                M 	__midpos:	= __endpos
0000D8B4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8B4 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8B4                          M 	rept	__stack
0000D8B4                          M 	popp	__command
0000D8B4 2F2D 0010                M 	move.l	cmod(a5),-(sp)
0000D8B8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D8BC 45EF 0010                M 	lea	4*4(sp),a2
0000D8C0 43FA 0000                M 	lea	.str_373(pc),a1
0000D8C4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D8CA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D8CE 584F                     M 	addq.w	#__sp,sp
0000D8D0 46DF                     M 	move.w	(sp)+,sr
0000D8D2 6000 0000                M 	bra.w	.instr_end_373
0000D8D6                          M 	.str_373:
0000D8D6                          M 	__fstring_generatedecodedstring	"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8D6 =00000001                M 	__lpos:	set 1
0000D8D6 =00000001                M 	__pos:	set instr("%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8D6                          M 	while	(__pos)
0000D8D6                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8D6                          M 	dc.b	""
0000D8D6 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8D6 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8D6 =00000008                M 	__midpos:	= __endpos
0000D8D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8D6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8D6 EA                       M 	dc.b	fpal1
0000D8D7 =00000009                M 	__lpos:	set __endpos+1
0000D8D7 =0000000E                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8D7                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8D7 4D6F 643A 20             M 	dc.b	"Mod: "
0000D8DC =00000015                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8DC =0000001A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8DC =00000015                M 	__midpos:	= __endpos
0000D8DC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8DC                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8DC E8                       M 	dc.b	fpal0
0000D8DD =00000016                M 	__lpos:	set __endpos+1
0000D8DD =00000016                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8DD                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8DD                          M 	dc.b	""
0000D8DD =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8DD =00000023                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8DD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8DD                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8DD BB                       M 	dc.b	sym|fsplit|3
0000D8DE =0000002F                M 	__lpos:	set __endpos+1
0000D8DE =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8DE                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8DE                          M 	dc.b	""
0000D8DE =0000003F                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8DE =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8DE =0000003F                M 	__midpos:	= __endpos
0000D8DE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8DE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8DE ECC0                     M 	dc.b	fpal2,fsymdisp
0000D8E0 =00000040                M 	__lpos:	set __endpos+1
0000D8E0 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8E0                          M 	__substr:	substr __lpos,,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8E0                          M 	dc.b	""
0000D8E0 00                       M 	dc.b	0
0000D8E2 00                       M 	even
0000D8E2                          M 	.instr_end_373:
0000D8E2                            	Console.Write	  "%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E2 40E7                     M 	move.w	sr,-(sp)
0000D8E4                          M 	__fstring_generateargumentscode	"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4 =00000001                M 	__pos:	set instr("%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8E4 =00000000                M 	__stack:set	0
0000D8E4 =00000000                M 	__sp:	set 0
0000D8E4                          M 	while	(__pos)
0000D8E4 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8E4 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8E4 =00000008                M 	__midpos:	= __endpos
0000D8E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4 =00000013                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8E4 =0000001A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8E4 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8E4 =0000001A                M 	__midpos:	= __endpos
0000D8E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4 =0000001B                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8E4 =0000002D                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8E4 =0000002E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8E4 =0000002D                M 	__midpos:	= __endpos
0000D8E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	pushp	"move.b cModDelay(a5),1(sp)"
0000D8E4                          M 	pushp	"subq.w	#2, sp"
0000D8E4 =00000002                M 	__stack:	= __stack+2
0000D8E4 =00000002                M 	__sp:	= __sp+2
0000D8E4 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8E4 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8E4 =0000003B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8E4 =00000036                M 	__midpos:	= __endpos
0000D8E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8E4 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8E4 =00000049                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8E4 =00000048                M 	__midpos:	= __endpos
0000D8E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E4                          M 	pushp	"move.w cModFreq(a5),-(sp)"
0000D8E4 =00000003                M 	__stack:	= __stack+1
0000D8E4 =00000004                M 	__sp:	= __sp+2
0000D8E4 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8E4                          M 	rept	__stack
0000D8E4                          M 	popp	__command
0000D8E4 3F2D 0014                M 	move.w	cmodfreq(a5),-(sp)
0000D8E8                          M 	popp	__command
0000D8E8 554F                     M 	subq.w	#2,sp
0000D8EA                          M 	popp	__command
0000D8EA 1F6D 0010 0001           M 	move.b	cmoddelay(a5),1(sp)
0000D8F0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D8F4 45EF 0010                M 	lea	4*4(sp),a2
0000D8F8 43FA 0000                M 	lea	.str_376(pc),a1
0000D8FC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D902 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D906 584F                     M 	addq.w	#__sp,sp
0000D908 46DF                     M 	move.w	(sp)+,sr
0000D90A 6000 0000                M 	bra.w	.instr_end_376
0000D90E                          M 	.str_376:
0000D90E                          M 	__fstring_generatedecodedstring	"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D90E =00000001                M 	__lpos:	set 1
0000D90E =00000001                M 	__pos:	set instr("%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D90E                          M 	while	(__pos)
0000D90E                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D90E                          M 	dc.b	""
0000D90E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D90E =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D90E =00000008                M 	__midpos:	= __endpos
0000D90E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D90E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D90E EA                       M 	dc.b	fpal1
0000D90F =00000009                M 	__lpos:	set __endpos+1
0000D90F =00000013                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D90F                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D90F 4D6F 6420 4461 7461 3A20 M 	dc.b	"Mod Data: "
0000D919 =0000001A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D919 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D919 =0000001A                M 	__midpos:	= __endpos
0000D919                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D919                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D919 EC                       M 	dc.b	fpal2
0000D91A =0000001B                M 	__lpos:	set __endpos+1
0000D91A =0000001B                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D91A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91A                          M 	dc.b	""
0000D91A =0000002D                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D91A =0000002E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D91A =0000002D                M 	__midpos:	= __endpos
0000D91A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91A                          M 	__param:	substr ,,"hex"
0000D91A 80                       M 	dc.b	hex
0000D91B =0000002E                M 	__lpos:	set __endpos+1
0000D91B =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D91B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91B 20                       M 	dc.b	" "
0000D91C =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D91C =0000003B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D91C =00000036                M 	__midpos:	= __endpos
0000D91C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91C EC                       M 	dc.b	fpal2
0000D91D =00000037                M 	__lpos:	set __endpos+1
0000D91D =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D91D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91D                          M 	dc.b	""
0000D91D =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D91D =00000049                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D91D =00000048                M 	__midpos:	= __endpos
0000D91D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91D                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91D                          M 	__param:	substr ,,"hex"
0000D91D 81                       M 	dc.b	hex|1
0000D91E =00000049                M 	__lpos:	set __endpos+1
0000D91E =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D91E                          M 	__substr:	substr __lpos,,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D91E 20                       M 	dc.b	" "
0000D91F 00                       M 	dc.b	0
0000D920                          M 	even
0000D920                          M 	.instr_end_376:
0000D920                            	Console.WriteLine "%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D920 40E7                     M 	move.w	sr,-(sp)
0000D922                          M 	__fstring_generateargumentscode	"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922 =00000001                M 	__pos:	set instr("%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D922 =00000000                M 	__stack:set	0
0000D922 =00000000                M 	__sp:	set 0
0000D922                          M 	while	(__pos)
0000D922 =00000013                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D922 =00000014                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D922 =00000013                M 	__midpos:	= __endpos
0000D922                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	pushp	"move.b cModSpeed(a5),1(sp)"
0000D922                          M 	pushp	"subq.w	#2, sp"
0000D922 =00000002                M 	__stack:	= __stack+2
0000D922 =00000002                M 	__sp:	= __sp+2
0000D922 =00000015                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D922 =00000026                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D922 =00000027                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D922 =00000026                M 	__midpos:	= __endpos
0000D922                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	pushp	"move.b cModStep(a5),1(sp)"
0000D922                          M 	pushp	"subq.w	#2, sp"
0000D922 =00000004                M 	__stack:	= __stack+2
0000D922 =00000004                M 	__sp:	= __sp+2
0000D922 =00000028                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D922 =0000003A                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D922 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D922 =0000003A                M 	__midpos:	= __endpos
0000D922                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D922                          M 	pushp	"move.b cModCount(a5),1(sp)"
0000D922                          M 	pushp	"subq.w	#2, sp"
0000D922 =00000006                M 	__stack:	= __stack+2
0000D922 =00000006                M 	__sp:	= __sp+2
0000D922 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D922                          M 	rept	__stack
0000D922                          M 	popp	__command
0000D922 554F                     M 	subq.w	#2,sp
0000D924                          M 	popp	__command
0000D924 1F6D 0018 0001           M 	move.b	cmodcount(a5),1(sp)
0000D92A                          M 	popp	__command
0000D92A 554F                     M 	subq.w	#2,sp
0000D92C                          M 	popp	__command
0000D92C 1F6D 0017 0001           M 	move.b	cmodstep(a5),1(sp)
0000D932                          M 	popp	__command
0000D932 554F                     M 	subq.w	#2,sp
0000D934                          M 	popp	__command
0000D934 1F6D 0016 0001           M 	move.b	cmodspeed(a5),1(sp)
0000D93A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D93E 45EF 0010                M 	lea	4*4(sp),a2
0000D942 43FA 0000                M 	lea	.str_379(pc),a1
0000D946 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D94C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D950 5C4F                     M 	addq.w	#__sp,sp
0000D952 46DF                     M 	move.w	(sp)+,sr
0000D954 6000 0000                M 	bra.w	.instr_end_379
0000D958                          M 	.str_379:
0000D958                          M 	__fstring_generatedecodedstring	"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D958 =00000001                M 	__lpos:	set 1
0000D958 =00000001                M 	__pos:	set instr("%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D958                          M 	while	(__pos)
0000D958                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D958                          M 	dc.b	""
0000D958 =00000013                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D958 =00000014                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D958 =00000013                M 	__midpos:	= __endpos
0000D958                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D958                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D958                          M 	__param:	substr ,,"hex"
0000D958 80                       M 	dc.b	hex
0000D959 =00000014                M 	__lpos:	set __endpos+1
0000D959 =00000015                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D959                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D959 20                       M 	dc.b	" "
0000D95A =00000026                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D95A =00000027                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D95A =00000026                M 	__midpos:	= __endpos
0000D95A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D95A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D95A                          M 	__param:	substr ,,"hex"
0000D95A 80                       M 	dc.b	hex
0000D95B =00000027                M 	__lpos:	set __endpos+1
0000D95B =00000028                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D95B                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D95B 20                       M 	dc.b	" "
0000D95C =0000003A                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D95C =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D95C =0000003A                M 	__midpos:	= __endpos
0000D95C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D95C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D95C                          M 	__param:	substr ,,"hex"
0000D95C 80                       M 	dc.b	hex
0000D95D =0000003B                M 	__lpos:	set __endpos+1
0000D95D =00000000                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D95D                          M 	__substr:	substr __lpos,,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D95D                          M 	dc.b	""
0000D95D 00                       M 	dc.b	0
0000D95E                          M 	even
0000D95E                          M 	.instr_end_379:
0000D95E                            	Console.BreakLine
0000D95E 40E7                     M 	move.w	sr,-(sp)
0000D960 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D966 46DF                     M 	move.w	(sp)+,sr
0000D968                            
0000D968                            	Console.Write "%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D968 40E7                     M 	move.w	sr,-(sp)
0000D96A                          M 	__fstring_generateargumentscode	"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A =00000001                M 	__pos:	set instr("%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D96A =00000000                M 	__stack:set	0
0000D96A =00000000                M 	__sp:	set 0
0000D96A                          M 	while	(__pos)
0000D96A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D96A =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D96A =00000008                M 	__midpos:	= __endpos
0000D96A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D96A =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D96A =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D96A =00000016                M 	__midpos:	= __endpos
0000D96A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D96A =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D96A =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D96A =00000025                M 	__midpos:	= __endpos
0000D96A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	pushp	"move.b cLoop(a5),1(sp)"
0000D96A                          M 	pushp	"subq.w	#2, sp"
0000D96A =00000002                M 	__stack:	= __stack+2
0000D96A =00000002                M 	__sp:	= __sp+2
0000D96A =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D96A =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D96A =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D96A =00000037                M 	__midpos:	= __endpos
0000D96A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	pushp	"move.b cLoop+1(a5),1(sp)"
0000D96A                          M 	pushp	"subq.w	#2, sp"
0000D96A =00000004                M 	__stack:	= __stack+2
0000D96A =00000004                M 	__sp:	= __sp+2
0000D96A =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D96A =00000049                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D96A =0000004A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D96A =00000049                M 	__midpos:	= __endpos
0000D96A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96A                          M 	pushp	"move.b cLoop+2(a5),1(sp)"
0000D96A                          M 	pushp	"subq.w	#2, sp"
0000D96A =00000006                M 	__stack:	= __stack+2
0000D96A =00000006                M 	__sp:	= __sp+2
0000D96A =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D96A                          M 	rept	__stack
0000D96A                          M 	popp	__command
0000D96A 554F                     M 	subq.w	#2,sp
0000D96C                          M 	popp	__command
0000D96C 1F6D 001B 0001           M 	move.b	cloop+2(a5),1(sp)
0000D972                          M 	popp	__command
0000D972 554F                     M 	subq.w	#2,sp
0000D974                          M 	popp	__command
0000D974 1F6D 001A 0001           M 	move.b	cloop+1(a5),1(sp)
0000D97A                          M 	popp	__command
0000D97A 554F                     M 	subq.w	#2,sp
0000D97C                          M 	popp	__command
0000D97C 1F6D 0019 0001           M 	move.b	cloop(a5),1(sp)
0000D982 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D986 45EF 0010                M 	lea	4*4(sp),a2
0000D98A 43FA 0000                M 	lea	.str_383(pc),a1
0000D98E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D994 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D998 5C4F                     M 	addq.w	#__sp,sp
0000D99A 46DF                     M 	move.w	(sp)+,sr
0000D99C 6000 0000                M 	bra.w	.instr_end_383
0000D9A0                          M 	.str_383:
0000D9A0                          M 	__fstring_generatedecodedstring	"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A0 =00000001                M 	__lpos:	set 1
0000D9A0 =00000001                M 	__pos:	set instr("%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9A0                          M 	while	(__pos)
0000D9A0                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A0                          M 	dc.b	""
0000D9A0 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9A0 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9A0 =00000008                M 	__midpos:	= __endpos
0000D9A0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A0 EA                       M 	dc.b	fpal1
0000D9A1 =00000009                M 	__lpos:	set __endpos+1
0000D9A1 =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9A1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A1 4C6F 6F70 3A20           M 	dc.b	"Loop: "
0000D9A7 =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9A7 =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9A7 =00000016                M 	__midpos:	= __endpos
0000D9A7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A7                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A7 EC                       M 	dc.b	fpal2
0000D9A8 =00000017                M 	__lpos:	set __endpos+1
0000D9A8 =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9A8                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A8                          M 	dc.b	""
0000D9A8 =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9A8 =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9A8 =00000025                M 	__midpos:	= __endpos
0000D9A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A8                          M 	__param:	substr ,,"hex"
0000D9A8 80                       M 	dc.b	hex
0000D9A9 =00000026                M 	__lpos:	set __endpos+1
0000D9A9 =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9A9                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9A9 20                       M 	dc.b	" "
0000D9AA =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9AA =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9AA =00000037                M 	__midpos:	= __endpos
0000D9AA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9AA                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9AA                          M 	__param:	substr ,,"hex"
0000D9AA 80                       M 	dc.b	hex
0000D9AB =00000038                M 	__lpos:	set __endpos+1
0000D9AB =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9AB                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9AB 20                       M 	dc.b	" "
0000D9AC =00000049                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D9AC =0000004A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D9AC =00000049                M 	__midpos:	= __endpos
0000D9AC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9AC                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9AC                          M 	__param:	substr ,,"hex"
0000D9AC 80                       M 	dc.b	hex
0000D9AD =0000004A                M 	__lpos:	set __endpos+1
0000D9AD =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D9AD                          M 	__substr:	substr __lpos,,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D9AD 20                       M 	dc.b	" "
0000D9AE 00                       M 	dc.b	0
0000D9B0 00                       M 	even
0000D9B0                          M 	.instr_end_383:
0000D9B0 BAFC C67C                  	cmp.w	#mSFXDAC1,a5
0000D9B4 6400 0000                  	bhs.w	AMPS_Debug_Console_Channel_Writerts
0000D9B8                            	Console.WriteLine "%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9B8 40E7                     M 	move.w	sr,-(sp)
0000D9BA                          M 	__fstring_generateargumentscode	"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9BA =00000001                M 	__pos:	set instr("%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D9BA =00000000                M 	__stack:set	0
0000D9BA =00000000                M 	__sp:	set 0
0000D9BA                          M 	while	(__pos)
0000D9BA =00000016                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D9BA =00000017                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D9BA =00000016                M 	__midpos:	= __endpos
0000D9BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9BA                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9BA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9BA                          M 	pushp	"move.b cNoteTimeCur(a5),1(sp)"
0000D9BA                          M 	pushp	"subq.w	#2, sp"
0000D9BA =00000002                M 	__stack:	= __stack+2
0000D9BA =00000002                M 	__sp:	= __sp+2
0000D9BA =00000018                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D9BA =0000002E                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D9BA =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D9BA =0000002E                M 	__midpos:	= __endpos
0000D9BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9BA                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9BA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9BA                          M 	pushp	"move.b cNoteTimeMain(a5),1(sp)"
0000D9BA                          M 	pushp	"subq.w	#2, sp"
0000D9BA =00000004                M 	__stack:	= __stack+2
0000D9BA =00000004                M 	__sp:	= __sp+2
0000D9BA =00000000                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D9BA                          M 	rept	__stack
0000D9BA                          M 	popp	__command
0000D9BA 554F                     M 	subq.w	#2,sp
0000D9BC                          M 	popp	__command
0000D9BC 1F6D 001D 0001           M 	move.b	cnotetimemain(a5),1(sp)
0000D9C2                          M 	popp	__command
0000D9C2 554F                     M 	subq.w	#2,sp
0000D9C4                          M 	popp	__command
0000D9C4 1F6D 001C 0001           M 	move.b	cnotetimecur(a5),1(sp)
0000D9CA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D9CE 45EF 0010                M 	lea	4*4(sp),a2
0000D9D2 43FA 0000                M 	lea	.str_386(pc),a1
0000D9D6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D9DC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D9E0 584F                     M 	addq.w	#__sp,sp
0000D9E2 46DF                     M 	move.w	(sp)+,sr
0000D9E4 6000 0000                M 	bra.w	.instr_end_386
0000D9E8                          M 	.str_386:
0000D9E8                          M 	__fstring_generatedecodedstring	"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9E8 =00000001                M 	__lpos:	set 1
0000D9E8 =00000001                M 	__pos:	set instr("%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D9E8                          M 	while	(__pos)
0000D9E8                          M 	__substr:	substr __lpos,__pos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9E8                          M 	dc.b	""
0000D9E8 =00000016                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D9E8 =00000017                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D9E8 =00000016                M 	__midpos:	= __endpos
0000D9E8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9E8                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9E8                          M 	__param:	substr ,,"hex"
0000D9E8 80                       M 	dc.b	hex
0000D9E9 =00000017                M 	__lpos:	set __endpos+1
0000D9E9 =00000018                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D9E9                          M 	__substr:	substr __lpos,__pos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9E9 20                       M 	dc.b	" "
0000D9EA =0000002E                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D9EA =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D9EA =0000002E                M 	__midpos:	= __endpos
0000D9EA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9EA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9EA                          M 	__param:	substr ,,"hex"
0000D9EA 80                       M 	dc.b	hex
0000D9EB =0000002F                M 	__lpos:	set __endpos+1
0000D9EB =00000000                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D9EB                          M 	__substr:	substr __lpos,,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9EB                          M 	dc.b	""
0000D9EB 00                       M 	dc.b	0
0000D9EC                          M 	even
0000D9EC                          M 	.instr_end_386:
0000D9EC                            	Console.WriteLine "%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EC 40E7                     M 	move.w	sr,-(sp)
0000D9EE                          M 	__fstring_generateargumentscode	"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EE =00000001                M 	__pos:	set instr("%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9EE =00000000                M 	__stack:set	0
0000D9EE =00000000                M 	__sp:	set 0
0000D9EE                          M 	while	(__pos)
0000D9EE =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D9EE =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D9EE =00000008                M 	__midpos:	= __endpos
0000D9EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EE =00000010                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9EE =00000017                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D9EE =0000001C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D9EE =00000017                M 	__midpos:	= __endpos
0000D9EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EE =00000018                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9EE =00000027                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D9EE =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D9EE =00000027                M 	__midpos:	= __endpos
0000D9EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9EE                          M 	pushp	"move.b cStack(a5),1(sp)"
0000D9EE                          M 	pushp	"subq.w	#2, sp"
0000D9EE =00000002                M 	__stack:	= __stack+2
0000D9EE =00000002                M 	__sp:	= __sp+2
0000D9EE =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9EE                          M 	rept	__stack
0000D9EE                          M 	popp	__command
0000D9EE 554F                     M 	subq.w	#2,sp
0000D9F0                          M 	popp	__command
0000D9F0 1F6D 001E 0001           M 	move.b	cstack(a5),1(sp)
0000D9F6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D9FA 45EF 0010                M 	lea	4*4(sp),a2
0000D9FE 43FA 0000                M 	lea	.str_389(pc),a1
0000DA02 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA08 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA0C 544F                     M 	addq.w	#__sp,sp
0000DA0E 46DF                     M 	move.w	(sp)+,sr
0000DA10 6000 0000                M 	bra.w	.instr_end_389
0000DA14                          M 	.str_389:
0000DA14                          M 	__fstring_generatedecodedstring	"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA14 =00000001                M 	__lpos:	set 1
0000DA14 =00000001                M 	__pos:	set instr("%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DA14                          M 	while	(__pos)
0000DA14                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA14                          M 	dc.b	""
0000DA14 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000DA14 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000DA14 =00000008                M 	__midpos:	= __endpos
0000DA14                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA14                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA14 EA                       M 	dc.b	fpal1
0000DA15 =00000009                M 	__lpos:	set __endpos+1
0000DA15 =00000010                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DA15                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA15 5374 6163 6B3A 20        M 	dc.b	"Stack: "
0000DA1C =00000017                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000DA1C =0000001C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000DA1C =00000017                M 	__midpos:	= __endpos
0000DA1C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA1C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA1C EC                       M 	dc.b	fpal2
0000DA1D =00000018                M 	__lpos:	set __endpos+1
0000DA1D =00000018                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DA1D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA1D                          M 	dc.b	""
0000DA1D =00000027                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000DA1D =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000DA1D =00000027                M 	__midpos:	= __endpos
0000DA1D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA1D                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA1D                          M 	__param:	substr ,,"hex"
0000DA1D 80                       M 	dc.b	hex
0000DA1E =00000028                M 	__lpos:	set __endpos+1
0000DA1E =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000DA1E                          M 	__substr:	substr __lpos,,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000DA1E                          M 	dc.b	""
0000DA1E 00                       M 	dc.b	0
0000DA20 00                       M 	even
0000DA20                          M 	.instr_end_389:
0000DA20                            
0000DA20 320D                       	move.w	a5,d1
0000DA22 0641 002C                  	add.w	#cSize,d1
0000DA26                            
0000DA26 7000                       	moveq	#0,d0
0000DA28 102D 001E                  	move.b	cStack(a5),d0
0000DA2C DAC0                       	add.w	d0,a5
0000DA2E                            
0000DA2E                            AMPS_Debug_Console_Channel_Writeloop
0000DA2E B24D                       	cmp.w	a5,d1
0000DA30 6300                       	bls.s	AMPS_Debug_Console_Channel_Writerts
0000DA32                            	Console.WriteLine "%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA32 40E7                     M 	move.w	sr,-(sp)
0000DA34                          M 	__fstring_generateargumentscode	"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA34 =00000001                M 	__pos:	set instr("%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA34 =00000000                M 	__stack:set	0
0000DA34 =00000000                M 	__sp:	set 0
0000DA34                          M 	while	(__pos)
0000DA34 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA34 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA34 =00000008                M 	__midpos:	= __endpos
0000DA34                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA34 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA34 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA34 =00000013                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA34                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA34                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA34                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA34                          M 	pushp	"move.l (a5)+,-(sp)"
0000DA34 =00000001                M 	__stack:	= __stack+1
0000DA34 =00000004                M 	__sp:	= __sp+4
0000DA34 =0000001F                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA34 =0000002F                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA34 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA34 =0000002F                M 	__midpos:	= __endpos
0000DA34                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA34                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA34 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA34                          M 	rept	__stack
0000DA34                          M 	popp	__command
0000DA34 2F1D                     M 	move.l	(a5)+,-(sp)
0000DA36 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA3A 45EF 0010                M 	lea	4*4(sp),a2
0000DA3E 43FA 0000                M 	lea	.str_392(pc),a1
0000DA42 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA48 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA4C 584F                     M 	addq.w	#__sp,sp
0000DA4E 46DF                     M 	move.w	(sp)+,sr
0000DA50 6000 0000                M 	bra.w	.instr_end_392
0000DA54                          M 	.str_392:
0000DA54                          M 	__fstring_generatedecodedstring	"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA54 =00000001                M 	__lpos:	set 1
0000DA54 =00000001                M 	__pos:	set instr("%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA54                          M 	while	(__pos)
0000DA54                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA54                          M 	dc.b	""
0000DA54 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA54 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA54 =00000008                M 	__midpos:	= __endpos
0000DA54                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA54                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA54 E8                       M 	dc.b	fpal0
0000DA55 =00000009                M 	__lpos:	set __endpos+1
0000DA55 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA55                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA55                          M 	dc.b	""
0000DA55 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA55 =00000013                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA55                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA55                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA55 BB                       M 	dc.b	sym|fsplit|3
0000DA56 =0000001F                M 	__lpos:	set __endpos+1
0000DA56 =0000001F                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA56                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA56                          M 	dc.b	""
0000DA56 =0000002F                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA56 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA56 =0000002F                M 	__midpos:	= __endpos
0000DA56                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA56                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA56 ECC0                     M 	dc.b	fpal2,fsymdisp
0000DA58 =00000030                M 	__lpos:	set __endpos+1
0000DA58 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA58                          M 	__substr:	substr __lpos,,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA58                          M 	dc.b	""
0000DA58 00                       M 	dc.b	0
0000DA5A 00                       M 	even
0000DA5A                          M 	.instr_end_392:
0000DA5A 60D2                       	bra.s	AMPS_Debug_Console_Channel_Writeloop
0000DA5C                            
0000DA5C                            AMPS_Debug_Console_Channel_Writerts
0000DA5C 4E75                       	rts
0000DA5E                            ; ===========================================================================
0000DA5E                            ; ---------------------------------------------------------------------------
0000DA5E                            ; Generic console code
0000DA5E                            ; ---------------------------------------------------------------------------
0000DA5E                            
0000DA5E                            AMPS_Debug_Console_Main:
0000DA5E                            	Console.WriteLine "  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA5E 40E7                     M 	move.w	sr,-(sp)
0000DA60                          M 	__fstring_generateargumentscode	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA60 =00000000                M 	__stack:set	0
0000DA60 =00000000                M 	__sp:	set 0
0000DA60                          M 	while	(__pos)
0000DA60 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA60 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA60 =0000000A                M 	__midpos:	= __endpos
0000DA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA60 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA60 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA60 =00000016                M 	__midpos:	= __endpos
0000DA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA60 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA60 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA60 =0000001E                M 	__midpos:	= __endpos
0000DA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	pushp	"move.l d0,-(sp)"
0000DA60 =00000001                M 	__stack:	= __stack+1
0000DA60 =00000004                M 	__sp:	= __sp+4
0000DA60 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA60 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA60 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA60 =00000028                M 	__midpos:	= __endpos
0000DA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA60 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA60 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA60 =00000034                M 	__midpos:	= __endpos
0000DA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA60 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA60 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA60 =0000003C                M 	__midpos:	= __endpos
0000DA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA60                          M 	pushp	"move.l a0,-(sp)"
0000DA60 =00000002                M 	__stack:	= __stack+1
0000DA60 =00000008                M 	__sp:	= __sp+4
0000DA60 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA60                          M 	rept	__stack
0000DA60                          M 	popp	__command
0000DA60 2F08                     M 	move.l	a0,-(sp)
0000DA62                          M 	popp	__command
0000DA62 2F00                     M 	move.l	d0,-(sp)
0000DA64 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA68 45EF 0010                M 	lea	4*4(sp),a2
0000DA6C 43FA 0000                M 	lea	.str_395(pc),a1
0000DA70 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA76 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA7A 504F                     M 	addq.w	#__sp,sp
0000DA7C 46DF                     M 	move.w	(sp)+,sr
0000DA7E 6000 0000                M 	bra.w	.instr_end_395
0000DA82                          M 	.str_395:
0000DA82                          M 	__fstring_generatedecodedstring	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA82 =00000001                M 	__lpos:	set 1
0000DA82 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA82                          M 	while	(__pos)
0000DA82                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA82 2020                     M 	dc.b	"  "
0000DA84 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA84 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA84 =0000000A                M 	__midpos:	= __endpos
0000DA84                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA84                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA84 E8                       M 	dc.b	fpal0
0000DA85 =0000000B                M 	__lpos:	set __endpos+1
0000DA85 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA85                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA85 6430 3A20                M 	dc.b	"d0: "
0000DA89 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA89 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA89 =00000016                M 	__midpos:	= __endpos
0000DA89                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA89                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA89 EC                       M 	dc.b	fpal2
0000DA8A =00000017                M 	__lpos:	set __endpos+1
0000DA8A =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA8A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA8A                          M 	dc.b	""
0000DA8A =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA8A =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA8A =0000001E                M 	__midpos:	= __endpos
0000DA8A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA8A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA8A                          M 	__param:	substr ,,"hex"
0000DA8A 83                       M 	dc.b	hex|3
0000DA8B =0000001F                M 	__lpos:	set __endpos+1
0000DA8B =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA8B                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA8B 2020                     M 	dc.b	"  "
0000DA8D =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA8D =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA8D =00000028                M 	__midpos:	= __endpos
0000DA8D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA8D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA8D E8                       M 	dc.b	fpal0
0000DA8E =00000029                M 	__lpos:	set __endpos+1
0000DA8E =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA8E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA8E 6130 3A20                M 	dc.b	"a0: "
0000DA92 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA92 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA92 =00000034                M 	__midpos:	= __endpos
0000DA92                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA92                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA92 EC                       M 	dc.b	fpal2
0000DA93 =00000035                M 	__lpos:	set __endpos+1
0000DA93 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA93                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA93                          M 	dc.b	""
0000DA93 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA93 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA93 =0000003C                M 	__midpos:	= __endpos
0000DA93                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA93                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA93                          M 	__param:	substr ,,"hex"
0000DA93 83                       M 	dc.b	hex|3
0000DA94 =0000003D                M 	__lpos:	set __endpos+1
0000DA94 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA94                          M 	__substr:	substr __lpos,,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA94                          M 	dc.b	""
0000DA94 00                       M 	dc.b	0
0000DA96 00                       M 	even
0000DA96                          M 	.instr_end_395:
0000DA96                            	Console.WriteLine "  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA96 40E7                     M 	move.w	sr,-(sp)
0000DA98                          M 	__fstring_generateargumentscode	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98 =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA98 =00000000                M 	__stack:set	0
0000DA98 =00000000                M 	__sp:	set 0
0000DA98                          M 	while	(__pos)
0000DA98 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA98 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA98 =0000000A                M 	__midpos:	= __endpos
0000DA98                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA98 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA98 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA98 =00000016                M 	__midpos:	= __endpos
0000DA98                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA98 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA98 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA98 =0000001E                M 	__midpos:	= __endpos
0000DA98                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	pushp	"move.l d1,-(sp)"
0000DA98 =00000001                M 	__stack:	= __stack+1
0000DA98 =00000004                M 	__sp:	= __sp+4
0000DA98 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA98 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA98 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA98 =00000028                M 	__midpos:	= __endpos
0000DA98                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA98 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA98 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA98 =00000034                M 	__midpos:	= __endpos
0000DA98                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA98 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA98 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA98 =0000003C                M 	__midpos:	= __endpos
0000DA98                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA98                          M 	pushp	"move.l a1,-(sp)"
0000DA98 =00000002                M 	__stack:	= __stack+1
0000DA98 =00000008                M 	__sp:	= __sp+4
0000DA98 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA98                          M 	rept	__stack
0000DA98                          M 	popp	__command
0000DA98 2F09                     M 	move.l	a1,-(sp)
0000DA9A                          M 	popp	__command
0000DA9A 2F01                     M 	move.l	d1,-(sp)
0000DA9C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DAA0 45EF 0010                M 	lea	4*4(sp),a2
0000DAA4 43FA 0000                M 	lea	.str_398(pc),a1
0000DAA8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DAAE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DAB2 504F                     M 	addq.w	#__sp,sp
0000DAB4 46DF                     M 	move.w	(sp)+,sr
0000DAB6 6000 0000                M 	bra.w	.instr_end_398
0000DABA                          M 	.str_398:
0000DABA                          M 	__fstring_generatedecodedstring	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DABA =00000001                M 	__lpos:	set 1
0000DABA =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DABA                          M 	while	(__pos)
0000DABA                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DABA 2020                     M 	dc.b	"  "
0000DABC =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DABC =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DABC =0000000A                M 	__midpos:	= __endpos
0000DABC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DABC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DABC E8                       M 	dc.b	fpal0
0000DABD =0000000B                M 	__lpos:	set __endpos+1
0000DABD =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DABD                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DABD 6431 3A20                M 	dc.b	"d1: "
0000DAC1 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DAC1 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DAC1 =00000016                M 	__midpos:	= __endpos
0000DAC1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DAC1                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DAC1 EC                       M 	dc.b	fpal2
0000DAC2 =00000017                M 	__lpos:	set __endpos+1
0000DAC2 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DAC2                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DAC2                          M 	dc.b	""
0000DAC2 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DAC2 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DAC2 =0000001E                M 	__midpos:	= __endpos
0000DAC2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DAC2                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DAC2                          M 	__param:	substr ,,"hex"
0000DAC2 83                       M 	dc.b	hex|3
0000DAC3 =0000001F                M 	__lpos:	set __endpos+1
0000DAC3 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DAC3                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DAC3 2020                     M 	dc.b	"  "
0000DAC5 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DAC5 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DAC5 =00000028                M 	__midpos:	= __endpos
0000DAC5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DAC5                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DAC5 E8                       M 	dc.b	fpal0
0000DAC6 =00000029                M 	__lpos:	set __endpos+1
0000DAC6 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DAC6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DAC6 6131 3A20                M 	dc.b	"a1: "
0000DACA =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DACA =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DACA =00000034                M 	__midpos:	= __endpos
0000DACA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DACA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DACA EC                       M 	dc.b	fpal2
0000DACB =00000035                M 	__lpos:	set __endpos+1
0000DACB =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DACB                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DACB                          M 	dc.b	""
0000DACB =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DACB =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DACB =0000003C                M 	__midpos:	= __endpos
0000DACB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DACB                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DACB                          M 	__param:	substr ,,"hex"
0000DACB 83                       M 	dc.b	hex|3
0000DACC =0000003D                M 	__lpos:	set __endpos+1
0000DACC =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DACC                          M 	__substr:	substr __lpos,,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DACC                          M 	dc.b	""
0000DACC 00                       M 	dc.b	0
0000DACE 00                       M 	even
0000DACE                          M 	.instr_end_398:
0000DACE                            	Console.WriteLine "  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DACE 40E7                     M 	move.w	sr,-(sp)
0000DAD0                          M 	__fstring_generateargumentscode	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAD0 =00000000                M 	__stack:set	0
0000DAD0 =00000000                M 	__sp:	set 0
0000DAD0                          M 	while	(__pos)
0000DAD0 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAD0 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAD0 =0000000A                M 	__midpos:	= __endpos
0000DAD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAD0 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAD0 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAD0 =00000016                M 	__midpos:	= __endpos
0000DAD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAD0 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAD0 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAD0 =0000001E                M 	__midpos:	= __endpos
0000DAD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	pushp	"move.l d2,-(sp)"
0000DAD0 =00000001                M 	__stack:	= __stack+1
0000DAD0 =00000004                M 	__sp:	= __sp+4
0000DAD0 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAD0 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAD0 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAD0 =00000028                M 	__midpos:	= __endpos
0000DAD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAD0 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAD0 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAD0 =00000034                M 	__midpos:	= __endpos
0000DAD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAD0 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAD0 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAD0 =0000003C                M 	__midpos:	= __endpos
0000DAD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAD0                          M 	pushp	"move.l a2,-(sp)"
0000DAD0 =00000002                M 	__stack:	= __stack+1
0000DAD0 =00000008                M 	__sp:	= __sp+4
0000DAD0 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAD0                          M 	rept	__stack
0000DAD0                          M 	popp	__command
0000DAD0 2F0A                     M 	move.l	a2,-(sp)
0000DAD2                          M 	popp	__command
0000DAD2 2F02                     M 	move.l	d2,-(sp)
0000DAD4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DAD8 45EF 0010                M 	lea	4*4(sp),a2
0000DADC 43FA 0000                M 	lea	.str_401(pc),a1
0000DAE0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DAE6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DAEA 504F                     M 	addq.w	#__sp,sp
0000DAEC 46DF                     M 	move.w	(sp)+,sr
0000DAEE 6000 0000                M 	bra.w	.instr_end_401
0000DAF2                          M 	.str_401:
0000DAF2                          M 	__fstring_generatedecodedstring	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAF2 =00000001                M 	__lpos:	set 1
0000DAF2 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAF2                          M 	while	(__pos)
0000DAF2                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAF2 2020                     M 	dc.b	"  "
0000DAF4 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAF4 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAF4 =0000000A                M 	__midpos:	= __endpos
0000DAF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAF4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAF4 E8                       M 	dc.b	fpal0
0000DAF5 =0000000B                M 	__lpos:	set __endpos+1
0000DAF5 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAF5                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAF5 6432 3A20                M 	dc.b	"d2: "
0000DAF9 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAF9 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAF9 =00000016                M 	__midpos:	= __endpos
0000DAF9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAF9                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAF9 EC                       M 	dc.b	fpal2
0000DAFA =00000017                M 	__lpos:	set __endpos+1
0000DAFA =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAFA                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAFA                          M 	dc.b	""
0000DAFA =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAFA =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAFA =0000001E                M 	__midpos:	= __endpos
0000DAFA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAFA                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAFA                          M 	__param:	substr ,,"hex"
0000DAFA 83                       M 	dc.b	hex|3
0000DAFB =0000001F                M 	__lpos:	set __endpos+1
0000DAFB =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAFB                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAFB 2020                     M 	dc.b	"  "
0000DAFD =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAFD =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAFD =00000028                M 	__midpos:	= __endpos
0000DAFD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAFD                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAFD E8                       M 	dc.b	fpal0
0000DAFE =00000029                M 	__lpos:	set __endpos+1
0000DAFE =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAFE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAFE 6132 3A20                M 	dc.b	"a2: "
0000DB02 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB02 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB02 =00000034                M 	__midpos:	= __endpos
0000DB02                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB02                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB02 EC                       M 	dc.b	fpal2
0000DB03 =00000035                M 	__lpos:	set __endpos+1
0000DB03 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB03                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB03                          M 	dc.b	""
0000DB03 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DB03 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DB03 =0000003C                M 	__midpos:	= __endpos
0000DB03                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB03                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB03                          M 	__param:	substr ,,"hex"
0000DB03 83                       M 	dc.b	hex|3
0000DB04 =0000003D                M 	__lpos:	set __endpos+1
0000DB04 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DB04                          M 	__substr:	substr __lpos,,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DB04                          M 	dc.b	""
0000DB04 00                       M 	dc.b	0
0000DB06 00                       M 	even
0000DB06                          M 	.instr_end_401:
0000DB06                            	Console.WriteLine "  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB06 40E7                     M 	move.w	sr,-(sp)
0000DB08                          M 	__fstring_generateargumentscode	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08 =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB08 =00000000                M 	__stack:set	0
0000DB08 =00000000                M 	__sp:	set 0
0000DB08                          M 	while	(__pos)
0000DB08 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB08 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB08 =0000000A                M 	__midpos:	= __endpos
0000DB08                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB08 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB08 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB08 =00000016                M 	__midpos:	= __endpos
0000DB08                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB08 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB08 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB08 =0000001E                M 	__midpos:	= __endpos
0000DB08                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	pushp	"move.l d3,-(sp)"
0000DB08 =00000001                M 	__stack:	= __stack+1
0000DB08 =00000004                M 	__sp:	= __sp+4
0000DB08 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB08 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB08 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB08 =00000028                M 	__midpos:	= __endpos
0000DB08                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB08 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB08 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB08 =00000034                M 	__midpos:	= __endpos
0000DB08                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB08 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB08 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB08 =0000003C                M 	__midpos:	= __endpos
0000DB08                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB08                          M 	pushp	"move.l a3,-(sp)"
0000DB08 =00000002                M 	__stack:	= __stack+1
0000DB08 =00000008                M 	__sp:	= __sp+4
0000DB08 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB08                          M 	rept	__stack
0000DB08                          M 	popp	__command
0000DB08 2F0B                     M 	move.l	a3,-(sp)
0000DB0A                          M 	popp	__command
0000DB0A 2F03                     M 	move.l	d3,-(sp)
0000DB0C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DB10 45EF 0010                M 	lea	4*4(sp),a2
0000DB14 43FA 0000                M 	lea	.str_404(pc),a1
0000DB18 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB1E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB22 504F                     M 	addq.w	#__sp,sp
0000DB24 46DF                     M 	move.w	(sp)+,sr
0000DB26 6000 0000                M 	bra.w	.instr_end_404
0000DB2A                          M 	.str_404:
0000DB2A                          M 	__fstring_generatedecodedstring	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB2A =00000001                M 	__lpos:	set 1
0000DB2A =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB2A                          M 	while	(__pos)
0000DB2A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB2A 2020                     M 	dc.b	"  "
0000DB2C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB2C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB2C =0000000A                M 	__midpos:	= __endpos
0000DB2C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB2C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB2C E8                       M 	dc.b	fpal0
0000DB2D =0000000B                M 	__lpos:	set __endpos+1
0000DB2D =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB2D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB2D 6433 3A20                M 	dc.b	"d3: "
0000DB31 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB31 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB31 =00000016                M 	__midpos:	= __endpos
0000DB31                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB31                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB31 EC                       M 	dc.b	fpal2
0000DB32 =00000017                M 	__lpos:	set __endpos+1
0000DB32 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB32                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB32                          M 	dc.b	""
0000DB32 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB32 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB32 =0000001E                M 	__midpos:	= __endpos
0000DB32                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB32                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB32                          M 	__param:	substr ,,"hex"
0000DB32 83                       M 	dc.b	hex|3
0000DB33 =0000001F                M 	__lpos:	set __endpos+1
0000DB33 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB33                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB33 2020                     M 	dc.b	"  "
0000DB35 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB35 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB35 =00000028                M 	__midpos:	= __endpos
0000DB35                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB35                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB35 E8                       M 	dc.b	fpal0
0000DB36 =00000029                M 	__lpos:	set __endpos+1
0000DB36 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB36                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB36 6133 3A20                M 	dc.b	"a3: "
0000DB3A =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB3A =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB3A =00000034                M 	__midpos:	= __endpos
0000DB3A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB3A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB3A EC                       M 	dc.b	fpal2
0000DB3B =00000035                M 	__lpos:	set __endpos+1
0000DB3B =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB3B                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB3B                          M 	dc.b	""
0000DB3B =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DB3B =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DB3B =0000003C                M 	__midpos:	= __endpos
0000DB3B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB3B                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB3B                          M 	__param:	substr ,,"hex"
0000DB3B 83                       M 	dc.b	hex|3
0000DB3C =0000003D                M 	__lpos:	set __endpos+1
0000DB3C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB3C                          M 	__substr:	substr __lpos,,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB3C                          M 	dc.b	""
0000DB3C 00                       M 	dc.b	0
0000DB3E 00                       M 	even
0000DB3E                          M 	.instr_end_404:
0000DB3E                            	Console.WriteLine "  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB3E 40E7                     M 	move.w	sr,-(sp)
0000DB40                          M 	__fstring_generateargumentscode	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB40 =00000000                M 	__stack:set	0
0000DB40 =00000000                M 	__sp:	set 0
0000DB40                          M 	while	(__pos)
0000DB40 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB40 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB40 =0000000A                M 	__midpos:	= __endpos
0000DB40                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB40 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB40 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB40 =00000016                M 	__midpos:	= __endpos
0000DB40                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB40 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB40 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB40 =0000001E                M 	__midpos:	= __endpos
0000DB40                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	pushp	"move.l d4,-(sp)"
0000DB40 =00000001                M 	__stack:	= __stack+1
0000DB40 =00000004                M 	__sp:	= __sp+4
0000DB40 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB40 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB40 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB40 =00000028                M 	__midpos:	= __endpos
0000DB40                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB40 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB40 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB40 =00000034                M 	__midpos:	= __endpos
0000DB40                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB40 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB40 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB40 =0000003C                M 	__midpos:	= __endpos
0000DB40                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB40                          M 	pushp	"move.l a4,-(sp)"
0000DB40 =00000002                M 	__stack:	= __stack+1
0000DB40 =00000008                M 	__sp:	= __sp+4
0000DB40 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB40                          M 	rept	__stack
0000DB40                          M 	popp	__command
0000DB40 2F0C                     M 	move.l	a4,-(sp)
0000DB42                          M 	popp	__command
0000DB42 2F04                     M 	move.l	d4,-(sp)
0000DB44 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DB48 45EF 0010                M 	lea	4*4(sp),a2
0000DB4C 43FA 0000                M 	lea	.str_407(pc),a1
0000DB50 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB56 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB5A 504F                     M 	addq.w	#__sp,sp
0000DB5C 46DF                     M 	move.w	(sp)+,sr
0000DB5E 6000 0000                M 	bra.w	.instr_end_407
0000DB62                          M 	.str_407:
0000DB62                          M 	__fstring_generatedecodedstring	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB62 =00000001                M 	__lpos:	set 1
0000DB62 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB62                          M 	while	(__pos)
0000DB62                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB62 2020                     M 	dc.b	"  "
0000DB64 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB64 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB64 =0000000A                M 	__midpos:	= __endpos
0000DB64                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB64                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB64 E8                       M 	dc.b	fpal0
0000DB65 =0000000B                M 	__lpos:	set __endpos+1
0000DB65 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB65                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB65 6434 3A20                M 	dc.b	"d4: "
0000DB69 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB69 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB69 =00000016                M 	__midpos:	= __endpos
0000DB69                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB69                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB69 EC                       M 	dc.b	fpal2
0000DB6A =00000017                M 	__lpos:	set __endpos+1
0000DB6A =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB6A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB6A                          M 	dc.b	""
0000DB6A =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB6A =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB6A =0000001E                M 	__midpos:	= __endpos
0000DB6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB6A                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB6A                          M 	__param:	substr ,,"hex"
0000DB6A 83                       M 	dc.b	hex|3
0000DB6B =0000001F                M 	__lpos:	set __endpos+1
0000DB6B =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB6B                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB6B 2020                     M 	dc.b	"  "
0000DB6D =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB6D =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB6D =00000028                M 	__midpos:	= __endpos
0000DB6D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB6D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB6D E8                       M 	dc.b	fpal0
0000DB6E =00000029                M 	__lpos:	set __endpos+1
0000DB6E =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB6E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB6E 6134 3A20                M 	dc.b	"a4: "
0000DB72 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB72 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB72 =00000034                M 	__midpos:	= __endpos
0000DB72                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB72                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB72 EC                       M 	dc.b	fpal2
0000DB73 =00000035                M 	__lpos:	set __endpos+1
0000DB73 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB73                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB73                          M 	dc.b	""
0000DB73 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB73 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB73 =0000003C                M 	__midpos:	= __endpos
0000DB73                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB73                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB73                          M 	__param:	substr ,,"hex"
0000DB73 83                       M 	dc.b	hex|3
0000DB74 =0000003D                M 	__lpos:	set __endpos+1
0000DB74 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB74                          M 	__substr:	substr __lpos,,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB74                          M 	dc.b	""
0000DB74 00                       M 	dc.b	0
0000DB76 00                       M 	even
0000DB76                          M 	.instr_end_407:
0000DB76                            	Console.WriteLine "  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB76 40E7                     M 	move.w	sr,-(sp)
0000DB78                          M 	__fstring_generateargumentscode	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78 =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB78 =00000000                M 	__stack:set	0
0000DB78 =00000000                M 	__sp:	set 0
0000DB78                          M 	while	(__pos)
0000DB78 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB78 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB78 =0000000A                M 	__midpos:	= __endpos
0000DB78                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB78 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB78 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB78 =00000016                M 	__midpos:	= __endpos
0000DB78                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB78 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB78 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB78 =0000001E                M 	__midpos:	= __endpos
0000DB78                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	pushp	"move.l d5,-(sp)"
0000DB78 =00000001                M 	__stack:	= __stack+1
0000DB78 =00000004                M 	__sp:	= __sp+4
0000DB78 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB78 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB78 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB78 =00000028                M 	__midpos:	= __endpos
0000DB78                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB78 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB78 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB78 =00000034                M 	__midpos:	= __endpos
0000DB78                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB78 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB78 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB78 =0000003C                M 	__midpos:	= __endpos
0000DB78                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB78                          M 	pushp	"move.l a5,-(sp)"
0000DB78 =00000002                M 	__stack:	= __stack+1
0000DB78 =00000008                M 	__sp:	= __sp+4
0000DB78 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB78                          M 	rept	__stack
0000DB78                          M 	popp	__command
0000DB78 2F0D                     M 	move.l	a5,-(sp)
0000DB7A                          M 	popp	__command
0000DB7A 2F05                     M 	move.l	d5,-(sp)
0000DB7C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DB80 45EF 0010                M 	lea	4*4(sp),a2
0000DB84 43FA 0000                M 	lea	.str_410(pc),a1
0000DB88 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB8E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB92 504F                     M 	addq.w	#__sp,sp
0000DB94 46DF                     M 	move.w	(sp)+,sr
0000DB96 6000 0000                M 	bra.w	.instr_end_410
0000DB9A                          M 	.str_410:
0000DB9A                          M 	__fstring_generatedecodedstring	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB9A =00000001                M 	__lpos:	set 1
0000DB9A =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB9A                          M 	while	(__pos)
0000DB9A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB9A 2020                     M 	dc.b	"  "
0000DB9C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB9C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB9C =0000000A                M 	__midpos:	= __endpos
0000DB9C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB9C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB9C E8                       M 	dc.b	fpal0
0000DB9D =0000000B                M 	__lpos:	set __endpos+1
0000DB9D =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB9D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB9D 6435 3A20                M 	dc.b	"d5: "
0000DBA1 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DBA1 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DBA1 =00000016                M 	__midpos:	= __endpos
0000DBA1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBA1                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBA1 EC                       M 	dc.b	fpal2
0000DBA2 =00000017                M 	__lpos:	set __endpos+1
0000DBA2 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DBA2                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBA2                          M 	dc.b	""
0000DBA2 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DBA2 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DBA2 =0000001E                M 	__midpos:	= __endpos
0000DBA2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBA2                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBA2                          M 	__param:	substr ,,"hex"
0000DBA2 83                       M 	dc.b	hex|3
0000DBA3 =0000001F                M 	__lpos:	set __endpos+1
0000DBA3 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DBA3                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBA3 2020                     M 	dc.b	"  "
0000DBA5 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DBA5 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DBA5 =00000028                M 	__midpos:	= __endpos
0000DBA5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBA5                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBA5 E8                       M 	dc.b	fpal0
0000DBA6 =00000029                M 	__lpos:	set __endpos+1
0000DBA6 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DBA6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBA6 6135 3A20                M 	dc.b	"a5: "
0000DBAA =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DBAA =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DBAA =00000034                M 	__midpos:	= __endpos
0000DBAA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBAA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBAA EC                       M 	dc.b	fpal2
0000DBAB =00000035                M 	__lpos:	set __endpos+1
0000DBAB =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DBAB                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBAB                          M 	dc.b	""
0000DBAB =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DBAB =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DBAB =0000003C                M 	__midpos:	= __endpos
0000DBAB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBAB                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBAB                          M 	__param:	substr ,,"hex"
0000DBAB 83                       M 	dc.b	hex|3
0000DBAC =0000003D                M 	__lpos:	set __endpos+1
0000DBAC =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DBAC                          M 	__substr:	substr __lpos,,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DBAC                          M 	dc.b	""
0000DBAC 00                       M 	dc.b	0
0000DBAE 00                       M 	even
0000DBAE                          M 	.instr_end_410:
0000DBAE                            	Console.WriteLine "  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBAE 40E7                     M 	move.w	sr,-(sp)
0000DBB0                          M 	__fstring_generateargumentscode	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBB0 =00000000                M 	__stack:set	0
0000DBB0 =00000000                M 	__sp:	set 0
0000DBB0                          M 	while	(__pos)
0000DBB0 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBB0 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBB0 =0000000A                M 	__midpos:	= __endpos
0000DBB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBB0 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBB0 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBB0 =00000016                M 	__midpos:	= __endpos
0000DBB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBB0 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBB0 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBB0 =0000001E                M 	__midpos:	= __endpos
0000DBB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	pushp	"move.l d6,-(sp)"
0000DBB0 =00000001                M 	__stack:	= __stack+1
0000DBB0 =00000004                M 	__sp:	= __sp+4
0000DBB0 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBB0 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBB0 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBB0 =00000028                M 	__midpos:	= __endpos
0000DBB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBB0 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBB0 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBB0 =00000034                M 	__midpos:	= __endpos
0000DBB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBB0 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBB0 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBB0 =0000003C                M 	__midpos:	= __endpos
0000DBB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBB0                          M 	pushp	"move.l a6,-(sp)"
0000DBB0 =00000002                M 	__stack:	= __stack+1
0000DBB0 =00000008                M 	__sp:	= __sp+4
0000DBB0 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBB0                          M 	rept	__stack
0000DBB0                          M 	popp	__command
0000DBB0 2F0E                     M 	move.l	a6,-(sp)
0000DBB2                          M 	popp	__command
0000DBB2 2F06                     M 	move.l	d6,-(sp)
0000DBB4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DBB8 45EF 0010                M 	lea	4*4(sp),a2
0000DBBC 43FA 0000                M 	lea	.str_413(pc),a1
0000DBC0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DBC6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DBCA 504F                     M 	addq.w	#__sp,sp
0000DBCC 46DF                     M 	move.w	(sp)+,sr
0000DBCE 6000 0000                M 	bra.w	.instr_end_413
0000DBD2                          M 	.str_413:
0000DBD2                          M 	__fstring_generatedecodedstring	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBD2 =00000001                M 	__lpos:	set 1
0000DBD2 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBD2                          M 	while	(__pos)
0000DBD2                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBD2 2020                     M 	dc.b	"  "
0000DBD4 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBD4 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBD4 =0000000A                M 	__midpos:	= __endpos
0000DBD4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBD4                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBD4 E8                       M 	dc.b	fpal0
0000DBD5 =0000000B                M 	__lpos:	set __endpos+1
0000DBD5 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBD5                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBD5 6436 3A20                M 	dc.b	"d6: "
0000DBD9 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBD9 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBD9 =00000016                M 	__midpos:	= __endpos
0000DBD9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBD9                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBD9 EC                       M 	dc.b	fpal2
0000DBDA =00000017                M 	__lpos:	set __endpos+1
0000DBDA =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBDA                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBDA                          M 	dc.b	""
0000DBDA =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBDA =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBDA =0000001E                M 	__midpos:	= __endpos
0000DBDA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBDA                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBDA                          M 	__param:	substr ,,"hex"
0000DBDA 83                       M 	dc.b	hex|3
0000DBDB =0000001F                M 	__lpos:	set __endpos+1
0000DBDB =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBDB                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBDB 2020                     M 	dc.b	"  "
0000DBDD =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBDD =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBDD =00000028                M 	__midpos:	= __endpos
0000DBDD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBDD                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBDD E8                       M 	dc.b	fpal0
0000DBDE =00000029                M 	__lpos:	set __endpos+1
0000DBDE =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBDE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBDE 6136 3A20                M 	dc.b	"a6: "
0000DBE2 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBE2 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBE2 =00000034                M 	__midpos:	= __endpos
0000DBE2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBE2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBE2 EC                       M 	dc.b	fpal2
0000DBE3 =00000035                M 	__lpos:	set __endpos+1
0000DBE3 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBE3                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBE3                          M 	dc.b	""
0000DBE3 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBE3 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBE3 =0000003C                M 	__midpos:	= __endpos
0000DBE3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBE3                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBE3                          M 	__param:	substr ,,"hex"
0000DBE3 83                       M 	dc.b	hex|3
0000DBE4 =0000003D                M 	__lpos:	set __endpos+1
0000DBE4 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBE4                          M 	__substr:	substr __lpos,,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBE4                          M 	dc.b	""
0000DBE4 00                       M 	dc.b	0
0000DBE6 00                       M 	even
0000DBE6                          M 	.instr_end_413:
0000DBE6                            	Console.WriteLine "  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE6 40E7                     M 	move.w	sr,-(sp)
0000DBE8                          M 	__fstring_generateargumentscode	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8 =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBE8 =00000000                M 	__stack:set	0
0000DBE8 =00000000                M 	__sp:	set 0
0000DBE8                          M 	while	(__pos)
0000DBE8 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBE8 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBE8 =0000000A                M 	__midpos:	= __endpos
0000DBE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBE8 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBE8 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBE8 =00000016                M 	__midpos:	= __endpos
0000DBE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBE8 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBE8 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBE8 =0000001E                M 	__midpos:	= __endpos
0000DBE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	pushp	"move.l d7,-(sp)"
0000DBE8 =00000001                M 	__stack:	= __stack+1
0000DBE8 =00000004                M 	__sp:	= __sp+4
0000DBE8 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBE8 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBE8 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBE8 =00000028                M 	__midpos:	= __endpos
0000DBE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBE8 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBE8 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBE8 =00000034                M 	__midpos:	= __endpos
0000DBE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBE8 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBE8 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBE8 =0000003C                M 	__midpos:	= __endpos
0000DBE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE8                          M 	pushp	"move.l a7,-(sp)"
0000DBE8 =00000002                M 	__stack:	= __stack+1
0000DBE8 =00000008                M 	__sp:	= __sp+4
0000DBE8 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBE8                          M 	rept	__stack
0000DBE8                          M 	popp	__command
0000DBE8 2F0F                     M 	move.l	a7,-(sp)
0000DBEA                          M 	popp	__command
0000DBEA 2F07                     M 	move.l	d7,-(sp)
0000DBEC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DBF0 45EF 0010                M 	lea	4*4(sp),a2
0000DBF4 43FA 0000                M 	lea	.str_416(pc),a1
0000DBF8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DBFE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DC02 504F                     M 	addq.w	#__sp,sp
0000DC04 46DF                     M 	move.w	(sp)+,sr
0000DC06 6000 0000                M 	bra.w	.instr_end_416
0000DC0A                          M 	.str_416:
0000DC0A                          M 	__fstring_generatedecodedstring	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC0A =00000001                M 	__lpos:	set 1
0000DC0A =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC0A                          M 	while	(__pos)
0000DC0A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC0A 2020                     M 	dc.b	"  "
0000DC0C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC0C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC0C =0000000A                M 	__midpos:	= __endpos
0000DC0C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC0C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC0C E8                       M 	dc.b	fpal0
0000DC0D =0000000B                M 	__lpos:	set __endpos+1
0000DC0D =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC0D                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC0D 6437 3A20                M 	dc.b	"d7: "
0000DC11 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC11 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC11 =00000016                M 	__midpos:	= __endpos
0000DC11                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC11                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC11 EC                       M 	dc.b	fpal2
0000DC12 =00000017                M 	__lpos:	set __endpos+1
0000DC12 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC12                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC12                          M 	dc.b	""
0000DC12 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC12 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC12 =0000001E                M 	__midpos:	= __endpos
0000DC12                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC12                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC12                          M 	__param:	substr ,,"hex"
0000DC12 83                       M 	dc.b	hex|3
0000DC13 =0000001F                M 	__lpos:	set __endpos+1
0000DC13 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC13                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC13 2020                     M 	dc.b	"  "
0000DC15 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC15 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC15 =00000028                M 	__midpos:	= __endpos
0000DC15                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC15                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC15 E8                       M 	dc.b	fpal0
0000DC16 =00000029                M 	__lpos:	set __endpos+1
0000DC16 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC16                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC16 7370 3A20                M 	dc.b	"sp: "
0000DC1A =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC1A =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC1A =00000034                M 	__midpos:	= __endpos
0000DC1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC1A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC1A EC                       M 	dc.b	fpal2
0000DC1B =00000035                M 	__lpos:	set __endpos+1
0000DC1B =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC1B                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC1B                          M 	dc.b	""
0000DC1B =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DC1B =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DC1B =0000003C                M 	__midpos:	= __endpos
0000DC1B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC1B                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC1B                          M 	__param:	substr ,,"hex"
0000DC1B 83                       M 	dc.b	hex|3
0000DC1C =0000003D                M 	__lpos:	set __endpos+1
0000DC1C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DC1C                          M 	__substr:	substr __lpos,,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DC1C                          M 	dc.b	""
0000DC1C 00                       M 	dc.b	0
0000DC1E 00                       M 	even
0000DC1E                          M 	.instr_end_416:
0000DC1E                            	Console.BreakLine
0000DC1E 40E7                     M 	move.w	sr,-(sp)
0000DC20 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000DC26 46DF                     M 	move.w	(sp)+,sr
0000DC28                            
0000DC28                            	Console.Write	  "%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC28 40E7                     M 	move.w	sr,-(sp)
0000DC2A                          M 	__fstring_generateargumentscode	"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A =00000001                M 	__pos:	set instr("%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC2A =00000000                M 	__stack:set	0
0000DC2A =00000000                M 	__sp:	set 0
0000DC2A                          M 	while	(__pos)
0000DC2A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC2A =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC2A =00000008                M 	__midpos:	= __endpos
0000DC2A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC2A =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC2A =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC2A =00000018                M 	__midpos:	= __endpos
0000DC2A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC2A =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC2A =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC2A =00000026                M 	__midpos:	= __endpos
0000DC2A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	pushp	"move.b mFlags.w,1(sp)"
0000DC2A                          M 	pushp	"subq.w	#2, sp"
0000DC2A =00000002                M 	__stack:	= __stack+2
0000DC2A =00000002                M 	__sp:	= __sp+2
0000DC2A =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC2A =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC2A =00000037                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC2A =00000036                M 	__midpos:	= __endpos
0000DC2A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC2A                          M 	pushp	"move.b mCtrPal.w,1(sp)"
0000DC2A                          M 	pushp	"subq.w	#2, sp"
0000DC2A =00000004                M 	__stack:	= __stack+2
0000DC2A =00000004                M 	__sp:	= __sp+2
0000DC2A =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC2A                          M 	rept	__stack
0000DC2A                          M 	popp	__command
0000DC2A 554F                     M 	subq.w	#2,sp
0000DC2C                          M 	popp	__command
0000DC2C 1F78 C4A7 0001           M 	move.b	mctrpal.w,1(sp)
0000DC32                          M 	popp	__command
0000DC32 554F                     M 	subq.w	#2,sp
0000DC34                          M 	popp	__command
0000DC34 1F78 C4A6 0001           M 	move.b	mflags.w,1(sp)
0000DC3A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DC3E 45EF 0010                M 	lea	4*4(sp),a2
0000DC42 43FA 0000                M 	lea	.str_420(pc),a1
0000DC46 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DC4C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DC50 584F                     M 	addq.w	#__sp,sp
0000DC52 46DF                     M 	move.w	(sp)+,sr
0000DC54 6000 0000                M 	bra.w	.instr_end_420
0000DC58                          M 	.str_420:
0000DC58                          M 	__fstring_generatedecodedstring	"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC58 =00000001                M 	__lpos:	set 1
0000DC58 =00000001                M 	__pos:	set instr("%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC58                          M 	while	(__pos)
0000DC58                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC58                          M 	dc.b	""
0000DC58 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC58 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC58 =00000008                M 	__midpos:	= __endpos
0000DC58                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC58                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC58 EA                       M 	dc.b	fpal1
0000DC59 =00000009                M 	__lpos:	set __endpos+1
0000DC59 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC59                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC59 4D69 7363 3A20 2020      M 	dc.b	"Misc:   "
0000DC61 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC61 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC61 =00000018                M 	__midpos:	= __endpos
0000DC61                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC61                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC61 EC                       M 	dc.b	fpal2
0000DC62 =00000019                M 	__lpos:	set __endpos+1
0000DC62 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC62                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC62                          M 	dc.b	""
0000DC62 =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC62 =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC62 =00000026                M 	__midpos:	= __endpos
0000DC62                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC62                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC62                          M 	__param:	substr ,,"hex"
0000DC62 80                       M 	dc.b	hex
0000DC63 =00000027                M 	__lpos:	set __endpos+1
0000DC63 =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC63                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC63 20                       M 	dc.b	" "
0000DC64 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC64 =00000037                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC64 =00000036                M 	__midpos:	= __endpos
0000DC64                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC64                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC64                          M 	__param:	substr ,,"hex"
0000DC64 80                       M 	dc.b	hex
0000DC65 =00000037                M 	__lpos:	set __endpos+1
0000DC65 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC65                          M 	__substr:	substr __lpos,,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC65 20                       M 	dc.b	" "
0000DC66 00                       M 	dc.b	0
0000DC68 00                       M 	even
0000DC68                          M 	.instr_end_420:
0000DC68                            	Console.WriteLine "%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC68 40E7                     M 	move.w	sr,-(sp)
0000DC6A                          M 	__fstring_generateargumentscode	"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A =00000001                M 	__pos:	set instr("%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC6A =00000000                M 	__stack:set	0
0000DC6A =00000000                M 	__sp:	set 0
0000DC6A                          M 	while	(__pos)
0000DC6A =00000011                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DC6A =00000012                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DC6A =00000011                M 	__midpos:	= __endpos
0000DC6A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	pushp	"move.b mSpindash.w,1(sp)"
0000DC6A                          M 	pushp	"subq.w	#2, sp"
0000DC6A =00000002                M 	__stack:	= __stack+2
0000DC6A =00000002                M 	__sp:	= __sp+2
0000DC6A =00000013                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC6A =00000022                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DC6A =00000023                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DC6A =00000022                M 	__midpos:	= __endpos
0000DC6A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	pushp	"move.b mContCtr.w,1(sp)"
0000DC6A                          M 	pushp	"subq.w	#2, sp"
0000DC6A =00000004                M 	__stack:	= __stack+2
0000DC6A =00000004                M 	__sp:	= __sp+2
0000DC6A =00000024                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC6A =00000034                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DC6A =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DC6A =00000034                M 	__midpos:	= __endpos
0000DC6A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC6A                          M 	pushp	"move.b mContLast.w,1(sp)"
0000DC6A                          M 	pushp	"subq.w	#2, sp"
0000DC6A =00000006                M 	__stack:	= __stack+2
0000DC6A =00000006                M 	__sp:	= __sp+2
0000DC6A =00000000                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC6A                          M 	rept	__stack
0000DC6A                          M 	popp	__command
0000DC6A 554F                     M 	subq.w	#2,sp
0000DC6C                          M 	popp	__command
0000DC6C 1F78 C4C3 0001           M 	move.b	mcontlast.w,1(sp)
0000DC72                          M 	popp	__command
0000DC72 554F                     M 	subq.w	#2,sp
0000DC74                          M 	popp	__command
0000DC74 1F78 C4C2 0001           M 	move.b	mcontctr.w,1(sp)
0000DC7A                          M 	popp	__command
0000DC7A 554F                     M 	subq.w	#2,sp
0000DC7C                          M 	popp	__command
0000DC7C 1F78 C4C1 0001           M 	move.b	mspindash.w,1(sp)
0000DC82 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DC86 45EF 0010                M 	lea	4*4(sp),a2
0000DC8A 43FA 0000                M 	lea	.str_423(pc),a1
0000DC8E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DC94 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DC98 5C4F                     M 	addq.w	#__sp,sp
0000DC9A 46DF                     M 	move.w	(sp)+,sr
0000DC9C 6000 0000                M 	bra.w	.instr_end_423
0000DCA0                          M 	.str_423:
0000DCA0                          M 	__fstring_generatedecodedstring	"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA0 =00000001                M 	__lpos:	set 1
0000DCA0 =00000001                M 	__pos:	set instr("%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DCA0                          M 	while	(__pos)
0000DCA0                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA0                          M 	dc.b	""
0000DCA0 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DCA0 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DCA0 =00000011                M 	__midpos:	= __endpos
0000DCA0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA0                          M 	__param:	substr ,,"hex"
0000DCA0 80                       M 	dc.b	hex
0000DCA1 =00000012                M 	__lpos:	set __endpos+1
0000DCA1 =00000013                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DCA1                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA1 20                       M 	dc.b	" "
0000DCA2 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DCA2 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DCA2 =00000022                M 	__midpos:	= __endpos
0000DCA2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA2                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA2                          M 	__param:	substr ,,"hex"
0000DCA2 80                       M 	dc.b	hex
0000DCA3 =00000023                M 	__lpos:	set __endpos+1
0000DCA3 =00000024                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DCA3                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA3 20                       M 	dc.b	" "
0000DCA4 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DCA4 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DCA4 =00000034                M 	__midpos:	= __endpos
0000DCA4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA4                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA4                          M 	__param:	substr ,,"hex"
0000DCA4 80                       M 	dc.b	hex
0000DCA5 =00000035                M 	__lpos:	set __endpos+1
0000DCA5 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DCA5                          M 	__substr:	substr __lpos,,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DCA5                          M 	dc.b	""
0000DCA5 00                       M 	dc.b	0
0000DCA6                          M 	even
0000DCA6                          M 	.instr_end_423:
0000DCA6                            	Console.Write	  "%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA6 40E7                     M 	move.w	sr,-(sp)
0000DCA8                          M 	__fstring_generateargumentscode	"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8 =00000001                M 	__pos:	set instr("%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCA8 =00000000                M 	__stack:set	0
0000DCA8 =00000000                M 	__sp:	set 0
0000DCA8                          M 	while	(__pos)
0000DCA8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCA8 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCA8 =00000008                M 	__midpos:	= __endpos
0000DCA8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCA8 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCA8 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCA8 =00000018                M 	__midpos:	= __endpos
0000DCA8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCA8 =0000002A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCA8 =0000002B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCA8 =0000002A                M 	__midpos:	= __endpos
0000DCA8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	pushp	"move.b mTempoMain.w,1(sp)"
0000DCA8                          M 	pushp	"subq.w	#2, sp"
0000DCA8 =00000002                M 	__stack:	= __stack+2
0000DCA8 =00000002                M 	__sp:	= __sp+2
0000DCA8 =0000002C                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCA8 =0000003E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCA8 =0000003F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCA8 =0000003E                M 	__midpos:	= __endpos
0000DCA8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA8                          M 	pushp	"move.b mTempoSpeed.w,1(sp)"
0000DCA8                          M 	pushp	"subq.w	#2, sp"
0000DCA8 =00000004                M 	__stack:	= __stack+2
0000DCA8 =00000004                M 	__sp:	= __sp+2
0000DCA8 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCA8                          M 	rept	__stack
0000DCA8                          M 	popp	__command
0000DCA8 554F                     M 	subq.w	#2,sp
0000DCAA                          M 	popp	__command
0000DCAA 1F78 C4B9 0001           M 	move.b	mtempospeed.w,1(sp)
0000DCB0                          M 	popp	__command
0000DCB0 554F                     M 	subq.w	#2,sp
0000DCB2                          M 	popp	__command
0000DCB2 1F78 C4B8 0001           M 	move.b	mtempomain.w,1(sp)
0000DCB8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DCBC 45EF 0010                M 	lea	4*4(sp),a2
0000DCC0 43FA 0000                M 	lea	.str_426(pc),a1
0000DCC4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DCCA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DCCE 584F                     M 	addq.w	#__sp,sp
0000DCD0 46DF                     M 	move.w	(sp)+,sr
0000DCD2 6000 0000                M 	bra.w	.instr_end_426
0000DCD6                          M 	.str_426:
0000DCD6                          M 	__fstring_generatedecodedstring	"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCD6 =00000001                M 	__lpos:	set 1
0000DCD6 =00000001                M 	__pos:	set instr("%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCD6                          M 	while	(__pos)
0000DCD6                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCD6                          M 	dc.b	""
0000DCD6 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCD6 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCD6 =00000008                M 	__midpos:	= __endpos
0000DCD6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCD6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCD6 EA                       M 	dc.b	fpal1
0000DCD7 =00000009                M 	__lpos:	set __endpos+1
0000DCD7 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCD7                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCD7 5465 6D70 6F3A 2020      M 	dc.b	"Tempo:  "
0000DCDF =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCDF =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCDF =00000018                M 	__midpos:	= __endpos
0000DCDF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCDF                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCDF EC                       M 	dc.b	fpal2
0000DCE0 =00000019                M 	__lpos:	set __endpos+1
0000DCE0 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCE0                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCE0                          M 	dc.b	""
0000DCE0 =0000002A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCE0 =0000002B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCE0 =0000002A                M 	__midpos:	= __endpos
0000DCE0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCE0                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCE0                          M 	__param:	substr ,,"hex"
0000DCE0 80                       M 	dc.b	hex
0000DCE1 =0000002B                M 	__lpos:	set __endpos+1
0000DCE1 =0000002C                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCE1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCE1 20                       M 	dc.b	" "
0000DCE2 =0000003E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCE2 =0000003F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCE2 =0000003E                M 	__midpos:	= __endpos
0000DCE2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCE2                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCE2                          M 	__param:	substr ,,"hex"
0000DCE2 80                       M 	dc.b	hex
0000DCE3 =0000003F                M 	__lpos:	set __endpos+1
0000DCE3 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCE3                          M 	__substr:	substr __lpos,,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCE3 20                       M 	dc.b	" "
0000DCE4 00                       M 	dc.b	0
0000DCE6 00                       M 	even
0000DCE6                          M 	.instr_end_426:
0000DCE6                            	Console.WriteLine "%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE6 40E7                     M 	move.w	sr,-(sp)
0000DCE8                          M 	__fstring_generateargumentscode	"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE8 =00000001                M 	__pos:	set instr("%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DCE8 =00000000                M 	__stack:set	0
0000DCE8 =00000000                M 	__sp:	set 0
0000DCE8                          M 	while	(__pos)
0000DCE8 =0000000E                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DCE8 =0000000F                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DCE8 =0000000E                M 	__midpos:	= __endpos
0000DCE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE8                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE8                          M 	pushp	"move.b mTempo.w,1(sp)"
0000DCE8                          M 	pushp	"subq.w	#2, sp"
0000DCE8 =00000002                M 	__stack:	= __stack+2
0000DCE8 =00000002                M 	__sp:	= __sp+2
0000DCE8 =00000010                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DCE8 =00000020                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DCE8 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DCE8 =00000020                M 	__midpos:	= __endpos
0000DCE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE8                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCE8                          M 	pushp	"move.b mTempoCur.w,1(sp)"
0000DCE8                          M 	pushp	"subq.w	#2, sp"
0000DCE8 =00000004                M 	__stack:	= __stack+2
0000DCE8 =00000004                M 	__sp:	= __sp+2
0000DCE8 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DCE8                          M 	rept	__stack
0000DCE8                          M 	popp	__command
0000DCE8 554F                     M 	subq.w	#2,sp
0000DCEA                          M 	popp	__command
0000DCEA 1F78 C4BB 0001           M 	move.b	mtempocur.w,1(sp)
0000DCF0                          M 	popp	__command
0000DCF0 554F                     M 	subq.w	#2,sp
0000DCF2                          M 	popp	__command
0000DCF2 1F78 C4BA 0001           M 	move.b	mtempo.w,1(sp)
0000DCF8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DCFC 45EF 0010                M 	lea	4*4(sp),a2
0000DD00 43FA 0000                M 	lea	.str_429(pc),a1
0000DD04 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DD0A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DD0E 584F                     M 	addq.w	#__sp,sp
0000DD10 46DF                     M 	move.w	(sp)+,sr
0000DD12 6000 0000                M 	bra.w	.instr_end_429
0000DD16                          M 	.str_429:
0000DD16                          M 	__fstring_generatedecodedstring	"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD16 =00000001                M 	__lpos:	set 1
0000DD16 =00000001                M 	__pos:	set instr("%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DD16                          M 	while	(__pos)
0000DD16                          M 	__substr:	substr __lpos,__pos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD16                          M 	dc.b	""
0000DD16 =0000000E                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DD16 =0000000F                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DD16 =0000000E                M 	__midpos:	= __endpos
0000DD16                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD16                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD16                          M 	__param:	substr ,,"hex"
0000DD16 80                       M 	dc.b	hex
0000DD17 =0000000F                M 	__lpos:	set __endpos+1
0000DD17 =00000010                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DD17                          M 	__substr:	substr __lpos,__pos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD17 20                       M 	dc.b	" "
0000DD18 =00000020                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DD18 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DD18 =00000020                M 	__midpos:	= __endpos
0000DD18                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD18                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD18                          M 	__param:	substr ,,"hex"
0000DD18 80                       M 	dc.b	hex
0000DD19 =00000021                M 	__lpos:	set __endpos+1
0000DD19 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DD19                          M 	__substr:	substr __lpos,,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DD19                          M 	dc.b	""
0000DD19 00                       M 	dc.b	0
0000DD1A                          M 	even
0000DD1A                          M 	.instr_end_429:
0000DD1A                            	Console.Write	  "%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1A 40E7                     M 	move.w	sr,-(sp)
0000DD1C                          M 	__fstring_generateargumentscode	"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C =00000001                M 	__pos:	set instr("%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD1C =00000000                M 	__stack:set	0
0000DD1C =00000000                M 	__sp:	set 0
0000DD1C                          M 	while	(__pos)
0000DD1C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD1C =00000010                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD1C =00000008                M 	__midpos:	= __endpos
0000DD1C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD1C =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD1C =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD1C =00000018                M 	__midpos:	= __endpos
0000DD1C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD1C =0000002C                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD1C =0000002D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD1C =0000002C                M 	__midpos:	= __endpos
0000DD1C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	pushp	"move.b mMasterVolFM.w,1(sp)"
0000DD1C                          M 	pushp	"subq.w	#2, sp"
0000DD1C =00000002                M 	__stack:	= __stack+2
0000DD1C =00000002                M 	__sp:	= __sp+2
0000DD1C =0000002E                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD1C =00000042                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD1C =00000043                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD1C =00000042                M 	__midpos:	= __endpos
0000DD1C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1C                          M 	pushp	"move.b mMasterVolDAC.w,1(sp)"
0000DD1C                          M 	pushp	"subq.w	#2, sp"
0000DD1C =00000004                M 	__stack:	= __stack+2
0000DD1C =00000004                M 	__sp:	= __sp+2
0000DD1C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD1C                          M 	rept	__stack
0000DD1C                          M 	popp	__command
0000DD1C 554F                     M 	subq.w	#2,sp
0000DD1E                          M 	popp	__command
0000DD1E 1F78 C4C0 0001           M 	move.b	mmastervoldac.w,1(sp)
0000DD24                          M 	popp	__command
0000DD24 554F                     M 	subq.w	#2,sp
0000DD26                          M 	popp	__command
0000DD26 1F78 C4B4 0001           M 	move.b	mmastervolfm.w,1(sp)
0000DD2C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DD30 45EF 0010                M 	lea	4*4(sp),a2
0000DD34 43FA 0000                M 	lea	.str_432(pc),a1
0000DD38 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DD3E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DD42 584F                     M 	addq.w	#__sp,sp
0000DD44 46DF                     M 	move.w	(sp)+,sr
0000DD46 6000 0000                M 	bra.w	.instr_end_432
0000DD4A                          M 	.str_432:
0000DD4A                          M 	__fstring_generatedecodedstring	"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD4A =00000001                M 	__lpos:	set 1
0000DD4A =00000001                M 	__pos:	set instr("%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD4A                          M 	while	(__pos)
0000DD4A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD4A                          M 	dc.b	""
0000DD4A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD4A =00000010                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD4A =00000008                M 	__midpos:	= __endpos
0000DD4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD4A EA                       M 	dc.b	fpal1
0000DD4B =00000009                M 	__lpos:	set __endpos+1
0000DD4B =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD4B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD4B 566F 6C75 6D65 3A20      M 	dc.b	"Volume: "
0000DD53 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD53 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD53 =00000018                M 	__midpos:	= __endpos
0000DD53                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD53                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD53 EC                       M 	dc.b	fpal2
0000DD54 =00000019                M 	__lpos:	set __endpos+1
0000DD54 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD54                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD54                          M 	dc.b	""
0000DD54 =0000002C                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD54 =0000002D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD54 =0000002C                M 	__midpos:	= __endpos
0000DD54                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD54                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD54                          M 	__param:	substr ,,"hex"
0000DD54 80                       M 	dc.b	hex
0000DD55 =0000002D                M 	__lpos:	set __endpos+1
0000DD55 =0000002E                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD55                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD55 20                       M 	dc.b	" "
0000DD56 =00000042                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD56 =00000043                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD56 =00000042                M 	__midpos:	= __endpos
0000DD56                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD56                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD56                          M 	__param:	substr ,,"hex"
0000DD56 80                       M 	dc.b	hex
0000DD57 =00000043                M 	__lpos:	set __endpos+1
0000DD57 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD57                          M 	__substr:	substr __lpos,,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD57 20                       M 	dc.b	" "
0000DD58 00                       M 	dc.b	0
0000DD5A 00                       M 	even
0000DD5A                          M 	.instr_end_432:
0000DD5A                            	Console.WriteLine "%<.b mMasterVolPSG.w>"
0000DD5A 40E7                     M 	move.w	sr,-(sp)
0000DD5C                          M 	__fstring_generateargumentscode	"%<.b mMasterVolPSG.w>"
0000DD5C =00000001                M 	__pos:	set instr("%<.b mMasterVolPSG.w>",'%<')
0000DD5C =00000000                M 	__stack:set	0
0000DD5C =00000000                M 	__sp:	set 0
0000DD5C                          M 	while	(__pos)
0000DD5C =00000015                M 	__endpos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'>')
0000DD5C =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mMasterVolPSG.w>",' ')
0000DD5C =00000015                M 	__midpos:	= __endpos
0000DD5C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000DD5C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mMasterVolPSG.w>"
0000DD5C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mMasterVolPSG.w>"
0000DD5C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000DD5C                          M 	pushp	"move.b mMasterVolPSG.w,1(sp)"
0000DD5C                          M 	pushp	"subq.w	#2, sp"
0000DD5C =00000002                M 	__stack:	= __stack+2
0000DD5C =00000002                M 	__sp:	= __sp+2
0000DD5C =00000000                M 	__pos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'%<')
0000DD5C                          M 	rept	__stack
0000DD5C                          M 	popp	__command
0000DD5C 554F                     M 	subq.w	#2,sp
0000DD5E                          M 	popp	__command
0000DD5E 1F78 C4BF 0001           M 	move.b	mmastervolpsg.w,1(sp)
0000DD64 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DD68 45EF 0010                M 	lea	4*4(sp),a2
0000DD6C 43FA 0000                M 	lea	.str_435(pc),a1
0000DD70 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DD76 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DD7A 544F                     M 	addq.w	#__sp,sp
0000DD7C 46DF                     M 	move.w	(sp)+,sr
0000DD7E 6000 0000                M 	bra.w	.instr_end_435
0000DD82                          M 	.str_435:
0000DD82                          M 	__fstring_generatedecodedstring	"%<.b mMasterVolPSG.w>"
0000DD82 =00000001                M 	__lpos:	set 1
0000DD82 =00000001                M 	__pos:	set instr("%<.b mMasterVolPSG.w>",'%<')
0000DD82                          M 	while	(__pos)
0000DD82                          M 	__substr:	substr __lpos,__pos-1,"%<.b mMasterVolPSG.w>"
0000DD82                          M 	dc.b	""
0000DD82 =00000015                M 	__endpos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'>')
0000DD82 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mMasterVolPSG.w>",' ')
0000DD82 =00000015                M 	__midpos:	= __endpos
0000DD82                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mMasterVolPSG.w>"
0000DD82                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000DD82                          M 	__param:	substr ,,"hex"
0000DD82 80                       M 	dc.b	hex
0000DD83 =00000016                M 	__lpos:	set __endpos+1
0000DD83 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'%<')
0000DD83                          M 	__substr:	substr __lpos,,"%<.b mMasterVolPSG.w>"
0000DD83                          M 	dc.b	""
0000DD83 00                       M 	dc.b	0
0000DD84                          M 	even
0000DD84                          M 	.instr_end_435:
0000DD84                            	Console.WriteLine "%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD84 40E7                     M 	move.w	sr,-(sp)
0000DD86                          M 	__fstring_generateargumentscode	"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86 =00000001                M 	__pos:	set instr("%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD86 =00000000                M 	__stack:set	0
0000DD86 =00000000                M 	__sp:	set 0
0000DD86                          M 	while	(__pos)
0000DD86 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD86 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD86 =00000008                M 	__midpos:	= __endpos
0000DD86                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD86 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD86 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD86 =00000018                M 	__midpos:	= __endpos
0000DD86                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD86 =00000034                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD86 =00000029                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD86                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86                          M 	pushp	"move.l mFadeAddr.w,-(sp)"
0000DD86 =00000001                M 	__stack:	= __stack+1
0000DD86 =00000004                M 	__sp:	= __sp+4
0000DD86 =00000035                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD86 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD86 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD86 =00000045                M 	__midpos:	= __endpos
0000DD86                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD86 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD86                          M 	rept	__stack
0000DD86                          M 	popp	__command
0000DD86 2F38 C4B4                M 	move.l	mfadeaddr.w,-(sp)
0000DD8A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DD8E 45EF 0010                M 	lea	4*4(sp),a2
0000DD92 43FA 0000                M 	lea	.str_438(pc),a1
0000DD96 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DD9C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DDA0 584F                     M 	addq.w	#__sp,sp
0000DDA2 46DF                     M 	move.w	(sp)+,sr
0000DDA4 6000 0000                M 	bra.w	.instr_end_438
0000DDA8                          M 	.str_438:
0000DDA8                          M 	__fstring_generatedecodedstring	"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDA8 =00000001                M 	__lpos:	set 1
0000DDA8 =00000001                M 	__pos:	set instr("%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DDA8                          M 	while	(__pos)
0000DDA8                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDA8                          M 	dc.b	""
0000DDA8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DDA8 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DDA8 =00000008                M 	__midpos:	= __endpos
0000DDA8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDA8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDA8 EA                       M 	dc.b	fpal1
0000DDA9 =00000009                M 	__lpos:	set __endpos+1
0000DDA9 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DDA9                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDA9 4661 6465 3A20 2020      M 	dc.b	"Fade:   "
0000DDB1 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DDB1 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DDB1 =00000018                M 	__midpos:	= __endpos
0000DDB1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDB1                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDB1 E8                       M 	dc.b	fpal0
0000DDB2 =00000019                M 	__lpos:	set __endpos+1
0000DDB2 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DDB2                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDB2                          M 	dc.b	""
0000DDB2 =00000034                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DDB2 =00000029                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DDB2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDB2                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDB2 BB                       M 	dc.b	sym|fsplit|3
0000DDB3 =00000035                M 	__lpos:	set __endpos+1
0000DDB3 =00000035                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DDB3                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDB3                          M 	dc.b	""
0000DDB3 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DDB3 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DDB3 =00000045                M 	__midpos:	= __endpos
0000DDB3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDB3                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDB3 ECC0                     M 	dc.b	fpal2,fsymdisp
0000DDB5 =00000046                M 	__lpos:	set __endpos+1
0000DDB5 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DDB5                          M 	__substr:	substr __lpos,,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DDB5                          M 	dc.b	""
0000DDB5 00                       M 	dc.b	0
0000DDB6                          M 	even
0000DDB6                          M 	.instr_end_438:
0000DDB6                            	Console.WriteLine "%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB6 40E7                     M 	move.w	sr,-(sp)
0000DDB8                          M 	__fstring_generateargumentscode	"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8 =00000001                M 	__pos:	set instr("%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDB8 =00000000                M 	__stack:set	0
0000DDB8 =00000000                M 	__sp:	set 0
0000DDB8                          M 	while	(__pos)
0000DDB8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDB8 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDB8 =00000008                M 	__midpos:	= __endpos
0000DDB8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDB8 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDB8 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDB8 =00000018                M 	__midpos:	= __endpos
0000DDB8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDB8 =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDB8 =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDB8 =00000026                M 	__midpos:	= __endpos
0000DDB8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	pushp	"move.b mQueue.w,1(sp)"
0000DDB8                          M 	pushp	"subq.w	#2, sp"
0000DDB8 =00000002                M 	__stack:	= __stack+2
0000DDB8 =00000002                M 	__sp:	= __sp+2
0000DDB8 =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDB8 =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDB8 =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDB8 =00000037                M 	__midpos:	= __endpos
0000DDB8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	pushp	"move.b mQueue+1.w,1(sp)"
0000DDB8                          M 	pushp	"subq.w	#2, sp"
0000DDB8 =00000004                M 	__stack:	= __stack+2
0000DDB8 =00000004                M 	__sp:	= __sp+2
0000DDB8 =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDB8 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDB8 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDB8 =00000048                M 	__midpos:	= __endpos
0000DDB8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB8                          M 	pushp	"move.b mQueue+2.w,1(sp)"
0000DDB8                          M 	pushp	"subq.w	#2, sp"
0000DDB8 =00000006                M 	__stack:	= __stack+2
0000DDB8 =00000006                M 	__sp:	= __sp+2
0000DDB8 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDB8                          M 	rept	__stack
0000DDB8                          M 	popp	__command
0000DDB8 554F                     M 	subq.w	#2,sp
0000DDBA                          M 	popp	__command
0000DDBA 1F78 C4BE 0001           M 	move.b	mqueue+2.w,1(sp)
0000DDC0                          M 	popp	__command
0000DDC0 554F                     M 	subq.w	#2,sp
0000DDC2                          M 	popp	__command
0000DDC2 1F78 C4BD 0001           M 	move.b	mqueue+1.w,1(sp)
0000DDC8                          M 	popp	__command
0000DDC8 554F                     M 	subq.w	#2,sp
0000DDCA                          M 	popp	__command
0000DDCA 1F78 C4BC 0001           M 	move.b	mqueue.w,1(sp)
0000DDD0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DDD4 45EF 0010                M 	lea	4*4(sp),a2
0000DDD8 43FA 0000                M 	lea	.str_441(pc),a1
0000DDDC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DDE2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DDE6 5C4F                     M 	addq.w	#__sp,sp
0000DDE8 46DF                     M 	move.w	(sp)+,sr
0000DDEA 6000 0000                M 	bra.w	.instr_end_441
0000DDEE                          M 	.str_441:
0000DDEE                          M 	__fstring_generatedecodedstring	"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDEE =00000001                M 	__lpos:	set 1
0000DDEE =00000001                M 	__pos:	set instr("%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDEE                          M 	while	(__pos)
0000DDEE                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDEE                          M 	dc.b	""
0000DDEE =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDEE =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDEE =00000008                M 	__midpos:	= __endpos
0000DDEE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDEE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDEE EA                       M 	dc.b	fpal1
0000DDEF =00000009                M 	__lpos:	set __endpos+1
0000DDEF =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDEF                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDEF 5175 6575 653A 2020      M 	dc.b	"Queue:  "
0000DDF7 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDF7 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDF7 =00000018                M 	__midpos:	= __endpos
0000DDF7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDF7                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDF7 EC                       M 	dc.b	fpal2
0000DDF8 =00000019                M 	__lpos:	set __endpos+1
0000DDF8 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDF8                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDF8                          M 	dc.b	""
0000DDF8 =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDF8 =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDF8 =00000026                M 	__midpos:	= __endpos
0000DDF8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDF8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDF8                          M 	__param:	substr ,,"hex"
0000DDF8 80                       M 	dc.b	hex
0000DDF9 =00000027                M 	__lpos:	set __endpos+1
0000DDF9 =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDF9                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDF9 20                       M 	dc.b	" "
0000DDFA =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDFA =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDFA =00000037                M 	__midpos:	= __endpos
0000DDFA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDFA                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDFA                          M 	__param:	substr ,,"hex"
0000DDFA 80                       M 	dc.b	hex
0000DDFB =00000038                M 	__lpos:	set __endpos+1
0000DDFB =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDFB                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDFB 20                       M 	dc.b	" "
0000DDFC =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDFC =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDFC =00000048                M 	__midpos:	= __endpos
0000DDFC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDFC                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDFC                          M 	__param:	substr ,,"hex"
0000DDFC 80                       M 	dc.b	hex
0000DDFD =00000049                M 	__lpos:	set __endpos+1
0000DDFD =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDFD                          M 	__substr:	substr __lpos,,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDFD                          M 	dc.b	""
0000DDFD 00                       M 	dc.b	0
0000DDFE                          M 	even
0000DDFE                          M 	.instr_end_441:
0000DDFE                            	Console.Write	  "%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDFE 40E7                     M 	move.w	sr,-(sp)
0000DE00                          M 	__fstring_generateargumentscode	"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00 =00000001                M 	__pos:	set instr("%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE00 =00000000                M 	__stack:set	0
0000DE00 =00000000                M 	__sp:	set 0
0000DE00                          M 	while	(__pos)
0000DE00 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE00 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE00 =00000008                M 	__midpos:	= __endpos
0000DE00                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE00 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE00 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE00 =00000018                M 	__midpos:	= __endpos
0000DE00                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE00 =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE00 =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE00 =00000025                M 	__midpos:	= __endpos
0000DE00                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	pushp	"move.b mComm.w,1(sp)"
0000DE00                          M 	pushp	"subq.w	#2, sp"
0000DE00 =00000002                M 	__stack:	= __stack+2
0000DE00 =00000002                M 	__sp:	= __sp+2
0000DE00 =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE00 =00000035                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE00 =00000036                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE00 =00000035                M 	__midpos:	= __endpos
0000DE00                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	pushp	"move.b mComm+1.w,1(sp)"
0000DE00                          M 	pushp	"subq.w	#2, sp"
0000DE00 =00000004                M 	__stack:	= __stack+2
0000DE00 =00000004                M 	__sp:	= __sp+2
0000DE00 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE00 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE00 =00000046                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE00 =00000045                M 	__midpos:	= __endpos
0000DE00                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE00                          M 	pushp	"move.b mComm+2.w,1(sp)"
0000DE00                          M 	pushp	"subq.w	#2, sp"
0000DE00 =00000006                M 	__stack:	= __stack+2
0000DE00 =00000006                M 	__sp:	= __sp+2
0000DE00 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE00                          M 	rept	__stack
0000DE00                          M 	popp	__command
0000DE00 554F                     M 	subq.w	#2,sp
0000DE02                          M 	popp	__command
0000DE02 1F78 C4AE 0001           M 	move.b	mcomm+2.w,1(sp)
0000DE08                          M 	popp	__command
0000DE08 554F                     M 	subq.w	#2,sp
0000DE0A                          M 	popp	__command
0000DE0A 1F78 C4AD 0001           M 	move.b	mcomm+1.w,1(sp)
0000DE10                          M 	popp	__command
0000DE10 554F                     M 	subq.w	#2,sp
0000DE12                          M 	popp	__command
0000DE12 1F78 C4AC 0001           M 	move.b	mcomm.w,1(sp)
0000DE18 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DE1C 45EF 0010                M 	lea	4*4(sp),a2
0000DE20 43FA 0000                M 	lea	.str_444(pc),a1
0000DE24 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DE2A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DE2E 5C4F                     M 	addq.w	#__sp,sp
0000DE30 46DF                     M 	move.w	(sp)+,sr
0000DE32 6000 0000                M 	bra.w	.instr_end_444
0000DE36                          M 	.str_444:
0000DE36                          M 	__fstring_generatedecodedstring	"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE36 =00000001                M 	__lpos:	set 1
0000DE36 =00000001                M 	__pos:	set instr("%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE36                          M 	while	(__pos)
0000DE36                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE36                          M 	dc.b	""
0000DE36 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE36 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE36 =00000008                M 	__midpos:	= __endpos
0000DE36                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE36                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE36 EA                       M 	dc.b	fpal1
0000DE37 =00000009                M 	__lpos:	set __endpos+1
0000DE37 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE37                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE37 436F 6D6D 3A20 2020      M 	dc.b	"Comm:   "
0000DE3F =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE3F =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE3F =00000018                M 	__midpos:	= __endpos
0000DE3F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE3F                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE3F EC                       M 	dc.b	fpal2
0000DE40 =00000019                M 	__lpos:	set __endpos+1
0000DE40 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE40                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE40                          M 	dc.b	""
0000DE40 =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE40 =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE40 =00000025                M 	__midpos:	= __endpos
0000DE40                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE40                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE40                          M 	__param:	substr ,,"hex"
0000DE40 80                       M 	dc.b	hex
0000DE41 =00000026                M 	__lpos:	set __endpos+1
0000DE41 =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE41                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE41 20                       M 	dc.b	" "
0000DE42 =00000035                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE42 =00000036                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE42 =00000035                M 	__midpos:	= __endpos
0000DE42                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE42                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE42                          M 	__param:	substr ,,"hex"
0000DE42 80                       M 	dc.b	hex
0000DE43 =00000036                M 	__lpos:	set __endpos+1
0000DE43 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE43                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE43 20                       M 	dc.b	" "
0000DE44 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE44 =00000046                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE44 =00000045                M 	__midpos:	= __endpos
0000DE44                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE44                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE44                          M 	__param:	substr ,,"hex"
0000DE44 80                       M 	dc.b	hex
0000DE45 =00000046                M 	__lpos:	set __endpos+1
0000DE45 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE45                          M 	__substr:	substr __lpos,,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE45 20                       M 	dc.b	" "
0000DE46 00                       M 	dc.b	0
0000DE48 00                       M 	even
0000DE48                          M 	.instr_end_444:
0000DE48                            	Console.Write	  "%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE48 40E7                     M 	move.w	sr,-(sp)
0000DE4A                          M 	__fstring_generateargumentscode	"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A =00000001                M 	__pos:	set instr("%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE4A =00000000                M 	__stack:set	0
0000DE4A =00000000                M 	__sp:	set 0
0000DE4A                          M 	while	(__pos)
0000DE4A =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE4A =00000010                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE4A =0000000F                M 	__midpos:	= __endpos
0000DE4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	pushp	"move.b mComm+3.w,1(sp)"
0000DE4A                          M 	pushp	"subq.w	#2, sp"
0000DE4A =00000002                M 	__stack:	= __stack+2
0000DE4A =00000002                M 	__sp:	= __sp+2
0000DE4A =00000011                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE4A =0000001F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE4A =00000020                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE4A =0000001F                M 	__midpos:	= __endpos
0000DE4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	pushp	"move.b mComm+4.w,1(sp)"
0000DE4A                          M 	pushp	"subq.w	#2, sp"
0000DE4A =00000004                M 	__stack:	= __stack+2
0000DE4A =00000004                M 	__sp:	= __sp+2
0000DE4A =00000021                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE4A =0000002F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE4A =00000030                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE4A =0000002F                M 	__midpos:	= __endpos
0000DE4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	pushp	"move.b mComm+5.w,1(sp)"
0000DE4A                          M 	pushp	"subq.w	#2, sp"
0000DE4A =00000006                M 	__stack:	= __stack+2
0000DE4A =00000006                M 	__sp:	= __sp+2
0000DE4A =00000031                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE4A =0000003F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE4A =00000040                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE4A =0000003F                M 	__midpos:	= __endpos
0000DE4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4A                          M 	pushp	"move.b mComm+6.w,1(sp)"
0000DE4A                          M 	pushp	"subq.w	#2, sp"
0000DE4A =00000008                M 	__stack:	= __stack+2
0000DE4A =00000008                M 	__sp:	= __sp+2
0000DE4A =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE4A                          M 	rept	__stack
0000DE4A                          M 	popp	__command
0000DE4A 554F                     M 	subq.w	#2,sp
0000DE4C                          M 	popp	__command
0000DE4C 1F78 C4B2 0001           M 	move.b	mcomm+6.w,1(sp)
0000DE52                          M 	popp	__command
0000DE52 554F                     M 	subq.w	#2,sp
0000DE54                          M 	popp	__command
0000DE54 1F78 C4B1 0001           M 	move.b	mcomm+5.w,1(sp)
0000DE5A                          M 	popp	__command
0000DE5A 554F                     M 	subq.w	#2,sp
0000DE5C                          M 	popp	__command
0000DE5C 1F78 C4B0 0001           M 	move.b	mcomm+4.w,1(sp)
0000DE62                          M 	popp	__command
0000DE62 554F                     M 	subq.w	#2,sp
0000DE64                          M 	popp	__command
0000DE64 1F78 C4AF 0001           M 	move.b	mcomm+3.w,1(sp)
0000DE6A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DE6E 45EF 0010                M 	lea	4*4(sp),a2
0000DE72 43FA 0000                M 	lea	.str_447(pc),a1
0000DE76 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DE7C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DE80 504F                     M 	addq.w	#__sp,sp
0000DE82 46DF                     M 	move.w	(sp)+,sr
0000DE84 6000 0000                M 	bra.w	.instr_end_447
0000DE88                          M 	.str_447:
0000DE88                          M 	__fstring_generatedecodedstring	"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE88 =00000001                M 	__lpos:	set 1
0000DE88 =00000001                M 	__pos:	set instr("%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE88                          M 	while	(__pos)
0000DE88                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE88                          M 	dc.b	""
0000DE88 =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE88 =00000010                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE88 =0000000F                M 	__midpos:	= __endpos
0000DE88                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE88                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE88                          M 	__param:	substr ,,"hex"
0000DE88 80                       M 	dc.b	hex
0000DE89 =00000010                M 	__lpos:	set __endpos+1
0000DE89 =00000011                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE89                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE89 20                       M 	dc.b	" "
0000DE8A =0000001F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE8A =00000020                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE8A =0000001F                M 	__midpos:	= __endpos
0000DE8A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE8A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE8A                          M 	__param:	substr ,,"hex"
0000DE8A 80                       M 	dc.b	hex
0000DE8B =00000020                M 	__lpos:	set __endpos+1
0000DE8B =00000021                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE8B                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE8B 20                       M 	dc.b	" "
0000DE8C =0000002F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE8C =00000030                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE8C =0000002F                M 	__midpos:	= __endpos
0000DE8C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE8C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE8C                          M 	__param:	substr ,,"hex"
0000DE8C 80                       M 	dc.b	hex
0000DE8D =00000030                M 	__lpos:	set __endpos+1
0000DE8D =00000031                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE8D                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE8D 20                       M 	dc.b	" "
0000DE8E =0000003F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE8E =00000040                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE8E =0000003F                M 	__midpos:	= __endpos
0000DE8E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE8E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE8E                          M 	__param:	substr ,,"hex"
0000DE8E 80                       M 	dc.b	hex
0000DE8F =00000040                M 	__lpos:	set __endpos+1
0000DE8F =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE8F                          M 	__substr:	substr __lpos,,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE8F 20                       M 	dc.b	" "
0000DE90 00                       M 	dc.b	0
0000DE92 00                       M 	even
0000DE92                          M 	.instr_end_447:
0000DE92                            	Console.WriteLine "%<.b mComm+7.w>"
0000DE92 40E7                     M 	move.w	sr,-(sp)
0000DE94                          M 	__fstring_generateargumentscode	"%<.b mComm+7.w>"
0000DE94 =00000001                M 	__pos:	set instr("%<.b mComm+7.w>",'%<')
0000DE94 =00000000                M 	__stack:set	0
0000DE94 =00000000                M 	__sp:	set 0
0000DE94                          M 	while	(__pos)
0000DE94 =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+7.w>",'>')
0000DE94 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mComm+7.w>",' ')
0000DE94 =0000000F                M 	__midpos:	= __endpos
0000DE94                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+7.w>"
0000DE94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+7.w>"
0000DE94                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+7.w>"
0000DE94                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+7.w>"
0000DE94                          M 	pushp	"move.b mComm+7.w,1(sp)"
0000DE94                          M 	pushp	"subq.w	#2, sp"
0000DE94 =00000002                M 	__stack:	= __stack+2
0000DE94 =00000002                M 	__sp:	= __sp+2
0000DE94 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+7.w>",'%<')
0000DE94                          M 	rept	__stack
0000DE94                          M 	popp	__command
0000DE94 554F                     M 	subq.w	#2,sp
0000DE96                          M 	popp	__command
0000DE96 1F78 C4B3 0001           M 	move.b	mcomm+7.w,1(sp)
0000DE9C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DEA0 45EF 0010                M 	lea	4*4(sp),a2
0000DEA4 43FA 0000                M 	lea	.str_450(pc),a1
0000DEA8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DEAE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DEB2 544F                     M 	addq.w	#__sp,sp
0000DEB4 46DF                     M 	move.w	(sp)+,sr
0000DEB6 6000 0000                M 	bra.w	.instr_end_450
0000DEBA                          M 	.str_450:
0000DEBA                          M 	__fstring_generatedecodedstring	"%<.b mComm+7.w>"
0000DEBA =00000001                M 	__lpos:	set 1
0000DEBA =00000001                M 	__pos:	set instr("%<.b mComm+7.w>",'%<')
0000DEBA                          M 	while	(__pos)
0000DEBA                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+7.w>"
0000DEBA                          M 	dc.b	""
0000DEBA =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+7.w>",'>')
0000DEBA =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mComm+7.w>",' ')
0000DEBA =0000000F                M 	__midpos:	= __endpos
0000DEBA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+7.w>"
0000DEBA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+7.w>"
0000DEBA                          M 	__param:	substr ,,"hex"
0000DEBA 80                       M 	dc.b	hex
0000DEBB =00000010                M 	__lpos:	set __endpos+1
0000DEBB =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+7.w>",'%<')
0000DEBB                          M 	__substr:	substr __lpos,,"%<.b mComm+7.w>"
0000DEBB                          M 	dc.b	""
0000DEBB 00                       M 	dc.b	0
0000DEBC                          M 	even
0000DEBC                          M 	.instr_end_450:
0000DEBC                            
0000DEBC                            .rts
0000DEBC 4E75                       	rts
0000DEBE                            ; ===========================================================================
0000DEBE                            ; ---------------------------------------------------------------------------
0000DEBE                            ; Invalid fade command handler
0000DEBE                            ; ---------------------------------------------------------------------------
0000DEBE                            
0000DEBE                            AMPS_Debug_FadeCmd	macro
0000DEBE                            	cmp.b	#fLast,d0	; check against max
0000DEBE                            	bhs.s	.fail		; if in range, branch
0000DEBE                            	cmp.b	#$80,d0		; check against min
0000DEBE                            	blo.s	.fail		; if too little, bra
0000DEBE                            	btst	#1,d0		; check if bit1 set
0000DEBE                            	bne.s	.fail		; if is, branch
0000DEBE                            	btst	#0,d0		; check if even
0000DEBE                            	beq.s	.ok		; if is, branch
0000DEBE                            .fail
0000DEBE                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DEBE                            		jsr	AMPS_DebugR_FadeCmd
0000DEBE                            	else
0000DEBE                            		bra.w	*
0000DEBE                            	endif
0000DEBE                            .ok
0000DEBE                                endm
0000DEBE                            
0000DEBE                            AMPS_DebugR_FadeCmd:
0000DEBE                            		RaiseError2 "Invalid Fade command: %<.b d0>", AMPS_Debug_Console_Main
0000DEBE 40E7                     M 	move.w	sr,-(sp)
0000DEC0                          M 	__fstring_generateargumentscode	"Invalid Fade command: %<.b d0>"
0000DEC0 =00000017                M 	__pos:	set instr("Invalid Fade command: %<.b d0>",'%<')
0000DEC0 =00000000                M 	__stack:set	0
0000DEC0 =00000000                M 	__sp:	set 0
0000DEC0                          M 	while	(__pos)
0000DEC0 =0000001E                M 	__endpos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'>')
0000DEC0 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid Fade command: %<.b d0>",' ')
0000DEC0 =0000001E                M 	__midpos:	= __endpos
0000DEC0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DEC0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid Fade command: %<.b d0>"
0000DEC0                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid Fade command: %<.b d0>"
0000DEC0                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DEC0                          M 	pushp	"move.b d0,1(sp)"
0000DEC0                          M 	pushp	"subq.w	#2, sp"
0000DEC0 =00000002                M 	__stack:	= __stack+2
0000DEC0 =00000002                M 	__sp:	= __sp+2
0000DEC0 =00000000                M 	__pos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'%<')
0000DEC0                          M 	rept	__stack
0000DEC0                          M 	popp	__command
0000DEC0 554F                     M 	subq.w	#2,sp
0000DEC2                          M 	popp	__command
0000DEC2 1F40 0001                M 	move.b	d0,1(sp)
0000DEC6 4EB9 0000 0000           M 	jsr	errorhandler
0000DECC                          M 	__fstring_generatedecodedstring	"Invalid Fade command: %<.b d0>"
0000DECC =00000001                M 	__lpos:	set 1
0000DECC =00000017                M 	__pos:	set instr("Invalid Fade command: %<.b d0>",'%<')
0000DECC                          M 	while	(__pos)
0000DECC                          M 	__substr:	substr __lpos,__pos-1,"Invalid Fade command: %<.b d0>"
0000DECC 496E 7661 6C69 6420 4661+M 	dc.b	"Invalid Fade command: "
0000DEE2 =0000001E                M 	__endpos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'>')
0000DEE2 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid Fade command: %<.b d0>",' ')
0000DEE2 =0000001E                M 	__midpos:	= __endpos
0000DEE2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid Fade command: %<.b d0>"
0000DEE2                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DEE2                          M 	__param:	substr ,,"hex"
0000DEE2 80                       M 	dc.b	hex
0000DEE3 =0000001F                M 	__lpos:	set __endpos+1
0000DEE3 =00000000                M 	__pos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'%<')
0000DEE3                          M 	__substr:	substr __lpos,,"Invalid Fade command: %<.b d0>"
0000DEE3                          M 	dc.b	""
0000DEE3 00                       M 	dc.b	0
0000DEE4 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DEE6 00                       M 	even
0000DEE6 4EFA FB76                M 	jmp	amps_debug_console_main
0000DEEA                          M 	even
0000DEEA                            ; ===========================================================================
0000DEEA                            ; ---------------------------------------------------------------------------
0000DEEA                            ; Invalid volume envelope handler
0000DEEA                            ; ---------------------------------------------------------------------------
0000DEEA                            
0000DEEA                            AMPS_Debug_VolEnvID	macro
0000DEEA                            	cmp.b	#(VolEnvs_End-VolEnvs)/4,d4	; check against max
0000DEEA                            	bls.s	.ok			; if in range, branch
0000DEEA                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DEEA                            		jsr	AMPS_DebugR_VolEnvID
0000DEEA                            	else
0000DEEA                            		bra.w	*
0000DEEA                            	endif
0000DEEA                            .ok
0000DEEA                                endm
0000DEEA                            
0000DEEA                            AMPS_DebugR_VolEnvID:
0000DEEA                            		RaiseError2 "Volume envelope ID out of range: %<.b d4>", AMPS_Debug_Console_Channel
0000DEEA 40E7                     M 	move.w	sr,-(sp)
0000DEEC                          M 	__fstring_generateargumentscode	"Volume envelope ID out of range: %<.b d4>"
0000DEEC =00000022                M 	__pos:	set instr("Volume envelope ID out of range: %<.b d4>",'%<')
0000DEEC =00000000                M 	__stack:set	0
0000DEEC =00000000                M 	__sp:	set 0
0000DEEC                          M 	while	(__pos)
0000DEEC =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'>')
0000DEEC =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope ID out of range: %<.b d4>",' ')
0000DEEC =00000029                M 	__midpos:	= __endpos
0000DEEC                          M 	__substr:	substr __pos+1+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DEEC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope ID out of range: %<.b d4>"
0000DEEC                          M 	__operand:	substr __pos+1+1,__midpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DEEC                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DEEC                          M 	pushp	"move.b d4,1(sp)"
0000DEEC                          M 	pushp	"subq.w	#2, sp"
0000DEEC =00000002                M 	__stack:	= __stack+2
0000DEEC =00000002                M 	__sp:	= __sp+2
0000DEEC =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'%<')
0000DEEC                          M 	rept	__stack
0000DEEC                          M 	popp	__command
0000DEEC 554F                     M 	subq.w	#2,sp
0000DEEE                          M 	popp	__command
0000DEEE 1F44 0001                M 	move.b	d4,1(sp)
0000DEF2 4EB9 0000 0000           M 	jsr	errorhandler
0000DEF8                          M 	__fstring_generatedecodedstring	"Volume envelope ID out of range: %<.b d4>"
0000DEF8 =00000001                M 	__lpos:	set 1
0000DEF8 =00000022                M 	__pos:	set instr("Volume envelope ID out of range: %<.b d4>",'%<')
0000DEF8                          M 	while	(__pos)
0000DEF8                          M 	__substr:	substr __lpos,__pos-1,"Volume envelope ID out of range: %<.b d4>"
0000DEF8 566F 6C75 6D65 2065 6E76+M 	dc.b	"Volume envelope ID out of range: "
0000DF19 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'>')
0000DF19 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope ID out of range: %<.b d4>",' ')
0000DF19 =00000029                M 	__midpos:	= __endpos
0000DF19                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope ID out of range: %<.b d4>"
0000DF19                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DF19                          M 	__param:	substr ,,"hex"
0000DF19 80                       M 	dc.b	hex
0000DF1A =0000002A                M 	__lpos:	set __endpos+1
0000DF1A =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'%<')
0000DF1A                          M 	__substr:	substr __lpos,,"Volume envelope ID out of range: %<.b d4>"
0000DF1A                          M 	dc.b	""
0000DF1A 00                       M 	dc.b	0
0000DF1B 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DF1C                          M 	even
0000DF1C 4EFA F39A                M 	jmp	amps_debug_console_channel
0000DF20                          M 	even
0000DF20                            ; ===========================================================================
0000DF20                            ; ---------------------------------------------------------------------------
0000DF20                            ; Invalid volume envelope command handler
0000DF20                            ; ---------------------------------------------------------------------------
0000DF20                            
0000DF20                            AMPS_Debug_VolEnvCmd	macro
0000DF20                            	cmp.b	#eLast,d0	; check against max
0000DF20                            	bhs.s	.fail		; if too much, bra
0000DF20                            	cmp.b	#$80,d0		; check against min
0000DF20                            	blo.s	.fail		; if too little, bra
0000DF20                            	btst	#0,d0		; check if even
0000DF20                            	beq.s	.ok		; if is, branch
0000DF20                            .fail
0000DF20                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF20                            		RaiseError2 "Volume envelope command invalid: %<.b d0>", AMPS_Debug_Console_Channel
0000DF20                            	else
0000DF20                            		bra.w	*
0000DF20                            	endif
0000DF20                            .ok
0000DF20                                endm
0000DF20                            ; ===========================================================================
0000DF20                            ; ---------------------------------------------------------------------------
0000DF20                            ; PSG note check
0000DF20                            ; ---------------------------------------------------------------------------
0000DF20                            
0000DF20                            AMPS_Debug_NotePSG	macro
0000DF20                            	cmp.b	#dFreqPSG_-dFreqPSG,d5; check against max
0000DF20                            	blo.s	.ok		; if too little, bra
0000DF20                            .fail
0000DF20                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF20                            		jsr	AMPS_DebugR_NotePSG
0000DF20                            	else
0000DF20                            		bra.w	*
0000DF20                            	endif
0000DF20                            .ok
0000DF20                                endm
0000DF20                            
0000DF20                            AMPS_DebugR_NotePSG:
0000DF20 E24D                       		lsr.w	#1,d5	; get real note
0000DF22                            		RaiseError2 "Invalid PSG note: %<.b d5>", AMPS_Debug_Console_Channel
0000DF22 40E7                     M 	move.w	sr,-(sp)
0000DF24                          M 	__fstring_generateargumentscode	"Invalid PSG note: %<.b d5>"
0000DF24 =00000013                M 	__pos:	set instr("Invalid PSG note: %<.b d5>",'%<')
0000DF24 =00000000                M 	__stack:set	0
0000DF24 =00000000                M 	__sp:	set 0
0000DF24                          M 	while	(__pos)
0000DF24 =0000001A                M 	__endpos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'>')
0000DF24 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid PSG note: %<.b d5>",' ')
0000DF24 =0000001A                M 	__midpos:	= __endpos
0000DF24                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DF24                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid PSG note: %<.b d5>"
0000DF24                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid PSG note: %<.b d5>"
0000DF24                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DF24                          M 	pushp	"move.b d5,1(sp)"
0000DF24                          M 	pushp	"subq.w	#2, sp"
0000DF24 =00000002                M 	__stack:	= __stack+2
0000DF24 =00000002                M 	__sp:	= __sp+2
0000DF24 =00000000                M 	__pos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'%<')
0000DF24                          M 	rept	__stack
0000DF24                          M 	popp	__command
0000DF24 554F                     M 	subq.w	#2,sp
0000DF26                          M 	popp	__command
0000DF26 1F45 0001                M 	move.b	d5,1(sp)
0000DF2A 4EB9 0000 0000           M 	jsr	errorhandler
0000DF30                          M 	__fstring_generatedecodedstring	"Invalid PSG note: %<.b d5>"
0000DF30 =00000001                M 	__lpos:	set 1
0000DF30 =00000013                M 	__pos:	set instr("Invalid PSG note: %<.b d5>",'%<')
0000DF30                          M 	while	(__pos)
0000DF30                          M 	__substr:	substr __lpos,__pos-1,"Invalid PSG note: %<.b d5>"
0000DF30 496E 7661 6C69 6420 5053+M 	dc.b	"Invalid PSG note: "
0000DF42 =0000001A                M 	__endpos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'>')
0000DF42 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid PSG note: %<.b d5>",' ')
0000DF42 =0000001A                M 	__midpos:	= __endpos
0000DF42                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid PSG note: %<.b d5>"
0000DF42                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DF42                          M 	__param:	substr ,,"hex"
0000DF42 80                       M 	dc.b	hex
0000DF43 =0000001B                M 	__lpos:	set __endpos+1
0000DF43 =00000000                M 	__pos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'%<')
0000DF43                          M 	__substr:	substr __lpos,,"Invalid PSG note: %<.b d5>"
0000DF43                          M 	dc.b	""
0000DF43 00                       M 	dc.b	0
0000DF44 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DF46 00                       M 	even
0000DF46 4EFA F370                M 	jmp	amps_debug_console_channel
0000DF4A                          M 	even
0000DF4A                            ; ===========================================================================
0000DF4A                            ; ---------------------------------------------------------------------------
0000DF4A                            ; FM note check
0000DF4A                            ; ---------------------------------------------------------------------------
0000DF4A                            
0000DF4A                            AMPS_Debug_NoteFM	macro
0000DF4A                            	cmp.b	#dFreqFM_-dFreqFM,d5; check against max
0000DF4A                            	blo.s	.ok		; if too little, bra
0000DF4A                            .fail
0000DF4A                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF4A                            		jsr	AMPS_DebugR_NoteFM
0000DF4A                            	else
0000DF4A                            		bra.w	*
0000DF4A                            	endif
0000DF4A                            .ok
0000DF4A                                endm
0000DF4A                            
0000DF4A                            AMPS_DebugR_NoteFM:
0000DF4A E24D                       		lsr.w	#1,d5	; get real note
0000DF4C                            		RaiseError2 "Invalid FM note: %<.b d5>", AMPS_Debug_Console_Channel
0000DF4C 40E7                     M 	move.w	sr,-(sp)
0000DF4E                          M 	__fstring_generateargumentscode	"Invalid FM note: %<.b d5>"
0000DF4E =00000012                M 	__pos:	set instr("Invalid FM note: %<.b d5>",'%<')
0000DF4E =00000000                M 	__stack:set	0
0000DF4E =00000000                M 	__sp:	set 0
0000DF4E                          M 	while	(__pos)
0000DF4E =00000019                M 	__endpos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'>')
0000DF4E =00000000                M 	__midpos:	set instr(__pos+5,"Invalid FM note: %<.b d5>",' ')
0000DF4E =00000019                M 	__midpos:	= __endpos
0000DF4E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DF4E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid FM note: %<.b d5>"
0000DF4E                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid FM note: %<.b d5>"
0000DF4E                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DF4E                          M 	pushp	"move.b d5,1(sp)"
0000DF4E                          M 	pushp	"subq.w	#2, sp"
0000DF4E =00000002                M 	__stack:	= __stack+2
0000DF4E =00000002                M 	__sp:	= __sp+2
0000DF4E =00000000                M 	__pos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'%<')
0000DF4E                          M 	rept	__stack
0000DF4E                          M 	popp	__command
0000DF4E 554F                     M 	subq.w	#2,sp
0000DF50                          M 	popp	__command
0000DF50 1F45 0001                M 	move.b	d5,1(sp)
0000DF54 4EB9 0000 0000           M 	jsr	errorhandler
0000DF5A                          M 	__fstring_generatedecodedstring	"Invalid FM note: %<.b d5>"
0000DF5A =00000001                M 	__lpos:	set 1
0000DF5A =00000012                M 	__pos:	set instr("Invalid FM note: %<.b d5>",'%<')
0000DF5A                          M 	while	(__pos)
0000DF5A                          M 	__substr:	substr __lpos,__pos-1,"Invalid FM note: %<.b d5>"
0000DF5A 496E 7661 6C69 6420 464D+M 	dc.b	"Invalid FM note: "
0000DF6B =00000019                M 	__endpos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'>')
0000DF6B =00000000                M 	__midpos:	set instr(__pos+5,"Invalid FM note: %<.b d5>",' ')
0000DF6B =00000019                M 	__midpos:	= __endpos
0000DF6B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid FM note: %<.b d5>"
0000DF6B                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DF6B                          M 	__param:	substr ,,"hex"
0000DF6B 80                       M 	dc.b	hex
0000DF6C =0000001A                M 	__lpos:	set __endpos+1
0000DF6C =00000000                M 	__pos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'%<')
0000DF6C                          M 	__substr:	substr __lpos,,"Invalid FM note: %<.b d5>"
0000DF6C                          M 	dc.b	""
0000DF6C 00                       M 	dc.b	0
0000DF6D 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DF6E                          M 	even
0000DF6E 4EFA F348                M 	jmp	amps_debug_console_channel
0000DF72                          M 	even
0000DF72                            ; ===========================================================================
0000DF72                            ; ---------------------------------------------------------------------------
0000DF72                            ; DAC frequency check
0000DF72                            ; ---------------------------------------------------------------------------
0000DF72                            
0000DF72                            AMPS_Debug_FreqDAC	macro
0000DF72                            	cmp.w	#MaxPitch,d6	; check if frequency is too large
0000DF72                            	bgt.s	.fail		; if so, branch
0000DF72                            	cmp.w	#-MaxPitch,d6	; check if frequency is too small
0000DF72                            	bge.s	.ok		; if not, branch
0000DF72                            .fail
0000DF72                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF72                            		jsr	AMPS_DebugR_FreqDAC
0000DF72                            	else
0000DF72                            		bra.w	*
0000DF72                            	endif
0000DF72                            .ok
0000DF72                                endm
0000DF72                            
0000DF72                            AMPS_DebugR_FreqDAC:
0000DF72                            		RaiseError "Out of range DAC frequency: %<.w d6>", AMPS_Debug_Console_Channel
0000DF72 487A FFFE                M 	pea	*(pc)
0000DF76                          M 	raiseerror2	"Out of range DAC frequency: %<.w d6>",amps_debug_console_channel
0000DF76 40E7                     M 	move.w	sr,-(sp)
0000DF78                          M 	__fstring_generateargumentscode	"Out of range DAC frequency: %<.w d6>"
0000DF78 =0000001D                M 	__pos:	set instr("Out of range DAC frequency: %<.w d6>",'%<')
0000DF78 =00000000                M 	__stack:set	0
0000DF78 =00000000                M 	__sp:	set 0
0000DF78                          M 	while	(__pos)
0000DF78 =00000024                M 	__endpos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'>')
0000DF78 =00000000                M 	__midpos:	set instr(__pos+5,"Out of range DAC frequency: %<.w d6>",' ')
0000DF78 =00000024                M 	__midpos:	= __endpos
0000DF78                          M 	__substr:	substr __pos+1+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000DF78                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Out of range DAC frequency: %<.w d6>"
0000DF78                          M 	__operand:	substr __pos+1+1,__midpos-1,"Out of range DAC frequency: %<.w d6>"
0000DF78                          M 	__param:	substr __midpos+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000DF78                          M 	pushp	"move.w d6,-(sp)"
0000DF78 =00000001                M 	__stack:	= __stack+1
0000DF78 =00000002                M 	__sp:	= __sp+2
0000DF78 =00000000                M 	__pos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'%<')
0000DF78                          M 	rept	__stack
0000DF78                          M 	popp	__command
0000DF78 3F06                     M 	move.w	d6,-(sp)
0000DF7A 4EB9 0000 0000           M 	jsr	errorhandler
0000DF80                          M 	__fstring_generatedecodedstring	"Out of range DAC frequency: %<.w d6>"
0000DF80 =00000001                M 	__lpos:	set 1
0000DF80 =0000001D                M 	__pos:	set instr("Out of range DAC frequency: %<.w d6>",'%<')
0000DF80                          M 	while	(__pos)
0000DF80                          M 	__substr:	substr __lpos,__pos-1,"Out of range DAC frequency: %<.w d6>"
0000DF80 4F75 7420 6F66 2072 616E+M 	dc.b	"Out of range DAC frequency: "
0000DF9C =00000024                M 	__endpos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'>')
0000DF9C =00000000                M 	__midpos:	set instr(__pos+5,"Out of range DAC frequency: %<.w d6>",' ')
0000DF9C =00000024                M 	__midpos:	= __endpos
0000DF9C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Out of range DAC frequency: %<.w d6>"
0000DF9C                          M 	__param:	substr __midpos+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000DF9C                          M 	__param:	substr ,,"hex"
0000DF9C 81                       M 	dc.b	hex|1
0000DF9D =00000025                M 	__lpos:	set __endpos+1
0000DF9D =00000000                M 	__pos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'%<')
0000DF9D                          M 	__substr:	substr __lpos,,"Out of range DAC frequency: %<.w d6>"
0000DF9D                          M 	dc.b	""
0000DF9D 00                       M 	dc.b	0
0000DF9E 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DFA0 00                       M 	even
0000DFA0 4EFA F316                M 	jmp	amps_debug_console_channel
0000DFA4                          M 	even
0000DFA4                            ; ===========================================================================
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            ; Invalid tracker command handlers
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            
0000DFA4                            AMPS_Debug_dcInvalid	macro
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		RaiseError "Invalid command detected!", AMPS_Debug_Console_Channel
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                                endm
0000DFA4                            ; ===========================================================================
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            ; PSG on sPan handler
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            
0000DFA4                            AMPS_Debug_dcPan	macro
0000DFA4                            	tst.b	cType(a5)	; check for PSG channel
0000DFA4                            	bpl.s	.ok		; if no, branch
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		RaiseError "sPan on a PSG channel!", AMPS_Debug_Console_Channel
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                            .ok
0000DFA4                                endm
0000DFA4                            ; ===========================================================================
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            ; Timeout command on SFX channel handler
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            
0000DFA4                            AMPS_Debug_dcTimeout	macro
0000DFA4                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DFA4                            	blo.s	.ok		; if no, branch
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		RaiseError "sNoteTimeOut on a SFX channel!", AMPS_Debug_Console_Channel
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                            .ok
0000DFA4                                endm
0000DFA4                            ; ===========================================================================
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            ; Call command handlers
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            
0000DFA4                            AMPS_Debug_dcCall1	macro
0000DFA4                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DFA4                            	blo.s	.ok1		; if no, branch
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		RaiseError "sCall on a SFX channel!", AMPS_Debug_Console_Channel
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                            .ok1
0000DFA4                                endm
0000DFA4                            
0000DFA4                            AMPS_Debug_dcCall2	macro
0000DFA4                            	cmp.b	#cNoteTimeCur,d0; check for invalid stack address
0000DFA4                            	bhi.s	.ok2		; if no, branch
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		RaiseError "sCall stack too deep!", AMPS_Debug_Console_Channel
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                            .ok2
0000DFA4                                endm
0000DFA4                            ; ===========================================================================
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            ; Loop command handler
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            
0000DFA4                            AMPS_Debug_dcLoop	macro
0000DFA4                            	cmp.b	#3,d0		; check for invalid call number
0000DFA4                            	bhi.s	.fail		; if is, branch
0000DFA4                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DFA4                            	blo.s	.nosfx		; if no, branch
0000DFA4                            	cmp.b	#1,d0		; check if cPrio
0000DFA4                            	beq.s	.fail		; if so, branch
0000DFA4                            .nosfx
0000DFA4                            	cmp.b	#$C0,cType(a5)	; check if PSG3 or PSG4
0000DFA4                            	blo.s	AMPS_Debug_dcLoop_ok; if no, branch
0000DFA4                            	cmp.b	#2,d0		; check if cStatPSG4
0000DFA4                            	bne.s	AMPS_Debug_dcLoop_ok; if no, branch
0000DFA4                            .fail
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		RaiseError "sLoop ID is invalid!", AMPS_Debug_Console_Channel
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                            AMPS_Debug_dcLoop_ok
0000DFA4                                endm
0000DFA4                            ; ===========================================================================
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            ; Return command handlers
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            
0000DFA4                            AMPS_Debug_dcReturn1	macro
0000DFA4                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DFA4                            	blo.s	.ok1		; if no, branch
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		RaiseError "sRet on a SFX channel!", AMPS_Debug_Console_Channel
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                            .ok1
0000DFA4                                endm
0000DFA4                            
0000DFA4                            AMPS_Debug_dcReturn2	macro
0000DFA4                            	cmp.b	#cSize,d0	; check for invalid stack address
0000DFA4                            	bls.s	.ok2		; if no, branch
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		RaiseError "sRet stack too shallow!", AMPS_Debug_Console_Channel
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                            .ok2
0000DFA4                                endm
0000DFA4                            ; ===========================================================================
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            ; Update FM voice handler
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            
0000DFA4                            AMPS_Debug_UpdVoiceFM	macro
0000DFA4                            	cmp.b	#'N',(a1)+	; check if this is valid voice
0000DFA4                            	bne.s	.fail		; if not, branch
0000DFA4                            	cmp.w	#'AT',(a1)+	; check if this is valid voice
0000DFA4                            	beq.s	.ok		; if is, branch
0000DFA4                            .fail
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		RaiseError "FM voice Update invalid voice: %<.b cVoice(a5)>", AMPS_Debug_Console_Channel
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                            .ok
0000DFA4                                endm
0000DFA4                            ; ===========================================================================
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            ; Update FM Volume handler
0000DFA4                            ; ---------------------------------------------------------------------------
0000DFA4                            
0000DFA4                            AMPS_Debug_UpdVolFM	macro
0000DFA4                            	cmp.b	#'N',(a1)+	; check if this is valid voice
0000DFA4                            	bne.s	.fail		; if not, branch
0000DFA4                            	cmp.w	#'AT',(a1)+	; check if this is valid voice
0000DFA4                            	beq.s	.ok		; if is, branch
0000DFA4                            .fail
0000DFA4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA4                            		jsr	AMPS_DebugR_UpdVolFM
0000DFA4                            	else
0000DFA4                            		bra.w	*
0000DFA4                            	endif
0000DFA4                            .ok
0000DFA4                                endm
0000DFA4                            
0000DFA4                            AMPS_DebugR_UpdVolFM:
0000DFA4                            	RaiseError2 "FM Volume Update invalid voice: %<.b cVoice(a5)>", AMPS_Debug_Console_Channel
0000DFA4 40E7                     M 	move.w	sr,-(sp)
0000DFA6                          M 	__fstring_generateargumentscode	"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFA6 =00000021                M 	__pos:	set instr("FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DFA6 =00000000                M 	__stack:set	0
0000DFA6 =00000000                M 	__sp:	set 0
0000DFA6                          M 	while	(__pos)
0000DFA6 =00000030                M 	__endpos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'>')
0000DFA6 =00000000                M 	__midpos:	set instr(__pos+5,"FM Volume Update invalid voice: %<.b cVoice(a5)>",' ')
0000DFA6 =00000030                M 	__midpos:	= __endpos
0000DFA6                          M 	__substr:	substr __pos+1+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFA6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFA6                          M 	__operand:	substr __pos+1+1,__midpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFA6                          M 	__param:	substr __midpos+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFA6                          M 	pushp	"move.b cVoice(a5),1(sp)"
0000DFA6                          M 	pushp	"subq.w	#2, sp"
0000DFA6 =00000002                M 	__stack:	= __stack+2
0000DFA6 =00000002                M 	__sp:	= __sp+2
0000DFA6 =00000000                M 	__pos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DFA6                          M 	rept	__stack
0000DFA6                          M 	popp	__command
0000DFA6 554F                     M 	subq.w	#2,sp
0000DFA8                          M 	popp	__command
0000DFA8 1F6D 000B 0001           M 	move.b	cvoice(a5),1(sp)
0000DFAE 4EB9 0000 0000           M 	jsr	errorhandler
0000DFB4                          M 	__fstring_generatedecodedstring	"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFB4 =00000001                M 	__lpos:	set 1
0000DFB4 =00000021                M 	__pos:	set instr("FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DFB4                          M 	while	(__pos)
0000DFB4                          M 	__substr:	substr __lpos,__pos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFB4 464D 2056 6F6C 756D 6520+M 	dc.b	"FM Volume Update invalid voice: "
0000DFD4 =00000030                M 	__endpos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'>')
0000DFD4 =00000000                M 	__midpos:	set instr(__pos+5,"FM Volume Update invalid voice: %<.b cVoice(a5)>",' ')
0000DFD4 =00000030                M 	__midpos:	= __endpos
0000DFD4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFD4                          M 	__param:	substr __midpos+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFD4                          M 	__param:	substr ,,"hex"
0000DFD4 80                       M 	dc.b	hex
0000DFD5 =00000031                M 	__lpos:	set __endpos+1
0000DFD5 =00000000                M 	__pos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DFD5                          M 	__substr:	substr __lpos,,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DFD5                          M 	dc.b	""
0000DFD5 00                       M 	dc.b	0
0000DFD6 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DFD8 00                       M 	even
0000DFD8 4EFA F2DE                M 	jmp	amps_debug_console_channel
0000DFDC                          M 	even
0000DFDC                            ; ===========================================================================
0000DFDC                            ; ---------------------------------------------------------------------------
0000DFDC                            ; Invalid cue handler
0000DFDC                            ; ---------------------------------------------------------------------------
0000DFDC                            
0000DFDC                            AMPS_Debug_CuePtr	macro id
0000DFDC                            	cmp.l	#$A00000+YM_Buffer1,a0	; check against min
0000DFDC                            	blo.s	.fail\@			; if not in range, branch
0000DFDC                            	cmp.l	#$A00000+YM_Buffer2+$400,a0; check against max
0000DFDC                            	blo.s	.ok\@			; if in range, branch
0000DFDC                            .fail\@
0000DFDC                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFDC                            		jsr	AMPS_Debug_CuePtr\id
0000DFDC                            	else
0000DFDC                            		bra.w	*
0000DFDC                            	endif
0000DFDC                            .ok\@
0000DFDC                                endm
0000DFDC                            
0000DFDC                            AMPS_Debug_CuePtr1:
0000DFDC                            		RaiseError2 "CUE invalid at WriteYM_Pt1: %<.l a0>", AMPS_Debug_Console_Channel
0000DFDC 40E7                     M 	move.w	sr,-(sp)
0000DFDE                          M 	__fstring_generateargumentscode	"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFDE =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DFDE =00000000                M 	__stack:set	0
0000DFDE =00000000                M 	__sp:	set 0
0000DFDE                          M 	while	(__pos)
0000DFDE =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'>')
0000DFDE =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt1: %<.l a0>",' ')
0000DFDE =00000024                M 	__midpos:	= __endpos
0000DFDE                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFDE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFDE                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFDE                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFDE                          M 	pushp	"move.l a0,-(sp)"
0000DFDE =00000001                M 	__stack:	= __stack+1
0000DFDE =00000004                M 	__sp:	= __sp+4
0000DFDE =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DFDE                          M 	rept	__stack
0000DFDE                          M 	popp	__command
0000DFDE 2F08                     M 	move.l	a0,-(sp)
0000DFE0 4EB9 0000 0000           M 	jsr	errorhandler
0000DFE6                          M 	__fstring_generatedecodedstring	"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFE6 =00000001                M 	__lpos:	set 1
0000DFE6 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DFE6                          M 	while	(__pos)
0000DFE6                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFE6 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at WriteYM_Pt1: "
0000E002 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'>')
0000E002 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt1: %<.l a0>",' ')
0000E002 =00000024                M 	__midpos:	= __endpos
0000E002                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E002                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E002                          M 	__param:	substr ,,"hex"
0000E002 83                       M 	dc.b	hex|3
0000E003 =00000025                M 	__lpos:	set __endpos+1
0000E003 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000E003                          M 	__substr:	substr __lpos,,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000E003                          M 	dc.b	""
0000E003 00                       M 	dc.b	0
0000E004 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E006 00                       M 	even
0000E006 4EFA F2B0                M 	jmp	amps_debug_console_channel
0000E00A                          M 	even
0000E00A                            AMPS_Debug_CuePtr2:
0000E00A                            		RaiseError2 "CUE invalid at WriteYM_Pt2: %<.l a0>", AMPS_Debug_Console_Channel
0000E00A 40E7                     M 	move.w	sr,-(sp)
0000E00C                          M 	__fstring_generateargumentscode	"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E00C =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000E00C =00000000                M 	__stack:set	0
0000E00C =00000000                M 	__sp:	set 0
0000E00C                          M 	while	(__pos)
0000E00C =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'>')
0000E00C =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt2: %<.l a0>",' ')
0000E00C =00000024                M 	__midpos:	= __endpos
0000E00C                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E00C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E00C                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E00C                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E00C                          M 	pushp	"move.l a0,-(sp)"
0000E00C =00000001                M 	__stack:	= __stack+1
0000E00C =00000004                M 	__sp:	= __sp+4
0000E00C =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000E00C                          M 	rept	__stack
0000E00C                          M 	popp	__command
0000E00C 2F08                     M 	move.l	a0,-(sp)
0000E00E 4EB9 0000 0000           M 	jsr	errorhandler
0000E014                          M 	__fstring_generatedecodedstring	"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E014 =00000001                M 	__lpos:	set 1
0000E014 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000E014                          M 	while	(__pos)
0000E014                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E014 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at WriteYM_Pt2: "
0000E030 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'>')
0000E030 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt2: %<.l a0>",' ')
0000E030 =00000024                M 	__midpos:	= __endpos
0000E030                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E030                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E030                          M 	__param:	substr ,,"hex"
0000E030 83                       M 	dc.b	hex|3
0000E031 =00000025                M 	__lpos:	set __endpos+1
0000E031 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000E031                          M 	__substr:	substr __lpos,,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000E031                          M 	dc.b	""
0000E031 00                       M 	dc.b	0
0000E032 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E034 00                       M 	even
0000E034 4EFA F282                M 	jmp	amps_debug_console_channel
0000E038                          M 	even
0000E038                            AMPS_Debug_CuePtr0:
0000E038                            		RaiseError2 "CUE invalid at dUpdateVoiceFM: %<.l a0>", AMPS_Debug_Console_Channel
0000E038 40E7                     M 	move.w	sr,-(sp)
0000E03A                          M 	__fstring_generateargumentscode	"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E03A =00000020                M 	__pos:	set instr("CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E03A =00000000                M 	__stack:set	0
0000E03A =00000000                M 	__sp:	set 0
0000E03A                          M 	while	(__pos)
0000E03A =00000027                M 	__endpos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'>')
0000E03A =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dUpdateVoiceFM: %<.l a0>",' ')
0000E03A =00000027                M 	__midpos:	= __endpos
0000E03A                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E03A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E03A                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E03A                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E03A                          M 	pushp	"move.l a0,-(sp)"
0000E03A =00000001                M 	__stack:	= __stack+1
0000E03A =00000004                M 	__sp:	= __sp+4
0000E03A =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E03A                          M 	rept	__stack
0000E03A                          M 	popp	__command
0000E03A 2F08                     M 	move.l	a0,-(sp)
0000E03C 4EB9 0000 0000           M 	jsr	errorhandler
0000E042                          M 	__fstring_generatedecodedstring	"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E042 =00000001                M 	__lpos:	set 1
0000E042 =00000020                M 	__pos:	set instr("CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E042                          M 	while	(__pos)
0000E042                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E042 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at dUpdateVoiceFM: "
0000E061 =00000027                M 	__endpos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'>')
0000E061 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dUpdateVoiceFM: %<.l a0>",' ')
0000E061 =00000027                M 	__midpos:	= __endpos
0000E061                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E061                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E061                          M 	__param:	substr ,,"hex"
0000E061 83                       M 	dc.b	hex|3
0000E062 =00000028                M 	__lpos:	set __endpos+1
0000E062 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E062                          M 	__substr:	substr __lpos,,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E062                          M 	dc.b	""
0000E062 00                       M 	dc.b	0
0000E063 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E064                          M 	even
0000E064 4EFA F252                M 	jmp	amps_debug_console_channel
0000E068                          M 	even
0000E068                            AMPS_Debug_CuePtr3:
0000E068                            		RaiseError2 "CUE invalid at dAMPSend: %<.l a0>", AMPS_Debug_Console_Channel
0000E068 40E7                     M 	move.w	sr,-(sp)
0000E06A                          M 	__fstring_generateargumentscode	"CUE invalid at dAMPSend: %<.l a0>"
0000E06A =0000001A                M 	__pos:	set instr("CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E06A =00000000                M 	__stack:set	0
0000E06A =00000000                M 	__sp:	set 0
0000E06A                          M 	while	(__pos)
0000E06A =00000021                M 	__endpos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'>')
0000E06A =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dAMPSend: %<.l a0>",' ')
0000E06A =00000021                M 	__midpos:	= __endpos
0000E06A                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E06A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dAMPSend: %<.l a0>"
0000E06A                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E06A                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E06A                          M 	pushp	"move.l a0,-(sp)"
0000E06A =00000001                M 	__stack:	= __stack+1
0000E06A =00000004                M 	__sp:	= __sp+4
0000E06A =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E06A                          M 	rept	__stack
0000E06A                          M 	popp	__command
0000E06A 2F08                     M 	move.l	a0,-(sp)
0000E06C 4EB9 0000 0000           M 	jsr	errorhandler
0000E072                          M 	__fstring_generatedecodedstring	"CUE invalid at dAMPSend: %<.l a0>"
0000E072 =00000001                M 	__lpos:	set 1
0000E072 =0000001A                M 	__pos:	set instr("CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E072                          M 	while	(__pos)
0000E072                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E072 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at dAMPSend: "
0000E08B =00000021                M 	__endpos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'>')
0000E08B =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dAMPSend: %<.l a0>",' ')
0000E08B =00000021                M 	__midpos:	= __endpos
0000E08B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dAMPSend: %<.l a0>"
0000E08B                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E08B                          M 	__param:	substr ,,"hex"
0000E08B 83                       M 	dc.b	hex|3
0000E08C =00000022                M 	__lpos:	set __endpos+1
0000E08C =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E08C                          M 	__substr:	substr __lpos,,"CUE invalid at dAMPSend: %<.l a0>"
0000E08C                          M 	dc.b	""
0000E08C 00                       M 	dc.b	0
0000E08D 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E08E                          M 	even
0000E08E 4EFA F228                M 	jmp	amps_debug_console_channel
0000E092                          M 	even
0000E092                            ; ===========================================================================
0000E092                            ; ---------------------------------------------------------------------------
0000E092                            ; Play Command handler
0000E092                            ; ---------------------------------------------------------------------------
0000E092                            
0000E092                            AMPS_Debug_PlayCmd	macro
0000E092                            	cmp.b	#(dSoundCommands_End-dSoundCommands)/4,d7; check if this is valid command
0000E092                            	bls.s	.ok		; if is, branch
0000E092                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E092                            		RaiseError "Invalid command in queue: %<.b d7>", AMPS_Debug_Console_Channel
0000E092                            	else
0000E092                            		bra.w	*
0000E092                            	endif
0000E092                            .ok
0000E092                                endm
0000E092                            ; ===========================================================================
0000E092                            ; ---------------------------------------------------------------------------
0000E092                            ; Tracker address handlers
0000E092                            ; ---------------------------------------------------------------------------
0000E092                            
0000E092                            AMPS_Debug_PlayTrackMus	macro
0000E092                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E092                            	blo.s	.fail\@		; if no, branch
0000E092                            	cmp.l	#musend,d0	; check if this is valid tracker
0000E092                            	blo.s	.ok\@		; if is, branch
0000E092                            .fail\@
0000E092                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E092                            		lsr.w	#2,d7	; get actual ID
0000E092                            		RaiseError "Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Main
0000E092                            	else
0000E092                            		bra.w	*
0000E092                            	endif
0000E092                            .ok\@
0000E092                                endm
0000E092                            
0000E092                            AMPS_Debug_PlayTrackMus2	macro ch
0000E092                            	and.l	#$FFFFFF,d0	; remove high byte
0000E092                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E092                            	blo.s	.fail\@		; if no, branch
0000E092                            	cmp.l	#dacaddr,d0	; check if this is valid tracker
0000E092                            	blo.s	.ok\@		; if is, branch
0000E092                            .fail\@
0000E092                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E092                            		RaiseError "Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>", AMPS_Debug_Console_Main
0000E092                            	else
0000E092                            		bra.w	*
0000E092                            	endif
0000E092                            .ok\@
0000E092                                endm
0000E092                            
0000E092                            AMPS_Debug_PlayTrackSFX	macro
0000E092                            	cmp.l	#sfxaddr,d0	; check if this is valid tracker
0000E092                            	blo.s	.fail\@		; if no, branch
0000E092                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E092                            	blo.s	.ok\@		; if is, branch
0000E092                            .fail\@
0000E092                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E092                            		RaiseError "Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Main
0000E092                            	else
0000E092                            		bra.w	*
0000E092                            	endif
0000E092                            .ok\@
0000E092                                endm
0000E092                            
0000E092                            AMPS_Debug_PlayTrackSFX2	macro
0000E092                            	cmp.l	#sfxaddr,d0	; check if this is valid tracker
0000E092                            	blo.s	.fail\@		; if no, branch
0000E092                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E092                            	blo.s	.ok\@		; if is, branch
0000E092                            .fail\@
0000E092                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E092                            		RaiseError "Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>", AMPS_Debug_Console_Main
0000E092                            	else
0000E092                            		bra.w	*
0000E092                            	endif
0000E092                            .ok\@
0000E092                                endm
0000E092                            
0000E092                            AMPS_Debug_TrackUpd	macro
0000E092                            	move.l	a4,d1		; copy to d1
0000E092                            	and.l	#$FFFFFF,d1	; remove high byte
0000E092                            	cmp.l	#sfxaddr,d1	; check if this is valid tracker
0000E092                            	blo.s	.fail2		; if no, branch
0000E092                            	cmp.l	#dacaddr,d1	; check if this is valid tracker
0000E092                            	blo.s	.data		; if is, branch
0000E092                            .fail2
0000E092                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E092                            		RaiseError "Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Channel
0000E092                            	else
0000E092                            		bra.w	*
0000E092                            	endif
0000E092                                endm
0000E092                            ; ===========================================================================
0000E092                            ; ---------------------------------------------------------------------------
0000E092                            ; Tracker debugger handler and console code
0000E092                            ; ---------------------------------------------------------------------------
0000E092                            
0000E092                            AMPS_Debug_ChkTracker	macro
0000E092                            .fail
0000E092                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E092                            		jsr	AMPS_DebugR_ChkTracker
0000E092                            	else
0000E092                            		bra.w	*
0000E092                            	endif
0000E092                                endm
0000E092                            
0000E092                            AMPS_DebugR_ChkTracker:
0000E092 4EBA 0000                  		jsr	AMPS_Debug_CalcMax(pc)
0000E096 4847                       		swap	d7			; swap d7 words
0000E098                            
0000E098                            AMPS_DebugR_ChkTracker_loop
0000E098 23C7 00FF 0000             		move.l	d7,$FF0000		; save stuff in RAM
0000E09E                            		Console.Run AMPS_DebugR_ChkTracker2, "NAT"
0000E09E 4EB9 0000 0000           M 	jsr	errorhandler.__extern__console_only
0000E0A4 4EB9 0000 0000           M 	jsr	amps_debugr_chktracker2
0000E0AA 2E39 00FF 0000             		move.l	$FF0000,d7		; get stuff back
0000E0B0                            
0000E0B0                            AMPS_DebugR_ChkTracker_nodraw
0000E0B0 7CFF                       		moveq	#-1,d6
0000E0B2 51CE FFFE                  		dbf	d6,*			; delay a lot
0000E0B6                            
0000E0B6                            	; implement reading control data
0000E0B6 43F9 00A1 0003             		lea	$A10003,a1
0000E0BC 12BC 0000                  		move.b	#0,(a1)			; set TH low
0000E0C0 8080                       		or.l	d0,d0			; delay
0000E0C2 12BC 0040                  		move.b	#$40,(a1)		; set TH high
0000E0C6 8080                       		or.l	d0,d0			; delay
0000E0C8 1011                       		move.b	(a1),d0			; get dpad stat
0000E0CA                            
0000E0CA 3A07                       		move.w	d7,d5			; copy to d5
0000E0CC 0800 0000                  		btst	#0,d0			; check if up held
0000E0D0 6600                       		bne.s	AMPS_Debug_Writekd			; if not ,branch
0000E0D2                            
0000E0D2 5347                       		subq.w	#1,d7			; move up
0000E0D4 6A00                       		bpl.s	AMPS_Debug_Writekd			; if positive, branch
0000E0D6 4247                       		clr.w	d7			; else force to 0
0000E0D8                            
0000E0D8                            AMPS_Debug_Writekd
0000E0D8 0800 0001                  		btst	#1,d0			; check if down held
0000E0DC 6600                       		bne.s	AMPS_Debug_Writekdraw			; if not ,branch
0000E0DE                            
0000E0DE 4847                       		swap	d7
0000E0E0 3C07                       		move.w	d7,d6			; copy high word to d6
0000E0E2 4847                       		swap	d7
0000E0E4                            
0000E0E4 BE46                       		cmp.w	d6,d7			; check if we can move up
0000E0E6 6C00                       		bge.s	AMPS_Debug_Writekdraw			; if not, branch
0000E0E8 5247                       		addq.w	#1,d7			; move down
0000E0EA                            
0000E0EA                            AMPS_Debug_Writekdraw
0000E0EA BA47                       		cmp.w	d7,d5			; check if we need to redraw
0000E0EC 67C2                       		beq.s	AMPS_DebugR_ChkTracker_nodraw; if not, branch
0000E0EE 6000 FFA8                  		bra.w	AMPS_DebugR_ChkTracker_loop
0000E0F2                            
0000E0F2                            AMPS_Debug_CalcMax:
0000E0F2 7C1C                       		moveq	#28,d6	; max lines count
0000E0F4 7E09                       		moveq	#10-1,d7	; run for 10 chs
0000E0F6 7A2C                       		moveq	#cSize,d5	; prepare size
0000E0F8 4BF8 C650                  		lea	mPSG3.w,a5	; start at PSG3
0000E0FC                            
0000E0FC                            AMPS_Debug_Writehkloop
0000E0FC 4A46                       		tst.w	d6		; check if we have no lines left
0000E0FE                            	;	ble.s	.rts		; if so, we found it
0000E0FE 5746                       		subq.w	#3,d6		; we need at least 3 lines
0000E100 6B00                       		bmi.s	.add		; if not enough lines, branch
0000E102                            
0000E102 320D                       		move.w	a5,d1		; copy ch to d1
0000E104 0641 002C                  		add.w	#cSize,d1	; go to end of it
0000E108                            
0000E108 7000                       		moveq	#0,d0
0000E10A 102D 001E                  		move.b	cStack(a5),d0	; get stack to d0
0000E10E 4DF5 0000                  		lea	(a5,d0.w),a6	; and get first element to a6
0000E112                            
0000E112                            .stack
0000E112 B24E                       		cmp.w	a6,d1		; check if stack is dry now
0000E114 6200                       		bhi.s	.inc		; if not, branch
0000E116                            
0000E116 9AC5                       		sub.w	d5,a5		; sub ch size
0000E118 51CF FFE2                  		dbf	d7,AMPS_Debug_Writehkloop	; loop for all chans
0000E11C 6000                       		bra.s	.add
0000E11E                            
0000E11E                            .inc
0000E11E 584E                       		addq.w	#4,a6		; go to next long
0000E120 5346                       		subq.w	#1,d6		; sub 1 line
0000E122 6AEE                       		bpl.s	.stack		; if lines left, branch
0000E124                            
0000E124                            .add
0000E124 5247                       		addq.w	#1,d7		; increase ch by 1
0000E126                            .rts
0000E126 4E75                       		rts
0000E128                            
0000E128                            AMPS_DebugR_ChkTracker_Ch:
0000E128 5347                       		subq.w	#1,d7		; sub 1 from offset
0000E12A 6A00 0000                  		bpl.w	AMPS_Debug_Write_n; branch if positive
0000E12E 4A46                       		tst.w	d6		; check if we need to render anymore
0000E130 6B00 0000                  		bmi.w	AMPS_Debug_Write_n; if not, branch
0000E134                            
0000E134                            ; fmt: <addr> lstdur, dur, freq, sample, loop0, loop1, loop2
0000E134 4E90                       		jsr	(a0)
0000E136                            	Console.Write	  ": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E136 40E7                     M 	move.w	sr,-(sp)
0000E138                          M 	__fstring_generateargumentscode	": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138 =00000003                M 	__pos:	set instr(": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E138 =00000000                M 	__stack:set	0
0000E138 =00000000                M 	__sp:	set 0
0000E138                          M 	while	(__pos)
0000E138 =0000000A                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E138 =0000000F                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E138 =0000000A                M 	__midpos:	= __endpos
0000E138                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138 =0000000B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E138 =00000012                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E138 =00000013                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E138 =00000012                M 	__midpos:	= __endpos
0000E138                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	pushp	"move.w a5,-(sp)"
0000E138 =00000001                M 	__stack:	= __stack+1
0000E138 =00000002                M 	__sp:	= __sp+2
0000E138 =00000014                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E138 =00000025                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E138 =00000026                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E138 =00000025                M 	__midpos:	= __endpos
0000E138                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	pushp	"move.b cLastDur(a5),1(sp)"
0000E138                          M 	pushp	"subq.w	#2, sp"
0000E138 =00000003                M 	__stack:	= __stack+2
0000E138 =00000004                M 	__sp:	= __sp+2
0000E138 =00000027                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E138 =00000039                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E138 =0000003A                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E138 =00000039                M 	__midpos:	= __endpos
0000E138                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	pushp	"move.b cDuration(a5),1(sp)"
0000E138                          M 	pushp	"subq.w	#2, sp"
0000E138 =00000005                M 	__stack:	= __stack+2
0000E138 =00000006                M 	__sp:	= __sp+2
0000E138 =0000003B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E138 =00000049                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E138 =00000000                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E138 =00000049                M 	__midpos:	= __endpos
0000E138                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138                          M 	pushp	"move.w cFreq(a5),-(sp)"
0000E138 =00000006                M 	__stack:	= __stack+1
0000E138 =00000008                M 	__sp:	= __sp+2
0000E138 =00000000                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E138                          M 	rept	__stack
0000E138                          M 	popp	__command
0000E138 3F2D 000E                M 	move.w	cfreq(a5),-(sp)
0000E13C                          M 	popp	__command
0000E13C 554F                     M 	subq.w	#2,sp
0000E13E                          M 	popp	__command
0000E13E 1F6D 000C 0001           M 	move.b	cduration(a5),1(sp)
0000E144                          M 	popp	__command
0000E144 554F                     M 	subq.w	#2,sp
0000E146                          M 	popp	__command
0000E146 1F6D 000D 0001           M 	move.b	clastdur(a5),1(sp)
0000E14C                          M 	popp	__command
0000E14C 3F0D                     M 	move.w	a5,-(sp)
0000E14E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E152 45EF 0010                M 	lea	4*4(sp),a2
0000E156 43FA 0000                M 	lea	.str_485(pc),a1
0000E15A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E160 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E164 504F                     M 	addq.w	#__sp,sp
0000E166 46DF                     M 	move.w	(sp)+,sr
0000E168 6000 0000                M 	bra.w	.instr_end_485
0000E16C                          M 	.str_485:
0000E16C                          M 	__fstring_generatedecodedstring	": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E16C =00000001                M 	__lpos:	set 1
0000E16C =00000003                M 	__pos:	set instr(": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E16C                          M 	while	(__pos)
0000E16C                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E16C 3A20                     M 	dc.b	": "
0000E16E =0000000A                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E16E =0000000F                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E16E =0000000A                M 	__midpos:	= __endpos
0000E16E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E16E                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E16E EC                       M 	dc.b	fpal2
0000E16F =0000000B                M 	__lpos:	set __endpos+1
0000E16F =0000000B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E16F                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E16F                          M 	dc.b	""
0000E16F =00000012                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E16F =00000013                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E16F =00000012                M 	__midpos:	= __endpos
0000E16F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E16F                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E16F                          M 	__param:	substr ,,"hex"
0000E16F 81                       M 	dc.b	hex|1
0000E170 =00000013                M 	__lpos:	set __endpos+1
0000E170 =00000014                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E170                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E170 20                       M 	dc.b	" "
0000E171 =00000025                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E171 =00000026                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E171 =00000025                M 	__midpos:	= __endpos
0000E171                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E171                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E171                          M 	__param:	substr ,,"hex"
0000E171 80                       M 	dc.b	hex
0000E172 =00000026                M 	__lpos:	set __endpos+1
0000E172 =00000027                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E172                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E172 20                       M 	dc.b	" "
0000E173 =00000039                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E173 =0000003A                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E173 =00000039                M 	__midpos:	= __endpos
0000E173                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E173                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E173                          M 	__param:	substr ,,"hex"
0000E173 80                       M 	dc.b	hex
0000E174 =0000003A                M 	__lpos:	set __endpos+1
0000E174 =0000003B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E174                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E174 20                       M 	dc.b	" "
0000E175 =00000049                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E175 =00000000                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E175 =00000049                M 	__midpos:	= __endpos
0000E175                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E175                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E175                          M 	__param:	substr ,,"hex"
0000E175 81                       M 	dc.b	hex|1
0000E176 =0000004A                M 	__lpos:	set __endpos+1
0000E176 =00000000                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E176                          M 	__substr:	substr __lpos,,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E176                          M 	dc.b	""
0000E176 00                       M 	dc.b	0
0000E178 00                       M 	even
0000E178                          M 	.instr_end_485:
0000E178                            	Console.WriteLine " %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E178 40E7                     M 	move.w	sr,-(sp)
0000E17A                          M 	__fstring_generateargumentscode	" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A =00000002                M 	__pos:	set instr(" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E17A =00000000                M 	__stack:set	0
0000E17A =00000000                M 	__sp:	set 0
0000E17A                          M 	while	(__pos)
0000E17A =00000012                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E17A =00000013                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E17A =00000012                M 	__midpos:	= __endpos
0000E17A                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	pushp	"move.b cSample(a5),1(sp)"
0000E17A                          M 	pushp	"subq.w	#2, sp"
0000E17A =00000002                M 	__stack:	= __stack+2
0000E17A =00000002                M 	__sp:	= __sp+2
0000E17A =00000014                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E17A =00000022                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E17A =00000023                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E17A =00000022                M 	__midpos:	= __endpos
0000E17A                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	pushp	"move.b cLoop(a5),1(sp)"
0000E17A                          M 	pushp	"subq.w	#2, sp"
0000E17A =00000004                M 	__stack:	= __stack+2
0000E17A =00000004                M 	__sp:	= __sp+2
0000E17A =00000024                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E17A =00000034                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E17A =00000035                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E17A =00000034                M 	__midpos:	= __endpos
0000E17A                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	pushp	"move.b cLoop+1(a5),1(sp)"
0000E17A                          M 	pushp	"subq.w	#2, sp"
0000E17A =00000006                M 	__stack:	= __stack+2
0000E17A =00000006                M 	__sp:	= __sp+2
0000E17A =00000036                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E17A =00000046                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E17A =00000000                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E17A =00000046                M 	__midpos:	= __endpos
0000E17A                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17A                          M 	pushp	"move.b cLoop+2(a5),1(sp)"
0000E17A                          M 	pushp	"subq.w	#2, sp"
0000E17A =00000008                M 	__stack:	= __stack+2
0000E17A =00000008                M 	__sp:	= __sp+2
0000E17A =00000000                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E17A                          M 	rept	__stack
0000E17A                          M 	popp	__command
0000E17A 554F                     M 	subq.w	#2,sp
0000E17C                          M 	popp	__command
0000E17C 1F6D 001B 0001           M 	move.b	cloop+2(a5),1(sp)
0000E182                          M 	popp	__command
0000E182 554F                     M 	subq.w	#2,sp
0000E184                          M 	popp	__command
0000E184 1F6D 001A 0001           M 	move.b	cloop+1(a5),1(sp)
0000E18A                          M 	popp	__command
0000E18A 554F                     M 	subq.w	#2,sp
0000E18C                          M 	popp	__command
0000E18C 1F6D 0019 0001           M 	move.b	cloop(a5),1(sp)
0000E192                          M 	popp	__command
0000E192 554F                     M 	subq.w	#2,sp
0000E194                          M 	popp	__command
0000E194 1F6D 000B 0001           M 	move.b	csample(a5),1(sp)
0000E19A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E19E 45EF 0010                M 	lea	4*4(sp),a2
0000E1A2 43FA 0000                M 	lea	.str_488(pc),a1
0000E1A6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E1AC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E1B0 504F                     M 	addq.w	#__sp,sp
0000E1B2 46DF                     M 	move.w	(sp)+,sr
0000E1B4 6000 0000                M 	bra.w	.instr_end_488
0000E1B8                          M 	.str_488:
0000E1B8                          M 	__fstring_generatedecodedstring	" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1B8 =00000001                M 	__lpos:	set 1
0000E1B8 =00000002                M 	__pos:	set instr(" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E1B8                          M 	while	(__pos)
0000E1B8                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1B8 20                       M 	dc.b	" "
0000E1B9 =00000012                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E1B9 =00000013                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E1B9 =00000012                M 	__midpos:	= __endpos
0000E1B9                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1B9                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1B9                          M 	__param:	substr ,,"hex"
0000E1B9 80                       M 	dc.b	hex
0000E1BA =00000013                M 	__lpos:	set __endpos+1
0000E1BA =00000014                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E1BA                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1BA 20                       M 	dc.b	" "
0000E1BB =00000022                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E1BB =00000023                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E1BB =00000022                M 	__midpos:	= __endpos
0000E1BB                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1BB                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1BB                          M 	__param:	substr ,,"hex"
0000E1BB 80                       M 	dc.b	hex
0000E1BC =00000023                M 	__lpos:	set __endpos+1
0000E1BC =00000024                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E1BC                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1BC 20                       M 	dc.b	" "
0000E1BD =00000034                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E1BD =00000035                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E1BD =00000034                M 	__midpos:	= __endpos
0000E1BD                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1BD                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1BD                          M 	__param:	substr ,,"hex"
0000E1BD 80                       M 	dc.b	hex
0000E1BE =00000035                M 	__lpos:	set __endpos+1
0000E1BE =00000036                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E1BE                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1BE 20                       M 	dc.b	" "
0000E1BF =00000046                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E1BF =00000000                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E1BF =00000046                M 	__midpos:	= __endpos
0000E1BF                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1BF                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1BF                          M 	__param:	substr ,,"hex"
0000E1BF 80                       M 	dc.b	hex
0000E1C0 =00000047                M 	__lpos:	set __endpos+1
0000E1C0 =00000000                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E1C0                          M 	__substr:	substr __lpos,," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E1C0                          M 	dc.b	""
0000E1C0 00                       M 	dc.b	0
0000E1C2 00                       M 	even
0000E1C2                          M 	.instr_end_488:
0000E1C2                            	Console.WriteLine " %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C2 40E7                     M 	move.w	sr,-(sp)
0000E1C4                          M 	__fstring_generateargumentscode	" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4 =00000002                M 	__pos:	set instr(" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1C4 =00000000                M 	__stack:set	0
0000E1C4 =00000000                M 	__sp:	set 0
0000E1C4                          M 	while	(__pos)
0000E1C4 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1C4 =0000000F                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1C4 =00000009                M 	__midpos:	= __endpos
0000E1C4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1C4 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1C4 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1C4 =00000017                M 	__midpos:	= __endpos
0000E1C4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1C4 =00000031                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1C4 =00000026                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1C4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4                          M 	__operand:	substr __pos+1+1,__midpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4                          M 	pushp	"move.l cData(a5),-(sp)"
0000E1C4 =00000001                M 	__stack:	= __stack+1
0000E1C4 =00000004                M 	__sp:	= __sp+4
0000E1C4 =00000032                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1C4 =00000042                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1C4 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1C4 =00000042                M 	__midpos:	= __endpos
0000E1C4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1C4 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1C4                          M 	rept	__stack
0000E1C4                          M 	popp	__command
0000E1C4 2F2D 0002                M 	move.l	cdata(a5),-(sp)
0000E1C8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E1CC 45EF 0010                M 	lea	4*4(sp),a2
0000E1D0 43FA 0000                M 	lea	.str_491(pc),a1
0000E1D4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E1DA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E1DE 584F                     M 	addq.w	#__sp,sp
0000E1E0 46DF                     M 	move.w	(sp)+,sr
0000E1E2 6000 0000                M 	bra.w	.instr_end_491
0000E1E6                          M 	.str_491:
0000E1E6                          M 	__fstring_generatedecodedstring	" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1E6 =00000001                M 	__lpos:	set 1
0000E1E6 =00000002                M 	__pos:	set instr(" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1E6                          M 	while	(__pos)
0000E1E6                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1E6 20                       M 	dc.b	" "
0000E1E7 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1E7 =0000000F                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1E7 =00000009                M 	__midpos:	= __endpos
0000E1E7                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1E7                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1E7 EA                       M 	dc.b	fpal1
0000E1E8 =0000000A                M 	__lpos:	set __endpos+1
0000E1E8 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1E8                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1E8 4164 6472 3A20           M 	dc.b	"Addr: "
0000E1EE =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1EE =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1EE =00000017                M 	__midpos:	= __endpos
0000E1EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1EE                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1EE E8                       M 	dc.b	fpal0
0000E1EF =00000018                M 	__lpos:	set __endpos+1
0000E1EF =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1EF                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1EF                          M 	dc.b	""
0000E1EF =00000031                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1EF =00000026                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1EF                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1EF                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1EF BB                       M 	dc.b	sym|fsplit|3
0000E1F0 =00000032                M 	__lpos:	set __endpos+1
0000E1F0 =00000032                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1F0                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1F0                          M 	dc.b	""
0000E1F0 =00000042                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1F0 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1F0 =00000042                M 	__midpos:	= __endpos
0000E1F0                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1F0                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1F0 ECC0                     M 	dc.b	fpal2,fsymdisp
0000E1F2 =00000043                M 	__lpos:	set __endpos+1
0000E1F2 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1F2                          M 	__substr:	substr __lpos,," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1F2                          M 	dc.b	""
0000E1F2 00                       M 	dc.b	0
0000E1F4 00                       M 	even
0000E1F4                          M 	.instr_end_491:
0000E1F4                            
0000E1F4 5546                       		subq.w	#2,d6		; sub those 2 lines from stuff
0000E1F6 6B00 0000                  		bmi.w	AMPS_Debug_Write_n; if drawn all, branch
0000E1FA 320D                       		move.w	a5,d1		; copy ch to d1
0000E1FC D245                       		add.w	d5,d1		; go to end of it
0000E1FE                            
0000E1FE 7000                       		moveq	#0,d0
0000E200 102D 001E                  		move.b	cStack(a5),d0	; get stack to d0
0000E204 4DF5 0000                  		lea	(a5,d0.w),a6	; and get first element to a6
0000E208                            
0000E208 B24E                       		cmp.w	a6,d1		; check if stack is dry
0000E20A 6300                       		bls.s	AMPS_Debug_Write		; if is, branch
0000E20C                            	Console.WriteLine " %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20C 40E7                     M 	move.w	sr,-(sp)
0000E20E                          M 	__fstring_generateargumentscode	" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E =00000002                M 	__pos:	set instr(" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E20E =00000000                M 	__stack:set	0
0000E20E =00000000                M 	__sp:	set 0
0000E20E                          M 	while	(__pos)
0000E20E =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E20E =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E20E =00000009                M 	__midpos:	= __endpos
0000E20E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E20E =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E20E =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E20E =00000017                M 	__midpos:	= __endpos
0000E20E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E20E =0000002D                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E20E =00000022                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E20E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E                          M 	pushp	"move.l (a6)+,-(sp)"
0000E20E =00000001                M 	__stack:	= __stack+1
0000E20E =00000004                M 	__sp:	= __sp+4
0000E20E =0000002E                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E20E =0000003E                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E20E =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E20E =0000003E                M 	__midpos:	= __endpos
0000E20E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20E =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E20E                          M 	rept	__stack
0000E20E                          M 	popp	__command
0000E20E 2F1E                     M 	move.l	(a6)+,-(sp)
0000E210 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E214 45EF 0010                M 	lea	4*4(sp),a2
0000E218 43FA 0000                M 	lea	.str_494(pc),a1
0000E21C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E222 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E226 584F                     M 	addq.w	#__sp,sp
0000E228 46DF                     M 	move.w	(sp)+,sr
0000E22A 6000 0000                M 	bra.w	.instr_end_494
0000E22E                          M 	.str_494:
0000E22E                          M 	__fstring_generatedecodedstring	" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22E =00000001                M 	__lpos:	set 1
0000E22E =00000002                M 	__pos:	set instr(" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E22E                          M 	while	(__pos)
0000E22E                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22E 20                       M 	dc.b	" "
0000E22F =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E22F =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E22F =00000009                M 	__midpos:	= __endpos
0000E22F                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22F                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22F EA                       M 	dc.b	fpal1
0000E230 =0000000A                M 	__lpos:	set __endpos+1
0000E230 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E230                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E230 5374 6163 6B3A           M 	dc.b	"Stack:"
0000E236 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E236 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E236 =00000017                M 	__midpos:	= __endpos
0000E236                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E236                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E236 E8                       M 	dc.b	fpal0
0000E237 =00000018                M 	__lpos:	set __endpos+1
0000E237 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E237                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E237                          M 	dc.b	""
0000E237 =0000002D                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E237 =00000022                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E237                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E237                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E237 BB                       M 	dc.b	sym|fsplit|3
0000E238 =0000002E                M 	__lpos:	set __endpos+1
0000E238 =0000002E                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E238                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E238                          M 	dc.b	""
0000E238 =0000003E                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E238 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E238 =0000003E                M 	__midpos:	= __endpos
0000E238                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E238                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E238 ECC0                     M 	dc.b	fpal2,fsymdisp
0000E23A =0000003F                M 	__lpos:	set __endpos+1
0000E23A =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E23A                          M 	__substr:	substr __lpos,," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E23A                          M 	dc.b	""
0000E23A 00                       M 	dc.b	0
0000E23C 00                       M 	even
0000E23C                          M 	.instr_end_494:
0000E23C 5346                       		subq.w	#1,d6		; sub a line
0000E23E 6B00                       		bmi.s	AMPS_Debug_Write_n; if drawn all, branch
0000E240                            
0000E240                            AMPS_DebugR_ChkTracker_Ch_loop
0000E240 B24E                       		cmp.w	a6,d1		; check if we printed full stack
0000E242 6300                       		bls.s	AMPS_Debug_Write		; if not though, branch
0000E244                            	Console.WriteLine "   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E244 40E7                     M 	move.w	sr,-(sp)
0000E246                          M 	__fstring_generateargumentscode	"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E246 =00000004                M 	__pos:	set instr("   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E246 =00000000                M 	__stack:set	0
0000E246 =00000000                M 	__sp:	set 0
0000E246                          M 	while	(__pos)
0000E246 =0000000B                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E246 =00000010                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E246 =0000000B                M 	__midpos:	= __endpos
0000E246                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E246                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E246 =0000000C                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E246 =00000021                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E246 =00000016                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E246                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E246                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E246                          M 	__operand:	substr __pos+1+1,__midpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E246                          M 	__param:	substr __midpos+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E246                          M 	pushp	"move.l (a6)+,-(sp)"
0000E246 =00000001                M 	__stack:	= __stack+1
0000E246 =00000004                M 	__sp:	= __sp+4
0000E246 =00000022                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E246 =00000032                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E246 =00000000                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E246 =00000032                M 	__midpos:	= __endpos
0000E246                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E246                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E246 =00000000                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E246                          M 	rept	__stack
0000E246                          M 	popp	__command
0000E246 2F1E                     M 	move.l	(a6)+,-(sp)
0000E248 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E24C 45EF 0010                M 	lea	4*4(sp),a2
0000E250 43FA 0000                M 	lea	.str_497(pc),a1
0000E254 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E25A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E25E 584F                     M 	addq.w	#__sp,sp
0000E260 46DF                     M 	move.w	(sp)+,sr
0000E262 6000 0000                M 	bra.w	.instr_end_497
0000E266                          M 	.str_497:
0000E266                          M 	__fstring_generatedecodedstring	"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E266 =00000001                M 	__lpos:	set 1
0000E266 =00000004                M 	__pos:	set instr("   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E266                          M 	while	(__pos)
0000E266                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E266 2020 20                  M 	dc.b	"   "
0000E269 =0000000B                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E269 =00000010                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E269 =0000000B                M 	__midpos:	= __endpos
0000E269                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E269                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E269 E8                       M 	dc.b	fpal0
0000E26A =0000000C                M 	__lpos:	set __endpos+1
0000E26A =0000000C                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E26A                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E26A                          M 	dc.b	""
0000E26A =00000021                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E26A =00000016                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E26A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E26A                          M 	__param:	substr __midpos+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E26A BB                       M 	dc.b	sym|fsplit|3
0000E26B =00000022                M 	__lpos:	set __endpos+1
0000E26B =00000022                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E26B                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E26B                          M 	dc.b	""
0000E26B =00000032                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E26B =00000000                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E26B =00000032                M 	__midpos:	= __endpos
0000E26B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E26B                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E26B ECC0                     M 	dc.b	fpal2,fsymdisp
0000E26D =00000033                M 	__lpos:	set __endpos+1
0000E26D =00000000                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E26D                          M 	__substr:	substr __lpos,,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E26D                          M 	dc.b	""
0000E26D 00                       M 	dc.b	0
0000E26E                          M 	even
0000E26E                          M 	.instr_end_497:
0000E26E 5346                       		subq.w	#1,d6		; sub a line
0000E270 6ACE                       		bpl.s	AMPS_DebugR_ChkTracker_Ch_loop; if we havent drawn all, branch
0000E272                            
0000E272                            AMPS_Debug_Write
0000E272                            	Console.BreakLine
0000E272 40E7                     M 	move.w	sr,-(sp)
0000E274 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000E27A 46DF                     M 	move.w	(sp)+,sr
0000E27C 5346                       		subq.w	#1,d6		; sub a line
0000E27E                            AMPS_Debug_Write_n
0000E27E DAC5                       		add.w	d5,a5		; go to next ch
0000E280 4E75                       		rts
0000E282                            
0000E282                            AMPS_DebugR_ChkTracker2:
0000E282 7C27                       		moveq	#40-1,d6
0000E284 7A2C                       		moveq	#cSize,d5
0000E286 4BF8 C4C4                  		lea	mDAC1.w,a5
0000E28A                            
0000E28A                            
0000E28A 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_dac1(pc),a0
0000E28E 4EBA FE98                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E292 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_dac2(pc),a0
0000E296 4EBA FE90                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E29A                            
0000E29A 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm1(pc),a0
0000E29E 4EBA FE88                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E2A2 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm2(pc),a0
0000E2A6 4EBA FE80                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E2AA 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm3(pc),a0
0000E2AE 4EBA FE78                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E2B2 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm4(pc),a0
0000E2B6 4EBA FE70                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E2BA 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm5(pc),a0
0000E2BE 4EBA FE68                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E2C2                            
0000E2C2 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg1(pc),a0
0000E2C6 4EBA FE60                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E2CA 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg2(pc),a0
0000E2CE 4EBA FE58                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E2D2 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg3(pc),a0
0000E2D6 4EFA FE50                  		jmp	AMPS_DebugR_ChkTracker_Ch(pc)
0000E2DA                            
0000E2DA                            AMPS_DebugR_ChkTracker2_dac1
0000E2DA                            	Console.Write " %<fpal0>DAC1"
0000E2DA 40E7                     M 	move.w	sr,-(sp)
0000E2DC                          M 	__fstring_generateargumentscode	" %<fpal0>DAC1"
0000E2DC =00000002                M 	__pos:	set instr(" %<fpal0>DAC1",'%<')
0000E2DC =00000000                M 	__stack:set	0
0000E2DC =00000000                M 	__sp:	set 0
0000E2DC                          M 	while	(__pos)
0000E2DC =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC1",'>')
0000E2DC =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC1",' ')
0000E2DC =00000009                M 	__midpos:	= __endpos
0000E2DC                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC1"
0000E2DC                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC1"
0000E2DC =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC1",'%<')
0000E2DC                          M 	rept	__stack
0000E2DC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E2E0 43FA 0000                M 	lea	.str_501(pc),a1
0000E2E4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E2EA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E2EE 46DF                     M 	move.w	(sp)+,sr
0000E2F0 6000 0000                M 	bra.w	.instr_end_501
0000E2F4                          M 	.str_501:
0000E2F4                          M 	__fstring_generatedecodedstring	" %<fpal0>DAC1"
0000E2F4 =00000001                M 	__lpos:	set 1
0000E2F4 =00000002                M 	__pos:	set instr(" %<fpal0>DAC1",'%<')
0000E2F4                          M 	while	(__pos)
0000E2F4                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>DAC1"
0000E2F4 20                       M 	dc.b	" "
0000E2F5 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC1",'>')
0000E2F5 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC1",' ')
0000E2F5 =00000009                M 	__midpos:	= __endpos
0000E2F5                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC1"
0000E2F5                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC1"
0000E2F5 E8                       M 	dc.b	fpal0
0000E2F6 =0000000A                M 	__lpos:	set __endpos+1
0000E2F6 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC1",'%<')
0000E2F6                          M 	__substr:	substr __lpos,," %<fpal0>DAC1"
0000E2F6 4441 4331                M 	dc.b	"DAC1"
0000E2FA 00                       M 	dc.b	0
0000E2FC 00                       M 	even
0000E2FC                          M 	.instr_end_501:
0000E2FC 4E75                       		rts
0000E2FE                            
0000E2FE                            AMPS_DebugR_ChkTracker2_dac2
0000E2FE                            	Console.Write " %<fpal0>DAC2"
0000E2FE 40E7                     M 	move.w	sr,-(sp)
0000E300                          M 	__fstring_generateargumentscode	" %<fpal0>DAC2"
0000E300 =00000002                M 	__pos:	set instr(" %<fpal0>DAC2",'%<')
0000E300 =00000000                M 	__stack:set	0
0000E300 =00000000                M 	__sp:	set 0
0000E300                          M 	while	(__pos)
0000E300 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC2",'>')
0000E300 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC2",' ')
0000E300 =00000009                M 	__midpos:	= __endpos
0000E300                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC2"
0000E300                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC2"
0000E300 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC2",'%<')
0000E300                          M 	rept	__stack
0000E300 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E304 43FA 0000                M 	lea	.str_504(pc),a1
0000E308 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E30E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E312 46DF                     M 	move.w	(sp)+,sr
0000E314 6000 0000                M 	bra.w	.instr_end_504
0000E318                          M 	.str_504:
0000E318                          M 	__fstring_generatedecodedstring	" %<fpal0>DAC2"
0000E318 =00000001                M 	__lpos:	set 1
0000E318 =00000002                M 	__pos:	set instr(" %<fpal0>DAC2",'%<')
0000E318                          M 	while	(__pos)
0000E318                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>DAC2"
0000E318 20                       M 	dc.b	" "
0000E319 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC2",'>')
0000E319 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC2",' ')
0000E319 =00000009                M 	__midpos:	= __endpos
0000E319                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC2"
0000E319                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC2"
0000E319 E8                       M 	dc.b	fpal0
0000E31A =0000000A                M 	__lpos:	set __endpos+1
0000E31A =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC2",'%<')
0000E31A                          M 	__substr:	substr __lpos,," %<fpal0>DAC2"
0000E31A 4441 4332                M 	dc.b	"DAC2"
0000E31E 00                       M 	dc.b	0
0000E320 00                       M 	even
0000E320                          M 	.instr_end_504:
0000E320 4E75                       		rts
0000E322                            
0000E322                            AMPS_DebugR_ChkTracker2_fm1
0000E322                            	Console.Write " %<fpal0> FM1"
0000E322 40E7                     M 	move.w	sr,-(sp)
0000E324                          M 	__fstring_generateargumentscode	" %<fpal0> FM1"
0000E324 =00000002                M 	__pos:	set instr(" %<fpal0> FM1",'%<')
0000E324 =00000000                M 	__stack:set	0
0000E324 =00000000                M 	__sp:	set 0
0000E324                          M 	while	(__pos)
0000E324 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM1",'>')
0000E324 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM1",' ')
0000E324 =00000009                M 	__midpos:	= __endpos
0000E324                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM1"
0000E324                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM1"
0000E324 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM1",'%<')
0000E324                          M 	rept	__stack
0000E324 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E328 43FA 0000                M 	lea	.str_507(pc),a1
0000E32C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E332 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E336 46DF                     M 	move.w	(sp)+,sr
0000E338 6000 0000                M 	bra.w	.instr_end_507
0000E33C                          M 	.str_507:
0000E33C                          M 	__fstring_generatedecodedstring	" %<fpal0> FM1"
0000E33C =00000001                M 	__lpos:	set 1
0000E33C =00000002                M 	__pos:	set instr(" %<fpal0> FM1",'%<')
0000E33C                          M 	while	(__pos)
0000E33C                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM1"
0000E33C 20                       M 	dc.b	" "
0000E33D =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM1",'>')
0000E33D =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM1",' ')
0000E33D =00000009                M 	__midpos:	= __endpos
0000E33D                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM1"
0000E33D                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM1"
0000E33D E8                       M 	dc.b	fpal0
0000E33E =0000000A                M 	__lpos:	set __endpos+1
0000E33E =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM1",'%<')
0000E33E                          M 	__substr:	substr __lpos,," %<fpal0> FM1"
0000E33E 2046 4D31                M 	dc.b	" FM1"
0000E342 00                       M 	dc.b	0
0000E344 00                       M 	even
0000E344                          M 	.instr_end_507:
0000E344 4E75                       		rts
0000E346                            
0000E346                            AMPS_DebugR_ChkTracker2_fm2
0000E346                            	Console.Write " %<fpal0> FM2"
0000E346 40E7                     M 	move.w	sr,-(sp)
0000E348                          M 	__fstring_generateargumentscode	" %<fpal0> FM2"
0000E348 =00000002                M 	__pos:	set instr(" %<fpal0> FM2",'%<')
0000E348 =00000000                M 	__stack:set	0
0000E348 =00000000                M 	__sp:	set 0
0000E348                          M 	while	(__pos)
0000E348 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM2",'>')
0000E348 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM2",' ')
0000E348 =00000009                M 	__midpos:	= __endpos
0000E348                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM2"
0000E348                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM2"
0000E348 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM2",'%<')
0000E348                          M 	rept	__stack
0000E348 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E34C 43FA 0000                M 	lea	.str_510(pc),a1
0000E350 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E356 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E35A 46DF                     M 	move.w	(sp)+,sr
0000E35C 6000 0000                M 	bra.w	.instr_end_510
0000E360                          M 	.str_510:
0000E360                          M 	__fstring_generatedecodedstring	" %<fpal0> FM2"
0000E360 =00000001                M 	__lpos:	set 1
0000E360 =00000002                M 	__pos:	set instr(" %<fpal0> FM2",'%<')
0000E360                          M 	while	(__pos)
0000E360                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM2"
0000E360 20                       M 	dc.b	" "
0000E361 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM2",'>')
0000E361 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM2",' ')
0000E361 =00000009                M 	__midpos:	= __endpos
0000E361                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM2"
0000E361                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM2"
0000E361 E8                       M 	dc.b	fpal0
0000E362 =0000000A                M 	__lpos:	set __endpos+1
0000E362 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM2",'%<')
0000E362                          M 	__substr:	substr __lpos,," %<fpal0> FM2"
0000E362 2046 4D32                M 	dc.b	" FM2"
0000E366 00                       M 	dc.b	0
0000E368 00                       M 	even
0000E368                          M 	.instr_end_510:
0000E368 4E75                       		rts
0000E36A                            
0000E36A                            AMPS_DebugR_ChkTracker2_fm3
0000E36A                            	Console.Write " %<fpal0> FM3"
0000E36A 40E7                     M 	move.w	sr,-(sp)
0000E36C                          M 	__fstring_generateargumentscode	" %<fpal0> FM3"
0000E36C =00000002                M 	__pos:	set instr(" %<fpal0> FM3",'%<')
0000E36C =00000000                M 	__stack:set	0
0000E36C =00000000                M 	__sp:	set 0
0000E36C                          M 	while	(__pos)
0000E36C =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM3",'>')
0000E36C =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM3",' ')
0000E36C =00000009                M 	__midpos:	= __endpos
0000E36C                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM3"
0000E36C                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM3"
0000E36C =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM3",'%<')
0000E36C                          M 	rept	__stack
0000E36C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E370 43FA 0000                M 	lea	.str_513(pc),a1
0000E374 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E37A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E37E 46DF                     M 	move.w	(sp)+,sr
0000E380 6000 0000                M 	bra.w	.instr_end_513
0000E384                          M 	.str_513:
0000E384                          M 	__fstring_generatedecodedstring	" %<fpal0> FM3"
0000E384 =00000001                M 	__lpos:	set 1
0000E384 =00000002                M 	__pos:	set instr(" %<fpal0> FM3",'%<')
0000E384                          M 	while	(__pos)
0000E384                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM3"
0000E384 20                       M 	dc.b	" "
0000E385 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM3",'>')
0000E385 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM3",' ')
0000E385 =00000009                M 	__midpos:	= __endpos
0000E385                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM3"
0000E385                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM3"
0000E385 E8                       M 	dc.b	fpal0
0000E386 =0000000A                M 	__lpos:	set __endpos+1
0000E386 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM3",'%<')
0000E386                          M 	__substr:	substr __lpos,," %<fpal0> FM3"
0000E386 2046 4D33                M 	dc.b	" FM3"
0000E38A 00                       M 	dc.b	0
0000E38C 00                       M 	even
0000E38C                          M 	.instr_end_513:
0000E38C 4E75                       		rts
0000E38E                            
0000E38E                            AMPS_DebugR_ChkTracker2_fm4
0000E38E                            	Console.Write " %<fpal0> FM4"
0000E38E 40E7                     M 	move.w	sr,-(sp)
0000E390                          M 	__fstring_generateargumentscode	" %<fpal0> FM4"
0000E390 =00000002                M 	__pos:	set instr(" %<fpal0> FM4",'%<')
0000E390 =00000000                M 	__stack:set	0
0000E390 =00000000                M 	__sp:	set 0
0000E390                          M 	while	(__pos)
0000E390 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM4",'>')
0000E390 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM4",' ')
0000E390 =00000009                M 	__midpos:	= __endpos
0000E390                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM4"
0000E390                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM4"
0000E390 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM4",'%<')
0000E390                          M 	rept	__stack
0000E390 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E394 43FA 0000                M 	lea	.str_516(pc),a1
0000E398 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E39E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E3A2 46DF                     M 	move.w	(sp)+,sr
0000E3A4 6000 0000                M 	bra.w	.instr_end_516
0000E3A8                          M 	.str_516:
0000E3A8                          M 	__fstring_generatedecodedstring	" %<fpal0> FM4"
0000E3A8 =00000001                M 	__lpos:	set 1
0000E3A8 =00000002                M 	__pos:	set instr(" %<fpal0> FM4",'%<')
0000E3A8                          M 	while	(__pos)
0000E3A8                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM4"
0000E3A8 20                       M 	dc.b	" "
0000E3A9 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM4",'>')
0000E3A9 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM4",' ')
0000E3A9 =00000009                M 	__midpos:	= __endpos
0000E3A9                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM4"
0000E3A9                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM4"
0000E3A9 E8                       M 	dc.b	fpal0
0000E3AA =0000000A                M 	__lpos:	set __endpos+1
0000E3AA =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM4",'%<')
0000E3AA                          M 	__substr:	substr __lpos,," %<fpal0> FM4"
0000E3AA 2046 4D34                M 	dc.b	" FM4"
0000E3AE 00                       M 	dc.b	0
0000E3B0 00                       M 	even
0000E3B0                          M 	.instr_end_516:
0000E3B0 4E75                       		rts
0000E3B2                            
0000E3B2                            AMPS_DebugR_ChkTracker2_fm5
0000E3B2                            	Console.Write " %<fpal0> FM5"
0000E3B2 40E7                     M 	move.w	sr,-(sp)
0000E3B4                          M 	__fstring_generateargumentscode	" %<fpal0> FM5"
0000E3B4 =00000002                M 	__pos:	set instr(" %<fpal0> FM5",'%<')
0000E3B4 =00000000                M 	__stack:set	0
0000E3B4 =00000000                M 	__sp:	set 0
0000E3B4                          M 	while	(__pos)
0000E3B4 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM5",'>')
0000E3B4 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM5",' ')
0000E3B4 =00000009                M 	__midpos:	= __endpos
0000E3B4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM5"
0000E3B4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM5"
0000E3B4 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM5",'%<')
0000E3B4                          M 	rept	__stack
0000E3B4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E3B8 43FA 0000                M 	lea	.str_519(pc),a1
0000E3BC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E3C2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E3C6 46DF                     M 	move.w	(sp)+,sr
0000E3C8 6000 0000                M 	bra.w	.instr_end_519
0000E3CC                          M 	.str_519:
0000E3CC                          M 	__fstring_generatedecodedstring	" %<fpal0> FM5"
0000E3CC =00000001                M 	__lpos:	set 1
0000E3CC =00000002                M 	__pos:	set instr(" %<fpal0> FM5",'%<')
0000E3CC                          M 	while	(__pos)
0000E3CC                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM5"
0000E3CC 20                       M 	dc.b	" "
0000E3CD =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM5",'>')
0000E3CD =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM5",' ')
0000E3CD =00000009                M 	__midpos:	= __endpos
0000E3CD                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM5"
0000E3CD                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM5"
0000E3CD E8                       M 	dc.b	fpal0
0000E3CE =0000000A                M 	__lpos:	set __endpos+1
0000E3CE =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM5",'%<')
0000E3CE                          M 	__substr:	substr __lpos,," %<fpal0> FM5"
0000E3CE 2046 4D35                M 	dc.b	" FM5"
0000E3D2 00                       M 	dc.b	0
0000E3D4 00                       M 	even
0000E3D4                          M 	.instr_end_519:
0000E3D4 4E75                       		rts
0000E3D6                            
0000E3D6                            AMPS_DebugR_ChkTracker2_psg1
0000E3D6                            	Console.Write " %<fpal0>PSG1"
0000E3D6 40E7                     M 	move.w	sr,-(sp)
0000E3D8                          M 	__fstring_generateargumentscode	" %<fpal0>PSG1"
0000E3D8 =00000002                M 	__pos:	set instr(" %<fpal0>PSG1",'%<')
0000E3D8 =00000000                M 	__stack:set	0
0000E3D8 =00000000                M 	__sp:	set 0
0000E3D8                          M 	while	(__pos)
0000E3D8 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG1",'>')
0000E3D8 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG1",' ')
0000E3D8 =00000009                M 	__midpos:	= __endpos
0000E3D8                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG1"
0000E3D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG1"
0000E3D8 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG1",'%<')
0000E3D8                          M 	rept	__stack
0000E3D8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E3DC 43FA 0000                M 	lea	.str_522(pc),a1
0000E3E0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E3E6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E3EA 46DF                     M 	move.w	(sp)+,sr
0000E3EC 6000 0000                M 	bra.w	.instr_end_522
0000E3F0                          M 	.str_522:
0000E3F0                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG1"
0000E3F0 =00000001                M 	__lpos:	set 1
0000E3F0 =00000002                M 	__pos:	set instr(" %<fpal0>PSG1",'%<')
0000E3F0                          M 	while	(__pos)
0000E3F0                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG1"
0000E3F0 20                       M 	dc.b	" "
0000E3F1 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG1",'>')
0000E3F1 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG1",' ')
0000E3F1 =00000009                M 	__midpos:	= __endpos
0000E3F1                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG1"
0000E3F1                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG1"
0000E3F1 E8                       M 	dc.b	fpal0
0000E3F2 =0000000A                M 	__lpos:	set __endpos+1
0000E3F2 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG1",'%<')
0000E3F2                          M 	__substr:	substr __lpos,," %<fpal0>PSG1"
0000E3F2 5053 4731                M 	dc.b	"PSG1"
0000E3F6 00                       M 	dc.b	0
0000E3F8 00                       M 	even
0000E3F8                          M 	.instr_end_522:
0000E3F8 4E75                       		rts
0000E3FA                            
0000E3FA                            AMPS_DebugR_ChkTracker2_psg2
0000E3FA                            	Console.Write " %<fpal0>PSG2"
0000E3FA 40E7                     M 	move.w	sr,-(sp)
0000E3FC                          M 	__fstring_generateargumentscode	" %<fpal0>PSG2"
0000E3FC =00000002                M 	__pos:	set instr(" %<fpal0>PSG2",'%<')
0000E3FC =00000000                M 	__stack:set	0
0000E3FC =00000000                M 	__sp:	set 0
0000E3FC                          M 	while	(__pos)
0000E3FC =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG2",'>')
0000E3FC =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG2",' ')
0000E3FC =00000009                M 	__midpos:	= __endpos
0000E3FC                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG2"
0000E3FC                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG2"
0000E3FC =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG2",'%<')
0000E3FC                          M 	rept	__stack
0000E3FC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E400 43FA 0000                M 	lea	.str_525(pc),a1
0000E404 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E40A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E40E 46DF                     M 	move.w	(sp)+,sr
0000E410 6000 0000                M 	bra.w	.instr_end_525
0000E414                          M 	.str_525:
0000E414                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG2"
0000E414 =00000001                M 	__lpos:	set 1
0000E414 =00000002                M 	__pos:	set instr(" %<fpal0>PSG2",'%<')
0000E414                          M 	while	(__pos)
0000E414                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG2"
0000E414 20                       M 	dc.b	" "
0000E415 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG2",'>')
0000E415 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG2",' ')
0000E415 =00000009                M 	__midpos:	= __endpos
0000E415                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG2"
0000E415                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG2"
0000E415 E8                       M 	dc.b	fpal0
0000E416 =0000000A                M 	__lpos:	set __endpos+1
0000E416 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG2",'%<')
0000E416                          M 	__substr:	substr __lpos,," %<fpal0>PSG2"
0000E416 5053 4732                M 	dc.b	"PSG2"
0000E41A 00                       M 	dc.b	0
0000E41C 00                       M 	even
0000E41C                          M 	.instr_end_525:
0000E41C 4E75                       		rts
0000E41E                            
0000E41E                            AMPS_DebugR_ChkTracker2_psg3
0000E41E                            	Console.Write " %<fpal0>PSG3"
0000E41E 40E7                     M 	move.w	sr,-(sp)
0000E420                          M 	__fstring_generateargumentscode	" %<fpal0>PSG3"
0000E420 =00000002                M 	__pos:	set instr(" %<fpal0>PSG3",'%<')
0000E420 =00000000                M 	__stack:set	0
0000E420 =00000000                M 	__sp:	set 0
0000E420                          M 	while	(__pos)
0000E420 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG3",'>')
0000E420 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG3",' ')
0000E420 =00000009                M 	__midpos:	= __endpos
0000E420                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG3"
0000E420                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG3"
0000E420 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG3",'%<')
0000E420                          M 	rept	__stack
0000E420 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E424 43FA 0000                M 	lea	.str_528(pc),a1
0000E428 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E42E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E432 46DF                     M 	move.w	(sp)+,sr
0000E434 6000 0000                M 	bra.w	.instr_end_528
0000E438                          M 	.str_528:
0000E438                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG3"
0000E438 =00000001                M 	__lpos:	set 1
0000E438 =00000002                M 	__pos:	set instr(" %<fpal0>PSG3",'%<')
0000E438                          M 	while	(__pos)
0000E438                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG3"
0000E438 20                       M 	dc.b	" "
0000E439 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG3",'>')
0000E439 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG3",' ')
0000E439 =00000009                M 	__midpos:	= __endpos
0000E439                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG3"
0000E439                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG3"
0000E439 E8                       M 	dc.b	fpal0
0000E43A =0000000A                M 	__lpos:	set __endpos+1
0000E43A =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG3",'%<')
0000E43A                          M 	__substr:	substr __lpos,," %<fpal0>PSG3"
0000E43A 5053 4733                M 	dc.b	"PSG3"
0000E43E 00                       M 	dc.b	0
0000E440 00                       M 	even
0000E440                          M 	.instr_end_528:
0000E440 4E75                       		rts
0000E442                            ; ===========================================================================
0000E442                            ; ---------------------------------------------------------------------------
0000E442                            ; Routine for loading the Dual PCM driver into Z80 RAM
0000E442                            ; ---------------------------------------------------------------------------
0000E442                            
0000E442                            LoadDualPCM:
0000E442 33FC 0100 00A1 1100        		move.w	#$0100,$A11100		; request Z80 stop
0000E44A 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0000E452                            
0000E452 41F9 0000 0000             		lea	DualPCM,a0		; load Dual PCM address into a0
0000E458 43F9 00A0 0000             		lea	dZ80,a1			; load Z80 RAM address into a1
0000E45E 323C 0000                  		move.w	#DualPCM_sz-1,d1	; get lenght counter for dbf into d1
0000E462                            
0000E462                            .z80
0000E462 0839 0000 00A1 1100        		btst	#$00,$A11100		; check if Z80 has stopped
0000E46A 66F6                       		bne.s	.z80			; if not, wait more
0000E46C                            
0000E46C                            .load
0000E46C 12D8                       		move.b	(a0)+,(a1)+		; copy the Dual PCM driver into Z80 RAM
0000E46E 51C9 FFFC                  		dbf	d1,.load		; write every single byte
0000E472                            
0000E472 41FA 0000                  		lea	SampleList(pc),a0	; load address for the stop sample data into a0
0000E476 43F9 0000 0000             		lea	dZ80+MuteSample,a1	; load address in Dual PCM to write into a1
0000E47C                            
0000E47C                            	rept 6
0000E47C                            		move.b	(a0)+,(a1)+		; copy all required data
0000E47C                            	endr
0000E47C 12D8                     M 	move.b	(a0)+,(a1)+
0000E47E 12D8                     M 	move.b	(a0)+,(a1)+
0000E480 12D8                     M 	move.b	(a0)+,(a1)+
0000E482 12D8                     M 	move.b	(a0)+,(a1)+
0000E484 12D8                     M 	move.b	(a0)+,(a1)+
0000E486 12D8                     M 	move.b	(a0)+,(a1)+
0000E488                            
0000E488 7002                       		moveq	#2,d0			; set flush timer for 60hz systems
0000E48A 0838 0006 C746             		btst	#6,hwVersion.w	; is this a PAL Mega Drive?
0000E490 6700                       		beq.s	.ntsc			; if not, branch
0000E492 7003                       		moveq	#3,d0			; set flush timer for 50hz systems
0000E494                            .ntsc
0000E494 13C0 0000 0000             		move.b	d0,dZ80+YM_FlushTimer+2	; save flush timer
0000E49A                            
0000E49A 33FC 0000 00A1 1200        		move.w	#$0000,$A11200		; request Z80 reset
0000E4A2 727F                       		moveq	#$7F,d1			; wait for a little bit
0000E4A4 51C9 FFFE                  		dbf	d1,*			; we can't check for reset, so we need to delay
0000E4A8                            
0000E4A8 33FC 0000 00A1 1100        		move.w	#$0000,$A11100		; enable Z80
0000E4B0 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0000E4B8 4E75                       		rts
0000E4BA                            ; ---------------------------------------------------------------------------
0000E4BA                            ; Play DAC
0000E4BA                            ; ---------------------------------------------------------------------------
0000E4BA                            
0000E4BA                            PlayDAC2:
0000E4BA 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0000E4C0                            	StopZ80					; wait for Z80 to stop
0000E4C0 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E4C8                          M 	waitz80stop
0000E4C8 0839 0000 00A1 1100      M .wait_532:	btst	#0,z80_bus_req
0000E4D0 66F6                     M 	bne.s	.wait_532
0000E4D2                            	rept 12
0000E4D2                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E4D2                            	endr
0000E4D2 12DB                     M 	move.b	(a3)+,(a1)+
0000E4D4 12DB                     M 	move.b	(a3)+,(a1)+
0000E4D6 12DB                     M 	move.b	(a3)+,(a1)+
0000E4D8 12DB                     M 	move.b	(a3)+,(a1)+
0000E4DA 12DB                     M 	move.b	(a3)+,(a1)+
0000E4DC 12DB                     M 	move.b	(a3)+,(a1)+
0000E4DE 12DB                     M 	move.b	(a3)+,(a1)+
0000E4E0 12DB                     M 	move.b	(a3)+,(a1)+
0000E4E2 12DB                     M 	move.b	(a3)+,(a1)+
0000E4E4 12DB                     M 	move.b	(a3)+,(a1)+
0000E4E6 12DB                     M 	move.b	(a3)+,(a1)+
0000E4E8 12DB                     M 	move.b	(a3)+,(a1)+
0000E4EA 101B                       		move.b	(a3)+,d0
0000E4EC 5200                       		addq.b	#1,d0
0000E4EE 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchHigh+1
0000E4F4 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM2_PitchLow+1
0000E4FA 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0000E502                            
0000E502 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0000E50A                            	StartZ80				; enable Z80 execution
0000E50A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E512 4E75                       		rts
0000E514                            
0000E514                            ; ---------------------------------------------------------------------------
0000E514                            
0000E514                            PlayDAC1:
0000E514 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1
0000E51A                            	StopZ80					; wait for Z80 to stop
0000E51A 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E522                          M 	waitz80stop
0000E522 0839 0000 00A1 1100      M .wait_535:	btst	#0,z80_bus_req
0000E52A 66F6                     M 	bne.s	.wait_535
0000E52C                            	rept 12
0000E52C                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E52C                            	endr
0000E52C 12DB                     M 	move.b	(a3)+,(a1)+
0000E52E 12DB                     M 	move.b	(a3)+,(a1)+
0000E530 12DB                     M 	move.b	(a3)+,(a1)+
0000E532 12DB                     M 	move.b	(a3)+,(a1)+
0000E534 12DB                     M 	move.b	(a3)+,(a1)+
0000E536 12DB                     M 	move.b	(a3)+,(a1)+
0000E538 12DB                     M 	move.b	(a3)+,(a1)+
0000E53A 12DB                     M 	move.b	(a3)+,(a1)+
0000E53C 12DB                     M 	move.b	(a3)+,(a1)+
0000E53E 12DB                     M 	move.b	(a3)+,(a1)+
0000E540 12DB                     M 	move.b	(a3)+,(a1)+
0000E542 12DB                     M 	move.b	(a3)+,(a1)+
0000E544 101B                       		move.b	(a3)+,d0
0000E546 5200                       		addq.b	#1,d0
0000E548 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchHigh+1
0000E54E 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM1_PitchLow+1
0000E554 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0000E55C                            
0000E55C 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0000E564                            	StartZ80				; enable Z80 execution
0000E564 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E56C 4E75                       		rts
0000E56E                            ; ===========================================================================
0000E56E                            ; ---------------------------------------------------------------------------
0000E56E                            ; Handle Dual PCM YM Cue correctly
0000E56E                            ; ---------------------------------------------------------------------------
0000E56E                            
0000E56E                            UpdateAMPS:
0000E56E                            	StopZ80					; wait for Z80 to stop
0000E56E 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E576                          M 	waitz80stop
0000E576 0839 0000 00A1 1100      M .wait_538:	btst	#0,z80_bus_req
0000E57E 66F6                     M 	bne.s	.wait_538
0000E580 1039 0000 0000             		move.b	dZ80+YM_Buffer,d0	; load current cue buffer in use
0000E586                            	StartZ80				; enable Z80 execution
0000E586 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E58E                            
0000E58E 207C 0000 0000             		move.l	#dZ80+YM_Buffer1,a0	; set the cue address to buffer 1
0000E594 4A00                       		tst.b	d0			; check buffer to use
0000E596 6600                       		bne.s	.gotbuffer		; if Z80 is reading buffer 2, branch
0000E598 D0FC 0000                  		add.w	#YM_Buffer2-YM_Buffer1,a0; set the cue address to buffer 2
0000E59C                            
0000E59C                            .gotbuffer
0000E59C 6100                       		bsr.s	dUpdateAllAMPS		; process the driver
0000E59E                            		AMPS_Debug_CuePtr 3		; check if the cue is still valid
0000E59E B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000E5A4 6500                     M 	blo.s	.fail_540
0000E5A6 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000E5AC 6500                     M 	blo.s	.ok_540
0000E5AE                          M .fail_540
0000E5AE 4EBA FAB8                M 	jsr	amps_debug_cueptr3
0000E5B2                          M .ok_540
0000E5B2                            
0000E5B2                            	StopZ80					; wait for Z80 to stop
0000E5B2 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E5BA                          M 	waitz80stop
0000E5BA 0839 0000 00A1 1100      M .wait_542:	btst	#0,z80_bus_req
0000E5C2 66F6                     M 	bne.s	.wait_542
0000E5C4 50D0                       		st	(a0)			; make sure cue is marked as completed
0000E5C6                            	StartZ80				; enable Z80 execution
0000E5C6 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E5CE                            
0000E5CE                            dPaused:
0000E5CE 4E75                       		rts
0000E5D0                            ; ===========================================================================
0000E5D0                            ; ---------------------------------------------------------------------------
0000E5D0                            ; Main routine for updating the AMPS driver
0000E5D0                            ; ---------------------------------------------------------------------------
0000E5D0                            
0000E5D0                            dUpdateAllAMPS:
0000E5D0 4EBA 0000                  		jsr	dPlaySnd(pc)		; check if any music needs playing
0000E5D4 4A38 C4A6                  		tst.b	mFlags.w		; is music paused?
0000E5D8 6BF4                       		bmi.s	dPaused			; if yes, branch
0000E5DA                            ; ---------------------------------------------------------------------------
0000E5DA                            ; This is the new fading feature I created, to make custom fading
0000E5DA                            ; types easier to program. You can define series of 3 bytes, each
0000E5DA                            ; representing FM, PSG and DAC volumes. Each group of 3 is executed
0000E5DA                            ; once per frame. If the first value in a frame is a command flag,
0000E5DA                            ; instead its code is executed. Additionally, no fade program may
0000E5DA                            ; appear before ROM offset $10000, or else it will never be executed.
0000E5DA                            ; ---------------------------------------------------------------------------
0000E5DA                            
0000E5DA 4A38 C4B5                  .notempo	tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0000E5DE 6700 0000                  		beq.w	.chkregion		; branch if not
0000E5E2                            
0000E5E2 2278 C4B4                  		move.l	mFadeAddr.w,a1		; get the fade porogram address to a1
0000E5E6 56B8 C4B4                  		addq.l	#3,mFadeAddr.w		; set the fade address to next group
0000E5EA                            
0000E5EA 7220                       		moveq	#(1<<cfbVol),d1		; prepare volume update to d1
0000E5EC 7000                       		moveq	#0,d0
0000E5EE 1019                       		move.b	(a1)+,d0		; get FM/command byte from fade data
0000E5F0 6A00                       		bpl.s	.nofadeend		; branch if this is not a command
0000E5F2                            
0000E5F2                            		AMPS_Debug_FadeCmd		; check if this command is valid
0000E5F2 0C00 0090                M 	cmp.b	#flast,d0
0000E5F6 6400                     M 	bhs.s	.fail
0000E5F8 0C00 0080                M 	cmp.b	#$80,d0
0000E5FC 6500                     M 	blo.s	.fail
0000E5FE 0800 0001                M 	btst	#1,d0
0000E602 6600                     M 	bne.s	.fail
0000E604 0800 0000                M 	btst	#0,d0
0000E608 6700                     M 	beq.s	.ok
0000E60A                          M .fail
0000E60A 4EBA F8B2                M 	jsr	amps_debugr_fadecmd
0000E60E                          M .ok
0000E60E 45FA 0000                  		lea	dFadeCommands-$80(pc),a2; load fade commands pointer table to a2
0000E612 4EB2 0000                  		jsr	(a2,d0.w)		; run the fade command code
0000E616 4238 C4B5                  		clr.b	mFadeAddr+1.w		; mark the fade program as completed
0000E61A 6000                       		bra.s	.chkregion		; go check the region
0000E61C                            
0000E61C                            .nofadeend
0000E61C B038 C4B4                  		cmp.b	mMasterVolFM.w,d0	; check if volume did not change
0000E620 6700                       		beq.s	.fadedac		; if did not, branch
0000E622 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save the new volume
0000E626 4EBA 0000                  		jsr	dReqVolUpFM(pc)		; go request volume update for FM
0000E62A                            
0000E62A                            .fadedac
0000E62A 1019                       		move.b	(a1)+,d0		; get DAC volume byte from fade data
0000E62C B038 C4C0                  		cmp.b	mMasterVolDAC.w,d0	; check if volume did not change
0000E630 6700                       		beq.s	.fadepsg		; if did not, branch
0000E632 11C0 C4C0                  		move.b	d0,mMasterVolDAC.w	; save new volume
0000E636                            
0000E636 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0000E636                            	rept Mus_DAC				; do for all music DAC channels
0000E636                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E636                            .ch =		.ch+cSize			; go to next channel
0000E636                            	endr
0000E636 8338 C4C4                M 	or.b	d1,.ch.w
0000E63A =FFFFC4F0                M .ch	=	.ch+csize
0000E63A 8338 C4F0                M 	or.b	d1,.ch.w
0000E63E =FFFFC51C                M .ch	=	.ch+csize
0000E63E 8338 C67C                  		or.b	d1,mSFXDAC1.w		; tell SFX DAC1 to update its volume
0000E642                            
0000E642                            .fadepsg
0000E642 1019                       		move.b	(a1)+,d0		; get PSG volume byte from fade data
0000E644 B038 C4BF                  		cmp.b	mMasterVolPSG.w,d0	; check if volume did not change
0000E648 6700                       		beq.s	.chkregion		; if did not, branch
0000E64A 11C0 C4BF                  		move.b	d0,mMasterVolPSG.w	; save new volume
0000E64E                            
0000E64E =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0000E64E                            	rept Mus_PSG				; do for all music PSG channels
0000E64E                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E64E                            .ch =		.ch+cSize			; go to next channel
0000E64E                            	endr
0000E64E 8338 C5F8                M 	or.b	d1,.ch.w
0000E652 =FFFFC624                M .ch	=	.ch+csize
0000E652 8338 C624                M 	or.b	d1,.ch.w
0000E656 =FFFFC650                M .ch	=	.ch+csize
0000E656 8338 C650                M 	or.b	d1,.ch.w
0000E65A =FFFFC67C                M .ch	=	.ch+csize
0000E65A                            
0000E65A =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0000E65A                            	rept SFX_PSG				; do for all SFX PSG channels
0000E65A                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E65A                            .ch =		.ch+cSizeSFX			; go to next channel
0000E65A                            	endr
0000E65A 8338 C6EC                M 	or.b	d1,.ch.w
0000E65E =FFFFC708                M .ch	=	.ch+csizesfx
0000E65E 8338 C708                M 	or.b	d1,.ch.w
0000E662 =FFFFC724                M .ch	=	.ch+csizesfx
0000E662 8338 C724                M 	or.b	d1,.ch.w
0000E666 =FFFFC740                M .ch	=	.ch+csizesfx
0000E666                            ; ---------------------------------------------------------------------------
0000E666                            ; Since PAL Mega Drive's run slower than NTSC, if we want the music to
0000E666                            ; sound consistent, we need to run the sound driver 1.2 times as fast
0000E666                            ; on PAL systems. This will cause issues with some songs that rely on
0000E666                            ; game engine to seem "in sync". Because of that, I added a flag to
0000E666                            ; disable the PAL fix (much like in Sonic 2's driver). Unlike the fix
0000E666                            ; in SMPS drivers (and Sonic 3 and above), this fix will make the music
0000E666                            ; play at the exact right speed, instead of slightly too slow.
0000E666                            ; ---------------------------------------------------------------------------
0000E666                            
0000E666 0838 0006 C746             .chkregion	btst	#6,hwVersion.w	; is this PAL system?
0000E66C 6700                       		beq.s	.driver			; if not, branch
0000E66E 5338 C4A7                  		subq.b	#1,mCtrPal.w		; decrease PAL frame counter
0000E672 6E00                       		bgt.s	.driver			; if hasn't become 0 (or lower!), branch
0000E674                            
0000E674 0838 0003 C4A6             		btst	#mfbNoPAL,mFlags.w	; check if we have disabled the PAL fix
0000E67A 6600                       		bne.s	.nofix			; if yes, run music and SFX
0000E67C 6100                       		bsr.s	.nosfx			; run the sound driver
0000E67E                            
0000E67E                            .nofix
0000E67E 11FC 0005 C4A7             		move.b	#6-1,mCtrPal.w		; reset counter
0000E684                            .driver
0000E684 6100 0000                  		bsr.w	dAMPSdoSFX		; run SFX this time
0000E688                            
0000E688                            .nosfx		; continue to run sound driver again
0000E688                            ; ---------------------------------------------------------------------------
0000E688                            ; There are 2 methods of handling tempo adjustments in SMPS,
0000E688                            ; overflow (where a value is added to the accumulator, and when it
0000E688                            ; range overflows, tick of delay is added), and counter (where a
0000E688                            ; counter is copied to the tempo, which is then decreased each frame,
0000E688                            ; until it becomes 0, after which a tick of delay is added). AMPS
0000E688                            ; supports these both too, because there is no single right answer,
0000E688                            ; and users may prefer one over the other. The overflow method is
0000E688                            ; really good for low values, as it provides very fine control over
0000E688                            ; the tempo, but at high ranges it gets worse. Meanwhile the counter
0000E688                            ; method isn't as good for small values, but for large value it works
0000E688                            ; better. You may choose this setting in the macro.asm file,
0000E688                            ; ---------------------------------------------------------------------------
0000E688                            
0000E688 1038 C4BA                  		move.b	mTempo.w,d0		; get tempo to d0
0000E68C D138 C4BB                  		add.b	d0,mTempoCur.w		; add to accumulator
0000E690 6400                       		bcc.s	dAMPSdoAll		; if carry clear, branch
0000E692                            
0000E692                            
0000E692 =FFFFC4D0                  .ch =	mDAC1+cDuration				; start at DAC1 duration
0000E692                            	rept Mus_Ch				; loop through all music channels
0000E692                            		addq.b	#1,.ch.w		; add 1 to duration
0000E692                            .ch =		.ch+cSize			; go to next channel
0000E692                            	endr
0000E692 5238 C4D0                M 	addq.b	#1,.ch.w
0000E696 =FFFFC4FC                M .ch	=	.ch+csize
0000E696 5238 C4FC                M 	addq.b	#1,.ch.w
0000E69A =FFFFC528                M .ch	=	.ch+csize
0000E69A 5238 C528                M 	addq.b	#1,.ch.w
0000E69E =FFFFC554                M .ch	=	.ch+csize
0000E69E 5238 C554                M 	addq.b	#1,.ch.w
0000E6A2 =FFFFC580                M .ch	=	.ch+csize
0000E6A2 5238 C580                M 	addq.b	#1,.ch.w
0000E6A6 =FFFFC5AC                M .ch	=	.ch+csize
0000E6A6 5238 C5AC                M 	addq.b	#1,.ch.w
0000E6AA =FFFFC5D8                M .ch	=	.ch+csize
0000E6AA 5238 C5D8                M 	addq.b	#1,.ch.w
0000E6AE =FFFFC604                M .ch	=	.ch+csize
0000E6AE 5238 C604                M 	addq.b	#1,.ch.w
0000E6B2 =FFFFC630                M .ch	=	.ch+csize
0000E6B2 5238 C630                M 	addq.b	#1,.ch.w
0000E6B6 =FFFFC65C                M .ch	=	.ch+csize
0000E6B6 5238 C65C                M 	addq.b	#1,.ch.w
0000E6BA =FFFFC688                M .ch	=	.ch+csize
0000E6BA                            ; ===========================================================================
0000E6BA                            ; ---------------------------------------------------------------------------
0000E6BA                            ; Process music DAC channels
0000E6BA                            ; ---------------------------------------------------------------------------
0000E6BA                            
0000E6BA                            dAMPSdoAll:
0000E6BA 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0000E6BE 4BF8 C498                  		lea	mDAC1-cSize.w,a5	; get DAC1 channel RAM address into a5
0000E6C2 7E01                       		moveq	#Mus_DAC-1,d7		; get total number of DAC channels to d7
0000E6C4                            
0000E6C4                            dAMPSdoDAC:
0000E6C4 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel (first time its mDAC1!)
0000E6C8 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000E6CA 6A00 0000                  		bpl.w	.next			; if not, branch
0000E6CE 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000E6D2 6700 0000                  		beq.w	.update			; if timed out, update channel
0000E6D6                            	dNoteToutDAC	 			; handle DAC-specific note timeout behavior
0000E6D6                          M 	dnotetouthandler
0000E6D6 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000E6DA 6700                     M 	beq.s	.endt
0000E6DC 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000E6E0 6600                     M 	bne.s	.endt
0000E6E2 7000                     M 	moveq	#0,d0
0000E6E4 6000 0000                M 	bra.w	dnoteondac2
0000E6E8                          M .endt
0000E6E8                            
0000E6E8                            	dCalcFreq				; calculate channel base frequency
0000E6E8 1C2D 0007                M 	move.b	cdetune(a5),d6
0000E6EC 4886                     M 	ext.w	d6
0000E6EE DC6D 000E                M 	add.w	cfreq(a5),d6
0000E6F2                            	dModulate dAMPSdoFM, dAMPSdoDAC, 4	; run modulation code
0000E6F2 0815 0003                M 	btst	#cfbmod,(a5)
0000E6F6 6700                     M 	beq.s	.noret
0000E6F8 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000E6FC 6700                     M 	beq.s	.started
0000E6FE 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000E702                          M .noret
0000E702 0895 0005                M 	bclr	#cfbvol,(a5)
0000E706 6700                     M 	beq.s	.noupdatevol
0000E708 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0000E70C                          M 	.noupdatevol:
0000E70C 51CF FFB6                M 	dbf	d7,dampsdodac
0000E710 6000 0000                M 	bra.w	dampsdofm
0000E714                          M .started
0000E714 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000E718 66E8                     M 	bne.s	.noret
0000E71A 226D 0010                M 	movea.l	cmod(a5),a1
0000E71E 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000E724 4A2D 0018                M 	tst.b	cmodcount(a5)
0000E728 6600                     M 	bne.s	.norev
0000E72A 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000E730 442D 0017                M 	neg.b	cmodstep(a5)
0000E734                          M .norev
0000E734 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000E738 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000E73C 4885                     M 	ext.w	d5
0000E73E DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000E742 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000E746 DC45                     M 	add.w	d5,d6
0000E748 6100 0000                  		bsr.w	dUpdateFreqDAC		; if frequency needs changing, do it
0000E74C                            
0000E74C 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000E750 6700                       		beq.s	.next			; if not, skip
0000E752 6100 0000                  		bsr.w	dUpdateVolDAC		; update DAC volume
0000E756                            
0000E756                            .next
0000E756 51CF FF6C                  		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0000E75A 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process music FM channels
0000E75E                            
0000E75E                            .update
0000E75E 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0000E762                            	dDoTracker				; process tracker
0000E762 286D 0002                M 	movea.l	cdata(a5),a4
0000E766                          M 	amps_debug_trackupd
0000E766 220C                     M 	move.l	a4,d1
0000E768 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000E76E 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000E774 6500                     M 	blo.s	.fail2
0000E776 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000E77C 6500                     M 	blo.s	.data
0000E77E                          M .fail2
0000E77E                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E77E 487A FFFE                M 	pea	*(pc)
0000E782                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E782 40E7                     M 	move.w	sr,-(sp)
0000E784                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E784 =00000000                M 	__stack:set	0
0000E784 =00000000                M 	__sp:	set 0
0000E784                          M 	while	(__pos)
0000E784 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E784 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E784 =00000021                M 	__midpos:	= __endpos
0000E784                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784                          M 	pushp	"move.l a4,-(sp)"
0000E784 =00000001                M 	__stack:	= __stack+1
0000E784 =00000004                M 	__sp:	= __sp+4
0000E784 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E784 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E784 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E784 =00000029                M 	__midpos:	= __endpos
0000E784                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E784 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E784 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E784                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E784                          M 	pushp	"move.l a4,-(sp)"
0000E784 =00000002                M 	__stack:	= __stack+1
0000E784 =00000008                M 	__sp:	= __sp+4
0000E784 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E784                          M 	rept	__stack
0000E784                          M 	popp	__command
0000E784 2F0C                     M 	move.l	a4,-(sp)
0000E786                          M 	popp	__command
0000E786 2F0C                     M 	move.l	a4,-(sp)
0000E788 4EB9 0000 0000           M 	jsr	errorhandler
0000E78E                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E78E =00000001                M 	__lpos:	set 1
0000E78E =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E78E                          M 	while	(__pos)
0000E78E                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E78E 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000E7A7 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E7A7 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E7A7 =00000021                M 	__midpos:	= __endpos
0000E7A7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E7A7                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E7A7                          M 	__param:	substr ,,"hex"
0000E7A7 83                       M 	dc.b	hex|3
0000E7A8 =00000022                M 	__lpos:	set __endpos+1
0000E7A8 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E7A8                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E7A8                          M 	dc.b	""
0000E7A8 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E7A8 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E7A8 =00000029                M 	__midpos:	= __endpos
0000E7A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E7A8                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E7A8 E0                       M 	dc.b	fendl
0000E7A9 =0000002A                M 	__lpos:	set __endpos+1
0000E7A9 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E7A9                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E7A9                          M 	dc.b	""
0000E7A9 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E7A9 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E7A9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E7A9                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E7A9 B3                       M 	dc.b	sym|3
0000E7AA =00000036                M 	__lpos:	set __endpos+1
0000E7AA =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E7AA                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E7AA                          M 	dc.b	""
0000E7AA 00                       M 	dc.b	0
0000E7AB 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E7AC                          M 	even
0000E7AC 4EFA EB0A                M 	jmp	amps_debug_console_channel
0000E7B0                          M 	even
0000E7B0                          M .data
0000E7B0 7A00                     M 	moveq	#0,d5
0000E7B2 1A1C                     M 	move.b	(a4)+,d5
0000E7B4 0C05 00E0                M 	cmpi.b	#$e0,d5
0000E7B8 6500                     M 	blo.s	.notcomm
0000E7BA 4EBA 0000                M 	jsr	dcommands(pc)
0000E7BE 60F0                     M 	bra.s	.data
0000E7C0 6094                     M 	bra.s	.next
0000E7C2                          M .notcomm
0000E7C2 7C00                       		moveq	#0,d6			; clear rest flag
0000E7C4 4A05                       		tst.b	d5			; check if note is being played
0000E7C6 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000E7C8                            
0000E7C8                            	dTrackNoteDAC				; calculate frequency or update sample
0000E7C8 0815 0000                M 	btst	#cfbmode,(a5)
0000E7CC 6600                     M 	bne.s	.pitch
0000E7CE 1B45 000B                M 	move.b	d5,csample(a5)
0000E7D2 6000                     M 	bra.s	.cont
0000E7D4                          M .pitch
0000E7D4 0405 0080                M 	subi.b	#$80,d5
0000E7D8 6600                     M 	bne.s	.noprest
0000E7DA 7000                     M 	moveq	#0,d0
0000E7DC 6100 0000                M 	bsr.w	dnoteondac2
0000E7E0 7C80                     M 	moveq	#-$80,d6
0000E7E2 6000                     M 	bra.s	.cont
0000E7E4                          M .noprest
0000E7E4 DA2D 0008                M 	add.b	cpitch(a5),d5
0000E7E8 DA45                     M 	add.w	d5,d5
0000E7EA 43FA 0000                M 	lea	dfreqdac(pc),a1
0000E7EE 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0000E7F4                          M .cont
0000E7F4 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000E7F6 6A00                       		bpl.s	.timer			; if yes, handle timer
0000E7F8 534C                       		subq.w	#1,a4			; else, undo the increment
0000E7FA 6000                       		bra.s	.pcnote			; do not calculate duration
0000E7FC                            
0000E7FC                            .timer
0000E7FC 4EBA 0000                  		jsr	dCalcDuration(pc)	; calculate duration
0000E800                            .pcnote
0000E800                            	dProcNote 0, 0				; reset necessary channel memory
0000E800 2B4C 0002                M 	move.l	a4,cdata(a5)
0000E804 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000E80A 0815 0002                M 	btst	#cfbhold,(a5)
0000E80E 6600                     M 	bne.s	.endpn
0000E810 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000E816 0815 0003                M 	btst	#cfbmod,(a5)
0000E81A 6700                     M 	beq.s	.endpn
0000E81C 226D 0010                M 	movea.l	cmod(a5),a1
0000E820 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000E824 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000E828 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000E82C 1011                     M 	move.b	(a1),d0
0000E82E E208                     M 	lsr.b	#1,d0
0000E830 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000E834 426D 0014                M 	clr.w	cmodfreq(a5)
0000E838                          M .endpn
0000E838                            
0000E838 4A06                       		tst.b	d6			; check if channel was resting
0000E83A 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0000E83C 6100                       		bsr.s	dNoteOnDAC		; do hardware note-on behavior
0000E83E                            
0000E83E 51CF FE84                  .noplay		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0000E842 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process FM channels
0000E846                            ; ===========================================================================
0000E846                            ; ---------------------------------------------------------------------------
0000E846                            ; Write DAC sample information to Dual PCM
0000E846                            ; ---------------------------------------------------------------------------
0000E846                            
0000E846                            dNoteOnDAC2:
0000E846 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E84A 6700                       		beq.s	dNoteOnDAC3		; if not, process note
0000E84C 4E75                       		rts
0000E84E                            
0000E84E                            dNoteOnDAC:
0000E84E 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E852 6600                       		bne.s	locret_dNoteOnDAC4	; if so, do not note on or update frequency
0000E854                            
0000E854 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0000E856 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0000E85A 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0000E85E 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0000E862 6600 0000                  		bne.w	dUpdateFreqOffDAC2	; if so, only update frequency
0000E866                            
0000E866                            dNoteOnDAC3:
0000E866 E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0000E868 47F6 0000                  		lea	(a6,d0.w),a3		; get sample data to a3
0000E86C                            
0000E86C 487A 0000                  		pea	dUpdateFreqOffDAC(pc)	; update frequency after loading sample
0000E870 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0000E876 6700                       		beq.s	dNoteWriteDAC1		; if is, branch
0000E878                            ; ---------------------------------------------------------------------------
0000E878                            ; This code is for updating the note to Dual PCM. We have tracker commands
0000E878                            ; for also playing notes on DAC channels, which is why the code seems a
0000E878                            ; little weird.
0000E878                            ; ---------------------------------------------------------------------------
0000E878                            
0000E878                            dNoteWriteDAC2:
0000E878 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0000E87E 45F9 0000 0000             		lea	dZ80+PCM2_NewRET,a2	; ''
0000E884 6000                       		bra.s	dNoteOnDAC4
0000E886                            
0000E886                            dNoteWriteDAC1:
0000E886                            
0000E886 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 2
0000E88C 45F9 0000 0000             		lea	dZ80+PCM1_NewRET,a2	; ''
0000E892                            
0000E892                            dNoteOnDAC4:
0000E892                            	StopZ80					; wait for Z80 to stop
0000E892 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E89A                          M 	waitz80stop
0000E89A 0839 0000 00A1 1100      M .wait_558:	btst	#0,z80_bus_req
0000E8A2 66F6                     M 	bne.s	.wait_558
0000E8A4                            	rept 12
0000E8A4                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E8A4                            	endr
0000E8A4 12DB                     M 	move.b	(a3)+,(a1)+
0000E8A6 12DB                     M 	move.b	(a3)+,(a1)+
0000E8A8 12DB                     M 	move.b	(a3)+,(a1)+
0000E8AA 12DB                     M 	move.b	(a3)+,(a1)+
0000E8AC 12DB                     M 	move.b	(a3)+,(a1)+
0000E8AE 12DB                     M 	move.b	(a3)+,(a1)+
0000E8B0 12DB                     M 	move.b	(a3)+,(a1)+
0000E8B2 12DB                     M 	move.b	(a3)+,(a1)+
0000E8B4 12DB                     M 	move.b	(a3)+,(a1)+
0000E8B6 12DB                     M 	move.b	(a3)+,(a1)+
0000E8B8 12DB                     M 	move.b	(a3)+,(a1)+
0000E8BA 12DB                     M 	move.b	(a3)+,(a1)+
0000E8BC                            
0000E8BC 14BC 00DA                  		move.b	#$DA,(a2)		; activate sample switch (change instruction)
0000E8C0                            	StartZ80				; enable Z80 execution
0000E8C0 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E8C8                            
0000E8C8                            locret_dNoteOnDAC4:
0000E8C8 4E75                       		rts
0000E8CA                            ; ===========================================================================
0000E8CA                            ; ---------------------------------------------------------------------------
0000E8CA                            ; Write DAC frequency to Dual PCM
0000E8CA                            ; ---------------------------------------------------------------------------
0000E8CA                            
0000E8CA                            dUpdateFreqOffDAC2:
0000E8CA E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0000E8CC 47F6 000C                  		lea	$0C(a6,d0.w),a3		; get sample pitch to a3
0000E8D0                            
0000E8D0                            dUpdateFreqOffDAC:
0000E8D0 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0000E8D4 DC5B                       		add.w	(a3)+,d6		; add sample frequency offset to d6
0000E8D6                            
0000E8D6 102D 0007                  		move.b	cDetune(a5),d0		; get detune value
0000E8DA 4880                       		ext.w	d0			; extend to word
0000E8DC DC40                       		add.w	d0,d6			; add it to d6
0000E8DE                            
0000E8DE 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0000E8E2 6700                       		beq.s	dUpdateFreqDAC3		; if not, branch
0000E8E4 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0000E8E8 6000                       		bra.s	dUpdateFreqDAC3
0000E8EA                            
0000E8EA                            dUpdateFreqDAC:
0000E8EA 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E8EE 6600                       		bne.s	locret_UpdFreqDAC	; if so, branch
0000E8F0                            
0000E8F0                            dUpdateFreqDAC2:
0000E8F0 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0000E8F2 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0000E8F6 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0000E8FA E948                       		lsl.w	#4,d0			; multiply ID by $10 (size of each entry)
0000E8FC DC76 000C                  		add.w	$0C(a6,d0.w),d6		; add sample frequency offset to d6
0000E900                            
0000E900                            dUpdateFreqDAC3:
0000E900                            		AMPS_Debug_FreqDAC		; check if DAC frequency is in bounds
0000E900 0C46 1000                M 	cmp.w	#maxpitch,d6
0000E904 6E00                     M 	bgt.s	.fail
0000E906 0C46 F000                M 	cmp.w	#-maxpitch,d6
0000E90A 6C00                     M 	bge.s	.ok
0000E90C                          M .fail
0000E90C 4EBA F664                M 	jsr	amps_debugr_freqdac
0000E910                          M .ok
0000E910                            
0000E910 1006                       		move.b	d6,d0			; copy the frequency to d0
0000E912 E04E                       		lsr.w	#8,d6			; get the upper byte to the lower byte
0000E914 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if DAC1
0000E91A 6700                       		beq.s	dFreqDAC1		; if is, branch
0000E91C                            
0000E91C                            	StopZ80					; wait for Z80 to stop
0000E91C 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E924                          M 	waitz80stop
0000E924 0839 0000 00A1 1100      M .wait_562:	btst	#0,z80_bus_req
0000E92C 66F6                     M 	bne.s	.wait_562
0000E92E 13C6 0000 0000             		move.b	d6,dZ80+PCM2_PitchHigh+1
0000E934 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchLow+1
0000E93A 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0000E942                            	StartZ80				; enable Z80 execution
0000E942 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E94A                            
0000E94A                            locret_UpdFreqDAC;
0000E94A 4E75                       		rts
0000E94C                            
0000E94C                            dFreqDAC1:
0000E94C                            	StopZ80					; wait for Z80 to stop
0000E94C 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E954                          M 	waitz80stop
0000E954 0839 0000 00A1 1100      M .wait_565:	btst	#0,z80_bus_req
0000E95C 66F6                     M 	bne.s	.wait_565
0000E95E 13C6 0000 0000             		move.b	d6,dZ80+PCM1_PitchHigh+1
0000E964 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchLow+1
0000E96A 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0000E972                            	StartZ80				; enable Z80 execution
0000E972 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E97A 4E75                       		rts
0000E97C                            ; ===========================================================================
0000E97C                            ; ---------------------------------------------------------------------------
0000E97C                            ; Routine to multiply duration by tick rate
0000E97C                            ; We actually use a dbf loop instead of mulu, because 2 rounds
0000E97C                            ; around the loop will be faster than a single mulu instruction
0000E97C                            ; ---------------------------------------------------------------------------
0000E97C                            
0000E97C                            dCalcDuration:
0000E97C 7000                       		moveq	#0,d0			; clear duration
0000E97E 7200                       		moveq	#0,d1			; clear upper bytes (for dbf)
0000E980 122D 000A                  		move.b	cTick(a5),d1		; get tick multiplier to d1
0000E984                            
0000E984 D005                       .multiply	add.b	d5,d0			; add duration value to d0
0000E986 51C9 FFFC                  		dbf	d1,.multiply		; multiply by tick rate
0000E98A                            
0000E98A 1B40 000D                  		move.b	d0,cLastDur(a5)		; save as the new duration
0000E98E 4E75                       		rts				; get copied to duration by later code
0000E990                            ; ===========================================================================
0000E990                            ; ---------------------------------------------------------------------------
0000E990                            ; Process SFX DAC channels
0000E990                            ; ---------------------------------------------------------------------------
0000E990                            
0000E990                            dAMPSdoSFX:
0000E990 4BF8 C660                  		lea	mSFXDAC1-cSizeSFX.w,a5	; get SFX DAC1 channel RAM address into a5
0000E994                            
0000E994                            dAMPSdoDACSFX:
0000E994 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000E998 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000E99A 6A00                       		bpl.s	.next			; if not, branch
0000E99C                            
0000E99C 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0000E9A0 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000E9A4 6700 0000                  		beq.w	.update			; if timed out, update channel
0000E9A8                            
0000E9A8                            	dCalcFreq				; calculate channel base frequency
0000E9A8 1C2D 0007                M 	move.b	cdetune(a5),d6
0000E9AC 4886                     M 	ext.w	d6
0000E9AE DC6D 000E                M 	add.w	cfreq(a5),d6
0000E9B2                            	dModulate dAMPSdoFMSFX, dAMPSdoDAC, 5	; run modulation code
0000E9B2 0815 0003                M 	btst	#cfbmod,(a5)
0000E9B6 6700                     M 	beq.s	.noret
0000E9B8 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000E9BC 6700                     M 	beq.s	.started
0000E9BE 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000E9C2                          M .noret
0000E9C2 0895 0005                M 	bclr	#cfbvol,(a5)
0000E9C6 6700                     M 	beq.s	.noupdatevol
0000E9C8 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0000E9CC                          M 	.noupdatevol:
0000E9CC 6000 0000                M 	bra.w	dampsdofmsfx
0000E9D0                          M .started
0000E9D0 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000E9D4 66EC                     M 	bne.s	.noret
0000E9D6 226D 0010                M 	movea.l	cmod(a5),a1
0000E9DA 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000E9E0 4A2D 0018                M 	tst.b	cmodcount(a5)
0000E9E4 6600                     M 	bne.s	.norev
0000E9E6 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000E9EC 442D 0017                M 	neg.b	cmodstep(a5)
0000E9F0                          M .norev
0000E9F0 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000E9F4 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000E9F8 4885                     M 	ext.w	d5
0000E9FA DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000E9FE 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000EA02 DC45                     M 	add.w	d5,d6
0000EA04 6100 FEEA                  		bsr.w	dUpdateFreqDAC2		; if frequency needs changing, do it
0000EA08                            
0000EA08 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000EA0C 6700                       		beq.s	.next			; if not, skip
0000EA0E 6100 0000                  		bsr.w	dUpdateVolDAC2		; update DAC volume
0000EA12                            
0000EA12                            .next
0000EA12 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0000EA16                            
0000EA16                            .update
0000EA16 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0000EA1A                            	dDoTracker				; process tracker
0000EA1A 286D 0002                M 	movea.l	cdata(a5),a4
0000EA1E                          M 	amps_debug_trackupd
0000EA1E 220C                     M 	move.l	a4,d1
0000EA20 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000EA26 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000EA2C 6500                     M 	blo.s	.fail2
0000EA2E 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000EA34 6500                     M 	blo.s	.data
0000EA36                          M .fail2
0000EA36                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000EA36 487A FFFE                M 	pea	*(pc)
0000EA3A                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000EA3A 40E7                     M 	move.w	sr,-(sp)
0000EA3C                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA3C =00000000                M 	__stack:set	0
0000EA3C =00000000                M 	__sp:	set 0
0000EA3C                          M 	while	(__pos)
0000EA3C =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA3C =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA3C =00000021                M 	__midpos:	= __endpos
0000EA3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C                          M 	pushp	"move.l a4,-(sp)"
0000EA3C =00000001                M 	__stack:	= __stack+1
0000EA3C =00000004                M 	__sp:	= __sp+4
0000EA3C =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA3C =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA3C =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA3C =00000029                M 	__midpos:	= __endpos
0000EA3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA3C =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA3C =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA3C                          M 	pushp	"move.l a4,-(sp)"
0000EA3C =00000002                M 	__stack:	= __stack+1
0000EA3C =00000008                M 	__sp:	= __sp+4
0000EA3C =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA3C                          M 	rept	__stack
0000EA3C                          M 	popp	__command
0000EA3C 2F0C                     M 	move.l	a4,-(sp)
0000EA3E                          M 	popp	__command
0000EA3E 2F0C                     M 	move.l	a4,-(sp)
0000EA40 4EB9 0000 0000           M 	jsr	errorhandler
0000EA46                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA46 =00000001                M 	__lpos:	set 1
0000EA46 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA46                          M 	while	(__pos)
0000EA46                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA46 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000EA5F =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA5F =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA5F =00000021                M 	__midpos:	= __endpos
0000EA5F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA5F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA5F                          M 	__param:	substr ,,"hex"
0000EA5F 83                       M 	dc.b	hex|3
0000EA60 =00000022                M 	__lpos:	set __endpos+1
0000EA60 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA60                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA60                          M 	dc.b	""
0000EA60 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA60 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA60 =00000029                M 	__midpos:	= __endpos
0000EA60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA60                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA60 E0                       M 	dc.b	fendl
0000EA61 =0000002A                M 	__lpos:	set __endpos+1
0000EA61 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA61                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA61                          M 	dc.b	""
0000EA61 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA61 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA61                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA61                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA61 B3                       M 	dc.b	sym|3
0000EA62 =00000036                M 	__lpos:	set __endpos+1
0000EA62 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA62                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA62                          M 	dc.b	""
0000EA62 00                       M 	dc.b	0
0000EA63 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EA64                          M 	even
0000EA64 4EFA E852                M 	jmp	amps_debug_console_channel
0000EA68                          M 	even
0000EA68                          M .data
0000EA68 7A00                     M 	moveq	#0,d5
0000EA6A 1A1C                     M 	move.b	(a4)+,d5
0000EA6C 0C05 00E0                M 	cmpi.b	#$e0,d5
0000EA70 6500                     M 	blo.s	.notcomm
0000EA72 4EBA 0000                M 	jsr	dcommands(pc)
0000EA76 60F0                     M 	bra.s	.data
0000EA78 6098                     M 	bra.s	.next
0000EA7A                          M .notcomm
0000EA7A 7C00                       		moveq	#0,d6			; clear rest flag
0000EA7C 4A05                       		tst.b	d5			; check if note is being played
0000EA7E 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000EA80                            
0000EA80                            	dTrackNoteDAC				; calculate frequency or update sample
0000EA80 0815 0000                M 	btst	#cfbmode,(a5)
0000EA84 6600                     M 	bne.s	.pitch
0000EA86 1B45 000B                M 	move.b	d5,csample(a5)
0000EA8A 6000                     M 	bra.s	.cont
0000EA8C                          M .pitch
0000EA8C 0405 0080                M 	subi.b	#$80,d5
0000EA90 6600                     M 	bne.s	.noprest
0000EA92 7000                     M 	moveq	#0,d0
0000EA94 6100 FDB0                M 	bsr.w	dnoteondac2
0000EA98 7C80                     M 	moveq	#-$80,d6
0000EA9A 6000                     M 	bra.s	.cont
0000EA9C                          M .noprest
0000EA9C DA2D 0008                M 	add.b	cpitch(a5),d5
0000EAA0 DA45                     M 	add.w	d5,d5
0000EAA2 43FA 0000                M 	lea	dfreqdac(pc),a1
0000EAA6 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0000EAAC                          M .cont
0000EAAC 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000EAAE 6A00                       		bpl.s	.timer			; if yes, handle timer
0000EAB0 534C                       		subq.w	#1,a4			; else, undo the increment
0000EAB2 6000                       		bra.s	.pcnote			; do not calculate duration
0000EAB4                            
0000EAB4                            .timer
0000EAB4 4EBA FEC6                  		jsr	dCalcDuration(pc)	; calculate duration
0000EAB8                            .pcnote
0000EAB8                            	dProcNote 1, 0				; reset necessary channel memory
0000EAB8 2B4C 0002                M 	move.l	a4,cdata(a5)
0000EABC 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000EAC2 0815 0002                M 	btst	#cfbhold,(a5)
0000EAC6 6600                     M 	bne.s	.endpn
0000EAC8 0815 0003                M 	btst	#cfbmod,(a5)
0000EACC 6700                     M 	beq.s	.endpn
0000EACE 226D 0010                M 	movea.l	cmod(a5),a1
0000EAD2 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000EAD6 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000EADA 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000EADE 1011                     M 	move.b	(a1),d0
0000EAE0 E208                     M 	lsr.b	#1,d0
0000EAE2 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000EAE6 426D 0014                M 	clr.w	cmodfreq(a5)
0000EAEA                          M .endpn
0000EAEA 4A06                       		tst.b	d6			; check if channel was resting
0000EAEC 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0000EAEE 6100 FD5E                  		bsr.w	dNoteOnDAC		; do hardware note-on behavior
0000EAF2                            
0000EAF2                            .noplay
0000EAF2 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0000EAF6                            ; ===========================================================================
0000EAF6                            ; ---------------------------------------------------------------------------
0000EAF6                            ; Write DAC volume to Dual PCM
0000EAF6                            ; ---------------------------------------------------------------------------
0000EAF6                            
0000EAF6                            dUpdateVolDAC:
0000EAF6 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000EAFA 6600                       		bne.s	locret_VolDAC		; if yes, do not update
0000EAFC                            
0000EAFC                            dUpdateVolDAC2:
0000EAFC 162D 0009                  		move.b	cVolume(a5),d3		; get channel volume to d3
0000EB00 D638 C4C0                  		add.b	mMasterVolDAC.w,d3	; add master volume to it
0000EB04 6A00                       		bpl.s	.gotvol			; if positive (in range), branch
0000EB06 7680                       		moveq	#$FFFFFF80,d3		; force volume to mute ($80 is the last valid volume)
0000EB08                            
0000EB08                            .gotvol
0000EB08                            	StopZ80					; wait for Z80 to stop
0000EB08 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000EB10                          M 	waitz80stop
0000EB10 0839 0000 00A1 1100      M .wait_578:	btst	#0,z80_bus_req
0000EB18 66F6                     M 	bne.s	.wait_578
0000EB1A 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM_ChangeVolume; set volume change flag
0000EB22                            
0000EB22 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0000EB28 6700                       		beq.s	.dac1			; if is, branch
0000EB2A 13C3 0000 0000             		move.b	d3,dZ80+PCM2_Volume+1	; save volume for PCM 1
0000EB30                            	StartZ80				; enable Z80 execution
0000EB30 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000EB38 4E75                       		rts
0000EB3A                            
0000EB3A                            .dac1
0000EB3A 13C3 0000 0000             		move.b	d3,dZ80+PCM1_Volume+1	; save volume for PCM 2
0000EB40                            	StartZ80				; enable Z80 execution
0000EB40 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000EB48                            
0000EB48                            locret_VolDAC:
0000EB48 4E75                       		rts
0000EB4A                            ; ===========================================================================
0000EB4A                            ; ---------------------------------------------------------------------------
0000EB4A                            ; Routine for unpausing the sound driver
0000EB4A                            ; ---------------------------------------------------------------------------
0000EB4A                            
0000EB4A                            dPlaySnd_Unpause:
0000EB4A 08B8 0007 C4A6             		bclr	#mfbPaused,mFlags.w	; unpause music
0000EB50 67F6                       		beq.s	locret_VolDAC		; if was already unpaused, skip
0000EB52                            ; ---------------------------------------------------------------------------
0000EB52                            ; The following code will reset the panning values for each running
0000EB52                            ; channel. It also makes sure that the channel is not interrupted
0000EB52                            ; by sound effects, and that each running sound effect channel gets
0000EB52                            ; updated. We do not handle key on's, since that could potentially
0000EB52                            ; cause issues if notes are half-done. The next time tracker plays
0000EB52                            ; notes, they start being audible again.
0000EB52                            ; ---------------------------------------------------------------------------
0000EB52                            
0000EB52 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0000EB56 7804                       		moveq	#Mus_FM-1,d4		; load the number of music FM channels to d4
0000EB58 762C                       		moveq	#cSize,d3		; get the size of each music channel to d3
0000EB5A                            
0000EB5A                            .musloop
0000EB5A 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0000EB5C 6A00                       		bpl.s	.skipmus		; if not, do not update
0000EB5E 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000EB62 6600                       		bne.s	.skipmus		; if is, do not update
0000EB64                            
0000EB64 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000EB66 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0000EB6A 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0000EB6E                            
0000EB6E                            .skipmus
0000EB6E DAC3                       		adda.w	d3,a5			; go to next channel
0000EB70 51CC FFE8                  		dbf	d4,.musloop		; repeat for all music FM channels
0000EB74                            
0000EB74 4BF8 C698                  		lea	mSFXFM3.w,a5		; start from SFX FM1 channel
0000EB78 7802                       		moveq	#SFX_FM-1,d4		; load the number of SFX FM channels to d4
0000EB7A 761C                       		moveq	#cSizeSFX,d3		; get the size of each SFX channel to d3
0000EB7C                            
0000EB7C                            .sfxloop
0000EB7C 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0000EB7E 6A00                       		bpl.s	.skipsfx		; if not, do not update
0000EB80                            
0000EB80 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000EB82 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0000EB86 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0000EB8A                            
0000EB8A                            .skipsfx
0000EB8A DAC3                       		adda.w  d3,a5			; go to next channel
0000EB8C 51CC FFEE                  		dbf     d4,.sfxloop		; repeat for all SFX FM channels
0000EB90                            ; ---------------------------------------------------------------------------
0000EB90                            ; Since the DAC channels have or based panning behavior, we need this
0000EB90                            ; piece of code to update its panning
0000EB90                            ; ---------------------------------------------------------------------------
0000EB90                            
0000EB90 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0000EB94 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0000EB9A 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0000EB9C 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0000EBA0                            
0000EBA0                            .nodacsfx
0000EBA0 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0000EBA4 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0000EBA6 4EFA 0000                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0000EBAA                            ; ===========================================================================
0000EBAA                            ; ---------------------------------------------------------------------------
0000EBAA                            ; Routine for pausing the sound driver
0000EBAA                            ; ---------------------------------------------------------------------------
0000EBAA                            
0000EBAA                            dPlaySnd_Pause:
0000EBAA 08F8 0007 C4A6             		bset	#mfbPaused,mFlags.w	; pause music
0000EBB0 6696                       		bne.s	locret_VolDAC		; if was already paused, skip
0000EBB2                            ; ---------------------------------------------------------------------------
0000EBB2                            ; The following code will set channel panning to none for all FM channels.
0000EBB2                            ; This will ensure they are muted while we are pausing.
0000EBB2                            ; ---------------------------------------------------------------------------
0000EBB2                            
0000EBB2 7602                       		moveq	#3-1,d3			; 3 channels per YM2616 "part"
0000EBB4 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000EBB6 7200                       		moveq	#0,d1			; pan to neither speaker and remove LFO
0000EBB8                            
0000EBB8                            .muteFM
0000EBB8 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000EBBC 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EBC0 5200                       		addq.b	#1,d0			; go to next FM channel
0000EBC2 51CB FFF4                  		dbf	d3,.muteFM		; write each 3 channels per part
0000EBC6                            ; ---------------------------------------------------------------------------
0000EBC6                            ; The following code will key off all FM channels. There is a special
0000EBC6                            ; behavior in that, we must write all channels into part 1, and we
0000EBC6                            ; control the channel we are writing in the data portion.
0000EBC6                            ; 4 bits are reserved for which operators are active (in this case,
0000EBC6                            ; none), and 3 bits are reserved for the channel we want to affect.
0000EBC6                            ; ---------------------------------------------------------------------------
0000EBC6                            
0000EBC6 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000EBC8 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0000EBCA                            
0000EBCA                            .note
0000EBCA 1203                       		move.b	d3,d1			; copy value into d1
0000EBCC 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000EBD0 5801                       		addq.b	#4,d1			; set this to part 2 channel
0000EBD2 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000EBD6 51CB FFF2                  		dbf	d3,.note		; loop for all 3 channel groups
0000EBDA                            
0000EBDA 4EBA 0000                  		jsr	dMutePSG(pc)		; mute all PSG channels
0000EBDE                            	; continue to mute all DAC channels
0000EBDE                            ; ===========================================================================
0000EBDE                            ; ---------------------------------------------------------------------------
0000EBDE                            ; Routine for muting all DAC channels
0000EBDE                            ; ---------------------------------------------------------------------------
0000EBDE                            
0000EBDE                            dMuteDAC:
0000EBDE                            	StopZ80					; wait for Z80 to stop
0000EBDE 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000EBE6                          M 	waitz80stop
0000EBE6 0839 0000 00A1 1100      M .wait_582:	btst	#0,z80_bus_req
0000EBEE 66F6                     M 	bne.s	.wait_582
0000EBF0 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0000EBF4 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1 sample to a1
0000EBFA                            
0000EBFA                            	rept 12
0000EBFA                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0000EBFA                            	endr
0000EBFA 12DA                     M 	move.b	(a2)+,(a1)+
0000EBFC 12DA                     M 	move.b	(a2)+,(a1)+
0000EBFE 12DA                     M 	move.b	(a2)+,(a1)+
0000EC00 12DA                     M 	move.b	(a2)+,(a1)+
0000EC02 12DA                     M 	move.b	(a2)+,(a1)+
0000EC04 12DA                     M 	move.b	(a2)+,(a1)+
0000EC06 12DA                     M 	move.b	(a2)+,(a1)+
0000EC08 12DA                     M 	move.b	(a2)+,(a1)+
0000EC0A 12DA                     M 	move.b	(a2)+,(a1)+
0000EC0C 12DA                     M 	move.b	(a2)+,(a1)+
0000EC0E 12DA                     M 	move.b	(a2)+,(a1)+
0000EC10 12DA                     M 	move.b	(a2)+,(a1)+
0000EC12                            
0000EC12 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0000EC1A                            
0000EC1A 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0000EC1E 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 2 sample to a1
0000EC24                            
0000EC24                            	rept 12
0000EC24                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0000EC24                            	endr
0000EC24 12DA                     M 	move.b	(a2)+,(a1)+
0000EC26 12DA                     M 	move.b	(a2)+,(a1)+
0000EC28 12DA                     M 	move.b	(a2)+,(a1)+
0000EC2A 12DA                     M 	move.b	(a2)+,(a1)+
0000EC2C 12DA                     M 	move.b	(a2)+,(a1)+
0000EC2E 12DA                     M 	move.b	(a2)+,(a1)+
0000EC30 12DA                     M 	move.b	(a2)+,(a1)+
0000EC32 12DA                     M 	move.b	(a2)+,(a1)+
0000EC34 12DA                     M 	move.b	(a2)+,(a1)+
0000EC36 12DA                     M 	move.b	(a2)+,(a1)+
0000EC38 12DA                     M 	move.b	(a2)+,(a1)+
0000EC3A 12DA                     M 	move.b	(a2)+,(a1)+
0000EC3C                            
0000EC3C 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0000EC44                            	StartZ80				; enable Z80 execution
0000EC44 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000EC4C                            
0000EC4C                            locret_MuteDAC:
0000EC4C 4E75                       		rts
0000EC4E                            ; ===========================================================================
0000EC4E                            ; ---------------------------------------------------------------------------
0000EC4E                            ; Subroutine to play any queued music tracks, sound effects or commands
0000EC4E                            ; ---------------------------------------------------------------------------
0000EC4E                            
0000EC4E                            dPlaySnd:
0000EC4E 4DF8 C4BC                  		lea	mQueue.w,a6		; get address to the sound queue
0000EC52 7E00                       		moveq	#0,d7
0000EC54 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000EC56 6600                       		bne.s	.found			; if nonzero, a sound is queued
0000EC58 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000EC5A 6600                       		bne.s	.found			; if nonzero, a sound is queued
0000EC5C 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000EC5E 67EC                       		beq.s	locret_MuteDAC		; if 0, no sounds were queued, return
0000EC60                            
0000EC60                            .found
0000EC60 422E FFFF                  		clr.b	-1(a6)			; clear the slot we are processing
0000EC64 0C07 0082                  		cmpi.b	#SFXoff,d7		; check if this sound was a sound effect
0000EC68 6400 0000                  		bhs.w	dPlaySnd_SFX		; if so, handle it
0000EC6C 0C07 000A                  		cmpi.b	#MusOff,d7		; check if this sound was a command
0000EC70 6500 0000                  		blo.w	dPlaySnd_Comm		; if so, handle it
0000EC74                            	; it was music, handle it below
0000EC74                            ; ===========================================================================
0000EC74                            ; ---------------------------------------------------------------------------
0000EC74                            ; Subroutine to play a queued music track
0000EC74                            ; ---------------------------------------------------------------------------
0000EC74                            
0000EC74                            dPlaySnd_Music:
0000EC74 4EBA 0000                  		jsr	dStopMusic(pc)		; mute hardware and reset all driver memory
0000EC78 4EBA 0000                  		jsr	dResetVolume(pc)	; reset volumes and end any fades
0000EC7C                            ; ---------------------------------------------------------------------------
0000EC7C                            ; To save few cycles, we don't directly substract the music offset from
0000EC7C                            ; the ID, and instead offset the table position. In practice this will
0000EC7C                            ; have the same effect, but saves us 8 cycles overall.
0000EC7C                            ; ---------------------------------------------------------------------------
0000EC7C                            
0000EC7C 49FA 0000                  		lea	MusicIndex-(MusOff*4)(pc),a4; get music pointer table with an offset
0000EC80 DE47                       		add.w	d7,d7			; quadruple music ID
0000EC82 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0000EC84 11F4 7000 C4B9             		move.b	(a4,d7.w),mTempoSpeed.w	; load speed shoes tempo from the unused 8 bits
0000EC8A 2874 7000                  		movea.l	(a4,d7.w),a4		; get music header pointer from the table
0000EC8E                            
0000EC8E 200C                       		move.l	a4,d0			; copy pointer to d0
0000EC90 0280 00FF FFFF             		and.l	#$FFFFFF,d0		; clearing the upper 8 bits allows the debugger
0000EC96 2840                       		move.l	d0,a4			; to show the address correctly. Move ptr back to a4
0000EC98                            		AMPS_Debug_PlayTrackMus		; check if this was valid music
0000EC98 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EC9E 6500                     M 	blo.s	.fail_584
0000ECA0 0C80 0000 0000           M 	cmp.l	#musend,d0
0000ECA6 6500                     M 	blo.s	.ok_584
0000ECA8                          M .fail_584
0000ECA8 E44F                     M 	lsr.w	#2,d7
0000ECAA                          M 	raiseerror	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000ECAA 487A FFFE                M 	pea	*(pc)
0000ECAE                          M 	raiseerror2	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000ECAE 40E7                     M 	move.w	sr,-(sp)
0000ECB0                          M 	__fstring_generateargumentscode	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0 =0000001A                M 	__pos:	set instr("Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECB0 =00000000                M 	__stack:set	0
0000ECB0 =00000000                M 	__sp:	set 0
0000ECB0                          M 	while	(__pos)
0000ECB0 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECB0 =00000023                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECB0 =00000021                M 	__midpos:	= __endpos
0000ECB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	pushp	"move.b d7,1(sp)"
0000ECB0                          M 	pushp	"subq.w	#2, sp"
0000ECB0 =00000002                M 	__stack:	= __stack+2
0000ECB0 =00000002                M 	__sp:	= __sp+2
0000ECB0 =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECB0 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECB0 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECB0 =0000002B                M 	__midpos:	= __endpos
0000ECB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	pushp	"move.l a4,-(sp)"
0000ECB0 =00000003                M 	__stack:	= __stack+1
0000ECB0 =00000006                M 	__sp:	= __sp+4
0000ECB0 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECB0 =00000033                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECB0 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECB0 =00000033                M 	__midpos:	= __endpos
0000ECB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0 =00000034                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECB0 =0000003F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECB0 =0000003B                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECB0                          M 	pushp	"move.l a4,-(sp)"
0000ECB0 =00000004                M 	__stack:	= __stack+1
0000ECB0 =0000000A                M 	__sp:	= __sp+4
0000ECB0 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECB0                          M 	rept	__stack
0000ECB0                          M 	popp	__command
0000ECB0 2F0C                     M 	move.l	a4,-(sp)
0000ECB2                          M 	popp	__command
0000ECB2 2F0C                     M 	move.l	a4,-(sp)
0000ECB4                          M 	popp	__command
0000ECB4 554F                     M 	subq.w	#2,sp
0000ECB6                          M 	popp	__command
0000ECB6 1F47 0001                M 	move.b	d7,1(sp)
0000ECBA 4EB9 0000 0000           M 	jsr	errorhandler
0000ECC0                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECC0 =00000001                M 	__lpos:	set 1
0000ECC0 =0000001A                M 	__pos:	set instr("Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECC0                          M 	while	(__pos)
0000ECC0                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECC0 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music "
0000ECD9 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECD9 =00000023                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECD9 =00000021                M 	__midpos:	= __endpos
0000ECD9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECD9                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECD9                          M 	__param:	substr ,,"hex"
0000ECD9 80                       M 	dc.b	hex
0000ECDA =00000022                M 	__lpos:	set __endpos+1
0000ECDA =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECDA                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDA 3A20                     M 	dc.b	": "
0000ECDC =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECDC =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECDC =0000002B                M 	__midpos:	= __endpos
0000ECDC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDC                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDC                          M 	__param:	substr ,,"hex"
0000ECDC 83                       M 	dc.b	hex|3
0000ECDD =0000002C                M 	__lpos:	set __endpos+1
0000ECDD =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECDD                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDD                          M 	dc.b	""
0000ECDD =00000033                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECDD =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECDD =00000033                M 	__midpos:	= __endpos
0000ECDD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDD                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDD E0                       M 	dc.b	fendl
0000ECDE =00000034                M 	__lpos:	set __endpos+1
0000ECDE =00000034                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECDE                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDE                          M 	dc.b	""
0000ECDE =0000003F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECDE =0000003B                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECDE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDE B3                       M 	dc.b	sym|3
0000ECDF =00000040                M 	__lpos:	set __endpos+1
0000ECDF =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECDF                          M 	__substr:	substr __lpos,,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECDF                          M 	dc.b	""
0000ECDF 00                       M 	dc.b	0
0000ECE0 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000ECE2 00                       M 	even
0000ECE2 4EFA ED7A                M 	jmp	amps_debug_console_main
0000ECE6                          M 	even
0000ECE6                          M .ok_584
0000ECE6                            
0000ECE6 264C                       		move.l	a4,a3			; copy pointer to a3
0000ECE8 584C                       		addq.w	#4,a4			; go to DAC1 data section
0000ECEA                            
0000ECEA 7000                       		moveq	#0,d0
0000ECEC 102B 0001                  		move.b	1(a3),d0		; load song tempo to d0
0000ECF0 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as regular tempo
0000ECF4 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes flag was set
0000ECFA 6700                       		beq.s	.tempogot		; if not, use main tempo
0000ECFC 1038 C4B9                  		move.b	mTempoSpeed.w,d0	; load speed shoes tempo to d0 instead
0000ED00                            
0000ED00                            .tempogot
0000ED00 11C0 C4BA                  		move.b	d0,mTempo.w		; save as the current tempo
0000ED04 11C0 C4BB                  		move.b	d0,mTempoCur.w		; copy into the accumulator/counter
0000ED08 0238 00F7 C4A6             		and.b	#$FF-(1<<mfbNoPAL),mFlags.w; enable PAL fix
0000ED0E                            ; ---------------------------------------------------------------------------
0000ED0E                            ; If the 7th bit (msb) of tick multiplier is set, PAL fix gets
0000ED0E                            ; disabled. I know, very weird place to put it, but we dont have
0000ED0E                            ; much free room in the song header
0000ED0E                            ; ---------------------------------------------------------------------------
0000ED0E                            
0000ED0E 1813                       		move.b	(a3),d4			; load the tick multiplier to d4
0000ED10 6A00                       		bpl.s	.noPAL			; branch if the loaded value was positive
0000ED12 0244 007F                  		and.w	#$7F,d4			; keep value in range
0000ED16 0038 0008 C4A6             		or.b	#1<<mfbNoPAL,mFlags.w	; disable PAL fix
0000ED1C                            
0000ED1C                            .noPAL
0000ED1C 74A0                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbVol),d2; prepare running tracker and volume flags into d2
0000ED1E 72C0                       		moveq	#$FFFFFFC0,d1		; prepare panning value of centre to d1
0000ED20 7C2C                       		moveq	#cSize,d6		; prepare channel size to d6
0000ED22 7A01                       		moveq	#1,d5			; prepare duration of 0 frames to d5
0000ED24                            
0000ED24 43F8 C4C4                  		lea	mDAC1.w,a1		; start from DAC1 channel
0000ED28 45FA 0000                  		lea	dDACtypeVals(pc),a2	; prepare DAC (and FM) type value list into a2
0000ED2C 7E01                       		moveq	#2-1,d7			; always run for 2 DAC channels
0000ED2E 363C 0100                  		move.w	#$100,d3		; prepare default DAC frequency
0000ED32                            
0000ED32                            .loopDAC
0000ED32 1282                       		move.b	d2,(a1)			; save channel flags
0000ED34 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000ED38 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000ED3C 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000ED40 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0000ED44 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000ED48 3343 000E                  		move.w	d3,cFreq(a1)		; reset channel base frequency
0000ED4C                            
0000ED4C 7000                       		moveq	#0,d0
0000ED4E 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000ED50 D08B                       		add.l	a3,d0			; add music header offset to d0
0000ED52 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000ED56                            		AMPS_Debug_PlayTrackMus2 DAC	; make sure the tracker address is valid
0000ED56 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000ED5C 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000ED62 6500                     M 	blo.s	.fail_589
0000ED64 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000ED6A 6500                     M 	blo.s	.ok_589
0000ED6C                          M .fail_589
0000ED6C                          M 	raiseerror	"Invalid tracker at Music dac: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000ED6C 487A FFFE                M 	pea	*(pc)
0000ED70                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000ED70 40E7                     M 	move.w	sr,-(sp)
0000ED72                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED72 =00000000                M 	__stack:set	0
0000ED72 =00000000                M 	__sp:	set 0
0000ED72                          M 	while	(__pos)
0000ED72 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED72 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED72 =00000027                M 	__midpos:	= __endpos
0000ED72                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72                          M 	pushp	"move.l d0,-(sp)"
0000ED72 =00000001                M 	__stack:	= __stack+1
0000ED72 =00000004                M 	__sp:	= __sp+4
0000ED72 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED72 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED72 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED72 =0000002F                M 	__midpos:	= __endpos
0000ED72                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED72 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED72 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED72                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED72                          M 	pushp	"move.l d0,-(sp)"
0000ED72 =00000002                M 	__stack:	= __stack+1
0000ED72 =00000008                M 	__sp:	= __sp+4
0000ED72 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED72                          M 	rept	__stack
0000ED72                          M 	popp	__command
0000ED72 2F00                     M 	move.l	d0,-(sp)
0000ED74                          M 	popp	__command
0000ED74 2F00                     M 	move.l	d0,-(sp)
0000ED76 4EB9 0000 0000           M 	jsr	errorhandler
0000ED7C                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED7C =00000001                M 	__lpos:	set 1
0000ED7C =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED7C                          M 	while	(__pos)
0000ED7C                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED7C 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000ED9B =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED9B =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED9B =00000027                M 	__midpos:	= __endpos
0000ED9B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED9B                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED9B                          M 	__param:	substr ,,"hex"
0000ED9B 83                       M 	dc.b	hex|3
0000ED9C =00000028                M 	__lpos:	set __endpos+1
0000ED9C =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED9C                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED9C                          M 	dc.b	""
0000ED9C =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED9C =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED9C =0000002F                M 	__midpos:	= __endpos
0000ED9C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED9C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED9C E0                       M 	dc.b	fendl
0000ED9D =00000030                M 	__lpos:	set __endpos+1
0000ED9D =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED9D                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED9D                          M 	dc.b	""
0000ED9D =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED9D =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED9D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED9D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED9D B3                       M 	dc.b	sym|3
0000ED9E =0000003C                M 	__lpos:	set __endpos+1
0000ED9E =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED9E                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED9E                          M 	dc.b	""
0000ED9E 00                       M 	dc.b	0
0000ED9F 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EDA0                          M 	even
0000EDA0 4EFA ECBC                M 	jmp	amps_debug_console_main
0000EDA4                          M 	even
0000EDA4                          M .ok_589
0000EDA4                            
0000EDA4 135C 0009                  		move.b	(a4)+,cVolume(a1)	; load channel volume
0000EDA8 135C 000B                  		move.b	(a4)+,cSample(a1)	; load channel sample ID
0000EDAC 6700                       		beq.s	.sampmode		; if 0, we are in sample mode
0000EDAE 08D1 0000                  		bset	#cfbMode,(a1)		; if not 0, enable pitch mode
0000EDB2                            
0000EDB2                            .sampmode
0000EDB2 D2C6                       		add.w	d6,a1			; go to the next channel
0000EDB4 51CF FF7C                  		dbf	d7,.loopDAC		; repeat for all DAC channels
0000EDB8                            
0000EDB8 7E00                       		moveq	#0,d7
0000EDBA 7481                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbRest),d2; prepare running tracker and channel rest flags
0000EDBC 1E2B 0002                  		move.b	2(a3),d7		; load the FM channel count to d7
0000EDC0 6B00                       		bmi.s	.doPSG			; if no FM channels are loaded, branch
0000EDC2                            
0000EDC2                            .loopFM
0000EDC2 1282                       		move.b	d2,(a1)			; save channel flags
0000EDC4 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000EDC8 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000EDCC 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000EDD0 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0000EDD4 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000EDD8                            
0000EDD8 7000                       		moveq	#0,d0
0000EDDA 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000EDDC D08B                       		add.l	a3,d0			; add music header offset to d0
0000EDDE 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000EDE2                            		AMPS_Debug_PlayTrackMus2 FM	; make sure the tracker address is valid
0000EDE2 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000EDE8 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EDEE 6500                     M 	blo.s	.fail_594
0000EDF0 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000EDF6 6500                     M 	blo.s	.ok_594
0000EDF8                          M .fail_594
0000EDF8                          M 	raiseerror	"Invalid tracker at Music fm: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EDF8 487A FFFE                M 	pea	*(pc)
0000EDFC                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EDFC 40E7                     M 	move.w	sr,-(sp)
0000EDFE                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDFE =00000000                M 	__stack:set	0
0000EDFE =00000000                M 	__sp:	set 0
0000EDFE                          M 	while	(__pos)
0000EDFE =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EDFE =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EDFE =00000027                M 	__midpos:	= __endpos
0000EDFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE                          M 	pushp	"move.l d0,-(sp)"
0000EDFE =00000001                M 	__stack:	= __stack+1
0000EDFE =00000004                M 	__sp:	= __sp+4
0000EDFE =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDFE =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EDFE =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EDFE =0000002F                M 	__midpos:	= __endpos
0000EDFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDFE =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EDFE =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EDFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDFE                          M 	pushp	"move.l d0,-(sp)"
0000EDFE =00000002                M 	__stack:	= __stack+1
0000EDFE =00000008                M 	__sp:	= __sp+4
0000EDFE =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDFE                          M 	rept	__stack
0000EDFE                          M 	popp	__command
0000EDFE 2F00                     M 	move.l	d0,-(sp)
0000EE00                          M 	popp	__command
0000EE00 2F00                     M 	move.l	d0,-(sp)
0000EE02 4EB9 0000 0000           M 	jsr	errorhandler
0000EE08                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE08 =00000001                M 	__lpos:	set 1
0000EE08 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE08                          M 	while	(__pos)
0000EE08                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE08 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EE27 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE27 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE27 =00000027                M 	__midpos:	= __endpos
0000EE27                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE27                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE27                          M 	__param:	substr ,,"hex"
0000EE27 83                       M 	dc.b	hex|3
0000EE28 =00000028                M 	__lpos:	set __endpos+1
0000EE28 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE28                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE28                          M 	dc.b	""
0000EE28 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE28 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE28 =0000002F                M 	__midpos:	= __endpos
0000EE28                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE28                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE28 E0                       M 	dc.b	fendl
0000EE29 =00000030                M 	__lpos:	set __endpos+1
0000EE29 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE29                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE29                          M 	dc.b	""
0000EE29 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE29 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE29                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE29                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE29 B3                       M 	dc.b	sym|3
0000EE2A =0000003C                M 	__lpos:	set __endpos+1
0000EE2A =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE2A                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE2A                          M 	dc.b	""
0000EE2A 00                       M 	dc.b	0
0000EE2B 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EE2C                          M 	even
0000EE2C 4EFA EC30                M 	jmp	amps_debug_console_main
0000EE30                          M 	even
0000EE30                          M .ok_594
0000EE30                            
0000EE30 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0000EE34 D2C6                       		adda.w	d6,a1			; go to the next channel
0000EE36 51CF FF8A                  		dbf	d7,.loopFM		; repeat for all FM channels
0000EE3A                            
0000EE3A                            .doPSG
0000EE3A 7E00                       		moveq	#0,d7
0000EE3C 1E2B 0003                  		move.b	3(a3),d7		; load the FM channel count to d7
0000EE40 6B00 0000                  		bmi.w	.intSFX			; if no PSG channels are loaded, branch
0000EE44                            ; ---------------------------------------------------------------------------
0000EE44                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0000EE44                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0000EE44                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0000EE44                            ; is controlled by the 68000, we would be off by a single frame without
0000EE44                            ; this fix.
0000EE44                            ; ---------------------------------------------------------------------------
0000EE44                            
0000EE44 7A02                       		moveq	#2,d5			; prepare duration of 1 frames to d5
0000EE46 45FA 0000                  		lea	dPSGtypeVals(pc),a2	; prepare PSG type value list into a2
0000EE4A 43F8 C5F8                  		lea	mPSG1.w,a1		; start from PSG1 channel
0000EE4E                            
0000EE4E                            .loopPSG
0000EE4E 1282                       		move.b	d2,(a1)			; save channel flags
0000EE50 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000EE54 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000EE58 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000EE5C 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000EE60                            
0000EE60 7000                       		moveq	#0,d0
0000EE62 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000EE64 D08B                       		add.l	a3,d0			; add music header offset to d0
0000EE66 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000EE6A                            		AMPS_Debug_PlayTrackMus2 PSG	; make sure the tracker address is valid
0000EE6A 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000EE70 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EE76 6500                     M 	blo.s	.fail_599
0000EE78 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000EE7E 6500                     M 	blo.s	.ok_599
0000EE80                          M .fail_599
0000EE80                          M 	raiseerror	"Invalid tracker at Music psg: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EE80 487A FFFE                M 	pea	*(pc)
0000EE84                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EE84 40E7                     M 	move.w	sr,-(sp)
0000EE86                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE86 =00000000                M 	__stack:set	0
0000EE86 =00000000                M 	__sp:	set 0
0000EE86                          M 	while	(__pos)
0000EE86 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE86 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE86 =00000027                M 	__midpos:	= __endpos
0000EE86                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86                          M 	pushp	"move.l d0,-(sp)"
0000EE86 =00000001                M 	__stack:	= __stack+1
0000EE86 =00000004                M 	__sp:	= __sp+4
0000EE86 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE86 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE86 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE86 =0000002F                M 	__midpos:	= __endpos
0000EE86                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE86 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE86 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE86                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE86                          M 	pushp	"move.l d0,-(sp)"
0000EE86 =00000002                M 	__stack:	= __stack+1
0000EE86 =00000008                M 	__sp:	= __sp+4
0000EE86 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE86                          M 	rept	__stack
0000EE86                          M 	popp	__command
0000EE86 2F00                     M 	move.l	d0,-(sp)
0000EE88                          M 	popp	__command
0000EE88 2F00                     M 	move.l	d0,-(sp)
0000EE8A 4EB9 0000 0000           M 	jsr	errorhandler
0000EE90                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE90 =00000001                M 	__lpos:	set 1
0000EE90 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE90                          M 	while	(__pos)
0000EE90                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE90 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EEAF =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EEAF =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EEAF =00000027                M 	__midpos:	= __endpos
0000EEAF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEAF                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEAF                          M 	__param:	substr ,,"hex"
0000EEAF 83                       M 	dc.b	hex|3
0000EEB0 =00000028                M 	__lpos:	set __endpos+1
0000EEB0 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EEB0                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEB0                          M 	dc.b	""
0000EEB0 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EEB0 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EEB0 =0000002F                M 	__midpos:	= __endpos
0000EEB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEB0 E0                       M 	dc.b	fendl
0000EEB1 =00000030                M 	__lpos:	set __endpos+1
0000EEB1 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EEB1                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEB1                          M 	dc.b	""
0000EEB1 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EEB1 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EEB1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEB1                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEB1 B3                       M 	dc.b	sym|3
0000EEB2 =0000003C                M 	__lpos:	set __endpos+1
0000EEB2 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EEB2                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EEB2                          M 	dc.b	""
0000EEB2 00                       M 	dc.b	0
0000EEB3 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EEB4                          M 	even
0000EEB4 4EFA EBA8                M 	jmp	amps_debug_console_main
0000EEB8                          M 	even
0000EEB8                          M .ok_599
0000EEB8                            
0000EEB8 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0000EEBC 135C 0007                  		move.b	(a4)+,cDetune(a1)	; load detune offset
0000EEC0 135C 000B                  		move.b	(a4)+,cVolEnv(a1)	; load volume envelope ID
0000EEC4 D2C6                       		adda.w	d6,a1			; go to the next channel
0000EEC6 51CF FF86                  		dbf	d7,.loopPSG		; repeat for all FM channels
0000EECA                            
0000EECA                            .intSFX
0000EECA                            ; ---------------------------------------------------------------------------
0000EECA                            ; Now follows initializing FM6 to be ready for PCM streaming,
0000EECA                            ; and resetting the PCM filter for Dual PCM. Simply, this just
0000EECA                            ; clears some YM registers.
0000EECA                            ; ---------------------------------------------------------------------------
0000EECA                            
0000EECA 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000EECC 7206                       		moveq	#6,d1			; FM6, all operators off
0000EECE 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000EED2                            
0000EED2 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0000EED4 7042                       		moveq	#$42,d0			; YM address: Total Level Operator 1 (FM3/6)
0000EED6 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EEDA 704A                       		moveq	#$4A,d0			; YM address: Total Level Operator 2 (FM3/6)
0000EEDC 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EEE0 7046                       		moveq	#$46,d0			; YM address: Total Level Operator 3 (FM3/6)
0000EEE2 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EEE6 704E                       		moveq	#$4E,d0			; YM address: Total Level Operator 4 (FM3/6)
0000EEE8 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EEEC                            
0000EEEC 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0000EEEE 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0000EEF0 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EEF4                            
0000EEF4 303C 0000                  		move.w	#fLog>>$0F,d0		; use linear filter
0000EEF8 4EBA 0000                  		jsr	dSetFilter(pc)		; set filter
0000EEFC                            ; ---------------------------------------------------------------------------
0000EEFC                            ; This piece of code here handles SFX overriding our newly loaded
0000EEFC                            ; music channels. Since we did not do this at the initialization
0000EEFC                            ; step, we will handle it here instead.
0000EEFC                            ; ---------------------------------------------------------------------------
0000EEFC                            
0000EEFC 45FA 0000                  		lea	dSFXoverList(pc),a2	; load quick reference to the SFX override list
0000EF00 43F8 C67C                  		lea	mSFXDAC1.w,a1		; start from SFX DAC1 channel
0000EF04 7E06                       		moveq	#SFX_Ch-1,d7		; prepare total number of SFX channels into d7
0000EF06 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0000EF08                            
0000EF08                            .loopSFX
0000EF08 4A11                       		tst.b	(a1)			; check if SFX channel is running a tracker
0000EF0A 6A00                       		bpl.s	.nextSFX		; if not, skip this channel
0000EF0C                            
0000EF0C 7000                       		moveq	#0,d0
0000EF0E 1029 0001                  		move.b	cType(a1),d0		; load SFX channel type to d0
0000EF12 6B00                       		bmi.s	.SFXPSG			; if negative, it is a PSG channel
0000EF14                            
0000EF14 0240 0007                  		and.w	#$07,d0			; get only the necessary bits to d3
0000EF18 5540                       		subq.w	#2,d0			; since FM 1 and 2 are not used, skip over them
0000EF1A D040                       		add.w	d0,d0			; double offset (each entry is 1 word in size)
0000EF1C 6000                       		bra.s	.override
0000EF1E                            ; ---------------------------------------------------------------------------
0000EF1E                            
0000EF1E                            .SFXPSG
0000EF1E E808                       		lsr.b	#4,d0			; make it easier to reference the right offset in the table
0000EF20                            .override
0000EF20 3672 0000                  		move.w	(a2,d0.w),a3		; get music channel RAM address to a3
0000EF24 08D3 0001                  		bset	#cfbInt,(a3)		; set as interrupted
0000EF28                            
0000EF28                            .nextSFX
0000EF28 D2C6                       		adda.w	d6,a1			; go to the next channel
0000EF2A 51CF FFDC                  		dbf	d7,.loopSFX		; repeat for all SFX channels
0000EF2E                            ; ---------------------------------------------------------------------------
0000EF2E                            ; Here we mute all non-interrupted FM and PSG channels
0000EF2E                            ; ---------------------------------------------------------------------------
0000EF2E                            
0000EF2E 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0000EF32 7804                       		moveq	#Mus_FM-1,d4		; prepare total number of FM channels into d7
0000EF34                            .stopFM
0000EF34 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key off even if not interrupted
0000EF38 DAC6                       		adda.w	d6,a5			; go to the next channel
0000EF3A 51CC FFF8                  		dbf	d4,.stopFM		; repeat for all FM channels
0000EF3E                            
0000EF3E 7802                       		moveq	#Mus_PSG-1,d4		; start from PSG1 channel
0000EF40                            .mutePSG
0000EF40 4EBA 0000                  		jsr	dMutePSGmus(pc)		; mute PSG channel if not interrupted
0000EF44 DAC6                       		adda.w	d6,a5			; go to the next channel
0000EF46 51CC FFF8                  		dbf	d4,.mutePSG		; repeat for all FM channels
0000EF4A 4E75                       		rts
0000EF4C                            
0000EF4C                            ; ===========================================================================
0000EF4C                            ; ---------------------------------------------------------------------------
0000EF4C                            ; Type values for different channels. Used for playing music
0000EF4C                            ; ---------------------------------------------------------------------------
0000EF4C 0B0E                       dDACtypeVals:	dc.b ctDAC1, ctDAC2
0000EF4E 0001 0204 05               dFMtypeVals:	dc.b ctFM1, ctFM2, ctFM3, ctFM4, ctFM5
0000EF53 80A0 C0                    dPSGtypeVals:	dc.b ctPSG1, ctPSG2, ctPSG3
0000EF56                            		even
0000EF56                            ; ===========================================================================
0000EF56                            ; ---------------------------------------------------------------------------
0000EF56                            ; Subroutine to play a queued sound effect
0000EF56                            ; ---------------------------------------------------------------------------
0000EF56                            
0000EF56                            dPlaySnd_SFX:
0000EF56                            ; ---------------------------------------------------------------------------
0000EF56                            ; This is a little special case with Sonic 1 - 3K, where the ring
0000EF56                            ; sound effect would change panning each time it is played. AMPS
0000EF56                            ; emulates this behavior like the original drivers did, by
0000EF56                            ; playing a different sound effect ID.
0000EF56                            ; ---------------------------------------------------------------------------
0000EF56                            
0000EF56                            		;cmpi.b	#sfx_RingRight,d7	; check if the sound effect was the ring sound effect
0000EF56                            		;bne.s	.noring			; if not, skip
0000EF56                            		;bchg	#mfbRing,mFlags.w	; swap flag and check if it was set
0000EF56                            		;beq.s	.noring			; if was not, do not change sound effect
0000EF56                            		;move.w	#sfx_RingLeft,d7	; switch to left panned sound effect instead
0000EF56                            ; ---------------------------------------------------------------------------
0000EF56                            ; To save few cycles, we don't directly substract the SFX offset from
0000EF56                            ; the ID, and instead offset the table position. In practice this will
0000EF56                            ; have the same effect, but saves us 8 cycles overall.
0000EF56                            ; ---------------------------------------------------------------------------
0000EF56                            
0000EF56                            .noring
0000EF56 43FA 0000                  		lea	SoundIndex-(SFXoff*4)(pc),a1; get sfx pointer table with an offset to a4
0000EF5A 1207                       		move.b	d7,d1			; copy sfx ID to d1 (used later)
0000EF5C DE47                       		add.w	d7,d7			; quadruple sfx ID
0000EF5E DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0000EF60 2871 7000                  		movea.l	(a1,d7.w),a4		; get SFX header pointer from the table
0000EF64                            
0000EF64 200C                       		move.l	a4,d0			; copy pointer to d0
0000EF66 0280 00FF FFFF             		and.l	#$FFFFFF,d0		; clearing the upper 8 bits allows the debugger
0000EF6C 2840                       		move.l	d0,a4			; to show the address correctly. Move ptr back to a4
0000EF6E                            		AMPS_Debug_PlayTrackSFX		; check if this was valid sound effect
0000EF6E 0C80 0000 0000           M 	cmp.l	#sfxaddr,d0
0000EF74 6500                     M 	blo.s	.fail_604
0000EF76 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EF7C 6500                     M 	blo.s	.ok_604
0000EF7E                          M .fail_604
0000EF7E                          M 	raiseerror	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000EF7E 487A FFFE                M 	pea	*(pc)
0000EF82                          M 	raiseerror2	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000EF82 40E7                     M 	move.w	sr,-(sp)
0000EF84                          M 	__fstring_generateargumentscode	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84 =00000018                M 	__pos:	set instr("Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF84 =00000000                M 	__stack:set	0
0000EF84 =00000000                M 	__sp:	set 0
0000EF84                          M 	while	(__pos)
0000EF84 =0000001F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF84 =00000021                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF84 =0000001F                M 	__midpos:	= __endpos
0000EF84                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	pushp	"move.b d0,1(sp)"
0000EF84                          M 	pushp	"subq.w	#2, sp"
0000EF84 =00000002                M 	__stack:	= __stack+2
0000EF84 =00000002                M 	__sp:	= __sp+2
0000EF84 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF84 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF84 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF84 =00000029                M 	__midpos:	= __endpos
0000EF84                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	pushp	"move.l a4,-(sp)"
0000EF84 =00000003                M 	__stack:	= __stack+1
0000EF84 =00000006                M 	__sp:	= __sp+4
0000EF84 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF84 =00000031                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF84 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF84 =00000031                M 	__midpos:	= __endpos
0000EF84                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84 =00000032                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF84 =0000003D                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF84 =00000039                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF84                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF84                          M 	pushp	"move.l a4,-(sp)"
0000EF84 =00000004                M 	__stack:	= __stack+1
0000EF84 =0000000A                M 	__sp:	= __sp+4
0000EF84 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF84                          M 	rept	__stack
0000EF84                          M 	popp	__command
0000EF84 2F0C                     M 	move.l	a4,-(sp)
0000EF86                          M 	popp	__command
0000EF86 2F0C                     M 	move.l	a4,-(sp)
0000EF88                          M 	popp	__command
0000EF88 554F                     M 	subq.w	#2,sp
0000EF8A                          M 	popp	__command
0000EF8A 1F40 0001                M 	move.b	d0,1(sp)
0000EF8E 4EB9 0000 0000           M 	jsr	errorhandler
0000EF94                          M 	__fstring_generatedecodedstring	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF94 =00000001                M 	__lpos:	set 1
0000EF94 =00000018                M 	__pos:	set instr("Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF94                          M 	while	(__pos)
0000EF94                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF94 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at SFX "
0000EFAB =0000001F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EFAB =00000021                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EFAB =0000001F                M 	__midpos:	= __endpos
0000EFAB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFAB                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFAB                          M 	__param:	substr ,,"hex"
0000EFAB 80                       M 	dc.b	hex
0000EFAC =00000020                M 	__lpos:	set __endpos+1
0000EFAC =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EFAC                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFAC 3A20                     M 	dc.b	": "
0000EFAE =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EFAE =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EFAE =00000029                M 	__midpos:	= __endpos
0000EFAE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFAE                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFAE                          M 	__param:	substr ,,"hex"
0000EFAE 83                       M 	dc.b	hex|3
0000EFAF =0000002A                M 	__lpos:	set __endpos+1
0000EFAF =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EFAF                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFAF                          M 	dc.b	""
0000EFAF =00000031                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EFAF =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EFAF =00000031                M 	__midpos:	= __endpos
0000EFAF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFAF                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFAF E0                       M 	dc.b	fendl
0000EFB0 =00000032                M 	__lpos:	set __endpos+1
0000EFB0 =00000032                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EFB0                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFB0                          M 	dc.b	""
0000EFB0 =0000003D                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EFB0 =00000039                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EFB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFB0                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFB0 B3                       M 	dc.b	sym|3
0000EFB1 =0000003E                M 	__lpos:	set __endpos+1
0000EFB1 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EFB1                          M 	__substr:	substr __lpos,,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EFB1                          M 	dc.b	""
0000EFB1 00                       M 	dc.b	0
0000EFB2 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EFB4 00                       M 	even
0000EFB4 4EFA EAA8                M 	jmp	amps_debug_console_main
0000EFB8                          M 	even
0000EFB8                          M .ok_604
0000EFB8                            ; ---------------------------------------------------------------------------
0000EFB8                            ; Continous SFX is a very special type of sound effect. Unlike other
0000EFB8                            ; sound effects, when a continous SFX is played, it will run a loop
0000EFB8                            ; again, until it is no longer queued. This is very useful for sound
0000EFB8                            ; effects that need to be queued very often, but that really do not
0000EFB8                            ; sound good when restarted (plus, it requires more CPU time, anyway).
0000EFB8                            ; Even the Marble Zone block pushing sound effect had similar behavior,
0000EFB8                            ; but the code was not quite as matured as this here. Only one continous
0000EFB8                            ; SFX may be running at once, when other type is loaded, the earlier one
0000EFB8                            ; is stopped and replaced.
0000EFB8                            ; ---------------------------------------------------------------------------
0000EFB8                            
0000EFB8 4A31 7000                  		tst.b	(a1,d7.w)		; check if this sound effect is continously looping
0000EFBC 6A00                       		bpl.s	.nocont			; if not, skip
0000EFBE 11EC 0001 C4C2             		move.b	1(a4),mContCtr.w	; copy the number of channels as the new continous loop counter
0000EFC4 B238 C4C3                  		cmp.b	mContLast.w,d1		; check if the last continous SFX had the same ID
0000EFC8 6600                       		bne.s	.setcont		; if not, play as a new sound effect anyway
0000EFCA 4E75                       		rts
0000EFCC                            
0000EFCC                            .setcont
0000EFCC 11C1 C4C3                  		move.b	d1,mContLast.w		; save new continous SFX ID
0000EFD0                            .nocont
0000EFD0 224C                       		movea.l	a4,a1			; copy tracker header pointer to a1
0000EFD2                            
0000EFD2 7E00                       		moveq	#0,d7
0000EFD4 47FA 0000                  		lea	dSFXoverList(pc),a3	; load quick reference to the SFX override list to a3
0000EFD8 45FA 0000                  		lea	dSFXoffList(pc),a2	; load quick reference to the SFX channel list to a2
0000EFDC 1A19                       		move.b	(a1)+,d5		; load sound effect priority to d5
0000EFDE 1E19                       		move.b	(a1)+,d7		; load number of SFX channels to d7
0000EFE0 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0000EFE2                            ; ---------------------------------------------------------------------------
0000EFE2                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0000EFE2                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0000EFE2                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0000EFE2                            ; is controlled by the 68000, we would be off by a single frame without
0000EFE2                            ; this fix.
0000EFE2                            ; ---------------------------------------------------------------------------
0000EFE2                            
0000EFE2                            .loopSFX
0000EFE2 7600                       		moveq	#0,d3
0000EFE4 7402                       		moveq	#2,d2			; prepare duration of 1 frames to d5
0000EFE6 1629 0001                  		move.b	1(a1),d3		; load sound effect channel type to d3
0000EFEA 1803                       		move.b	d3,d4			; copy type to d4
0000EFEC 6B00                       		bmi.s	.chPSG			; if channel is a PSG channel, branch
0000EFEE                            
0000EFEE 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0000EFF2 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0000EFF4 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0000EFF6                            
0000EFF6 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0000EFFA BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0000EFFE 6500                       		blo.s	.skip			; if not, we can not override it
0000F000                            
0000F000 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0000F004 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0000F008 7401                       		moveq	#1,d2			; prepare duration of 0 frames to d5
0000F00A 6000                       		bra.s	.clearCh
0000F00C                            ; ---------------------------------------------------------------------------
0000F00C                            
0000F00C                            .skip
0000F00C 5C89                       		addq.l	#6,a1			; skip this sound effect channel
0000F00E 51CF FFD2                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000F012 4E75                       		rts
0000F014                            ; ---------------------------------------------------------------------------
0000F014                            
0000F014                            .chPSG
0000F014 E84B                       		lsr.w	#4,d3			; make it easier to reference the right offset in the table
0000F016 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0000F01A BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0000F01E 65EC                       		blo.s	.skip			; if not, we can not override it
0000F020                            
0000F020 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0000F024 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0000F028 0004 001F                  		ori.b	#$1F,d4			; add volume update and max volume to channel type
0000F02C 13C4 00C0 0011             		move.b	d4,dPSG			; send volume mute command to PSG
0000F032                            
0000F032 0C04 00DF                  		cmpi.b	#ctPSG3|$1F,d4		; check if we sent command about PSG3
0000F036 6600                       		bne.s	.clearCh		; if not, skip
0000F038 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send volume mute command for PSG4 to PSG
0000F040                            
0000F040                            .clearCh
0000F040 3C4D                       		move.w	a5,a6			; copy sound effect channel RAM pointer to a6
0000F042 7006                       		moveq	#cSizeSFX/4-1,d0	; prepare SFX channel size / 4 to d0
0000F044                            .clear
0000F044 429E                       		clr.l	(a6)+			; clear 4 bytes of channel data
0000F046 51C8 FFFC                  		dbf	d0,.clear		; clear the entire channel
0000F04A                            
0000F04A                            
0000F04A 3A99                       		move.w	(a1)+,(a5)		; load channel flags and type
0000F04C 1B45 001A                  		move.b	d5,cPrio(a5)		; set channel priority
0000F050 1B42 000C                  		move.b	d2,cDuration(a5)	; reset channel duration
0000F054                            
0000F054 7000                       		moveq	#0,d0
0000F056 3019                       		move.w	(a1)+,d0		; load tracker offset to d0
0000F058 D08C                       		add.l	a4,d0			; add music header offset to d0
0000F05A 2B40 0002                  		move.l	d0,cData(a5)		; save as the tracker address of the channel
0000F05E                            		AMPS_Debug_PlayTrackSFX2	; make sure the tracker address is valid
0000F05E 0C80 0000 0000           M 	cmp.l	#sfxaddr,d0
0000F064 6500                     M 	blo.s	.fail_609
0000F066 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000F06C 6500                     M 	blo.s	.ok_609
0000F06E                          M .fail_609
0000F06E                          M 	raiseerror	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000F06E 487A FFFE                M 	pea	*(pc)
0000F072                          M 	raiseerror2	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000F072 40E7                     M 	move.w	sr,-(sp)
0000F074                          M 	__fstring_generateargumentscode	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074 =0000001C                M 	__pos:	set instr("Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F074 =00000000                M 	__stack:set	0
0000F074 =00000000                M 	__sp:	set 0
0000F074                          M 	while	(__pos)
0000F074 =00000023                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F074 =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F074 =00000023                M 	__midpos:	= __endpos
0000F074                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074                          M 	pushp	"move.l d0,-(sp)"
0000F074 =00000001                M 	__stack:	= __stack+1
0000F074 =00000004                M 	__sp:	= __sp+4
0000F074 =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F074 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F074 =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F074 =0000002B                M 	__midpos:	= __endpos
0000F074                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F074 =00000037                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F074 =00000033                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F074                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F074                          M 	pushp	"move.l d0,-(sp)"
0000F074 =00000002                M 	__stack:	= __stack+1
0000F074 =00000008                M 	__sp:	= __sp+4
0000F074 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F074                          M 	rept	__stack
0000F074                          M 	popp	__command
0000F074 2F00                     M 	move.l	d0,-(sp)
0000F076                          M 	popp	__command
0000F076 2F00                     M 	move.l	d0,-(sp)
0000F078 4EB9 0000 0000           M 	jsr	errorhandler
0000F07E                          M 	__fstring_generatedecodedstring	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F07E =00000001                M 	__lpos:	set 1
0000F07E =0000001C                M 	__pos:	set instr("Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F07E                          M 	while	(__pos)
0000F07E                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F07E 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at SFX ch: "
0000F099 =00000023                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F099 =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F099 =00000023                M 	__midpos:	= __endpos
0000F099                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F099                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F099                          M 	__param:	substr ,,"hex"
0000F099 83                       M 	dc.b	hex|3
0000F09A =00000024                M 	__lpos:	set __endpos+1
0000F09A =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F09A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F09A                          M 	dc.b	""
0000F09A =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F09A =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F09A =0000002B                M 	__midpos:	= __endpos
0000F09A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F09A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F09A E0                       M 	dc.b	fendl
0000F09B =0000002C                M 	__lpos:	set __endpos+1
0000F09B =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F09B                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F09B                          M 	dc.b	""
0000F09B =00000037                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F09B =00000033                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F09B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F09B                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F09B B3                       M 	dc.b	sym|3
0000F09C =00000038                M 	__lpos:	set __endpos+1
0000F09C =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F09C                          M 	__substr:	substr __lpos,,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F09C                          M 	dc.b	""
0000F09C 00                       M 	dc.b	0
0000F09D 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F09E                          M 	even
0000F09E 4EFA E9BE                M 	jmp	amps_debug_console_main
0000F0A2                          M 	even
0000F0A2                          M .ok_609
0000F0A2                            
0000F0A2 3B59 0008                  		move.w	(a1)+,cPitch(a5)	; load pitch offset and channel volume
0000F0A6 4A04                       		tst.b	d4			; check if this channel is a PSG channel
0000F0A8 6B00                       		bmi.s	.loop			; if is, skip over this
0000F0AA                            
0000F0AA 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0000F0AC 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel memory too
0000F0B0 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000F0B2 4EBA 0000                  		jsr	WriteChYM(pc)		; write to part 2 channel
0000F0B6                            
0000F0B6 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this channel is a DAC channel
0000F0BA 6600                       		bne.s	.fm			; if not, branch
0000F0BC 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; DAC default frequency is $100, NOT $000
0000F0C2                            
0000F0C2                            .loop
0000F0C2 51CF FF1E                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000F0C6 4E75                       		rts
0000F0C8                            ; ---------------------------------------------------------------------------
0000F0C8                            ; The instant release for FM channels behavior was not in the Sonic 1
0000F0C8                            ; SMPS driver by default, but it has been added since it fixes an
0000F0C8                            ; issue with YM2612, where sometimes subsequent sound effect activations
0000F0C8                            ; would sound different over time. This fix will help to mitigate that.
0000F0C8                            ; ---------------------------------------------------------------------------
0000F0C8                            
0000F0C8                            .fm
0000F0C8 720F                       		moveq	#$F,d1			; set to release note instantly
0000F0CA 7080                       		moveq	#$FFFFFF80,d0		; YM address: Release Rate Operator 1
0000F0CC 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F0D0 7088                       		moveq	#$FFFFFF88,d0		; YM address: Release Rate Operator 3
0000F0D2 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F0D6 7084                       		moveq	#$FFFFFF84,d0		; YM address: Release Rate Operator 2
0000F0D8 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F0DC 708C                       		moveq	#$FFFFFF8C,d0		; YM address: Release Rate Operator 4
0000F0DE 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F0E2                            
0000F0E2 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000F0E4 122D 0001                  		move.b	cType(a5),d1		; FM channel, all operators off
0000F0E8 6100 0000                  		bsr.w	WriteYM_Pt1		; write to part 1 or 2 channel
0000F0EC                            
0000F0EC 51CF FEF4                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000F0F0 4E75                       		rts
0000F0F2                            ; ===========================================================================
0000F0F2                            ; ---------------------------------------------------------------------------
0000F0F2                            ; pointers for music channels SFX can override and addresses of SFX channels
0000F0F2                            ; ---------------------------------------------------------------------------
0000F0F2                            
0000F0F2 C698                       dSFXoffList:	dc.w mSFXFM3			; FM3
0000F0F4 C67C                       		dc.w mSFXDAC1			; DAC1
0000F0F6 C6B4                       		dc.w mSFXFM4			; FM4
0000F0F8 C6D0                       		dc.w mSFXFM5			; FM5
0000F0FA C6EC                       		dc.w mSFXPSG1			; PSG1
0000F0FC C708                       		dc.w mSFXPSG2			; PSG2
0000F0FE C724                       		dc.w mSFXPSG3			; PSG3
0000F100 C724                       		dc.w mSFXPSG3			; PSG4
0000F102                            
0000F102 C574                       dSFXoverList:	dc.w mFM3			; SFX FM3
0000F104 C4C4                       		dc.w mDAC1			; SFX DAC1
0000F106 C5A0                       		dc.w mFM4			; SFX FM4
0000F108 C5CC                       		dc.w mFM5			; SFX FM5
0000F10A C5F8                       		dc.w mPSG1			; SFX PSG1
0000F10C C624                       		dc.w mPSG2			; SFX PSG2
0000F10E C650                       		dc.w mPSG3			; SFX PSG3
0000F110 C650                       		dc.w mPSG3			; SFX PSG4
0000F112                            ; ===========================================================================
0000F112                            ; ---------------------------------------------------------------------------
0000F112                            ; Play queued command
0000F112                            ; ---------------------------------------------------------------------------
0000F112                            
0000F112                            dPlaySnd_Comm:
0000F112                            		AMPS_Debug_PlayCmd		; check if the command is valid
0000F112 0C07 0000                M 	cmp.b	#(dsoundcommands_end-dsoundcommands)/4,d7
0000F116 6300                     M 	bls.s	.ok
0000F118                          M 	raiseerror	"Invalid command in queue: %<.b d7>",amps_debug_console_channel
0000F118 487A FFFE                M 	pea	*(pc)
0000F11C                          M 	raiseerror2	"Invalid command in queue: %<.b d7>",amps_debug_console_channel
0000F11C 40E7                     M 	move.w	sr,-(sp)
0000F11E                          M 	__fstring_generateargumentscode	"Invalid command in queue: %<.b d7>"
0000F11E =0000001B                M 	__pos:	set instr("Invalid command in queue: %<.b d7>",'%<')
0000F11E =00000000                M 	__stack:set	0
0000F11E =00000000                M 	__sp:	set 0
0000F11E                          M 	while	(__pos)
0000F11E =00000022                M 	__endpos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'>')
0000F11E =00000000                M 	__midpos:	set instr(__pos+5,"Invalid command in queue: %<.b d7>",' ')
0000F11E =00000022                M 	__midpos:	= __endpos
0000F11E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000F11E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid command in queue: %<.b d7>"
0000F11E                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid command in queue: %<.b d7>"
0000F11E                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000F11E                          M 	pushp	"move.b d7,1(sp)"
0000F11E                          M 	pushp	"subq.w	#2, sp"
0000F11E =00000002                M 	__stack:	= __stack+2
0000F11E =00000002                M 	__sp:	= __sp+2
0000F11E =00000000                M 	__pos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'%<')
0000F11E                          M 	rept	__stack
0000F11E                          M 	popp	__command
0000F11E 554F                     M 	subq.w	#2,sp
0000F120                          M 	popp	__command
0000F120 1F47 0001                M 	move.b	d7,1(sp)
0000F124 4EB9 0000 0000           M 	jsr	errorhandler
0000F12A                          M 	__fstring_generatedecodedstring	"Invalid command in queue: %<.b d7>"
0000F12A =00000001                M 	__lpos:	set 1
0000F12A =0000001B                M 	__pos:	set instr("Invalid command in queue: %<.b d7>",'%<')
0000F12A                          M 	while	(__pos)
0000F12A                          M 	__substr:	substr __lpos,__pos-1,"Invalid command in queue: %<.b d7>"
0000F12A 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command in queue: "
0000F144 =00000022                M 	__endpos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'>')
0000F144 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid command in queue: %<.b d7>",' ')
0000F144 =00000022                M 	__midpos:	= __endpos
0000F144                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid command in queue: %<.b d7>"
0000F144                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000F144                          M 	__param:	substr ,,"hex"
0000F144 80                       M 	dc.b	hex
0000F145 =00000023                M 	__lpos:	set __endpos+1
0000F145 =00000000                M 	__pos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'%<')
0000F145                          M 	__substr:	substr __lpos,,"Invalid command in queue: %<.b d7>"
0000F145                          M 	dc.b	""
0000F145 00                       M 	dc.b	0
0000F146 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F148 00                       M 	even
0000F148 4EFA E16E                M 	jmp	amps_debug_console_channel
0000F14C                          M 	even
0000F14C                          M .ok
0000F14C                            
0000F14C DE47                       		add.w	d7,d7			; quadruple ID
0000F14E DE47                       		add.w	d7,d7			; because each entry is 1 long word
0000F150 4EFB 7000                  		jmp	dSoundCommands-4(pc,d7.w); jump to appropriate command handler
0000F154                            
0000F154                            ; ---------------------------------------------------------------------------
0000F154                            dSoundCommands:
0000F154 6000 0000                  		bra.w	dPlaySnd_Reset		; 01 - Reset underwater and speed shoes flags, update volume
0000F158 6000 0000                  		bra.w	dPlaySnd_FadeOut	; 02 - Initialize a music fade out
0000F15C 6000 0000                  		bra.w	dPlaySnd_Stop		; 03 - Stop all music
0000F160 6000 0000                  		bra.w	dPlaySnd_ShoesOn	; 04 - Enable speed shoes mode
0000F164 6000 0000                  		bra.w	dPlaySnd_ShoesOff	; 05 - Disable speed shoes mode
0000F168 6000 0000                  		bra.w	dPlaySnd_ToWater	; 06 - Enable underwater mode
0000F16C 6000 0000                  		bra.w	dPlaySnd_OutWater	; 07 - Disable underwater mode
0000F170 6000 FA38                  		bra.w	dPlaySnd_Pause		; 08 - Pause the sound driver
0000F174 6000 F9D4                  		bra.w	dPlaySnd_Unpause	; 09 - Unpause the sound driver
0000F178                            dSoundCommands_End:
0000F178                            ; ===========================================================================
0000F178                            ; ---------------------------------------------------------------------------
0000F178                            ; Commands for what to do after a volume fade
0000F178                            ; ---------------------------------------------------------------------------
0000F178                            
0000F178                            dFadeCommands:
0000F178 4E75                       		rts				; 80 - Do nothing
0000F17A 4E75                       		rts
0000F17C 6000                       .stop		bra.s	dPlaySnd_Stop		; 84 - Stop all music
0000F17E 4E75                       		rts
0000F180 6000 0000                  .resv		bra.w	dResetVolume		; 88 - Reset volume and update
0000F184 61FA                       		bsr.s	.resv			; 8C - Stop music playing and reset volume
0000F186 60F4                       		bra.s	.stop
0000F188                            ; ===========================================================================
0000F188                            ; ---------------------------------------------------------------------------
0000F188                            ; Stop music and SFX from playing (This code clears SFX RAM also)
0000F188                            ; ---------------------------------------------------------------------------
0000F188                            
0000F188                            dPlaySnd_Stop:
0000F188                            ; Not needed,	moveq	#$2B,d0			; YM command: DAC Enable
0000F188                            ; Dual PCM does	moveq	#$FFFFFF80,d1		; FM6 acts as DAC
0000F188                            ; this for us	jsr	WriteYM_Pt1(pc)		; write to YM global register
0000F188                            
0000F188 7027                       		moveq	#$27,d0			; YM command: Channel 3 Mode & Timer Control
0000F18A 7200                       		moveq	#0,d1			; disable timers and channel 3 special mode
0000F18C 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to YM global register
0000F190                            
0000F190 43F8 C67C                  		lea	mSFXDAC1.w,a1		; prepare SFX DAC 1 to start clearing fromn
0000F194                            
0000F194                            	rept (mSize-mSFXDAC1)/4
0000F194                            		clr.l	(a1)+			; clear entire SFX RAM (others done below)
0000F194                            	endr
0000F194 4299                     M 	clr.l	(a1)+
0000F196 4299                     M 	clr.l	(a1)+
0000F198 4299                     M 	clr.l	(a1)+
0000F19A 4299                     M 	clr.l	(a1)+
0000F19C 4299                     M 	clr.l	(a1)+
0000F19E 4299                     M 	clr.l	(a1)+
0000F1A0 4299                     M 	clr.l	(a1)+
0000F1A2 4299                     M 	clr.l	(a1)+
0000F1A4 4299                     M 	clr.l	(a1)+
0000F1A6 4299                     M 	clr.l	(a1)+
0000F1A8 4299                     M 	clr.l	(a1)+
0000F1AA 4299                     M 	clr.l	(a1)+
0000F1AC 4299                     M 	clr.l	(a1)+
0000F1AE 4299                     M 	clr.l	(a1)+
0000F1B0 4299                     M 	clr.l	(a1)+
0000F1B2 4299                     M 	clr.l	(a1)+
0000F1B4 4299                     M 	clr.l	(a1)+
0000F1B6 4299                     M 	clr.l	(a1)+
0000F1B8 4299                     M 	clr.l	(a1)+
0000F1BA 4299                     M 	clr.l	(a1)+
0000F1BC 4299                     M 	clr.l	(a1)+
0000F1BE 4299                     M 	clr.l	(a1)+
0000F1C0 4299                     M 	clr.l	(a1)+
0000F1C2 4299                     M 	clr.l	(a1)+
0000F1C4 4299                     M 	clr.l	(a1)+
0000F1C6 4299                     M 	clr.l	(a1)+
0000F1C8 4299                     M 	clr.l	(a1)+
0000F1CA 4299                     M 	clr.l	(a1)+
0000F1CC 4299                     M 	clr.l	(a1)+
0000F1CE 4299                     M 	clr.l	(a1)+
0000F1D0 4299                     M 	clr.l	(a1)+
0000F1D2 4299                     M 	clr.l	(a1)+
0000F1D4 4299                     M 	clr.l	(a1)+
0000F1D6 4299                     M 	clr.l	(a1)+
0000F1D8 4299                     M 	clr.l	(a1)+
0000F1DA 4299                     M 	clr.l	(a1)+
0000F1DC 4299                     M 	clr.l	(a1)+
0000F1DE 4299                     M 	clr.l	(a1)+
0000F1E0 4299                     M 	clr.l	(a1)+
0000F1E2 4299                     M 	clr.l	(a1)+
0000F1E4 4299                     M 	clr.l	(a1)+
0000F1E6 4299                     M 	clr.l	(a1)+
0000F1E8 4299                     M 	clr.l	(a1)+
0000F1EA 4299                     M 	clr.l	(a1)+
0000F1EC 4299                     M 	clr.l	(a1)+
0000F1EE 4299                     M 	clr.l	(a1)+
0000F1F0 4299                     M 	clr.l	(a1)+
0000F1F2 4299                     M 	clr.l	(a1)+
0000F1F4 4299                     M 	clr.l	(a1)+
0000F1F6                            
0000F1F6 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0000F1F8                            	; continue straight to stopping music
0000F1F8                            ; ===========================================================================
0000F1F8                            ; ---------------------------------------------------------------------------
0000F1F8                            ; Stop music from playing, reset driver memory and mute hardware
0000F1F8                            ; ---------------------------------------------------------------------------
0000F1F8                            
0000F1F8                            dStopMusic:
0000F1F8 43F8 C4A6                  		lea	mFlags.w,a1		; load driver RAM start to a1
0000F1FC 3611                       		move.w	(a1),d3			; load driver flags and PAL counter to d3
0000F1FE 1838 C4C0                  		move.b	mMasterVolDAC.w,d4	; load DAC master volume to d4
0000F202 2A38 C4BC                  		move.l	mQueue.w,d5		; load sound queue and PSG master volume to d5
0000F206 4CF8 0007 C4AC             		movem.l	mComm.w,d0-d2		; load communications bytes, FM master volume and fade address to d0-d2
0000F20C                            
0000F20C                            	rept (mSFXDAC1-mFlags)/4
0000F20C                            		clr.l	(a1)+			; clear driver and music channel memory
0000F20C                            	endr
0000F20C 4299                     M 	clr.l	(a1)+
0000F20E 4299                     M 	clr.l	(a1)+
0000F210 4299                     M 	clr.l	(a1)+
0000F212 4299                     M 	clr.l	(a1)+
0000F214 4299                     M 	clr.l	(a1)+
0000F216 4299                     M 	clr.l	(a1)+
0000F218 4299                     M 	clr.l	(a1)+
0000F21A 4299                     M 	clr.l	(a1)+
0000F21C 4299                     M 	clr.l	(a1)+
0000F21E 4299                     M 	clr.l	(a1)+
0000F220 4299                     M 	clr.l	(a1)+
0000F222 4299                     M 	clr.l	(a1)+
0000F224 4299                     M 	clr.l	(a1)+
0000F226 4299                     M 	clr.l	(a1)+
0000F228 4299                     M 	clr.l	(a1)+
0000F22A 4299                     M 	clr.l	(a1)+
0000F22C 4299                     M 	clr.l	(a1)+
0000F22E 4299                     M 	clr.l	(a1)+
0000F230 4299                     M 	clr.l	(a1)+
0000F232 4299                     M 	clr.l	(a1)+
0000F234 4299                     M 	clr.l	(a1)+
0000F236 4299                     M 	clr.l	(a1)+
0000F238 4299                     M 	clr.l	(a1)+
0000F23A 4299                     M 	clr.l	(a1)+
0000F23C 4299                     M 	clr.l	(a1)+
0000F23E 4299                     M 	clr.l	(a1)+
0000F240 4299                     M 	clr.l	(a1)+
0000F242 4299                     M 	clr.l	(a1)+
0000F244 4299                     M 	clr.l	(a1)+
0000F246 4299                     M 	clr.l	(a1)+
0000F248 4299                     M 	clr.l	(a1)+
0000F24A 4299                     M 	clr.l	(a1)+
0000F24C 4299                     M 	clr.l	(a1)+
0000F24E 4299                     M 	clr.l	(a1)+
0000F250 4299                     M 	clr.l	(a1)+
0000F252 4299                     M 	clr.l	(a1)+
0000F254 4299                     M 	clr.l	(a1)+
0000F256 4299                     M 	clr.l	(a1)+
0000F258 4299                     M 	clr.l	(a1)+
0000F25A 4299                     M 	clr.l	(a1)+
0000F25C 4299                     M 	clr.l	(a1)+
0000F25E 4299                     M 	clr.l	(a1)+
0000F260 4299                     M 	clr.l	(a1)+
0000F262 4299                     M 	clr.l	(a1)+
0000F264 4299                     M 	clr.l	(a1)+
0000F266 4299                     M 	clr.l	(a1)+
0000F268 4299                     M 	clr.l	(a1)+
0000F26A 4299                     M 	clr.l	(a1)+
0000F26C 4299                     M 	clr.l	(a1)+
0000F26E 4299                     M 	clr.l	(a1)+
0000F270 4299                     M 	clr.l	(a1)+
0000F272 4299                     M 	clr.l	(a1)+
0000F274 4299                     M 	clr.l	(a1)+
0000F276 4299                     M 	clr.l	(a1)+
0000F278 4299                     M 	clr.l	(a1)+
0000F27A 4299                     M 	clr.l	(a1)+
0000F27C 4299                     M 	clr.l	(a1)+
0000F27E 4299                     M 	clr.l	(a1)+
0000F280 4299                     M 	clr.l	(a1)+
0000F282 4299                     M 	clr.l	(a1)+
0000F284 4299                     M 	clr.l	(a1)+
0000F286 4299                     M 	clr.l	(a1)+
0000F288 4299                     M 	clr.l	(a1)+
0000F28A 4299                     M 	clr.l	(a1)+
0000F28C 4299                     M 	clr.l	(a1)+
0000F28E 4299                     M 	clr.l	(a1)+
0000F290 4299                     M 	clr.l	(a1)+
0000F292 4299                     M 	clr.l	(a1)+
0000F294 4299                     M 	clr.l	(a1)+
0000F296 4299                     M 	clr.l	(a1)+
0000F298 4299                     M 	clr.l	(a1)+
0000F29A 4299                     M 	clr.l	(a1)+
0000F29C 4299                     M 	clr.l	(a1)+
0000F29E 4299                     M 	clr.l	(a1)+
0000F2A0 4299                     M 	clr.l	(a1)+
0000F2A2 4299                     M 	clr.l	(a1)+
0000F2A4 4299                     M 	clr.l	(a1)+
0000F2A6 4299                     M 	clr.l	(a1)+
0000F2A8 4299                     M 	clr.l	(a1)+
0000F2AA 4299                     M 	clr.l	(a1)+
0000F2AC 4299                     M 	clr.l	(a1)+
0000F2AE 4299                     M 	clr.l	(a1)+
0000F2B0 4299                     M 	clr.l	(a1)+
0000F2B2 4299                     M 	clr.l	(a1)+
0000F2B4 4299                     M 	clr.l	(a1)+
0000F2B6 4299                     M 	clr.l	(a1)+
0000F2B8 4299                     M 	clr.l	(a1)+
0000F2BA 4299                     M 	clr.l	(a1)+
0000F2BC 4299                     M 	clr.l	(a1)+
0000F2BE 4299                     M 	clr.l	(a1)+
0000F2C0 4299                     M 	clr.l	(a1)+
0000F2C2 4299                     M 	clr.l	(a1)+
0000F2C4 4299                     M 	clr.l	(a1)+
0000F2C6 4299                     M 	clr.l	(a1)+
0000F2C8 4299                     M 	clr.l	(a1)+
0000F2CA 4299                     M 	clr.l	(a1)+
0000F2CC 4299                     M 	clr.l	(a1)+
0000F2CE 4299                     M 	clr.l	(a1)+
0000F2D0 4299                     M 	clr.l	(a1)+
0000F2D2 4299                     M 	clr.l	(a1)+
0000F2D4 4299                     M 	clr.l	(a1)+
0000F2D6 4299                     M 	clr.l	(a1)+
0000F2D8 4299                     M 	clr.l	(a1)+
0000F2DA 4299                     M 	clr.l	(a1)+
0000F2DC 4299                     M 	clr.l	(a1)+
0000F2DE 4299                     M 	clr.l	(a1)+
0000F2E0 4299                     M 	clr.l	(a1)+
0000F2E2 4299                     M 	clr.l	(a1)+
0000F2E4 4299                     M 	clr.l	(a1)+
0000F2E6 4299                     M 	clr.l	(a1)+
0000F2E8 4299                     M 	clr.l	(a1)+
0000F2EA 4299                     M 	clr.l	(a1)+
0000F2EC 4299                     M 	clr.l	(a1)+
0000F2EE 4299                     M 	clr.l	(a1)+
0000F2F0 4299                     M 	clr.l	(a1)+
0000F2F2 4299                     M 	clr.l	(a1)+
0000F2F4 4299                     M 	clr.l	(a1)+
0000F2F6                            
0000F2F6 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0000F2F8                            
0000F2F8 31C3 C4A6                  		move.w	d3,mFlags.w		; save driver flags and PAL counter
0000F2FC 11C4 C4C0                  		move.b	d4,mMasterVolDAC.w	; save DAC master volume
0000F300 21C5 C4BC                  		move.l	d5,mQueue.w		; save sound queue and PSG master volume
0000F304 48F8 0007 C4AC             		movem.l	d0-d2,mComm.w		; save communications bytes, FM master volume and fade address
0000F30A                            
0000F30A 6100                       		bsr.s	dMutePSG		; hardware mute PSG
0000F30C 4EBA F8D0                  		jsr	dMuteDAC(pc)		; hardware mute DAC
0000F310                            	; continue straight to hardware muting FM
0000F310                            ; ===========================================================================
0000F310                            ; ---------------------------------------------------------------------------
0000F310                            ; Mute all FM channels
0000F310                            ; ---------------------------------------------------------------------------
0000F310                            
0000F310                            dMuteFM:
0000F310 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000F312 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0000F314                            
0000F314                            .noteoff
0000F314 1203                       		move.b	d3,d1			; copy value into d1
0000F316 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000F31A 5801                       		addq.b	#4,d1			; set this to part 2 channel
0000F31C 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000F320 51CB FFF2                  		dbf	d3,.noteoff		; loop for all 3 channel groups
0000F324                            
0000F324 7040                       		moveq	#$40,d0			; YM command: Total Level Operator 1
0000F326 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0000F328 7802                       		moveq	#3-1,d4			; prepare 3 groups of channels to d4
0000F32A                            
0000F32A                            .chloop
0000F32A 7603                       		moveq	#4-1,d3			; prepare 4 operator writes per channel to d3
0000F32C 7A0F                       		moveq	#$10-1,d5		; prepare the value for going to next channel to d5
0000F32E                            
0000F32E                            .oploop
0000F32E 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000F332 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000F336 5840                       		addq.w	#4,d0			; go to next operator (1 2 3 4)
0000F338 51CB FFF4                  		dbf	d3,.oploop		; repeat for each operator
0000F33C                            
0000F33C 9005                       		sub.b	d5,d0			; go to next FM channel
0000F33E 51CC FFEA                  		dbf	d4,.chloop		; repeat for each channel
0000F342 4E75                       		rts
0000F344                            ; ===========================================================================
0000F344                            ; ---------------------------------------------------------------------------
0000F344                            ; Routine for muting all PSG channels
0000F344                            ; ---------------------------------------------------------------------------
0000F344                            
0000F344                            dMutePSG:
0000F344 43F9 00C0 0011             		lea	dPSG,a1			; load PSG data port address to a1
0000F34A 12BC 009F                  		move.b	#ctPSG1|$1F,(a1)	; send volume mute command for PSG1 to PSG
0000F34E 12BC 00BF                  		move.b	#ctPSG2|$1F,(a1)	; send volume mute command for PSG2 to PSG
0000F352 12BC 00DF                  		move.b	#ctPSG3|$1F,(a1)	; send volume mute command for PSG3 to PSG
0000F356 12BC 00FF                  		move.b	#ctPSG4|$1F,(a1)	; send volume mute command for PSG4 to PSG
0000F35A 4E75                       		rts
0000F35C                            ; ===========================================================================
0000F35C                            ; ---------------------------------------------------------------------------
0000F35C                            ; Normal fade out data
0000F35C                            ; ---------------------------------------------------------------------------
0000F35C                            
0000F35C                            dFadeOutDataLog:
0000F35C 0101 0002 0200 0204 0103+  	dc.b $01, $01, $00,  $02, $02, $00,  $02, $04, $01,  $03, $05, $01
0000F368 0405 0104 0602 0507 0206+  	dc.b $04, $05, $01,  $04, $06, $02,  $05, $07, $02,  $06, $08, $02
0000F374 0709 0309 0B03 0A0C 030C+  	dc.b $07, $09, $03,  $09, $0B, $03,  $0A, $0C, $03,  $0C, $0E, $03
0000F380 0E10 0410 1104 1113 0414+  	dc.b $0E, $10, $04,  $10, $11, $04,  $11, $13, $04,  $14, $15, $05
0000F38C 1618 051A 1C05 1C1F 0620+  	dc.b $16, $18, $05,  $1A, $1C, $05,  $1C, $1F, $06,  $20, $24, $06
0000F398 2228 0726 2E07 2C34 0830+  	dc.b $22, $28, $07,  $26, $2E, $07,  $2C, $34, $08,  $30, $39, $08
0000F3A4 343E 093C 440A 404C 0A46+  	dc.b $34, $3E, $09,  $3C, $44, $0A,  $40, $4C, $0A,  $46, $54, $0B
0000F3B0 4C5A 0C54 620D 5C6B 0D60+  	dc.b $4C, $5A, $0C,  $54, $62, $0D,  $5C, $6B, $0D,  $60, $76, $0E
0000F3BC 6C7C 0E74 7F0F 7F7F 0F8C   	dc.b $6C, $7C, $0E,  $74, $7F, $0F,  $7F, $7F, $0F,  fReset
0000F3C6                            
0000F3C6                            ;dFadeOutDataLinear:
0000F3C6                            ;	dc.b $01, $00, $00,  $02, $01, $00,  $02, $01, $01,  $03, $02, $01
0000F3C6                            ;	dc.b $04, $02, $01,  $04, $03, $02,  $05, $03, $02,  $06, $04, $02
0000F3C6                            ;	dc.b $07, $05, $03,  $09, $06, $03,  $0A, $08, $03,  $0C, $0A, $03
0000F3C6                            ;	dc.b $0E, $0D, $04,  $10, $0F, $04,  $11, $10, $04,  $14, $13, $05
0000F3C6                            ;	dc.b $16, $16, $05,  $1A, $1A, $05,  $1C, $1E, $06,  $20, $22, $06
0000F3C6                            ;	dc.b $22, $27, $07,  $26, $2A, $07,  $2C, $2E, $08,  $30, $34, $08
0000F3C6                            ;	dc.b $34, $39, $09,  $3C, $3E, $0A,  $40, $3F, $0A,  $46, $40, $0B
0000F3C6                            ;	dc.b $4C, $40, $0C,  $54, $40, $0D,  $5C, $40, $0D,  $60, $40, $0E
0000F3C6                            ;	dc.b $6C, $40, $0E,  $74, $40, $0F,  $7F, $40, $0F,  fReset
0000F3C6                            	even
0000F3C6                            ; ===========================================================================
0000F3C6                            ; ---------------------------------------------------------------------------
0000F3C6                            ; Subroutine for initializing a fade effect.
0000F3C6                            ; Since the driver allows for such an extensive and customizable
0000F3C6                            ; fading code, we may hit a snag if we use fades too fast. It is
0000F3C6                            ; possible, for example, to fade out, then in the middle of that,
0000F3C6                            ; start fading in. This would normally cause a quick jump in the
0000F3C6                            ; volume level from maybe half to completely mute. This routine
0000F3C6                            ; aims to combat this by actually searching for the closest FM
0000F3C6                            ; volume level in the fade program, and to start the new fade from
0000F3C6                            ; where that byte appears. This can alter how long a volume fade
0000F3C6                            ; lasts however, and if PSG and DAC volume are not correct faded,
0000F3C6                            ; it may still cause a jump in their volume (especially if only,
0000F3C6                            ; say, DAC fades volume). In the future, there might be a fix for
0000F3C6                            ; that.
0000F3C6                            ; ---------------------------------------------------------------------------
0000F3C6                            
0000F3C6                            dPlaySnd_FadeOut:
0000F3C6 43FA FF94                  		lea	dFadeOutDataLog(pc),a1	; prepare stock fade out program to a1
0000F3CA                            
0000F3CA                            dLoadFade:
0000F3CA 1038 C4B4                  		move.b	mMasterVolFM.w,d0	; load FM master volume to d0
0000F3CE 4A38 C4B5                  		tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0000F3D2 6700                       		beq.s	.nofade			; if not, load fade as is
0000F3D4                            
0000F3D4 2449                       		move.l	a1,a2			; copy fade program address to a2
0000F3D6 74FF                       		moveq	#-1,d2			; prepare max byter difference
0000F3D8                            
0000F3D8                            .find
0000F3D8 1212                       		move.b	(a2),d1			; load the next FM volume from fade program
0000F3DA 6A00                       		bpl.s	.search			; branch if this is not a command
0000F3DC                            
0000F3DC                            .nofade
0000F3DC 21C9 C4B4                  		move.l	a1,mFadeAddr.w		; save new fade program address to memory
0000F3E0 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save new FM master volume
0000F3E4 4E75                       		rts
0000F3E6                            
0000F3E6                            .search
0000F3E6 568A                       		addq.l	#3,a2			; skip over the current volume group
0000F3E8 9200                       		sub.b	d0,d1			; sub current FM volume from read volume
0000F3EA 6A00                       		bpl.s	.abs			; if positive, do not negate
0000F3EC 4401                       		neg.b	d1			; negative to positive
0000F3EE                            
0000F3EE                            .abs
0000F3EE B202                       		cmp.b	d2,d1			; check if volume difference was smaller than before
0000F3F0 64E6                       		bhs.s	.find			; if not, read next group
0000F3F2                            
0000F3F2 1401                       		move.b	d1,d2			; else save the new difference
0000F3F4 224A                       		move.l	a2,a1			; also save the fade program address where we found it
0000F3F6 60E0                       		bra.s	.find			; loop through each group in the program
0000F3F8                            ; ===========================================================================
0000F3F8                            ; ---------------------------------------------------------------------------
0000F3F8                            ; Routine for loading a volume filter into Dual PCM ROM.
0000F3F8                            ; This routine will actually write the bank number the volume filter
0000F3F8                            ; is in. This requires volume filters are aligned to Z80 banks, and
0000F3F8                            ; just because we can, we write 9 bits (yeah its not necessary, but
0000F3F8                            ; what the hell, you have to have fun sometimes!)
0000F3F8                            ; ---------------------------------------------------------------------------
0000F3F8                            
0000F3F8                            dSetFilter:
0000F3F8 43F9 0000 0000             		lea	dZ80+SV_VolumeBank,a1	; load volume bank instructions address to a1
0000F3FE 7274                       		moveq	#$74,d1			; prepare the "ld  (hl),h" instruction to d1
0000F400 7408                       		moveq	#9-1,d2			; prepare number of instructions to write to d2
0000F402                            	StopZ80					; wait for Z80 to stop
0000F402 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F40A                          M 	waitz80stop
0000F40A 0839 0000 00A1 1100      M .wait_620:	btst	#0,z80_bus_req
0000F412 66F6                     M 	bne.s	.wait_620
0000F414                            ; ---------------------------------------------------------------------------
0000F414                            ; addx in Motorola 68000 is much like adc in Z80. It allows us to add
0000F414                            ; a register AND the carry to another register. What this means, is if
0000F414                            ; we push 1 into carry (so, carry set), we will be loading $75 instead
0000F414                            ; of $74 into the carry, making us able to switch between the Z80
0000F414                            ; instructions  "ld  (hl),h" and "ld  (hl),l", which in turn allows
0000F414                            ; Dual PCM to bank switch into the appropriate bank.
0000F414                            ; ---------------------------------------------------------------------------
0000F414                            
0000F414                            .loop
0000F414 7600                       		moveq	#0,d3			; prepare 0 into d3 (because of addx)
0000F416 E248                       		lsr.w	#1,d0			; shift lsb into carry
0000F418 D701                       		addx.b	d1,d3			; add instruction and carry into d3
0000F41A                            
0000F41A 12C3                       		move.b	d3,(a1)+		; save instruction into Z80 memory
0000F41C 51CA FFF6                  		dbf	d2,.loop		; repeat for each bit/instruction
0000F420                            	StartZ80				; enable Z80 execution
0000F420 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F428 4E75                       		rts
0000F42A                            
0000F42A                            ; ===========================================================================
0000F42A                            ; ---------------------------------------------------------------------------
0000F42A                            ; Routine for resetting master volumes, filters and disabling fading
0000F42A                            ; ---------------------------------------------------------------------------
0000F42A                            
0000F42A                            dResetVolume:
0000F42A 42B8 C4B4                  		clr.l	mFadeAddr.w		; stop fading program and reset FM master volume
0000F42E 4238 C4BF                  		clr.b	mMasterVolPSG.w		; reset PSG master volume
0000F432 4238 C4C0                  		clr.b	mMasterVolDAC.w		; reset DAC master volume
0000F436 303C 0000                  		move.w	#fLog>>$0F,d0		; load value for linear filter
0000F43A 61BC                       		bsr.s	dSetFilter		; load filter instructions
0000F43C                            
0000F43C                            dUpdateVolumeAll:
0000F43C 6100                       		bsr.s	dReqVolUpFM		; request FM volume update
0000F43E 8138 C67C                  		or.b	d0,mSFXDAC1.w		; request update for SFX DAC1 channel
0000F442                            
0000F442 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0000F442                            	rept Mus_DAC				; loop through all music DAC channels
0000F442                            		or.b	d0,.ch.w		; request channel volume update
0000F442                            .ch =		.ch+cSize			; go to next channel
0000F442                            	endr
0000F442 8138 C4C4                M 	or.b	d0,.ch.w
0000F446 =FFFFC4F0                M .ch	=	.ch+csize
0000F446 8138 C4F0                M 	or.b	d0,.ch.w
0000F44A =FFFFC51C                M .ch	=	.ch+csize
0000F44A                            
0000F44A =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0000F44A                            	rept Mus_PSG				; loop through all music PSG channels
0000F44A                            		or.b	d0,.ch.w		; request channel volume update
0000F44A                            .ch =		.ch+cSize			; go to next channel
0000F44A                            	endr
0000F44A 8138 C5F8                M 	or.b	d0,.ch.w
0000F44E =FFFFC624                M .ch	=	.ch+csize
0000F44E 8138 C624                M 	or.b	d0,.ch.w
0000F452 =FFFFC650                M .ch	=	.ch+csize
0000F452 8138 C650                M 	or.b	d0,.ch.w
0000F456 =FFFFC67C                M .ch	=	.ch+csize
0000F456                            
0000F456 =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0000F456                            	rept SFX_PSG				; loop through all SFX PSG channels
0000F456                            		or.b	d0,.ch.w		; request channel volume update
0000F456                            .ch =		.ch+cSizeSFX			; go to next channel
0000F456                            	endr
0000F456 8138 C6EC                M 	or.b	d0,.ch.w
0000F45A =FFFFC708                M .ch	=	.ch+csizesfx
0000F45A 8138 C708                M 	or.b	d0,.ch.w
0000F45E =FFFFC724                M .ch	=	.ch+csizesfx
0000F45E 8138 C724                M 	or.b	d0,.ch.w
0000F462 =FFFFC740                M .ch	=	.ch+csizesfx
0000F462 4E75                       		rts
0000F464                            ; ===========================================================================
0000F464                            ; ---------------------------------------------------------------------------
0000F464                            ; Enable speed shoes mode
0000F464                            ; ---------------------------------------------------------------------------
0000F464                            
0000F464                            dPlaySnd_ShoesOn:
0000F464 11F8 C4B9 C4BB             		move.b	mTempoSpeed.w,mTempoCur.w; set tempo accumulator/counter to speed shoes one
0000F46A 11F8 C4B9 C4BA             		move.b	mTempoSpeed.w,mTempo.w	; set main tempor to speed shoes one
0000F470 08F8 0001 C4A6             		bset	#mfbSpeed,mFlags.w	; enable speed shoes flag
0000F476 4E75                       		rts
0000F478                            ; ===========================================================================
0000F478                            ; ---------------------------------------------------------------------------
0000F478                            ; Reset music flags (underwater mode and tempo mode)
0000F478                            ; ---------------------------------------------------------------------------
0000F478                            
0000F478                            dPlaySnd_Reset:
0000F478 6100                       		bsr.s	dPlaySnd_OutWater	; gp reset underwater flag and request volume update
0000F47A                            ; ===========================================================================
0000F47A                            ; ---------------------------------------------------------------------------
0000F47A                            ; Disable speed shoes mode
0000F47A                            ; ---------------------------------------------------------------------------
0000F47A                            
0000F47A                            dPlaySnd_ShoesOff:
0000F47A 11F8 C4B8 C4BB             		move.b	mTempoMain.w,mTempoCur.w; set tempo accumulator/counter to normal one
0000F480 11F8 C4B8 C4BA             		move.b	mTempoMain.w,mTempo.w	; set main tempor to normal one
0000F486 08B8 0001 C4A6             		bclr	#mfbSpeed,mFlags.w	; disable speed shoes flag
0000F48C 4E75                       		rts
0000F48E                            ; ===========================================================================
0000F48E                            ; ---------------------------------------------------------------------------
0000F48E                            ; Enable Underwater mode
0000F48E                            ; ---------------------------------------------------------------------------
0000F48E                            
0000F48E                            dPlaySnd_ToWater:
0000F48E 08F8 0002 C4A6             		bset	#mfbWater,mFlags.w	; enable underwater mode
0000F494 6000                       		bra.s	dReqVolUpFM		; request FM volume update
0000F496                            ; ===========================================================================
0000F496                            ; ---------------------------------------------------------------------------
0000F496                            ; Disable Underwater mode
0000F496                            ; ---------------------------------------------------------------------------
0000F496                            
0000F496                            dPlaySnd_OutWater:
0000F496 08B8 0002 C4A6             		bclr	#mfbWater,mFlags.w	; disable underwater mode
0000F49C                            ; ===========================================================================
0000F49C                            ; ---------------------------------------------------------------------------
0000F49C                            ; force volume update on all FM channels
0000F49C                            ; ---------------------------------------------------------------------------
0000F49C                            
0000F49C                            dReqVolUpFM;
0000F49C 7020                       		moveq	#1<<cfbVol,d0		; prepare volume update flag to d0
0000F49E =FFFFC51C                  .ch =	mFM1					; start at FM1
0000F49E                            	rept Mus_FM				; loop through all music FM channels
0000F49E                            		or.b	d0,.ch.w		; request channel volume update
0000F49E                            .ch =		.ch+cSize			; go to next channel
0000F49E                            	endr
0000F49E 8138 C51C                M 	or.b	d0,.ch.w
0000F4A2 =FFFFC548                M .ch	=	.ch+csize
0000F4A2 8138 C548                M 	or.b	d0,.ch.w
0000F4A6 =FFFFC574                M .ch	=	.ch+csize
0000F4A6 8138 C574                M 	or.b	d0,.ch.w
0000F4AA =FFFFC5A0                M .ch	=	.ch+csize
0000F4AA 8138 C5A0                M 	or.b	d0,.ch.w
0000F4AE =FFFFC5CC                M .ch	=	.ch+csize
0000F4AE 8138 C5CC                M 	or.b	d0,.ch.w
0000F4B2 =FFFFC5F8                M .ch	=	.ch+csize
0000F4B2                            
0000F4B2 =FFFFC698                  .ch =	mSFXFM3					; start at SFX FM3
0000F4B2                            	rept SFX_FM				; loop through all SFX FM channels
0000F4B2                            		or.b	d0,.ch.w		; request channel volume update
0000F4B2                            .ch =		.ch+cSizeSFX			; go to next channel
0000F4B2                            	endr
0000F4B2 8138 C698                M 	or.b	d0,.ch.w
0000F4B6 =FFFFC6B4                M .ch	=	.ch+csizesfx
0000F4B6 8138 C6B4                M 	or.b	d0,.ch.w
0000F4BA =FFFFC6D0                M .ch	=	.ch+csizesfx
0000F4BA 8138 C6D0                M 	or.b	d0,.ch.w
0000F4BE =FFFFC6EC                M .ch	=	.ch+csizesfx
0000F4BE 4E75                       		rts
0000F4C0                            ; ===========================================================================
0000F4C0                            ; ---------------------------------------------------------------------------
0000F4C0                            ; Subroutine for updating Total Levels for FM channel
0000F4C0                            ; ---------------------------------------------------------------------------
0000F4C0                            
0000F4C0                            dUpdateVolFM:
0000F4C0 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000F4C4 6600                       		bne.s	locret_VolFM		; if yes, do not update
0000F4C6                            
0000F4C6 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0000F4CA D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0000F4CE 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0000F4D0 767F                       		moveq	#$7F,d3			; force FM volume to silence
0000F4D2                            
0000F4D2                            .noover
0000F4D2 7000                       		moveq	#0,d0
0000F4D4 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0000F4D8 224E                       		move.l	a6,a1			; copy music voice table address to a1
0000F4DA                            
0000F4DA                            	dCALC_VOICE				; get address of the specific voice to a1
0000F4DA EB48                     M 	lsl.w	#5,d0
0000F4DC D2C0                     M 	add.w	d0,a1
0000F4DE 1011                       		move.b	(a1),d0			; load algorithm and feedback to d0
0000F4E0 7C00                       		moveq	#0,d6			; reset the modulator offset
0000F4E2                            
0000F4E2 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0000F4E8 6700                       		beq.s	.uwdone			; if not, skip
0000F4EA 1C00                       		move.b	d0,d6			; copy algorithm and feedback to d6
0000F4EC 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0000F4F0 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0000F4F2 1C00                       		move.b	d0,d6			; set algorithm and feedback to modulator offset
0000F4F4                            
0000F4F4                            .uwdone
0000F4F4 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0000F4F6 D2FC 0019                  		add.w	#VoiceTL,a1		; go to the Total Level offset of the voice
0000F4FA 45FA 0000                  		lea	dOpTLFM(pc),a2		; load Total Level address table to a3
0000F4FE                            
0000F4FE                            .tlloop
0000F4FE 101A                       		move.b	(a2)+,d0		; load YM address to write to
0000F500 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0000F502 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0000F504                            
0000F504 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0000F506 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0000F508 727F                       		moveq	#$7F,d1			; cap to silent volume
0000F50A 6000                       		bra.s	.slot
0000F50C                            
0000F50C                            .noslot
0000F50C D206                       		add.b	d6,d1			; add modulator offset to loaded value
0000F50E                            .slot
0000F50E 4EBA 0000                  		jsr	WriteChYM(pc)		; write Total Level to YM according to channel
0000F512                            .ignore
0000F512 51CD FFEA                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0000F516                            
0000F516                            		AMPS_Debug_UpdVolFM		; check if the voice was valid
0000F516 0C19 004E                M 	cmp.b	#'N',(a1)+
0000F51A 6600                     M 	bne.s	.fail
0000F51C 0C59 4154                M 	cmp.w	#'AT',(a1)+
0000F520 6700                     M 	beq.s	.ok
0000F522                          M .fail
0000F522 4EBA EA80                M 	jsr	amps_debugr_updvolfm
0000F526                          M .ok
0000F526                            
0000F526                            locret_VolFM:
0000F526 4E75                       		rts
0000F528                            ; ===========================================================================
0000F528                            ; ---------------------------------------------------------------------------
0000F528                            ; YM2612 register update list
0000F528                            ; ---------------------------------------------------------------------------
0000F528                            
0000F528 3038 343C                  dOpListYM:	dc.b $30, $38, $34, $3C		; Detune, Multiple
0000F52C 5058 545C                  		dc.b $50, $58, $54, $5C		; Rate Scale, Attack Rate
0000F530 6068 646C                  dAMSEn_Ops:	dc.b $60, $68, $64, $6C		; Decay 1 Rate
0000F534 7078 747C                  		dc.b $70, $78, $74, $7C		; Decay 2 Rate
0000F538 8088 848C                  		dc.b $80, $88, $84, $8C		; Decay 1 level, Release Rate
0000F53C 9098 949C                  		dc.b $90, $98, $94, $9C		; SSG-EG
0000F540 4048 444C                  dOpTLFM:	dc.b $40, $48, $44, $4C		; Total Level
0000F544                            ; ===========================================================================
0000F544                            ; ---------------------------------------------------------------------------
0000F544                            ; Process SFX FM channels
0000F544                            ; ---------------------------------------------------------------------------
0000F544                            
0000F544                            dAMPSdoFMSFX:
0000F544 4DFA 0000                  		lea	VoiceBankSFX(pc),a6	; load sound effects voice table into a6
0000F548 7E02                       		moveq	#SFX_FM-1,d7		; get total number of SFX FM channels to d7
0000F54A                            
0000F54A                            dAMPSnextFMSFX:
0000F54A DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000F54E 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000F550 6A00 0000                  		bpl.w	.next			; if not, branch
0000F554 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000F558 6700 0000                  		beq.w	.update			; if timed out, update channel
0000F55C                            
0000F55C                            	dCalcFreq				; calculate channel base frequency
0000F55C 1C2D 0007                M 	move.b	cdetune(a5),d6
0000F560 4886                     M 	ext.w	d6
0000F562 DC6D 000E                M 	add.w	cfreq(a5),d6
0000F566                            	dModulate dAMPSdoPSGSFX, dAMPSnextFMSFX, 1; run modulation code
0000F566 0815 0003                M 	btst	#cfbmod,(a5)
0000F56A 6700                     M 	beq.s	.noret
0000F56C 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000F570 6700                     M 	beq.s	.started
0000F572 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000F576                          M .noret
0000F576 0895 0005                M 	bclr	#cfbvol,(a5)
0000F57A 6700                     M 	beq.s	.noupdatevol
0000F57C 4EBA FF42                M 	jsr	dupdatevolfm(pc)
0000F580                          M 	.noupdatevol:
0000F580 51CF FFC8                M 	dbf	d7,dampsnextfmsfx
0000F584 6000 0000                M 	bra.w	dampsdopsgsfx
0000F588                          M .started
0000F588 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000F58C 66E8                     M 	bne.s	.noret
0000F58E 226D 0010                M 	movea.l	cmod(a5),a1
0000F592 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000F598 4A2D 0018                M 	tst.b	cmodcount(a5)
0000F59C 6600                     M 	bne.s	.norev
0000F59E 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000F5A4 442D 0017                M 	neg.b	cmodstep(a5)
0000F5A8                          M .norev
0000F5A8 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000F5AC 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000F5B0 4885                     M 	ext.w	d5
0000F5B2 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000F5B6 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000F5BA DC45                     M 	add.w	d5,d6
0000F5BC 6100 0000                  		bsr.w	dUpdateFreqFM3		; send FM frequency to hardware
0000F5C0                            
0000F5C0 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F5C4 6700                       		beq.s	.next			; if not, skip
0000F5C6 4EBA FEF8                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F5CA                            
0000F5CA                            .next
0000F5CA 51CF FF7E                  		dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0000F5CE 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0000F5D2                            
0000F5D2                            .update
0000F5D2 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000F5D6                            	dDoTracker				; process tracker
0000F5D6 286D 0002                M 	movea.l	cdata(a5),a4
0000F5DA                          M 	amps_debug_trackupd
0000F5DA 220C                     M 	move.l	a4,d1
0000F5DC 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000F5E2 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000F5E8 6500                     M 	blo.s	.fail2
0000F5EA 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000F5F0 6500                     M 	blo.s	.data
0000F5F2                          M .fail2
0000F5F2                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F5F2 487A FFFE                M 	pea	*(pc)
0000F5F6                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F5F6 40E7                     M 	move.w	sr,-(sp)
0000F5F8                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5F8 =00000000                M 	__stack:set	0
0000F5F8 =00000000                M 	__sp:	set 0
0000F5F8                          M 	while	(__pos)
0000F5F8 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F5F8 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F5F8 =00000021                M 	__midpos:	= __endpos
0000F5F8                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8                          M 	pushp	"move.l a4,-(sp)"
0000F5F8 =00000001                M 	__stack:	= __stack+1
0000F5F8 =00000004                M 	__sp:	= __sp+4
0000F5F8 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5F8 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F5F8 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F5F8 =00000029                M 	__midpos:	= __endpos
0000F5F8                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5F8 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F5F8 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F5F8                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5F8                          M 	pushp	"move.l a4,-(sp)"
0000F5F8 =00000002                M 	__stack:	= __stack+1
0000F5F8 =00000008                M 	__sp:	= __sp+4
0000F5F8 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5F8                          M 	rept	__stack
0000F5F8                          M 	popp	__command
0000F5F8 2F0C                     M 	move.l	a4,-(sp)
0000F5FA                          M 	popp	__command
0000F5FA 2F0C                     M 	move.l	a4,-(sp)
0000F5FC 4EB9 0000 0000           M 	jsr	errorhandler
0000F602                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F602 =00000001                M 	__lpos:	set 1
0000F602 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F602                          M 	while	(__pos)
0000F602                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F602 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000F61B =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F61B =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F61B =00000021                M 	__midpos:	= __endpos
0000F61B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F61B                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F61B                          M 	__param:	substr ,,"hex"
0000F61B 83                       M 	dc.b	hex|3
0000F61C =00000022                M 	__lpos:	set __endpos+1
0000F61C =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F61C                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F61C                          M 	dc.b	""
0000F61C =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F61C =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F61C =00000029                M 	__midpos:	= __endpos
0000F61C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F61C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F61C E0                       M 	dc.b	fendl
0000F61D =0000002A                M 	__lpos:	set __endpos+1
0000F61D =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F61D                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F61D                          M 	dc.b	""
0000F61D =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F61D =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F61D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F61D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F61D B3                       M 	dc.b	sym|3
0000F61E =00000036                M 	__lpos:	set __endpos+1
0000F61E =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F61E                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F61E                          M 	dc.b	""
0000F61E 00                       M 	dc.b	0
0000F61F 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F620                          M 	even
0000F620 4EFA DC96                M 	jmp	amps_debug_console_channel
0000F624                          M 	even
0000F624                          M .data
0000F624 7A00                     M 	moveq	#0,d5
0000F626 1A1C                     M 	move.b	(a4)+,d5
0000F628 0C05 00E0                M 	cmpi.b	#$e0,d5
0000F62C 6500                     M 	blo.s	.notcomm
0000F62E 4EBA 0000                M 	jsr	dcommands(pc)
0000F632 60F0                     M 	bra.s	.data
0000F634 6094                     M 	bra.s	.next
0000F636                          M .notcomm
0000F636 4EBA 0000                  		jsr	dKeyOffFM2(pc)		; send key-off command to YM
0000F63A 4A05                       		tst.b	d5			; check if note is being played
0000F63C 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000F63E                            
0000F63E 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0000F642 1A1C                       		move.b	(a4)+,d5		; check next byte
0000F644 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0000F646 534C                       		subq.w	#1,a4			; if not, then return back
0000F648 6000                       		bra.s	.pcnote			; do some extra clearing
0000F64A                            
0000F64A                            .timer
0000F64A 4EBA F330                  		jsr	dCalcDuration(pc)	; calculate duration
0000F64E                            .pcnote
0000F64E                            	dProcNote 1, 0				; reset necessary channel memory
0000F64E 2B4C 0002                M 	move.l	a4,cdata(a5)
0000F652 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000F658 0815 0002                M 	btst	#cfbhold,(a5)
0000F65C 6600                     M 	bne.s	.endpn
0000F65E 0815 0003                M 	btst	#cfbmod,(a5)
0000F662 6700                     M 	beq.s	.endpn
0000F664 226D 0010                M 	movea.l	cmod(a5),a1
0000F668 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000F66C 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000F670 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000F674 1011                     M 	move.b	(a1),d0
0000F676 E208                     M 	lsr.b	#1,d0
0000F678 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000F67C 426D 0014                M 	clr.w	cmodfreq(a5)
0000F680                          M .endpn
0000F680 6100 0000                  		bsr.w	dUpdateFreqFM		; send FM frequency to hardware
0000F684                            	dKeyOnFM 1				; send key-on command to YM
0000F684 0815 0002                M 	btst	#cfbhold,(a5)
0000F688 6600                     M 	bne.s	.k
0000F68A 0815 0000                M 	btst	#cfbrest,(a5)
0000F68E 6600                     M 	bne.s	.k
0000F690 7028                     M 	moveq	#$28,d0
0000F692 122D 0001                M 	move.b	ctype(a5),d1
0000F696 0001 00F0                M 	ori.b	#$f0,d1
0000F69A 6100 0000                M 	bsr.w	writeym_pt1
0000F69E                          M .k
0000F69E                            
0000F69E 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F6A2 6700                       		beq.s	.noupdate		; if not, branch
0000F6A4 4EBA FE1A                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F6A8                            
0000F6A8 51CF FEA0                  .noupdate	dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0000F6AC 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0000F6B0                            ; ===========================================================================
0000F6B0                            ; ---------------------------------------------------------------------------
0000F6B0                            ; Process music FM channels
0000F6B0                            ; ---------------------------------------------------------------------------
0000F6B0                            
0000F6B0                            dAMPSdoFM:
0000F6B0 4DFA 0000                  		lea	VoiceBankMusic(pc),a6	; load music voice table into a6
0000F6B4 7E04                       		moveq	#Mus_FM-1,d7		; get total number of music FM channels to d7
0000F6B6                            
0000F6B6                            dAMPSnextFM:
0000F6B6 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel
0000F6BA 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000F6BC 6A00 0000                  		bpl.w	.next			; if not, branch
0000F6C0 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000F6C4 6700 0000                  		beq.w	.update			; if timed out, update channel
0000F6C8                            
0000F6C8                            	dNoteToutFM.w				; handle FM-specific note timeout behavior
0000F6C8                          M 	dnotetouthandler
0000F6C8 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000F6CC 6700                     M 	beq.s	.endt
0000F6CE 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000F6D2 6600                     M 	bne.s	.endt
0000F6D4 08D5 0000                M 	bset	#cfbrest,(a5)
0000F6D8 6100 0000                M 	bsr.w	dkeyofffm
0000F6DC 6000 0000                M 	bra.w	.next
0000F6E0                          M .endt
0000F6E0                            	dCalcFreq				; calculate channel base frequency
0000F6E0 1C2D 0007                M 	move.b	cdetune(a5),d6
0000F6E4 4886                     M 	ext.w	d6
0000F6E6 DC6D 000E                M 	add.w	cfreq(a5),d6
0000F6EA                            	dModulate dAMPSdoPSG, dAMPSnextFM, 0	; run modulation code
0000F6EA 0815 0003                M 	btst	#cfbmod,(a5)
0000F6EE 6700                     M 	beq.s	.noret
0000F6F0 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000F6F4 6700                     M 	beq.s	.started
0000F6F6 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000F6FA                          M .noret
0000F6FA 0895 0005                M 	bclr	#cfbvol,(a5)
0000F6FE 6700                     M 	beq.s	.noupdatevol
0000F700 4EBA FDBE                M 	jsr	dupdatevolfm(pc)
0000F704                          M 	.noupdatevol:
0000F704 51CF FFB0                M 	dbf	d7,dampsnextfm
0000F708 6000 0000                M 	bra.w	dampsdopsg
0000F70C                          M .started
0000F70C 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000F710 66E8                     M 	bne.s	.noret
0000F712 226D 0010                M 	movea.l	cmod(a5),a1
0000F716 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000F71C 4A2D 0018                M 	tst.b	cmodcount(a5)
0000F720 6600                     M 	bne.s	.norev
0000F722 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000F728 442D 0017                M 	neg.b	cmodstep(a5)
0000F72C                          M .norev
0000F72C 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000F730 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000F734 4885                     M 	ext.w	d5
0000F736 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000F73A 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000F73E DC45                     M 	add.w	d5,d6
0000F740 6100 0000                  		bsr.w	dUpdateFreqFM2		; send FM frequency to hardware
0000F744                            
0000F744 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F748 6700                       		beq.s	.next			; if not, skip
0000F74A 4EBA FD74                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F74E                            
0000F74E                            .next
0000F74E 51CF FF66                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0000F752 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0000F756                            
0000F756                            .update
0000F756 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000F75A                            	dDoTracker				; process tracker
0000F75A 286D 0002                M 	movea.l	cdata(a5),a4
0000F75E                          M 	amps_debug_trackupd
0000F75E 220C                     M 	move.l	a4,d1
0000F760 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000F766 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000F76C 6500                     M 	blo.s	.fail2
0000F76E 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000F774 6500                     M 	blo.s	.data
0000F776                          M .fail2
0000F776                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F776 487A FFFE                M 	pea	*(pc)
0000F77A                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F77A 40E7                     M 	move.w	sr,-(sp)
0000F77C                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F77C =00000000                M 	__stack:set	0
0000F77C =00000000                M 	__sp:	set 0
0000F77C                          M 	while	(__pos)
0000F77C =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F77C =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F77C =00000021                M 	__midpos:	= __endpos
0000F77C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C                          M 	pushp	"move.l a4,-(sp)"
0000F77C =00000001                M 	__stack:	= __stack+1
0000F77C =00000004                M 	__sp:	= __sp+4
0000F77C =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F77C =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F77C =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F77C =00000029                M 	__midpos:	= __endpos
0000F77C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F77C =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F77C =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F77C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F77C                          M 	pushp	"move.l a4,-(sp)"
0000F77C =00000002                M 	__stack:	= __stack+1
0000F77C =00000008                M 	__sp:	= __sp+4
0000F77C =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F77C                          M 	rept	__stack
0000F77C                          M 	popp	__command
0000F77C 2F0C                     M 	move.l	a4,-(sp)
0000F77E                          M 	popp	__command
0000F77E 2F0C                     M 	move.l	a4,-(sp)
0000F780 4EB9 0000 0000           M 	jsr	errorhandler
0000F786                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F786 =00000001                M 	__lpos:	set 1
0000F786 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F786                          M 	while	(__pos)
0000F786                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F786 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000F79F =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F79F =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F79F =00000021                M 	__midpos:	= __endpos
0000F79F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F79F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F79F                          M 	__param:	substr ,,"hex"
0000F79F 83                       M 	dc.b	hex|3
0000F7A0 =00000022                M 	__lpos:	set __endpos+1
0000F7A0 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F7A0                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F7A0                          M 	dc.b	""
0000F7A0 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F7A0 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F7A0 =00000029                M 	__midpos:	= __endpos
0000F7A0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F7A0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F7A0 E0                       M 	dc.b	fendl
0000F7A1 =0000002A                M 	__lpos:	set __endpos+1
0000F7A1 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F7A1                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F7A1                          M 	dc.b	""
0000F7A1 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F7A1 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F7A1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F7A1                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F7A1 B3                       M 	dc.b	sym|3
0000F7A2 =00000036                M 	__lpos:	set __endpos+1
0000F7A2 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F7A2                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F7A2                          M 	dc.b	""
0000F7A2 00                       M 	dc.b	0
0000F7A3 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F7A4                          M 	even
0000F7A4 4EFA DB12                M 	jmp	amps_debug_console_channel
0000F7A8                          M 	even
0000F7A8                          M .data
0000F7A8 7A00                     M 	moveq	#0,d5
0000F7AA 1A1C                     M 	move.b	(a4)+,d5
0000F7AC 0C05 00E0                M 	cmpi.b	#$e0,d5
0000F7B0 6500                     M 	blo.s	.notcomm
0000F7B2 4EBA 0000                M 	jsr	dcommands(pc)
0000F7B6 60F0                     M 	bra.s	.data
0000F7B8 6094                     M 	bra.s	.next
0000F7BA                          M .notcomm
0000F7BA 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0000F7BE 4A05                       		tst.b	d5			; check if note is being played
0000F7C0 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000F7C2                            
0000F7C2 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0000F7C6 1A1C                       		move.b	(a4)+,d5		; check next byte
0000F7C8 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0000F7CA 534C                       		subq.w	#1,a4			; if not, then return back
0000F7CC 6000                       		bra.s	.pcnote			; do some extra clearing
0000F7CE                            
0000F7CE                            .timer
0000F7CE 4EBA F1AC                  		jsr	dCalcDuration(pc)	; calculate duration
0000F7D2                            .pcnote
0000F7D2                            	dProcNote 0, 0				; reset necessary channel memory
0000F7D2 2B4C 0002                M 	move.l	a4,cdata(a5)
0000F7D6 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000F7DC 0815 0002                M 	btst	#cfbhold,(a5)
0000F7E0 6600                     M 	bne.s	.endpn
0000F7E2 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000F7E8 0815 0003                M 	btst	#cfbmod,(a5)
0000F7EC 6700                     M 	beq.s	.endpn
0000F7EE 226D 0010                M 	movea.l	cmod(a5),a1
0000F7F2 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000F7F6 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000F7FA 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000F7FE 1011                     M 	move.b	(a1),d0
0000F800 E208                     M 	lsr.b	#1,d0
0000F802 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000F806 426D 0014                M 	clr.w	cmodfreq(a5)
0000F80A                          M .endpn
0000F80A 6100                       		bsr.s	dUpdateFreqFM		; send FM frequency to hardware
0000F80C                            	dKeyOnFM				; send key-on command to YM
0000F80C 0815 0002                M 	btst	#cfbhold,(a5)
0000F810 6600                     M 	bne.s	.k
0000F812 0815 0000                M 	btst	#cfbrest,(a5)
0000F816 6600                     M 	bne.s	.k
0000F818 0815 0001                M 	btst	#cfbint,(a5)
0000F81C 6600                     M 	bne.s	.k
0000F81E 7028                     M 	moveq	#$28,d0
0000F820 122D 0001                M 	move.b	ctype(a5),d1
0000F824 0001 00F0                M 	ori.b	#$f0,d1
0000F828 6100 0000                M 	bsr.w	writeym_pt1
0000F82C                          M .k
0000F82C                            
0000F82C 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F830 6700                       		beq.s	.noupdate		; if not, branch
0000F832 4EBA FC8C                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F836                            
0000F836                            .noupdate
0000F836 51CF FE7E                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0000F83A 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0000F83E                            ; ===========================================================================
0000F83E                            ; ---------------------------------------------------------------------------
0000F83E                            ; Write FM frequency to Dual PCM YMCue
0000F83E                            ; ---------------------------------------------------------------------------
0000F83E                            
0000F83E                            dUpdateFreqFM:
0000F83E 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0000F842 6600                       		bne.s	locret_UpdFreqFM	; if is, skip
0000F844 3C2D 000E                  		move.w	cFreq(a5),d6		; load channel base frequency to d6
0000F848 6700                       		beq.s	dUpdFreqFMrest		; if 0, this channel should be resting
0000F84A                            
0000F84A 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0000F84E 4880                       		ext.w	d0			; extend to word
0000F850 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0000F852                            
0000F852 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0000F856 6700                       		beq.s	dUpdateFreqFM2		; if not, branch
0000F858 DC6D 0014                  		add.w	cModFreq(a5),d6		; add channel modulation frequency offset to d6
0000F85C                            
0000F85C                            dUpdateFreqFM2:
0000F85C 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000F860 6600                       		bne.s	locret_UpdFreqFM	; if is, do not update frequency anyway
0000F862                            
0000F862                            dUpdateFreqFM3:
0000F862 3206                       		move.w	d6,d1			; copy frequency to d1
0000F864 E049                       		lsr.w	#8,d1			; shift upper byte into lower byte
0000F866 70A4                       		moveq	#$FFFFFFA4,d0		; YM command: Frequency MSB & Octave
0000F868 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F86C                            
0000F86C 1206                       		move.b	d6,d1			; copy lower byte of frequency into d1 (value)
0000F86E 103C 00A0                  		move.b	#$FFFFFFA0,d0		; YM command: Frequency LSB
0000F872 4EFA 0000                  		jmp	WriteChYM(pc)		; write to YM according to channel
0000F876                            
0000F876                            dUpdFreqFMrest:
0000F876 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0000F87A                            
0000F87A                            locret_UpdFreqFM:
0000F87A 4E75                       		rts
0000F87C                            ; ===========================================================================
0000F87C                            ; ---------------------------------------------------------------------------
0000F87C                            ; Process a note in FM channel (enable resting or get frequency)
0000F87C                            ; ---------------------------------------------------------------------------
0000F87C                            
0000F87C                            dGetFreqFM:
0000F87C 0405 0080                  		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0000F880 6600                       		bne.s	.norest			; branch if note wasnt $80 (rest)
0000F882 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0000F886 426D 000E                  		clr.w	cFreq(a5)		; set base frequency to 0
0000F88A 4E75                       		rts
0000F88C                            
0000F88C                            .norest
0000F88C DA2D 0008                  		add.b	cPitch(a5),d5		; add pitch offset to note
0000F890 0245 007F                  		andi.w	#$7F,d5			; keep within $80 notes
0000F894 DA45                       		add.w	d5,d5			; double offset (each entry is a word)
0000F896                            
0000F896 43FA 0000                  		lea	dFreqFM(pc),a1		; load FM frequency table to a1
0000F89A 3B71 5000 000E             		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0000F8A0                            
0000F8A0                            		AMPS_Debug_NoteFM		; check if the note was valid
0000F8A0 0C05 0000                M 	cmp.b	#dfreqfm_-dfreqfm,d5
0000F8A4 6500                     M 	blo.s	.ok
0000F8A6                          M .fail
0000F8A6 4EBA E6A2                M 	jsr	amps_debugr_notefm
0000F8AA                          M .ok
0000F8AA 4E75                       		rts
0000F8AC                            ; ===========================================================================
0000F8AC                            ; ---------------------------------------------------------------------------
0000F8AC                            ; Subroutine for doing keying-off FM channel
0000F8AC                            ; ---------------------------------------------------------------------------
0000F8AC                            
0000F8AC                            dKeyOffFM:
0000F8AC 0815 0001                  		btst	#cfbInt,(a5)		; check if overridden by sfx
0000F8B0 66C8                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0000F8B2                            
0000F8B2                            dKeyOffFM2:
0000F8B2 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0000F8B6 66C2                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0000F8B8                            
0000F8B8 7028                       		moveq	#$28,d0			; YM command: Key on
0000F8BA 122D 0001                  		move.b	cType(a5),d1		; get channel type bits (and turn all operators off)
0000F8BE 6000                       		bra.s	WriteYM_Pt1		; write to part 1 channel
0000F8C0                            ; ===========================================================================
0000F8C0                            ; ---------------------------------------------------------------------------
0000F8C0                            ; Write to YMCue according to channel and check if interrupted by sfx
0000F8C0                            ; ---------------------------------------------------------------------------
0000F8C0                            
0000F8C0                            dWriteYMchnInt:
0000F8C0 0815 0001                  		btst	#cfbInt,(a5)		; check if interrupted by sfx
0000F8C4 6600                       		bne.s	WriteYM_Pt1_rts		; if was, do not note on
0000F8C6                            ; ===========================================================================
0000F8C6                            ; ---------------------------------------------------------------------------
0000F8C6                            ; Write to YMCue according to channel
0000F8C6                            ; ---------------------------------------------------------------------------
0000F8C6                            
0000F8C6                            WriteChYM:
0000F8C6 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this is a YM part 1 or 2 channel
0000F8CC 6600                       		bne.s	WriteChYM2		; if part 2, branch
0000F8CE D02D 0001                  		add.b	cType(a5),d0		; add channel type to address
0000F8D2                            ; ===========================================================================
0000F8D2                            ; ---------------------------------------------------------------------------
0000F8D2                            ; Write to YMCue using part 1
0000F8D2                            ; ---------------------------------------------------------------------------
0000F8D2                            
0000F8D2                            WriteYM_Pt1:
0000F8D2                            		AMPS_Debug_CuePtr 1		; check if cue pointer is valid
0000F8D2 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000F8D8 6500                     M 	blo.s	.fail_647
0000F8DA B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000F8E0 6500                     M 	blo.s	.ok_647
0000F8E2                          M .fail_647
0000F8E2 4EBA E6F8                M 	jsr	amps_debug_cueptr1
0000F8E6                          M .ok_647
0000F8E6                            	StopZ80					; wait for Z80 to stop
0000F8E6 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F8EE                          M 	waitz80stop
0000F8EE 0839 0000 00A1 1100      M .wait_649:	btst	#0,z80_bus_req
0000F8F6 66F6                     M 	bne.s	.wait_649
0000F8F8 51D8                       		sf	(a0)+			; set YM port address as 0
0000F8FA 10C1                       		move.b	d1,(a0)+		; write data value to cue
0000F8FC 10C0                       		move.b	d0,(a0)+		; write address to cue
0000F8FE                            	;	st	(a0)			; mark as the end of the cue data
0000F8FE                            	StartZ80				; enable Z80 execution
0000F8FE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F906                            
0000F906                            WriteYM_Pt1_rts:
0000F906 4E75                       		rts
0000F908                            ; ===========================================================================
0000F908                            ; ---------------------------------------------------------------------------
0000F908                            ; Write to YMCue according to channel in part 2
0000F908                            ; ---------------------------------------------------------------------------
0000F908                            
0000F908                            WriteChYM2:
0000F908 142D 0001                  		move.b	cType(a5),d2		; get channel type to d2
0000F90C 0882 0002                  		bclr	#ctbPt2,d2		; remove part 2 marker from it
0000F910 D002                       		add.b	d2,d0			; add to YM address
0000F912                            ; ===========================================================================
0000F912                            ; ---------------------------------------------------------------------------
0000F912                            ; Write to YMCue using part 2
0000F912                            ; ---------------------------------------------------------------------------
0000F912                            
0000F912                            WriteYM_Pt2:
0000F912                            		AMPS_Debug_CuePtr 2		; check if cue pointer is valid
0000F912 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000F918 6500                     M 	blo.s	.fail_651
0000F91A B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000F920 6500                     M 	blo.s	.ok_651
0000F922                          M .fail_651
0000F922 4EBA E6E6                M 	jsr	amps_debug_cueptr2
0000F926                          M .ok_651
0000F926                            	StopZ80					; wait for Z80 to stop
0000F926 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F92E                          M 	waitz80stop
0000F92E 0839 0000 00A1 1100      M .wait_653:	btst	#0,z80_bus_req
0000F936 66F6                     M 	bne.s	.wait_653
0000F938 10FC 0002                  		move.b	#$02,(a0)+		; set YM port address as 2
0000F93C 10C1                       		move.b	d1,(a0)+		; write data value to cue
0000F93E 10C0                       		move.b	d0,(a0)+		; write address to cue
0000F940                            	;	st	(a0)			; mark as the end of the cue data
0000F940                            	StartZ80				; enable Z80 execution
0000F940 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F948 4E75                       		rts
0000F94A                            ; ===========================================================================
0000F94A                            ; ---------------------------------------------------------------------------
0000F94A                            ; Note to FM frequency conversion table
0000F94A                            ; ---------------------------------------------------------------------------
0000F94A                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000F94A 025E                       dFreqFM:dc.w								       $025E; Octave-1 - (80)
0000F94C 0284 02AB 02D3 02FE 032D+  	dc.w $0284,$02AB,$02D3,$02FE,$032D,$035C,$038F,$03C5,$03FF,$043C,$047C,$0A5E; Octave 0 - (81 - 8C)
0000F964 0A84 0AAB 0AD3 0AFE 0B2D+  	dc.w $0A84,$0AAB,$0AD3,$0AFE,$0B2D,$0B5C,$0B8F,$0BC5,$0BFF,$0C3C,$0C7C,$125E; Octave 1 - (8D - 98)
0000F97C 1284 12AB 12D3 12FE 132D+  	dc.w $1284,$12AB,$12D3,$12FE,$132D,$135C,$138F,$13C5,$13FF,$143C,$147C,$1A5E; Octave 2 - (99 - A4)
0000F994 1A84 1AAB 1AD3 1AFE 1B2D+  	dc.w $1A84,$1AAB,$1AD3,$1AFE,$1B2D,$1B5C,$1B8F,$1BC5,$1BFF,$1C3C,$1C7C,$225E; Octave 3 - (A5 - B0)
0000F9AC 2284 22AB 22D3 22FE 232D+  	dc.w $2284,$22AB,$22D3,$22FE,$232D,$235C,$238F,$23C5,$23FF,$243C,$247C,$2A5E; Octave 4 - (B1 - BC)
0000F9C4 2A84 2AAB 2AD3 2AFE 2B2D+  	dc.w $2A84,$2AAB,$2AD3,$2AFE,$2B2D,$2B5C,$2B8F,$2BC5,$2BFF,$2C3C,$2C7C,$325E; Octave 5 - (BD - C8)
0000F9DC 3284 32AB 32D3 32FE 332D+  	dc.w $3284,$32AB,$32D3,$32FE,$332D,$335C,$338F,$33C5,$33FF,$343C,$347C,$3A5E; Octave 6 - (c9 - D4)
0000F9F4 3A84 3AAB 3AD3 3AFE 3B2D+  	dc.w $3A84,$3AAB,$3AD3,$3AFE,$3B2D,$3B5C,$3B8F,$3BC5,$3BFF,$3C3C,$3C7C	    ; Octave 7 - (D5 - DF)
0000FA0A                            dFreqFM_:
0000FA0A =00000160                  .x = $100|((dFreqFM_-dFreqFM)/2)		; to check if we played an invalid note
0000FA0A                            		rept $80-((dFreqFM_-dFreqFM)/2)	; and if so, tell us which note it was
0000FA0A                            			dc.w .x
0000FA0A                            .x =			.x+$101
0000FA0A                            		endr
0000FA0A 0160                     M 	dc.w	.x
0000FA0C =00000261                M .x	=	.x+$101
0000FA0C 0261                     M 	dc.w	.x
0000FA0E =00000362                M .x	=	.x+$101
0000FA0E 0362                     M 	dc.w	.x
0000FA10 =00000463                M .x	=	.x+$101
0000FA10 0463                     M 	dc.w	.x
0000FA12 =00000564                M .x	=	.x+$101
0000FA12 0564                     M 	dc.w	.x
0000FA14 =00000665                M .x	=	.x+$101
0000FA14 0665                     M 	dc.w	.x
0000FA16 =00000766                M .x	=	.x+$101
0000FA16 0766                     M 	dc.w	.x
0000FA18 =00000867                M .x	=	.x+$101
0000FA18 0867                     M 	dc.w	.x
0000FA1A =00000968                M .x	=	.x+$101
0000FA1A 0968                     M 	dc.w	.x
0000FA1C =00000A69                M .x	=	.x+$101
0000FA1C 0A69                     M 	dc.w	.x
0000FA1E =00000B6A                M .x	=	.x+$101
0000FA1E 0B6A                     M 	dc.w	.x
0000FA20 =00000C6B                M .x	=	.x+$101
0000FA20 0C6B                     M 	dc.w	.x
0000FA22 =00000D6C                M .x	=	.x+$101
0000FA22 0D6C                     M 	dc.w	.x
0000FA24 =00000E6D                M .x	=	.x+$101
0000FA24 0E6D                     M 	dc.w	.x
0000FA26 =00000F6E                M .x	=	.x+$101
0000FA26 0F6E                     M 	dc.w	.x
0000FA28 =0000106F                M .x	=	.x+$101
0000FA28 106F                     M 	dc.w	.x
0000FA2A =00001170                M .x	=	.x+$101
0000FA2A 1170                     M 	dc.w	.x
0000FA2C =00001271                M .x	=	.x+$101
0000FA2C 1271                     M 	dc.w	.x
0000FA2E =00001372                M .x	=	.x+$101
0000FA2E 1372                     M 	dc.w	.x
0000FA30 =00001473                M .x	=	.x+$101
0000FA30 1473                     M 	dc.w	.x
0000FA32 =00001574                M .x	=	.x+$101
0000FA32 1574                     M 	dc.w	.x
0000FA34 =00001675                M .x	=	.x+$101
0000FA34 1675                     M 	dc.w	.x
0000FA36 =00001776                M .x	=	.x+$101
0000FA36 1776                     M 	dc.w	.x
0000FA38 =00001877                M .x	=	.x+$101
0000FA38 1877                     M 	dc.w	.x
0000FA3A =00001978                M .x	=	.x+$101
0000FA3A 1978                     M 	dc.w	.x
0000FA3C =00001A79                M .x	=	.x+$101
0000FA3C 1A79                     M 	dc.w	.x
0000FA3E =00001B7A                M .x	=	.x+$101
0000FA3E 1B7A                     M 	dc.w	.x
0000FA40 =00001C7B                M .x	=	.x+$101
0000FA40 1C7B                     M 	dc.w	.x
0000FA42 =00001D7C                M .x	=	.x+$101
0000FA42 1D7C                     M 	dc.w	.x
0000FA44 =00001E7D                M .x	=	.x+$101
0000FA44 1E7D                     M 	dc.w	.x
0000FA46 =00001F7E                M .x	=	.x+$101
0000FA46 1F7E                     M 	dc.w	.x
0000FA48 =0000207F                M .x	=	.x+$101
0000FA48 207F                     M 	dc.w	.x
0000FA4A =00002180                M .x	=	.x+$101
0000FA4A                            ; ===========================================================================
0000FA4A                            ; ---------------------------------------------------------------------------
0000FA4A                            ; Note to Dual PCM frequency conversion table
0000FA4A                            ; ---------------------------------------------------------------------------
0000FA4A                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000FA4A 0000                       dFreqDAC:dc.w $0000								    ; Octave NOPE - (80)
0000FA4C 0010 0011 0012 0013 0014+  	dc.w $0010,$0011,$0012,$0013,$0014,$0015,$0017,$0018,$0019,$001B,$001D,$001E; Octave 0 - (81 - 8C)
0000FA64 0020 0022 0024 0026 0028+  	dc.w $0020,$0022,$0024,$0026,$0028,$002B,$002D,$0030,$0033,$0036,$0039,$003C; Octave 1 - (8D - 98)
0000FA7C 0040 0044 0048 004C 0051+  	dc.w $0040,$0044,$0048,$004C,$0051,$0055,$005B,$0060,$0066,$006C,$0072,$0079; Octave 2 - (99 - A4)
0000FA94 0080 0088 0090 0098 00A1+  	dc.w $0080,$0088,$0090,$0098,$00A1,$00AB,$00B5,$00C0,$00CB,$00D7,$00E4,$00F2; Octave 3 - (A5 - B0)
0000FAAC 0100 010F 011F 0130 0143+  	dc.w $0100,$010F,$011F,$0130,$0143,$0156,$016A,$0180,$0196,$01AF,$01C8,$01E3; Octave 4 - (B1 - BC)
0000FAC4 0200 021E 023F 0261 0285+  	dc.w $0200,$021E,$023F,$0261,$0285,$02AB,$02D4,$02FF,$032D,$035D,$0390,$03C7; Octave 5 - (BD - C8)
0000FADC 0400 043D 047D 04C2 050A+  	dc.w $0400,$043D,$047D,$04C2,$050A,$0557,$05A8,$05FE,$0659,$06BA,$0721,$078D; Octave 6 - (C9 - D4)
0000FAF4 0800 087A 08FB 0983 0A14+  	dc.w $0800,$087A,$08FB,$0983,$0A14,$0AAE,$0B50,$0BFD,$0CB3,$0D74,$0E41,$0F1A; Octave 7 - (D5 - E0)
0000FB0C 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 8 - (E1 - EC)
0000FB24 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 9 - (ED - F8)
0000FB3C 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF				    ; Octave 10 -(F9 - FF)
0000FB4A                            
0000FB4A F001 F001 F001 F001 F001+  	dc.w			     -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -10 -(00 - 07)
0000FB5A F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -9 - (08 - 13)
0000FB72 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -8 - (14 - 1F)
0000FB8A F0E6 F1BF F28C F34D F403+  	dc.w -$F1A,-$E41,-$D74,-$CB3,-$BFD,-$B50,-$AAE,-$A14,-$983,-$8FB,-$87A,-$800; Octave -7 - (20 - 2B)
0000FBA2 F873 F8DF F946 F9A7 FA02+  	dc.w -$78D,-$721,-$6BA,-$659,-$5FE,-$5A8,-$557,-$50A,-$4C2,-$47D,-$43D,-$400; Octave -6 - (2C - 37)
0000FBBA FC39 FC70 FCA3 FCD3 FD01+  	dc.w -$3C7,-$390,-$35D,-$32D,-$2FF,-$2D4,-$2AB,-$285,-$261,-$23F,-$21E,-$200; Octave -5 - (38 - 43)
0000FBD2 FE1D FE38 FE51 FE6A FE80+  	dc.w -$1E3,-$1C8,-$1AF,-$196,-$180,-$16A,-$156,-$143,-$130,-$11F,-$10F,-$100; Octave -4 - (44 - 4F)
0000FBEA FF0E FF1C FF29 FF35 FF40+  	dc.w -$0F2,-$0E4,-$0D7,-$0CB,-$0C0,-$0B5,-$0AB,-$0A1,-$098,-$090,-$088,-$080; Octave -3 - (50 - 5B)
0000FC02 FF87 FF8E FF94 FF9A FFA0+  	dc.w -$079,-$072,-$06C,-$066,-$060,-$05B,-$055,-$051,-$04C,-$048,-$044,-$040; Octave -2 - (5C - 67)
0000FC1A FFC4 FFC7 FFCA FFCD FFD0+  	dc.w -$03C,-$039,-$036,-$033,-$030,-$02D,-$02B,-$028,-$026,-$024,-$022,-$020; Octave -1 - (68 - 73)
0000FC32 FFE2 FFE3 FFE5 FFE7 FFE8+  	dc.w -$01E,-$01D,-$01B,-$019,-$018,-$017,-$015,-$014,-$013,-$012,-$011,-$010; Octave -0 - (74 - 7F)
0000FC4A                            ; ===========================================================================
0000FC4A                            ; ---------------------------------------------------------------------------
0000FC4A                            ; Note to PSG frequency conversion table
0000FC4A                            ; ---------------------------------------------------------------------------
0000FC4A                            ;	dc.w	C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000FC4A 0356 0326 02F9 02CE 02A5+  dFreqPSG:dc.w $0356,$0326,$02F9,$02CE,$02A5,$0280,$025C,$023A,$021A,$01FB,$01DF,$01C4; Octave 3 - (81 - 8C)
0000FC62 01AB 0193 017D 0167 0153+  	dc.w  $01AB,$0193,$017D,$0167,$0153,$0140,$012E,$011D,$010D,$00FE,$00EF,$00E2; Octave 4 - (8D - 98)
0000FC7A 00D6 00C9 00BE 00B4 00A9+  	dc.w  $00D6,$00C9,$00BE,$00B4,$00A9,$00A0,$0097,$008F,$0087,$007F,$0078,$0071; Octave 5 - (99 - A4)
0000FC92 006B 0065 005F 005A 0055+  	dc.w  $006B,$0065,$005F,$005A,$0055,$0050,$004B,$0047,$0043,$0040,$003C,$0039; Octave 6 - (A5 - B0)
0000FCAA 0036 0033 0030 002D 002B+  	dc.w  $0036,$0033,$0030,$002D,$002B,$0028,$0026,$0024,$0022,$0020,$001F,$001D; Octave 7 - (B1 - BC)
0000FCC2 001B 001A 0018 0017 0016+  	dc.w  $001B,$001A,$0018,$0017,$0016,$0015,$0013,$0012,$0011		     ; Notes (BD - C5)
0000FCD4 0000                       	dc.w  $0000								     ; Note (C6)
0000FCD6                            dFreqPSG_:
0000FCD6 =00000146                  .x = $100|((dFreqPSG_-dFreqPSG)/2)		; to check if we played an invalid note
0000FCD6                            		rept $80-((dFreqPSG_-dFreqPSG)/2); and if so, tell us which note it was
0000FCD6                            			dc.w .x
0000FCD6                            .x =			.x+$101
0000FCD6                            		endr
0000FCD6 0146                     M 	dc.w	.x
0000FCD8 =00000247                M .x	=	.x+$101
0000FCD8 0247                     M 	dc.w	.x
0000FCDA =00000348                M .x	=	.x+$101
0000FCDA 0348                     M 	dc.w	.x
0000FCDC =00000449                M .x	=	.x+$101
0000FCDC 0449                     M 	dc.w	.x
0000FCDE =0000054A                M .x	=	.x+$101
0000FCDE 054A                     M 	dc.w	.x
0000FCE0 =0000064B                M .x	=	.x+$101
0000FCE0 064B                     M 	dc.w	.x
0000FCE2 =0000074C                M .x	=	.x+$101
0000FCE2 074C                     M 	dc.w	.x
0000FCE4 =0000084D                M .x	=	.x+$101
0000FCE4 084D                     M 	dc.w	.x
0000FCE6 =0000094E                M .x	=	.x+$101
0000FCE6 094E                     M 	dc.w	.x
0000FCE8 =00000A4F                M .x	=	.x+$101
0000FCE8 0A4F                     M 	dc.w	.x
0000FCEA =00000B50                M .x	=	.x+$101
0000FCEA 0B50                     M 	dc.w	.x
0000FCEC =00000C51                M .x	=	.x+$101
0000FCEC 0C51                     M 	dc.w	.x
0000FCEE =00000D52                M .x	=	.x+$101
0000FCEE 0D52                     M 	dc.w	.x
0000FCF0 =00000E53                M .x	=	.x+$101
0000FCF0 0E53                     M 	dc.w	.x
0000FCF2 =00000F54                M .x	=	.x+$101
0000FCF2 0F54                     M 	dc.w	.x
0000FCF4 =00001055                M .x	=	.x+$101
0000FCF4 1055                     M 	dc.w	.x
0000FCF6 =00001156                M .x	=	.x+$101
0000FCF6 1156                     M 	dc.w	.x
0000FCF8 =00001257                M .x	=	.x+$101
0000FCF8 1257                     M 	dc.w	.x
0000FCFA =00001358                M .x	=	.x+$101
0000FCFA 1358                     M 	dc.w	.x
0000FCFC =00001459                M .x	=	.x+$101
0000FCFC 1459                     M 	dc.w	.x
0000FCFE =0000155A                M .x	=	.x+$101
0000FCFE 155A                     M 	dc.w	.x
0000FD00 =0000165B                M .x	=	.x+$101
0000FD00 165B                     M 	dc.w	.x
0000FD02 =0000175C                M .x	=	.x+$101
0000FD02 175C                     M 	dc.w	.x
0000FD04 =0000185D                M .x	=	.x+$101
0000FD04 185D                     M 	dc.w	.x
0000FD06 =0000195E                M .x	=	.x+$101
0000FD06 195E                     M 	dc.w	.x
0000FD08 =00001A5F                M .x	=	.x+$101
0000FD08 1A5F                     M 	dc.w	.x
0000FD0A =00001B60                M .x	=	.x+$101
0000FD0A 1B60                     M 	dc.w	.x
0000FD0C =00001C61                M .x	=	.x+$101
0000FD0C 1C61                     M 	dc.w	.x
0000FD0E =00001D62                M .x	=	.x+$101
0000FD0E 1D62                     M 	dc.w	.x
0000FD10 =00001E63                M .x	=	.x+$101
0000FD10 1E63                     M 	dc.w	.x
0000FD12 =00001F64                M .x	=	.x+$101
0000FD12 1F64                     M 	dc.w	.x
0000FD14 =00002065                M .x	=	.x+$101
0000FD14 2065                     M 	dc.w	.x
0000FD16 =00002166                M .x	=	.x+$101
0000FD16 2166                     M 	dc.w	.x
0000FD18 =00002267                M .x	=	.x+$101
0000FD18 2267                     M 	dc.w	.x
0000FD1A =00002368                M .x	=	.x+$101
0000FD1A 2368                     M 	dc.w	.x
0000FD1C =00002469                M .x	=	.x+$101
0000FD1C 2469                     M 	dc.w	.x
0000FD1E =0000256A                M .x	=	.x+$101
0000FD1E 256A                     M 	dc.w	.x
0000FD20 =0000266B                M .x	=	.x+$101
0000FD20 266B                     M 	dc.w	.x
0000FD22 =0000276C                M .x	=	.x+$101
0000FD22 276C                     M 	dc.w	.x
0000FD24 =0000286D                M .x	=	.x+$101
0000FD24 286D                     M 	dc.w	.x
0000FD26 =0000296E                M .x	=	.x+$101
0000FD26 296E                     M 	dc.w	.x
0000FD28 =00002A6F                M .x	=	.x+$101
0000FD28 2A6F                     M 	dc.w	.x
0000FD2A =00002B70                M .x	=	.x+$101
0000FD2A 2B70                     M 	dc.w	.x
0000FD2C =00002C71                M .x	=	.x+$101
0000FD2C 2C71                     M 	dc.w	.x
0000FD2E =00002D72                M .x	=	.x+$101
0000FD2E 2D72                     M 	dc.w	.x
0000FD30 =00002E73                M .x	=	.x+$101
0000FD30 2E73                     M 	dc.w	.x
0000FD32 =00002F74                M .x	=	.x+$101
0000FD32 2F74                     M 	dc.w	.x
0000FD34 =00003075                M .x	=	.x+$101
0000FD34 3075                     M 	dc.w	.x
0000FD36 =00003176                M .x	=	.x+$101
0000FD36 3176                     M 	dc.w	.x
0000FD38 =00003277                M .x	=	.x+$101
0000FD38 3277                     M 	dc.w	.x
0000FD3A =00003378                M .x	=	.x+$101
0000FD3A 3378                     M 	dc.w	.x
0000FD3C =00003479                M .x	=	.x+$101
0000FD3C 3479                     M 	dc.w	.x
0000FD3E =0000357A                M .x	=	.x+$101
0000FD3E 357A                     M 	dc.w	.x
0000FD40 =0000367B                M .x	=	.x+$101
0000FD40 367B                     M 	dc.w	.x
0000FD42 =0000377C                M .x	=	.x+$101
0000FD42 377C                     M 	dc.w	.x
0000FD44 =0000387D                M .x	=	.x+$101
0000FD44 387D                     M 	dc.w	.x
0000FD46 =0000397E                M .x	=	.x+$101
0000FD46 397E                     M 	dc.w	.x
0000FD48 =00003A7F                M .x	=	.x+$101
0000FD48 3A7F                     M 	dc.w	.x
0000FD4A =00003B80                M .x	=	.x+$101
0000FD4A                            ; ===========================================================================
0000FD4A                            ; ---------------------------------------------------------------------------
0000FD4A                            ; Process SFX PSG channels
0000FD4A                            ; ---------------------------------------------------------------------------
0000FD4A                            
0000FD4A                            dAMPSdoPSGSFX:
0000FD4A 7E02                       		moveq	#SFX_PSG-1,d7		; get total number of SFX PSG channels to d7
0000FD4C 4DFA FEFC                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0000FD50                            
0000FD50                            dAMPSnextPSGSFX:
0000FD50 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000FD54 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000FD56 6A00                       		bpl.s	.next			; if not, branch
0000FD58 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000FD5C 6700 0000                  		beq.w	.update			; if timed out, update channel
0000FD60                            
0000FD60                            	dCalcFreq				; calculate channel base frequency
0000FD60 1C2D 0007                M 	move.b	cdetune(a5),d6
0000FD64 4886                     M 	ext.w	d6
0000FD66 DC6D 000E                M 	add.w	cfreq(a5),d6
0000FD6A                            	dModulate				; run modulation code
0000FD6A 0815 0003                M 	btst	#cfbmod,(a5)
0000FD6E 6700                     M 	beq.s	.noret
0000FD70 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000FD74 6700                     M 	beq.s	.started
0000FD76 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000FD7A                          M .noret
0000FD7A 6000                     M 	bra.s	.endm
0000FD7C                          M .started
0000FD7C 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000FD80 66F8                     M 	bne.s	.noret
0000FD82 226D 0010                M 	movea.l	cmod(a5),a1
0000FD86 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000FD8C 4A2D 0018                M 	tst.b	cmodcount(a5)
0000FD90 6600                     M 	bne.s	.norev
0000FD92 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000FD98 442D 0017                M 	neg.b	cmodstep(a5)
0000FD9C                          M .norev
0000FD9C 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000FDA0 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000FDA4 4885                     M 	ext.w	d5
0000FDA6 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000FDAA 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000FDAE DC45                     M 	add.w	d5,d6
0000FDB0 6100 0000                  		bsr.w	dUpdateFreqPSG3		; if frequency needs changing, do it
0000FDB4                            
0000FDB4                            .endm
0000FDB4 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0000FDB8                            .next
0000FDB8 51CF FF96                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0000FDBC 4EFA 0000                  		jmp	dCheckTracker(pc)	; after that, check tracker and end loop
0000FDC0                            
0000FDC0                            .update
0000FDC0 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000FDC4                            	dDoTracker				; process tracker
0000FDC4 286D 0002                M 	movea.l	cdata(a5),a4
0000FDC8                          M 	amps_debug_trackupd
0000FDC8 220C                     M 	move.l	a4,d1
0000FDCA 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000FDD0 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000FDD6 6500                     M 	blo.s	.fail2
0000FDD8 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000FDDE 6500                     M 	blo.s	.data
0000FDE0                          M .fail2
0000FDE0                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FDE0 487A FFFE                M 	pea	*(pc)
0000FDE4                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FDE4 40E7                     M 	move.w	sr,-(sp)
0000FDE6                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDE6 =00000000                M 	__stack:set	0
0000FDE6 =00000000                M 	__sp:	set 0
0000FDE6                          M 	while	(__pos)
0000FDE6 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FDE6 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FDE6 =00000021                M 	__midpos:	= __endpos
0000FDE6                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6                          M 	pushp	"move.l a4,-(sp)"
0000FDE6 =00000001                M 	__stack:	= __stack+1
0000FDE6 =00000004                M 	__sp:	= __sp+4
0000FDE6 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDE6 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FDE6 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FDE6 =00000029                M 	__midpos:	= __endpos
0000FDE6                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDE6 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FDE6 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FDE6                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDE6                          M 	pushp	"move.l a4,-(sp)"
0000FDE6 =00000002                M 	__stack:	= __stack+1
0000FDE6 =00000008                M 	__sp:	= __sp+4
0000FDE6 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDE6                          M 	rept	__stack
0000FDE6                          M 	popp	__command
0000FDE6 2F0C                     M 	move.l	a4,-(sp)
0000FDE8                          M 	popp	__command
0000FDE8 2F0C                     M 	move.l	a4,-(sp)
0000FDEA 4EB9 0000 0000           M 	jsr	errorhandler
0000FDF0                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDF0 =00000001                M 	__lpos:	set 1
0000FDF0 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDF0                          M 	while	(__pos)
0000FDF0                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDF0 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000FE09 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FE09 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FE09 =00000021                M 	__midpos:	= __endpos
0000FE09                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE09                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE09                          M 	__param:	substr ,,"hex"
0000FE09 83                       M 	dc.b	hex|3
0000FE0A =00000022                M 	__lpos:	set __endpos+1
0000FE0A =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE0A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE0A                          M 	dc.b	""
0000FE0A =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FE0A =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FE0A =00000029                M 	__midpos:	= __endpos
0000FE0A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE0A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE0A E0                       M 	dc.b	fendl
0000FE0B =0000002A                M 	__lpos:	set __endpos+1
0000FE0B =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE0B                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE0B                          M 	dc.b	""
0000FE0B =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FE0B =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FE0B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE0B                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE0B B3                       M 	dc.b	sym|3
0000FE0C =00000036                M 	__lpos:	set __endpos+1
0000FE0C =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FE0C                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FE0C                          M 	dc.b	""
0000FE0C 00                       M 	dc.b	0
0000FE0D 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000FE0E                          M 	even
0000FE0E 4EFA D4A8                M 	jmp	amps_debug_console_channel
0000FE12                          M 	even
0000FE12                          M .data
0000FE12 7A00                     M 	moveq	#0,d5
0000FE14 1A1C                     M 	move.b	(a4)+,d5
0000FE16 0C05 00E0                M 	cmpi.b	#$e0,d5
0000FE1A 6500                     M 	blo.s	.notcomm
0000FE1C 4EBA 0000                M 	jsr	dcommands(pc)
0000FE20 60F0                     M 	bra.s	.data
0000FE22 6094                     M 	bra.s	.next
0000FE24                          M .notcomm
0000FE24 4A05                       		tst.b	d5			; check if note is being played
0000FE26 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000FE28                            
0000FE28                            	dGetFreqPSG				; get PSG frequency
0000FE28 0405 0081                M 	subi.b	#$81,d5
0000FE2C 6400                     M 	bhs.s	.norest
0000FE2E 08D5 0000                M 	bset	#cfbrest,(a5)
0000FE32 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0000FE38 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0000FE3C 6000                     M 	bra.s	.freqgot
0000FE3E                          M .norest
0000FE3E DA2D 0008                M 	add.b	cpitch(a5),d5
0000FE42 0245 007F                M 	andi.w	#$7f,d5
0000FE46 DA45                     M 	add.w	d5,d5
0000FE48 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0000FE4E                          M 	amps_debug_notepsg
0000FE4E 0C05 008C                M 	cmp.b	#dfreqpsg_-dfreqpsg,d5
0000FE52 6500                     M 	blo.s	.ok
0000FE54                          M .fail
0000FE54 4EBA E0CA                M 	jsr	amps_debugr_notepsg
0000FE58                          M .ok
0000FE58                          M .freqgot
0000FE58 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000FE5A 6A00                       		bpl.s	.timer			; if yes, handle timer
0000FE5C 534C                       		subq.w	#1,a4			; else, undo the increment
0000FE5E 6000                       		bra.s	.pcnote			; do not calculate duration
0000FE60                            
0000FE60                            .timer
0000FE60 4EBA EB1A                  		jsr	dCalcDuration(pc)	; calculate duration
0000FE64                            .pcnote
0000FE64                            	dProcNote 1, 1				; reset necessary channel memory
0000FE64 2B4C 0002                M 	move.l	a4,cdata(a5)
0000FE68 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000FE6E 0815 0002                M 	btst	#cfbhold,(a5)
0000FE72 6600                     M 	bne.s	.endpn
0000FE74 422D 0006                M 	clr.b	cenvpos(a5)
0000FE78 0815 0003                M 	btst	#cfbmod,(a5)
0000FE7C 6700                     M 	beq.s	.endpn
0000FE7E 226D 0010                M 	movea.l	cmod(a5),a1
0000FE82 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000FE86 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000FE8A 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000FE8E 1011                     M 	move.b	(a1),d0
0000FE90 E208                     M 	lsr.b	#1,d0
0000FE92 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000FE96 426D 0014                M 	clr.w	cmodfreq(a5)
0000FE9A                          M .endpn
0000FE9A                            
0000FE9A 6100 0000                  		bsr.w	dUpdateFreqPSG		; update hardware frequency
0000FE9E 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0000FEA2 51CF FEAC                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0000FEA6                            	; continue to check tracker and end loop
0000FEA6                            ; ===========================================================================
0000FEA6                            ; ---------------------------------------------------------------------------
0000FEA6                            ; End channel loop and check if tracker debugger should be opened
0000FEA6                            ; ---------------------------------------------------------------------------
0000FEA6                            
0000FEA6                            dCheckTracker:
0000FEA6 4A38 C740                  		tst.b	msChktracker.w		; check if tracker debugger flag was set
0000FEAA 6700                       		beq.s	.rts			; if not, skip
0000FEAC 4238 C740                  		clr.b	msChktracker.w		; clear that flag
0000FEB0                            		AMPS_Debug_ChkTracker		; run debugger
0000FEB0                          M .fail
0000FEB0 4EBA E1E0                M 	jsr	amps_debugr_chktracker
0000FEB4                            .rts
0000FEB4 4E75                       		rts
0000FEB6                            ; ===========================================================================
0000FEB6                            ; ---------------------------------------------------------------------------
0000FEB6                            ; Music PSG channel loop
0000FEB6                            ; ---------------------------------------------------------------------------
0000FEB6                            
0000FEB6                            dAMPSdoPSG:
0000FEB6 7E02                       		moveq	#Mus_PSG-1,d7		; get total number of music PSG channels to d7
0000FEB8 4DFA FD90                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0000FEBC                            
0000FEBC                            dAMPSnextPSG:
0000FEBC DAFC 002C                  		add.w	#cSize,a5		; go to the next channe
0000FEC0 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000FEC2 6A00 0000                  		bpl.w	.next			; if not, branch
0000FEC6 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000FECA 6700 0000                  		beq.w	.update			; if timed out, update channel
0000FECE                            
0000FECE                            	dNoteToutPSG				; handle PSG-specific note timeout behavior
0000FECE                          M 	dnotetouthandler
0000FECE 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000FED2 6700                     M 	beq.s	.endt
0000FED4 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000FED8 6600                     M 	bne.s	.endt
0000FEDA 08D5 0000                M 	bset	#cfbrest,(a5)
0000FEDE 6100 0000                M 	bsr.w	dmutepsgmus
0000FEE2 6000                     M 	bra.s	.next
0000FEE4                          M .endt
0000FEE4                            	dCalcFreq				; calculate channel base frequency
0000FEE4 1C2D 0007                M 	move.b	cdetune(a5),d6
0000FEE8 4886                     M 	ext.w	d6
0000FEEA DC6D 000E                M 	add.w	cfreq(a5),d6
0000FEEE                            	dModulate				; run modulation code
0000FEEE 0815 0003                M 	btst	#cfbmod,(a5)
0000FEF2 6700                     M 	beq.s	.noret
0000FEF4 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000FEF8 6700                     M 	beq.s	.started
0000FEFA 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000FEFE                          M .noret
0000FEFE 6000                     M 	bra.s	.endm
0000FF00                          M .started
0000FF00 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000FF04 66F8                     M 	bne.s	.noret
0000FF06 226D 0010                M 	movea.l	cmod(a5),a1
0000FF0A 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000FF10 4A2D 0018                M 	tst.b	cmodcount(a5)
0000FF14 6600                     M 	bne.s	.norev
0000FF16 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000FF1C 442D 0017                M 	neg.b	cmodstep(a5)
0000FF20                          M .norev
0000FF20 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000FF24 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000FF28 4885                     M 	ext.w	d5
0000FF2A DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000FF2E 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000FF32 DC45                     M 	add.w	d5,d6
0000FF34 6100 0000                  		bsr.w	dUpdateFreqPSG2		; if frequency needs changing, do it
0000FF38                            
0000FF38                            .endm
0000FF38 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0000FF3C                            .next
0000FF3C 51CF FF7E                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0000FF40 4EFA EA52                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0000FF44                            
0000FF44                            .update
0000FF44 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000FF48                            	dDoTracker				; process tracker
0000FF48 286D 0002                M 	movea.l	cdata(a5),a4
0000FF4C                          M 	amps_debug_trackupd
0000FF4C 220C                     M 	move.l	a4,d1
0000FF4E 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000FF54 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000FF5A 6500                     M 	blo.s	.fail2
0000FF5C 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000FF62 6500                     M 	blo.s	.data
0000FF64                          M .fail2
0000FF64                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FF64 487A FFFE                M 	pea	*(pc)
0000FF68                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FF68 40E7                     M 	move.w	sr,-(sp)
0000FF6A                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF6A =00000000                M 	__stack:set	0
0000FF6A =00000000                M 	__sp:	set 0
0000FF6A                          M 	while	(__pos)
0000FF6A =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF6A =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF6A =00000021                M 	__midpos:	= __endpos
0000FF6A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A                          M 	pushp	"move.l a4,-(sp)"
0000FF6A =00000001                M 	__stack:	= __stack+1
0000FF6A =00000004                M 	__sp:	= __sp+4
0000FF6A =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF6A =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF6A =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF6A =00000029                M 	__midpos:	= __endpos
0000FF6A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF6A =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF6A =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF6A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF6A                          M 	pushp	"move.l a4,-(sp)"
0000FF6A =00000002                M 	__stack:	= __stack+1
0000FF6A =00000008                M 	__sp:	= __sp+4
0000FF6A =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF6A                          M 	rept	__stack
0000FF6A                          M 	popp	__command
0000FF6A 2F0C                     M 	move.l	a4,-(sp)
0000FF6C                          M 	popp	__command
0000FF6C 2F0C                     M 	move.l	a4,-(sp)
0000FF6E 4EB9 0000 0000           M 	jsr	errorhandler
0000FF74                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF74 =00000001                M 	__lpos:	set 1
0000FF74 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF74                          M 	while	(__pos)
0000FF74                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF74 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000FF8D =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF8D =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF8D =00000021                M 	__midpos:	= __endpos
0000FF8D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF8D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF8D                          M 	__param:	substr ,,"hex"
0000FF8D 83                       M 	dc.b	hex|3
0000FF8E =00000022                M 	__lpos:	set __endpos+1
0000FF8E =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF8E                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF8E                          M 	dc.b	""
0000FF8E =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF8E =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF8E =00000029                M 	__midpos:	= __endpos
0000FF8E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF8E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF8E E0                       M 	dc.b	fendl
0000FF8F =0000002A                M 	__lpos:	set __endpos+1
0000FF8F =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF8F                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF8F                          M 	dc.b	""
0000FF8F =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF8F =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF8F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF8F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF8F B3                       M 	dc.b	sym|3
0000FF90 =00000036                M 	__lpos:	set __endpos+1
0000FF90 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF90                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF90                          M 	dc.b	""
0000FF90 00                       M 	dc.b	0
0000FF91 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000FF92                          M 	even
0000FF92 4EFA D324                M 	jmp	amps_debug_console_channel
0000FF96                          M 	even
0000FF96                          M .data
0000FF96 7A00                     M 	moveq	#0,d5
0000FF98 1A1C                     M 	move.b	(a4)+,d5
0000FF9A 0C05 00E0                M 	cmpi.b	#$e0,d5
0000FF9E 6500                     M 	blo.s	.notcomm
0000FFA0 4EBA 0000                M 	jsr	dcommands(pc)
0000FFA4 60F0                     M 	bra.s	.data
0000FFA6 6094                     M 	bra.s	.next
0000FFA8                          M .notcomm
0000FFA8 4A05                       		tst.b	d5			; check if note is being played
0000FFAA 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000FFAC                            
0000FFAC                            	dGetFreqPSG				; get PSG frequency
0000FFAC 0405 0081                M 	subi.b	#$81,d5
0000FFB0 6400                     M 	bhs.s	.norest
0000FFB2 08D5 0000                M 	bset	#cfbrest,(a5)
0000FFB6 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0000FFBC 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0000FFC0 6000                     M 	bra.s	.freqgot
0000FFC2                          M .norest
0000FFC2 DA2D 0008                M 	add.b	cpitch(a5),d5
0000FFC6 0245 007F                M 	andi.w	#$7f,d5
0000FFCA DA45                     M 	add.w	d5,d5
0000FFCC 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0000FFD2                          M 	amps_debug_notepsg
0000FFD2 0C05 008C                M 	cmp.b	#dfreqpsg_-dfreqpsg,d5
0000FFD6 6500                     M 	blo.s	.ok
0000FFD8                          M .fail
0000FFD8 4EBA DF46                M 	jsr	amps_debugr_notepsg
0000FFDC                          M .ok
0000FFDC                          M .freqgot
0000FFDC 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000FFDE 6A00                       		bpl.s	.timer			; if yes, handle timer
0000FFE0 534C                       		subq.w	#1,a4			; else, undo the increment
0000FFE2 6000                       		bra.s	.pcnote			; do not calculate duration
0000FFE4                            
0000FFE4                            .timer
0000FFE4 4EBA E996                  		jsr	dCalcDuration(pc)	; calculate duration
0000FFE8                            .pcnote
0000FFE8                            	dProcNote 0, 1				; reset necessary channel memory
0000FFE8 2B4C 0002                M 	move.l	a4,cdata(a5)
0000FFEC 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000FFF2 0815 0002                M 	btst	#cfbhold,(a5)
0000FFF6 6600                     M 	bne.s	.endpn
0000FFF8 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000FFFE 422D 0006                M 	clr.b	cenvpos(a5)
00010002 0815 0003                M 	btst	#cfbmod,(a5)
00010006 6700                     M 	beq.s	.endpn
00010008 226D 0010                M 	movea.l	cmod(a5),a1
0001000C 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
00010010 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
00010014 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
00010018 1011                     M 	move.b	(a1),d0
0001001A E208                     M 	lsr.b	#1,d0
0001001C 1B40 0018                M 	move.b	d0,cmodcount(a5)
00010020 426D 0014                M 	clr.w	cmodfreq(a5)
00010024                          M .endpn
00010024                            
00010024 6100                       		bsr.s	dUpdateFreqPSG		; update hardware frequency
00010026 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001002A 51CF FE90                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001002E 4EFA E964                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
00010032                            ; ===========================================================================
00010032                            ; ---------------------------------------------------------------------------
00010032                            ; Write PSG frequency to hardware
00010032                            ; ---------------------------------------------------------------------------
00010032                            
00010032                            dUpdateFreqPSG:
00010032 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
00010036 6A00                       		bpl.s	.detune			; if it was not rest frequency, branch
00010038 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001003C 4E75                       		rts
0001003E                            
0001003E                            .detune
0001003E 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
00010042 4880                       		ext.w	d0			; extend to word
00010044 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
00010046                            
00010046 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001004A 6700                       		beq.s	dUpdateFreqPSG2		; if not, branch
0001004C DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
00010050                            
00010050                            dUpdateFreqPSG2:
00010050 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
00010054 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
00010056                            
00010056                            dUpdateFreqPSG3:
00010056 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001005A 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001005C                            
0001005C 102D 0001                  		move.b	cType(a5),d0		; load channel type value to d0
00010060 0C00 00E0                  		cmpi.b	#ctPSG4,d0		; check if this channel is in PSG4 mode
00010064 6600                       		bne.s	.notPSG4		; if not, branch
00010066 70C0                       		moveq	#$FFFFFF00|ctPSG3,d0	; load PSG3 type value instead
00010068                            
00010068                            .notPSG4
00010068 3206                       		move.w	d6,d1			; copy frequency to d1
0001006A 0201 000F                  		andi.b	#$F,d1			; get the low nibble of it
0001006E 8001                       		or.b	d1,d0			; combine with channel type
00010070                            ; ---------------------------------------------------------------------------
00010070                            ; Note about the and instruction below: If this instruction is
00010070                            ; not commented out, the instashield SFX will not sound correct.
00010070                            ; This instruction was removed in Sonic 3K because of this, but
00010070                            ; this can cause issues when values overflow the valid range of
00010070                            ; PSG frequency. This may cause erroneous behavior if not anded,
00010070                            ; but will also make the instashield SFX not sound correctly.
00010070                            ; Comment out the instruction with caution, if you are planning
00010070                            ; to port said sound effect to this driver. This has not caused
00010070                            ; any issues for me, and if you are careful you can avoid any
00010070                            ; such case, but beware of this issue!
00010070                            ; ---------------------------------------------------------------------------
00010070                            
00010070 E84E                       		lsr.w	#4,d6			; get the 2 higher nibbles of frequency
00010072 0206 003F                  		andi.b	#$3F,d6			; clear any extra bits that aren't valid
00010076 13C0 00C0 0011             		move.b	d0,dPSG			; write frequency low nibble and latch channel
0001007C 13C6 00C0 0011             		move.b	d6,dPSG			; write frequency high nibbles to PSG
00010082                            
00010082                            locret_dUpdateFreqPSG:
00010082 4E75                       		rts
00010084                            ; ===========================================================================
00010084                            ; ---------------------------------------------------------------------------
00010084                            ; Routine for running envelope programs
00010084                            ; ---------------------------------------------------------------------------
00010084                            
00010084                            dEnvProgPSG:
00010084 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
00010088 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001008C                            
0001008C 7800                       		moveq	#0,d4
0001008E 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
00010092 6700                       		beq.s	dUpdateVolPSG2		; if 0, update volume only
00010094 6000                       		bra.s	dEnvProgPSG2		; continue to run code below
00010096                            
00010096                            dEnvelopePSG:
00010096 7800                       		moveq	#0,d4
00010098 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001009C 6700                       		beq.s	locret_UpdVolPSG	; if 0, return
0001009E                            
0001009E 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
000100A2 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
000100A6                            
000100A6                            dEnvProgPSG2:
000100A6                            		AMPS_Debug_VolEnvID		; check if volume envelope ID is valid
000100A6 0C04 0000                M 	cmp.b	#(volenvs_end-volenvs)/4,d4
000100AA 6300                     M 	bls.s	.ok
000100AC 4EBA DE3C                M 	jsr	amps_debugr_volenvid
000100B0                          M .ok
000100B0                            
000100B0 43FA 0000                  		lea	VolEnvs-4(pc),a1	; load volume envelope data array
000100B4 D844                       		add.w	d4,d4			; quadruple volume envelope ID
000100B6 D844                       		add.w	d4,d4			; (each entry is 4 bytes in size)
000100B8 2271 4000                  		move.l	(a1,d4.w),a1		; get pointer to volume envelope data
000100BC                            
000100BC 7200                       		moveq	#0,d1
000100BE 7000                       		moveq	#0,d0
000100C0                            
000100C0                            dEnvProgPSG3:
000100C0 122D 0006                  		move.b	cEnvPos(a5),d1		; get envelope position to d1
000100C4 1031 1000                  		move.b	(a1,d1.w),d0		; get the date in that position
000100C8 6B00                       		bmi.s	dEnvCommand		; if it is a command, handle it
000100CA                            
000100CA 522D 0006                  		addq.b	#1,cEnvPos(a5)		; increment envelope position
000100CE DA00                       		add.b	d0,d5			; add envelope volume to d5
000100D0                            	; continue to update PSG volume
000100D0                            ; ===========================================================================
000100D0                            ; ---------------------------------------------------------------------------
000100D0                            ; Routine for updating PSG volume to hardware
000100D0                            ; ---------------------------------------------------------------------------
000100D0                            
000100D0                            dUpdateVolPSG2:
000100D0 0C05 000F                  		cmpi.b	#$F,d5			; check if volume is out of range
000100D4 6300                       		bls.s	dUpdateVolPSG		; if not, branch
000100D6 7A0F                       		moveq	#$F,d5			; cap volume to silent
000100D8                            
000100D8                            dUpdateVolPSG:
000100D8 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
000100DC 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
000100DE 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
000100E2 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
000100E4                            
000100E4 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
000100E8 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
000100EA BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this is a SFX channel
000100EE 6400                       		bhs.s	dUpdVolPSGset		; if so, update volume
000100F0                            
000100F0 4A2D 001D                  		tst.b	cNoteTimeMain(a5)	; check if note timeout is active
000100F4 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
000100F6 4A2D 001C                  		tst.b	cNoteTimeCur(a5)	; is note stopped already?
000100FA 6700                       		beq.s	locret_UpdVolPSG	; if is, do not update
000100FC                            
000100FC                            dUpdVolPSGset:
000100FC 8A2D 0001                  		or.b	cType(a5),d5		; combine channel type value with volume
00010100 0605 0010                  		addi.b	#$10,d5			; set volume update bit
00010104 13C5 00C0 0011             		move.b	d5,dPSG			; write volume command to PSG port
0001010A                            
0001010A                            locret_UpdVolPSG:
0001010A 4E75                       		rts
0001010C                            ; ===========================================================================
0001010C                            ; ---------------------------------------------------------------------------
0001010C                            ; Subroutine for handling volume envelope commands
0001010C                            ; ---------------------------------------------------------------------------
0001010C                            
0001010C                            dEnvCommand:
0001010C                            		AMPS_Debug_VolEnvCmd		; check if command is valid
0001010C 0C00 0088                M 	cmp.b	#elast,d0
00010110 6400                     M 	bhs.s	.fail
00010112 0C00 0080                M 	cmp.b	#$80,d0
00010116 6500                     M 	blo.s	.fail
00010118 0800 0000                M 	btst	#0,d0
0001011C 6700                     M 	beq.s	.ok
0001011E                          M .fail
0001011E                          M 	raiseerror2	"Volume envelope command invalid: %<.b d0>",amps_debug_console_channel
0001011E 40E7                     M 	move.w	sr,-(sp)
00010120                          M 	__fstring_generateargumentscode	"Volume envelope command invalid: %<.b d0>"
00010120 =00000022                M 	__pos:	set instr("Volume envelope command invalid: %<.b d0>",'%<')
00010120 =00000000                M 	__stack:set	0
00010120 =00000000                M 	__sp:	set 0
00010120                          M 	while	(__pos)
00010120 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'>')
00010120 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope command invalid: %<.b d0>",' ')
00010120 =00000029                M 	__midpos:	= __endpos
00010120                          M 	__substr:	substr __pos+1+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
00010120                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope command invalid: %<.b d0>"
00010120                          M 	__operand:	substr __pos+1+1,__midpos-1,"Volume envelope command invalid: %<.b d0>"
00010120                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
00010120                          M 	pushp	"move.b d0,1(sp)"
00010120                          M 	pushp	"subq.w	#2, sp"
00010120 =00000002                M 	__stack:	= __stack+2
00010120 =00000002                M 	__sp:	= __sp+2
00010120 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'%<')
00010120                          M 	rept	__stack
00010120                          M 	popp	__command
00010120 554F                     M 	subq.w	#2,sp
00010122                          M 	popp	__command
00010122 1F40 0001                M 	move.b	d0,1(sp)
00010126 4EB9 0000 0000           M 	jsr	errorhandler
0001012C                          M 	__fstring_generatedecodedstring	"Volume envelope command invalid: %<.b d0>"
0001012C =00000001                M 	__lpos:	set 1
0001012C =00000022                M 	__pos:	set instr("Volume envelope command invalid: %<.b d0>",'%<')
0001012C                          M 	while	(__pos)
0001012C                          M 	__substr:	substr __lpos,__pos-1,"Volume envelope command invalid: %<.b d0>"
0001012C 566F 6C75 6D65 2065 6E76+M 	dc.b	"Volume envelope command invalid: "
0001014D =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'>')
0001014D =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope command invalid: %<.b d0>",' ')
0001014D =00000029                M 	__midpos:	= __endpos
0001014D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope command invalid: %<.b d0>"
0001014D                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
0001014D                          M 	__param:	substr ,,"hex"
0001014D 80                       M 	dc.b	hex
0001014E =0000002A                M 	__lpos:	set __endpos+1
0001014E =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'%<')
0001014E                          M 	__substr:	substr __lpos,,"Volume envelope command invalid: %<.b d0>"
0001014E                          M 	dc.b	""
0001014E 00                       M 	dc.b	0
0001014F 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010150                          M 	even
00010150 4EFA D166                M 	jmp	amps_debug_console_channel
00010154                          M 	even
00010154                          M .ok
00010154                            
00010154 4EFB 0000                  		jmp	.comm-$80(pc,d0.w)	; jump to command handler
00010158                            
00010158                            .comm
00010158 6000                       		bra.s	.reset			; 80 - Loop back to beginning
0001015A 6000                       		bra.s	.hold			; 82 - Hold the envelope at current level
0001015C 6000                       		bra.s	.loop			; 84 - Go to position defined by the next byte
0001015E                            	;	bra.s	.stop			; 86 - Stop current note and envelope
0001015E                            ; ---------------------------------------------------------------------------
0001015E                            
0001015E                            .stop
0001015E 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting bit
00010162 6000                       		bra.s	dMutePSGmus		; nute the channel
00010164                            ; ---------------------------------------------------------------------------
00010164                            
00010164                            .hold
00010164 532D 0006                  		subq.b	#1,cEnvPos(a5)		; decrease envelope position
00010168 4EFA FF56                  		jmp	dEnvProgPSG3(pc)	; run the program again (make sure volume fades work)
0001016C                            ; ---------------------------------------------------------------------------
0001016C                            
0001016C                            .reset
0001016C 422D 0006                  		clr.b	cEnvPos(a5)		; set envelope position to 0
00010170 4EFA FF4E                  		jmp	dEnvProgPSG3(pc)	; run the program again
00010174                            ; ---------------------------------------------------------------------------
00010174                            
00010174                            .loop
00010174 1B71 1001 0006             		move.b	1(a1,d1.w),cEnvPos(a5)	; set envelope position to the next byte
0001017A 4EFA FF44                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001017E                            ; ===========================================================================
0001017E                            ; ---------------------------------------------------------------------------
0001017E                            ; Routine for hardware muting a PSG channel
0001017E                            ; ---------------------------------------------------------------------------
0001017E                            
0001017E                            dMutePSGmus:
0001017E 0815 0001                  		btst	#cfbInt,(a5)		; check if this is a SFX channel
00010182 6600                       		bne.s	locret_MutePSG		; if yes, do not update
00010184                            
00010184                            dMutePSGsfx:
00010184 701F                       		moveq	#$1F,d0			; prepare volume update to mute value to d0
00010186 802D 0001                  		or.b	cType(a5),d0		; combine channel type value with d0
0001018A 13C0 00C0 0011             		move.b	d0,dPSG			; write volume command to PSG port
00010190                            
00010190                            locret_MutePSG:
00010190 4E75                       		rts
00010192                            
00010192 414D 5053 2031 2E30        	dc.b "AMPS 1.0"				; not required, just here to make my life easier
0001019A                            ; ===========================================================================
0001019A                            ; ---------------------------------------------------------------------------
0001019A                            ; Routine to execute tracker commands
0001019A                            ;
0001019A                            ; The reason we use add.b instead of add.w, is to get rid of some bits that
0001019A                            ; would make this kind of arbitary jumping way more complex than it needs to be.
0001019A                            ; What do we win by doing this? Why, 8 cycles per command! Thats... Not a lot,
0001019A                            ; but it may be helpful with speed anyway.
0001019A                            ; ---------------------------------------------------------------------------
0001019A                            
0001019A                            dCommands:
0001019A DA05                       		add.b	d5,d5			; quadruple command ID
0001019C DA05                       		add.b	d5,d5			; since each entry is 4 bytes large
0001019E                            
0001019E 0815 0004                  		btst	#cfbCond,(a5)		; check if condition state
000101A2 6600 0000                  		bne.w	.falsecomm		; branch if false
000101A6 4EFB 5000                  		jmp	.comm-$80(pc,d5.w)	; jump to appropriate handler
000101AA                            ; ===========================================================================
000101AA                            ; ---------------------------------------------------------------------------
000101AA                            ; Command handlers for normal execution
000101AA                            ; ---------------------------------------------------------------------------
000101AA                            
000101AA                            .comm
000101AA 6000 0000                  	bra.w	dcPan		; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
000101AE 6000 0000                  	bra.w	dcsDetune	; E1 - Set channel frequency displacement to xx (DETUNE_SET)
000101B2 6000 0000                  	bra.w	dcaDetune	; E2 - Add xx to channel frequency displacement (DETUNE)
000101B6 6000 0000                  	bra.w	dcsTransp	; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
000101BA 6000 0000                  	bra.w	dcaTransp	; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
000101BE 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
000101C2 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
000101C6 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
000101CA 6000 0000                  	bra.w	dcVoice		; E8 - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
000101CE 6000 0000                  	bra.w	dcsTempoShoes	; E9 - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
000101D2 6000 0000                  	bra.w	dcsTempo	; EA - Set music tempo to xx (TEMPO - TEMPO_SET)
000101D6 6000 0000                  	bra.w	dcModOn		; EB - Turn on Modulation (MOD_SET - MODS_ON)
000101DA 6000 0000                  	bra.w	dcModOff	; EC - Turn off Modulation (MOD_SET - MODS_OFF)
000101DE 6000 0000                  	bra.w	dcaVolume	; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
000101E2 6000 0000                  	bra.w	dcsVolume	; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
000101E6 6000 0000                  	bra.w	dcsLFO		; EF - Set LFO (SET_LFO - LFO_AMSEN)
000101EA 6000 0000                  	bra.w	dcMod68K	; F0 - Modulation (MOD_SETUP)
000101EE 6000 0000                  	bra.w	dcSampDAC	; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
000101F2 6000 0000                  	bra.w	dcPitchDAC	; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
000101F6 6000 0000                  	bra.w	dcNoisePSG	; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_AMPS)
000101FA 6000 0000                  	bra.w	dcCont		; F4 - Do a continuous SFX loop (CONT_SFX)
000101FE 6000 0000                  	bra.w	dcStop		; F5 - End of channel (TRK_END - TEND_STD)
00010202 6000 0000                  	bra.w	dcJump		; F6 - Jump to xxxx (GOTO)
00010206 6000 0000                  	bra.w	dcLoop		; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001020A 6000 0000                  	bra.w	dcCall		; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001020E 6000 0000                  	bra.w	dcReturn	; F9 - Return (RETURN)
00010212 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
00010216 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001021A 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COMM_RESET)
0001021E 6000 0000                  	bra.w	dcTimeout	; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
00010222 6000 0000                  	bra.w	dcYM		; FE - YM command (YMCMD)
00010226                            				; FF - META
00010226                            ; ===========================================================================
00010226                            ; ---------------------------------------------------------------------------
00010226                            ; Routine to execute tracker meta and false condition commands
00010226                            ; ---------------------------------------------------------------------------
00010226                            
00010226                            .metacall
00010226 1A1C                       		move.b	(a4)+,d5		; get next command byte
00010228 DA45                       		add.w	d5,d5			; quadruple ID
0001022A DA45                       		add.w	d5,d5			; since each entry is again 4 bytes large
0001022C 4EFB 5000                  		jmp	.meta(pc,d5.w)		; jump to appropriate meta handler
00010230                            
00010230                            .falsecomm
00010230 4EFB 5000                  		jmp	.false-$80(pc,d5.w)	; jump to appropriate handler (false command)
00010234                            ; ===========================================================================
00010234                            ; ---------------------------------------------------------------------------
00010234                            ; Command handlers for meta commands
00010234                            ; ---------------------------------------------------------------------------
00010234                            
00010234                            .meta
00010234 6000 0000                  	bra.w	dcWriteDAC1	; FF 00 - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00010238 6000 0000                  	bra.w	dcWriteDAC2	; FF 01 - Play sample xx on DAC2 (PLAY_DAC - PLAY_DAC2)
0001023C 6000 0000                  	bra.w	dcsFreq		; FF 02 - Set channel frequency to xxxx (CHFREQ_SET)
00010240 6000 0000                  	bra.w	dcsFreqNote	; FF 03 - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00010244 6000 0000                  	bra.w	dcSpRev		; FF 04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00010248 6000 0000                  	bra.w	dcSpReset	; FF 05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
0001024C 6000 0000                  	bra.w	dcaTempoShoes	; FF 06 - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00010250 6000 0000                  	bra.w	dcaTempo	; FF 07 - Add xx to music tempo (TEMPO - TEMPO_ADD)
00010254 6000 0000                  	bra.w	dcCondReg	; FF 08 - Get RAM table offset by y, and chk zz with cond x (COMM_CONDITION - COMM_SPEC)
00010258 6000 0000                  	bra.w	dcSound		; FF 09 - Play another music/sfx (SND_CMD)
0001025C 6000 0000                  	bra.w	dcFreqOn	; FF 0A - Enable raw frequency mode (RAW_FREQ)
00010260 6000 0000                  	bra.w	dcFreqOff	; FF 0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00010264 6000 0000                  	bra.w	dcSpecFM3	; FF 0C - Enable FM3 special mode (SPC_FM3)
00010268 6000 0000                  	bra.w	dcFilter	; FF 0D - Set DAC filter bank. (DAC_FILTER)
0001026C                            
0001026C 6000 0000                  		bra.w	dcFreeze	; FF 0E - Freeze CPU. Debug flag (DEBUG_STOP_CPU)
00010270 6000 0000                  		bra.w	dcTracker	; FF 0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00010274                            ; ===========================================================================
00010274                            ; ---------------------------------------------------------------------------
00010274                            ; Command handlers for false condition execution
00010274                            ; ---------------------------------------------------------------------------
00010274                            
00010274                            .false
00010274 524C                       	addq.w	#1,a4
00010276 4E75                       	rts			; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00010278 524C                       	addq.w	#1,a4
0001027A 4E75                       	rts			; E1 - Add xx to channel frequency displacement (DETUNE)
0001027C 524C                       	addq.w	#1,a4
0001027E 4E75                       	rts			; E2 - Add xx to channel frequency displacement (DETUNE)
00010280 524C                       	addq.w	#1,a4
00010282 4E75                       	rts			; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00010284 524C                       	addq.w	#1,a4
00010286 4E75                       	rts			; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00010288 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001028C 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00010290 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
00010294 524C                       	addq.w	#1,a4
00010296 4E75                       	rts			; E8 - Add xx to music tempo (TEMPO - TEMPO_ADD)
00010298 524C                       	addq.w	#1,a4
0001029A 4E75                       	rts			; E9 - Set music tempo to xx (TEMPO - TEMPO_SET)
0001029C 524C                       	addq.w	#1,a4
0001029E 4E75                       	rts			; EA - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
000102A0 4E75                       	rts
000102A2 4E75                       	rts			; EB - Turn on Modulation (MOD_SET - MODS_ON)
000102A4 4E75                       	rts
000102A6 4E75                       	rts			; EC - Turn off Modulation (MOD_SET - MODS_OFF)
000102A8 524C                       	addq.w	#1,a4
000102AA 4E75                       	rts			; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
000102AC 524C                       	addq.w	#1,a4
000102AE 4E75                       	rts			; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
000102B0 524C                       	addq.w	#1,a4
000102B2 4E75                       	rts			; EF - Set LFO (SET_LFO - LFO_AMSEN)
000102B4 584C                       	addq.w	#4,a4
000102B6 4E75                       	rts			; F0 - Modulation (MOD_SETUP)
000102B8 4E75                       	rts
000102BA 4E75                       	rts			; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
000102BC 4E75                       	rts
000102BE 4E75                       	rts			; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
000102C0 524C                       	addq.w	#1,a4
000102C2 4E75                       	rts			; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_SET)
000102C4 544C                       	addq.w	#2,a4
000102C6 4E75                       	rts			; F4 - Do a continuous SFX loop (CONT_SFX)
000102C8 4E75                       	rts
000102CA 4E75                       	rts			; F5 - End of channel (TRK_END - TEND_STD)
000102CC 544C                       	addq.w	#2,a4
000102CE 4E75                       	rts			; F6 - Jump to xxxx (GOTO)
000102D0 584C                       	addq.w	#4,a4
000102D2 4E75                       	rts			; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
000102D4 544C                       	addq.w	#2,a4
000102D6 4E75                       	rts			; F8 - Call pattern at xxxx, saving return point (GOSUB)
000102D8 4E75                       	rts
000102DA 4E75                       	rts			; F9 - Return (RETURN)
000102DC 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
000102E0 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
000102E4 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COND_RESET)
000102E8 524C                       	addq.w	#1,a4
000102EA 4E75                       	rts			; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
000102EC 524C                       	addq.w	#1,a4
000102EE 4E75                       	rts			; FE - YM command (YMCMD)
000102F0 6000 FF34                  	bra.w	.metacall	; FF - META
000102F4                            ; ===========================================================================
000102F4                            ; ---------------------------------------------------------------------------
000102F4                            ; Tracker commands for writing direct DAC samples to Dual PCM.
000102F4                            ; Note that this will override any DAC already being played,
000102F4                            ; and in turn trackers may override these DAC samples at any
000102F4                            ; time. Use with caution!
000102F4                            ; ---------------------------------------------------------------------------
000102F4                            
000102F4                            dcWriteDAC1:
000102F4 7000                       		moveq	#0,d0
000102F6 101C                       		move.b	(a4)+,d0		; get note to write
000102F8 4EFA E58C                  		jmp	dNoteWriteDAC1(pc)	; note-on
000102FC                            
000102FC                            dcWriteDAC2:
000102FC 7000                       		moveq	#0,d0
000102FE 101C                       		move.b	(a4)+,d0		; get note to write
00010300 4EFA E576                  		jmp	dNoteWriteDAC2(pc)	; note-on
00010304                            ; ===========================================================================
00010304                            ; ---------------------------------------------------------------------------
00010304                            ; Tracker commands for handling spindash revving.
00010304                            ; The way spindash revving works, is it actually just
00010304                            ; increments a counter each time, and this counter is
00010304                            ; added into the channel pitch offset.
00010304                            ; ---------------------------------------------------------------------------
00010304                            
00010304                            dcSpRev:
00010304 1038 C4C1                  		move.b	mSpindash.w,d0		; load spindash rev counter to d0
00010308 5238 C4C1                  		addq.b	#1,mSpindash.w		; increment spindash rev counter
0001030C D12D 0008                  		add.b	d0,cPitch(a5)		; add d0 to channel pitch offset
00010310                            
00010310 0C00 000B                  		cmp.b	#$C-1,d0		; check if this is the max pitch offset
00010314 6500                       		blo.s	.rts			; if not, skip
00010316 5338 C4C1                  		subq.b	#1,mSpindash.w		; cap at pitch offset $C
0001031A                            
0001031A                            .rts
0001031A 4E75                       		rts
0001031C                            
0001031C                            dcSpReset:
0001031C 4238 C4C1                  		clr.b	mSpindash.w		; reset spindash rev counter
00010320 4E75                       		rts
00010322                            ; ===========================================================================
00010322                            ; ---------------------------------------------------------------------------
00010322                            ; Tracker command for changing channel panning
00010322                            ; ---------------------------------------------------------------------------
00010322                            
00010322                            dcPan:
00010322                            		AMPS_Debug_dcPan		; check if this channel can pan
00010322 4A2D 0001                M 	tst.b	ctype(a5)
00010326 6A00                     M 	bpl.s	.ok
00010328                          M 	raiseerror	"sPan on a PSG channel!",amps_debug_console_channel
00010328 487A FFFE                M 	pea	*(pc)
0001032C                          M 	raiseerror2	"sPan on a PSG channel!",amps_debug_console_channel
0001032C 40E7                     M 	move.w	sr,-(sp)
0001032E                          M 	__fstring_generateargumentscode	"sPan on a PSG channel!"
0001032E =00000000                M 	__pos:	set instr("sPan on a PSG channel!",'%<')
0001032E =00000000                M 	__stack:set	0
0001032E =00000000                M 	__sp:	set 0
0001032E                          M 	while	(__pos)
0001032E                          M 	rept	__stack
0001032E 4EB9 0000 0000           M 	jsr	errorhandler
00010334                          M 	__fstring_generatedecodedstring	"sPan on a PSG channel!"
00010334 =00000001                M 	__lpos:	set 1
00010334 =00000000                M 	__pos:	set instr("sPan on a PSG channel!",'%<')
00010334                          M 	while	(__pos)
00010334                          M 	__substr:	substr __lpos,,"sPan on a PSG channel!"
00010334 7350 616E 206F 6E20 6120+M 	dc.b	"sPan on a PSG channel!"
0001034A 00                       M 	dc.b	0
0001034B 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001034C                          M 	even
0001034C 4EFA CF6A                M 	jmp	amps_debug_console_channel
00010350                          M 	even
00010350                          M .ok
00010350                            
00010350 7237                       		moveq	#$37,d1			; prepare bits to keep
00010352 C22D 0006                  		and.b	cPanning(a5),d1		; and with channel LFO settings
00010356 821C                       		or.b	(a4)+,d1		; or panning value
00010358 1B41 0006                  		move.b	d1,cPanning(a5)		; save as channel panning
0001035C                            
0001035C 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001035E 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
00010364 6700 F55A                  		beq.w	dWriteYMchnInt		; if not, write channel-specific YM command
00010368                            ; ---------------------------------------------------------------------------
00010368                            ; Since the DAC channels have or based panning behavior, we need this
00010368                            ; piece of code to update its panning
00010368                            ; ---------------------------------------------------------------------------
00010368                            
00010368 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001036C 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
00010372 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
00010374 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
00010378                            
00010378                            .nodacsfx
00010378 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001037C 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001037E 4EFA F592                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
00010382                            ; ===========================================================================
00010382                            ; ---------------------------------------------------------------------------
00010382                            ; Tracker commands for changing detune offset
00010382                            ; ---------------------------------------------------------------------------
00010382                            
00010382                            dcaDetune:
00010382 101C                       		move.b	(a4)+,d0		; load detune offset from tracker
00010384 D12D 0007                  		add.b	d0,cDetune(a5)		; Add to channel detune offset
00010388 4E75                       		rts
0001038A                            
0001038A                            dcsDetune:
0001038A 1B5C 0007                  		move.b	(a4)+,cDetune(a5)	; load detune offset from tracker to channel
0001038E 4E75                       		rts
00010390                            ; ===========================================================================
00010390                            ; ---------------------------------------------------------------------------
00010390                            ; Tracker command for changing channel volume
00010390                            ; ---------------------------------------------------------------------------
00010390                            
00010390                            dcsVolume:
00010390 1B5C 0009                  		move.b	(a4)+,cVolume(a5)	; load volume from tracker to channel
00010394 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
00010398 4E75                       		rts
0001039A                            
0001039A                            dcaVolume:
0001039A 101C                       		move.b	(a4)+,d0		; load volume from tracker
0001039C D12D 0009                  		add.b	d0,cVolume(a5)		; add to channel volume
000103A0 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
000103A4 4E75                       		rts
000103A6                            ; ===========================================================================
000103A6                            ; ---------------------------------------------------------------------------
000103A6                            ; Tracker command for setting DAC to sample mode and resetting frequency
000103A6                            ; ---------------------------------------------------------------------------
000103A6                            
000103A6                            dcSampDAC:
000103A6 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; reset to defualt base frequency
000103AC 0895 0000                  		bclr	#cfbMode,(a5)		; enable sample mode
000103B0 4E75                       		rts
000103B2                            ; ===========================================================================
000103B2                            ; ---------------------------------------------------------------------------
000103B2                            ; Tracker command for setting DAC to pitch mode
000103B2                            ; ---------------------------------------------------------------------------
000103B2                            
000103B2                            dcPitchDAC:
000103B2 08D5 0000                  		bset	#cfbMode,(a5)		; enable pitch mode
000103B6 4E75                       		rts
000103B8                            ; ===========================================================================
000103B8                            ; ---------------------------------------------------------------------------
000103B8                            ; Tracker commands for changing channel tick multiplier
000103B8                            ; ---------------------------------------------------------------------------
000103B8                            
000103B8                            dcsTmulCh:
000103B8 1B5C 000A                  		move.b	(a4)+,cTick(a5)		; load tick multiplier from tracker to channel
000103BC 4E75                       		rts
000103BE                            
000103BE                            dcsTmul:
000103BE 101C                       		move.b	(a4)+,d0		; load tick multiplier from tracker to d0
000103C0 =FFFFC4C4                  .x =	mDAC1					; start at DAC1
000103C0                            	rept Mus_Ch				; do for all music channels
000103C0                            		move.b	d0,cTick+.x.w		; set channel tick multiplier
000103C0                            .x =		.x+cSize			; go to next channel
000103C0                            	endr
000103C0 11C0 C4CE                M 	move.b	d0,ctick+.x.w
000103C4 =FFFFC4F0                M .x	=	.x+csize
000103C4 11C0 C4FA                M 	move.b	d0,ctick+.x.w
000103C8 =FFFFC51C                M .x	=	.x+csize
000103C8 11C0 C526                M 	move.b	d0,ctick+.x.w
000103CC =FFFFC548                M .x	=	.x+csize
000103CC 11C0 C552                M 	move.b	d0,ctick+.x.w
000103D0 =FFFFC574                M .x	=	.x+csize
000103D0 11C0 C57E                M 	move.b	d0,ctick+.x.w
000103D4 =FFFFC5A0                M .x	=	.x+csize
000103D4 11C0 C5AA                M 	move.b	d0,ctick+.x.w
000103D8 =FFFFC5CC                M .x	=	.x+csize
000103D8 11C0 C5D6                M 	move.b	d0,ctick+.x.w
000103DC =FFFFC5F8                M .x	=	.x+csize
000103DC 11C0 C602                M 	move.b	d0,ctick+.x.w
000103E0 =FFFFC624                M .x	=	.x+csize
000103E0 11C0 C62E                M 	move.b	d0,ctick+.x.w
000103E4 =FFFFC650                M .x	=	.x+csize
000103E4 11C0 C65A                M 	move.b	d0,ctick+.x.w
000103E8 =FFFFC67C                M .x	=	.x+csize
000103E8 4E75                       		rts
000103EA                            ; ===========================================================================
000103EA                            ; ---------------------------------------------------------------------------
000103EA                            ; Tracker command for enabling or disabling the hold flag
000103EA                            ; ---------------------------------------------------------------------------
000103EA                            
000103EA                            dcHold:
000103EA 0855 0002                  		bchg	#cfbHold,(a5)		; flip the channel hold flag
000103EE 4E75                       		rts
000103F0                            ; ===========================================================================
000103F0                            ; ---------------------------------------------------------------------------
000103F0                            ; Tracker command for enabling or disabling note timeout
000103F0                            ; ---------------------------------------------------------------------------
000103F0                            
000103F0                            dcTimeout:
000103F0                            		AMPS_Debug_dcTimeout		; check if this channel has timeout support
000103F0 BAFC C67C                M 	cmp.w	#msfxdac1,a5
000103F4 6500                     M 	blo.s	.ok
000103F6                          M 	raiseerror	"sNoteTimeOut on a SFX channel!",amps_debug_console_channel
000103F6 487A FFFE                M 	pea	*(pc)
000103FA                          M 	raiseerror2	"sNoteTimeOut on a SFX channel!",amps_debug_console_channel
000103FA 40E7                     M 	move.w	sr,-(sp)
000103FC                          M 	__fstring_generateargumentscode	"sNoteTimeOut on a SFX channel!"
000103FC =00000000                M 	__pos:	set instr("sNoteTimeOut on a SFX channel!",'%<')
000103FC =00000000                M 	__stack:set	0
000103FC =00000000                M 	__sp:	set 0
000103FC                          M 	while	(__pos)
000103FC                          M 	rept	__stack
000103FC 4EB9 0000 0000           M 	jsr	errorhandler
00010402                          M 	__fstring_generatedecodedstring	"sNoteTimeOut on a SFX channel!"
00010402 =00000001                M 	__lpos:	set 1
00010402 =00000000                M 	__pos:	set instr("sNoteTimeOut on a SFX channel!",'%<')
00010402                          M 	while	(__pos)
00010402                          M 	__substr:	substr __lpos,,"sNoteTimeOut on a SFX channel!"
00010402 734E 6F74 6554 696D 654F+M 	dc.b	"sNoteTimeOut on a SFX channel!"
00010420 00                       M 	dc.b	0
00010421 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010422                          M 	even
00010422 4EFA CE94                M 	jmp	amps_debug_console_channel
00010426                          M 	even
00010426                          M .ok
00010426                            
00010426 1B54 001D                  		move.b	(a4),cNoteTimeMain(a5)	; load note timeout from tracker to channel
0001042A 1B5C 001C                  		move.b	(a4)+,cNoteTimeCur(a5)	; ''
0001042E 4E75                       		rts
00010430                            ; ===========================================================================
00010430                            ; ---------------------------------------------------------------------------
00010430                            ; Tracker commands for changing channel pitch
00010430                            ; ---------------------------------------------------------------------------
00010430                            
00010430                            dcaTransp:
00010430 101C                       		move.b	(a4)+,d0		; load pitch offset from tracker
00010432 D12D 0008                  		add.b	d0,cPitch(a5)		; add to channel pitch offset
00010436 4E75                       		rts
00010438                            
00010438                            dcsTransp:
00010438 1B5C 0008                  		move.b	(a4)+,cPitch(a5)	; load pitch offset from tracker to channel
0001043C 4E75                       		rts
0001043E                            ; ===========================================================================
0001043E                            ; ---------------------------------------------------------------------------
0001043E                            ; Tracker commands for tempo control
0001043E                            ; ---------------------------------------------------------------------------
0001043E                            
0001043E                            dcsTempoShoes:
0001043E 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
00010440 11C0 C4B9                  		move.b	d0,mTempoSpeed.w	; save as the speed shoes tempo
00010444 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001044A 6600                       		bne.s	dcsTempoCur		; if is, load as current tempo too
0001044C 4E75                       		rts
0001044E                            
0001044E                            dcsTempo:
0001044E 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
00010450 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as the main tempo
00010454 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001045A 6600                       		bne.s	locret_Tempo		; if not, load as current tempo too
0001045C                            
0001045C                            dcsTempoCur:
0001045C 11C0 C4BA                  		move.b	d0,mTempo.w		; save as current tempo
00010460                            
00010460                            locret_Tempo:
00010460 4E75                       		rts
00010462                            
00010462                            dcaTempoShoes:
00010462 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
00010464 D138 C4B9                  		add.b	d0,mTempoSpeed.w	; add to the speed shoes tempo
00010468 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001046E 6600                       		bne.s	dcaTempoCur		; if is, add to current tempo too
00010470 4E75                       		rts
00010472                            
00010472                            dcaTempo:
00010472 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
00010474 D138 C4B8                  		add.b	d0,mTempoMain.w		; add to the main tempo
00010478 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001047E 66E0                       		bne.s	locret_Tempo		; if not, add to current tempo too
00010480                            
00010480                            dcaTempoCur:
00010480 D138 C4BA                  		add.b	d0,mTempo.w		; add to current tempo
00010484 4E75                       		rts
00010486                            ; ===========================================================================
00010486                            ; ---------------------------------------------------------------------------
00010486                            ; Tracker command for enabling or disabling PSG4 noise mode
00010486                            ; ---------------------------------------------------------------------------
00010486                            
00010486                            dcNoisePSG:
00010486 1B54 001B                  		move.b	(a4),cStatPSG4(a5)	; load PSG4 status command from tracker to channel
0001048A 6700                       		beq.s	.psg3			; if disabling PSG4 mode, branch
0001048C 1B7C 00E0 0001             		move.b	#ctPSG4,cType(a5)	; make PSG3 act on behalf of PSG4
00010492 13DC 00C0 0011             		move.b	(a4)+,dPSG		; send command to PSG port
00010498 4E75                       		rts
0001049A                            
0001049A                            .psg3
0001049A 1B7C 00C0 0001             		move.b	#ctPSG3,cType(a5)	; make PSG3 not act on behalf of PSG4
000104A0 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send PSG4 mute command to PSG
000104A8 524C                       		addq.w	#1,a4			; skip param
000104AA 4E75                       		rts
000104AC                            ; ===========================================================================
000104AC                            ; ---------------------------------------------------------------------------
000104AC                            ; Tracker command for playing another music or SFX
000104AC                            ; ---------------------------------------------------------------------------
000104AC                            
000104AC                            dcSound:
000104AC 11DC C4BE                  		move.b	(a4)+,mQueue+2.w	; load sound ID from tracker to sound queue
000104B0                            
000104B0                            Return_dcSound:
000104B0 4E75                       		rts
000104B2                            ; ===========================================================================
000104B2                            ; ---------------------------------------------------------------------------
000104B2                            ; Tracker command for setting DAC filter bank
000104B2                            ; ---------------------------------------------------------------------------
000104B2                            
000104B2                            dcFilter:
000104B2 7000                       		moveq	#0,d0
000104B4 101C                       		move.b	(a4)+,d0		; load filter bank number from tracker
000104B6 4EFA EF40                  		jmp	dSetFilter(pc)		; load filter bank instructions to Z80 RAM
000104BA                            ; ===========================================================================
000104BA                            ; ---------------------------------------------------------------------------
000104BA                            ; Tracker command for writing a YM command to YMCue
000104BA                            ; ---------------------------------------------------------------------------
000104BA                            
000104BA                            dcYM:
000104BA 101C                       		move.b	(a4)+,d0		; load YM address from tracker to d0
000104BC 121C                       		move.b	(a4)+,d1		; get command value from tracker to d1
000104BE 0815 0001                  		btst	#cfbInt,(a5)		; is this channel overridden by SFX?
000104C2 66EC                       		bne.s	Return_dcSound		; if so, skip
000104C4                            
000104C4 0C00 0030                  		cmp.b	#$30,d0			; is this register 00-2F?
000104C8 6500 F408                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
000104CC                            
000104CC 1400                       		move.b	d0,d2			; copy address to d2
000104CE 0402 00A8                  		sub.b	#$A8,d2			; align $A8 with 0
000104D2 0C02 0008                  		cmp.b	#$08,d2			; is this egister A8-AF?
000104D6 6500 F3FA                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
000104DA 4EFA F3EA                  		jmp	WriteChYM(pc)		; write to YM according to channel
000104DE                            ; ===========================================================================
000104DE                            ; ---------------------------------------------------------------------------
000104DE                            ; Tracker command for setting channel base frequency
000104DE                            ; ---------------------------------------------------------------------------
000104DE                            
000104DE                            dcsFreq:
000104DE 1B5C 000E                  		move.b	(a4)+,cFreq(a5)		; load base frequency from tracker to channel
000104E2 1B5C 000F                  		move.b	(a4)+,cFreq+1(a5)	; ''
000104E6                            
000104E6 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
000104EC 6600                       		bne.s	.rts			; if so, brÃ¡nch
000104EE                            		AMPS_Debug_dcInvalid		; this command should be only used with DAC channels
000104EE                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000104EE 487A FFFE                M 	pea	*(pc)
000104F2                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000104F2 40E7                     M 	move.w	sr,-(sp)
000104F4                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000104F4 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000104F4 =00000000                M 	__stack:set	0
000104F4 =00000000                M 	__sp:	set 0
000104F4                          M 	while	(__pos)
000104F4                          M 	rept	__stack
000104F4 4EB9 0000 0000           M 	jsr	errorhandler
000104FA                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000104FA =00000001                M 	__lpos:	set 1
000104FA =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000104FA                          M 	while	(__pos)
000104FA                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000104FA 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
00010513 00                       M 	dc.b	0
00010514 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010516 00                       M 	even
00010516 4EFA CDA0                M 	jmp	amps_debug_console_channel
0001051A                          M 	even
0001051A                            .rts
0001051A 4E75                       		rts
0001051C                            ; ===========================================================================
0001051C                            ; ---------------------------------------------------------------------------
0001051C                            ; Tracker command for setting channel base frequency from the note table
0001051C                            ; ---------------------------------------------------------------------------
0001051C                            
0001051C                            dcsFreqNote:
0001051C 7000                       		moveq	#0,d0
0001051E 101C                       		move.b	(a4)+,d0		; load note from tracker to d0
00010520 D02D 0008                  		add.b	cPitch(a5),d0		; add pitch offset to note
00010524 D040                       		add.w	d0,d0			; double offset (each entry is a word)
00010526                            
00010526 43FA F522                  		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001052A 3B71 0000 000E             		move.w	(a1,d0.w),cFreq(a5)	; load and save the requested frequency
00010530                            
00010530 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
00010536 6600                       		bne.s	.rts			; if so, brÃ¡nch
00010538                            		AMPS_Debug_dcInvalid		; this command should be only used with DAC channels
00010538                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
00010538 487A FFFE                M 	pea	*(pc)
0001053C                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
0001053C 40E7                     M 	move.w	sr,-(sp)
0001053E                          M 	__fstring_generateargumentscode	"Invalid command detected!"
0001053E =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
0001053E =00000000                M 	__stack:set	0
0001053E =00000000                M 	__sp:	set 0
0001053E                          M 	while	(__pos)
0001053E                          M 	rept	__stack
0001053E 4EB9 0000 0000           M 	jsr	errorhandler
00010544                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
00010544 =00000001                M 	__lpos:	set 1
00010544 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010544                          M 	while	(__pos)
00010544                          M 	__substr:	substr __lpos,,"Invalid command detected!"
00010544 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
0001055D 00                       M 	dc.b	0
0001055E 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010560 00                       M 	even
00010560 4EFA CD56                M 	jmp	amps_debug_console_channel
00010564                          M 	even
00010564                            .rts
00010564 4E75                       		rts
00010566                            ; ===========================================================================
00010566                            ; ---------------------------------------------------------------------------
00010566                            ; Tracker command for doing a continous SFX loop
00010566                            ; ---------------------------------------------------------------------------
00010566                            
00010566                            dcCont:
00010566 5338 C4C2                  		subq.b	#1,mContCtr.w		; decrease continous sfx counter
0001056A 6A00                       		bpl.s	dcJump			; if positive, jump to routine
0001056C 4238 C4C3                  		clr.b	mContLast.w		; clear continous SFX ID
00010570 544C                       		addq.w	#2,a4			; skip over jump offset
00010572 4E75                       		rts
00010574                            ; ===========================================================================
00010574                            ; ---------------------------------------------------------------------------
00010574                            ; Tracker command for calling a tracker subroutine
00010574                            ; ---------------------------------------------------------------------------
00010574                            
00010574                            dcCall:
00010574                            		AMPS_Debug_dcCall1		; check if this channel supports the stack
00010574 BAFC C67C                M 	cmp.w	#msfxdac1,a5
00010578 6500                     M 	blo.s	.ok1
0001057A                          M 	raiseerror	"sCall on a SFX channel!",amps_debug_console_channel
0001057A 487A FFFE                M 	pea	*(pc)
0001057E                          M 	raiseerror2	"sCall on a SFX channel!",amps_debug_console_channel
0001057E 40E7                     M 	move.w	sr,-(sp)
00010580                          M 	__fstring_generateargumentscode	"sCall on a SFX channel!"
00010580 =00000000                M 	__pos:	set instr("sCall on a SFX channel!",'%<')
00010580 =00000000                M 	__stack:set	0
00010580 =00000000                M 	__sp:	set 0
00010580                          M 	while	(__pos)
00010580                          M 	rept	__stack
00010580 4EB9 0000 0000           M 	jsr	errorhandler
00010586                          M 	__fstring_generatedecodedstring	"sCall on a SFX channel!"
00010586 =00000001                M 	__lpos:	set 1
00010586 =00000000                M 	__pos:	set instr("sCall on a SFX channel!",'%<')
00010586                          M 	while	(__pos)
00010586                          M 	__substr:	substr __lpos,,"sCall on a SFX channel!"
00010586 7343 616C 6C20 6F6E 2061+M 	dc.b	"sCall on a SFX channel!"
0001059D 00                       M 	dc.b	0
0001059E 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000105A0 00                       M 	even
000105A0 4EFA CD16                M 	jmp	amps_debug_console_channel
000105A4                          M 	even
000105A4                          M .ok1
000105A4                            
000105A4 7000                       		moveq	#0,d0
000105A6 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
000105AA 5900                       		subq.b	#4,d0			; allocate space for another routine
000105AC                            
000105AC                            		AMPS_Debug_dcCall2		; check if we overflowed the space
000105AC 0C00 001C                M 	cmp.b	#cnotetimecur,d0
000105B0 6200                     M 	bhi.s	.ok2
000105B2                          M 	raiseerror	"sCall stack too deep!",amps_debug_console_channel
000105B2 487A FFFE                M 	pea	*(pc)
000105B6                          M 	raiseerror2	"sCall stack too deep!",amps_debug_console_channel
000105B6 40E7                     M 	move.w	sr,-(sp)
000105B8                          M 	__fstring_generateargumentscode	"sCall stack too deep!"
000105B8 =00000000                M 	__pos:	set instr("sCall stack too deep!",'%<')
000105B8 =00000000                M 	__stack:set	0
000105B8 =00000000                M 	__sp:	set 0
000105B8                          M 	while	(__pos)
000105B8                          M 	rept	__stack
000105B8 4EB9 0000 0000           M 	jsr	errorhandler
000105BE                          M 	__fstring_generatedecodedstring	"sCall stack too deep!"
000105BE =00000001                M 	__lpos:	set 1
000105BE =00000000                M 	__pos:	set instr("sCall stack too deep!",'%<')
000105BE                          M 	while	(__pos)
000105BE                          M 	__substr:	substr __lpos,,"sCall stack too deep!"
000105BE 7343 616C 6C20 7374 6163+M 	dc.b	"sCall stack too deep!"
000105D3 00                       M 	dc.b	0
000105D4 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000105D6 00                       M 	even
000105D6 4EFA CCE0                M 	jmp	amps_debug_console_channel
000105DA                          M 	even
000105DA                          M .ok2
000105DA 2B8C 0000                  		move.l	a4,(a5,d0.w)		; save current address in stack
000105DE 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
000105E2                            ; ===========================================================================
000105E2                            ; ---------------------------------------------------------------------------
000105E2                            ; Tracker command for jumping to another tracker location
000105E2                            ; ---------------------------------------------------------------------------
000105E2                            
000105E2                            dcJump:
000105E2                            	dREAD_WORD a4, d0			; read a word from tracker to d0
000105E2 1E9C                     M 	move.b	(a4)+,(sp)
000105E4 3017                     M 	move.w	(sp),d0
000105E6 1014                     M 	move.b	(a4),d0
000105E8 D8C0                       		adda.w	d0,a4			; offset tracker address by d0
000105EA 4E75                       		rts
000105EC                            ; ===========================================================================
000105EC                            ; ---------------------------------------------------------------------------
000105EC                            ; Tracker command for handling loops
000105EC                            ; ---------------------------------------------------------------------------
000105EC                            
000105EC                            dcLoop:
000105EC 7000                       		moveq	#0,d0
000105EE 101C                       		move.b	(a4)+,d0		; load loop index from tracker to d0
000105F0                            		AMPS_Debug_dcLoop		; check if loop index is valid
000105F0 0C00 0003                M 	cmp.b	#3,d0
000105F4 6200                     M 	bhi.s	.fail
000105F6 BAFC C67C                M 	cmp.w	#msfxdac1,a5
000105FA 6500                     M 	blo.s	.nosfx
000105FC 0C00 0001                M 	cmp.b	#1,d0
00010600 6700                     M 	beq.s	.fail
00010602                          M .nosfx
00010602 0C2D 00C0 0001           M 	cmp.b	#$c0,ctype(a5)
00010608 6500                     M 	blo.s	amps_debug_dcloop_ok
0001060A 0C00 0002                M 	cmp.b	#2,d0
0001060E 6600                     M 	bne.s	amps_debug_dcloop_ok
00010610                          M .fail
00010610                          M 	raiseerror	"sLoop ID is invalid!",amps_debug_console_channel
00010610 487A FFFE                M 	pea	*(pc)
00010614                          M 	raiseerror2	"sLoop ID is invalid!",amps_debug_console_channel
00010614 40E7                     M 	move.w	sr,-(sp)
00010616                          M 	__fstring_generateargumentscode	"sLoop ID is invalid!"
00010616 =00000000                M 	__pos:	set instr("sLoop ID is invalid!",'%<')
00010616 =00000000                M 	__stack:set	0
00010616 =00000000                M 	__sp:	set 0
00010616                          M 	while	(__pos)
00010616                          M 	rept	__stack
00010616 4EB9 0000 0000           M 	jsr	errorhandler
0001061C                          M 	__fstring_generatedecodedstring	"sLoop ID is invalid!"
0001061C =00000001                M 	__lpos:	set 1
0001061C =00000000                M 	__pos:	set instr("sLoop ID is invalid!",'%<')
0001061C                          M 	while	(__pos)
0001061C                          M 	__substr:	substr __lpos,,"sLoop ID is invalid!"
0001061C 734C 6F6F 7020 4944 2069+M 	dc.b	"sLoop ID is invalid!"
00010630 00                       M 	dc.b	0
00010631 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010632                          M 	even
00010632 4EFA CC84                M 	jmp	amps_debug_console_channel
00010636                          M 	even
00010636                          M amps_debug_dcloop_ok
00010636                            
00010636 4A35 0019                  		tst.b	cLoop(a5,d0.w)		; check the loop counter
0001063A 6600                       		bne.s	.loopok			; if nonzero, branch
0001063C 1BAC 0002 0019             		move.b	2(a4),cLoop(a5,d0.w)	; reload loop counter
00010642                            
00010642                            .loopok
00010642 5335 0019                  		subq.b	#1,cLoop(a5,d0.w)	; decrease loop counter
00010646 669A                       		bne.s	dcJump			; if not 0, jump to routine
00010648 564C                       		addq.w	#3,a4			; skip over jump offset
0001064A 4E75                       		rts
0001064C                            ; ===========================================================================
0001064C                            ; ---------------------------------------------------------------------------
0001064C                            ; Tracker command for initializing modulation
0001064C                            ; ---------------------------------------------------------------------------
0001064C                            
0001064C                            dcMod68K:
0001064C 2B4C 0010                  		move.l	a4,cMod(a5)		; set modulation data address
00010650 1B5C 0010                  		move.b	(a4)+,cModDelay(a5)	; load modulation delay from tracker to channel
00010654 1B5C 0016                  		move.b	(a4)+,cModSpeed(a5)	; load modulation speed from tracker to channel
00010658 1B5C 0017                  		move.b	(a4)+,cModStep(a5)	; load modulation step offset from tracker to channel
0001065C                            
0001065C 101C                       		move.b	(a4)+,d0		; load modulation step count from tracker to d0
0001065E E208                       		lsr.b	#1,d0			; halve it
00010660 1B40 0018                  		move.b	d0,cModCount(a5)	; save as modulation step count to channel
00010664 426D 0014                  		clr.w	cModFreq(a5)		; reset modulation frequency offset to 0
00010668                            	; continue to enabling modulation
00010668                            ; ===========================================================================
00010668                            ; ---------------------------------------------------------------------------
00010668                            ; Tracker commands for enabling and disabling modulation
00010668                            ; ---------------------------------------------------------------------------
00010668                            
00010668                            dcModOn:
00010668 08D5 0003                  		bset	#cfbMod,(a5)		; enable modulation
0001066C 4E75                       		rts
0001066E                            
0001066E                            dcModOff:
0001066E 0895 0003                  		bclr	#cfbMod,(a5)		; disable modulation
00010672 4E75                       		rts
00010674                            ; ===========================================================================
00010674                            ; ---------------------------------------------------------------------------
00010674                            ; Tracker command for returning from tracker subroutine
00010674                            ; ---------------------------------------------------------------------------
00010674                            
00010674                            dcReturn:
00010674                            		AMPS_Debug_dcReturn1		; check if this channel supports the stack
00010674 BAFC C67C                M 	cmp.w	#msfxdac1,a5
00010678 6500                     M 	blo.s	.ok1
0001067A                          M 	raiseerror	"sRet on a SFX channel!",amps_debug_console_channel
0001067A 487A FFFE                M 	pea	*(pc)
0001067E                          M 	raiseerror2	"sRet on a SFX channel!",amps_debug_console_channel
0001067E 40E7                     M 	move.w	sr,-(sp)
00010680                          M 	__fstring_generateargumentscode	"sRet on a SFX channel!"
00010680 =00000000                M 	__pos:	set instr("sRet on a SFX channel!",'%<')
00010680 =00000000                M 	__stack:set	0
00010680 =00000000                M 	__sp:	set 0
00010680                          M 	while	(__pos)
00010680                          M 	rept	__stack
00010680 4EB9 0000 0000           M 	jsr	errorhandler
00010686                          M 	__fstring_generatedecodedstring	"sRet on a SFX channel!"
00010686 =00000001                M 	__lpos:	set 1
00010686 =00000000                M 	__pos:	set instr("sRet on a SFX channel!",'%<')
00010686                          M 	while	(__pos)
00010686                          M 	__substr:	substr __lpos,,"sRet on a SFX channel!"
00010686 7352 6574 206F 6E20 6120+M 	dc.b	"sRet on a SFX channel!"
0001069C 00                       M 	dc.b	0
0001069D 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001069E                          M 	even
0001069E 4EFA CC18                M 	jmp	amps_debug_console_channel
000106A2                          M 	even
000106A2                          M .ok1
000106A2 7000                       		moveq	#0,d0
000106A4 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
000106A8 2875 0000                  		movea.l	(a5,d0.w),a4		; load the address to return to
000106AC                            
000106AC 544C                       		addq.w	#2,a4			; skip the call address parameter
000106AE 5800                       		addq.b	#4,d0			; deallocate stack space
000106B0 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
000106B4                            
000106B4                            		AMPS_Debug_dcReturn2		; check if we underflowed the space
000106B4 0C00 002C                M 	cmp.b	#csize,d0
000106B8 6300                     M 	bls.s	.ok2
000106BA                          M 	raiseerror	"sRet stack too shallow!",amps_debug_console_channel
000106BA 487A FFFE                M 	pea	*(pc)
000106BE                          M 	raiseerror2	"sRet stack too shallow!",amps_debug_console_channel
000106BE 40E7                     M 	move.w	sr,-(sp)
000106C0                          M 	__fstring_generateargumentscode	"sRet stack too shallow!"
000106C0 =00000000                M 	__pos:	set instr("sRet stack too shallow!",'%<')
000106C0 =00000000                M 	__stack:set	0
000106C0 =00000000                M 	__sp:	set 0
000106C0                          M 	while	(__pos)
000106C0                          M 	rept	__stack
000106C0 4EB9 0000 0000           M 	jsr	errorhandler
000106C6                          M 	__fstring_generatedecodedstring	"sRet stack too shallow!"
000106C6 =00000001                M 	__lpos:	set 1
000106C6 =00000000                M 	__pos:	set instr("sRet stack too shallow!",'%<')
000106C6                          M 	while	(__pos)
000106C6                          M 	__substr:	substr __lpos,,"sRet stack too shallow!"
000106C6 7352 6574 2073 7461 636B+M 	dc.b	"sRet stack too shallow!"
000106DD 00                       M 	dc.b	0
000106DE 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000106E0 00                       M 	even
000106E0 4EFA CBD6                M 	jmp	amps_debug_console_channel
000106E4                          M 	even
000106E4                          M .ok2
000106E4 4E75                       		rts
000106E6                            ; ===========================================================================
000106E6                            ; ---------------------------------------------------------------------------
000106E6                            ; Tracker command for initializing special FM3 mode
000106E6                            ; ---------------------------------------------------------------------------
000106E6                            
000106E6                            dcSpecFM3:
000106E6                            		AMPS_Debug_dcInvalid		; this is an invalid command
000106E6                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000106E6 487A FFFE                M 	pea	*(pc)
000106EA                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000106EA 40E7                     M 	move.w	sr,-(sp)
000106EC                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000106EC =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000106EC =00000000                M 	__stack:set	0
000106EC =00000000                M 	__sp:	set 0
000106EC                          M 	while	(__pos)
000106EC                          M 	rept	__stack
000106EC 4EB9 0000 0000           M 	jsr	errorhandler
000106F2                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000106F2 =00000001                M 	__lpos:	set 1
000106F2 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000106F2                          M 	while	(__pos)
000106F2                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000106F2 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
0001070B 00                       M 	dc.b	0
0001070C 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001070E 00                       M 	even
0001070E 4EFA CBA8                M 	jmp	amps_debug_console_channel
00010712                          M 	even
00010712 4E75                       		rts
00010714                            ; ===========================================================================
00010714                            ; ---------------------------------------------------------------------------
00010714                            ; Tracker command for enabling raw frequency mode
00010714                            ; ---------------------------------------------------------------------------
00010714                            
00010714                            dcFreqOn:
00010714                            		AMPS_Debug_dcInvalid		; this is an invalid command
00010714                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
00010714 487A FFFE                M 	pea	*(pc)
00010718                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
00010718 40E7                     M 	move.w	sr,-(sp)
0001071A                          M 	__fstring_generateargumentscode	"Invalid command detected!"
0001071A =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
0001071A =00000000                M 	__stack:set	0
0001071A =00000000                M 	__sp:	set 0
0001071A                          M 	while	(__pos)
0001071A                          M 	rept	__stack
0001071A 4EB9 0000 0000           M 	jsr	errorhandler
00010720                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
00010720 =00000001                M 	__lpos:	set 1
00010720 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010720                          M 	while	(__pos)
00010720                          M 	__substr:	substr __lpos,,"Invalid command detected!"
00010720 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
00010739 00                       M 	dc.b	0
0001073A 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001073C 00                       M 	even
0001073C 4EFA CB7A                M 	jmp	amps_debug_console_channel
00010740                          M 	even
00010740 4E75                       		rts
00010742                            ; ===========================================================================
00010742                            ; ---------------------------------------------------------------------------
00010742                            ; Tracker command for disabling raw frequency mode
00010742                            ; ---------------------------------------------------------------------------
00010742                            
00010742                            dcFreqOff:
00010742                            		AMPS_Debug_dcInvalid		; this is an invalid command
00010742                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
00010742 487A FFFE                M 	pea	*(pc)
00010746                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
00010746 40E7                     M 	move.w	sr,-(sp)
00010748                          M 	__fstring_generateargumentscode	"Invalid command detected!"
00010748 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010748 =00000000                M 	__stack:set	0
00010748 =00000000                M 	__sp:	set 0
00010748                          M 	while	(__pos)
00010748                          M 	rept	__stack
00010748 4EB9 0000 0000           M 	jsr	errorhandler
0001074E                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
0001074E =00000001                M 	__lpos:	set 1
0001074E =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
0001074E                          M 	while	(__pos)
0001074E                          M 	__substr:	substr __lpos,,"Invalid command detected!"
0001074E 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
00010767 00                       M 	dc.b	0
00010768 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001076A 00                       M 	even
0001076A 4EFA CB4C                M 	jmp	amps_debug_console_channel
0001076E                          M 	even
0001076E                            
0001076E                            locret_FreqOff:
0001076E 4E75                       		rts
00010770                            ; ===========================================================================
00010770                            ; ---------------------------------------------------------------------------
00010770                            ; Tracker command for changing voice, volume envelope or sample
00010770                            ; ---------------------------------------------------------------------------
00010770                            
00010770                            dcVoice:
00010770 7000                       		moveq	#0,d0
00010772 101C                       		move.b	(a4)+,d0		; load voice/sample/volume envelope from tracker to d0
00010774 1B40 000B                  		move.b	d0,cVoice(a5)		; save to channel
00010778                            
00010778 4A2D 0001                  		tst.b	cType(a5)		; check if this is a PSG channel
0001077C 6BF0                       		bmi.s	locret_FreqOff		; if is, skip
0001077E 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
00010784 66E8                       		bne.s	locret_FreqOff		; if is, skip
00010786                            
00010786 0815 0001                  		btst	#cfbInt,(a5)		; check if channel is interrupted by SFX
0001078A 66E2                       		bne.s	locret_FreqOff		; if is, skip
0001078C 224E                       		move.l	a6,a1			; load voice table to a1
0001078E                            	; continue to send FM voice
0001078E                            ; ===========================================================================
0001078E                            ; ---------------------------------------------------------------------------
0001078E                            ; Subroutine for sending the FM voice to YM2612
0001078E                            ; This routine is speed optimized in a way that allows Dual PCM
0001078E                            ; to only be stopped for as long as it must be. This will waste
0001078E                            ; some cycles for 68000, but it will help improve DAC quality.
0001078E                            ; ---------------------------------------------------------------------------
0001078E                            
0001078E                            dUpdateVoiceFM:
0001078E                            	dCALC_VOICE				; get address of the specific voice to a1
0001078E EB48                     M 	lsl.w	#5,d0
00010790 D2C0                     M 	add.w	d0,a1
00010792 9EFC 003C                  		sub.w	#(VoiceRegs+1)*2,sp	; prepapre space in the stack
00010796 264F                       		move.l	sp,a3			; copy pointer to the free space to a3
00010798                            
00010798 1819                       		move.b	(a1)+,d4		; load feedback and algorithm to d4
0001079A 16C4                       		move.b	d4,(a3)+		; save it to free space
0001079C 16FC 00B0                  		move.b	#$B0,(a3)+		; YM command: Algorithm & FeedBack
000107A0                            
000107A0 45FA ED86                  		lea	dOpListYM(pc),a2	; load YM2612 operator list into a2
000107A4                            	rept VoiceRegs-5
000107A4                            		move.b	(a1)+,(a3)+		; copy each value (except Total Level)
000107A4                            		move.b	(a2)+,(a3)+		; copy each command
000107A4                            	endr
000107A4 16D9                     M 	move.b	(a1)+,(a3)+
000107A6 16DA                     M 	move.b	(a2)+,(a3)+
000107A8 16D9                     M 	move.b	(a1)+,(a3)+
000107AA 16DA                     M 	move.b	(a2)+,(a3)+
000107AC 16D9                     M 	move.b	(a1)+,(a3)+
000107AE 16DA                     M 	move.b	(a2)+,(a3)+
000107B0 16D9                     M 	move.b	(a1)+,(a3)+
000107B2 16DA                     M 	move.b	(a2)+,(a3)+
000107B4 16D9                     M 	move.b	(a1)+,(a3)+
000107B6 16DA                     M 	move.b	(a2)+,(a3)+
000107B8 16D9                     M 	move.b	(a1)+,(a3)+
000107BA 16DA                     M 	move.b	(a2)+,(a3)+
000107BC 16D9                     M 	move.b	(a1)+,(a3)+
000107BE 16DA                     M 	move.b	(a2)+,(a3)+
000107C0 16D9                     M 	move.b	(a1)+,(a3)+
000107C2 16DA                     M 	move.b	(a2)+,(a3)+
000107C4 16D9                     M 	move.b	(a1)+,(a3)+
000107C6 16DA                     M 	move.b	(a2)+,(a3)+
000107C8 16D9                     M 	move.b	(a1)+,(a3)+
000107CA 16DA                     M 	move.b	(a2)+,(a3)+
000107CC 16D9                     M 	move.b	(a1)+,(a3)+
000107CE 16DA                     M 	move.b	(a2)+,(a3)+
000107D0 16D9                     M 	move.b	(a1)+,(a3)+
000107D2 16DA                     M 	move.b	(a2)+,(a3)+
000107D4 16D9                     M 	move.b	(a1)+,(a3)+
000107D6 16DA                     M 	move.b	(a2)+,(a3)+
000107D8 16D9                     M 	move.b	(a1)+,(a3)+
000107DA 16DA                     M 	move.b	(a2)+,(a3)+
000107DC 16D9                     M 	move.b	(a1)+,(a3)+
000107DE 16DA                     M 	move.b	(a2)+,(a3)+
000107E0 16D9                     M 	move.b	(a1)+,(a3)+
000107E2 16DA                     M 	move.b	(a2)+,(a3)+
000107E4 16D9                     M 	move.b	(a1)+,(a3)+
000107E6 16DA                     M 	move.b	(a2)+,(a3)+
000107E8 16D9                     M 	move.b	(a1)+,(a3)+
000107EA 16DA                     M 	move.b	(a2)+,(a3)+
000107EC 16D9                     M 	move.b	(a1)+,(a3)+
000107EE 16DA                     M 	move.b	(a2)+,(a3)+
000107F0 16D9                     M 	move.b	(a1)+,(a3)+
000107F2 16DA                     M 	move.b	(a2)+,(a3)+
000107F4 16D9                     M 	move.b	(a1)+,(a3)+
000107F6 16DA                     M 	move.b	(a2)+,(a3)+
000107F8 16D9                     M 	move.b	(a1)+,(a3)+
000107FA 16DA                     M 	move.b	(a2)+,(a3)+
000107FC 16D9                     M 	move.b	(a1)+,(a3)+
000107FE 16DA                     M 	move.b	(a2)+,(a3)+
00010800 16D9                     M 	move.b	(a1)+,(a3)+
00010802 16DA                     M 	move.b	(a2)+,(a3)+
00010804                            
00010804 7C00                       		moveq	#0,d6			; reset the modulator offset
00010806 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001080A D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001080E 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
00010810 767F                       		moveq	#$7F,d3			; force FM volume to silence
00010812                            
00010812                            .noover
00010812 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
00010818 6700                       		beq.s	.uwdone			; if not, skip
0001081A 1C04                       		move.b	d4,d6			; copy algorithm and feedback to d6
0001081C 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
00010820 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
00010822 1C04                       		move.b	d4,d6			; set algorithm and feedback to modulator offset
00010824                            
00010824                            .uwdone
00010824 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
00010826                            
00010826                            .tlloop
00010826 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
00010828 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001082A                            
0001082A D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001082C 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001082E 727F                       		moveq	#$7F,d1			; cap to silent volume
00010830 6000                       		bra.s	.slot
00010832                            
00010832                            .noslot
00010832 D206                       		add.b	d6,d1			; add modulator offset to loaded value
00010834                            .slot
00010834 16C1                       		move.b	d1,(a3)+		; save the Total Level value
00010836 16DA                       		move.b	(a2)+,(a3)+		; copy total level command
00010838 51CD FFEC                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001083C                            
0001083C                            		AMPS_Debug_UpdVoiceFM		; check if the voice was valid
0001083C 0C19 004E                M 	cmp.b	#'N',(a1)+
00010840 6600                     M 	bne.s	.fail
00010842 0C59 4154                M 	cmp.w	#'AT',(a1)+
00010846 6700                     M 	beq.s	.ok
00010848                          M .fail
00010848                          M 	raiseerror	"FM voice Update invalid voice: %<.b cVoice(a5)>",amps_debug_console_channel
00010848 487A FFFE                M 	pea	*(pc)
0001084C                          M 	raiseerror2	"FM voice Update invalid voice: %<.b cVoice(a5)>",amps_debug_console_channel
0001084C 40E7                     M 	move.w	sr,-(sp)
0001084E                          M 	__fstring_generateargumentscode	"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001084E =00000020                M 	__pos:	set instr("FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
0001084E =00000000                M 	__stack:set	0
0001084E =00000000                M 	__sp:	set 0
0001084E                          M 	while	(__pos)
0001084E =0000002F                M 	__endpos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'>')
0001084E =00000000                M 	__midpos:	set instr(__pos+5,"FM voice Update invalid voice: %<.b cVoice(a5)>",' ')
0001084E =0000002F                M 	__midpos:	= __endpos
0001084E                          M 	__substr:	substr __pos+1+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001084E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001084E                          M 	__operand:	substr __pos+1+1,__midpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001084E                          M 	__param:	substr __midpos+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001084E                          M 	pushp	"move.b cVoice(a5),1(sp)"
0001084E                          M 	pushp	"subq.w	#2, sp"
0001084E =00000002                M 	__stack:	= __stack+2
0001084E =00000002                M 	__sp:	= __sp+2
0001084E =00000000                M 	__pos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
0001084E                          M 	rept	__stack
0001084E                          M 	popp	__command
0001084E 554F                     M 	subq.w	#2,sp
00010850                          M 	popp	__command
00010850 1F6D 000B 0001           M 	move.b	cvoice(a5),1(sp)
00010856 4EB9 0000 0000           M 	jsr	errorhandler
0001085C                          M 	__fstring_generatedecodedstring	"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001085C =00000001                M 	__lpos:	set 1
0001085C =00000020                M 	__pos:	set instr("FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
0001085C                          M 	while	(__pos)
0001085C                          M 	__substr:	substr __lpos,__pos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001085C 464D 2076 6F69 6365 2055+M 	dc.b	"FM voice Update invalid voice: "
0001087B =0000002F                M 	__endpos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'>')
0001087B =00000000                M 	__midpos:	set instr(__pos+5,"FM voice Update invalid voice: %<.b cVoice(a5)>",' ')
0001087B =0000002F                M 	__midpos:	= __endpos
0001087B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001087B                          M 	__param:	substr __midpos+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001087B                          M 	__param:	substr ,,"hex"
0001087B 80                       M 	dc.b	hex
0001087C =00000030                M 	__lpos:	set __endpos+1
0001087C =00000000                M 	__pos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
0001087C                          M 	__substr:	substr __lpos,,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001087C                          M 	dc.b	""
0001087C 00                       M 	dc.b	0
0001087D 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001087E                          M 	even
0001087E 4EFA CA38                M 	jmp	amps_debug_console_channel
00010882                          M 	even
00010882                          M .ok
00010882                            
00010882 0895 0005                  		bclr	#cfbVol,(a5)		; reset volume update request flag
00010886 16ED 0006                  		move.b	cPanning(a5),(a3)+	; copy panning value to free space
0001088A 16FC 00B4                  		move.b	#$B4,(a3)+		; YM command: Panning & LFO
0001088E                            
0001088E 7400                       		moveq	#0,d2			; prepare part 1 value
00010890 162D 0001                  		move.b	cType(a5),d3		; load FM channel type to d3
00010894 0803 0002                  		btst	#ctbPt2,d3		; check if its part 1
00010898 6700                       		beq.s	.ptok			; if so, branch
0001089A 0203 0003                  		and.b	#3,d3			; get channel offset only
0001089E 7402                       		moveq	#2,d2			; prepare part 2 value
000108A0                            
000108A0                            .ptok
000108A0 264F                       		move.l	sp,a3			; copy free space pointer to a3 again
000108A2 721D                       		moveq	#VoiceRegs,d1		; prepare loop point
000108A4                            		AMPS_Debug_CuePtr 0		; make sure cue is valid
000108A4 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
000108AA 6500                     M 	blo.s	.fail_752
000108AC B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
000108B2 6500                     M 	blo.s	.ok_752
000108B4                          M .fail_752
000108B4 4EBA D782                M 	jsr	amps_debug_cueptr0
000108B8                          M .ok_752
000108B8                            	StopZ80					; wait for Z80 to stop
000108B8 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
000108C0                          M 	waitz80stop
000108C0 0839 0000 00A1 1100      M .wait_754:	btst	#0,z80_bus_req
000108C8 66F6                     M 	bne.s	.wait_754
000108CA                            
000108CA                            .write
000108CA 10C2                       		move.b	d2,(a0)+		; select YM port to access (4000 or 4002)
000108CC 10DB                       		move.b	(a3)+,(a0)+		; write command values
000108CE                            
000108CE 101B                       		move.b	(a3)+,d0		; load YM command
000108D0 8003                       		or.b	d3,d0			; add the channel offset to command
000108D2 10C0                       		move.b	d0,(a0)+		; save to Z80 cue
000108D4 51C9 FFF4                  		dbf	d1,.write		; write all registers
000108D8 50D0                       		st	(a0)			; mark as end of the cue
000108DA                            
000108DA                            	StartZ80				; enable Z80 execution
000108DA 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
000108E2 DEFC 003C                  		add.w	#(VoiceRegs+1)*2,sp	; reset stack pointer
000108E6 4E75                       		rts
000108E8                            ; ===========================================================================
000108E8                            ; ---------------------------------------------------------------------------
000108E8                            ; Tracker command for stopping the current channel
000108E8                            ; ---------------------------------------------------------------------------
000108E8                            
000108E8                            dcStop:
000108E8 0215 007B                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRun),(a5); clear hold and running tracker flags
000108EC 4A2D 0001                  		tst.b	cType(a5)		; check if this was a PSG channel
000108F0 6B00                       		bmi.s	.mutePSG		; if yes, mute it
000108F2                            
000108F2 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this was a DAC channel
000108F8 6600                       		bne.s	.cont			; if we are, skip
000108FA 4EBA EFB0                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
000108FE 6000                       		bra.s	.cont
00010900                            ; ---------------------------------------------------------------------------
00010900                            
00010900                            .mutePSG
00010900 4EBA F87C                  		jsr	dMutePSGmus(pc)		; mute PSG channel
00010904                            
00010904                            .cont
00010904 BAFC C698                  		cmpa.w	#mSFXFM3,a5		; check if this is a SFX channel
00010908 6500                       		blo.s	.exit			; if not, skip all this mess
0001090A 422D 001A                  		clr.b	cPrio(a5)		; clear channel priority
0001090E                            
0001090E 43FA E7F2                  		lea	dSFXoverList(pc),a1	; load quick reference to the SFX override list to a1
00010912 7600                       		moveq	#0,d3
00010914 162D 0001                  		move.b	cType(a5),d3		; load channel type to d3
00010918 6B00                       		bmi.s	.psg			; if this is a PSG channel, branch
0001091A 3F0D                       		move.w	a5,-(sp)		; push channel pointer
0001091C                            
0001091C 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
00010920 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
00010922 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
00010924 3A71 3000                  		move.w	(a1,d3.w),a5		; get the SFX channel we were overriding
00010928                            
00010928                            .dacdone
00010928 4A15                       		tst.b	(a5)			; check if that channel is running a tracker
0001092A 6A00                       		bpl.s	.fixch			; if not, branch
0001092C                            
0001092C 08D5 0005                  		bset	#cfbVol,(a5)		; set update volume flag (cleared by dUpdateVoiceFM)
00010930 0895 0001                  		bclr	#cfbInt,(a5)		; reset sfx override flag
00010934 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if the channel is a DAC channel
0001093A 6600                       		bne.s	.fixch			; if yes, skip
0001093C                            
0001093C 08D5 0000                  		bset	#cfbRest,(a5)		; Set channel resting flag
00010940 43FA 0000                  		lea	VoiceBankMusic(pc),a1	; load music voice table to a1
00010944 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
00010948 4EBA FE44                  		jsr	dUpdateVoiceFM(pc)	; send FM voice for this channel
0001094C                            
0001094C                            .fixch
0001094C 3A5F                       		move.w	(sp)+,a5		; pop the current channel
0001094E                            .exit
0001094E 5497                       		addq.l	#2,(sp)			; go to next channel immediately
00010950 4E75                       		rts
00010952                            ; ---------------------------------------------------------------------------
00010952                            ; There is nothing that would break even if the channel is not
00010952                            ; running a tracker, so we do not bother checking
00010952                            ; ---------------------------------------------------------------------------
00010952                            
00010952                            .psg
00010952 E80B                       		lsr.b	#4,d3			; make it easier to reference the right offset in the table
00010954 3271 3000                  		movea.w	(a1,d3.w),a1		; get the SFX channel we were overriding
00010958 0891 0001                  		bclr	#cfbInt,(a1)		; channel is not interrupted anymore
0001095C 08D1 0000                  		bset	#cfbRest,(a1)		; reset sfx override flag
00010960                            
00010960 0C29 00E0 0001             		cmp.b	#ctPSG4,cType(a1)	; check if this channel is in PSG4 mode
00010966 66E6                       		bne.s	.exit			; if not, skip
00010968 13E9 001B 00C0 0011        		move.b	cStatPSG4(a1),dPSG	; update PSG4 status to PSG port
00010970 60DC                       		bra.s	.exit
00010972                            ; ===========================================================================
00010972                            ; ---------------------------------------------------------------------------
00010972                            ; Tracker command for enabling LFO
00010972                            ; ---------------------------------------------------------------------------
00010972                            
00010972                            dcsLFO:
00010972 7000                       		moveq	#0,d0
00010974 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
00010978 224E                       		move.l	a6,a1			; load voice table to a1
0001097A                            
0001097A                            	dCALC_VOICE 9				; get address of the specific voice to a1
0001097A EB48                     M 	lsl.w	#5,d0
0001097C 0640 0009                M 	add.w	#9,d0
00010980 D2C0                     M 	add.w	d0,a1
00010982 1614                       		move.b	(a4),d3			; load LFO enable operators to d3
00010984 45FA EBAA                  		lea	dAMSEn_Ops(pc),a2	; load Decay 1 Rate address table to a2
00010988 7C03                       		moveq	#4-1,d6			; prepare 4 operators to d5
0001098A                            
0001098A                            .decayloop
0001098A 1219                       		move.b	(a1)+,d1		; get Decay 1 Level value from voice to d1
0001098C 101A                       		move.b	(a2)+,d0		; load YM address to write to d0
0001098E                            
0001098E D603                       		add.b	d3,d3			; check if LFO is enabled for this channeÃ¶
00010990 6400                       		bcc.s	.noLFO			; if not, skip
00010992 0001 0080                  		or.b	#$80,d1			; set enable LFO bit
00010996 4EBA EF2E                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001099A                            
0001099A                            .noLFO
0001099A 51CE FFEE                  		dbf	d6,.decayloop		; repeat for each Decay 1 Level operator
0001099E                            
0001099E 121C                       		move.b	(a4)+,d1		; load LFO frequency value from tracker
000109A0 7022                       		moveq	#$22,d0			; YM command: LFO
000109A2 4EBA EF2E                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
000109A6                            
000109A6 121C                       		move.b	(a4)+,d1		; load AMS, FMS & Panning from tracker
000109A8 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel panning
000109AC                            
000109AC 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
000109AE 4EFA EF10                  		jmp	dWriteYMchnInt(pc)	; write to YM according to channel
000109B2                            ; ===========================================================================
000109B2                            ; ---------------------------------------------------------------------------
000109B2                            ; Tracker command for resetting condition
000109B2                            ; ---------------------------------------------------------------------------
000109B2                            
000109B2                            dcResetCond:
000109B2 0895 0004                  		bclr	#cfbCond,(a5)		; reset condition flag
000109B6 4E75                       		rts
000109B8                            ; ===========================================================================
000109B8                            ; ---------------------------------------------------------------------------
000109B8                            ; Tracker command for writing to communications flags
000109B8                            ; ---------------------------------------------------------------------------
000109B8                            
000109B8                            dcsComm:
000109B8 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
000109BC 7000                       		moveq	#0,d0
000109BE 101C                       		move.b	(a4)+,d0		; load byte number to write from tracker
000109C0 139C 0000                  		move.b	(a4)+,(a1,d0.w)		; load vaue from tracker to communications byte
000109C4 4E75                       		rts
000109C6                            ; ===========================================================================
000109C6                            ; ---------------------------------------------------------------------------
000109C6                            ; RAM addresses for special condition code
000109C6                            ; ---------------------------------------------------------------------------
000109C6                            
000109C6                            dcCondRegTable:
000109C6 C746 C4A6                  	dc.w hwVersion, mFlags	; 0
000109CA C4B8 C4B9                  	dc.w mTempoMain, mTempoSpeed	; 2
000109CE 0000 0000                  	dc.w 0, 0			; 4
000109D2 0000 0000                  	dc.w 0, 0			; 6
000109D6 0000 0000                  	dc.w 0, 0			; 8
000109DA 0000 0000                  	dc.w 0, 0			; $A
000109DE 0000 0000                  	dc.w 0, 0			; $C
000109E2 0000 0001                  	dc.w 0, cType			; $E
000109E6                            ; ===========================================================================
000109E6                            ; ---------------------------------------------------------------------------
000109E6                            ; Tracker command for checking special RAM addresses
000109E6                            ; ---------------------------------------------------------------------------
000109E6                            
000109E6                            dcCondReg:
000109E6 101C                       		move.b	(a4)+,d0		; get value from tracker
000109E8 1200                       		move.b	d0,d1			; copy to d1
000109EA                            
000109EA 0240 000F                  		and.w	#$F,d0			; get RAM table offset to d0
000109EE D040                       		add.w	d0,d0			; double it (each entry is 1 word)
000109F0 303B 00D4                  		move.w	dcCondRegTable(pc,d0.w),d0; get data to read from
000109F4 6B00                       		bmi.s	.gotit			; branch if if was a RAM address
000109F6 D04D                       		add.w	a5,d0			; else it was a channel offset
000109F8                            
000109F8                            .gotit
000109F8 3240                       		move.w	d0,a1			; get the desired address from d0 to a1
000109FA 1011                       		move.b	(a1),d0			; read byte from it
000109FC 6000                       		bra.s	dcCondCom
000109FE                            ; ===========================================================================
000109FE                            ; ---------------------------------------------------------------------------
000109FE                            ; Tracker command for checking communications bytes
000109FE                            ; ---------------------------------------------------------------------------
000109FE                            
000109FE                            dcCond:
000109FE 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
00010A02 101C                       		move.b	(a4)+,d0		; load condition and offset from tracker to d0
00010A04 1200                       		move.b	d0,d1			; copy to d1
00010A06 0240 000F                  		and.w	#$F,d0			; get offset only
00010A0A 1031 0000                  		move.b	(a1,d0.w),d0		; load value from communcations byte to d0
00010A0E                            
00010A0E                            dcCondCom:
00010A0E 0895 0004                  		bclr	#cfbCond,(a5)		; set condition to true
00010A12 0241 00F0                  		and.w	#$F0,d1			; get condition value only
00010A16 E449                       		lsr.w	#2,d1			; shift 2 bits down (each entry is 4 bytes large)
00010A18 B01C                       		cmp.b	(a4)+,d0		; check value against tracker byte
00010A1A 4EFB 1000                  		jmp	.cond(pc,d1.w)		; handle conditional code
00010A1E                            ; ===========================================================================
00010A1E                            ; ---------------------------------------------------------------------------
00010A1E                            ; Code for setting the condition flag
00010A1E                            ; ---------------------------------------------------------------------------
00010A1E                            
00010A1E                            .c	macro x
00010A1E                            	\x	.false
00010A1E                            	rts
00010A1E                                 endm
00010A1E                            
00010A1E                            .false
00010A1E 08D5 0004                  		bset	#cfbCond,(a5)		; set condition to false
00010A22                            
00010A22 4E75                       .cond	rts		; T
00010A24 4E75                       	rts
00010A26                            	.c bra.s	; F
00010A26 60F6                     M 	bra.s	.false
00010A28 4E75                     M 	rts
00010A2A                            	.c bls.s	; HI
00010A2A 63F2                     M 	bls.s	.false
00010A2C 4E75                     M 	rts
00010A2E                            	.c bhi.s	; LS
00010A2E 62EE                     M 	bhi.s	.false
00010A30 4E75                     M 	rts
00010A32                            	.c blo.s	; HS/CC
00010A32 65EA                     M 	blo.s	.false
00010A34 4E75                     M 	rts
00010A36                            	.c bhs.s	; LO/CS
00010A36 64E6                     M 	bhs.s	.false
00010A38 4E75                     M 	rts
00010A3A                            	.c beq.s	; NE
00010A3A 67E2                     M 	beq.s	.false
00010A3C 4E75                     M 	rts
00010A3E                            	.c bne.s	; EQ
00010A3E 66DE                     M 	bne.s	.false
00010A40 4E75                     M 	rts
00010A42                            	.c bvs.s	; VC
00010A42 69DA                     M 	bvs.s	.false
00010A44 4E75                     M 	rts
00010A46                            	.c bvc.s	; VS
00010A46 68D6                     M 	bvc.s	.false
00010A48 4E75                     M 	rts
00010A4A                            	.c bmi.s	; PL
00010A4A 6BD2                     M 	bmi.s	.false
00010A4C 4E75                     M 	rts
00010A4E                            	.c bpl.s	; MI
00010A4E 6ACE                     M 	bpl.s	.false
00010A50 4E75                     M 	rts
00010A52                            	.c blt.s	; GE
00010A52 6DCA                     M 	blt.s	.false
00010A54 4E75                     M 	rts
00010A56                            	.c bge.s	; LT
00010A56 6CC6                     M 	bge.s	.false
00010A58 4E75                     M 	rts
00010A5A                            	.c ble.s	; GT
00010A5A 6FC2                     M 	ble.s	.false
00010A5C 4E75                     M 	rts
00010A5E                            	.c bgt.s	; LE
00010A5E 6EBE                     M 	bgt.s	.false
00010A60 4E75                     M 	rts
00010A62                            ; ===========================================================================
00010A62                            ; ---------------------------------------------------------------------------
00010A62                            ; Tracker command for freezing the CPU. DEBUG FLAG
00010A62                            ; ---------------------------------------------------------------------------
00010A62                            
00010A62                            dcFreeze:
00010A62 6000 FFFE                  		bra.w	*		; Freeze CPU here
00010A66 4E75                       		rts
00010A68                            ; ===========================================================================
00010A68                            ; ---------------------------------------------------------------------------
00010A68                            ; Tracker command for debugging tracker data. DEBUG FLAG
00010A68                            ; ---------------------------------------------------------------------------
00010A68                            
00010A68                            dcTracker:
00010A68 50F8 C740                  		st	msChktracker.w	; set debug flag
00010A6C 4E75                       		rts
00010A6E                            ; ===========================================================================
00010A6E                            ; ---------------------------------------------------------------------------
00010A6E                            ; Check if a song is playing
00010A6E                            ; ---------------------------------------------------------------------------
00010A6E                            
00010A6E                            dChkSongPlay:
00010A6E 43F8 C4C4                  	lea	mDAC1.w,a1		; Music track RAM
00010A72 7209                       	moveq	#Mus_Ch-1,d1
00010A74                            
00010A74                            .ChkTracks:
00010A74 4A11                       	tst.b	cFlags(a1)		; Is this track playing?
00010A76 6B00                       	bmi.s	.Playing		; If so, branch
00010A78 43E9 002C                  	lea	cSize(a1),a1		; Next track
00010A7C 51C9 FFF6                  	dbf	d1,.ChkTracks		; Loop
00010A80 7200                       	moveq	#0,d1
00010A82 4E75                       	rts
00010A84                            
00010A84                            .Playing:
00010A84 50C1                       	st	d1
00010A86 4E75                       	rts
00010A88                            ; ===========================================================================
00010A88                            ; ---------------------------------------------------------------------------
00010A88                            ; Define music and SFX
00010A88                            ; ---------------------------------------------------------------------------
00010A88                            
00010A88                            	opt oz-				; disable zero-offset optimization
00010A88                            
00010A88 =00000082                  __sfx =		SFXoff
00010A88 =0000000A                  __mus =		MusOff
00010A88                            	include	"Sound/sfx.asm"
00010A88                            
00010A88                            
00010A88                            ; ------------------------------------------------------------------------
00010A88                            ; AMPS SFX list
00010A88                            ; -------------------------------------------------------------------------
00010A88                            
00010A88                            ; -------------------------------------------------------------------------
00010A88                            ; SFX index
00010A88                            ; -------------------------------------------------------------------------
00010A88                            
00010A88                            SoundIndex:
00010A88                            	ptrSFX	$00, Snd_Jump
00010A88 =00000000                M .type	=	$00<<24
00010A88                          M 	rept	narg-1
00010A88 0000 0000                M 	dc.l	snd_jump|.type
00010A8C =00000083                M __sfx	=	__sfx+1
00010A8C                          M 	shift
00010A8C                            	ptrSFX	$00, Snd_Skid
00010A8C =00000000                M .type	=	$00<<24
00010A8C                          M 	rept	narg-1
00010A8C 0000 0000                M 	dc.l	snd_skid|.type
00010A90 =00000084                M __sfx	=	__sfx+1
00010A90                          M 	shift
00010A90                            	ptrSFX	$00, Snd_Death
00010A90 =00000000                M .type	=	$00<<24
00010A90                          M 	rept	narg-1
00010A90 0000 0000                M 	dc.l	snd_death|.type
00010A94 =00000085                M __sfx	=	__sfx+1
00010A94                          M 	shift
00010A94                            	ptrSFX	$00, Snd_Push
00010A94 =00000000                M .type	=	$00<<24
00010A94                          M 	rept	narg-1
00010A94 0000 0000                M 	dc.l	snd_push|.type
00010A98 =00000086                M __sfx	=	__sfx+1
00010A98                          M 	shift
00010A98                            	ptrSFX	$00, Snd_Bubble
00010A98 =00000000                M .type	=	$00<<24
00010A98                          M 	rept	narg-1
00010A98 0000 0000                M 	dc.l	snd_bubble|.type
00010A9C =00000087                M __sfx	=	__sfx+1
00010A9C                          M 	shift
00010A9C                            	ptrSFX	$00, Snd_Drown
00010A9C =00000000                M .type	=	$00<<24
00010A9C                          M 	rept	narg-1
00010A9C 0000 0000                M 	dc.l	snd_drown|.type
00010AA0 =00000088                M __sfx	=	__sfx+1
00010AA0                          M 	shift
00010AA0                            	ptrSFX	$00, Snd_DrownWarning
00010AA0 =00000000                M .type	=	$00<<24
00010AA0                          M 	rept	narg-1
00010AA0 0000 0000                M 	dc.l	snd_drownwarning|.type
00010AA4 =00000089                M __sfx	=	__sfx+1
00010AA4                          M 	shift
00010AA4                            	ptrSFX	$00, Snd_DrownCountdown
00010AA4 =00000000                M .type	=	$00<<24
00010AA4                          M 	rept	narg-1
00010AA4 0000 0000                M 	dc.l	snd_drowncountdown|.type
00010AA8 =0000008A                M __sfx	=	__sfx+1
00010AA8                          M 	shift
00010AA8                            	ptrSFX	$00, Snd_Checkpoint
00010AA8 =00000000                M .type	=	$00<<24
00010AA8                          M 	rept	narg-1
00010AA8 0000 0000                M 	dc.l	snd_checkpoint|.type
00010AAC =0000008B                M __sfx	=	__sfx+1
00010AAC                          M 	shift
00010AAC                            	ptrSFX	$00, Snd_SpikeMove
00010AAC =00000000                M .type	=	$00<<24
00010AAC                          M 	rept	narg-1
00010AAC 0000 0000                M 	dc.l	snd_spikemove|.type
00010AB0 =0000008C                M __sfx	=	__sfx+1
00010AB0                          M 	shift
00010AB0                            	ptrSFX	$00, Snd_Ring
00010AB0 =00000000                M .type	=	$00<<24
00010AB0                          M 	rept	narg-1
00010AB0 0000 0000                M 	dc.l	snd_ring|.type
00010AB4 =0000008D                M __sfx	=	__sfx+1
00010AB4                          M 	shift
00010AB4                            	ptrSFX	$00, Snd_RingLoss
00010AB4 =00000000                M .type	=	$00<<24
00010AB4                          M 	rept	narg-1
00010AB4 0000 0000                M 	dc.l	snd_ringloss|.type
00010AB8 =0000008E                M __sfx	=	__sfx+1
00010AB8                          M 	shift
00010AB8                            	ptrSFX	$00, Snd_Spring
00010AB8 =00000000                M .type	=	$00<<24
00010AB8                          M 	rept	narg-1
00010AB8 0000 0000                M 	dc.l	snd_spring|.type
00010ABC =0000008F                M __sfx	=	__sfx+1
00010ABC                          M 	shift
00010ABC                            	ptrSFX	$00, Snd_Shield
00010ABC =00000000                M .type	=	$00<<24
00010ABC                          M 	rept	narg-1
00010ABC 0000 0000                M 	dc.l	snd_shield|.type
00010AC0 =00000090                M __sfx	=	__sfx+1
00010AC0                          M 	shift
00010AC0                            	ptrSFX	$00, Snd_Splash
00010AC0 =00000000                M .type	=	$00<<24
00010AC0                          M 	rept	narg-1
00010AC0 0000 0000                M 	dc.l	snd_splash|.type
00010AC4 =00000091                M __sfx	=	__sfx+1
00010AC4                          M 	shift
00010AC4                            	ptrSFX	$00, Snd_Bumper
00010AC4 =00000000                M .type	=	$00<<24
00010AC4                          M 	rept	narg-1
00010AC4 0000 0000                M 	dc.l	snd_bumper|.type
00010AC8 =00000092                M __sfx	=	__sfx+1
00010AC8                          M 	shift
00010AC8                            	ptrSFX	$00, Snd_Switch
00010AC8 =00000000                M .type	=	$00<<24
00010AC8                          M 	rept	narg-1
00010AC8 0000 0000                M 	dc.l	snd_switch|.type
00010ACC =00000093                M __sfx	=	__sfx+1
00010ACC                          M 	shift
00010ACC                            	ptrSFX	$00, Snd_Signpost
00010ACC =00000000                M .type	=	$00<<24
00010ACC                          M 	rept	narg-1
00010ACC 0000 0000                M 	dc.l	snd_signpost|.type
00010AD0 =00000094                M __sfx	=	__sfx+1
00010AD0                          M 	shift
00010AD0                            	ptrSFX	$00, Snd_Collapse
00010AD0 =00000000                M .type	=	$00<<24
00010AD0                          M 	rept	narg-1
00010AD0 0000 0000                M 	dc.l	snd_collapse|.type
00010AD4 =00000095                M __sfx	=	__sfx+1
00010AD4                          M 	shift
00010AD4                            	ptrSFX	$00, Snd_WallSmash
00010AD4 =00000000                M .type	=	$00<<24
00010AD4                          M 	rept	narg-1
00010AD4 0000 0000                M 	dc.l	snd_wallsmash|.type
00010AD8 =00000096                M __sfx	=	__sfx+1
00010AD8                          M 	shift
00010AD8                            	ptrSFX	$00, Snd_Rumble
00010AD8 =00000000                M .type	=	$00<<24
00010AD8                          M 	rept	narg-1
00010AD8 0000 0000                M 	dc.l	snd_rumble|.type
00010ADC =00000097                M __sfx	=	__sfx+1
00010ADC                          M 	shift
00010ADC                            	ptrSFX	$00, Snd_Warp
00010ADC =00000000                M .type	=	$00<<24
00010ADC                          M 	rept	narg-1
00010ADC 0000 0000                M 	dc.l	snd_warp|.type
00010AE0 =00000098                M __sfx	=	__sfx+1
00010AE0                          M 	shift
00010AE0                            	ptrSFX	$00, Snd_BossHit
00010AE0 =00000000                M .type	=	$00<<24
00010AE0                          M 	rept	narg-1
00010AE0 0000 0000                M 	dc.l	snd_bosshit|.type
00010AE4 =00000099                M __sfx	=	__sfx+1
00010AE4                          M 	shift
00010AE4                            	ptrSFX	$00, Snd_Bomb
00010AE4 =00000000                M .type	=	$00<<24
00010AE4                          M 	rept	narg-1
00010AE4 0000 0000                M 	dc.l	snd_bomb|.type
00010AE8 =0000009A                M __sfx	=	__sfx+1
00010AE8                          M 	shift
00010AE8                            	ptrSFX	$00, Snd_BreakItem
00010AE8 =00000000                M .type	=	$00<<24
00010AE8                          M 	rept	narg-1
00010AE8 0000 0000                M 	dc.l	snd_breakitem|.type
00010AEC =0000009B                M __sfx	=	__sfx+1
00010AEC                          M 	shift
00010AEC                            	ptrSFX	$00, Snd_FloorBounce
00010AEC =00000000                M .type	=	$00<<24
00010AEC                          M 	rept	narg-1
00010AEC 0000 0000                M 	dc.l	snd_floorbounce|.type
00010AF0 =0000009C                M __sfx	=	__sfx+1
00010AF0                          M 	shift
00010AF0                            	ptrSFX	$00, Snd_Charge
00010AF0 =00000000                M .type	=	$00<<24
00010AF0                          M 	rept	narg-1
00010AF0 0000 0000                M 	dc.l	snd_charge|.type
00010AF4 =0000009D                M __sfx	=	__sfx+1
00010AF4                          M 	shift
00010AF4                            	ptrSFX	$00, Snd_ChargeStop
00010AF4 =00000000                M .type	=	$00<<24
00010AF4                          M 	rept	narg-1
00010AF4 0000 0000                M 	dc.l	snd_chargestop|.type
00010AF8 =0000009E                M __sfx	=	__sfx+1
00010AF8                          M 	shift
00010AF8                            	ptrSFX	$00, Snd_ChargeRelease
00010AF8 =00000000                M .type	=	$00<<24
00010AF8                          M 	rept	narg-1
00010AF8 0000 0000                M 	dc.l	snd_chargerelease|.type
00010AFC =0000009F                M __sfx	=	__sfx+1
00010AFC                          M 	shift
00010AFC                            	ptrSFX	$00, Snd_DiamondBreak
00010AFC =00000000                M .type	=	$00<<24
00010AFC                          M 	rept	narg-1
00010AFC 0000 0000                M 	dc.l	snd_diamondbreak|.type
00010B00 =000000A0                M __sfx	=	__sfx+1
00010B00                          M 	shift
00010B00                            SoundIndex_End:
00010B00                            
00010B00                            ; -------------------------------------------------------------------------
00010B00                            	include	"Sound/music.asm"
00010B00                            
00010B00                            
00010B00                            ; ------------------------------------------------------------------------
00010B00                            ; AMPS music list
00010B00                            ; -------------------------------------------------------------------------
00010B00                            
00010B00                            ; -------------------------------------------------------------------------
00010B00                            ; Music index
00010B00                            ; -------------------------------------------------------------------------
00010B00                            
00010B00                            MusicIndex:
00010B00                            	ptrMusic	Mus_WWZ,		$00
00010B00                          M 	rept	narg/2
00010B00 0000 0000                M 	dc.l	(($00)<<24)|mus_wwz
00010B04 =0000000B                M __mus	=	__mus+1
00010B04                          M 	shift
00010B04                          M 	shift
00010B04                            	ptrMusic	Mus_WWZ,		$00
00010B04                          M 	rept	narg/2
00010B04 0000 0000                M 	dc.l	(($00)<<24)|mus_wwz
00010B08 =0000000C                M __mus	=	__mus+1
00010B08                          M 	shift
00010B08                          M 	shift
00010B08                            	ptrMusic	Mus_Boss,		$00
00010B08                          M 	rept	narg/2
00010B08 0000 0000                M 	dc.l	(($00)<<24)|mus_boss
00010B0C =0000000D                M __mus	=	__mus+1
00010B0C                          M 	shift
00010B0C                          M 	shift
00010B0C                            MusicIndex_End:
00010B0C                            
00010B0C                            ; -------------------------------------------------------------------------
00010B0C                            ; ===========================================================================
00010B0C                            ; ---------------------------------------------------------------------------
00010B0C                            ; Define samples
00010B0C                            ; ---------------------------------------------------------------------------
00010B0C                            
00010B0C =00000080                  __samp =	$80
00010B0C                            	include	"Sound/dac.asm"
00010B0C                            
00010B0C                            
00010B0C                            ; ------------------------------------------------------------------------
00010B0C                            ; AMPS DAC list
00010B0C                            ; -------------------------------------------------------------------------
00010B0C                            
00010B0C                            ; -------------------------------------------------------------------------
00010B0C                            ; Sample 68k PCM list
00010B0C                            ; -------------------------------------------------------------------------
00010B0C                            
00010B0C                            SampleList:
00010B0C                            	sample	$0000, Stop,		Stop,		Stop		; 80 (THIS IS A REST NOTE, DO NOT EDIT...)
00010B0C =00000080                M dstop	=	__samp
00010B0C =00000081                M __samp	=	__samp+1
00010B0C 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B0F 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B12 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B15 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B18 FF00                     M 	dc.w	$0000-$100
00010B1A 0000                     M 	dc.w	0
00010B1C                            	sample	$0100, Kick,		Stop,		Kick		; 81
00010B1C =00000081                M dkick	=	__samp
00010B1C =00000082                M __samp	=	__samp+1
00010B1C 0000 00                  M 	dc.b	swf_kick&$ff,((swf_kick>>$08)&$7f)|$80,(swf_kick>>$0f)&$ff
00010B1F 0000 00                  M 	dc.b	(swfr_kick-1)&$ff,(((swfr_kick-1)>>$08)&$7f)|$80,((swfr_kick-1)>>$0f)&$ff
00010B22 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B25 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B28 0000                     M 	dc.w	$0100-$100
00010B2A 0000                     M 	dc.w	0
00010B2C                            	sample	$0100, Kick,		Stop,		Kick2		; 82
00010B2C =00000082                M dkick2	=	__samp
00010B2C =00000083                M __samp	=	__samp+1
00010B2C 0000 00                  M 	dc.b	swf_kick&$ff,((swf_kick>>$08)&$7f)|$80,(swf_kick>>$0f)&$ff
00010B2F 0000 00                  M 	dc.b	(swfr_kick-1)&$ff,(((swfr_kick-1)>>$08)&$7f)|$80,((swfr_kick-1)>>$0f)&$ff
00010B32 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B35 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B38 0000                     M 	dc.w	$0100-$100
00010B3A 0000                     M 	dc.w	0
00010B3C                            	sample	$0100, Snare,		Stop,		Snare		; 83
00010B3C =00000083                M dsnare	=	__samp
00010B3C =00000084                M __samp	=	__samp+1
00010B3C 0000 00                  M 	dc.b	swf_snare&$ff,((swf_snare>>$08)&$7f)|$80,(swf_snare>>$0f)&$ff
00010B3F 0000 00                  M 	dc.b	(swfr_snare-1)&$ff,(((swfr_snare-1)>>$08)&$7f)|$80,((swfr_snare-1)>>$0f)&$ff
00010B42 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B45 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B48 0000                     M 	dc.w	$0100-$100
00010B4A 0000                     M 	dc.w	0
00010B4C                            	sample	$0100, Snare,		Stop,		Snare2		; 84
00010B4C =00000084                M dsnare2	=	__samp
00010B4C =00000085                M __samp	=	__samp+1
00010B4C 0000 00                  M 	dc.b	swf_snare&$ff,((swf_snare>>$08)&$7f)|$80,(swf_snare>>$0f)&$ff
00010B4F 0000 00                  M 	dc.b	(swfr_snare-1)&$ff,(((swfr_snare-1)>>$08)&$7f)|$80,((swfr_snare-1)>>$0f)&$ff
00010B52 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B55 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B58 0000                     M 	dc.w	$0100-$100
00010B5A 0000                     M 	dc.w	0
00010B5C                            	sample	$0100, Tom,		Stop,		Tom		; 85
00010B5C =00000085                M dtom	=	__samp
00010B5C =00000086                M __samp	=	__samp+1
00010B5C 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B5F 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010B62 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B65 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B68 0000                     M 	dc.w	$0100-$100
00010B6A 0000                     M 	dc.w	0
00010B6C                            	sample	$0160, Tom,		Stop,		TomH 		; 86
00010B6C =00000086                M dtomh	=	__samp
00010B6C =00000087                M __samp	=	__samp+1
00010B6C 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B6F 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010B72 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B75 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B78 0060                     M 	dc.w	$0160-$100
00010B7A 0000                     M 	dc.w	0
00010B7C                            	sample	$0130, Tom,		Stop,		TomMid		; 87
00010B7C =00000087                M dtommid	=	__samp
00010B7C =00000088                M __samp	=	__samp+1
00010B7C 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B7F 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010B82 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B85 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B88 0030                     M 	dc.w	$0130-$100
00010B8A 0000                     M 	dc.w	0
00010B8C                            	sample	$0100, Tom,		Stop,		TomMidL		; 88
00010B8C =00000088                M dtommidl	=	__samp
00010B8C =00000089                M __samp	=	__samp+1
00010B8C 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B8F 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010B92 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B95 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B98 0000                     M 	dc.w	$0100-$100
00010B9A 0000                     M 	dc.w	0
00010B9C                            	sample	$00E0, Tom,		Stop,		TomL		; 89
00010B9C =00000089                M dtoml	=	__samp
00010B9C =0000008A                M __samp	=	__samp+1
00010B9C 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B9F 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010BA2 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BA5 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BA8 FFE0                     M 	dc.w	$00e0-$100
00010BAA 0000                     M 	dc.w	0
00010BAC                            	sample	$0100, Stop,		Stop,		Stop2		; 8A
00010BAC =0000008A                M dstop2	=	__samp
00010BAC =0000008B                M __samp	=	__samp+1
00010BAC 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BAF 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BB2 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BB5 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BB8 0000                     M 	dc.w	$0100-$100
00010BBA 0000                     M 	dc.w	0
00010BBC                            	sample	$0100, Stop,		Stop,		Stop3		; 8B
00010BBC =0000008B                M dstop3	=	__samp
00010BBC =0000008C                M __samp	=	__samp+1
00010BBC 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BBF 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BC2 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BC5 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BC8 0000                     M 	dc.w	$0100-$100
00010BCA 0000                     M 	dc.w	0
00010BCC                            	sample	$0104, Title,		Title,		Title		; 8C
00010BCC =0000008C                M dtitle	=	__samp
00010BCC =0000008D                M __samp	=	__samp+1
00010BCC 0000 00                  M 	dc.b	swf_title&$ff,((swf_title>>$08)&$7f)|$80,(swf_title>>$0f)&$ff
00010BCF 0000 00                  M 	dc.b	(swfr_title-1)&$ff,(((swfr_title-1)>>$08)&$7f)|$80,((swfr_title-1)>>$0f)&$ff
00010BD2 0000 00                  M 	dc.b	swf_title&$ff,((swf_title>>$08)&$7f)|$80,(swf_title>>$0f)&$ff
00010BD5 0000 00                  M 	dc.b	(swfr_title-1)&$ff,(((swfr_title-1)>>$08)&$7f)|$80,((swfr_title-1)>>$0f)&$ff
00010BD8 0004                     M 	dc.w	$0104-$100
00010BDA 0000                     M 	dc.w	0
00010BDC                            	sample	$0104, Sega,		Stop,		Sega		; 8D
00010BDC =0000008D                M dsega	=	__samp
00010BDC =0000008E                M __samp	=	__samp+1
00010BDC 0000 00                  M 	dc.b	swf_sega&$ff,((swf_sega>>$08)&$7f)|$80,(swf_sega>>$0f)&$ff
00010BDF 0000 00                  M 	dc.b	(swfr_sega-1)&$ff,(((swfr_sega-1)>>$08)&$7f)|$80,((swfr_sega-1)>>$0f)&$ff
00010BE2 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BE5 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BE8 0004                     M 	dc.w	$0104-$100
00010BEA 0000                     M 	dc.w	0
00010BEC                            	sample	$0104, Punch,		Stop,		Punch		; 8E
00010BEC =0000008E                M dpunch	=	__samp
00010BEC =0000008F                M __samp	=	__samp+1
00010BEC 0000 00                  M 	dc.b	swf_punch&$ff,((swf_punch>>$08)&$7f)|$80,(swf_punch>>$0f)&$ff
00010BEF 0000 00                  M 	dc.b	(swfr_punch-1)&$ff,(((swfr_punch-1)>>$08)&$7f)|$80,((swfr_punch-1)>>$0f)&$ff
00010BF2 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BF5 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BF8 0004                     M 	dc.w	$0104-$100
00010BFA 0000                     M 	dc.w	0
00010BFC                            	sample	$0114, EndingSong,	EndingSong,	EndingSong	; 8F
00010BFC =0000008F                M dendingsong	=	__samp
00010BFC =00000090                M __samp	=	__samp+1
00010BFC 0000 00                  M 	dc.b	swf_endingsong&$ff,((swf_endingsong>>$08)&$7f)|$80,(swf_endingsong>>$0f)&$ff
00010BFF 0000 00                  M 	dc.b	(swfr_endingsong-1)&$ff,(((swfr_endingsong-1)>>$08)&$7f)|$80,((swfr_endingsong-1)>>$0f)&$ff
00010C02 0000 00                  M 	dc.b	swf_endingsong&$ff,((swf_endingsong>>$08)&$7f)|$80,(swf_endingsong>>$0f)&$ff
00010C05 0000 00                  M 	dc.b	(swfr_endingsong-1)&$ff,(((swfr_endingsong-1)>>$08)&$7f)|$80,((swfr_endingsong-1)>>$0f)&$ff
00010C08 0014                     M 	dc.w	$0114-$100
00010C0A 0000                     M 	dc.w	0
00010C0C                            	sample	$0114, BinBowie,	Stop,		BinBowie	; 90
00010C0C =00000090                M dbinbowie	=	__samp
00010C0C =00000091                M __samp	=	__samp+1
00010C0C 0000 00                  M 	dc.b	swf_binbowie&$ff,((swf_binbowie>>$08)&$7f)|$80,(swf_binbowie>>$0f)&$ff
00010C0F 0000 00                  M 	dc.b	(swfr_binbowie-1)&$ff,(((swfr_binbowie-1)>>$08)&$7f)|$80,((swfr_binbowie-1)>>$0f)&$ff
00010C12 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C15 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C18 0014                     M 	dc.w	$0114-$100
00010C1A 0000                     M 	dc.w	0
00010C1C                            	sample	$0114, Wacky_Base_Loud,	Stop,		WackyBase	; 91
00010C1C =00000091                M dwackybase	=	__samp
00010C1C =00000092                M __samp	=	__samp+1
00010C1C 0000 00                  M 	dc.b	swf_wacky_base_loud&$ff,((swf_wacky_base_loud>>$08)&$7f)|$80,(swf_wacky_base_loud>>$0f)&$ff
00010C1F 0000 00                  M 	dc.b	(swfr_wacky_base_loud-1)&$ff,(((swfr_wacky_base_loud-1)>>$08)&$7f)|$80,((swfr_wacky_base_loud-1)>>$0f)&$ff
00010C22 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010C25 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010C28 0014                     M 	dc.w	$0114-$100
00010C2A 0000                     M 	dc.w	0
00010C2C                            SampleList_End:
00010C2C                            
00010C2C                            ; -------------------------------------------------------------------------
00010C2C                            ; ===========================================================================
00010C2C                            ; ---------------------------------------------------------------------------
00010C2C                            ; Define volume envelopes and their data
00010C2C                            ; ---------------------------------------------------------------------------
00010C2C                            
00010C2C =00000001                  __venv =	$01
00010C2C                            	include	"Sound/psg.asm"
00010C2C                            
00010C2C                            
00010C2C                            ; ------------------------------------------------------------------------
00010C2C                            ; AMPS PSG envelopes
00010C2C                            ; -------------------------------------------------------------------------
00010C2C                            
00010C2C                            ; -------------------------------------------------------------------------
00010C2C                            ; PSG envelope index
00010C2C                            ; -------------------------------------------------------------------------
00010C2C                            
00010C2C                            VolEnvs:
00010C2C                            	volenv	01
00010C2C                          M 	rept	narg
00010C2C =00000001                M v01	=	__venv
00010C2C 0000 0000                M 	dc.l	vd01
00010C30 =00000002                M __venv	=	__venv+1
00010C30                          M 	shift
00010C30                            	volenv	02
00010C30                          M 	rept	narg
00010C30 =00000002                M v02	=	__venv
00010C30 0000 0000                M 	dc.l	vd02
00010C34 =00000003                M __venv	=	__venv+1
00010C34                          M 	shift
00010C34                            	volenv	03
00010C34                          M 	rept	narg
00010C34 =00000003                M v03	=	__venv
00010C34 0000 0000                M 	dc.l	vd03
00010C38 =00000004                M __venv	=	__venv+1
00010C38                          M 	shift
00010C38                            	volenv	04
00010C38                          M 	rept	narg
00010C38 =00000004                M v04	=	__venv
00010C38 0000 0000                M 	dc.l	vd04
00010C3C =00000005                M __venv	=	__venv+1
00010C3C                          M 	shift
00010C3C                            	volenv	05
00010C3C                          M 	rept	narg
00010C3C =00000005                M v05	=	__venv
00010C3C 0000 0000                M 	dc.l	vd05
00010C40 =00000006                M __venv	=	__venv+1
00010C40                          M 	shift
00010C40                            	volenv	06
00010C40                          M 	rept	narg
00010C40 =00000006                M v06	=	__venv
00010C40 0000 0000                M 	dc.l	vd06
00010C44 =00000007                M __venv	=	__venv+1
00010C44                          M 	shift
00010C44                            	volenv	07
00010C44                          M 	rept	narg
00010C44 =00000007                M v07	=	__venv
00010C44 0000 0000                M 	dc.l	vd07
00010C48 =00000008                M __venv	=	__venv+1
00010C48                          M 	shift
00010C48                            	volenv	08
00010C48                          M 	rept	narg
00010C48 =00000008                M v08	=	__venv
00010C48 0000 0000                M 	dc.l	vd08
00010C4C =00000009                M __venv	=	__venv+1
00010C4C                          M 	shift
00010C4C                            	volenv	09
00010C4C                          M 	rept	narg
00010C4C =00000009                M v09	=	__venv
00010C4C 0000 0000                M 	dc.l	vd09
00010C50 =0000000A                M __venv	=	__venv+1
00010C50                          M 	shift
00010C50                            	volenv	0A
00010C50                          M 	rept	narg
00010C50 =0000000A                M v0a	=	__venv
00010C50 0000 0000                M 	dc.l	vd0a
00010C54 =0000000B                M __venv	=	__venv+1
00010C54                          M 	shift
00010C54                            	volenv	0B
00010C54                          M 	rept	narg
00010C54 =0000000B                M v0b	=	__venv
00010C54 0000 0000                M 	dc.l	vd0b
00010C58 =0000000C                M __venv	=	__venv+1
00010C58                          M 	shift
00010C58                            	volenv	0C
00010C58                          M 	rept	narg
00010C58 =0000000C                M v0c	=	__venv
00010C58 0000 0000                M 	dc.l	vd0c
00010C5C =0000000D                M __venv	=	__venv+1
00010C5C                          M 	shift
00010C5C                            	volenv	0D
00010C5C                          M 	rept	narg
00010C5C =0000000D                M v0d	=	__venv
00010C5C 0000 0000                M 	dc.l	vd0d
00010C60 =0000000E                M __venv	=	__venv+1
00010C60                          M 	shift
00010C60                            VolEnvs_End:
00010C60                            	opt ae-
00010C60                            
00010C60                            ; -------------------------------------------------------------------------
00010C60                            ; PSG envelope data
00010C60                            ; -------------------------------------------------------------------------
00010C60                            
00010C60 0000 0001 0101 0202        vd01:	dc.b	$00, $00, $00, $01, $01, $01, $02, $02
00010C68 0203 0303 0404 0405        	dc.b	$02, $03, $03, $03, $04, $04, $04, $05
00010C70 0505 0606 0607 82          	dc.b	$05, $05, $06, $06, $06, $07, eHold
00010C77                            
00010C77 0002 0406 0810 82          vd02:	dc.b	$00, $02, $04, $06, $08, $10, eHold
00010C7E                            
00010C7E 0000 0101 0202 0303        vd03:	dc.b	$00, $00, $01, $01, $02, $02, $03, $03
00010C86 0404 0505 0606 0707        	dc.b	$04, $04, $05, $05, $06, $06, $07, $07
00010C8E 82                         	dc.b	eHold
00010C8F                            
00010C8F 0000 0203 0404 0505        vd04:	dc.b	$00, $00, $02, $03, $04, $04, $05, $05
00010C97 0506 82                    	dc.b	$05, $06, eHold
00010C9A                            
00010C9A 0000 0000 0000 0000        vd05:	dc.b	$00, $00, $00, $00, $00, $00, $00, $00
00010CA2 0000 0101 0101 0101        	dc.b	$00, $00, $01, $01, $01, $01, $01, $01
00010CAA 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010CB2 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010CBA 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010CC2 0482                       	dc.b	$04, eHold
00010CC4                            
00010CC4 0303 0302 0202 0201        vd06:	dc.b	$03, $03, $03, $02, $02, $02, $02, $01
00010CCC 0101 0000 0000 82          	dc.b	$01, $01, $00, $00, $00, $00, eHold
00010CD3                            
00010CD3 0000 0000 0000 0101        vd07:	dc.b	$00, $00, $00, $00, $00, $00, $01, $01
00010CDB 0101 0102 0202 0202        	dc.b	$01, $01, $01, $02, $02, $02, $02, $02
00010CE3 0303 0304 0404 0505        	dc.b	$03, $03, $03, $04, $04, $04, $05, $05
00010CEB 0506 0782                  	dc.b	$05, $06, $07, eHold
00010CEF                            
00010CEF 0000 0000 0001 0101        vd08:	dc.b	$00, $00, $00, $00, $00, $01, $01, $01
00010CF7 0101 0202 0202 0202        	dc.b	$01, $01, $02, $02, $02, $02, $02, $02
00010CFF 0303 0303 0304 0404        	dc.b	$03, $03, $03, $03, $03, $04, $04, $04
00010D07 0404 0505 0505 0506        	dc.b	$04, $04, $05, $05, $05, $05, $05, $06
00010D0F 0606 0606 0707 0782        	dc.b	$06, $06, $06, $06, $07, $07, $07, eHold
00010D17                            
00010D17 0001 0203 0405 0607        vd09:	dc.b	$00, $01, $02, $03, $04, $05, $06, $07
00010D1F 0809 0A0B 0C0D 0E0F        	dc.b	$08, $09, $0A, $0B, $0C, $0D, $0E, $0F
00010D27 82                         	dc.b	eHold
00010D28                            	even
00010D28                            
00010D28 0000 0000 0000 0000        vd0A:	dc.b	$00, $00, $00, $00, $00, $00, $00, $00
00010D30 0000 0101 0101 0101        	dc.b	$00, $00, $01, $01, $01, $01, $01, $01
00010D38 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D40 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D48 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D50 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010D58 0202 0303 0303 0303        	dc.b	$02, $02, $03, $03, $03, $03, $03, $03
00010D60 0303 0303 0304 82          	dc.b	$03, $03, $03, $03, $03, $04, eHold
00010D68 00                         	even
00010D68                            
00010D68 0404 0403 0303 0202        vd0B:	dc.b	$04, $04, $04, $03, $03, $03, $02, $02
00010D70 0201 0101 0101 0101        	dc.b	$02, $01, $01, $01, $01, $01, $01, $01
00010D78 0202 0202 0203 0303        	dc.b	$02, $02, $02, $02, $02, $03, $03, $03
00010D80 0303 0482                  	dc.b	$03, $03, $04, eHold
00010D84                            	even
00010D84                            
00010D84 0404 0303 0202 0101        vd0C:	dc.b	$04, $04, $03, $03, $02, $02, $01, $01
00010D8C 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D94 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D9C 0101 0202 0202 0202        	dc.b	$01, $01, $02, $02, $02, $02, $02, $02
00010DA4 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010DAC 0202 0202 0202 0303        	dc.b	$02, $02, $02, $02, $02, $02, $03, $03
00010DB4 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010DBC 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010DC4 0303 0404 0404 0404        	dc.b	$03, $03, $04, $04, $04, $04, $04, $04
00010DCC 0404 0404 0404 0404        	dc.b	$04, $04, $04, $04, $04, $04, $04, $04
00010DD4 0404 0404 0404 0505        	dc.b	$04, $04, $04, $04, $04, $04, $05, $05
00010DDC 0505 0505 0505 0505        	dc.b	$05, $05, $05, $05, $05, $05, $05, $05
00010DE4 0505 0505 0505 0505        	dc.b	$05, $05, $05, $05, $05, $05, $05, $05
00010DEC 0505 0606 0606 0606        	dc.b	$05, $05, $06, $06, $06, $06, $06, $06
00010DF4 0606 0606 0606 0606        	dc.b	$06, $06, $06, $06, $06, $06, $06, $06
00010DFC 0606 0606 0606 0782        	dc.b	$06, $06, $06, $06, $06, $06, $07, eHold
00010E04                            	even
00010E04                            
00010E04 0E0D 0C0B 0A09 0807        vd0D:	dc.b	$0E, $0D, $0C, $0B, $0A, $09, $08, $07
00010E0C 0605 0403 0201 000F        	dc.b	$06, $05, $04, $03, $02, $01, $00, $0F
00010E14 82                         	dc.b	eHold
00010E16 00                         	even
00010E16                            
00010E16                            ; -------------------------------------------------------------------------
00010E16                            ; ===========================================================================
00010E16                            ; ---------------------------------------------------------------------------
00010E16                            ; Include music, sound effects and voice table
00010E16                            ; ---------------------------------------------------------------------------
00010E16                            
00010E16                            VoiceBankMusic:
00010E16 =00000000                  sPatNum = 0
00010E16                            	include "Sound/unipatchmus.asm"; include universal Voice banks
00010E16                            
00010E16                            
00010E16                            ; ------------------------------------------------------------------------
00010E16                            ; AMPS music patch list
00010E16                            ; -------------------------------------------------------------------------
00010E16                            
00010E16                            	; Patch $00
00010E16                            	; $2A
00010E16                            	; $02, $32, $03, $01,	$5F, $5F, $9F, $9C
00010E16                            	; $9F, $1F, $9F, $04,	$00, $00, $00, $07
00010E16                            	; $15, $15, $15, $F5,	$05, $08, $0C, $1A
00010E16                            	spAlgorithm	$02
00010E16 =00000001                M spatnum	=	spatnum+1
00010E16 =00000002                M spal	=	val
00010E16                            	spFeedback	$05
00010E16 =00000005                M spfe	=	val
00010E16                            	spDetune	$00, $00, $03, $00
00010E16 =00000000                M spde1	=	op1
00010E16 =00000000                M spde2	=	op2
00010E16 =00000003                M spde3	=	op3
00010E16 =00000000                M spde4	=	op4
00010E16                            	spMultiple	$02, $03, $02, $01
00010E16 =00000002                M spmu1	=	op1
00010E16 =00000003                M spmu2	=	op2
00010E16 =00000002                M spmu3	=	op3
00010E16 =00000001                M spmu4	=	op4
00010E16                            	spRateScale	$01, $02, $01, $02
00010E16 =00000001                M sprs1	=	op1
00010E16 =00000002                M sprs2	=	op2
00010E16 =00000001                M sprs3	=	op3
00010E16 =00000002                M sprs4	=	op4
00010E16                            	spAttackRt	$1F, $1F, $1F, $1C
00010E16 =0000001F                M spar1	=	op1
00010E16 =0000001F                M spar2	=	op2
00010E16 =0000001F                M spar3	=	op3
00010E16 =0000001C                M spar4	=	op4
00010E16                            	spAmpMod	$01, $01, $00, $00
00010E16 =00000001                M spam1	=	op1
00010E16 =00000001                M spam2	=	op2
00010E16 =00000000                M spam3	=	op3
00010E16 =00000000                M spam4	=	op4
00010E16                            	spSustainRt	$1F, $1F, $1F, $04
00010E16 =0000001F                M spsr1	=	op1
00010E16 =0000001F                M spsr2	=	op2
00010E16 =0000001F                M spsr3	=	op3
00010E16 =00000004                M spsr4	=	op4
00010E16                            	spDecayRt	$00, $00, $00, $07
00010E16 =00000000                M spdr1	=	op1
00010E16 =00000000                M spdr2	=	op2
00010E16 =00000000                M spdr3	=	op3
00010E16 =00000007                M spdr4	=	op4
00010E16                            	spSustainLv	$01, $01, $01, $0F
00010E16 =00000001                M spsl1	=	op1
00010E16 =00000001                M spsl2	=	op2
00010E16 =00000001                M spsl3	=	op3
00010E16 =0000000F                M spsl4	=	op4
00010E16                            	spReleaseRt	$05, $05, $05, $05
00010E16 =00000005                M sprr1	=	op1
00010E16 =00000005                M sprr2	=	op2
00010E16 =00000005                M sprr3	=	op3
00010E16 =00000005                M sprr4	=	op4
00010E16                            	spSSGEG		$00, $00, $00, $00
00010E16 =00000000                M spss1	=	op1
00010E16 =00000000                M spss2	=	op2
00010E16 =00000000                M spss3	=	op3
00010E16 =00000000                M spss4	=	op4
00010E16                            	spTotalLv	$05, $0C, $08, $1A
00010E16 =00000005                M sptl1	=	op1
00010E16 =0000000C                M sptl2	=	op2
00010E16 =00000008                M sptl3	=	op3
00010E16 =0000001A                M sptl4	=	op4
00010E16 2A                       M 	dc.b	(spfe<<3)+spal
00010E17 =00000080                M sptlmask4	set	$80
00010E17 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E17 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E17 =00000000                M sptlmask1	set	((spal=7)<<7)
00010E17 0232 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E1B 5F5F 9F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E1F 9F1F 9F04                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E23 0000 0007                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E27 1515 15F5                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E2B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E2F 0508 0C9A                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E33 4E41 54                  M 	dc.b	'NAT'
00010E36                            
00010E36                            	; Patch $01
00010E36                            	; $38
00010E36                            	; $01, $00, $01, $00,	$1F, $1F, $1F, $1F
00010E36                            	; $00, $00, $00, $0D,	$0E, $00, $00, $1F
00010E36                            	; $00, $00, $00, $30,	$1C, $11, $28, $04
00010E36                            	spAlgorithm	$00
00010E36 =00000002                M spatnum	=	spatnum+1
00010E36 =00000000                M spal	=	val
00010E36                            	spFeedback	$07
00010E36 =00000007                M spfe	=	val
00010E36                            	spDetune	$00, $00, $00, $00
00010E36 =00000000                M spde1	=	op1
00010E36 =00000000                M spde2	=	op2
00010E36 =00000000                M spde3	=	op3
00010E36 =00000000                M spde4	=	op4
00010E36                            	spMultiple	$01, $01, $00, $00
00010E36 =00000001                M spmu1	=	op1
00010E36 =00000001                M spmu2	=	op2
00010E36 =00000000                M spmu3	=	op3
00010E36 =00000000                M spmu4	=	op4
00010E36                            	spRateScale	$00, $00, $00, $00
00010E36 =00000000                M sprs1	=	op1
00010E36 =00000000                M sprs2	=	op2
00010E36 =00000000                M sprs3	=	op3
00010E36 =00000000                M sprs4	=	op4
00010E36                            	spAttackRt	$1F, $1F, $1F, $1F
00010E36 =0000001F                M spar1	=	op1
00010E36 =0000001F                M spar2	=	op2
00010E36 =0000001F                M spar3	=	op3
00010E36 =0000001F                M spar4	=	op4
00010E36                            	spAmpMod	$00, $00, $00, $00
00010E36 =00000000                M spam1	=	op1
00010E36 =00000000                M spam2	=	op2
00010E36 =00000000                M spam3	=	op3
00010E36 =00000000                M spam4	=	op4
00010E36                            	spSustainRt	$00, $00, $00, $0D
00010E36 =00000000                M spsr1	=	op1
00010E36 =00000000                M spsr2	=	op2
00010E36 =00000000                M spsr3	=	op3
00010E36 =0000000D                M spsr4	=	op4
00010E36                            	spDecayRt	$0E, $00, $00, $1F
00010E36 =0000000E                M spdr1	=	op1
00010E36 =00000000                M spdr2	=	op2
00010E36 =00000000                M spdr3	=	op3
00010E36 =0000001F                M spdr4	=	op4
00010E36                            	spSustainLv	$00, $00, $00, $03
00010E36 =00000000                M spsl1	=	op1
00010E36 =00000000                M spsl2	=	op2
00010E36 =00000000                M spsl3	=	op3
00010E36 =00000003                M spsl4	=	op4
00010E36                            	spReleaseRt	$00, $00, $00, $00
00010E36 =00000000                M sprr1	=	op1
00010E36 =00000000                M sprr2	=	op2
00010E36 =00000000                M sprr3	=	op3
00010E36 =00000000                M sprr4	=	op4
00010E36                            	spSSGEG		$00, $00, $00, $00
00010E36 =00000000                M spss1	=	op1
00010E36 =00000000                M spss2	=	op2
00010E36 =00000000                M spss3	=	op3
00010E36 =00000000                M spss4	=	op4
00010E36                            	spTotalLv	$1C, $28, $11, $04
00010E36 =0000001C                M sptl1	=	op1
00010E36 =00000028                M sptl2	=	op2
00010E36 =00000011                M sptl3	=	op3
00010E36 =00000004                M sptl4	=	op4
00010E36 38                       M 	dc.b	(spfe<<3)+spal
00010E37 =00000080                M sptlmask4	set	$80
00010E37 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E37 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E37 =00000000                M sptlmask1	set	((spal=7)<<7)
00010E37 0100 0100                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E3B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E3F 0000 000D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E43 0E00 001F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E47 0000 0030                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E4B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E4F 1C11 2884                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E53 4E41 54                  M 	dc.b	'NAT'
00010E56                            
00010E56                            	; Patch $02
00010E56                            	; $21
00010E56                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $1F
00010E56                            	; $0B, $08, $0F, $0B,	$01, $13, $1F, $1F
00010E56                            	; $14, $B4, $44, $14,	$7F, $7F, $14, $04
00010E56                            	spAlgorithm	$01
00010E56 =00000003                M spatnum	=	spatnum+1
00010E56 =00000001                M spal	=	val
00010E56                            	spFeedback	$04
00010E56 =00000004                M spfe	=	val
00010E56                            	spDetune	$00, $00, $00, $00
00010E56 =00000000                M spde1	=	op1
00010E56 =00000000                M spde2	=	op2
00010E56 =00000000                M spde3	=	op3
00010E56 =00000000                M spde4	=	op4
00010E56                            	spMultiple	$00, $00, $00, $00
00010E56 =00000000                M spmu1	=	op1
00010E56 =00000000                M spmu2	=	op2
00010E56 =00000000                M spmu3	=	op3
00010E56 =00000000                M spmu4	=	op4
00010E56                            	spRateScale	$00, $00, $00, $00
00010E56 =00000000                M sprs1	=	op1
00010E56 =00000000                M sprs2	=	op2
00010E56 =00000000                M sprs3	=	op3
00010E56 =00000000                M sprs4	=	op4
00010E56                            	spAttackRt	$1F, $1F, $1F, $1F
00010E56 =0000001F                M spar1	=	op1
00010E56 =0000001F                M spar2	=	op2
00010E56 =0000001F                M spar3	=	op3
00010E56 =0000001F                M spar4	=	op4
00010E56                            	spAmpMod	$00, $00, $00, $00
00010E56 =00000000                M spam1	=	op1
00010E56 =00000000                M spam2	=	op2
00010E56 =00000000                M spam3	=	op3
00010E56 =00000000                M spam4	=	op4
00010E56                            	spSustainRt	$0B, $0F, $08, $0B
00010E56 =0000000B                M spsr1	=	op1
00010E56 =0000000F                M spsr2	=	op2
00010E56 =00000008                M spsr3	=	op3
00010E56 =0000000B                M spsr4	=	op4
00010E56                            	spDecayRt	$01, $1F, $13, $1F
00010E56 =00000001                M spdr1	=	op1
00010E56 =0000001F                M spdr2	=	op2
00010E56 =00000013                M spdr3	=	op3
00010E56 =0000001F                M spdr4	=	op4
00010E56                            	spSustainLv	$01, $04, $0B, $01
00010E56 =00000001                M spsl1	=	op1
00010E56 =00000004                M spsl2	=	op2
00010E56 =0000000B                M spsl3	=	op3
00010E56 =00000001                M spsl4	=	op4
00010E56                            	spReleaseRt	$04, $04, $04, $04
00010E56 =00000004                M sprr1	=	op1
00010E56 =00000004                M sprr2	=	op2
00010E56 =00000004                M sprr3	=	op3
00010E56 =00000004                M sprr4	=	op4
00010E56                            	spSSGEG		$00, $00, $00, $00
00010E56 =00000000                M spss1	=	op1
00010E56 =00000000                M spss2	=	op2
00010E56 =00000000                M spss3	=	op3
00010E56 =00000000                M spss4	=	op4
00010E56                            	spTotalLv	$7F, $14, $7F, $04
00010E56 =0000007F                M sptl1	=	op1
00010E56 =00000014                M sptl2	=	op2
00010E56 =0000007F                M sptl3	=	op3
00010E56 =00000004                M sptl4	=	op4
00010E56 21                       M 	dc.b	(spfe<<3)+spal
00010E57 =00000080                M sptlmask4	set	$80
00010E57 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E57 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E57 =00000000                M sptlmask1	set	((spal=7)<<7)
00010E57 0000 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E5B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E5F 0B08 0F0B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E63 0113 1F1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E67 14B4 4414                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E6B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E6F 7F7F 1484                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E73 4E41 54                  M 	dc.b	'NAT'
00010E76                            
00010E76                            	; Patch $03
00010E76                            	; $34
00010E76                            	; $74, $02, $6B, $02,	$1F, $53, $53, $11
00010E76                            	; $11, $1F, $12, $01,	$00, $00, $00, $00
00010E76                            	; $2B, $0B, $F9, $69,	$2A, $0C, $13, $04
00010E76                            	spAlgorithm	$04
00010E76 =00000004                M spatnum	=	spatnum+1
00010E76 =00000004                M spal	=	val
00010E76                            	spFeedback	$06
00010E76 =00000006                M spfe	=	val
00010E76                            	spDetune	$07, $06, $00, $00
00010E76 =00000007                M spde1	=	op1
00010E76 =00000006                M spde2	=	op2
00010E76 =00000000                M spde3	=	op3
00010E76 =00000000                M spde4	=	op4
00010E76                            	spMultiple	$04, $0B, $02, $02
00010E76 =00000004                M spmu1	=	op1
00010E76 =0000000B                M spmu2	=	op2
00010E76 =00000002                M spmu3	=	op3
00010E76 =00000002                M spmu4	=	op4
00010E76                            	spRateScale	$00, $01, $01, $00
00010E76 =00000000                M sprs1	=	op1
00010E76 =00000001                M sprs2	=	op2
00010E76 =00000001                M sprs3	=	op3
00010E76 =00000000                M sprs4	=	op4
00010E76                            	spAttackRt	$1F, $13, $13, $11
00010E76 =0000001F                M spar1	=	op1
00010E76 =00000013                M spar2	=	op2
00010E76 =00000013                M spar3	=	op3
00010E76 =00000011                M spar4	=	op4
00010E76                            	spAmpMod	$00, $00, $00, $00
00010E76 =00000000                M spam1	=	op1
00010E76 =00000000                M spam2	=	op2
00010E76 =00000000                M spam3	=	op3
00010E76 =00000000                M spam4	=	op4
00010E76                            	spSustainRt	$11, $12, $1F, $01
00010E76 =00000011                M spsr1	=	op1
00010E76 =00000012                M spsr2	=	op2
00010E76 =0000001F                M spsr3	=	op3
00010E76 =00000001                M spsr4	=	op4
00010E76                            	spDecayRt	$00, $00, $00, $00
00010E76 =00000000                M spdr1	=	op1
00010E76 =00000000                M spdr2	=	op2
00010E76 =00000000                M spdr3	=	op3
00010E76 =00000000                M spdr4	=	op4
00010E76                            	spSustainLv	$02, $0F, $00, $06
00010E76 =00000002                M spsl1	=	op1
00010E76 =0000000F                M spsl2	=	op2
00010E76 =00000000                M spsl3	=	op3
00010E76 =00000006                M spsl4	=	op4
00010E76                            	spReleaseRt	$0B, $09, $0B, $09
00010E76 =0000000B                M sprr1	=	op1
00010E76 =00000009                M sprr2	=	op2
00010E76 =0000000B                M sprr3	=	op3
00010E76 =00000009                M sprr4	=	op4
00010E76                            	spSSGEG		$00, $00, $00, $00
00010E76 =00000000                M spss1	=	op1
00010E76 =00000000                M spss2	=	op2
00010E76 =00000000                M spss3	=	op3
00010E76 =00000000                M spss4	=	op4
00010E76                            	spTotalLv	$2A, $13, $0C, $04
00010E76 =0000002A                M sptl1	=	op1
00010E76 =00000013                M sptl2	=	op2
00010E76 =0000000C                M sptl3	=	op3
00010E76 =00000004                M sptl4	=	op4
00010E76 34                       M 	dc.b	(spfe<<3)+spal
00010E77 =00000080                M sptlmask4	set	$80
00010E77 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E77 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010E77 =00000000                M sptlmask1	set	((spal=7)<<7)
00010E77 7402 6B02                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E7B 1F53 5311                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E7F 111F 1201                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E83 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E87 2B0B F969                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E8B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E8F 2A8C 1384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E93 4E41 54                  M 	dc.b	'NAT'
00010E96                            
00010E96                            	; Patch $04
00010E96                            	; $24
00010E96                            	; $10, $01, $31, $11,	$9B, $5C, $1B, $5C
00010E96                            	; $0A, $10, $0A, $10,	$03, $04, $03, $04
00010E96                            	; $1F, $0C, $8F, $0C,	$06, $05, $04, $05
00010E96                            	spAlgorithm	$04
00010E96 =00000005                M spatnum	=	spatnum+1
00010E96 =00000004                M spal	=	val
00010E96                            	spFeedback	$04
00010E96 =00000004                M spfe	=	val
00010E96                            	spDetune	$01, $03, $00, $01
00010E96 =00000001                M spde1	=	op1
00010E96 =00000003                M spde2	=	op2
00010E96 =00000000                M spde3	=	op3
00010E96 =00000001                M spde4	=	op4
00010E96                            	spMultiple	$00, $01, $01, $01
00010E96 =00000000                M spmu1	=	op1
00010E96 =00000001                M spmu2	=	op2
00010E96 =00000001                M spmu3	=	op3
00010E96 =00000001                M spmu4	=	op4
00010E96                            	spRateScale	$02, $00, $01, $01
00010E96 =00000002                M sprs1	=	op1
00010E96 =00000000                M sprs2	=	op2
00010E96 =00000001                M sprs3	=	op3
00010E96 =00000001                M sprs4	=	op4
00010E96                            	spAttackRt	$1B, $1B, $1C, $1C
00010E96 =0000001B                M spar1	=	op1
00010E96 =0000001B                M spar2	=	op2
00010E96 =0000001C                M spar3	=	op3
00010E96 =0000001C                M spar4	=	op4
00010E96                            	spAmpMod	$00, $00, $00, $00
00010E96 =00000000                M spam1	=	op1
00010E96 =00000000                M spam2	=	op2
00010E96 =00000000                M spam3	=	op3
00010E96 =00000000                M spam4	=	op4
00010E96                            	spSustainRt	$0A, $0A, $10, $10
00010E96 =0000000A                M spsr1	=	op1
00010E96 =0000000A                M spsr2	=	op2
00010E96 =00000010                M spsr3	=	op3
00010E96 =00000010                M spsr4	=	op4
00010E96                            	spDecayRt	$03, $03, $04, $04
00010E96 =00000003                M spdr1	=	op1
00010E96 =00000003                M spdr2	=	op2
00010E96 =00000004                M spdr3	=	op3
00010E96 =00000004                M spdr4	=	op4
00010E96                            	spSustainLv	$01, $08, $00, $00
00010E96 =00000001                M spsl1	=	op1
00010E96 =00000008                M spsl2	=	op2
00010E96 =00000000                M spsl3	=	op3
00010E96 =00000000                M spsl4	=	op4
00010E96                            	spReleaseRt	$0F, $0F, $0C, $0C
00010E96 =0000000F                M sprr1	=	op1
00010E96 =0000000F                M sprr2	=	op2
00010E96 =0000000C                M sprr3	=	op3
00010E96 =0000000C                M sprr4	=	op4
00010E96                            	spSSGEG		$00, $00, $00, $00
00010E96 =00000000                M spss1	=	op1
00010E96 =00000000                M spss2	=	op2
00010E96 =00000000                M spss3	=	op3
00010E96 =00000000                M spss4	=	op4
00010E96                            	spTotalLv	$06, $04, $05, $05
00010E96 =00000006                M sptl1	=	op1
00010E96 =00000004                M sptl2	=	op2
00010E96 =00000005                M sptl3	=	op3
00010E96 =00000005                M sptl4	=	op4
00010E96 24                       M 	dc.b	(spfe<<3)+spal
00010E97 =00000080                M sptlmask4	set	$80
00010E97 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E97 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010E97 =00000000                M sptlmask1	set	((spal=7)<<7)
00010E97 1001 3111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E9B 9B5C 1B5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E9F 0A10 0A10                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EA3 0304 0304                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EA7 1F0C 8F0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EAB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010EAF 0685 0485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010EB3 4E41 54                  M 	dc.b	'NAT'
00010EB6                            
00010EB6                            	; Patch $05
00010EB6                            	; $38
00010EB6                            	; $56, $15, $10, $72,	$1F, $1F, $1F, $1F
00010EB6                            	; $08, $08, $0A, $00,	$07, $07, $07, $06
00010EB6                            	; $F0, $F5, $F6, $F8,	$2C, $28, $12, $05
00010EB6                            	spAlgorithm	$00
00010EB6 =00000006                M spatnum	=	spatnum+1
00010EB6 =00000000                M spal	=	val
00010EB6                            	spFeedback	$07
00010EB6 =00000007                M spfe	=	val
00010EB6                            	spDetune	$05, $01, $01, $07
00010EB6 =00000005                M spde1	=	op1
00010EB6 =00000001                M spde2	=	op2
00010EB6 =00000001                M spde3	=	op3
00010EB6 =00000007                M spde4	=	op4
00010EB6                            	spMultiple	$06, $00, $05, $02
00010EB6 =00000006                M spmu1	=	op1
00010EB6 =00000000                M spmu2	=	op2
00010EB6 =00000005                M spmu3	=	op3
00010EB6 =00000002                M spmu4	=	op4
00010EB6                            	spRateScale	$00, $00, $00, $00
00010EB6 =00000000                M sprs1	=	op1
00010EB6 =00000000                M sprs2	=	op2
00010EB6 =00000000                M sprs3	=	op3
00010EB6 =00000000                M sprs4	=	op4
00010EB6                            	spAttackRt	$1F, $1F, $1F, $1F
00010EB6 =0000001F                M spar1	=	op1
00010EB6 =0000001F                M spar2	=	op2
00010EB6 =0000001F                M spar3	=	op3
00010EB6 =0000001F                M spar4	=	op4
00010EB6                            	spAmpMod	$00, $00, $00, $00
00010EB6 =00000000                M spam1	=	op1
00010EB6 =00000000                M spam2	=	op2
00010EB6 =00000000                M spam3	=	op3
00010EB6 =00000000                M spam4	=	op4
00010EB6                            	spSustainRt	$08, $0A, $08, $00
00010EB6 =00000008                M spsr1	=	op1
00010EB6 =0000000A                M spsr2	=	op2
00010EB6 =00000008                M spsr3	=	op3
00010EB6 =00000000                M spsr4	=	op4
00010EB6                            	spDecayRt	$07, $07, $07, $06
00010EB6 =00000007                M spdr1	=	op1
00010EB6 =00000007                M spdr2	=	op2
00010EB6 =00000007                M spdr3	=	op3
00010EB6 =00000006                M spdr4	=	op4
00010EB6                            	spSustainLv	$0F, $0F, $0F, $0F
00010EB6 =0000000F                M spsl1	=	op1
00010EB6 =0000000F                M spsl2	=	op2
00010EB6 =0000000F                M spsl3	=	op3
00010EB6 =0000000F                M spsl4	=	op4
00010EB6                            	spReleaseRt	$00, $06, $05, $08
00010EB6 =00000000                M sprr1	=	op1
00010EB6 =00000006                M sprr2	=	op2
00010EB6 =00000005                M sprr3	=	op3
00010EB6 =00000008                M sprr4	=	op4
00010EB6                            	spSSGEG		$00, $00, $00, $00
00010EB6 =00000000                M spss1	=	op1
00010EB6 =00000000                M spss2	=	op2
00010EB6 =00000000                M spss3	=	op3
00010EB6 =00000000                M spss4	=	op4
00010EB6                            	spTotalLv	$2C, $12, $28, $05
00010EB6 =0000002C                M sptl1	=	op1
00010EB6 =00000012                M sptl2	=	op2
00010EB6 =00000028                M sptl3	=	op3
00010EB6 =00000005                M sptl4	=	op4
00010EB6 38                       M 	dc.b	(spfe<<3)+spal
00010EB7 =00000080                M sptlmask4	set	$80
00010EB7 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010EB7 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010EB7 =00000000                M sptlmask1	set	((spal=7)<<7)
00010EB7 5615 1072                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EBB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EBF 0808 0A00                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EC3 0707 0706                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EC7 F0F5 F6F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010ECB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010ECF 2C28 1285                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010ED3 4E41 54                  M 	dc.b	'NAT'
00010ED6                            
00010ED6                            	; Patch $06
00010ED6                            	; $02
00010ED6                            	; $71, $32, $06, $01,	$5F, $5E, $9F, $9C
00010ED6                            	; $02, $06, $05, $04,	$08, $07, $08, $07
00010ED6                            	; $F8, $F8, $F8, $F8,	$00, $10, $07, $05
00010ED6                            	spAlgorithm	$02
00010ED6 =00000007                M spatnum	=	spatnum+1
00010ED6 =00000002                M spal	=	val
00010ED6                            	spFeedback	$00
00010ED6 =00000000                M spfe	=	val
00010ED6                            	spDetune	$07, $00, $03, $00
00010ED6 =00000007                M spde1	=	op1
00010ED6 =00000000                M spde2	=	op2
00010ED6 =00000003                M spde3	=	op3
00010ED6 =00000000                M spde4	=	op4
00010ED6                            	spMultiple	$01, $06, $02, $01
00010ED6 =00000001                M spmu1	=	op1
00010ED6 =00000006                M spmu2	=	op2
00010ED6 =00000002                M spmu3	=	op3
00010ED6 =00000001                M spmu4	=	op4
00010ED6                            	spRateScale	$01, $02, $01, $02
00010ED6 =00000001                M sprs1	=	op1
00010ED6 =00000002                M sprs2	=	op2
00010ED6 =00000001                M sprs3	=	op3
00010ED6 =00000002                M sprs4	=	op4
00010ED6                            	spAttackRt	$1F, $1F, $1E, $1C
00010ED6 =0000001F                M spar1	=	op1
00010ED6 =0000001F                M spar2	=	op2
00010ED6 =0000001E                M spar3	=	op3
00010ED6 =0000001C                M spar4	=	op4
00010ED6                            	spAmpMod	$00, $00, $00, $00
00010ED6 =00000000                M spam1	=	op1
00010ED6 =00000000                M spam2	=	op2
00010ED6 =00000000                M spam3	=	op3
00010ED6 =00000000                M spam4	=	op4
00010ED6                            	spSustainRt	$02, $05, $06, $04
00010ED6 =00000002                M spsr1	=	op1
00010ED6 =00000005                M spsr2	=	op2
00010ED6 =00000006                M spsr3	=	op3
00010ED6 =00000004                M spsr4	=	op4
00010ED6                            	spDecayRt	$08, $08, $07, $07
00010ED6 =00000008                M spdr1	=	op1
00010ED6 =00000008                M spdr2	=	op2
00010ED6 =00000007                M spdr3	=	op3
00010ED6 =00000007                M spdr4	=	op4
00010ED6                            	spSustainLv	$0F, $0F, $0F, $0F
00010ED6 =0000000F                M spsl1	=	op1
00010ED6 =0000000F                M spsl2	=	op2
00010ED6 =0000000F                M spsl3	=	op3
00010ED6 =0000000F                M spsl4	=	op4
00010ED6                            	spReleaseRt	$08, $08, $08, $08
00010ED6 =00000008                M sprr1	=	op1
00010ED6 =00000008                M sprr2	=	op2
00010ED6 =00000008                M sprr3	=	op3
00010ED6 =00000008                M sprr4	=	op4
00010ED6                            	spSSGEG		$00, $00, $00, $00
00010ED6 =00000000                M spss1	=	op1
00010ED6 =00000000                M spss2	=	op2
00010ED6 =00000000                M spss3	=	op3
00010ED6 =00000000                M spss4	=	op4
00010ED6                            	spTotalLv	$00, $07, $10, $05
00010ED6 =00000000                M sptl1	=	op1
00010ED6 =00000007                M sptl2	=	op2
00010ED6 =00000010                M sptl3	=	op3
00010ED6 =00000005                M sptl4	=	op4
00010ED6 02                       M 	dc.b	(spfe<<3)+spal
00010ED7 =00000080                M sptlmask4	set	$80
00010ED7 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010ED7 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010ED7 =00000000                M sptlmask1	set	((spal=7)<<7)
00010ED7 7132 0601                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EDB 5F5E 9F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EDF 0206 0504                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EE3 0807 0807                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EE7 F8F8 F8F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EEB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010EEF 0010 0785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010EF3 4E41 54                  M 	dc.b	'NAT'
00010EF6                            
00010EF6                            	; Patch $07
00010EF6                            	; $3D
00010EF6                            	; $01, $01, $01, $01,	$8E, $52, $14, $4C
00010EF6                            	; $08, $08, $0E, $03,	$00, $00, $00, $00
00010EF6                            	; $1F, $1F, $1F, $1F,	$1B, $05, $05, $05
00010EF6                            	spAlgorithm	$05
00010EF6 =00000008                M spatnum	=	spatnum+1
00010EF6 =00000005                M spal	=	val
00010EF6                            	spFeedback	$07
00010EF6 =00000007                M spfe	=	val
00010EF6                            	spDetune	$00, $00, $00, $00
00010EF6 =00000000                M spde1	=	op1
00010EF6 =00000000                M spde2	=	op2
00010EF6 =00000000                M spde3	=	op3
00010EF6 =00000000                M spde4	=	op4
00010EF6                            	spMultiple	$01, $01, $01, $01
00010EF6 =00000001                M spmu1	=	op1
00010EF6 =00000001                M spmu2	=	op2
00010EF6 =00000001                M spmu3	=	op3
00010EF6 =00000001                M spmu4	=	op4
00010EF6                            	spRateScale	$02, $00, $01, $01
00010EF6 =00000002                M sprs1	=	op1
00010EF6 =00000000                M sprs2	=	op2
00010EF6 =00000001                M sprs3	=	op3
00010EF6 =00000001                M sprs4	=	op4
00010EF6                            	spAttackRt	$0E, $14, $12, $0C
00010EF6 =0000000E                M spar1	=	op1
00010EF6 =00000014                M spar2	=	op2
00010EF6 =00000012                M spar3	=	op3
00010EF6 =0000000C                M spar4	=	op4
00010EF6                            	spAmpMod	$00, $00, $00, $00
00010EF6 =00000000                M spam1	=	op1
00010EF6 =00000000                M spam2	=	op2
00010EF6 =00000000                M spam3	=	op3
00010EF6 =00000000                M spam4	=	op4
00010EF6                            	spSustainRt	$08, $0E, $08, $03
00010EF6 =00000008                M spsr1	=	op1
00010EF6 =0000000E                M spsr2	=	op2
00010EF6 =00000008                M spsr3	=	op3
00010EF6 =00000003                M spsr4	=	op4
00010EF6                            	spDecayRt	$00, $00, $00, $00
00010EF6 =00000000                M spdr1	=	op1
00010EF6 =00000000                M spdr2	=	op2
00010EF6 =00000000                M spdr3	=	op3
00010EF6 =00000000                M spdr4	=	op4
00010EF6                            	spSustainLv	$01, $01, $01, $01
00010EF6 =00000001                M spsl1	=	op1
00010EF6 =00000001                M spsl2	=	op2
00010EF6 =00000001                M spsl3	=	op3
00010EF6 =00000001                M spsl4	=	op4
00010EF6                            	spReleaseRt	$0F, $0F, $0F, $0F
00010EF6 =0000000F                M sprr1	=	op1
00010EF6 =0000000F                M sprr2	=	op2
00010EF6 =0000000F                M sprr3	=	op3
00010EF6 =0000000F                M sprr4	=	op4
00010EF6                            	spSSGEG		$00, $00, $00, $00
00010EF6 =00000000                M spss1	=	op1
00010EF6 =00000000                M spss2	=	op2
00010EF6 =00000000                M spss3	=	op3
00010EF6 =00000000                M spss4	=	op4
00010EF6                            	spTotalLv	$1B, $05, $05, $05
00010EF6 =0000001B                M sptl1	=	op1
00010EF6 =00000005                M sptl2	=	op2
00010EF6 =00000005                M sptl3	=	op3
00010EF6 =00000005                M sptl4	=	op4
00010EF6 3D                       M 	dc.b	(spfe<<3)+spal
00010EF7 =00000080                M sptlmask4	set	$80
00010EF7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010EF7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010EF7 =00000000                M sptlmask1	set	((spal=7)<<7)
00010EF7 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EFB 8E52 144C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EFF 0808 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F03 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F07 1F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F0B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F0F 1B85 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F13 4E41 54                  M 	dc.b	'NAT'
00010F16                            
00010F16                            	; Patch $08
00010F16                            	; $0D
00010F16                            	; $77, $65, $05, $15,	$1F, $5F, $5F, $5F
00010F16                            	; $00, $10, $08, $10,	$00, $03, $05, $04
00010F16                            	; $0F, $FC, $8C, $CC,	$1F, $05, $05, $05
00010F16                            	spAlgorithm	$05
00010F16 =00000009                M spatnum	=	spatnum+1
00010F16 =00000005                M spal	=	val
00010F16                            	spFeedback	$01
00010F16 =00000001                M spfe	=	val
00010F16                            	spDetune	$07, $00, $06, $01
00010F16 =00000007                M spde1	=	op1
00010F16 =00000000                M spde2	=	op2
00010F16 =00000006                M spde3	=	op3
00010F16 =00000001                M spde4	=	op4
00010F16                            	spMultiple	$07, $05, $05, $05
00010F16 =00000007                M spmu1	=	op1
00010F16 =00000005                M spmu2	=	op2
00010F16 =00000005                M spmu3	=	op3
00010F16 =00000005                M spmu4	=	op4
00010F16                            	spRateScale	$00, $01, $01, $01
00010F16 =00000000                M sprs1	=	op1
00010F16 =00000001                M sprs2	=	op2
00010F16 =00000001                M sprs3	=	op3
00010F16 =00000001                M sprs4	=	op4
00010F16                            	spAttackRt	$1F, $1F, $1F, $1F
00010F16 =0000001F                M spar1	=	op1
00010F16 =0000001F                M spar2	=	op2
00010F16 =0000001F                M spar3	=	op3
00010F16 =0000001F                M spar4	=	op4
00010F16                            	spAmpMod	$00, $00, $00, $00
00010F16 =00000000                M spam1	=	op1
00010F16 =00000000                M spam2	=	op2
00010F16 =00000000                M spam3	=	op3
00010F16 =00000000                M spam4	=	op4
00010F16                            	spSustainRt	$00, $08, $10, $10
00010F16 =00000000                M spsr1	=	op1
00010F16 =00000008                M spsr2	=	op2
00010F16 =00000010                M spsr3	=	op3
00010F16 =00000010                M spsr4	=	op4
00010F16                            	spDecayRt	$00, $05, $03, $04
00010F16 =00000000                M spdr1	=	op1
00010F16 =00000005                M spdr2	=	op2
00010F16 =00000003                M spdr3	=	op3
00010F16 =00000004                M spdr4	=	op4
00010F16                            	spSustainLv	$00, $08, $0F, $0C
00010F16 =00000000                M spsl1	=	op1
00010F16 =00000008                M spsl2	=	op2
00010F16 =0000000F                M spsl3	=	op3
00010F16 =0000000C                M spsl4	=	op4
00010F16                            	spReleaseRt	$0F, $0C, $0C, $0C
00010F16 =0000000F                M sprr1	=	op1
00010F16 =0000000C                M sprr2	=	op2
00010F16 =0000000C                M sprr3	=	op3
00010F16 =0000000C                M sprr4	=	op4
00010F16                            	spSSGEG		$00, $00, $00, $00
00010F16 =00000000                M spss1	=	op1
00010F16 =00000000                M spss2	=	op2
00010F16 =00000000                M spss3	=	op3
00010F16 =00000000                M spss4	=	op4
00010F16                            	spTotalLv	$1F, $05, $05, $05
00010F16 =0000001F                M sptl1	=	op1
00010F16 =00000005                M sptl2	=	op2
00010F16 =00000005                M sptl3	=	op3
00010F16 =00000005                M sptl4	=	op4
00010F16 0D                       M 	dc.b	(spfe<<3)+spal
00010F17 =00000080                M sptlmask4	set	$80
00010F17 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010F17 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F17 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F17 7765 0515                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F1B 1F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F1F 0010 0810                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F23 0003 0504                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F27 0FFC 8CCC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F2B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F2F 1F85 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F33 4E41 54                  M 	dc.b	'NAT'
00010F36                            
00010F36                            	; Patch $09
00010F36                            	; $32
00010F36                            	; $71, $0D, $33, $01,	$5F, $99, $5F, $94
00010F36                            	; $05, $05, $05, $07,	$02, $02, $02, $02
00010F36                            	; $11, $11, $11, $72,	$23, $2D, $26, $05
00010F36                            	spAlgorithm	$02
00010F36 =0000000A                M spatnum	=	spatnum+1
00010F36 =00000002                M spal	=	val
00010F36                            	spFeedback	$06
00010F36 =00000006                M spfe	=	val
00010F36                            	spDetune	$07, $03, $00, $00
00010F36 =00000007                M spde1	=	op1
00010F36 =00000003                M spde2	=	op2
00010F36 =00000000                M spde3	=	op3
00010F36 =00000000                M spde4	=	op4
00010F36                            	spMultiple	$01, $03, $0D, $01
00010F36 =00000001                M spmu1	=	op1
00010F36 =00000003                M spmu2	=	op2
00010F36 =0000000D                M spmu3	=	op3
00010F36 =00000001                M spmu4	=	op4
00010F36                            	spRateScale	$01, $01, $02, $02
00010F36 =00000001                M sprs1	=	op1
00010F36 =00000001                M sprs2	=	op2
00010F36 =00000002                M sprs3	=	op3
00010F36 =00000002                M sprs4	=	op4
00010F36                            	spAttackRt	$1F, $1F, $19, $14
00010F36 =0000001F                M spar1	=	op1
00010F36 =0000001F                M spar2	=	op2
00010F36 =00000019                M spar3	=	op3
00010F36 =00000014                M spar4	=	op4
00010F36                            	spAmpMod	$00, $00, $00, $00
00010F36 =00000000                M spam1	=	op1
00010F36 =00000000                M spam2	=	op2
00010F36 =00000000                M spam3	=	op3
00010F36 =00000000                M spam4	=	op4
00010F36                            	spSustainRt	$05, $05, $05, $07
00010F36 =00000005                M spsr1	=	op1
00010F36 =00000005                M spsr2	=	op2
00010F36 =00000005                M spsr3	=	op3
00010F36 =00000007                M spsr4	=	op4
00010F36                            	spDecayRt	$02, $02, $02, $02
00010F36 =00000002                M spdr1	=	op1
00010F36 =00000002                M spdr2	=	op2
00010F36 =00000002                M spdr3	=	op3
00010F36 =00000002                M spdr4	=	op4
00010F36                            	spSustainLv	$01, $01, $01, $07
00010F36 =00000001                M spsl1	=	op1
00010F36 =00000001                M spsl2	=	op2
00010F36 =00000001                M spsl3	=	op3
00010F36 =00000007                M spsl4	=	op4
00010F36                            	spReleaseRt	$01, $01, $01, $02
00010F36 =00000001                M sprr1	=	op1
00010F36 =00000001                M sprr2	=	op2
00010F36 =00000001                M sprr3	=	op3
00010F36 =00000002                M sprr4	=	op4
00010F36                            	spSSGEG		$00, $00, $00, $00
00010F36 =00000000                M spss1	=	op1
00010F36 =00000000                M spss2	=	op2
00010F36 =00000000                M spss3	=	op3
00010F36 =00000000                M spss4	=	op4
00010F36                            	spTotalLv	$23, $26, $2D, $05
00010F36 =00000023                M sptl1	=	op1
00010F36 =00000026                M sptl2	=	op2
00010F36 =0000002D                M sptl3	=	op3
00010F36 =00000005                M sptl4	=	op4
00010F36 32                       M 	dc.b	(spfe<<3)+spal
00010F37 =00000080                M sptlmask4	set	$80
00010F37 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F37 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010F37 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F37 710D 3301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F3B 5F99 5F94                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F3F 0505 0507                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F43 0202 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F47 1111 1172                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F4B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F4F 232D 2685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F53 4E41 54                  M 	dc.b	'NAT'
00010F56                            
00010F56                            	; Patch $0A
00010F56                            	; $08
00010F56                            	; $0A, $70, $30, $00,	$1F, $1F, $5F, $5F
00010F56                            	; $12, $0E, $0A, $0A,	$00, $04, $04, $03
00010F56                            	; $2F, $2F, $2F, $2F,	$22, $2E, $13, $04
00010F56                            	spAlgorithm	$00
00010F56 =0000000B                M spatnum	=	spatnum+1
00010F56 =00000000                M spal	=	val
00010F56                            	spFeedback	$01
00010F56 =00000001                M spfe	=	val
00010F56                            	spDetune	$00, $03, $07, $00
00010F56 =00000000                M spde1	=	op1
00010F56 =00000003                M spde2	=	op2
00010F56 =00000007                M spde3	=	op3
00010F56 =00000000                M spde4	=	op4
00010F56                            	spMultiple	$0A, $00, $00, $00
00010F56 =0000000A                M spmu1	=	op1
00010F56 =00000000                M spmu2	=	op2
00010F56 =00000000                M spmu3	=	op3
00010F56 =00000000                M spmu4	=	op4
00010F56                            	spRateScale	$00, $01, $00, $01
00010F56 =00000000                M sprs1	=	op1
00010F56 =00000001                M sprs2	=	op2
00010F56 =00000000                M sprs3	=	op3
00010F56 =00000001                M sprs4	=	op4
00010F56                            	spAttackRt	$1F, $1F, $1F, $1F
00010F56 =0000001F                M spar1	=	op1
00010F56 =0000001F                M spar2	=	op2
00010F56 =0000001F                M spar3	=	op3
00010F56 =0000001F                M spar4	=	op4
00010F56                            	spAmpMod	$00, $00, $00, $00
00010F56 =00000000                M spam1	=	op1
00010F56 =00000000                M spam2	=	op2
00010F56 =00000000                M spam3	=	op3
00010F56 =00000000                M spam4	=	op4
00010F56                            	spSustainRt	$12, $0A, $0E, $0A
00010F56 =00000012                M spsr1	=	op1
00010F56 =0000000A                M spsr2	=	op2
00010F56 =0000000E                M spsr3	=	op3
00010F56 =0000000A                M spsr4	=	op4
00010F56                            	spDecayRt	$00, $04, $04, $03
00010F56 =00000000                M spdr1	=	op1
00010F56 =00000004                M spdr2	=	op2
00010F56 =00000004                M spdr3	=	op3
00010F56 =00000003                M spdr4	=	op4
00010F56                            	spSustainLv	$02, $02, $02, $02
00010F56 =00000002                M spsl1	=	op1
00010F56 =00000002                M spsl2	=	op2
00010F56 =00000002                M spsl3	=	op3
00010F56 =00000002                M spsl4	=	op4
00010F56                            	spReleaseRt	$0F, $0F, $0F, $0F
00010F56 =0000000F                M sprr1	=	op1
00010F56 =0000000F                M sprr2	=	op2
00010F56 =0000000F                M sprr3	=	op3
00010F56 =0000000F                M sprr4	=	op4
00010F56                            	spSSGEG		$00, $00, $00, $00
00010F56 =00000000                M spss1	=	op1
00010F56 =00000000                M spss2	=	op2
00010F56 =00000000                M spss3	=	op3
00010F56 =00000000                M spss4	=	op4
00010F56                            	spTotalLv	$22, $13, $2E, $04
00010F56 =00000022                M sptl1	=	op1
00010F56 =00000013                M sptl2	=	op2
00010F56 =0000002E                M sptl3	=	op3
00010F56 =00000004                M sptl4	=	op4
00010F56 08                       M 	dc.b	(spfe<<3)+spal
00010F57 =00000080                M sptlmask4	set	$80
00010F57 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F57 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010F57 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F57 0A70 3000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F5B 1F1F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F5F 120E 0A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F63 0004 0403                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F67 2F2F 2F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F6B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F6F 222E 1384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F73 4E41 54                  M 	dc.b	'NAT'
00010F76                            
00010F76                            	; Patch $0B
00010F76                            	; $28
00010F76                            	; $39, $35, $30, $31,	$1F, $1F, $1F, $1F
00010F76                            	; $0C, $0A, $07, $0A,	$07, $07, $07, $09
00010F76                            	; $26, $16, $16, $F6,	$17, $32, $14, $05
00010F76                            	spAlgorithm	$00
00010F76 =0000000C                M spatnum	=	spatnum+1
00010F76 =00000000                M spal	=	val
00010F76                            	spFeedback	$05
00010F76 =00000005                M spfe	=	val
00010F76                            	spDetune	$03, $03, $03, $03
00010F76 =00000003                M spde1	=	op1
00010F76 =00000003                M spde2	=	op2
00010F76 =00000003                M spde3	=	op3
00010F76 =00000003                M spde4	=	op4
00010F76                            	spMultiple	$09, $00, $05, $01
00010F76 =00000009                M spmu1	=	op1
00010F76 =00000000                M spmu2	=	op2
00010F76 =00000005                M spmu3	=	op3
00010F76 =00000001                M spmu4	=	op4
00010F76                            	spRateScale	$00, $00, $00, $00
00010F76 =00000000                M sprs1	=	op1
00010F76 =00000000                M sprs2	=	op2
00010F76 =00000000                M sprs3	=	op3
00010F76 =00000000                M sprs4	=	op4
00010F76                            	spAttackRt	$1F, $1F, $1F, $1F
00010F76 =0000001F                M spar1	=	op1
00010F76 =0000001F                M spar2	=	op2
00010F76 =0000001F                M spar3	=	op3
00010F76 =0000001F                M spar4	=	op4
00010F76                            	spAmpMod	$00, $00, $00, $00
00010F76 =00000000                M spam1	=	op1
00010F76 =00000000                M spam2	=	op2
00010F76 =00000000                M spam3	=	op3
00010F76 =00000000                M spam4	=	op4
00010F76                            	spSustainRt	$0C, $07, $0A, $0A
00010F76 =0000000C                M spsr1	=	op1
00010F76 =00000007                M spsr2	=	op2
00010F76 =0000000A                M spsr3	=	op3
00010F76 =0000000A                M spsr4	=	op4
00010F76                            	spDecayRt	$07, $07, $07, $09
00010F76 =00000007                M spdr1	=	op1
00010F76 =00000007                M spdr2	=	op2
00010F76 =00000007                M spdr3	=	op3
00010F76 =00000009                M spdr4	=	op4
00010F76                            	spSustainLv	$02, $01, $01, $0F
00010F76 =00000002                M spsl1	=	op1
00010F76 =00000001                M spsl2	=	op2
00010F76 =00000001                M spsl3	=	op3
00010F76 =0000000F                M spsl4	=	op4
00010F76                            	spReleaseRt	$06, $06, $06, $06
00010F76 =00000006                M sprr1	=	op1
00010F76 =00000006                M sprr2	=	op2
00010F76 =00000006                M sprr3	=	op3
00010F76 =00000006                M sprr4	=	op4
00010F76                            	spSSGEG		$00, $00, $00, $00
00010F76 =00000000                M spss1	=	op1
00010F76 =00000000                M spss2	=	op2
00010F76 =00000000                M spss3	=	op3
00010F76 =00000000                M spss4	=	op4
00010F76                            	spTotalLv	$17, $14, $32, $05
00010F76 =00000017                M sptl1	=	op1
00010F76 =00000014                M sptl2	=	op2
00010F76 =00000032                M sptl3	=	op3
00010F76 =00000005                M sptl4	=	op4
00010F76 28                       M 	dc.b	(spfe<<3)+spal
00010F77 =00000080                M sptlmask4	set	$80
00010F77 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F77 =00000000                M sptlmask3	set	((spal>=4)<<7)
00010F77 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F77 3935 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F7B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F7F 0C0A 070A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F83 0707 0709                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F87 2616 16F6                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F8B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F8F 1732 1485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F93 4E41 54                  M 	dc.b	'NAT'
00010F96                            
00010F96                            	; Patch $0C
00010F96                            	; $3D
00010F96                            	; $6F, $22, $62, $22,	$1F, $1F, $1F, $1F
00010F96                            	; $0F, $0F, $0F, $0F,	$08, $08, $08, $08
00010F96                            	; $25, $25, $25, $25,	$1E, $36, $05, $09
00010F96                            	spAlgorithm	$05
00010F96 =0000000D                M spatnum	=	spatnum+1
00010F96 =00000005                M spal	=	val
00010F96                            	spFeedback	$07
00010F96 =00000007                M spfe	=	val
00010F96                            	spDetune	$06, $06, $02, $02
00010F96 =00000006                M spde1	=	op1
00010F96 =00000006                M spde2	=	op2
00010F96 =00000002                M spde3	=	op3
00010F96 =00000002                M spde4	=	op4
00010F96                            	spMultiple	$0F, $02, $02, $02
00010F96 =0000000F                M spmu1	=	op1
00010F96 =00000002                M spmu2	=	op2
00010F96 =00000002                M spmu3	=	op3
00010F96 =00000002                M spmu4	=	op4
00010F96                            	spRateScale	$00, $00, $00, $00
00010F96 =00000000                M sprs1	=	op1
00010F96 =00000000                M sprs2	=	op2
00010F96 =00000000                M sprs3	=	op3
00010F96 =00000000                M sprs4	=	op4
00010F96                            	spAttackRt	$1F, $1F, $1F, $1F
00010F96 =0000001F                M spar1	=	op1
00010F96 =0000001F                M spar2	=	op2
00010F96 =0000001F                M spar3	=	op3
00010F96 =0000001F                M spar4	=	op4
00010F96                            	spAmpMod	$00, $00, $00, $00
00010F96 =00000000                M spam1	=	op1
00010F96 =00000000                M spam2	=	op2
00010F96 =00000000                M spam3	=	op3
00010F96 =00000000                M spam4	=	op4
00010F96                            	spSustainRt	$0F, $0F, $0F, $0F
00010F96 =0000000F                M spsr1	=	op1
00010F96 =0000000F                M spsr2	=	op2
00010F96 =0000000F                M spsr3	=	op3
00010F96 =0000000F                M spsr4	=	op4
00010F96                            	spDecayRt	$08, $08, $08, $08
00010F96 =00000008                M spdr1	=	op1
00010F96 =00000008                M spdr2	=	op2
00010F96 =00000008                M spdr3	=	op3
00010F96 =00000008                M spdr4	=	op4
00010F96                            	spSustainLv	$02, $02, $02, $02
00010F96 =00000002                M spsl1	=	op1
00010F96 =00000002                M spsl2	=	op2
00010F96 =00000002                M spsl3	=	op3
00010F96 =00000002                M spsl4	=	op4
00010F96                            	spReleaseRt	$05, $05, $05, $05
00010F96 =00000005                M sprr1	=	op1
00010F96 =00000005                M sprr2	=	op2
00010F96 =00000005                M sprr3	=	op3
00010F96 =00000005                M sprr4	=	op4
00010F96                            	spSSGEG		$00, $00, $00, $00
00010F96 =00000000                M spss1	=	op1
00010F96 =00000000                M spss2	=	op2
00010F96 =00000000                M spss3	=	op3
00010F96 =00000000                M spss4	=	op4
00010F96                            	spTotalLv	$1E, $05, $36, $09
00010F96 =0000001E                M sptl1	=	op1
00010F96 =00000005                M sptl2	=	op2
00010F96 =00000036                M sptl3	=	op3
00010F96 =00000009                M sptl4	=	op4
00010F96 3D                       M 	dc.b	(spfe<<3)+spal
00010F97 =00000080                M sptlmask4	set	$80
00010F97 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010F97 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F97 =00000000                M sptlmask1	set	((spal=7)<<7)
00010F97 6F22 6222                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F9B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F9F 0F0F 0F0F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FA3 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FA7 2525 2525                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FAB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FAF 1EB6 8589                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FB3 4E41 54                  M 	dc.b	'NAT'
00010FB6                            
00010FB6                            	; Patch $0D
00010FB6                            	; $06
00010FB6                            	; $61, $03, $32, $71,	$1F, $1F, $1F, $1F
00010FB6                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00010FB6                            	; $07, $07, $07, $07,	$1E, $0A, $05, $05
00010FB6                            	spAlgorithm	$06
00010FB6 =0000000E                M spatnum	=	spatnum+1
00010FB6 =00000006                M spal	=	val
00010FB6                            	spFeedback	$00
00010FB6 =00000000                M spfe	=	val
00010FB6                            	spDetune	$06, $03, $00, $07
00010FB6 =00000006                M spde1	=	op1
00010FB6 =00000003                M spde2	=	op2
00010FB6 =00000000                M spde3	=	op3
00010FB6 =00000007                M spde4	=	op4
00010FB6                            	spMultiple	$01, $02, $03, $01
00010FB6 =00000001                M spmu1	=	op1
00010FB6 =00000002                M spmu2	=	op2
00010FB6 =00000003                M spmu3	=	op3
00010FB6 =00000001                M spmu4	=	op4
00010FB6                            	spRateScale	$00, $00, $00, $00
00010FB6 =00000000                M sprs1	=	op1
00010FB6 =00000000                M sprs2	=	op2
00010FB6 =00000000                M sprs3	=	op3
00010FB6 =00000000                M sprs4	=	op4
00010FB6                            	spAttackRt	$1F, $1F, $1F, $1F
00010FB6 =0000001F                M spar1	=	op1
00010FB6 =0000001F                M spar2	=	op2
00010FB6 =0000001F                M spar3	=	op3
00010FB6 =0000001F                M spar4	=	op4
00010FB6                            	spAmpMod	$00, $00, $00, $00
00010FB6 =00000000                M spam1	=	op1
00010FB6 =00000000                M spam2	=	op2
00010FB6 =00000000                M spam3	=	op3
00010FB6 =00000000                M spam4	=	op4
00010FB6                            	spSustainRt	$00, $00, $00, $00
00010FB6 =00000000                M spsr1	=	op1
00010FB6 =00000000                M spsr2	=	op2
00010FB6 =00000000                M spsr3	=	op3
00010FB6 =00000000                M spsr4	=	op4
00010FB6                            	spDecayRt	$00, $00, $00, $00
00010FB6 =00000000                M spdr1	=	op1
00010FB6 =00000000                M spdr2	=	op2
00010FB6 =00000000                M spdr3	=	op3
00010FB6 =00000000                M spdr4	=	op4
00010FB6                            	spSustainLv	$00, $00, $00, $00
00010FB6 =00000000                M spsl1	=	op1
00010FB6 =00000000                M spsl2	=	op2
00010FB6 =00000000                M spsl3	=	op3
00010FB6 =00000000                M spsl4	=	op4
00010FB6                            	spReleaseRt	$07, $07, $07, $07
00010FB6 =00000007                M sprr1	=	op1
00010FB6 =00000007                M sprr2	=	op2
00010FB6 =00000007                M sprr3	=	op3
00010FB6 =00000007                M sprr4	=	op4
00010FB6                            	spSSGEG		$00, $00, $00, $00
00010FB6 =00000000                M spss1	=	op1
00010FB6 =00000000                M spss2	=	op2
00010FB6 =00000000                M spss3	=	op3
00010FB6 =00000000                M spss4	=	op4
00010FB6                            	spTotalLv	$1E, $05, $0A, $05
00010FB6 =0000001E                M sptl1	=	op1
00010FB6 =00000005                M sptl2	=	op2
00010FB6 =0000000A                M sptl3	=	op3
00010FB6 =00000005                M sptl4	=	op4
00010FB6 06                       M 	dc.b	(spfe<<3)+spal
00010FB7 =00000080                M sptlmask4	set	$80
00010FB7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010FB7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010FB7 =00000000                M sptlmask1	set	((spal=7)<<7)
00010FB7 6103 3271                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FBB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FBF 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FC3 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FC7 0707 0707                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FCB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FCF 1E8A 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FD3 4E41 54                  M 	dc.b	'NAT'
00010FD6                            
00010FD6                            	; Patch $0E
00010FD6                            	; $24
00010FD6                            	; $31, $71, $61, $16,	$11, $55, $14, $55
00010FD6                            	; $1F, $01, $00, $04,	$00, $00, $00, $01
00010FD6                            	; $11, $97, $05, $A7,	$04, $05, $00, $05
00010FD6                            	spAlgorithm	$04
00010FD6 =0000000F                M spatnum	=	spatnum+1
00010FD6 =00000004                M spal	=	val
00010FD6                            	spFeedback	$04
00010FD6 =00000004                M spfe	=	val
00010FD6                            	spDetune	$03, $06, $07, $01
00010FD6 =00000003                M spde1	=	op1
00010FD6 =00000006                M spde2	=	op2
00010FD6 =00000007                M spde3	=	op3
00010FD6 =00000001                M spde4	=	op4
00010FD6                            	spMultiple	$01, $01, $01, $06
00010FD6 =00000001                M spmu1	=	op1
00010FD6 =00000001                M spmu2	=	op2
00010FD6 =00000001                M spmu3	=	op3
00010FD6 =00000006                M spmu4	=	op4
00010FD6                            	spRateScale	$00, $00, $01, $01
00010FD6 =00000000                M sprs1	=	op1
00010FD6 =00000000                M sprs2	=	op2
00010FD6 =00000001                M sprs3	=	op3
00010FD6 =00000001                M sprs4	=	op4
00010FD6                            	spAttackRt	$11, $14, $15, $15
00010FD6 =00000011                M spar1	=	op1
00010FD6 =00000014                M spar2	=	op2
00010FD6 =00000015                M spar3	=	op3
00010FD6 =00000015                M spar4	=	op4
00010FD6                            	spAmpMod	$00, $00, $00, $00
00010FD6 =00000000                M spam1	=	op1
00010FD6 =00000000                M spam2	=	op2
00010FD6 =00000000                M spam3	=	op3
00010FD6 =00000000                M spam4	=	op4
00010FD6                            	spSustainRt	$1F, $00, $01, $04
00010FD6 =0000001F                M spsr1	=	op1
00010FD6 =00000000                M spsr2	=	op2
00010FD6 =00000001                M spsr3	=	op3
00010FD6 =00000004                M spsr4	=	op4
00010FD6                            	spDecayRt	$00, $00, $00, $01
00010FD6 =00000000                M spdr1	=	op1
00010FD6 =00000000                M spdr2	=	op2
00010FD6 =00000000                M spdr3	=	op3
00010FD6 =00000001                M spdr4	=	op4
00010FD6                            	spSustainLv	$01, $00, $09, $0A
00010FD6 =00000001                M spsl1	=	op1
00010FD6 =00000000                M spsl2	=	op2
00010FD6 =00000009                M spsl3	=	op3
00010FD6 =0000000A                M spsl4	=	op4
00010FD6                            	spReleaseRt	$01, $05, $07, $07
00010FD6 =00000001                M sprr1	=	op1
00010FD6 =00000005                M sprr2	=	op2
00010FD6 =00000007                M sprr3	=	op3
00010FD6 =00000007                M sprr4	=	op4
00010FD6                            	spSSGEG		$00, $00, $00, $00
00010FD6 =00000000                M spss1	=	op1
00010FD6 =00000000                M spss2	=	op2
00010FD6 =00000000                M spss3	=	op3
00010FD6 =00000000                M spss4	=	op4
00010FD6                            	spTotalLv	$04, $00, $05, $05
00010FD6 =00000004                M sptl1	=	op1
00010FD6 =00000000                M sptl2	=	op2
00010FD6 =00000005                M sptl3	=	op3
00010FD6 =00000005                M sptl4	=	op4
00010FD6 24                       M 	dc.b	(spfe<<3)+spal
00010FD7 =00000080                M sptlmask4	set	$80
00010FD7 =00000000                M sptlmask2	set	((spal>=5)<<7)
00010FD7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010FD7 =00000000                M sptlmask1	set	((spal=7)<<7)
00010FD7 3171 6116                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FDB 1155 1455                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FDF 1F01 0004                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FE3 0000 0001                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FE7 1197 05A7                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FEB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FEF 0485 0085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FF3 4E41 54                  M 	dc.b	'NAT'
00010FF6                            
00010FF6                            	; Patch $0F
00010FF6                            	; $36
00010FF6                            	; $72, $02, $01, $01,	$D8, $47, $8D, $87
00010FF6                            	; $01, $04, $01, $05,	$00, $05, $07, $00
00010FF6                            	; $51, $14, $15, $14,	$11, $05, $7F, $7F
00010FF6                            	spAlgorithm	$06
00010FF6 =00000010                M spatnum	=	spatnum+1
00010FF6 =00000006                M spal	=	val
00010FF6                            	spFeedback	$06
00010FF6 =00000006                M spfe	=	val
00010FF6                            	spDetune	$07, $00, $00, $00
00010FF6 =00000007                M spde1	=	op1
00010FF6 =00000000                M spde2	=	op2
00010FF6 =00000000                M spde3	=	op3
00010FF6 =00000000                M spde4	=	op4
00010FF6                            	spMultiple	$02, $01, $02, $01
00010FF6 =00000002                M spmu1	=	op1
00010FF6 =00000001                M spmu2	=	op2
00010FF6 =00000002                M spmu3	=	op3
00010FF6 =00000001                M spmu4	=	op4
00010FF6                            	spRateScale	$03, $02, $01, $02
00010FF6 =00000003                M sprs1	=	op1
00010FF6 =00000002                M sprs2	=	op2
00010FF6 =00000001                M sprs3	=	op3
00010FF6 =00000002                M sprs4	=	op4
00010FF6                            	spAttackRt	$18, $0D, $07, $07
00010FF6 =00000018                M spar1	=	op1
00010FF6 =0000000D                M spar2	=	op2
00010FF6 =00000007                M spar3	=	op3
00010FF6 =00000007                M spar4	=	op4
00010FF6                            	spAmpMod	$00, $00, $00, $00
00010FF6 =00000000                M spam1	=	op1
00010FF6 =00000000                M spam2	=	op2
00010FF6 =00000000                M spam3	=	op3
00010FF6 =00000000                M spam4	=	op4
00010FF6                            	spSustainRt	$01, $01, $04, $05
00010FF6 =00000001                M spsr1	=	op1
00010FF6 =00000001                M spsr2	=	op2
00010FF6 =00000004                M spsr3	=	op3
00010FF6 =00000005                M spsr4	=	op4
00010FF6                            	spDecayRt	$00, $07, $05, $00
00010FF6 =00000000                M spdr1	=	op1
00010FF6 =00000007                M spdr2	=	op2
00010FF6 =00000005                M spdr3	=	op3
00010FF6 =00000000                M spdr4	=	op4
00010FF6                            	spSustainLv	$05, $01, $01, $01
00010FF6 =00000005                M spsl1	=	op1
00010FF6 =00000001                M spsl2	=	op2
00010FF6 =00000001                M spsl3	=	op3
00010FF6 =00000001                M spsl4	=	op4
00010FF6                            	spReleaseRt	$01, $05, $04, $04
00010FF6 =00000001                M sprr1	=	op1
00010FF6 =00000005                M sprr2	=	op2
00010FF6 =00000004                M sprr3	=	op3
00010FF6 =00000004                M sprr4	=	op4
00010FF6                            	spSSGEG		$00, $00, $00, $00
00010FF6 =00000000                M spss1	=	op1
00010FF6 =00000000                M spss2	=	op2
00010FF6 =00000000                M spss3	=	op3
00010FF6 =00000000                M spss4	=	op4
00010FF6                            	spTotalLv	$11, $7F, $05, $7F
00010FF6 =00000011                M sptl1	=	op1
00010FF6 =0000007F                M sptl2	=	op2
00010FF6 =00000005                M sptl3	=	op3
00010FF6 =0000007F                M sptl4	=	op4
00010FF6 36                       M 	dc.b	(spfe<<3)+spal
00010FF7 =00000080                M sptlmask4	set	$80
00010FF7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010FF7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010FF7 =00000000                M sptlmask1	set	((spal=7)<<7)
00010FF7 7202 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FFB D847 8D87                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FFF 0104 0105                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011003 0005 0700                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011007 5114 1514                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001100B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001100F 1185 FFFF                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011013 4E41 54                  M 	dc.b	'NAT'
00011016                            
00011016                            	; Patch $10
00011016                            	; $24
00011016                            	; $10, $01, $31, $11,	$9B, $5C, $1B, $5C
00011016                            	; $0A, $10, $0A, $10,	$03, $04, $03, $04
00011016                            	; $1F, $0C, $8F, $0C,	$06, $05, $04, $05
00011016                            	spAlgorithm	$04
00011016 =00000011                M spatnum	=	spatnum+1
00011016 =00000004                M spal	=	val
00011016                            	spFeedback	$04
00011016 =00000004                M spfe	=	val
00011016                            	spDetune	$01, $03, $00, $01
00011016 =00000001                M spde1	=	op1
00011016 =00000003                M spde2	=	op2
00011016 =00000000                M spde3	=	op3
00011016 =00000001                M spde4	=	op4
00011016                            	spMultiple	$00, $01, $01, $01
00011016 =00000000                M spmu1	=	op1
00011016 =00000001                M spmu2	=	op2
00011016 =00000001                M spmu3	=	op3
00011016 =00000001                M spmu4	=	op4
00011016                            	spRateScale	$02, $00, $01, $01
00011016 =00000002                M sprs1	=	op1
00011016 =00000000                M sprs2	=	op2
00011016 =00000001                M sprs3	=	op3
00011016 =00000001                M sprs4	=	op4
00011016                            	spAttackRt	$1B, $1B, $1C, $1C
00011016 =0000001B                M spar1	=	op1
00011016 =0000001B                M spar2	=	op2
00011016 =0000001C                M spar3	=	op3
00011016 =0000001C                M spar4	=	op4
00011016                            	spAmpMod	$00, $00, $00, $00
00011016 =00000000                M spam1	=	op1
00011016 =00000000                M spam2	=	op2
00011016 =00000000                M spam3	=	op3
00011016 =00000000                M spam4	=	op4
00011016                            	spSustainRt	$0A, $0A, $10, $10
00011016 =0000000A                M spsr1	=	op1
00011016 =0000000A                M spsr2	=	op2
00011016 =00000010                M spsr3	=	op3
00011016 =00000010                M spsr4	=	op4
00011016                            	spDecayRt	$03, $03, $04, $04
00011016 =00000003                M spdr1	=	op1
00011016 =00000003                M spdr2	=	op2
00011016 =00000004                M spdr3	=	op3
00011016 =00000004                M spdr4	=	op4
00011016                            	spSustainLv	$01, $08, $00, $00
00011016 =00000001                M spsl1	=	op1
00011016 =00000008                M spsl2	=	op2
00011016 =00000000                M spsl3	=	op3
00011016 =00000000                M spsl4	=	op4
00011016                            	spReleaseRt	$0F, $0F, $0C, $0C
00011016 =0000000F                M sprr1	=	op1
00011016 =0000000F                M sprr2	=	op2
00011016 =0000000C                M sprr3	=	op3
00011016 =0000000C                M sprr4	=	op4
00011016                            	spSSGEG		$00, $00, $00, $00
00011016 =00000000                M spss1	=	op1
00011016 =00000000                M spss2	=	op2
00011016 =00000000                M spss3	=	op3
00011016 =00000000                M spss4	=	op4
00011016                            	spTotalLv	$06, $04, $05, $05
00011016 =00000006                M sptl1	=	op1
00011016 =00000004                M sptl2	=	op2
00011016 =00000005                M sptl3	=	op3
00011016 =00000005                M sptl4	=	op4
00011016 24                       M 	dc.b	(spfe<<3)+spal
00011017 =00000080                M sptlmask4	set	$80
00011017 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011017 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011017 =00000000                M sptlmask1	set	((spal=7)<<7)
00011017 1001 3111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001101B 9B5C 1B5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001101F 0A10 0A10                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011023 0304 0304                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011027 1F0C 8F0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001102B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001102F 0685 0485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011033 4E41 54                  M 	dc.b	'NAT'
00011036                            
00011036                            	; Patch $11
00011036                            	; $23
00011036                            	; $30, $75, $30, $70,	$08, $1F, $1D, $5B
00011036                            	; $8B, $16, $96, $95,	$01, $00, $00, $00
00011036                            	; $8B, $3A, $3A, $3A,	$05, $0D, $0B, $02
00011036                            	spAlgorithm	$03
00011036 =00000012                M spatnum	=	spatnum+1
00011036 =00000003                M spal	=	val
00011036                            	spFeedback	$04
00011036 =00000004                M spfe	=	val
00011036                            	spDetune	$03, $03, $07, $07
00011036 =00000003                M spde1	=	op1
00011036 =00000003                M spde2	=	op2
00011036 =00000007                M spde3	=	op3
00011036 =00000007                M spde4	=	op4
00011036                            	spMultiple	$00, $00, $05, $00
00011036 =00000000                M spmu1	=	op1
00011036 =00000000                M spmu2	=	op2
00011036 =00000005                M spmu3	=	op3
00011036 =00000000                M spmu4	=	op4
00011036                            	spRateScale	$00, $00, $00, $01
00011036 =00000000                M sprs1	=	op1
00011036 =00000000                M sprs2	=	op2
00011036 =00000000                M sprs3	=	op3
00011036 =00000001                M sprs4	=	op4
00011036                            	spAttackRt	$08, $1D, $1F, $1B
00011036 =00000008                M spar1	=	op1
00011036 =0000001D                M spar2	=	op2
00011036 =0000001F                M spar3	=	op3
00011036 =0000001B                M spar4	=	op4
00011036                            	spAmpMod	$01, $01, $00, $01
00011036 =00000001                M spam1	=	op1
00011036 =00000001                M spam2	=	op2
00011036 =00000000                M spam3	=	op3
00011036 =00000001                M spam4	=	op4
00011036                            	spSustainRt	$0B, $16, $16, $15
00011036 =0000000B                M spsr1	=	op1
00011036 =00000016                M spsr2	=	op2
00011036 =00000016                M spsr3	=	op3
00011036 =00000015                M spsr4	=	op4
00011036                            	spDecayRt	$01, $00, $00, $00
00011036 =00000001                M spdr1	=	op1
00011036 =00000000                M spdr2	=	op2
00011036 =00000000                M spdr3	=	op3
00011036 =00000000                M spdr4	=	op4
00011036                            	spSustainLv	$08, $03, $03, $03
00011036 =00000008                M spsl1	=	op1
00011036 =00000003                M spsl2	=	op2
00011036 =00000003                M spsl3	=	op3
00011036 =00000003                M spsl4	=	op4
00011036                            	spReleaseRt	$0B, $0A, $0A, $0A
00011036 =0000000B                M sprr1	=	op1
00011036 =0000000A                M sprr2	=	op2
00011036 =0000000A                M sprr3	=	op3
00011036 =0000000A                M sprr4	=	op4
00011036                            	spSSGEG		$00, $00, $00, $00
00011036 =00000000                M spss1	=	op1
00011036 =00000000                M spss2	=	op2
00011036 =00000000                M spss3	=	op3
00011036 =00000000                M spss4	=	op4
00011036                            	spTotalLv	$05, $0B, $0D, $02
00011036 =00000005                M sptl1	=	op1
00011036 =0000000B                M sptl2	=	op2
00011036 =0000000D                M sptl3	=	op3
00011036 =00000002                M sptl4	=	op4
00011036 23                       M 	dc.b	(spfe<<3)+spal
00011037 =00000080                M sptlmask4	set	$80
00011037 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011037 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011037 =00000000                M sptlmask1	set	((spal=7)<<7)
00011037 3075 3070                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001103B 081F 1D5B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001103F 8B16 9695                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011043 0100 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011047 8B3A 3A3A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001104B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001104F 050D 0B82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011053 4E41 54                  M 	dc.b	'NAT'
00011056                            
00011056                            	; Patch $12
00011056                            	; $2C
00011056                            	; $70, $32, $00, $00,	$9F, $1F, $5F, $5E
00011056                            	; $1A, $15, $0C, $05,	$08, $06, $02, $09
00011056                            	; $28, $AA, $BA, $8A,	$08, $05, $0B, $05
00011056                            	spAlgorithm	$04
00011056 =00000013                M spatnum	=	spatnum+1
00011056 =00000004                M spal	=	val
00011056                            	spFeedback	$05
00011056 =00000005                M spfe	=	val
00011056                            	spDetune	$07, $00, $03, $00
00011056 =00000007                M spde1	=	op1
00011056 =00000000                M spde2	=	op2
00011056 =00000003                M spde3	=	op3
00011056 =00000000                M spde4	=	op4
00011056                            	spMultiple	$00, $00, $02, $00
00011056 =00000000                M spmu1	=	op1
00011056 =00000000                M spmu2	=	op2
00011056 =00000002                M spmu3	=	op3
00011056 =00000000                M spmu4	=	op4
00011056                            	spRateScale	$02, $01, $00, $01
00011056 =00000002                M sprs1	=	op1
00011056 =00000001                M sprs2	=	op2
00011056 =00000000                M sprs3	=	op3
00011056 =00000001                M sprs4	=	op4
00011056                            	spAttackRt	$1F, $1F, $1F, $1E
00011056 =0000001F                M spar1	=	op1
00011056 =0000001F                M spar2	=	op2
00011056 =0000001F                M spar3	=	op3
00011056 =0000001E                M spar4	=	op4
00011056                            	spAmpMod	$00, $00, $00, $00
00011056 =00000000                M spam1	=	op1
00011056 =00000000                M spam2	=	op2
00011056 =00000000                M spam3	=	op3
00011056 =00000000                M spam4	=	op4
00011056                            	spSustainRt	$1A, $0C, $15, $05
00011056 =0000001A                M spsr1	=	op1
00011056 =0000000C                M spsr2	=	op2
00011056 =00000015                M spsr3	=	op3
00011056 =00000005                M spsr4	=	op4
00011056                            	spDecayRt	$08, $02, $06, $09
00011056 =00000008                M spdr1	=	op1
00011056 =00000002                M spdr2	=	op2
00011056 =00000006                M spdr3	=	op3
00011056 =00000009                M spdr4	=	op4
00011056                            	spSustainLv	$02, $0B, $0A, $08
00011056 =00000002                M spsl1	=	op1
00011056 =0000000B                M spsl2	=	op2
00011056 =0000000A                M spsl3	=	op3
00011056 =00000008                M spsl4	=	op4
00011056                            	spReleaseRt	$08, $0A, $0A, $0A
00011056 =00000008                M sprr1	=	op1
00011056 =0000000A                M sprr2	=	op2
00011056 =0000000A                M sprr3	=	op3
00011056 =0000000A                M sprr4	=	op4
00011056                            	spSSGEG		$00, $00, $00, $00
00011056 =00000000                M spss1	=	op1
00011056 =00000000                M spss2	=	op2
00011056 =00000000                M spss3	=	op3
00011056 =00000000                M spss4	=	op4
00011056                            	spTotalLv	$08, $0B, $05, $05
00011056 =00000008                M sptl1	=	op1
00011056 =0000000B                M sptl2	=	op2
00011056 =00000005                M sptl3	=	op3
00011056 =00000005                M sptl4	=	op4
00011056 2C                       M 	dc.b	(spfe<<3)+spal
00011057 =00000080                M sptlmask4	set	$80
00011057 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011057 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011057 =00000000                M sptlmask1	set	((spal=7)<<7)
00011057 7032 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001105B 9F1F 5F5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001105F 1A15 0C05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011063 0806 0209                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011067 28AA BA8A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001106B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001106F 0885 0B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011073 4E41 54                  M 	dc.b	'NAT'
00011076                            
00011076                            	; Patch $13
00011076                            	; $35
00011076                            	; $77, $03, $74, $32,	$1A, $14, $56, $17
00011076                            	; $97, $9F, $9D, $9F,	$13, $0F, $0F, $0E
00011076                            	; $7C, $1D, $1D, $1D,	$13, $04, $02, $06
00011076                            	spAlgorithm	$05
00011076 =00000014                M spatnum	=	spatnum+1
00011076 =00000005                M spal	=	val
00011076                            	spFeedback	$06
00011076 =00000006                M spfe	=	val
00011076                            	spDetune	$07, $07, $00, $03
00011076 =00000007                M spde1	=	op1
00011076 =00000007                M spde2	=	op2
00011076 =00000000                M spde3	=	op3
00011076 =00000003                M spde4	=	op4
00011076                            	spMultiple	$07, $04, $03, $02
00011076 =00000007                M spmu1	=	op1
00011076 =00000004                M spmu2	=	op2
00011076 =00000003                M spmu3	=	op3
00011076 =00000002                M spmu4	=	op4
00011076                            	spRateScale	$00, $01, $00, $00
00011076 =00000000                M sprs1	=	op1
00011076 =00000001                M sprs2	=	op2
00011076 =00000000                M sprs3	=	op3
00011076 =00000000                M sprs4	=	op4
00011076                            	spAttackRt	$1A, $16, $14, $17
00011076 =0000001A                M spar1	=	op1
00011076 =00000016                M spar2	=	op2
00011076 =00000014                M spar3	=	op3
00011076 =00000017                M spar4	=	op4
00011076                            	spAmpMod	$01, $01, $01, $01
00011076 =00000001                M spam1	=	op1
00011076 =00000001                M spam2	=	op2
00011076 =00000001                M spam3	=	op3
00011076 =00000001                M spam4	=	op4
00011076                            	spSustainRt	$17, $1D, $1F, $1F
00011076 =00000017                M spsr1	=	op1
00011076 =0000001D                M spsr2	=	op2
00011076 =0000001F                M spsr3	=	op3
00011076 =0000001F                M spsr4	=	op4
00011076                            	spDecayRt	$13, $0F, $0F, $0E
00011076 =00000013                M spdr1	=	op1
00011076 =0000000F                M spdr2	=	op2
00011076 =0000000F                M spdr3	=	op3
00011076 =0000000E                M spdr4	=	op4
00011076                            	spSustainLv	$07, $01, $01, $01
00011076 =00000007                M spsl1	=	op1
00011076 =00000001                M spsl2	=	op2
00011076 =00000001                M spsl3	=	op3
00011076 =00000001                M spsl4	=	op4
00011076                            	spReleaseRt	$0C, $0D, $0D, $0D
00011076 =0000000C                M sprr1	=	op1
00011076 =0000000D                M sprr2	=	op2
00011076 =0000000D                M sprr3	=	op3
00011076 =0000000D                M sprr4	=	op4
00011076                            	spSSGEG		$00, $00, $00, $00
00011076 =00000000                M spss1	=	op1
00011076 =00000000                M spss2	=	op2
00011076 =00000000                M spss3	=	op3
00011076 =00000000                M spss4	=	op4
00011076                            	spTotalLv	$13, $02, $04, $06
00011076 =00000013                M sptl1	=	op1
00011076 =00000002                M sptl2	=	op2
00011076 =00000004                M sptl3	=	op3
00011076 =00000006                M sptl4	=	op4
00011076 35                       M 	dc.b	(spfe<<3)+spal
00011077 =00000080                M sptlmask4	set	$80
00011077 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011077 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011077 =00000000                M sptlmask1	set	((spal=7)<<7)
00011077 7703 7432                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001107B 1A14 5617                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001107F 979F 9D9F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011083 130F 0F0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011087 7C1D 1D1D                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001108B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001108F 1384 8286                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011093 4E41 54                  M 	dc.b	'NAT'
00011096                            
00011096                            	; Patch $14
00011096                            	; $35
00011096                            	; $21, $31, $20, $15,	$8E, $9B, $95, $94
00011096                            	; $00, $05, $00, $80,	$01, $02, $02, $02
00011096                            	; $47, $37, $19, $07,	$19, $05, $0E, $08
00011096                            	spAlgorithm	$05
00011096 =00000015                M spatnum	=	spatnum+1
00011096 =00000005                M spal	=	val
00011096                            	spFeedback	$06
00011096 =00000006                M spfe	=	val
00011096                            	spDetune	$02, $02, $03, $01
00011096 =00000002                M spde1	=	op1
00011096 =00000002                M spde2	=	op2
00011096 =00000003                M spde3	=	op3
00011096 =00000001                M spde4	=	op4
00011096                            	spMultiple	$01, $00, $01, $05
00011096 =00000001                M spmu1	=	op1
00011096 =00000000                M spmu2	=	op2
00011096 =00000001                M spmu3	=	op3
00011096 =00000005                M spmu4	=	op4
00011096                            	spRateScale	$02, $02, $02, $02
00011096 =00000002                M sprs1	=	op1
00011096 =00000002                M sprs2	=	op2
00011096 =00000002                M sprs3	=	op3
00011096 =00000002                M sprs4	=	op4
00011096                            	spAttackRt	$0E, $15, $1B, $14
00011096 =0000000E                M spar1	=	op1
00011096 =00000015                M spar2	=	op2
00011096 =0000001B                M spar3	=	op3
00011096 =00000014                M spar4	=	op4
00011096                            	spAmpMod	$00, $00, $00, $01
00011096 =00000000                M spam1	=	op1
00011096 =00000000                M spam2	=	op2
00011096 =00000000                M spam3	=	op3
00011096 =00000001                M spam4	=	op4
00011096                            	spSustainRt	$00, $00, $05, $00
00011096 =00000000                M spsr1	=	op1
00011096 =00000000                M spsr2	=	op2
00011096 =00000005                M spsr3	=	op3
00011096 =00000000                M spsr4	=	op4
00011096                            	spDecayRt	$01, $02, $02, $02
00011096 =00000001                M spdr1	=	op1
00011096 =00000002                M spdr2	=	op2
00011096 =00000002                M spdr3	=	op3
00011096 =00000002                M spdr4	=	op4
00011096                            	spSustainLv	$04, $01, $03, $00
00011096 =00000004                M spsl1	=	op1
00011096 =00000001                M spsl2	=	op2
00011096 =00000003                M spsl3	=	op3
00011096 =00000000                M spsl4	=	op4
00011096                            	spReleaseRt	$07, $09, $07, $07
00011096 =00000007                M sprr1	=	op1
00011096 =00000009                M sprr2	=	op2
00011096 =00000007                M sprr3	=	op3
00011096 =00000007                M sprr4	=	op4
00011096                            	spSSGEG		$00, $00, $00, $00
00011096 =00000000                M spss1	=	op1
00011096 =00000000                M spss2	=	op2
00011096 =00000000                M spss3	=	op3
00011096 =00000000                M spss4	=	op4
00011096                            	spTotalLv	$19, $0E, $05, $08
00011096 =00000019                M sptl1	=	op1
00011096 =0000000E                M sptl2	=	op2
00011096 =00000005                M sptl3	=	op3
00011096 =00000008                M sptl4	=	op4
00011096 35                       M 	dc.b	(spfe<<3)+spal
00011097 =00000080                M sptlmask4	set	$80
00011097 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011097 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011097 =00000000                M sptlmask1	set	((spal=7)<<7)
00011097 2131 2015                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001109B 8E9B 9594                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001109F 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110A3 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110A7 4737 1907                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110AF 1985 8E88                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110B3 4E41 54                  M 	dc.b	'NAT'
000110B6                            
000110B6                            	; Patch $15
000110B6                            	; $35
000110B6                            	; $22, $32, $21, $34,	$8E, $9B, $8F, $94
000110B6                            	; $00, $05, $00, $80,	$01, $02, $02, $02
000110B6                            	; $07, $36, $17, $08,	$15, $12, $14, $05
000110B6                            	spAlgorithm	$05
000110B6 =00000016                M spatnum	=	spatnum+1
000110B6 =00000005                M spal	=	val
000110B6                            	spFeedback	$06
000110B6 =00000006                M spfe	=	val
000110B6                            	spDetune	$02, $02, $03, $03
000110B6 =00000002                M spde1	=	op1
000110B6 =00000002                M spde2	=	op2
000110B6 =00000003                M spde3	=	op3
000110B6 =00000003                M spde4	=	op4
000110B6                            	spMultiple	$02, $01, $02, $04
000110B6 =00000002                M spmu1	=	op1
000110B6 =00000001                M spmu2	=	op2
000110B6 =00000002                M spmu3	=	op3
000110B6 =00000004                M spmu4	=	op4
000110B6                            	spRateScale	$02, $02, $02, $02
000110B6 =00000002                M sprs1	=	op1
000110B6 =00000002                M sprs2	=	op2
000110B6 =00000002                M sprs3	=	op3
000110B6 =00000002                M sprs4	=	op4
000110B6                            	spAttackRt	$0E, $0F, $1B, $14
000110B6 =0000000E                M spar1	=	op1
000110B6 =0000000F                M spar2	=	op2
000110B6 =0000001B                M spar3	=	op3
000110B6 =00000014                M spar4	=	op4
000110B6                            	spAmpMod	$00, $00, $00, $01
000110B6 =00000000                M spam1	=	op1
000110B6 =00000000                M spam2	=	op2
000110B6 =00000000                M spam3	=	op3
000110B6 =00000001                M spam4	=	op4
000110B6                            	spSustainRt	$00, $00, $05, $00
000110B6 =00000000                M spsr1	=	op1
000110B6 =00000000                M spsr2	=	op2
000110B6 =00000005                M spsr3	=	op3
000110B6 =00000000                M spsr4	=	op4
000110B6                            	spDecayRt	$01, $02, $02, $02
000110B6 =00000001                M spdr1	=	op1
000110B6 =00000002                M spdr2	=	op2
000110B6 =00000002                M spdr3	=	op3
000110B6 =00000002                M spdr4	=	op4
000110B6                            	spSustainLv	$00, $01, $03, $00
000110B6 =00000000                M spsl1	=	op1
000110B6 =00000001                M spsl2	=	op2
000110B6 =00000003                M spsl3	=	op3
000110B6 =00000000                M spsl4	=	op4
000110B6                            	spReleaseRt	$07, $07, $06, $08
000110B6 =00000007                M sprr1	=	op1
000110B6 =00000007                M sprr2	=	op2
000110B6 =00000006                M sprr3	=	op3
000110B6 =00000008                M sprr4	=	op4
000110B6                            	spSSGEG		$00, $00, $00, $00
000110B6 =00000000                M spss1	=	op1
000110B6 =00000000                M spss2	=	op2
000110B6 =00000000                M spss3	=	op3
000110B6 =00000000                M spss4	=	op4
000110B6                            	spTotalLv	$15, $14, $12, $05
000110B6 =00000015                M sptl1	=	op1
000110B6 =00000014                M sptl2	=	op2
000110B6 =00000012                M sptl3	=	op3
000110B6 =00000005                M sptl4	=	op4
000110B6 35                       M 	dc.b	(spfe<<3)+spal
000110B7 =00000080                M sptlmask4	set	$80
000110B7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000110B7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000110B7 =00000000                M sptlmask1	set	((spal=7)<<7)
000110B7 2232 2134                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110BB 8E9B 8F94                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110BF 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110C3 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110C7 0736 1708                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110CF 1592 9485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110D3 4E41 54                  M 	dc.b	'NAT'
000110D6                            
000110D6                            	; Patch $16
000110D6                            	; $2B
000110D6                            	; $31, $32, $35, $31,	$1F, $59, $9E, $5E
000110D6                            	; $06, $80, $80, $85,	$01, $17, $12, $0A
000110D6                            	; $AA, $AF, $F9, $FC,	$0E, $12, $46, $05
000110D6                            	spAlgorithm	$03
000110D6 =00000017                M spatnum	=	spatnum+1
000110D6 =00000003                M spal	=	val
000110D6                            	spFeedback	$05
000110D6 =00000005                M spfe	=	val
000110D6                            	spDetune	$03, $03, $03, $03
000110D6 =00000003                M spde1	=	op1
000110D6 =00000003                M spde2	=	op2
000110D6 =00000003                M spde3	=	op3
000110D6 =00000003                M spde4	=	op4
000110D6                            	spMultiple	$01, $05, $02, $01
000110D6 =00000001                M spmu1	=	op1
000110D6 =00000005                M spmu2	=	op2
000110D6 =00000002                M spmu3	=	op3
000110D6 =00000001                M spmu4	=	op4
000110D6                            	spRateScale	$00, $02, $01, $01
000110D6 =00000000                M sprs1	=	op1
000110D6 =00000002                M sprs2	=	op2
000110D6 =00000001                M sprs3	=	op3
000110D6 =00000001                M sprs4	=	op4
000110D6                            	spAttackRt	$1F, $1E, $19, $1E
000110D6 =0000001F                M spar1	=	op1
000110D6 =0000001E                M spar2	=	op2
000110D6 =00000019                M spar3	=	op3
000110D6 =0000001E                M spar4	=	op4
000110D6                            	spAmpMod	$00, $01, $01, $01
000110D6 =00000000                M spam1	=	op1
000110D6 =00000001                M spam2	=	op2
000110D6 =00000001                M spam3	=	op3
000110D6 =00000001                M spam4	=	op4
000110D6                            	spSustainRt	$06, $00, $00, $05
000110D6 =00000006                M spsr1	=	op1
000110D6 =00000000                M spsr2	=	op2
000110D6 =00000000                M spsr3	=	op3
000110D6 =00000005                M spsr4	=	op4
000110D6                            	spDecayRt	$01, $12, $17, $0A
000110D6 =00000001                M spdr1	=	op1
000110D6 =00000012                M spdr2	=	op2
000110D6 =00000017                M spdr3	=	op3
000110D6 =0000000A                M spdr4	=	op4
000110D6                            	spSustainLv	$0A, $0F, $0A, $0F
000110D6 =0000000A                M spsl1	=	op1
000110D6 =0000000F                M spsl2	=	op2
000110D6 =0000000A                M spsl3	=	op3
000110D6 =0000000F                M spsl4	=	op4
000110D6                            	spReleaseRt	$0A, $09, $0F, $0C
000110D6 =0000000A                M sprr1	=	op1
000110D6 =00000009                M sprr2	=	op2
000110D6 =0000000F                M sprr3	=	op3
000110D6 =0000000C                M sprr4	=	op4
000110D6                            	spSSGEG		$00, $00, $00, $00
000110D6 =00000000                M spss1	=	op1
000110D6 =00000000                M spss2	=	op2
000110D6 =00000000                M spss3	=	op3
000110D6 =00000000                M spss4	=	op4
000110D6                            	spTotalLv	$0E, $46, $12, $05
000110D6 =0000000E                M sptl1	=	op1
000110D6 =00000046                M sptl2	=	op2
000110D6 =00000012                M sptl3	=	op3
000110D6 =00000005                M sptl4	=	op4
000110D6 2B                       M 	dc.b	(spfe<<3)+spal
000110D7 =00000080                M sptlmask4	set	$80
000110D7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000110D7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000110D7 =00000000                M sptlmask1	set	((spal=7)<<7)
000110D7 3132 3531                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110DB 1F59 9E5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110DF 0680 8085                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110E3 0117 120A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110E7 AAAF F9FC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110EF 0E12 4685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110F3 4E41 54                  M 	dc.b	'NAT'
000110F6                            
000110F6                            	; Patch $17
000110F6                            	; $04
000110F6                            	; $00, $00, $01, $02,	$9F, $1F, $9F, $1F
000110F6                            	; $8A, $8A, $91, $94,	$0E, $0A, $0E, $0E
000110F6                            	; $F8, $48, $F8, $F8,	$17, $04, $07, $04
000110F6                            	spAlgorithm	$04
000110F6 =00000018                M spatnum	=	spatnum+1
000110F6 =00000004                M spal	=	val
000110F6                            	spFeedback	$00
000110F6 =00000000                M spfe	=	val
000110F6                            	spDetune	$00, $00, $00, $00
000110F6 =00000000                M spde1	=	op1
000110F6 =00000000                M spde2	=	op2
000110F6 =00000000                M spde3	=	op3
000110F6 =00000000                M spde4	=	op4
000110F6                            	spMultiple	$00, $01, $00, $02
000110F6 =00000000                M spmu1	=	op1
000110F6 =00000001                M spmu2	=	op2
000110F6 =00000000                M spmu3	=	op3
000110F6 =00000002                M spmu4	=	op4
000110F6                            	spRateScale	$02, $02, $00, $00
000110F6 =00000002                M sprs1	=	op1
000110F6 =00000002                M sprs2	=	op2
000110F6 =00000000                M sprs3	=	op3
000110F6 =00000000                M sprs4	=	op4
000110F6                            	spAttackRt	$1F, $1F, $1F, $1F
000110F6 =0000001F                M spar1	=	op1
000110F6 =0000001F                M spar2	=	op2
000110F6 =0000001F                M spar3	=	op3
000110F6 =0000001F                M spar4	=	op4
000110F6                            	spAmpMod	$01, $01, $01, $01
000110F6 =00000001                M spam1	=	op1
000110F6 =00000001                M spam2	=	op2
000110F6 =00000001                M spam3	=	op3
000110F6 =00000001                M spam4	=	op4
000110F6                            	spSustainRt	$0A, $11, $0A, $14
000110F6 =0000000A                M spsr1	=	op1
000110F6 =00000011                M spsr2	=	op2
000110F6 =0000000A                M spsr3	=	op3
000110F6 =00000014                M spsr4	=	op4
000110F6                            	spDecayRt	$0E, $0E, $0A, $0E
000110F6 =0000000E                M spdr1	=	op1
000110F6 =0000000E                M spdr2	=	op2
000110F6 =0000000A                M spdr3	=	op3
000110F6 =0000000E                M spdr4	=	op4
000110F6                            	spSustainLv	$0F, $0F, $04, $0F
000110F6 =0000000F                M spsl1	=	op1
000110F6 =0000000F                M spsl2	=	op2
000110F6 =00000004                M spsl3	=	op3
000110F6 =0000000F                M spsl4	=	op4
000110F6                            	spReleaseRt	$08, $08, $08, $08
000110F6 =00000008                M sprr1	=	op1
000110F6 =00000008                M sprr2	=	op2
000110F6 =00000008                M sprr3	=	op3
000110F6 =00000008                M sprr4	=	op4
000110F6                            	spSSGEG		$00, $00, $00, $00
000110F6 =00000000                M spss1	=	op1
000110F6 =00000000                M spss2	=	op2
000110F6 =00000000                M spss3	=	op3
000110F6 =00000000                M spss4	=	op4
000110F6                            	spTotalLv	$17, $07, $04, $04
000110F6 =00000017                M sptl1	=	op1
000110F6 =00000007                M sptl2	=	op2
000110F6 =00000004                M sptl3	=	op3
000110F6 =00000004                M sptl4	=	op4
000110F6 04                       M 	dc.b	(spfe<<3)+spal
000110F7 =00000080                M sptlmask4	set	$80
000110F7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000110F7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000110F7 =00000000                M sptlmask1	set	((spal=7)<<7)
000110F7 0000 0102                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110FB 9F1F 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110FF 8A8A 9194                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011103 0E0A 0E0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011107 F848 F8F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001110B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001110F 1784 0784                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011113 4E41 54                  M 	dc.b	'NAT'
00011116                            
00011116                            	; Patch $18
00011116                            	; $3A
00011116                            	; $71, $0C, $33, $01,	$5F, $5F, $5F, $5F
00011116                            	; $84, $89, $84, $8A,	$00, $01, $03, $06
00011116                            	; $15, $12, $16, $28,	$25, $2F, $25, $03
00011116                            	spAlgorithm	$02
00011116 =00000019                M spatnum	=	spatnum+1
00011116 =00000002                M spal	=	val
00011116                            	spFeedback	$07
00011116 =00000007                M spfe	=	val
00011116                            	spDetune	$07, $03, $00, $00
00011116 =00000007                M spde1	=	op1
00011116 =00000003                M spde2	=	op2
00011116 =00000000                M spde3	=	op3
00011116 =00000000                M spde4	=	op4
00011116                            	spMultiple	$01, $03, $0C, $01
00011116 =00000001                M spmu1	=	op1
00011116 =00000003                M spmu2	=	op2
00011116 =0000000C                M spmu3	=	op3
00011116 =00000001                M spmu4	=	op4
00011116                            	spRateScale	$01, $01, $01, $01
00011116 =00000001                M sprs1	=	op1
00011116 =00000001                M sprs2	=	op2
00011116 =00000001                M sprs3	=	op3
00011116 =00000001                M sprs4	=	op4
00011116                            	spAttackRt	$1F, $1F, $1F, $1F
00011116 =0000001F                M spar1	=	op1
00011116 =0000001F                M spar2	=	op2
00011116 =0000001F                M spar3	=	op3
00011116 =0000001F                M spar4	=	op4
00011116                            	spAmpMod	$01, $01, $01, $01
00011116 =00000001                M spam1	=	op1
00011116 =00000001                M spam2	=	op2
00011116 =00000001                M spam3	=	op3
00011116 =00000001                M spam4	=	op4
00011116                            	spSustainRt	$04, $04, $09, $0A
00011116 =00000004                M spsr1	=	op1
00011116 =00000004                M spsr2	=	op2
00011116 =00000009                M spsr3	=	op3
00011116 =0000000A                M spsr4	=	op4
00011116                            	spDecayRt	$00, $03, $01, $06
00011116 =00000000                M spdr1	=	op1
00011116 =00000003                M spdr2	=	op2
00011116 =00000001                M spdr3	=	op3
00011116 =00000006                M spdr4	=	op4
00011116                            	spSustainLv	$01, $01, $01, $02
00011116 =00000001                M spsl1	=	op1
00011116 =00000001                M spsl2	=	op2
00011116 =00000001                M spsl3	=	op3
00011116 =00000002                M spsl4	=	op4
00011116                            	spReleaseRt	$05, $06, $02, $08
00011116 =00000005                M sprr1	=	op1
00011116 =00000006                M sprr2	=	op2
00011116 =00000002                M sprr3	=	op3
00011116 =00000008                M sprr4	=	op4
00011116                            	spSSGEG		$00, $00, $00, $00
00011116 =00000000                M spss1	=	op1
00011116 =00000000                M spss2	=	op2
00011116 =00000000                M spss3	=	op3
00011116 =00000000                M spss4	=	op4
00011116                            	spTotalLv	$25, $25, $2F, $03
00011116 =00000025                M sptl1	=	op1
00011116 =00000025                M sptl2	=	op2
00011116 =0000002F                M sptl3	=	op3
00011116 =00000003                M sptl4	=	op4
00011116 3A                       M 	dc.b	(spfe<<3)+spal
00011117 =00000080                M sptlmask4	set	$80
00011117 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011117 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011117 =00000000                M sptlmask1	set	((spal=7)<<7)
00011117 710C 3301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001111B 5F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001111F 8489 848A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011123 0001 0306                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011127 1512 1628                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001112B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001112F 252F 2583                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011133 4E41 54                  M 	dc.b	'NAT'
00011136                            
00011136                            	; Patch $19
00011136                            	; $3A
00011136                            	; $04, $02, $08, $02,	$1F, $1F, $1F, $1F
00011136                            	; $00, $00, $00, $11,	$15, $0F, $0B, $1F
00011136                            	; $00, $00, $00, $50,	$09, $07, $3F, $04
00011136                            	spAlgorithm	$02
00011136 =0000001A                M spatnum	=	spatnum+1
00011136 =00000002                M spal	=	val
00011136                            	spFeedback	$07
00011136 =00000007                M spfe	=	val
00011136                            	spDetune	$00, $00, $00, $00
00011136 =00000000                M spde1	=	op1
00011136 =00000000                M spde2	=	op2
00011136 =00000000                M spde3	=	op3
00011136 =00000000                M spde4	=	op4
00011136                            	spMultiple	$04, $08, $02, $02
00011136 =00000004                M spmu1	=	op1
00011136 =00000008                M spmu2	=	op2
00011136 =00000002                M spmu3	=	op3
00011136 =00000002                M spmu4	=	op4
00011136                            	spRateScale	$00, $00, $00, $00
00011136 =00000000                M sprs1	=	op1
00011136 =00000000                M sprs2	=	op2
00011136 =00000000                M sprs3	=	op3
00011136 =00000000                M sprs4	=	op4
00011136                            	spAttackRt	$1F, $1F, $1F, $1F
00011136 =0000001F                M spar1	=	op1
00011136 =0000001F                M spar2	=	op2
00011136 =0000001F                M spar3	=	op3
00011136 =0000001F                M spar4	=	op4
00011136                            	spAmpMod	$00, $00, $00, $00
00011136 =00000000                M spam1	=	op1
00011136 =00000000                M spam2	=	op2
00011136 =00000000                M spam3	=	op3
00011136 =00000000                M spam4	=	op4
00011136                            	spSustainRt	$00, $00, $00, $11
00011136 =00000000                M spsr1	=	op1
00011136 =00000000                M spsr2	=	op2
00011136 =00000000                M spsr3	=	op3
00011136 =00000011                M spsr4	=	op4
00011136                            	spDecayRt	$15, $0B, $0F, $1F
00011136 =00000015                M spdr1	=	op1
00011136 =0000000B                M spdr2	=	op2
00011136 =0000000F                M spdr3	=	op3
00011136 =0000001F                M spdr4	=	op4
00011136                            	spSustainLv	$00, $00, $00, $05
00011136 =00000000                M spsl1	=	op1
00011136 =00000000                M spsl2	=	op2
00011136 =00000000                M spsl3	=	op3
00011136 =00000005                M spsl4	=	op4
00011136                            	spReleaseRt	$00, $00, $00, $00
00011136 =00000000                M sprr1	=	op1
00011136 =00000000                M sprr2	=	op2
00011136 =00000000                M sprr3	=	op3
00011136 =00000000                M sprr4	=	op4
00011136                            	spSSGEG		$00, $00, $00, $00
00011136 =00000000                M spss1	=	op1
00011136 =00000000                M spss2	=	op2
00011136 =00000000                M spss3	=	op3
00011136 =00000000                M spss4	=	op4
00011136                            	spTotalLv	$09, $3F, $07, $04
00011136 =00000009                M sptl1	=	op1
00011136 =0000003F                M sptl2	=	op2
00011136 =00000007                M sptl3	=	op3
00011136 =00000004                M sptl4	=	op4
00011136 3A                       M 	dc.b	(spfe<<3)+spal
00011137 =00000080                M sptlmask4	set	$80
00011137 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011137 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011137 =00000000                M sptlmask1	set	((spal=7)<<7)
00011137 0402 0802                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001113B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001113F 0000 0011                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011143 150F 0B1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011147 0000 0050                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001114B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001114F 0907 3F84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011153 4E41 54                  M 	dc.b	'NAT'
00011156                            
00011156                            	; Patch $1A
00011156                            	; $39
00011156                            	; $11, $0C, $00, $00,	$1F, $5F, $D4, $D3
00011156                            	; $07, $15, $0B, $0A,	$00, $10, $06, $01
00011156                            	; $17, $8D, $06, $06,	$27, $24, $0C, $05
00011156                            	spAlgorithm	$01
00011156 =0000001B                M spatnum	=	spatnum+1
00011156 =00000001                M spal	=	val
00011156                            	spFeedback	$07
00011156 =00000007                M spfe	=	val
00011156                            	spDetune	$01, $00, $00, $00
00011156 =00000001                M spde1	=	op1
00011156 =00000000                M spde2	=	op2
00011156 =00000000                M spde3	=	op3
00011156 =00000000                M spde4	=	op4
00011156                            	spMultiple	$01, $00, $0C, $00
00011156 =00000001                M spmu1	=	op1
00011156 =00000000                M spmu2	=	op2
00011156 =0000000C                M spmu3	=	op3
00011156 =00000000                M spmu4	=	op4
00011156                            	spRateScale	$00, $03, $01, $03
00011156 =00000000                M sprs1	=	op1
00011156 =00000003                M sprs2	=	op2
00011156 =00000001                M sprs3	=	op3
00011156 =00000003                M sprs4	=	op4
00011156                            	spAttackRt	$1F, $14, $1F, $13
00011156 =0000001F                M spar1	=	op1
00011156 =00000014                M spar2	=	op2
00011156 =0000001F                M spar3	=	op3
00011156 =00000013                M spar4	=	op4
00011156                            	spAmpMod	$00, $00, $00, $00
00011156 =00000000                M spam1	=	op1
00011156 =00000000                M spam2	=	op2
00011156 =00000000                M spam3	=	op3
00011156 =00000000                M spam4	=	op4
00011156                            	spSustainRt	$07, $0B, $15, $0A
00011156 =00000007                M spsr1	=	op1
00011156 =0000000B                M spsr2	=	op2
00011156 =00000015                M spsr3	=	op3
00011156 =0000000A                M spsr4	=	op4
00011156                            	spDecayRt	$00, $06, $10, $01
00011156 =00000000                M spdr1	=	op1
00011156 =00000006                M spdr2	=	op2
00011156 =00000010                M spdr3	=	op3
00011156 =00000001                M spdr4	=	op4
00011156                            	spSustainLv	$01, $00, $08, $00
00011156 =00000001                M spsl1	=	op1
00011156 =00000000                M spsl2	=	op2
00011156 =00000008                M spsl3	=	op3
00011156 =00000000                M spsl4	=	op4
00011156                            	spReleaseRt	$07, $06, $0D, $06
00011156 =00000007                M sprr1	=	op1
00011156 =00000006                M sprr2	=	op2
00011156 =0000000D                M sprr3	=	op3
00011156 =00000006                M sprr4	=	op4
00011156                            	spSSGEG		$00, $00, $00, $00
00011156 =00000000                M spss1	=	op1
00011156 =00000000                M spss2	=	op2
00011156 =00000000                M spss3	=	op3
00011156 =00000000                M spss4	=	op4
00011156                            	spTotalLv	$27, $0C, $24, $05
00011156 =00000027                M sptl1	=	op1
00011156 =0000000C                M sptl2	=	op2
00011156 =00000024                M sptl3	=	op3
00011156 =00000005                M sptl4	=	op4
00011156 39                       M 	dc.b	(spfe<<3)+spal
00011157 =00000080                M sptlmask4	set	$80
00011157 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011157 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011157 =00000000                M sptlmask1	set	((spal=7)<<7)
00011157 110C 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001115B 1F5F D4D3                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001115F 0715 0B0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011163 0010 0601                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011167 178D 0606                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001116B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001116F 2724 0C85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011173 4E41 54                  M 	dc.b	'NAT'
00011176                            
00011176                            	; Patch $1B
00011176                            	; $3A
00011176                            	; $60, $70, $21, $13,	$1F, $1F, $1F, $1F
00011176                            	; $08, $09, $09, $09,	$00, $00, $00, $00
00011176                            	; $FF, $FF, $FF, $FF,	$2C, $3C, $16, $05
00011176                            	spAlgorithm	$02
00011176 =0000001C                M spatnum	=	spatnum+1
00011176 =00000002                M spal	=	val
00011176                            	spFeedback	$07
00011176 =00000007                M spfe	=	val
00011176                            	spDetune	$06, $02, $07, $01
00011176 =00000006                M spde1	=	op1
00011176 =00000002                M spde2	=	op2
00011176 =00000007                M spde3	=	op3
00011176 =00000001                M spde4	=	op4
00011176                            	spMultiple	$00, $01, $00, $03
00011176 =00000000                M spmu1	=	op1
00011176 =00000001                M spmu2	=	op2
00011176 =00000000                M spmu3	=	op3
00011176 =00000003                M spmu4	=	op4
00011176                            	spRateScale	$00, $00, $00, $00
00011176 =00000000                M sprs1	=	op1
00011176 =00000000                M sprs2	=	op2
00011176 =00000000                M sprs3	=	op3
00011176 =00000000                M sprs4	=	op4
00011176                            	spAttackRt	$1F, $1F, $1F, $1F
00011176 =0000001F                M spar1	=	op1
00011176 =0000001F                M spar2	=	op2
00011176 =0000001F                M spar3	=	op3
00011176 =0000001F                M spar4	=	op4
00011176                            	spAmpMod	$00, $00, $00, $00
00011176 =00000000                M spam1	=	op1
00011176 =00000000                M spam2	=	op2
00011176 =00000000                M spam3	=	op3
00011176 =00000000                M spam4	=	op4
00011176                            	spSustainRt	$08, $09, $09, $09
00011176 =00000008                M spsr1	=	op1
00011176 =00000009                M spsr2	=	op2
00011176 =00000009                M spsr3	=	op3
00011176 =00000009                M spsr4	=	op4
00011176                            	spDecayRt	$00, $00, $00, $00
00011176 =00000000                M spdr1	=	op1
00011176 =00000000                M spdr2	=	op2
00011176 =00000000                M spdr3	=	op3
00011176 =00000000                M spdr4	=	op4
00011176                            	spSustainLv	$0F, $0F, $0F, $0F
00011176 =0000000F                M spsl1	=	op1
00011176 =0000000F                M spsl2	=	op2
00011176 =0000000F                M spsl3	=	op3
00011176 =0000000F                M spsl4	=	op4
00011176                            	spReleaseRt	$0F, $0F, $0F, $0F
00011176 =0000000F                M sprr1	=	op1
00011176 =0000000F                M sprr2	=	op2
00011176 =0000000F                M sprr3	=	op3
00011176 =0000000F                M sprr4	=	op4
00011176                            	spSSGEG		$00, $00, $00, $00
00011176 =00000000                M spss1	=	op1
00011176 =00000000                M spss2	=	op2
00011176 =00000000                M spss3	=	op3
00011176 =00000000                M spss4	=	op4
00011176                            	spTotalLv	$2C, $16, $3C, $05
00011176 =0000002C                M sptl1	=	op1
00011176 =00000016                M sptl2	=	op2
00011176 =0000003C                M sptl3	=	op3
00011176 =00000005                M sptl4	=	op4
00011176 3A                       M 	dc.b	(spfe<<3)+spal
00011177 =00000080                M sptlmask4	set	$80
00011177 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011177 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011177 =00000000                M sptlmask1	set	((spal=7)<<7)
00011177 6070 2113                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001117B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001117F 0809 0909                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011183 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011187 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001118B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001118F 2C3C 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011193 4E41 54                  M 	dc.b	'NAT'
00011196                            
00011196                            	; Patch $1C
00011196                            	; $3A
00011196                            	; $62, $62, $20, $13,	$1F, $1F, $1F, $1F
00011196                            	; $05, $10, $05, $08,	$1F, $1F, $1F, $1F
00011196                            	; $FF, $FF, $FF, $FF,	$2C, $3C, $16, $05
00011196                            	spAlgorithm	$02
00011196 =0000001D                M spatnum	=	spatnum+1
00011196 =00000002                M spal	=	val
00011196                            	spFeedback	$07
00011196 =00000007                M spfe	=	val
00011196                            	spDetune	$06, $02, $06, $01
00011196 =00000006                M spde1	=	op1
00011196 =00000002                M spde2	=	op2
00011196 =00000006                M spde3	=	op3
00011196 =00000001                M spde4	=	op4
00011196                            	spMultiple	$02, $00, $02, $03
00011196 =00000002                M spmu1	=	op1
00011196 =00000000                M spmu2	=	op2
00011196 =00000002                M spmu3	=	op3
00011196 =00000003                M spmu4	=	op4
00011196                            	spRateScale	$00, $00, $00, $00
00011196 =00000000                M sprs1	=	op1
00011196 =00000000                M sprs2	=	op2
00011196 =00000000                M sprs3	=	op3
00011196 =00000000                M sprs4	=	op4
00011196                            	spAttackRt	$1F, $1F, $1F, $1F
00011196 =0000001F                M spar1	=	op1
00011196 =0000001F                M spar2	=	op2
00011196 =0000001F                M spar3	=	op3
00011196 =0000001F                M spar4	=	op4
00011196                            	spAmpMod	$00, $00, $00, $00
00011196 =00000000                M spam1	=	op1
00011196 =00000000                M spam2	=	op2
00011196 =00000000                M spam3	=	op3
00011196 =00000000                M spam4	=	op4
00011196                            	spSustainRt	$05, $05, $10, $08
00011196 =00000005                M spsr1	=	op1
00011196 =00000005                M spsr2	=	op2
00011196 =00000010                M spsr3	=	op3
00011196 =00000008                M spsr4	=	op4
00011196                            	spDecayRt	$1F, $1F, $1F, $1F
00011196 =0000001F                M spdr1	=	op1
00011196 =0000001F                M spdr2	=	op2
00011196 =0000001F                M spdr3	=	op3
00011196 =0000001F                M spdr4	=	op4
00011196                            	spSustainLv	$0F, $0F, $0F, $0F
00011196 =0000000F                M spsl1	=	op1
00011196 =0000000F                M spsl2	=	op2
00011196 =0000000F                M spsl3	=	op3
00011196 =0000000F                M spsl4	=	op4
00011196                            	spReleaseRt	$0F, $0F, $0F, $0F
00011196 =0000000F                M sprr1	=	op1
00011196 =0000000F                M sprr2	=	op2
00011196 =0000000F                M sprr3	=	op3
00011196 =0000000F                M sprr4	=	op4
00011196                            	spSSGEG		$00, $00, $00, $00
00011196 =00000000                M spss1	=	op1
00011196 =00000000                M spss2	=	op2
00011196 =00000000                M spss3	=	op3
00011196 =00000000                M spss4	=	op4
00011196                            	spTotalLv	$2C, $16, $3C, $05
00011196 =0000002C                M sptl1	=	op1
00011196 =00000016                M sptl2	=	op2
00011196 =0000003C                M sptl3	=	op3
00011196 =00000005                M sptl4	=	op4
00011196 3A                       M 	dc.b	(spfe<<3)+spal
00011197 =00000080                M sptlmask4	set	$80
00011197 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011197 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011197 =00000000                M sptlmask1	set	((spal=7)<<7)
00011197 6262 2013                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001119B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001119F 0510 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111A3 1F1F 1F1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111A7 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111AF 2C3C 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111B3 4E41 54                  M 	dc.b	'NAT'
000111B6                            
000111B6                            	; Patch $1D
000111B6                            	; $17
000111B6                            	; $08, $70, $70, $30,	$1F, $19, $1C, $5F
000111B6                            	; $93, $8F, $93, $95,	$00, $09, $06, $09
000111B6                            	; $2F, $3F, $0C, $1A,	$05, $13, $20, $0B
000111B6                            	spAlgorithm	$07
000111B6 =0000001E                M spatnum	=	spatnum+1
000111B6 =00000007                M spal	=	val
000111B6                            	spFeedback	$02
000111B6 =00000002                M spfe	=	val
000111B6                            	spDetune	$00, $07, $07, $03
000111B6 =00000000                M spde1	=	op1
000111B6 =00000007                M spde2	=	op2
000111B6 =00000007                M spde3	=	op3
000111B6 =00000003                M spde4	=	op4
000111B6                            	spMultiple	$08, $00, $00, $00
000111B6 =00000008                M spmu1	=	op1
000111B6 =00000000                M spmu2	=	op2
000111B6 =00000000                M spmu3	=	op3
000111B6 =00000000                M spmu4	=	op4
000111B6                            	spRateScale	$00, $00, $00, $01
000111B6 =00000000                M sprs1	=	op1
000111B6 =00000000                M sprs2	=	op2
000111B6 =00000000                M sprs3	=	op3
000111B6 =00000001                M sprs4	=	op4
000111B6                            	spAttackRt	$1F, $1C, $19, $1F
000111B6 =0000001F                M spar1	=	op1
000111B6 =0000001C                M spar2	=	op2
000111B6 =00000019                M spar3	=	op3
000111B6 =0000001F                M spar4	=	op4
000111B6                            	spAmpMod	$01, $01, $01, $01
000111B6 =00000001                M spam1	=	op1
000111B6 =00000001                M spam2	=	op2
000111B6 =00000001                M spam3	=	op3
000111B6 =00000001                M spam4	=	op4
000111B6                            	spSustainRt	$13, $13, $0F, $15
000111B6 =00000013                M spsr1	=	op1
000111B6 =00000013                M spsr2	=	op2
000111B6 =0000000F                M spsr3	=	op3
000111B6 =00000015                M spsr4	=	op4
000111B6                            	spDecayRt	$00, $06, $09, $09
000111B6 =00000000                M spdr1	=	op1
000111B6 =00000006                M spdr2	=	op2
000111B6 =00000009                M spdr3	=	op3
000111B6 =00000009                M spdr4	=	op4
000111B6                            	spSustainLv	$02, $00, $03, $01
000111B6 =00000002                M spsl1	=	op1
000111B6 =00000000                M spsl2	=	op2
000111B6 =00000003                M spsl3	=	op3
000111B6 =00000001                M spsl4	=	op4
000111B6                            	spReleaseRt	$0F, $0C, $0F, $0A
000111B6 =0000000F                M sprr1	=	op1
000111B6 =0000000C                M sprr2	=	op2
000111B6 =0000000F                M sprr3	=	op3
000111B6 =0000000A                M sprr4	=	op4
000111B6                            	spSSGEG		$00, $00, $00, $00
000111B6 =00000000                M spss1	=	op1
000111B6 =00000000                M spss2	=	op2
000111B6 =00000000                M spss3	=	op3
000111B6 =00000000                M spss4	=	op4
000111B6                            	spTotalLv	$05, $20, $13, $0B
000111B6 =00000005                M sptl1	=	op1
000111B6 =00000020                M sptl2	=	op2
000111B6 =00000013                M sptl3	=	op3
000111B6 =0000000B                M sptl4	=	op4
000111B6 17                       M 	dc.b	(spfe<<3)+spal
000111B7 =00000080                M sptlmask4	set	$80
000111B7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000111B7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000111B7 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
000111B7 0870 7030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111BB 1F19 1C5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111BF 938F 9395                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111C3 0009 0609                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111C7 2F3F 0C1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111CF 8593 A08B                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111D3 4E41 54                  M 	dc.b	'NAT'
000111D6                            
000111D6                            	; Patch $1E
000111D6                            	; $33
000111D6                            	; $52, $60, $1B, $31,	$9A, $1F, $9C, $9F
000111D6                            	; $08, $1F, $09, $19,	$00, $00, $00, $02
000111D6                            	; $05, $16, $07, $08,	$23, $04, $19, $05
000111D6                            	spAlgorithm	$03
000111D6 =0000001F                M spatnum	=	spatnum+1
000111D6 =00000003                M spal	=	val
000111D6                            	spFeedback	$06
000111D6 =00000006                M spfe	=	val
000111D6                            	spDetune	$05, $01, $06, $03
000111D6 =00000005                M spde1	=	op1
000111D6 =00000001                M spde2	=	op2
000111D6 =00000006                M spde3	=	op3
000111D6 =00000003                M spde4	=	op4
000111D6                            	spMultiple	$02, $0B, $00, $01
000111D6 =00000002                M spmu1	=	op1
000111D6 =0000000B                M spmu2	=	op2
000111D6 =00000000                M spmu3	=	op3
000111D6 =00000001                M spmu4	=	op4
000111D6                            	spRateScale	$02, $02, $00, $02
000111D6 =00000002                M sprs1	=	op1
000111D6 =00000002                M sprs2	=	op2
000111D6 =00000000                M sprs3	=	op3
000111D6 =00000002                M sprs4	=	op4
000111D6                            	spAttackRt	$1A, $1C, $1F, $1F
000111D6 =0000001A                M spar1	=	op1
000111D6 =0000001C                M spar2	=	op2
000111D6 =0000001F                M spar3	=	op3
000111D6 =0000001F                M spar4	=	op4
000111D6                            	spAmpMod	$00, $00, $00, $00
000111D6 =00000000                M spam1	=	op1
000111D6 =00000000                M spam2	=	op2
000111D6 =00000000                M spam3	=	op3
000111D6 =00000000                M spam4	=	op4
000111D6                            	spSustainRt	$08, $09, $1F, $19
000111D6 =00000008                M spsr1	=	op1
000111D6 =00000009                M spsr2	=	op2
000111D6 =0000001F                M spsr3	=	op3
000111D6 =00000019                M spsr4	=	op4
000111D6                            	spDecayRt	$00, $00, $00, $02
000111D6 =00000000                M spdr1	=	op1
000111D6 =00000000                M spdr2	=	op2
000111D6 =00000000                M spdr3	=	op3
000111D6 =00000002                M spdr4	=	op4
000111D6                            	spSustainLv	$00, $00, $01, $00
000111D6 =00000000                M spsl1	=	op1
000111D6 =00000000                M spsl2	=	op2
000111D6 =00000001                M spsl3	=	op3
000111D6 =00000000                M spsl4	=	op4
000111D6                            	spReleaseRt	$05, $07, $06, $08
000111D6 =00000005                M sprr1	=	op1
000111D6 =00000007                M sprr2	=	op2
000111D6 =00000006                M sprr3	=	op3
000111D6 =00000008                M sprr4	=	op4
000111D6                            	spSSGEG		$00, $00, $00, $00
000111D6 =00000000                M spss1	=	op1
000111D6 =00000000                M spss2	=	op2
000111D6 =00000000                M spss3	=	op3
000111D6 =00000000                M spss4	=	op4
000111D6                            	spTotalLv	$23, $19, $04, $05
000111D6 =00000023                M sptl1	=	op1
000111D6 =00000019                M sptl2	=	op2
000111D6 =00000004                M sptl3	=	op3
000111D6 =00000005                M sptl4	=	op4
000111D6 33                       M 	dc.b	(spfe<<3)+spal
000111D7 =00000080                M sptlmask4	set	$80
000111D7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000111D7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000111D7 =00000000                M sptlmask1	set	((spal=7)<<7)
000111D7 5260 1B31                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111DB 9A1F 9C9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111DF 081F 0919                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111E3 0000 0002                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111E7 0516 0708                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111EF 2304 1985                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111F3 4E41 54                  M 	dc.b	'NAT'
000111F6                            
000111F6                            	; Patch $1F
000111F6                            	; $1B
000111F6                            	; $31, $13, $71, $52,	$18, $10, $16, $13
000111F6                            	; $17, $9F, $1F, $1F,	$00, $00, $00, $00
000111F6                            	; $06, $01, $07, $0C,	$0C, $10, $0E, $05
000111F6                            	spAlgorithm	$03
000111F6 =00000020                M spatnum	=	spatnum+1
000111F6 =00000003                M spal	=	val
000111F6                            	spFeedback	$03
000111F6 =00000003                M spfe	=	val
000111F6                            	spDetune	$03, $07, $01, $05
000111F6 =00000003                M spde1	=	op1
000111F6 =00000007                M spde2	=	op2
000111F6 =00000001                M spde3	=	op3
000111F6 =00000005                M spde4	=	op4
000111F6                            	spMultiple	$01, $01, $03, $02
000111F6 =00000001                M spmu1	=	op1
000111F6 =00000001                M spmu2	=	op2
000111F6 =00000003                M spmu3	=	op3
000111F6 =00000002                M spmu4	=	op4
000111F6                            	spRateScale	$00, $00, $00, $00
000111F6 =00000000                M sprs1	=	op1
000111F6 =00000000                M sprs2	=	op2
000111F6 =00000000                M sprs3	=	op3
000111F6 =00000000                M sprs4	=	op4
000111F6                            	spAttackRt	$18, $16, $10, $13
000111F6 =00000018                M spar1	=	op1
000111F6 =00000016                M spar2	=	op2
000111F6 =00000010                M spar3	=	op3
000111F6 =00000013                M spar4	=	op4
000111F6                            	spAmpMod	$00, $00, $01, $00
000111F6 =00000000                M spam1	=	op1
000111F6 =00000000                M spam2	=	op2
000111F6 =00000001                M spam3	=	op3
000111F6 =00000000                M spam4	=	op4
000111F6                            	spSustainRt	$17, $1F, $1F, $1F
000111F6 =00000017                M spsr1	=	op1
000111F6 =0000001F                M spsr2	=	op2
000111F6 =0000001F                M spsr3	=	op3
000111F6 =0000001F                M spsr4	=	op4
000111F6                            	spDecayRt	$00, $00, $00, $00
000111F6 =00000000                M spdr1	=	op1
000111F6 =00000000                M spdr2	=	op2
000111F6 =00000000                M spdr3	=	op3
000111F6 =00000000                M spdr4	=	op4
000111F6                            	spSustainLv	$00, $00, $00, $00
000111F6 =00000000                M spsl1	=	op1
000111F6 =00000000                M spsl2	=	op2
000111F6 =00000000                M spsl3	=	op3
000111F6 =00000000                M spsl4	=	op4
000111F6                            	spReleaseRt	$06, $07, $01, $0C
000111F6 =00000006                M sprr1	=	op1
000111F6 =00000007                M sprr2	=	op2
000111F6 =00000001                M sprr3	=	op3
000111F6 =0000000C                M sprr4	=	op4
000111F6                            	spSSGEG		$00, $00, $00, $00
000111F6 =00000000                M spss1	=	op1
000111F6 =00000000                M spss2	=	op2
000111F6 =00000000                M spss3	=	op3
000111F6 =00000000                M spss4	=	op4
000111F6                            	spTotalLv	$0C, $0E, $10, $05
000111F6 =0000000C                M sptl1	=	op1
000111F6 =0000000E                M sptl2	=	op2
000111F6 =00000010                M sptl3	=	op3
000111F6 =00000005                M sptl4	=	op4
000111F6 1B                       M 	dc.b	(spfe<<3)+spal
000111F7 =00000080                M sptlmask4	set	$80
000111F7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000111F7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000111F7 =00000000                M sptlmask1	set	((spal=7)<<7)
000111F7 3113 7152                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111FB 1810 1613                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111FF 179F 1F1F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011203 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011207 0601 070C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001120B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001120F 0C10 0E85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011213 4E41 54                  M 	dc.b	'NAT'
00011216                            
00011216                            	; Patch $20
00011216                            	; $11
00011216                            	; $01, $75, $64, $31,	$1F, $9F, $5F, $9F
00011216                            	; $04, $88, $06, $01,	$02, $02, $02, $02
00011216                            	; $81, $31, $51, $6A,	$08, $12, $16, $05
00011216                            	spAlgorithm	$01
00011216 =00000021                M spatnum	=	spatnum+1
00011216 =00000001                M spal	=	val
00011216                            	spFeedback	$02
00011216 =00000002                M spfe	=	val
00011216                            	spDetune	$00, $06, $07, $03
00011216 =00000000                M spde1	=	op1
00011216 =00000006                M spde2	=	op2
00011216 =00000007                M spde3	=	op3
00011216 =00000003                M spde4	=	op4
00011216                            	spMultiple	$01, $04, $05, $01
00011216 =00000001                M spmu1	=	op1
00011216 =00000004                M spmu2	=	op2
00011216 =00000005                M spmu3	=	op3
00011216 =00000001                M spmu4	=	op4
00011216                            	spRateScale	$00, $01, $02, $02
00011216 =00000000                M sprs1	=	op1
00011216 =00000001                M sprs2	=	op2
00011216 =00000002                M sprs3	=	op3
00011216 =00000002                M sprs4	=	op4
00011216                            	spAttackRt	$1F, $1F, $1F, $1F
00011216 =0000001F                M spar1	=	op1
00011216 =0000001F                M spar2	=	op2
00011216 =0000001F                M spar3	=	op3
00011216 =0000001F                M spar4	=	op4
00011216                            	spAmpMod	$00, $00, $01, $00
00011216 =00000000                M spam1	=	op1
00011216 =00000000                M spam2	=	op2
00011216 =00000001                M spam3	=	op3
00011216 =00000000                M spam4	=	op4
00011216                            	spSustainRt	$04, $06, $08, $01
00011216 =00000004                M spsr1	=	op1
00011216 =00000006                M spsr2	=	op2
00011216 =00000008                M spsr3	=	op3
00011216 =00000001                M spsr4	=	op4
00011216                            	spDecayRt	$02, $02, $02, $02
00011216 =00000002                M spdr1	=	op1
00011216 =00000002                M spdr2	=	op2
00011216 =00000002                M spdr3	=	op3
00011216 =00000002                M spdr4	=	op4
00011216                            	spSustainLv	$08, $05, $03, $06
00011216 =00000008                M spsl1	=	op1
00011216 =00000005                M spsl2	=	op2
00011216 =00000003                M spsl3	=	op3
00011216 =00000006                M spsl4	=	op4
00011216                            	spReleaseRt	$01, $01, $01, $0A
00011216 =00000001                M sprr1	=	op1
00011216 =00000001                M sprr2	=	op2
00011216 =00000001                M sprr3	=	op3
00011216 =0000000A                M sprr4	=	op4
00011216                            	spSSGEG		$00, $00, $00, $00
00011216 =00000000                M spss1	=	op1
00011216 =00000000                M spss2	=	op2
00011216 =00000000                M spss3	=	op3
00011216 =00000000                M spss4	=	op4
00011216                            	spTotalLv	$08, $16, $12, $05
00011216 =00000008                M sptl1	=	op1
00011216 =00000016                M sptl2	=	op2
00011216 =00000012                M sptl3	=	op3
00011216 =00000005                M sptl4	=	op4
00011216 11                       M 	dc.b	(spfe<<3)+spal
00011217 =00000080                M sptlmask4	set	$80
00011217 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011217 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011217 =00000000                M sptlmask1	set	((spal=7)<<7)
00011217 0175 6431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001121B 1F9F 5F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001121F 0488 0601                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011223 0202 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011227 8131 516A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001122B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001122F 0812 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011233 4E41 54                  M 	dc.b	'NAT'
00011236                            
00011236                            	; Patch $21
00011236                            	; $22
00011236                            	; $50, $05, $10, $00,	$D8, $DD, $DD, $9F
00011236                            	; $04, $05, $08, $0B,	$00, $00, $00, $06
00011236                            	; $FC, $FF, $FC, $FF,	$14, $16, $2B, $02
00011236                            	spAlgorithm	$02
00011236 =00000022                M spatnum	=	spatnum+1
00011236 =00000002                M spal	=	val
00011236                            	spFeedback	$04
00011236 =00000004                M spfe	=	val
00011236                            	spDetune	$05, $01, $00, $00
00011236 =00000005                M spde1	=	op1
00011236 =00000001                M spde2	=	op2
00011236 =00000000                M spde3	=	op3
00011236 =00000000                M spde4	=	op4
00011236                            	spMultiple	$00, $00, $05, $00
00011236 =00000000                M spmu1	=	op1
00011236 =00000000                M spmu2	=	op2
00011236 =00000005                M spmu3	=	op3
00011236 =00000000                M spmu4	=	op4
00011236                            	spRateScale	$03, $03, $03, $02
00011236 =00000003                M sprs1	=	op1
00011236 =00000003                M sprs2	=	op2
00011236 =00000003                M sprs3	=	op3
00011236 =00000002                M sprs4	=	op4
00011236                            	spAttackRt	$18, $1D, $1D, $1F
00011236 =00000018                M spar1	=	op1
00011236 =0000001D                M spar2	=	op2
00011236 =0000001D                M spar3	=	op3
00011236 =0000001F                M spar4	=	op4
00011236                            	spAmpMod	$00, $00, $00, $00
00011236 =00000000                M spam1	=	op1
00011236 =00000000                M spam2	=	op2
00011236 =00000000                M spam3	=	op3
00011236 =00000000                M spam4	=	op4
00011236                            	spSustainRt	$04, $08, $05, $0B
00011236 =00000004                M spsr1	=	op1
00011236 =00000008                M spsr2	=	op2
00011236 =00000005                M spsr3	=	op3
00011236 =0000000B                M spsr4	=	op4
00011236                            	spDecayRt	$00, $00, $00, $06
00011236 =00000000                M spdr1	=	op1
00011236 =00000000                M spdr2	=	op2
00011236 =00000000                M spdr3	=	op3
00011236 =00000006                M spdr4	=	op4
00011236                            	spSustainLv	$0F, $0F, $0F, $0F
00011236 =0000000F                M spsl1	=	op1
00011236 =0000000F                M spsl2	=	op2
00011236 =0000000F                M spsl3	=	op3
00011236 =0000000F                M spsl4	=	op4
00011236                            	spReleaseRt	$0C, $0C, $0F, $0F
00011236 =0000000C                M sprr1	=	op1
00011236 =0000000C                M sprr2	=	op2
00011236 =0000000F                M sprr3	=	op3
00011236 =0000000F                M sprr4	=	op4
00011236                            	spSSGEG		$00, $00, $00, $00
00011236 =00000000                M spss1	=	op1
00011236 =00000000                M spss2	=	op2
00011236 =00000000                M spss3	=	op3
00011236 =00000000                M spss4	=	op4
00011236                            	spTotalLv	$14, $2B, $16, $02
00011236 =00000014                M sptl1	=	op1
00011236 =0000002B                M sptl2	=	op2
00011236 =00000016                M sptl3	=	op3
00011236 =00000002                M sptl4	=	op4
00011236 22                       M 	dc.b	(spfe<<3)+spal
00011237 =00000080                M sptlmask4	set	$80
00011237 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011237 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011237 =00000000                M sptlmask1	set	((spal=7)<<7)
00011237 5005 1000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001123B D8DD DD9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001123F 0405 080B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011243 0000 0006                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011247 FCFF FCFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001124B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001124F 1416 2B82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011253 4E41 54                  M 	dc.b	'NAT'
00011256                            
00011256                            	; Patch $22
00011256                            	; $35
00011256                            	; $01, $00, $72, $31,	$9F, $14, $52, $52
00011256                            	; $0A, $8A, $8A, $0A,	$09, $0E, $0F, $10
00011256                            	; $11, $26, $26, $26,	$0F, $08, $05, $05
00011256                            	spAlgorithm	$05
00011256 =00000023                M spatnum	=	spatnum+1
00011256 =00000005                M spal	=	val
00011256                            	spFeedback	$06
00011256 =00000006                M spfe	=	val
00011256                            	spDetune	$00, $07, $00, $03
00011256 =00000000                M spde1	=	op1
00011256 =00000007                M spde2	=	op2
00011256 =00000000                M spde3	=	op3
00011256 =00000003                M spde4	=	op4
00011256                            	spMultiple	$01, $02, $00, $01
00011256 =00000001                M spmu1	=	op1
00011256 =00000002                M spmu2	=	op2
00011256 =00000000                M spmu3	=	op3
00011256 =00000001                M spmu4	=	op4
00011256                            	spRateScale	$02, $01, $00, $01
00011256 =00000002                M sprs1	=	op1
00011256 =00000001                M sprs2	=	op2
00011256 =00000000                M sprs3	=	op3
00011256 =00000001                M sprs4	=	op4
00011256                            	spAttackRt	$1F, $12, $14, $12
00011256 =0000001F                M spar1	=	op1
00011256 =00000012                M spar2	=	op2
00011256 =00000014                M spar3	=	op3
00011256 =00000012                M spar4	=	op4
00011256                            	spAmpMod	$00, $01, $01, $00
00011256 =00000000                M spam1	=	op1
00011256 =00000001                M spam2	=	op2
00011256 =00000001                M spam3	=	op3
00011256 =00000000                M spam4	=	op4
00011256                            	spSustainRt	$0A, $0A, $0A, $0A
00011256 =0000000A                M spsr1	=	op1
00011256 =0000000A                M spsr2	=	op2
00011256 =0000000A                M spsr3	=	op3
00011256 =0000000A                M spsr4	=	op4
00011256                            	spDecayRt	$09, $0F, $0E, $10
00011256 =00000009                M spdr1	=	op1
00011256 =0000000F                M spdr2	=	op2
00011256 =0000000E                M spdr3	=	op3
00011256 =00000010                M spdr4	=	op4
00011256                            	spSustainLv	$01, $02, $02, $02
00011256 =00000001                M spsl1	=	op1
00011256 =00000002                M spsl2	=	op2
00011256 =00000002                M spsl3	=	op3
00011256 =00000002                M spsl4	=	op4
00011256                            	spReleaseRt	$01, $06, $06, $06
00011256 =00000001                M sprr1	=	op1
00011256 =00000006                M sprr2	=	op2
00011256 =00000006                M sprr3	=	op3
00011256 =00000006                M sprr4	=	op4
00011256                            	spSSGEG		$00, $00, $00, $00
00011256 =00000000                M spss1	=	op1
00011256 =00000000                M spss2	=	op2
00011256 =00000000                M spss3	=	op3
00011256 =00000000                M spss4	=	op4
00011256                            	spTotalLv	$0F, $05, $08, $05
00011256 =0000000F                M sptl1	=	op1
00011256 =00000005                M sptl2	=	op2
00011256 =00000008                M sptl3	=	op3
00011256 =00000005                M sptl4	=	op4
00011256 35                       M 	dc.b	(spfe<<3)+spal
00011257 =00000080                M sptlmask4	set	$80
00011257 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011257 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011257 =00000000                M sptlmask1	set	((spal=7)<<7)
00011257 0100 7231                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001125B 9F14 5252                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001125F 0A8A 8A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011263 090E 0F10                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011267 1126 2626                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001126B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001126F 0F88 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011273 4E41 54                  M 	dc.b	'NAT'
00011276                            
00011276                            	; Patch $23
00011276                            	; $0D
00011276                            	; $50, $02, $14, $00,	$9D, $5E, $9D, $5C
00011276                            	; $8C, $09, $8B, $02,	$00, $00, $09, $00
00011276                            	; $FF, $FF, $FF, $FF,	$0C, $10, $0B, $05
00011276                            	spAlgorithm	$05
00011276 =00000024                M spatnum	=	spatnum+1
00011276 =00000005                M spal	=	val
00011276                            	spFeedback	$01
00011276 =00000001                M spfe	=	val
00011276                            	spDetune	$05, $01, $00, $00
00011276 =00000005                M spde1	=	op1
00011276 =00000001                M spde2	=	op2
00011276 =00000000                M spde3	=	op3
00011276 =00000000                M spde4	=	op4
00011276                            	spMultiple	$00, $04, $02, $00
00011276 =00000000                M spmu1	=	op1
00011276 =00000004                M spmu2	=	op2
00011276 =00000002                M spmu3	=	op3
00011276 =00000000                M spmu4	=	op4
00011276                            	spRateScale	$02, $02, $01, $01
00011276 =00000002                M sprs1	=	op1
00011276 =00000002                M sprs2	=	op2
00011276 =00000001                M sprs3	=	op3
00011276 =00000001                M sprs4	=	op4
00011276                            	spAttackRt	$1D, $1D, $1E, $1C
00011276 =0000001D                M spar1	=	op1
00011276 =0000001D                M spar2	=	op2
00011276 =0000001E                M spar3	=	op3
00011276 =0000001C                M spar4	=	op4
00011276                            	spAmpMod	$01, $01, $00, $00
00011276 =00000001                M spam1	=	op1
00011276 =00000001                M spam2	=	op2
00011276 =00000000                M spam3	=	op3
00011276 =00000000                M spam4	=	op4
00011276                            	spSustainRt	$0C, $0B, $09, $02
00011276 =0000000C                M spsr1	=	op1
00011276 =0000000B                M spsr2	=	op2
00011276 =00000009                M spsr3	=	op3
00011276 =00000002                M spsr4	=	op4
00011276                            	spDecayRt	$00, $09, $00, $00
00011276 =00000000                M spdr1	=	op1
00011276 =00000009                M spdr2	=	op2
00011276 =00000000                M spdr3	=	op3
00011276 =00000000                M spdr4	=	op4
00011276                            	spSustainLv	$0F, $0F, $0F, $0F
00011276 =0000000F                M spsl1	=	op1
00011276 =0000000F                M spsl2	=	op2
00011276 =0000000F                M spsl3	=	op3
00011276 =0000000F                M spsl4	=	op4
00011276                            	spReleaseRt	$0F, $0F, $0F, $0F
00011276 =0000000F                M sprr1	=	op1
00011276 =0000000F                M sprr2	=	op2
00011276 =0000000F                M sprr3	=	op3
00011276 =0000000F                M sprr4	=	op4
00011276                            	spSSGEG		$00, $00, $00, $00
00011276 =00000000                M spss1	=	op1
00011276 =00000000                M spss2	=	op2
00011276 =00000000                M spss3	=	op3
00011276 =00000000                M spss4	=	op4
00011276                            	spTotalLv	$0C, $0B, $10, $05
00011276 =0000000C                M sptl1	=	op1
00011276 =0000000B                M sptl2	=	op2
00011276 =00000010                M sptl3	=	op3
00011276 =00000005                M sptl4	=	op4
00011276 0D                       M 	dc.b	(spfe<<3)+spal
00011277 =00000080                M sptlmask4	set	$80
00011277 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011277 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011277 =00000000                M sptlmask1	set	((spal=7)<<7)
00011277 5002 1400                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001127B 9D5E 9D5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001127F 8C09 8B02                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011283 0000 0900                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011287 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001128B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001128F 0C90 8B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011293 4E41 54                  M 	dc.b	'NAT'
00011296                            
00011296                            	; Patch $24
00011296                            	; $35
00011296                            	; $30, $01, $70, $30,	$5F, $57, $56, $5F
00011296                            	; $19, $0A, $0A, $0A,	$0F, $0F, $0F, $0F
00011296                            	; $05, $35, $35, $35,	$13, $05, $05, $05
00011296                            	spAlgorithm	$05
00011296 =00000025                M spatnum	=	spatnum+1
00011296 =00000005                M spal	=	val
00011296                            	spFeedback	$06
00011296 =00000006                M spfe	=	val
00011296                            	spDetune	$03, $07, $00, $03
00011296 =00000003                M spde1	=	op1
00011296 =00000007                M spde2	=	op2
00011296 =00000000                M spde3	=	op3
00011296 =00000003                M spde4	=	op4
00011296                            	spMultiple	$00, $00, $01, $00
00011296 =00000000                M spmu1	=	op1
00011296 =00000000                M spmu2	=	op2
00011296 =00000001                M spmu3	=	op3
00011296 =00000000                M spmu4	=	op4
00011296                            	spRateScale	$01, $01, $01, $01
00011296 =00000001                M sprs1	=	op1
00011296 =00000001                M sprs2	=	op2
00011296 =00000001                M sprs3	=	op3
00011296 =00000001                M sprs4	=	op4
00011296                            	spAttackRt	$1F, $16, $17, $1F
00011296 =0000001F                M spar1	=	op1
00011296 =00000016                M spar2	=	op2
00011296 =00000017                M spar3	=	op3
00011296 =0000001F                M spar4	=	op4
00011296                            	spAmpMod	$00, $00, $00, $00
00011296 =00000000                M spam1	=	op1
00011296 =00000000                M spam2	=	op2
00011296 =00000000                M spam3	=	op3
00011296 =00000000                M spam4	=	op4
00011296                            	spSustainRt	$19, $0A, $0A, $0A
00011296 =00000019                M spsr1	=	op1
00011296 =0000000A                M spsr2	=	op2
00011296 =0000000A                M spsr3	=	op3
00011296 =0000000A                M spsr4	=	op4
00011296                            	spDecayRt	$0F, $0F, $0F, $0F
00011296 =0000000F                M spdr1	=	op1
00011296 =0000000F                M spdr2	=	op2
00011296 =0000000F                M spdr3	=	op3
00011296 =0000000F                M spdr4	=	op4
00011296                            	spSustainLv	$00, $03, $03, $03
00011296 =00000000                M spsl1	=	op1
00011296 =00000003                M spsl2	=	op2
00011296 =00000003                M spsl3	=	op3
00011296 =00000003                M spsl4	=	op4
00011296                            	spReleaseRt	$05, $05, $05, $05
00011296 =00000005                M sprr1	=	op1
00011296 =00000005                M sprr2	=	op2
00011296 =00000005                M sprr3	=	op3
00011296 =00000005                M sprr4	=	op4
00011296                            	spSSGEG		$00, $00, $00, $00
00011296 =00000000                M spss1	=	op1
00011296 =00000000                M spss2	=	op2
00011296 =00000000                M spss3	=	op3
00011296 =00000000                M spss4	=	op4
00011296                            	spTotalLv	$13, $05, $05, $05
00011296 =00000013                M sptl1	=	op1
00011296 =00000005                M sptl2	=	op2
00011296 =00000005                M sptl3	=	op3
00011296 =00000005                M sptl4	=	op4
00011296 35                       M 	dc.b	(spfe<<3)+spal
00011297 =00000080                M sptlmask4	set	$80
00011297 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011297 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011297 =00000000                M sptlmask1	set	((spal=7)<<7)
00011297 3001 7030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001129B 5F57 565F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001129F 190A 0A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112A3 0F0F 0F0F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112A7 0535 3535                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112AF 1385 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112B3 4E41 54                  M 	dc.b	'NAT'
000112B6                            
000112B6                            	; Patch $25
000112B6                            	; $3B
000112B6                            	; $00, $01, $00, $03,	$1F, $1F, $16, $14
000112B6                            	; $03, $02, $02, $00,	$02, $02, $02, $1F
000112B6                            	; $22, $14, $13, $15,	$0E, $04, $23, $04
000112B6                            	spAlgorithm	$03
000112B6 =00000026                M spatnum	=	spatnum+1
000112B6 =00000003                M spal	=	val
000112B6                            	spFeedback	$07
000112B6 =00000007                M spfe	=	val
000112B6                            	spDetune	$00, $00, $00, $00
000112B6 =00000000                M spde1	=	op1
000112B6 =00000000                M spde2	=	op2
000112B6 =00000000                M spde3	=	op3
000112B6 =00000000                M spde4	=	op4
000112B6                            	spMultiple	$00, $00, $01, $03
000112B6 =00000000                M spmu1	=	op1
000112B6 =00000000                M spmu2	=	op2
000112B6 =00000001                M spmu3	=	op3
000112B6 =00000003                M spmu4	=	op4
000112B6                            	spRateScale	$00, $00, $00, $00
000112B6 =00000000                M sprs1	=	op1
000112B6 =00000000                M sprs2	=	op2
000112B6 =00000000                M sprs3	=	op3
000112B6 =00000000                M sprs4	=	op4
000112B6                            	spAttackRt	$1F, $16, $1F, $14
000112B6 =0000001F                M spar1	=	op1
000112B6 =00000016                M spar2	=	op2
000112B6 =0000001F                M spar3	=	op3
000112B6 =00000014                M spar4	=	op4
000112B6                            	spAmpMod	$00, $00, $00, $00
000112B6 =00000000                M spam1	=	op1
000112B6 =00000000                M spam2	=	op2
000112B6 =00000000                M spam3	=	op3
000112B6 =00000000                M spam4	=	op4
000112B6                            	spSustainRt	$03, $02, $02, $00
000112B6 =00000003                M spsr1	=	op1
000112B6 =00000002                M spsr2	=	op2
000112B6 =00000002                M spsr3	=	op3
000112B6 =00000000                M spsr4	=	op4
000112B6                            	spDecayRt	$02, $02, $02, $1F
000112B6 =00000002                M spdr1	=	op1
000112B6 =00000002                M spdr2	=	op2
000112B6 =00000002                M spdr3	=	op3
000112B6 =0000001F                M spdr4	=	op4
000112B6                            	spSustainLv	$02, $01, $01, $01
000112B6 =00000002                M spsl1	=	op1
000112B6 =00000001                M spsl2	=	op2
000112B6 =00000001                M spsl3	=	op3
000112B6 =00000001                M spsl4	=	op4
000112B6                            	spReleaseRt	$02, $03, $04, $05
000112B6 =00000002                M sprr1	=	op1
000112B6 =00000003                M sprr2	=	op2
000112B6 =00000004                M sprr3	=	op3
000112B6 =00000005                M sprr4	=	op4
000112B6                            	spSSGEG		$00, $00, $00, $00
000112B6 =00000000                M spss1	=	op1
000112B6 =00000000                M spss2	=	op2
000112B6 =00000000                M spss3	=	op3
000112B6 =00000000                M spss4	=	op4
000112B6                            	spTotalLv	$0E, $23, $04, $04
000112B6 =0000000E                M sptl1	=	op1
000112B6 =00000023                M sptl2	=	op2
000112B6 =00000004                M sptl3	=	op3
000112B6 =00000004                M sptl4	=	op4
000112B6 3B                       M 	dc.b	(spfe<<3)+spal
000112B7 =00000080                M sptlmask4	set	$80
000112B7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000112B7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000112B7 =00000000                M sptlmask1	set	((spal=7)<<7)
000112B7 0001 0003                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112BB 1F1F 1614                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112BF 0302 0200                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112C3 0202 021F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112C7 2214 1315                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112CF 0E04 2384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112D3 4E41 54                  M 	dc.b	'NAT'
000112D6                            
000112D6                            	; Patch $26
000112D6                            	; $3B
000112D6                            	; $30, $50, $33, $10,	$59, $55, $19, $1A
000112D6                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $03
000112D6                            	; $7E, $17, $27, $17,	$0F, $00, $0D, $05
000112D6                            	spAlgorithm	$03
000112D6 =00000027                M spatnum	=	spatnum+1
000112D6 =00000003                M spal	=	val
000112D6                            	spFeedback	$07
000112D6 =00000007                M spfe	=	val
000112D6                            	spDetune	$03, $03, $05, $01
000112D6 =00000003                M spde1	=	op1
000112D6 =00000003                M spde2	=	op2
000112D6 =00000005                M spde3	=	op3
000112D6 =00000001                M spde4	=	op4
000112D6                            	spMultiple	$00, $03, $00, $00
000112D6 =00000000                M spmu1	=	op1
000112D6 =00000003                M spmu2	=	op2
000112D6 =00000000                M spmu3	=	op3
000112D6 =00000000                M spmu4	=	op4
000112D6                            	spRateScale	$01, $00, $01, $00
000112D6 =00000001                M sprs1	=	op1
000112D6 =00000000                M sprs2	=	op2
000112D6 =00000001                M sprs3	=	op3
000112D6 =00000000                M sprs4	=	op4
000112D6                            	spAttackRt	$19, $19, $15, $1A
000112D6 =00000019                M spar1	=	op1
000112D6 =00000019                M spar2	=	op2
000112D6 =00000015                M spar3	=	op3
000112D6 =0000001A                M spar4	=	op4
000112D6                            	spAmpMod	$00, $00, $00, $00
000112D6 =00000000                M spam1	=	op1
000112D6 =00000000                M spam2	=	op2
000112D6 =00000000                M spam3	=	op3
000112D6 =00000000                M spam4	=	op4
000112D6                            	spSustainRt	$00, $00, $00, $00
000112D6 =00000000                M spsr1	=	op1
000112D6 =00000000                M spsr2	=	op2
000112D6 =00000000                M spsr3	=	op3
000112D6 =00000000                M spsr4	=	op4
000112D6                            	spDecayRt	$1F, $1F, $1F, $03
000112D6 =0000001F                M spdr1	=	op1
000112D6 =0000001F                M spdr2	=	op2
000112D6 =0000001F                M spdr3	=	op3
000112D6 =00000003                M spdr4	=	op4
000112D6                            	spSustainLv	$07, $02, $01, $01
000112D6 =00000007                M spsl1	=	op1
000112D6 =00000002                M spsl2	=	op2
000112D6 =00000001                M spsl3	=	op3
000112D6 =00000001                M spsl4	=	op4
000112D6                            	spReleaseRt	$0E, $07, $07, $07
000112D6 =0000000E                M sprr1	=	op1
000112D6 =00000007                M sprr2	=	op2
000112D6 =00000007                M sprr3	=	op3
000112D6 =00000007                M sprr4	=	op4
000112D6                            	spSSGEG		$00, $00, $00, $00
000112D6 =00000000                M spss1	=	op1
000112D6 =00000000                M spss2	=	op2
000112D6 =00000000                M spss3	=	op3
000112D6 =00000000                M spss4	=	op4
000112D6                            	spTotalLv	$0F, $0D, $00, $05
000112D6 =0000000F                M sptl1	=	op1
000112D6 =0000000D                M sptl2	=	op2
000112D6 =00000000                M sptl3	=	op3
000112D6 =00000005                M sptl4	=	op4
000112D6 3B                       M 	dc.b	(spfe<<3)+spal
000112D7 =00000080                M sptlmask4	set	$80
000112D7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000112D7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000112D7 =00000000                M sptlmask1	set	((spal=7)<<7)
000112D7 3050 3310                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112DB 5955 191A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112DF 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112E3 1F1F 1F03                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112E7 7E17 2717                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112EF 0F00 0D85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112F3 4E41 54                  M 	dc.b	'NAT'
000112F6                            
000112F6                            	; Patch $27
000112F6                            	; $35
000112F6                            	; $21, $31, $20, $14,	$8E, $9B, $95, $94
000112F6                            	; $00, $05, $00, $80,	$01, $02, $02, $02
000112F6                            	; $4F, $3F, $1F, $0F,	$16, $06, $08, $05
000112F6                            	spAlgorithm	$05
000112F6 =00000028                M spatnum	=	spatnum+1
000112F6 =00000005                M spal	=	val
000112F6                            	spFeedback	$06
000112F6 =00000006                M spfe	=	val
000112F6                            	spDetune	$02, $02, $03, $01
000112F6 =00000002                M spde1	=	op1
000112F6 =00000002                M spde2	=	op2
000112F6 =00000003                M spde3	=	op3
000112F6 =00000001                M spde4	=	op4
000112F6                            	spMultiple	$01, $00, $01, $04
000112F6 =00000001                M spmu1	=	op1
000112F6 =00000000                M spmu2	=	op2
000112F6 =00000001                M spmu3	=	op3
000112F6 =00000004                M spmu4	=	op4
000112F6                            	spRateScale	$02, $02, $02, $02
000112F6 =00000002                M sprs1	=	op1
000112F6 =00000002                M sprs2	=	op2
000112F6 =00000002                M sprs3	=	op3
000112F6 =00000002                M sprs4	=	op4
000112F6                            	spAttackRt	$0E, $15, $1B, $14
000112F6 =0000000E                M spar1	=	op1
000112F6 =00000015                M spar2	=	op2
000112F6 =0000001B                M spar3	=	op3
000112F6 =00000014                M spar4	=	op4
000112F6                            	spAmpMod	$00, $00, $00, $01
000112F6 =00000000                M spam1	=	op1
000112F6 =00000000                M spam2	=	op2
000112F6 =00000000                M spam3	=	op3
000112F6 =00000001                M spam4	=	op4
000112F6                            	spSustainRt	$00, $00, $05, $00
000112F6 =00000000                M spsr1	=	op1
000112F6 =00000000                M spsr2	=	op2
000112F6 =00000005                M spsr3	=	op3
000112F6 =00000000                M spsr4	=	op4
000112F6                            	spDecayRt	$01, $02, $02, $02
000112F6 =00000001                M spdr1	=	op1
000112F6 =00000002                M spdr2	=	op2
000112F6 =00000002                M spdr3	=	op3
000112F6 =00000002                M spdr4	=	op4
000112F6                            	spSustainLv	$04, $01, $03, $00
000112F6 =00000004                M spsl1	=	op1
000112F6 =00000001                M spsl2	=	op2
000112F6 =00000003                M spsl3	=	op3
000112F6 =00000000                M spsl4	=	op4
000112F6                            	spReleaseRt	$0F, $0F, $0F, $0F
000112F6 =0000000F                M sprr1	=	op1
000112F6 =0000000F                M sprr2	=	op2
000112F6 =0000000F                M sprr3	=	op3
000112F6 =0000000F                M sprr4	=	op4
000112F6                            	spSSGEG		$00, $00, $00, $00
000112F6 =00000000                M spss1	=	op1
000112F6 =00000000                M spss2	=	op2
000112F6 =00000000                M spss3	=	op3
000112F6 =00000000                M spss4	=	op4
000112F6                            	spTotalLv	$16, $08, $06, $05
000112F6 =00000016                M sptl1	=	op1
000112F6 =00000008                M sptl2	=	op2
000112F6 =00000006                M sptl3	=	op3
000112F6 =00000005                M sptl4	=	op4
000112F6 35                       M 	dc.b	(spfe<<3)+spal
000112F7 =00000080                M sptlmask4	set	$80
000112F7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000112F7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000112F7 =00000000                M sptlmask1	set	((spal=7)<<7)
000112F7 2131 2014                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112FB 8E9B 9594                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112FF 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011303 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011307 4F3F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001130B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001130F 1686 8885                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011313 4E41 54                  M 	dc.b	'NAT'
00011316                            
00011316                            	; Patch $28
00011316                            	; $24
00011316                            	; $01, $33, $00, $00,	$12, $0A, $0D, $0C
00011316                            	; $00, $8F, $03, $0F,	$00, $00, $00, $00
00011316                            	; $4F, $1F, $1F, $1F,	$03, $05, $10, $05
00011316                            	spAlgorithm	$04
00011316 =00000029                M spatnum	=	spatnum+1
00011316 =00000004                M spal	=	val
00011316                            	spFeedback	$04
00011316 =00000004                M spfe	=	val
00011316                            	spDetune	$00, $00, $03, $00
00011316 =00000000                M spde1	=	op1
00011316 =00000000                M spde2	=	op2
00011316 =00000003                M spde3	=	op3
00011316 =00000000                M spde4	=	op4
00011316                            	spMultiple	$01, $00, $03, $00
00011316 =00000001                M spmu1	=	op1
00011316 =00000000                M spmu2	=	op2
00011316 =00000003                M spmu3	=	op3
00011316 =00000000                M spmu4	=	op4
00011316                            	spRateScale	$00, $00, $00, $00
00011316 =00000000                M sprs1	=	op1
00011316 =00000000                M sprs2	=	op2
00011316 =00000000                M sprs3	=	op3
00011316 =00000000                M sprs4	=	op4
00011316                            	spAttackRt	$12, $0D, $0A, $0C
00011316 =00000012                M spar1	=	op1
00011316 =0000000D                M spar2	=	op2
00011316 =0000000A                M spar3	=	op3
00011316 =0000000C                M spar4	=	op4
00011316                            	spAmpMod	$00, $00, $01, $00
00011316 =00000000                M spam1	=	op1
00011316 =00000000                M spam2	=	op2
00011316 =00000001                M spam3	=	op3
00011316 =00000000                M spam4	=	op4
00011316                            	spSustainRt	$00, $03, $0F, $0F
00011316 =00000000                M spsr1	=	op1
00011316 =00000003                M spsr2	=	op2
00011316 =0000000F                M spsr3	=	op3
00011316 =0000000F                M spsr4	=	op4
00011316                            	spDecayRt	$00, $00, $00, $00
00011316 =00000000                M spdr1	=	op1
00011316 =00000000                M spdr2	=	op2
00011316 =00000000                M spdr3	=	op3
00011316 =00000000                M spdr4	=	op4
00011316                            	spSustainLv	$04, $01, $01, $01
00011316 =00000004                M spsl1	=	op1
00011316 =00000001                M spsl2	=	op2
00011316 =00000001                M spsl3	=	op3
00011316 =00000001                M spsl4	=	op4
00011316                            	spReleaseRt	$0F, $0F, $0F, $0F
00011316 =0000000F                M sprr1	=	op1
00011316 =0000000F                M sprr2	=	op2
00011316 =0000000F                M sprr3	=	op3
00011316 =0000000F                M sprr4	=	op4
00011316                            	spSSGEG		$00, $00, $00, $00
00011316 =00000000                M spss1	=	op1
00011316 =00000000                M spss2	=	op2
00011316 =00000000                M spss3	=	op3
00011316 =00000000                M spss4	=	op4
00011316                            	spTotalLv	$03, $10, $05, $05
00011316 =00000003                M sptl1	=	op1
00011316 =00000010                M sptl2	=	op2
00011316 =00000005                M sptl3	=	op3
00011316 =00000005                M sptl4	=	op4
00011316 24                       M 	dc.b	(spfe<<3)+spal
00011317 =00000080                M sptlmask4	set	$80
00011317 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011317 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011317 =00000000                M sptlmask1	set	((spal=7)<<7)
00011317 0133 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001131B 120A 0D0C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001131F 008F 030F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011323 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011327 4F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001132B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001132F 0385 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011333 4E41 54                  M 	dc.b	'NAT'
00011336                            
00011336                            	; Patch $29
00011336                            	; $29
00011336                            	; $33, $50, $02, $25,	$9D, $56, $13, $5E
00011336                            	; $01, $01, $00, $01,	$15, $0F, $0C, $0F
00011336                            	; $4F, $3F, $3F, $3F,	$13, $10, $1B, $05
00011336                            	spAlgorithm	$01
00011336 =0000002A                M spatnum	=	spatnum+1
00011336 =00000001                M spal	=	val
00011336                            	spFeedback	$05
00011336 =00000005                M spfe	=	val
00011336                            	spDetune	$03, $00, $05, $02
00011336 =00000003                M spde1	=	op1
00011336 =00000000                M spde2	=	op2
00011336 =00000005                M spde3	=	op3
00011336 =00000002                M spde4	=	op4
00011336                            	spMultiple	$03, $02, $00, $05
00011336 =00000003                M spmu1	=	op1
00011336 =00000002                M spmu2	=	op2
00011336 =00000000                M spmu3	=	op3
00011336 =00000005                M spmu4	=	op4
00011336                            	spRateScale	$02, $00, $01, $01
00011336 =00000002                M sprs1	=	op1
00011336 =00000000                M sprs2	=	op2
00011336 =00000001                M sprs3	=	op3
00011336 =00000001                M sprs4	=	op4
00011336                            	spAttackRt	$1D, $13, $16, $1E
00011336 =0000001D                M spar1	=	op1
00011336 =00000013                M spar2	=	op2
00011336 =00000016                M spar3	=	op3
00011336 =0000001E                M spar4	=	op4
00011336                            	spAmpMod	$00, $00, $00, $00
00011336 =00000000                M spam1	=	op1
00011336 =00000000                M spam2	=	op2
00011336 =00000000                M spam3	=	op3
00011336 =00000000                M spam4	=	op4
00011336                            	spSustainRt	$01, $00, $01, $01
00011336 =00000001                M spsr1	=	op1
00011336 =00000000                M spsr2	=	op2
00011336 =00000001                M spsr3	=	op3
00011336 =00000001                M spsr4	=	op4
00011336                            	spDecayRt	$15, $0C, $0F, $0F
00011336 =00000015                M spdr1	=	op1
00011336 =0000000C                M spdr2	=	op2
00011336 =0000000F                M spdr3	=	op3
00011336 =0000000F                M spdr4	=	op4
00011336                            	spSustainLv	$04, $03, $03, $03
00011336 =00000004                M spsl1	=	op1
00011336 =00000003                M spsl2	=	op2
00011336 =00000003                M spsl3	=	op3
00011336 =00000003                M spsl4	=	op4
00011336                            	spReleaseRt	$0F, $0F, $0F, $0F
00011336 =0000000F                M sprr1	=	op1
00011336 =0000000F                M sprr2	=	op2
00011336 =0000000F                M sprr3	=	op3
00011336 =0000000F                M sprr4	=	op4
00011336                            	spSSGEG		$00, $00, $00, $00
00011336 =00000000                M spss1	=	op1
00011336 =00000000                M spss2	=	op2
00011336 =00000000                M spss3	=	op3
00011336 =00000000                M spss4	=	op4
00011336                            	spTotalLv	$13, $1B, $10, $05
00011336 =00000013                M sptl1	=	op1
00011336 =0000001B                M sptl2	=	op2
00011336 =00000010                M sptl3	=	op3
00011336 =00000005                M sptl4	=	op4
00011336 29                       M 	dc.b	(spfe<<3)+spal
00011337 =00000080                M sptlmask4	set	$80
00011337 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011337 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011337 =00000000                M sptlmask1	set	((spal=7)<<7)
00011337 3350 0225                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001133B 9D56 135E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001133F 0101 0001                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011343 150F 0C0F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011347 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001134B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001134F 1310 1B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011353 4E41 54                  M 	dc.b	'NAT'
00011356                            
00011356                            	; Patch $2A
00011356                            	; $2B
00011356                            	; $31, $32, $35, $31,	$1F, $59, $9E, $5E
00011356                            	; $80, $80, $80, $85,	$01, $17, $12, $0A
00011356                            	; $AA, $AF, $F9, $FC,	$0F, $12, $46, $05
00011356                            	spAlgorithm	$03
00011356 =0000002B                M spatnum	=	spatnum+1
00011356 =00000003                M spal	=	val
00011356                            	spFeedback	$05
00011356 =00000005                M spfe	=	val
00011356                            	spDetune	$03, $03, $03, $03
00011356 =00000003                M spde1	=	op1
00011356 =00000003                M spde2	=	op2
00011356 =00000003                M spde3	=	op3
00011356 =00000003                M spde4	=	op4
00011356                            	spMultiple	$01, $05, $02, $01
00011356 =00000001                M spmu1	=	op1
00011356 =00000005                M spmu2	=	op2
00011356 =00000002                M spmu3	=	op3
00011356 =00000001                M spmu4	=	op4
00011356                            	spRateScale	$00, $02, $01, $01
00011356 =00000000                M sprs1	=	op1
00011356 =00000002                M sprs2	=	op2
00011356 =00000001                M sprs3	=	op3
00011356 =00000001                M sprs4	=	op4
00011356                            	spAttackRt	$1F, $1E, $19, $1E
00011356 =0000001F                M spar1	=	op1
00011356 =0000001E                M spar2	=	op2
00011356 =00000019                M spar3	=	op3
00011356 =0000001E                M spar4	=	op4
00011356                            	spAmpMod	$01, $01, $01, $01
00011356 =00000001                M spam1	=	op1
00011356 =00000001                M spam2	=	op2
00011356 =00000001                M spam3	=	op3
00011356 =00000001                M spam4	=	op4
00011356                            	spSustainRt	$00, $00, $00, $05
00011356 =00000000                M spsr1	=	op1
00011356 =00000000                M spsr2	=	op2
00011356 =00000000                M spsr3	=	op3
00011356 =00000005                M spsr4	=	op4
00011356                            	spDecayRt	$01, $12, $17, $0A
00011356 =00000001                M spdr1	=	op1
00011356 =00000012                M spdr2	=	op2
00011356 =00000017                M spdr3	=	op3
00011356 =0000000A                M spdr4	=	op4
00011356                            	spSustainLv	$0A, $0F, $0A, $0F
00011356 =0000000A                M spsl1	=	op1
00011356 =0000000F                M spsl2	=	op2
00011356 =0000000A                M spsl3	=	op3
00011356 =0000000F                M spsl4	=	op4
00011356                            	spReleaseRt	$0A, $09, $0F, $0C
00011356 =0000000A                M sprr1	=	op1
00011356 =00000009                M sprr2	=	op2
00011356 =0000000F                M sprr3	=	op3
00011356 =0000000C                M sprr4	=	op4
00011356                            	spSSGEG		$00, $00, $00, $00
00011356 =00000000                M spss1	=	op1
00011356 =00000000                M spss2	=	op2
00011356 =00000000                M spss3	=	op3
00011356 =00000000                M spss4	=	op4
00011356                            	spTotalLv	$0F, $46, $12, $05
00011356 =0000000F                M sptl1	=	op1
00011356 =00000046                M sptl2	=	op2
00011356 =00000012                M sptl3	=	op3
00011356 =00000005                M sptl4	=	op4
00011356 2B                       M 	dc.b	(spfe<<3)+spal
00011357 =00000080                M sptlmask4	set	$80
00011357 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011357 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011357 =00000000                M sptlmask1	set	((spal=7)<<7)
00011357 3132 3531                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001135B 1F59 9E5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001135F 8080 8085                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011363 0117 120A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011367 AAAF F9FC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001136B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001136F 0F12 4685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011373 4E41 54                  M 	dc.b	'NAT'
00011376                            
00011376                            	; Patch $2B
00011376                            	; $04
00011376                            	; $70, $70, $30, $31,	$9F, $1F, $9F, $1F
00011376                            	; $80, $80, $9F, $8E,	$00, $00, $12, $00
00011376                            	; $09, $09, $09, $09,	$33, $05, $08, $05
00011376                            	spAlgorithm	$04
00011376 =0000002C                M spatnum	=	spatnum+1
00011376 =00000004                M spal	=	val
00011376                            	spFeedback	$00
00011376 =00000000                M spfe	=	val
00011376                            	spDetune	$07, $03, $07, $03
00011376 =00000007                M spde1	=	op1
00011376 =00000003                M spde2	=	op2
00011376 =00000007                M spde3	=	op3
00011376 =00000003                M spde4	=	op4
00011376                            	spMultiple	$00, $00, $00, $01
00011376 =00000000                M spmu1	=	op1
00011376 =00000000                M spmu2	=	op2
00011376 =00000000                M spmu3	=	op3
00011376 =00000001                M spmu4	=	op4
00011376                            	spRateScale	$02, $02, $00, $00
00011376 =00000002                M sprs1	=	op1
00011376 =00000002                M sprs2	=	op2
00011376 =00000000                M sprs3	=	op3
00011376 =00000000                M sprs4	=	op4
00011376                            	spAttackRt	$1F, $1F, $1F, $1F
00011376 =0000001F                M spar1	=	op1
00011376 =0000001F                M spar2	=	op2
00011376 =0000001F                M spar3	=	op3
00011376 =0000001F                M spar4	=	op4
00011376                            	spAmpMod	$01, $01, $01, $01
00011376 =00000001                M spam1	=	op1
00011376 =00000001                M spam2	=	op2
00011376 =00000001                M spam3	=	op3
00011376 =00000001                M spam4	=	op4
00011376                            	spSustainRt	$00, $1F, $00, $0E
00011376 =00000000                M spsr1	=	op1
00011376 =0000001F                M spsr2	=	op2
00011376 =00000000                M spsr3	=	op3
00011376 =0000000E                M spsr4	=	op4
00011376                            	spDecayRt	$00, $12, $00, $00
00011376 =00000000                M spdr1	=	op1
00011376 =00000012                M spdr2	=	op2
00011376 =00000000                M spdr3	=	op3
00011376 =00000000                M spdr4	=	op4
00011376                            	spSustainLv	$00, $00, $00, $00
00011376 =00000000                M spsl1	=	op1
00011376 =00000000                M spsl2	=	op2
00011376 =00000000                M spsl3	=	op3
00011376 =00000000                M spsl4	=	op4
00011376                            	spReleaseRt	$09, $09, $09, $09
00011376 =00000009                M sprr1	=	op1
00011376 =00000009                M sprr2	=	op2
00011376 =00000009                M sprr3	=	op3
00011376 =00000009                M sprr4	=	op4
00011376                            	spSSGEG		$00, $00, $00, $00
00011376 =00000000                M spss1	=	op1
00011376 =00000000                M spss2	=	op2
00011376 =00000000                M spss3	=	op3
00011376 =00000000                M spss4	=	op4
00011376                            	spTotalLv	$33, $08, $05, $05
00011376 =00000033                M sptl1	=	op1
00011376 =00000008                M sptl2	=	op2
00011376 =00000005                M sptl3	=	op3
00011376 =00000005                M sptl4	=	op4
00011376 04                       M 	dc.b	(spfe<<3)+spal
00011377 =00000080                M sptlmask4	set	$80
00011377 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011377 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011377 =00000000                M sptlmask1	set	((spal=7)<<7)
00011377 7070 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001137B 9F1F 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001137F 8080 9F8E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011383 0000 1200                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011387 0909 0909                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001138B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001138F 3385 0885                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011393 4E41 54                  M 	dc.b	'NAT'
00011396                            
00011396                            	; Patch $2C
00011396                            	; $1F
00011396                            	; $16, $61, $03, $52,	$1C, $9F, $1F, $1F
00011396                            	; $92, $8F, $8F, $8F,	$00, $00, $00, $00
00011396                            	; $FF, $0F, $0F, $0F,	$05, $05, $05, $05
00011396                            	spAlgorithm	$07
00011396 =0000002D                M spatnum	=	spatnum+1
00011396 =00000007                M spal	=	val
00011396                            	spFeedback	$03
00011396 =00000003                M spfe	=	val
00011396                            	spDetune	$01, $00, $06, $05
00011396 =00000001                M spde1	=	op1
00011396 =00000000                M spde2	=	op2
00011396 =00000006                M spde3	=	op3
00011396 =00000005                M spde4	=	op4
00011396                            	spMultiple	$06, $03, $01, $02
00011396 =00000006                M spmu1	=	op1
00011396 =00000003                M spmu2	=	op2
00011396 =00000001                M spmu3	=	op3
00011396 =00000002                M spmu4	=	op4
00011396                            	spRateScale	$00, $00, $02, $00
00011396 =00000000                M sprs1	=	op1
00011396 =00000000                M sprs2	=	op2
00011396 =00000002                M sprs3	=	op3
00011396 =00000000                M sprs4	=	op4
00011396                            	spAttackRt	$1C, $1F, $1F, $1F
00011396 =0000001C                M spar1	=	op1
00011396 =0000001F                M spar2	=	op2
00011396 =0000001F                M spar3	=	op3
00011396 =0000001F                M spar4	=	op4
00011396                            	spAmpMod	$01, $01, $01, $01
00011396 =00000001                M spam1	=	op1
00011396 =00000001                M spam2	=	op2
00011396 =00000001                M spam3	=	op3
00011396 =00000001                M spam4	=	op4
00011396                            	spSustainRt	$12, $0F, $0F, $0F
00011396 =00000012                M spsr1	=	op1
00011396 =0000000F                M spsr2	=	op2
00011396 =0000000F                M spsr3	=	op3
00011396 =0000000F                M spsr4	=	op4
00011396                            	spDecayRt	$00, $00, $00, $00
00011396 =00000000                M spdr1	=	op1
00011396 =00000000                M spdr2	=	op2
00011396 =00000000                M spdr3	=	op3
00011396 =00000000                M spdr4	=	op4
00011396                            	spSustainLv	$0F, $00, $00, $00
00011396 =0000000F                M spsl1	=	op1
00011396 =00000000                M spsl2	=	op2
00011396 =00000000                M spsl3	=	op3
00011396 =00000000                M spsl4	=	op4
00011396                            	spReleaseRt	$0F, $0F, $0F, $0F
00011396 =0000000F                M sprr1	=	op1
00011396 =0000000F                M sprr2	=	op2
00011396 =0000000F                M sprr3	=	op3
00011396 =0000000F                M sprr4	=	op4
00011396                            	spSSGEG		$00, $00, $00, $00
00011396 =00000000                M spss1	=	op1
00011396 =00000000                M spss2	=	op2
00011396 =00000000                M spss3	=	op3
00011396 =00000000                M spss4	=	op4
00011396                            	spTotalLv	$05, $05, $05, $05
00011396 =00000005                M sptl1	=	op1
00011396 =00000005                M sptl2	=	op2
00011396 =00000005                M sptl3	=	op3
00011396 =00000005                M sptl4	=	op4
00011396 1F                       M 	dc.b	(spfe<<3)+spal
00011397 =00000080                M sptlmask4	set	$80
00011397 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011397 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011397 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
00011397 1661 0352                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001139B 1C9F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001139F 928F 8F8F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113A3 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113A7 FF0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113AF 8585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113B3 4E41 54                  M 	dc.b	'NAT'
000113B6                            
000113B6                            	; Patch $2D
000113B6                            	; $2C
000113B6                            	; $74, $74, $34, $34,	$12, $12, $12, $12
000113B6                            	; $80, $80, $80, $80,	$00, $01, $00, $01
000113B6                            	; $07, $37, $07, $37,	$16, $05, $17, $05
000113B6                            	spAlgorithm	$04
000113B6 =0000002E                M spatnum	=	spatnum+1
000113B6 =00000004                M spal	=	val
000113B6                            	spFeedback	$05
000113B6 =00000005                M spfe	=	val
000113B6                            	spDetune	$07, $03, $07, $03
000113B6 =00000007                M spde1	=	op1
000113B6 =00000003                M spde2	=	op2
000113B6 =00000007                M spde3	=	op3
000113B6 =00000003                M spde4	=	op4
000113B6                            	spMultiple	$04, $04, $04, $04
000113B6 =00000004                M spmu1	=	op1
000113B6 =00000004                M spmu2	=	op2
000113B6 =00000004                M spmu3	=	op3
000113B6 =00000004                M spmu4	=	op4
000113B6                            	spRateScale	$00, $00, $00, $00
000113B6 =00000000                M sprs1	=	op1
000113B6 =00000000                M sprs2	=	op2
000113B6 =00000000                M sprs3	=	op3
000113B6 =00000000                M sprs4	=	op4
000113B6                            	spAttackRt	$12, $12, $12, $12
000113B6 =00000012                M spar1	=	op1
000113B6 =00000012                M spar2	=	op2
000113B6 =00000012                M spar3	=	op3
000113B6 =00000012                M spar4	=	op4
000113B6                            	spAmpMod	$01, $01, $01, $01
000113B6 =00000001                M spam1	=	op1
000113B6 =00000001                M spam2	=	op2
000113B6 =00000001                M spam3	=	op3
000113B6 =00000001                M spam4	=	op4
000113B6                            	spSustainRt	$00, $00, $00, $00
000113B6 =00000000                M spsr1	=	op1
000113B6 =00000000                M spsr2	=	op2
000113B6 =00000000                M spsr3	=	op3
000113B6 =00000000                M spsr4	=	op4
000113B6                            	spDecayRt	$00, $00, $01, $01
000113B6 =00000000                M spdr1	=	op1
000113B6 =00000000                M spdr2	=	op2
000113B6 =00000001                M spdr3	=	op3
000113B6 =00000001                M spdr4	=	op4
000113B6                            	spSustainLv	$00, $00, $03, $03
000113B6 =00000000                M spsl1	=	op1
000113B6 =00000000                M spsl2	=	op2
000113B6 =00000003                M spsl3	=	op3
000113B6 =00000003                M spsl4	=	op4
000113B6                            	spReleaseRt	$07, $07, $07, $07
000113B6 =00000007                M sprr1	=	op1
000113B6 =00000007                M sprr2	=	op2
000113B6 =00000007                M sprr3	=	op3
000113B6 =00000007                M sprr4	=	op4
000113B6                            	spSSGEG		$00, $00, $00, $00
000113B6 =00000000                M spss1	=	op1
000113B6 =00000000                M spss2	=	op2
000113B6 =00000000                M spss3	=	op3
000113B6 =00000000                M spss4	=	op4
000113B6                            	spTotalLv	$16, $17, $05, $05
000113B6 =00000016                M sptl1	=	op1
000113B6 =00000017                M sptl2	=	op2
000113B6 =00000005                M sptl3	=	op3
000113B6 =00000005                M sptl4	=	op4
000113B6 2C                       M 	dc.b	(spfe<<3)+spal
000113B7 =00000080                M sptlmask4	set	$80
000113B7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000113B7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000113B7 =00000000                M sptlmask1	set	((spal=7)<<7)
000113B7 7474 3434                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113BB 1212 1212                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113BF 8080 8080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113C3 0001 0001                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113C7 0737 0737                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113CF 1685 1785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113D3 4E41 54                  M 	dc.b	'NAT'
000113D6                            
000113D6                            	; Patch $2E
000113D6                            	; $07
000113D6                            	; $34, $74, $32, $70,	$1F, $1F, $1F, $1F
000113D6                            	; $0A, $0A, $05, $03,	$00, $00, $00, $00
000113D6                            	; $3F, $3F, $2F, $2F,	$05, $05, $05, $05
000113D6                            	spAlgorithm	$07
000113D6 =0000002F                M spatnum	=	spatnum+1
000113D6 =00000007                M spal	=	val
000113D6                            	spFeedback	$00
000113D6 =00000000                M spfe	=	val
000113D6                            	spDetune	$03, $03, $07, $07
000113D6 =00000003                M spde1	=	op1
000113D6 =00000003                M spde2	=	op2
000113D6 =00000007                M spde3	=	op3
000113D6 =00000007                M spde4	=	op4
000113D6                            	spMultiple	$04, $02, $04, $00
000113D6 =00000004                M spmu1	=	op1
000113D6 =00000002                M spmu2	=	op2
000113D6 =00000004                M spmu3	=	op3
000113D6 =00000000                M spmu4	=	op4
000113D6                            	spRateScale	$00, $00, $00, $00
000113D6 =00000000                M sprs1	=	op1
000113D6 =00000000                M sprs2	=	op2
000113D6 =00000000                M sprs3	=	op3
000113D6 =00000000                M sprs4	=	op4
000113D6                            	spAttackRt	$1F, $1F, $1F, $1F
000113D6 =0000001F                M spar1	=	op1
000113D6 =0000001F                M spar2	=	op2
000113D6 =0000001F                M spar3	=	op3
000113D6 =0000001F                M spar4	=	op4
000113D6                            	spAmpMod	$00, $00, $00, $00
000113D6 =00000000                M spam1	=	op1
000113D6 =00000000                M spam2	=	op2
000113D6 =00000000                M spam3	=	op3
000113D6 =00000000                M spam4	=	op4
000113D6                            	spSustainRt	$0A, $05, $0A, $03
000113D6 =0000000A                M spsr1	=	op1
000113D6 =00000005                M spsr2	=	op2
000113D6 =0000000A                M spsr3	=	op3
000113D6 =00000003                M spsr4	=	op4
000113D6                            	spDecayRt	$00, $00, $00, $00
000113D6 =00000000                M spdr1	=	op1
000113D6 =00000000                M spdr2	=	op2
000113D6 =00000000                M spdr3	=	op3
000113D6 =00000000                M spdr4	=	op4
000113D6                            	spSustainLv	$03, $02, $03, $02
000113D6 =00000003                M spsl1	=	op1
000113D6 =00000002                M spsl2	=	op2
000113D6 =00000003                M spsl3	=	op3
000113D6 =00000002                M spsl4	=	op4
000113D6                            	spReleaseRt	$0F, $0F, $0F, $0F
000113D6 =0000000F                M sprr1	=	op1
000113D6 =0000000F                M sprr2	=	op2
000113D6 =0000000F                M sprr3	=	op3
000113D6 =0000000F                M sprr4	=	op4
000113D6                            	spSSGEG		$00, $00, $00, $00
000113D6 =00000000                M spss1	=	op1
000113D6 =00000000                M spss2	=	op2
000113D6 =00000000                M spss3	=	op3
000113D6 =00000000                M spss4	=	op4
000113D6                            	spTotalLv	$05, $05, $05, $05
000113D6 =00000005                M sptl1	=	op1
000113D6 =00000005                M sptl2	=	op2
000113D6 =00000005                M sptl3	=	op3
000113D6 =00000005                M sptl4	=	op4
000113D6 07                       M 	dc.b	(spfe<<3)+spal
000113D7 =00000080                M sptlmask4	set	$80
000113D7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000113D7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000113D7 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
000113D7 3474 3270                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113DB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113DF 0A0A 0503                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113E3 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113E7 3F3F 2F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113EF 8585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113F3 4E41 54                  M 	dc.b	'NAT'
000113F6                            
000113F6                            	; Patch $2F
000113F6                            	; $3A
000113F6                            	; $70, $76, $30, $71,	$1F, $95, $1F, $1F
000113F6                            	; $0E, $0F, $05, $0C,	$07, $06, $06, $07
000113F6                            	; $2F, $4F, $1F, $5F,	$18, $0E, $0F, $02
000113F6                            	spAlgorithm	$02
000113F6 =00000030                M spatnum	=	spatnum+1
000113F6 =00000002                M spal	=	val
000113F6                            	spFeedback	$07
000113F6 =00000007                M spfe	=	val
000113F6                            	spDetune	$07, $03, $07, $07
000113F6 =00000007                M spde1	=	op1
000113F6 =00000003                M spde2	=	op2
000113F6 =00000007                M spde3	=	op3
000113F6 =00000007                M spde4	=	op4
000113F6                            	spMultiple	$00, $00, $06, $01
000113F6 =00000000                M spmu1	=	op1
000113F6 =00000000                M spmu2	=	op2
000113F6 =00000006                M spmu3	=	op3
000113F6 =00000001                M spmu4	=	op4
000113F6                            	spRateScale	$00, $00, $02, $00
000113F6 =00000000                M sprs1	=	op1
000113F6 =00000000                M sprs2	=	op2
000113F6 =00000002                M sprs3	=	op3
000113F6 =00000000                M sprs4	=	op4
000113F6                            	spAttackRt	$1F, $1F, $15, $1F
000113F6 =0000001F                M spar1	=	op1
000113F6 =0000001F                M spar2	=	op2
000113F6 =00000015                M spar3	=	op3
000113F6 =0000001F                M spar4	=	op4
000113F6                            	spAmpMod	$00, $00, $00, $00
000113F6 =00000000                M spam1	=	op1
000113F6 =00000000                M spam2	=	op2
000113F6 =00000000                M spam3	=	op3
000113F6 =00000000                M spam4	=	op4
000113F6                            	spSustainRt	$0E, $05, $0F, $0C
000113F6 =0000000E                M spsr1	=	op1
000113F6 =00000005                M spsr2	=	op2
000113F6 =0000000F                M spsr3	=	op3
000113F6 =0000000C                M spsr4	=	op4
000113F6                            	spDecayRt	$07, $06, $06, $07
000113F6 =00000007                M spdr1	=	op1
000113F6 =00000006                M spdr2	=	op2
000113F6 =00000006                M spdr3	=	op3
000113F6 =00000007                M spdr4	=	op4
000113F6                            	spSustainLv	$02, $01, $04, $05
000113F6 =00000002                M spsl1	=	op1
000113F6 =00000001                M spsl2	=	op2
000113F6 =00000004                M spsl3	=	op3
000113F6 =00000005                M spsl4	=	op4
000113F6                            	spReleaseRt	$0F, $0F, $0F, $0F
000113F6 =0000000F                M sprr1	=	op1
000113F6 =0000000F                M sprr2	=	op2
000113F6 =0000000F                M sprr3	=	op3
000113F6 =0000000F                M sprr4	=	op4
000113F6                            	spSSGEG		$00, $00, $00, $00
000113F6 =00000000                M spss1	=	op1
000113F6 =00000000                M spss2	=	op2
000113F6 =00000000                M spss3	=	op3
000113F6 =00000000                M spss4	=	op4
000113F6                            	spTotalLv	$18, $0F, $0E, $02
000113F6 =00000018                M sptl1	=	op1
000113F6 =0000000F                M sptl2	=	op2
000113F6 =0000000E                M sptl3	=	op3
000113F6 =00000002                M sptl4	=	op4
000113F6 3A                       M 	dc.b	(spfe<<3)+spal
000113F7 =00000080                M sptlmask4	set	$80
000113F7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000113F7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000113F7 =00000000                M sptlmask1	set	((spal=7)<<7)
000113F7 7076 3071                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113FB 1F95 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113FF 0E0F 050C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011403 0706 0607                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011407 2F4F 1F5F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001140B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001140F 180E 0F82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011413 4E41 54                  M 	dc.b	'NAT'
00011416                            
00011416                            	; Patch $30
00011416                            	; $20
00011416                            	; $34, $38, $30, $31,	$DF, $DF, $9F, $9F
00011416                            	; $07, $08, $08, $0A,	$07, $0E, $0A, $11
00011416                            	; $20, $1F, $1F, $1F,	$22, $37, $14, $00
00011416                            	spAlgorithm	$00
00011416 =00000031                M spatnum	=	spatnum+1
00011416 =00000000                M spal	=	val
00011416                            	spFeedback	$04
00011416 =00000004                M spfe	=	val
00011416                            	spDetune	$03, $03, $03, $03
00011416 =00000003                M spde1	=	op1
00011416 =00000003                M spde2	=	op2
00011416 =00000003                M spde3	=	op3
00011416 =00000003                M spde4	=	op4
00011416                            	spMultiple	$04, $00, $08, $01
00011416 =00000004                M spmu1	=	op1
00011416 =00000000                M spmu2	=	op2
00011416 =00000008                M spmu3	=	op3
00011416 =00000001                M spmu4	=	op4
00011416                            	spRateScale	$03, $02, $03, $02
00011416 =00000003                M sprs1	=	op1
00011416 =00000002                M sprs2	=	op2
00011416 =00000003                M sprs3	=	op3
00011416 =00000002                M sprs4	=	op4
00011416                            	spAttackRt	$1F, $1F, $1F, $1F
00011416 =0000001F                M spar1	=	op1
00011416 =0000001F                M spar2	=	op2
00011416 =0000001F                M spar3	=	op3
00011416 =0000001F                M spar4	=	op4
00011416                            	spAmpMod	$00, $00, $00, $00
00011416 =00000000                M spam1	=	op1
00011416 =00000000                M spam2	=	op2
00011416 =00000000                M spam3	=	op3
00011416 =00000000                M spam4	=	op4
00011416                            	spSustainRt	$07, $08, $08, $0A
00011416 =00000007                M spsr1	=	op1
00011416 =00000008                M spsr2	=	op2
00011416 =00000008                M spsr3	=	op3
00011416 =0000000A                M spsr4	=	op4
00011416                            	spDecayRt	$07, $0A, $0E, $11
00011416 =00000007                M spdr1	=	op1
00011416 =0000000A                M spdr2	=	op2
00011416 =0000000E                M spdr3	=	op3
00011416 =00000011                M spdr4	=	op4
00011416                            	spSustainLv	$02, $01, $01, $01
00011416 =00000002                M spsl1	=	op1
00011416 =00000001                M spsl2	=	op2
00011416 =00000001                M spsl3	=	op3
00011416 =00000001                M spsl4	=	op4
00011416                            	spReleaseRt	$00, $0F, $0F, $0F
00011416 =00000000                M sprr1	=	op1
00011416 =0000000F                M sprr2	=	op2
00011416 =0000000F                M sprr3	=	op3
00011416 =0000000F                M sprr4	=	op4
00011416                            	spSSGEG		$00, $00, $00, $00
00011416 =00000000                M spss1	=	op1
00011416 =00000000                M spss2	=	op2
00011416 =00000000                M spss3	=	op3
00011416 =00000000                M spss4	=	op4
00011416                            	spTotalLv	$22, $14, $37, $00
00011416 =00000022                M sptl1	=	op1
00011416 =00000014                M sptl2	=	op2
00011416 =00000037                M sptl3	=	op3
00011416 =00000000                M sptl4	=	op4
00011416 20                       M 	dc.b	(spfe<<3)+spal
00011417 =00000080                M sptlmask4	set	$80
00011417 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011417 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011417 =00000000                M sptlmask1	set	((spal=7)<<7)
00011417 3438 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001141B DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001141F 0708 080A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011423 070E 0A11                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011427 201F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001142B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001142F 2237 1480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011433 4E41 54                  M 	dc.b	'NAT'
00011436                            
00011436                            	; Patch $31
00011436                            	; $3A
00011436                            	; $31, $7F, $61, $0A,	$9C, $DB, $9C, $9A
00011436                            	; $04, $08, $03, $09,	$03, $01, $00, $00
00011436                            	; $1F, $0F, $FF, $FF,	$23, $25, $1B, $06
00011436                            	spAlgorithm	$02
00011436 =00000032                M spatnum	=	spatnum+1
00011436 =00000002                M spal	=	val
00011436                            	spFeedback	$07
00011436 =00000007                M spfe	=	val
00011436                            	spDetune	$03, $06, $07, $00
00011436 =00000003                M spde1	=	op1
00011436 =00000006                M spde2	=	op2
00011436 =00000007                M spde3	=	op3
00011436 =00000000                M spde4	=	op4
00011436                            	spMultiple	$01, $01, $0F, $0A
00011436 =00000001                M spmu1	=	op1
00011436 =00000001                M spmu2	=	op2
00011436 =0000000F                M spmu3	=	op3
00011436 =0000000A                M spmu4	=	op4
00011436                            	spRateScale	$02, $02, $03, $02
00011436 =00000002                M sprs1	=	op1
00011436 =00000002                M sprs2	=	op2
00011436 =00000003                M sprs3	=	op3
00011436 =00000002                M sprs4	=	op4
00011436                            	spAttackRt	$1C, $1C, $1B, $1A
00011436 =0000001C                M spar1	=	op1
00011436 =0000001C                M spar2	=	op2
00011436 =0000001B                M spar3	=	op3
00011436 =0000001A                M spar4	=	op4
00011436                            	spAmpMod	$00, $00, $00, $00
00011436 =00000000                M spam1	=	op1
00011436 =00000000                M spam2	=	op2
00011436 =00000000                M spam3	=	op3
00011436 =00000000                M spam4	=	op4
00011436                            	spSustainRt	$04, $03, $08, $09
00011436 =00000004                M spsr1	=	op1
00011436 =00000003                M spsr2	=	op2
00011436 =00000008                M spsr3	=	op3
00011436 =00000009                M spsr4	=	op4
00011436                            	spDecayRt	$03, $00, $01, $00
00011436 =00000003                M spdr1	=	op1
00011436 =00000000                M spdr2	=	op2
00011436 =00000001                M spdr3	=	op3
00011436 =00000000                M spdr4	=	op4
00011436                            	spSustainLv	$01, $0F, $00, $0F
00011436 =00000001                M spsl1	=	op1
00011436 =0000000F                M spsl2	=	op2
00011436 =00000000                M spsl3	=	op3
00011436 =0000000F                M spsl4	=	op4
00011436                            	spReleaseRt	$0F, $0F, $0F, $0F
00011436 =0000000F                M sprr1	=	op1
00011436 =0000000F                M sprr2	=	op2
00011436 =0000000F                M sprr3	=	op3
00011436 =0000000F                M sprr4	=	op4
00011436                            	spSSGEG		$00, $00, $00, $00
00011436 =00000000                M spss1	=	op1
00011436 =00000000                M spss2	=	op2
00011436 =00000000                M spss3	=	op3
00011436 =00000000                M spss4	=	op4
00011436                            	spTotalLv	$23, $1B, $25, $06
00011436 =00000023                M sptl1	=	op1
00011436 =0000001B                M sptl2	=	op2
00011436 =00000025                M sptl3	=	op3
00011436 =00000006                M sptl4	=	op4
00011436 3A                       M 	dc.b	(spfe<<3)+spal
00011437 =00000080                M sptlmask4	set	$80
00011437 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011437 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011437 =00000000                M sptlmask1	set	((spal=7)<<7)
00011437 317F 610A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001143B 9CDB 9C9A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001143F 0408 0309                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011443 0301 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011447 1F0F FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001144B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001144F 2325 1B86                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011453 4E41 54                  M 	dc.b	'NAT'
00011456                            
00011456                            	; Patch $32
00011456                            	; $04
00011456                            	; $02, $02, $03, $03,	$13, $10, $13, $10
00011456                            	; $06, $0C, $06, $0C,	$00, $00, $00, $00
00011456                            	; $4F, $2F, $4F, $2F,	$18, $06, $18, $06
00011456                            	spAlgorithm	$04
00011456 =00000033                M spatnum	=	spatnum+1
00011456 =00000004                M spal	=	val
00011456                            	spFeedback	$00
00011456 =00000000                M spfe	=	val
00011456                            	spDetune	$00, $00, $00, $00
00011456 =00000000                M spde1	=	op1
00011456 =00000000                M spde2	=	op2
00011456 =00000000                M spde3	=	op3
00011456 =00000000                M spde4	=	op4
00011456                            	spMultiple	$02, $03, $02, $03
00011456 =00000002                M spmu1	=	op1
00011456 =00000003                M spmu2	=	op2
00011456 =00000002                M spmu3	=	op3
00011456 =00000003                M spmu4	=	op4
00011456                            	spRateScale	$00, $00, $00, $00
00011456 =00000000                M sprs1	=	op1
00011456 =00000000                M sprs2	=	op2
00011456 =00000000                M sprs3	=	op3
00011456 =00000000                M sprs4	=	op4
00011456                            	spAttackRt	$13, $13, $10, $10
00011456 =00000013                M spar1	=	op1
00011456 =00000013                M spar2	=	op2
00011456 =00000010                M spar3	=	op3
00011456 =00000010                M spar4	=	op4
00011456                            	spAmpMod	$00, $00, $00, $00
00011456 =00000000                M spam1	=	op1
00011456 =00000000                M spam2	=	op2
00011456 =00000000                M spam3	=	op3
00011456 =00000000                M spam4	=	op4
00011456                            	spSustainRt	$06, $06, $0C, $0C
00011456 =00000006                M spsr1	=	op1
00011456 =00000006                M spsr2	=	op2
00011456 =0000000C                M spsr3	=	op3
00011456 =0000000C                M spsr4	=	op4
00011456                            	spDecayRt	$00, $00, $00, $00
00011456 =00000000                M spdr1	=	op1
00011456 =00000000                M spdr2	=	op2
00011456 =00000000                M spdr3	=	op3
00011456 =00000000                M spdr4	=	op4
00011456                            	spSustainLv	$04, $04, $02, $02
00011456 =00000004                M spsl1	=	op1
00011456 =00000004                M spsl2	=	op2
00011456 =00000002                M spsl3	=	op3
00011456 =00000002                M spsl4	=	op4
00011456                            	spReleaseRt	$0F, $0F, $0F, $0F
00011456 =0000000F                M sprr1	=	op1
00011456 =0000000F                M sprr2	=	op2
00011456 =0000000F                M sprr3	=	op3
00011456 =0000000F                M sprr4	=	op4
00011456                            	spSSGEG		$00, $00, $00, $00
00011456 =00000000                M spss1	=	op1
00011456 =00000000                M spss2	=	op2
00011456 =00000000                M spss3	=	op3
00011456 =00000000                M spss4	=	op4
00011456                            	spTotalLv	$18, $18, $06, $06
00011456 =00000018                M sptl1	=	op1
00011456 =00000018                M sptl2	=	op2
00011456 =00000006                M sptl3	=	op3
00011456 =00000006                M sptl4	=	op4
00011456 04                       M 	dc.b	(spfe<<3)+spal
00011457 =00000080                M sptlmask4	set	$80
00011457 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011457 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011457 =00000000                M sptlmask1	set	((spal=7)<<7)
00011457 0202 0303                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001145B 1310 1310                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001145F 060C 060C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011463 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011467 4F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001146B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001146F 1886 1886                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011473 4E41 54                  M 	dc.b	'NAT'
00011476                            
00011476                            	; Patch $33
00011476                            	; $38
00011476                            	; $75, $13, $71, $11,	$DF, $5F, $1F, $1F
00011476                            	; $0C, $0D, $01, $01,	$00, $00, $00, $00
00011476                            	; $FF, $FF, $FF, $FF,	$1E, $1E, $1E, $03
00011476                            	spAlgorithm	$00
00011476 =00000034                M spatnum	=	spatnum+1
00011476 =00000000                M spal	=	val
00011476                            	spFeedback	$07
00011476 =00000007                M spfe	=	val
00011476                            	spDetune	$07, $07, $01, $01
00011476 =00000007                M spde1	=	op1
00011476 =00000007                M spde2	=	op2
00011476 =00000001                M spde3	=	op3
00011476 =00000001                M spde4	=	op4
00011476                            	spMultiple	$05, $01, $03, $01
00011476 =00000005                M spmu1	=	op1
00011476 =00000001                M spmu2	=	op2
00011476 =00000003                M spmu3	=	op3
00011476 =00000001                M spmu4	=	op4
00011476                            	spRateScale	$03, $00, $01, $00
00011476 =00000003                M sprs1	=	op1
00011476 =00000000                M sprs2	=	op2
00011476 =00000001                M sprs3	=	op3
00011476 =00000000                M sprs4	=	op4
00011476                            	spAttackRt	$1F, $1F, $1F, $1F
00011476 =0000001F                M spar1	=	op1
00011476 =0000001F                M spar2	=	op2
00011476 =0000001F                M spar3	=	op3
00011476 =0000001F                M spar4	=	op4
00011476                            	spAmpMod	$00, $00, $00, $00
00011476 =00000000                M spam1	=	op1
00011476 =00000000                M spam2	=	op2
00011476 =00000000                M spam3	=	op3
00011476 =00000000                M spam4	=	op4
00011476                            	spSustainRt	$0C, $01, $0D, $01
00011476 =0000000C                M spsr1	=	op1
00011476 =00000001                M spsr2	=	op2
00011476 =0000000D                M spsr3	=	op3
00011476 =00000001                M spsr4	=	op4
00011476                            	spDecayRt	$00, $00, $00, $00
00011476 =00000000                M spdr1	=	op1
00011476 =00000000                M spdr2	=	op2
00011476 =00000000                M spdr3	=	op3
00011476 =00000000                M spdr4	=	op4
00011476                            	spSustainLv	$0F, $0F, $0F, $0F
00011476 =0000000F                M spsl1	=	op1
00011476 =0000000F                M spsl2	=	op2
00011476 =0000000F                M spsl3	=	op3
00011476 =0000000F                M spsl4	=	op4
00011476                            	spReleaseRt	$0F, $0F, $0F, $0F
00011476 =0000000F                M sprr1	=	op1
00011476 =0000000F                M sprr2	=	op2
00011476 =0000000F                M sprr3	=	op3
00011476 =0000000F                M sprr4	=	op4
00011476                            	spSSGEG		$00, $00, $00, $00
00011476 =00000000                M spss1	=	op1
00011476 =00000000                M spss2	=	op2
00011476 =00000000                M spss3	=	op3
00011476 =00000000                M spss4	=	op4
00011476                            	spTotalLv	$1E, $1E, $1E, $03
00011476 =0000001E                M sptl1	=	op1
00011476 =0000001E                M sptl2	=	op2
00011476 =0000001E                M sptl3	=	op3
00011476 =00000003                M sptl4	=	op4
00011476 38                       M 	dc.b	(spfe<<3)+spal
00011477 =00000080                M sptlmask4	set	$80
00011477 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011477 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011477 =00000000                M sptlmask1	set	((spal=7)<<7)
00011477 7513 7111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001147B DF5F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001147F 0C0D 0101                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011483 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011487 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001148B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001148F 1E1E 1E83                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011493 4E41 54                  M 	dc.b	'NAT'
00011496                            
00011496                            	; Patch $34
00011496                            	; $34
00011496                            	; $74, $21, $16, $71,	$11, $1F, $1F, $1F
00011496                            	; $08, $05, $08, $09,	$00, $00, $00, $00
00011496                            	; $FF, $FF, $FF, $FF,	$17, $05, $10, $05
00011496                            	spAlgorithm	$04
00011496 =00000035                M spatnum	=	spatnum+1
00011496 =00000004                M spal	=	val
00011496                            	spFeedback	$06
00011496 =00000006                M spfe	=	val
00011496                            	spDetune	$07, $01, $02, $07
00011496 =00000007                M spde1	=	op1
00011496 =00000001                M spde2	=	op2
00011496 =00000002                M spde3	=	op3
00011496 =00000007                M spde4	=	op4
00011496                            	spMultiple	$04, $06, $01, $01
00011496 =00000004                M spmu1	=	op1
00011496 =00000006                M spmu2	=	op2
00011496 =00000001                M spmu3	=	op3
00011496 =00000001                M spmu4	=	op4
00011496                            	spRateScale	$00, $00, $00, $00
00011496 =00000000                M sprs1	=	op1
00011496 =00000000                M sprs2	=	op2
00011496 =00000000                M sprs3	=	op3
00011496 =00000000                M sprs4	=	op4
00011496                            	spAttackRt	$11, $1F, $1F, $1F
00011496 =00000011                M spar1	=	op1
00011496 =0000001F                M spar2	=	op2
00011496 =0000001F                M spar3	=	op3
00011496 =0000001F                M spar4	=	op4
00011496                            	spAmpMod	$00, $00, $00, $00
00011496 =00000000                M spam1	=	op1
00011496 =00000000                M spam2	=	op2
00011496 =00000000                M spam3	=	op3
00011496 =00000000                M spam4	=	op4
00011496                            	spSustainRt	$08, $08, $05, $09
00011496 =00000008                M spsr1	=	op1
00011496 =00000008                M spsr2	=	op2
00011496 =00000005                M spsr3	=	op3
00011496 =00000009                M spsr4	=	op4
00011496                            	spDecayRt	$00, $00, $00, $00
00011496 =00000000                M spdr1	=	op1
00011496 =00000000                M spdr2	=	op2
00011496 =00000000                M spdr3	=	op3
00011496 =00000000                M spdr4	=	op4
00011496                            	spSustainLv	$0F, $0F, $0F, $0F
00011496 =0000000F                M spsl1	=	op1
00011496 =0000000F                M spsl2	=	op2
00011496 =0000000F                M spsl3	=	op3
00011496 =0000000F                M spsl4	=	op4
00011496                            	spReleaseRt	$0F, $0F, $0F, $0F
00011496 =0000000F                M sprr1	=	op1
00011496 =0000000F                M sprr2	=	op2
00011496 =0000000F                M sprr3	=	op3
00011496 =0000000F                M sprr4	=	op4
00011496                            	spSSGEG		$00, $00, $00, $00
00011496 =00000000                M spss1	=	op1
00011496 =00000000                M spss2	=	op2
00011496 =00000000                M spss3	=	op3
00011496 =00000000                M spss4	=	op4
00011496                            	spTotalLv	$17, $10, $05, $05
00011496 =00000017                M sptl1	=	op1
00011496 =00000010                M sptl2	=	op2
00011496 =00000005                M sptl3	=	op3
00011496 =00000005                M sptl4	=	op4
00011496 34                       M 	dc.b	(spfe<<3)+spal
00011497 =00000080                M sptlmask4	set	$80
00011497 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011497 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011497 =00000000                M sptlmask1	set	((spal=7)<<7)
00011497 7421 1671                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001149B 111F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001149F 0805 0809                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114A3 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114A7 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114AF 1785 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114B3 4E41 54                  M 	dc.b	'NAT'
000114B6                            
000114B6                            	; Patch $35
000114B6                            	; $38
000114B6                            	; $41, $11, $71, $41,	$16, $13, $0F, $17
000114B6                            	; $02, $0C, $05, $01,	$00, $0F, $00, $00
000114B6                            	; $1F, $3F, $5F, $1F,	$2A, $12, $24, $04
000114B6                            	spAlgorithm	$00
000114B6 =00000036                M spatnum	=	spatnum+1
000114B6 =00000000                M spal	=	val
000114B6                            	spFeedback	$07
000114B6 =00000007                M spfe	=	val
000114B6                            	spDetune	$04, $07, $01, $04
000114B6 =00000004                M spde1	=	op1
000114B6 =00000007                M spde2	=	op2
000114B6 =00000001                M spde3	=	op3
000114B6 =00000004                M spde4	=	op4
000114B6                            	spMultiple	$01, $01, $01, $01
000114B6 =00000001                M spmu1	=	op1
000114B6 =00000001                M spmu2	=	op2
000114B6 =00000001                M spmu3	=	op3
000114B6 =00000001                M spmu4	=	op4
000114B6                            	spRateScale	$00, $00, $00, $00
000114B6 =00000000                M sprs1	=	op1
000114B6 =00000000                M sprs2	=	op2
000114B6 =00000000                M sprs3	=	op3
000114B6 =00000000                M sprs4	=	op4
000114B6                            	spAttackRt	$16, $0F, $13, $17
000114B6 =00000016                M spar1	=	op1
000114B6 =0000000F                M spar2	=	op2
000114B6 =00000013                M spar3	=	op3
000114B6 =00000017                M spar4	=	op4
000114B6                            	spAmpMod	$00, $00, $00, $00
000114B6 =00000000                M spam1	=	op1
000114B6 =00000000                M spam2	=	op2
000114B6 =00000000                M spam3	=	op3
000114B6 =00000000                M spam4	=	op4
000114B6                            	spSustainRt	$02, $05, $0C, $01
000114B6 =00000002                M spsr1	=	op1
000114B6 =00000005                M spsr2	=	op2
000114B6 =0000000C                M spsr3	=	op3
000114B6 =00000001                M spsr4	=	op4
000114B6                            	spDecayRt	$00, $00, $0F, $00
000114B6 =00000000                M spdr1	=	op1
000114B6 =00000000                M spdr2	=	op2
000114B6 =0000000F                M spdr3	=	op3
000114B6 =00000000                M spdr4	=	op4
000114B6                            	spSustainLv	$01, $05, $03, $01
000114B6 =00000001                M spsl1	=	op1
000114B6 =00000005                M spsl2	=	op2
000114B6 =00000003                M spsl3	=	op3
000114B6 =00000001                M spsl4	=	op4
000114B6                            	spReleaseRt	$0F, $0F, $0F, $0F
000114B6 =0000000F                M sprr1	=	op1
000114B6 =0000000F                M sprr2	=	op2
000114B6 =0000000F                M sprr3	=	op3
000114B6 =0000000F                M sprr4	=	op4
000114B6                            	spSSGEG		$00, $00, $00, $00
000114B6 =00000000                M spss1	=	op1
000114B6 =00000000                M spss2	=	op2
000114B6 =00000000                M spss3	=	op3
000114B6 =00000000                M spss4	=	op4
000114B6                            	spTotalLv	$2A, $24, $12, $04
000114B6 =0000002A                M sptl1	=	op1
000114B6 =00000024                M sptl2	=	op2
000114B6 =00000012                M sptl3	=	op3
000114B6 =00000004                M sptl4	=	op4
000114B6 38                       M 	dc.b	(spfe<<3)+spal
000114B7 =00000080                M sptlmask4	set	$80
000114B7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000114B7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000114B7 =00000000                M sptlmask1	set	((spal=7)<<7)
000114B7 4111 7141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114BB 1613 0F17                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114BF 020C 0501                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114C3 000F 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114C7 1F3F 5F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114CF 2A12 2484                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114D3 4E41 54                  M 	dc.b	'NAT'
000114D6                            
000114D6                            	; Patch $36
000114D6                            	; $3D
000114D6                            	; $01, $01, $01, $01,	$94, $19, $19, $19
000114D6                            	; $0F, $0D, $0D, $0D,	$07, $04, $04, $04
000114D6                            	; $25, $1A, $1A, $1A,	$15, $05, $05, $05
000114D6                            	spAlgorithm	$05
000114D6 =00000037                M spatnum	=	spatnum+1
000114D6 =00000005                M spal	=	val
000114D6                            	spFeedback	$07
000114D6 =00000007                M spfe	=	val
000114D6                            	spDetune	$00, $00, $00, $00
000114D6 =00000000                M spde1	=	op1
000114D6 =00000000                M spde2	=	op2
000114D6 =00000000                M spde3	=	op3
000114D6 =00000000                M spde4	=	op4
000114D6                            	spMultiple	$01, $01, $01, $01
000114D6 =00000001                M spmu1	=	op1
000114D6 =00000001                M spmu2	=	op2
000114D6 =00000001                M spmu3	=	op3
000114D6 =00000001                M spmu4	=	op4
000114D6                            	spRateScale	$02, $00, $00, $00
000114D6 =00000002                M sprs1	=	op1
000114D6 =00000000                M sprs2	=	op2
000114D6 =00000000                M sprs3	=	op3
000114D6 =00000000                M sprs4	=	op4
000114D6                            	spAttackRt	$14, $19, $19, $19
000114D6 =00000014                M spar1	=	op1
000114D6 =00000019                M spar2	=	op2
000114D6 =00000019                M spar3	=	op3
000114D6 =00000019                M spar4	=	op4
000114D6                            	spAmpMod	$00, $00, $00, $00
000114D6 =00000000                M spam1	=	op1
000114D6 =00000000                M spam2	=	op2
000114D6 =00000000                M spam3	=	op3
000114D6 =00000000                M spam4	=	op4
000114D6                            	spSustainRt	$0F, $0D, $0D, $0D
000114D6 =0000000F                M spsr1	=	op1
000114D6 =0000000D                M spsr2	=	op2
000114D6 =0000000D                M spsr3	=	op3
000114D6 =0000000D                M spsr4	=	op4
000114D6                            	spDecayRt	$07, $04, $04, $04
000114D6 =00000007                M spdr1	=	op1
000114D6 =00000004                M spdr2	=	op2
000114D6 =00000004                M spdr3	=	op3
000114D6 =00000004                M spdr4	=	op4
000114D6                            	spSustainLv	$02, $01, $01, $01
000114D6 =00000002                M spsl1	=	op1
000114D6 =00000001                M spsl2	=	op2
000114D6 =00000001                M spsl3	=	op3
000114D6 =00000001                M spsl4	=	op4
000114D6                            	spReleaseRt	$05, $0A, $0A, $0A
000114D6 =00000005                M sprr1	=	op1
000114D6 =0000000A                M sprr2	=	op2
000114D6 =0000000A                M sprr3	=	op3
000114D6 =0000000A                M sprr4	=	op4
000114D6                            	spSSGEG		$00, $00, $00, $00
000114D6 =00000000                M spss1	=	op1
000114D6 =00000000                M spss2	=	op2
000114D6 =00000000                M spss3	=	op3
000114D6 =00000000                M spss4	=	op4
000114D6                            	spTotalLv	$15, $05, $05, $05
000114D6 =00000015                M sptl1	=	op1
000114D6 =00000005                M sptl2	=	op2
000114D6 =00000005                M sptl3	=	op3
000114D6 =00000005                M sptl4	=	op4
000114D6 3D                       M 	dc.b	(spfe<<3)+spal
000114D7 =00000080                M sptlmask4	set	$80
000114D7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000114D7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000114D7 =00000000                M sptlmask1	set	((spal=7)<<7)
000114D7 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114DB 9419 1919                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114DF 0F0D 0D0D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114E3 0704 0404                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114E7 251A 1A1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114EF 1585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114F3 4E41 54                  M 	dc.b	'NAT'
000114F6                            
000114F6                            	; Patch $37
000114F6                            	; $3A
000114F6                            	; $31, $77, $32, $02,	$1C, $13, $0E, $4E
000114F6                            	; $04, $10, $09, $0A,	$0C, $00, $03, $00
000114F6                            	; $16, $2B, $24, $18,	$1D, $13, $2A, $04
000114F6                            	spAlgorithm	$02
000114F6 =00000038                M spatnum	=	spatnum+1
000114F6 =00000002                M spal	=	val
000114F6                            	spFeedback	$07
000114F6 =00000007                M spfe	=	val
000114F6                            	spDetune	$03, $03, $07, $00
000114F6 =00000003                M spde1	=	op1
000114F6 =00000003                M spde2	=	op2
000114F6 =00000007                M spde3	=	op3
000114F6 =00000000                M spde4	=	op4
000114F6                            	spMultiple	$01, $02, $07, $02
000114F6 =00000001                M spmu1	=	op1
000114F6 =00000002                M spmu2	=	op2
000114F6 =00000007                M spmu3	=	op3
000114F6 =00000002                M spmu4	=	op4
000114F6                            	spRateScale	$00, $00, $00, $01
000114F6 =00000000                M sprs1	=	op1
000114F6 =00000000                M sprs2	=	op2
000114F6 =00000000                M sprs3	=	op3
000114F6 =00000001                M sprs4	=	op4
000114F6                            	spAttackRt	$1C, $0E, $13, $0E
000114F6 =0000001C                M spar1	=	op1
000114F6 =0000000E                M spar2	=	op2
000114F6 =00000013                M spar3	=	op3
000114F6 =0000000E                M spar4	=	op4
000114F6                            	spAmpMod	$00, $00, $00, $00
000114F6 =00000000                M spam1	=	op1
000114F6 =00000000                M spam2	=	op2
000114F6 =00000000                M spam3	=	op3
000114F6 =00000000                M spam4	=	op4
000114F6                            	spSustainRt	$04, $09, $10, $0A
000114F6 =00000004                M spsr1	=	op1
000114F6 =00000009                M spsr2	=	op2
000114F6 =00000010                M spsr3	=	op3
000114F6 =0000000A                M spsr4	=	op4
000114F6                            	spDecayRt	$0C, $03, $00, $00
000114F6 =0000000C                M spdr1	=	op1
000114F6 =00000003                M spdr2	=	op2
000114F6 =00000000                M spdr3	=	op3
000114F6 =00000000                M spdr4	=	op4
000114F6                            	spSustainLv	$01, $02, $02, $01
000114F6 =00000001                M spsl1	=	op1
000114F6 =00000002                M spsl2	=	op2
000114F6 =00000002                M spsl3	=	op3
000114F6 =00000001                M spsl4	=	op4
000114F6                            	spReleaseRt	$06, $04, $0B, $08
000114F6 =00000006                M sprr1	=	op1
000114F6 =00000004                M sprr2	=	op2
000114F6 =0000000B                M sprr3	=	op3
000114F6 =00000008                M sprr4	=	op4
000114F6                            	spSSGEG		$00, $00, $00, $00
000114F6 =00000000                M spss1	=	op1
000114F6 =00000000                M spss2	=	op2
000114F6 =00000000                M spss3	=	op3
000114F6 =00000000                M spss4	=	op4
000114F6                            	spTotalLv	$1D, $2A, $13, $04
000114F6 =0000001D                M sptl1	=	op1
000114F6 =0000002A                M sptl2	=	op2
000114F6 =00000013                M sptl3	=	op3
000114F6 =00000004                M sptl4	=	op4
000114F6 3A                       M 	dc.b	(spfe<<3)+spal
000114F7 =00000080                M sptlmask4	set	$80
000114F7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000114F7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000114F7 =00000000                M sptlmask1	set	((spal=7)<<7)
000114F7 3177 3202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114FB 1C13 0E4E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114FF 0410 090A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011503 0C00 0300                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011507 162B 2418                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001150B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001150F 1D13 2A84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011513 4E41 54                  M 	dc.b	'NAT'
00011516                            
00011516                            	; Patch $38
00011516                            	; $03
00011516                            	; $01, $78, $39, $3A,	$1F, $1F, $1F, $1F
00011516                            	; $06, $00, $08, $0A,	$00, $00, $00, $00
00011516                            	; $F4, $02, $56, $F5,	$33, $1B, $43, $04
00011516                            	spAlgorithm	$03
00011516 =00000039                M spatnum	=	spatnum+1
00011516 =00000003                M spal	=	val
00011516                            	spFeedback	$00
00011516 =00000000                M spfe	=	val
00011516                            	spDetune	$00, $03, $07, $03
00011516 =00000000                M spde1	=	op1
00011516 =00000003                M spde2	=	op2
00011516 =00000007                M spde3	=	op3
00011516 =00000003                M spde4	=	op4
00011516                            	spMultiple	$01, $09, $08, $0A
00011516 =00000001                M spmu1	=	op1
00011516 =00000009                M spmu2	=	op2
00011516 =00000008                M spmu3	=	op3
00011516 =0000000A                M spmu4	=	op4
00011516                            	spRateScale	$00, $00, $00, $00
00011516 =00000000                M sprs1	=	op1
00011516 =00000000                M sprs2	=	op2
00011516 =00000000                M sprs3	=	op3
00011516 =00000000                M sprs4	=	op4
00011516                            	spAttackRt	$1F, $1F, $1F, $1F
00011516 =0000001F                M spar1	=	op1
00011516 =0000001F                M spar2	=	op2
00011516 =0000001F                M spar3	=	op3
00011516 =0000001F                M spar4	=	op4
00011516                            	spAmpMod	$00, $00, $00, $00
00011516 =00000000                M spam1	=	op1
00011516 =00000000                M spam2	=	op2
00011516 =00000000                M spam3	=	op3
00011516 =00000000                M spam4	=	op4
00011516                            	spSustainRt	$06, $08, $00, $0A
00011516 =00000006                M spsr1	=	op1
00011516 =00000008                M spsr2	=	op2
00011516 =00000000                M spsr3	=	op3
00011516 =0000000A                M spsr4	=	op4
00011516                            	spDecayRt	$00, $00, $00, $00
00011516 =00000000                M spdr1	=	op1
00011516 =00000000                M spdr2	=	op2
00011516 =00000000                M spdr3	=	op3
00011516 =00000000                M spdr4	=	op4
00011516                            	spSustainLv	$0F, $05, $00, $0F
00011516 =0000000F                M spsl1	=	op1
00011516 =00000005                M spsl2	=	op2
00011516 =00000000                M spsl3	=	op3
00011516 =0000000F                M spsl4	=	op4
00011516                            	spReleaseRt	$04, $06, $02, $05
00011516 =00000004                M sprr1	=	op1
00011516 =00000006                M sprr2	=	op2
00011516 =00000002                M sprr3	=	op3
00011516 =00000005                M sprr4	=	op4
00011516                            	spSSGEG		$00, $00, $00, $00
00011516 =00000000                M spss1	=	op1
00011516 =00000000                M spss2	=	op2
00011516 =00000000                M spss3	=	op3
00011516 =00000000                M spss4	=	op4
00011516                            	spTotalLv	$33, $43, $1B, $04
00011516 =00000033                M sptl1	=	op1
00011516 =00000043                M sptl2	=	op2
00011516 =0000001B                M sptl3	=	op3
00011516 =00000004                M sptl4	=	op4
00011516 03                       M 	dc.b	(spfe<<3)+spal
00011517 =00000080                M sptlmask4	set	$80
00011517 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011517 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011517 =00000000                M sptlmask1	set	((spal=7)<<7)
00011517 0178 393A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001151B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001151F 0600 080A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011523 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011527 F402 56F5                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001152B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001152F 331B 4384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011533 4E41 54                  M 	dc.b	'NAT'
00011536                            
00011536                            	; Patch $39
00011536                            	; $3A
00011536                            	; $01, $07, $01, $01,	$8E, $8E, $8D, $53
00011536                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
00011536                            	; $13, $FA, $13, $0A,	$18, $1E, $27, $04
00011536                            	spAlgorithm	$02
00011536 =0000003A                M spatnum	=	spatnum+1
00011536 =00000002                M spal	=	val
00011536                            	spFeedback	$07
00011536 =00000007                M spfe	=	val
00011536                            	spDetune	$00, $00, $00, $00
00011536 =00000000                M spde1	=	op1
00011536 =00000000                M spde2	=	op2
00011536 =00000000                M spde3	=	op3
00011536 =00000000                M spde4	=	op4
00011536                            	spMultiple	$01, $01, $07, $01
00011536 =00000001                M spmu1	=	op1
00011536 =00000001                M spmu2	=	op2
00011536 =00000007                M spmu3	=	op3
00011536 =00000001                M spmu4	=	op4
00011536                            	spRateScale	$02, $02, $02, $01
00011536 =00000002                M sprs1	=	op1
00011536 =00000002                M sprs2	=	op2
00011536 =00000002                M sprs3	=	op3
00011536 =00000001                M sprs4	=	op4
00011536                            	spAttackRt	$0E, $0D, $0E, $13
00011536 =0000000E                M spar1	=	op1
00011536 =0000000D                M spar2	=	op2
00011536 =0000000E                M spar3	=	op3
00011536 =00000013                M spar4	=	op4
00011536                            	spAmpMod	$00, $00, $00, $00
00011536 =00000000                M spam1	=	op1
00011536 =00000000                M spam2	=	op2
00011536 =00000000                M spam3	=	op3
00011536 =00000000                M spam4	=	op4
00011536                            	spSustainRt	$0E, $0E, $0E, $03
00011536 =0000000E                M spsr1	=	op1
00011536 =0000000E                M spsr2	=	op2
00011536 =0000000E                M spsr3	=	op3
00011536 =00000003                M spsr4	=	op4
00011536                            	spDecayRt	$00, $00, $00, $00
00011536 =00000000                M spdr1	=	op1
00011536 =00000000                M spdr2	=	op2
00011536 =00000000                M spdr3	=	op3
00011536 =00000000                M spdr4	=	op4
00011536                            	spSustainLv	$01, $01, $0F, $00
00011536 =00000001                M spsl1	=	op1
00011536 =00000001                M spsl2	=	op2
00011536 =0000000F                M spsl3	=	op3
00011536 =00000000                M spsl4	=	op4
00011536                            	spReleaseRt	$03, $03, $0A, $0A
00011536 =00000003                M sprr1	=	op1
00011536 =00000003                M sprr2	=	op2
00011536 =0000000A                M sprr3	=	op3
00011536 =0000000A                M sprr4	=	op4
00011536                            	spSSGEG		$00, $00, $00, $00
00011536 =00000000                M spss1	=	op1
00011536 =00000000                M spss2	=	op2
00011536 =00000000                M spss3	=	op3
00011536 =00000000                M spss4	=	op4
00011536                            	spTotalLv	$18, $27, $1E, $04
00011536 =00000018                M sptl1	=	op1
00011536 =00000027                M sptl2	=	op2
00011536 =0000001E                M sptl3	=	op3
00011536 =00000004                M sptl4	=	op4
00011536 3A                       M 	dc.b	(spfe<<3)+spal
00011537 =00000080                M sptlmask4	set	$80
00011537 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011537 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011537 =00000000                M sptlmask1	set	((spal=7)<<7)
00011537 0107 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001153B 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001153F 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011543 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011547 13FA 130A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001154B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001154F 181E 2784                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011553 4E41 54                  M 	dc.b	'NAT'
00011556                            
00011556                            	; Patch $3A
00011556                            	; $24
00011556                            	; $7D, $35, $3D, $75,	$1F, $1F, $1F, $1F
00011556                            	; $01, $0D, $01, $0D,	$10, $12, $10, $12
00011556                            	; $F5, $38, $F5, $38,	$00, $04, $00, $04
00011556                            	spAlgorithm	$04
00011556 =0000003B                M spatnum	=	spatnum+1
00011556 =00000004                M spal	=	val
00011556                            	spFeedback	$04
00011556 =00000004                M spfe	=	val
00011556                            	spDetune	$07, $03, $03, $07
00011556 =00000007                M spde1	=	op1
00011556 =00000003                M spde2	=	op2
00011556 =00000003                M spde3	=	op3
00011556 =00000007                M spde4	=	op4
00011556                            	spMultiple	$0D, $0D, $05, $05
00011556 =0000000D                M spmu1	=	op1
00011556 =0000000D                M spmu2	=	op2
00011556 =00000005                M spmu3	=	op3
00011556 =00000005                M spmu4	=	op4
00011556                            	spRateScale	$00, $00, $00, $00
00011556 =00000000                M sprs1	=	op1
00011556 =00000000                M sprs2	=	op2
00011556 =00000000                M sprs3	=	op3
00011556 =00000000                M sprs4	=	op4
00011556                            	spAttackRt	$1F, $1F, $1F, $1F
00011556 =0000001F                M spar1	=	op1
00011556 =0000001F                M spar2	=	op2
00011556 =0000001F                M spar3	=	op3
00011556 =0000001F                M spar4	=	op4
00011556                            	spAmpMod	$00, $00, $00, $00
00011556 =00000000                M spam1	=	op1
00011556 =00000000                M spam2	=	op2
00011556 =00000000                M spam3	=	op3
00011556 =00000000                M spam4	=	op4
00011556                            	spSustainRt	$01, $01, $0D, $0D
00011556 =00000001                M spsr1	=	op1
00011556 =00000001                M spsr2	=	op2
00011556 =0000000D                M spsr3	=	op3
00011556 =0000000D                M spsr4	=	op4
00011556                            	spDecayRt	$10, $10, $12, $12
00011556 =00000010                M spdr1	=	op1
00011556 =00000010                M spdr2	=	op2
00011556 =00000012                M spdr3	=	op3
00011556 =00000012                M spdr4	=	op4
00011556                            	spSustainLv	$0F, $0F, $03, $03
00011556 =0000000F                M spsl1	=	op1
00011556 =0000000F                M spsl2	=	op2
00011556 =00000003                M spsl3	=	op3
00011556 =00000003                M spsl4	=	op4
00011556                            	spReleaseRt	$05, $05, $08, $08
00011556 =00000005                M sprr1	=	op1
00011556 =00000005                M sprr2	=	op2
00011556 =00000008                M sprr3	=	op3
00011556 =00000008                M sprr4	=	op4
00011556                            	spSSGEG		$00, $00, $00, $00
00011556 =00000000                M spss1	=	op1
00011556 =00000000                M spss2	=	op2
00011556 =00000000                M spss3	=	op3
00011556 =00000000                M spss4	=	op4
00011556                            	spTotalLv	$00, $00, $04, $04
00011556 =00000000                M sptl1	=	op1
00011556 =00000000                M sptl2	=	op2
00011556 =00000004                M sptl3	=	op3
00011556 =00000004                M sptl4	=	op4
00011556 24                       M 	dc.b	(spfe<<3)+spal
00011557 =00000080                M sptlmask4	set	$80
00011557 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011557 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011557 =00000000                M sptlmask1	set	((spal=7)<<7)
00011557 7D35 3D75                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001155B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001155F 010D 010D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011563 1012 1012                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011567 F538 F538                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001156B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001156F 0084 0084                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011573 4E41 54                  M 	dc.b	'NAT'
00011576                            
00011576                            	; Patch $3B
00011576                            	; $32
00011576                            	; $2A, $61, $65, $23,	$94, $10, $54, $19
00011576                            	; $85, $0B, $0E, $05,	$06, $04, $03, $03
00011576                            	; $12, $14, $24, $27,	$2E, $0A, $1B, $05
00011576                            	spAlgorithm	$02
00011576 =0000003C                M spatnum	=	spatnum+1
00011576 =00000002                M spal	=	val
00011576                            	spFeedback	$06
00011576 =00000006                M spfe	=	val
00011576                            	spDetune	$02, $06, $06, $02
00011576 =00000002                M spde1	=	op1
00011576 =00000006                M spde2	=	op2
00011576 =00000006                M spde3	=	op3
00011576 =00000002                M spde4	=	op4
00011576                            	spMultiple	$0A, $05, $01, $03
00011576 =0000000A                M spmu1	=	op1
00011576 =00000005                M spmu2	=	op2
00011576 =00000001                M spmu3	=	op3
00011576 =00000003                M spmu4	=	op4
00011576                            	spRateScale	$02, $01, $00, $00
00011576 =00000002                M sprs1	=	op1
00011576 =00000001                M sprs2	=	op2
00011576 =00000000                M sprs3	=	op3
00011576 =00000000                M sprs4	=	op4
00011576                            	spAttackRt	$14, $14, $10, $19
00011576 =00000014                M spar1	=	op1
00011576 =00000014                M spar2	=	op2
00011576 =00000010                M spar3	=	op3
00011576 =00000019                M spar4	=	op4
00011576                            	spAmpMod	$01, $00, $00, $00
00011576 =00000001                M spam1	=	op1
00011576 =00000000                M spam2	=	op2
00011576 =00000000                M spam3	=	op3
00011576 =00000000                M spam4	=	op4
00011576                            	spSustainRt	$05, $0E, $0B, $05
00011576 =00000005                M spsr1	=	op1
00011576 =0000000E                M spsr2	=	op2
00011576 =0000000B                M spsr3	=	op3
00011576 =00000005                M spsr4	=	op4
00011576                            	spDecayRt	$06, $03, $04, $03
00011576 =00000006                M spdr1	=	op1
00011576 =00000003                M spdr2	=	op2
00011576 =00000004                M spdr3	=	op3
00011576 =00000003                M spdr4	=	op4
00011576                            	spSustainLv	$01, $02, $01, $02
00011576 =00000001                M spsl1	=	op1
00011576 =00000002                M spsl2	=	op2
00011576 =00000001                M spsl3	=	op3
00011576 =00000002                M spsl4	=	op4
00011576                            	spReleaseRt	$02, $04, $04, $07
00011576 =00000002                M sprr1	=	op1
00011576 =00000004                M sprr2	=	op2
00011576 =00000004                M sprr3	=	op3
00011576 =00000007                M sprr4	=	op4
00011576                            	spSSGEG		$00, $00, $00, $00
00011576 =00000000                M spss1	=	op1
00011576 =00000000                M spss2	=	op2
00011576 =00000000                M spss3	=	op3
00011576 =00000000                M spss4	=	op4
00011576                            	spTotalLv	$2E, $1B, $0A, $05
00011576 =0000002E                M sptl1	=	op1
00011576 =0000001B                M sptl2	=	op2
00011576 =0000000A                M sptl3	=	op3
00011576 =00000005                M sptl4	=	op4
00011576 32                       M 	dc.b	(spfe<<3)+spal
00011577 =00000080                M sptlmask4	set	$80
00011577 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011577 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011577 =00000000                M sptlmask1	set	((spal=7)<<7)
00011577 2A61 6523                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001157B 9410 5419                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001157F 850B 0E05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011583 0604 0303                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011587 1214 2427                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001158B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001158F 2E0A 1B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011593 4E41 54                  M 	dc.b	'NAT'
00011596                            
00011596                            	; Patch $3C
00011596                            	; $38
00011596                            	; $71, $31, $71, $41,	$5F, $1F, $1F, $1F
00011596                            	; $07, $06, $09, $1F,	$00, $00, $00, $00
00011596                            	; $98, $9A, $09, $0C,	$1C, $1B, $1A, $04
00011596                            	spAlgorithm	$00
00011596 =0000003D                M spatnum	=	spatnum+1
00011596 =00000000                M spal	=	val
00011596                            	spFeedback	$07
00011596 =00000007                M spfe	=	val
00011596                            	spDetune	$07, $07, $03, $04
00011596 =00000007                M spde1	=	op1
00011596 =00000007                M spde2	=	op2
00011596 =00000003                M spde3	=	op3
00011596 =00000004                M spde4	=	op4
00011596                            	spMultiple	$01, $01, $01, $01
00011596 =00000001                M spmu1	=	op1
00011596 =00000001                M spmu2	=	op2
00011596 =00000001                M spmu3	=	op3
00011596 =00000001                M spmu4	=	op4
00011596                            	spRateScale	$01, $00, $00, $00
00011596 =00000001                M sprs1	=	op1
00011596 =00000000                M sprs2	=	op2
00011596 =00000000                M sprs3	=	op3
00011596 =00000000                M sprs4	=	op4
00011596                            	spAttackRt	$1F, $1F, $1F, $1F
00011596 =0000001F                M spar1	=	op1
00011596 =0000001F                M spar2	=	op2
00011596 =0000001F                M spar3	=	op3
00011596 =0000001F                M spar4	=	op4
00011596                            	spAmpMod	$00, $00, $00, $00
00011596 =00000000                M spam1	=	op1
00011596 =00000000                M spam2	=	op2
00011596 =00000000                M spam3	=	op3
00011596 =00000000                M spam4	=	op4
00011596                            	spSustainRt	$07, $09, $06, $1F
00011596 =00000007                M spsr1	=	op1
00011596 =00000009                M spsr2	=	op2
00011596 =00000006                M spsr3	=	op3
00011596 =0000001F                M spsr4	=	op4
00011596                            	spDecayRt	$00, $00, $00, $00
00011596 =00000000                M spdr1	=	op1
00011596 =00000000                M spdr2	=	op2
00011596 =00000000                M spdr3	=	op3
00011596 =00000000                M spdr4	=	op4
00011596                            	spSustainLv	$09, $00, $09, $00
00011596 =00000009                M spsl1	=	op1
00011596 =00000000                M spsl2	=	op2
00011596 =00000009                M spsl3	=	op3
00011596 =00000000                M spsl4	=	op4
00011596                            	spReleaseRt	$08, $09, $0A, $0C
00011596 =00000008                M sprr1	=	op1
00011596 =00000009                M sprr2	=	op2
00011596 =0000000A                M sprr3	=	op3
00011596 =0000000C                M sprr4	=	op4
00011596                            	spSSGEG		$00, $00, $00, $00
00011596 =00000000                M spss1	=	op1
00011596 =00000000                M spss2	=	op2
00011596 =00000000                M spss3	=	op3
00011596 =00000000                M spss4	=	op4
00011596                            	spTotalLv	$1C, $1A, $1B, $04
00011596 =0000001C                M sptl1	=	op1
00011596 =0000001A                M sptl2	=	op2
00011596 =0000001B                M sptl3	=	op3
00011596 =00000004                M sptl4	=	op4
00011596 38                       M 	dc.b	(spfe<<3)+spal
00011597 =00000080                M sptlmask4	set	$80
00011597 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011597 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011597 =00000000                M sptlmask1	set	((spal=7)<<7)
00011597 7131 7141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001159B 5F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001159F 0706 091F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115A3 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115A7 989A 090C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115AF 1C1B 1A84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115B3 4E41 54                  M 	dc.b	'NAT'
000115B6                            
000115B6                            	; Patch $3D
000115B6                            	; $02
000115B6                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
000115B6                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
000115B6                            	; $01, $11, $31, $88,	$1C, $2D, $27, $05
000115B6                            	spAlgorithm	$02
000115B6 =0000003E                M spatnum	=	spatnum+1
000115B6 =00000002                M spal	=	val
000115B6                            	spFeedback	$00
000115B6 =00000000                M spfe	=	val
000115B6                            	spDetune	$06, $00, $07, $03
000115B6 =00000006                M spde1	=	op1
000115B6 =00000000                M spde2	=	op2
000115B6 =00000007                M spde3	=	op3
000115B6 =00000003                M spde4	=	op4
000115B6                            	spMultiple	$01, $04, $0C, $01
000115B6 =00000001                M spmu1	=	op1
000115B6 =00000004                M spmu2	=	op2
000115B6 =0000000C                M spmu3	=	op3
000115B6 =00000001                M spmu4	=	op4
000115B6                            	spRateScale	$00, $02, $03, $01
000115B6 =00000000                M sprs1	=	op1
000115B6 =00000002                M sprs2	=	op2
000115B6 =00000003                M sprs3	=	op3
000115B6 =00000001                M sprs4	=	op4
000115B6                            	spAttackRt	$14, $0F, $10, $14
000115B6 =00000014                M spar1	=	op1
000115B6 =0000000F                M spar2	=	op2
000115B6 =00000010                M spar3	=	op3
000115B6 =00000014                M spar4	=	op4
000115B6                            	spAmpMod	$00, $00, $00, $00
000115B6 =00000000                M spam1	=	op1
000115B6 =00000000                M spam2	=	op2
000115B6 =00000000                M spam3	=	op3
000115B6 =00000000                M spam4	=	op4
000115B6                            	spSustainRt	$01, $05, $05, $08
000115B6 =00000001                M spsr1	=	op1
000115B6 =00000005                M spsr2	=	op2
000115B6 =00000005                M spsr3	=	op3
000115B6 =00000008                M spsr4	=	op4
000115B6                            	spDecayRt	$02, $05, $02, $1F
000115B6 =00000002                M spdr1	=	op1
000115B6 =00000005                M spdr2	=	op2
000115B6 =00000002                M spdr3	=	op3
000115B6 =0000001F                M spdr4	=	op4
000115B6                            	spSustainLv	$00, $03, $01, $08
000115B6 =00000000                M spsl1	=	op1
000115B6 =00000003                M spsl2	=	op2
000115B6 =00000001                M spsl3	=	op3
000115B6 =00000008                M spsl4	=	op4
000115B6                            	spReleaseRt	$01, $01, $01, $08
000115B6 =00000001                M sprr1	=	op1
000115B6 =00000001                M sprr2	=	op2
000115B6 =00000001                M sprr3	=	op3
000115B6 =00000008                M sprr4	=	op4
000115B6                            	spSSGEG		$00, $00, $00, $00
000115B6 =00000000                M spss1	=	op1
000115B6 =00000000                M spss2	=	op2
000115B6 =00000000                M spss3	=	op3
000115B6 =00000000                M spss4	=	op4
000115B6                            	spTotalLv	$1C, $27, $2D, $05
000115B6 =0000001C                M sptl1	=	op1
000115B6 =00000027                M sptl2	=	op2
000115B6 =0000002D                M sptl3	=	op3
000115B6 =00000005                M sptl4	=	op4
000115B6 02                       M 	dc.b	(spfe<<3)+spal
000115B7 =00000080                M sptlmask4	set	$80
000115B7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000115B7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000115B7 =00000000                M sptlmask1	set	((spal=7)<<7)
000115B7 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115BB 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115BF 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115C3 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115C7 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115CF 1C2D 2785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115D3 4E41 54                  M 	dc.b	'NAT'
000115D6                            
000115D6                            	; Patch $3E
000115D6                            	; $13
000115D6                            	; $01, $04, $00, $01,	$1C, $9D, $DE, $DF
000115D6                            	; $11, $0D, $02, $01,	$1F, $18, $0B, $01
000115D6                            	; $6F, $63, $FF, $3F,	$1E, $1C, $19, $05
000115D6                            	spAlgorithm	$03
000115D6 =0000003F                M spatnum	=	spatnum+1
000115D6 =00000003                M spal	=	val
000115D6                            	spFeedback	$02
000115D6 =00000002                M spfe	=	val
000115D6                            	spDetune	$00, $00, $00, $00
000115D6 =00000000                M spde1	=	op1
000115D6 =00000000                M spde2	=	op2
000115D6 =00000000                M spde3	=	op3
000115D6 =00000000                M spde4	=	op4
000115D6                            	spMultiple	$01, $00, $04, $01
000115D6 =00000001                M spmu1	=	op1
000115D6 =00000000                M spmu2	=	op2
000115D6 =00000004                M spmu3	=	op3
000115D6 =00000001                M spmu4	=	op4
000115D6                            	spRateScale	$00, $03, $02, $03
000115D6 =00000000                M sprs1	=	op1
000115D6 =00000003                M sprs2	=	op2
000115D6 =00000002                M sprs3	=	op3
000115D6 =00000003                M sprs4	=	op4
000115D6                            	spAttackRt	$1C, $1E, $1D, $1F
000115D6 =0000001C                M spar1	=	op1
000115D6 =0000001E                M spar2	=	op2
000115D6 =0000001D                M spar3	=	op3
000115D6 =0000001F                M spar4	=	op4
000115D6                            	spAmpMod	$00, $00, $00, $00
000115D6 =00000000                M spam1	=	op1
000115D6 =00000000                M spam2	=	op2
000115D6 =00000000                M spam3	=	op3
000115D6 =00000000                M spam4	=	op4
000115D6                            	spSustainRt	$11, $02, $0D, $01
000115D6 =00000011                M spsr1	=	op1
000115D6 =00000002                M spsr2	=	op2
000115D6 =0000000D                M spsr3	=	op3
000115D6 =00000001                M spsr4	=	op4
000115D6                            	spDecayRt	$1F, $0B, $18, $01
000115D6 =0000001F                M spdr1	=	op1
000115D6 =0000000B                M spdr2	=	op2
000115D6 =00000018                M spdr3	=	op3
000115D6 =00000001                M spdr4	=	op4
000115D6                            	spSustainLv	$06, $0F, $06, $03
000115D6 =00000006                M spsl1	=	op1
000115D6 =0000000F                M spsl2	=	op2
000115D6 =00000006                M spsl3	=	op3
000115D6 =00000003                M spsl4	=	op4
000115D6                            	spReleaseRt	$0F, $0F, $03, $0F
000115D6 =0000000F                M sprr1	=	op1
000115D6 =0000000F                M sprr2	=	op2
000115D6 =00000003                M sprr3	=	op3
000115D6 =0000000F                M sprr4	=	op4
000115D6                            	spSSGEG		$00, $00, $00, $00
000115D6 =00000000                M spss1	=	op1
000115D6 =00000000                M spss2	=	op2
000115D6 =00000000                M spss3	=	op3
000115D6 =00000000                M spss4	=	op4
000115D6                            	spTotalLv	$1E, $19, $1C, $05
000115D6 =0000001E                M sptl1	=	op1
000115D6 =00000019                M sptl2	=	op2
000115D6 =0000001C                M sptl3	=	op3
000115D6 =00000005                M sptl4	=	op4
000115D6 13                       M 	dc.b	(spfe<<3)+spal
000115D7 =00000080                M sptlmask4	set	$80
000115D7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000115D7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000115D7 =00000000                M sptlmask1	set	((spal=7)<<7)
000115D7 0104 0001                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115DB 1C9D DEDF                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115DF 110D 0201                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115E3 1F18 0B01                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115E7 6F63 FF3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115EF 1E1C 1985                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115F3 4E41 54                  M 	dc.b	'NAT'
000115F6                            
000115F6                            	; Patch $3F
000115F6                            	; $17
000115F6                            	; $32, $72, $32, $12,	$C8, $88, $8C, $C8
000115F6                            	; $00, $13, $8C, $8D,	$01, $01, $01, $00
000115F6                            	; $08, $58, $A8, $78,	$04, $08, $09, $07
000115F6                            	spAlgorithm	$07
000115F6 =00000040                M spatnum	=	spatnum+1
000115F6 =00000007                M spal	=	val
000115F6                            	spFeedback	$02
000115F6 =00000002                M spfe	=	val
000115F6                            	spDetune	$03, $03, $07, $01
000115F6 =00000003                M spde1	=	op1
000115F6 =00000003                M spde2	=	op2
000115F6 =00000007                M spde3	=	op3
000115F6 =00000001                M spde4	=	op4
000115F6                            	spMultiple	$02, $02, $02, $02
000115F6 =00000002                M spmu1	=	op1
000115F6 =00000002                M spmu2	=	op2
000115F6 =00000002                M spmu3	=	op3
000115F6 =00000002                M spmu4	=	op4
000115F6                            	spRateScale	$03, $02, $02, $03
000115F6 =00000003                M sprs1	=	op1
000115F6 =00000002                M sprs2	=	op2
000115F6 =00000002                M sprs3	=	op3
000115F6 =00000003                M sprs4	=	op4
000115F6                            	spAttackRt	$08, $0C, $08, $08
000115F6 =00000008                M spar1	=	op1
000115F6 =0000000C                M spar2	=	op2
000115F6 =00000008                M spar3	=	op3
000115F6 =00000008                M spar4	=	op4
000115F6                            	spAmpMod	$00, $01, $00, $01
000115F6 =00000000                M spam1	=	op1
000115F6 =00000001                M spam2	=	op2
000115F6 =00000000                M spam3	=	op3
000115F6 =00000001                M spam4	=	op4
000115F6                            	spSustainRt	$00, $0C, $13, $0D
000115F6 =00000000                M spsr1	=	op1
000115F6 =0000000C                M spsr2	=	op2
000115F6 =00000013                M spsr3	=	op3
000115F6 =0000000D                M spsr4	=	op4
000115F6                            	spDecayRt	$01, $01, $01, $00
000115F6 =00000001                M spdr1	=	op1
000115F6 =00000001                M spdr2	=	op2
000115F6 =00000001                M spdr3	=	op3
000115F6 =00000000                M spdr4	=	op4
000115F6                            	spSustainLv	$00, $0A, $05, $07
000115F6 =00000000                M spsl1	=	op1
000115F6 =0000000A                M spsl2	=	op2
000115F6 =00000005                M spsl3	=	op3
000115F6 =00000007                M spsl4	=	op4
000115F6                            	spReleaseRt	$08, $08, $08, $08
000115F6 =00000008                M sprr1	=	op1
000115F6 =00000008                M sprr2	=	op2
000115F6 =00000008                M sprr3	=	op3
000115F6 =00000008                M sprr4	=	op4
000115F6                            	spSSGEG		$00, $00, $00, $00
000115F6 =00000000                M spss1	=	op1
000115F6 =00000000                M spss2	=	op2
000115F6 =00000000                M spss3	=	op3
000115F6 =00000000                M spss4	=	op4
000115F6                            	spTotalLv	$04, $09, $08, $07
000115F6 =00000004                M sptl1	=	op1
000115F6 =00000009                M sptl2	=	op2
000115F6 =00000008                M sptl3	=	op3
000115F6 =00000007                M sptl4	=	op4
000115F6 17                       M 	dc.b	(spfe<<3)+spal
000115F7 =00000080                M sptlmask4	set	$80
000115F7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000115F7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000115F7 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
000115F7 3272 3212                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115FB C888 8CC8                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115FF 0013 8C8D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011603 0101 0100                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011607 0858 A878                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001160B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001160F 8488 8987                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011613 4E41 54                  M 	dc.b	'NAT'
00011616                            
00011616                            	; Patch $40
00011616                            	; $3D
00011616                            	; $01, $01, $01, $01,	$10, $50, $50, $50
00011616                            	; $07, $08, $08, $08,	$01, $00, $00, $00
00011616                            	; $20, $1A, $1A, $1A,	$19, $05, $05, $05
00011616                            	spAlgorithm	$05
00011616 =00000041                M spatnum	=	spatnum+1
00011616 =00000005                M spal	=	val
00011616                            	spFeedback	$07
00011616 =00000007                M spfe	=	val
00011616                            	spDetune	$00, $00, $00, $00
00011616 =00000000                M spde1	=	op1
00011616 =00000000                M spde2	=	op2
00011616 =00000000                M spde3	=	op3
00011616 =00000000                M spde4	=	op4
00011616                            	spMultiple	$01, $01, $01, $01
00011616 =00000001                M spmu1	=	op1
00011616 =00000001                M spmu2	=	op2
00011616 =00000001                M spmu3	=	op3
00011616 =00000001                M spmu4	=	op4
00011616                            	spRateScale	$00, $01, $01, $01
00011616 =00000000                M sprs1	=	op1
00011616 =00000001                M sprs2	=	op2
00011616 =00000001                M sprs3	=	op3
00011616 =00000001                M sprs4	=	op4
00011616                            	spAttackRt	$10, $10, $10, $10
00011616 =00000010                M spar1	=	op1
00011616 =00000010                M spar2	=	op2
00011616 =00000010                M spar3	=	op3
00011616 =00000010                M spar4	=	op4
00011616                            	spAmpMod	$00, $00, $00, $00
00011616 =00000000                M spam1	=	op1
00011616 =00000000                M spam2	=	op2
00011616 =00000000                M spam3	=	op3
00011616 =00000000                M spam4	=	op4
00011616                            	spSustainRt	$07, $08, $08, $08
00011616 =00000007                M spsr1	=	op1
00011616 =00000008                M spsr2	=	op2
00011616 =00000008                M spsr3	=	op3
00011616 =00000008                M spsr4	=	op4
00011616                            	spDecayRt	$01, $00, $00, $00
00011616 =00000001                M spdr1	=	op1
00011616 =00000000                M spdr2	=	op2
00011616 =00000000                M spdr3	=	op3
00011616 =00000000                M spdr4	=	op4
00011616                            	spSustainLv	$02, $01, $01, $01
00011616 =00000002                M spsl1	=	op1
00011616 =00000001                M spsl2	=	op2
00011616 =00000001                M spsl3	=	op3
00011616 =00000001                M spsl4	=	op4
00011616                            	spReleaseRt	$00, $0A, $0A, $0A
00011616 =00000000                M sprr1	=	op1
00011616 =0000000A                M sprr2	=	op2
00011616 =0000000A                M sprr3	=	op3
00011616 =0000000A                M sprr4	=	op4
00011616                            	spSSGEG		$00, $00, $00, $00
00011616 =00000000                M spss1	=	op1
00011616 =00000000                M spss2	=	op2
00011616 =00000000                M spss3	=	op3
00011616 =00000000                M spss4	=	op4
00011616                            	spTotalLv	$19, $05, $05, $05
00011616 =00000019                M sptl1	=	op1
00011616 =00000005                M sptl2	=	op2
00011616 =00000005                M sptl3	=	op3
00011616 =00000005                M sptl4	=	op4
00011616 3D                       M 	dc.b	(spfe<<3)+spal
00011617 =00000080                M sptlmask4	set	$80
00011617 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011617 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011617 =00000000                M sptlmask1	set	((spal=7)<<7)
00011617 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001161B 1050 5050                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001161F 0708 0808                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011623 0100 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011627 201A 1A1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001162B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001162F 1985 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011633 4E41 54                  M 	dc.b	'NAT'
00011636                            
00011636                            	; Patch $41
00011636                            	; $3A
00011636                            	; $03, $08, $03, $01,	$8E, $8E, $8D, $53
00011636                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
00011636                            	; $1F, $FF, $1F, $0F,	$17, $28, $20, $05
00011636                            	spAlgorithm	$02
00011636 =00000042                M spatnum	=	spatnum+1
00011636 =00000002                M spal	=	val
00011636                            	spFeedback	$07
00011636 =00000007                M spfe	=	val
00011636                            	spDetune	$00, $00, $00, $00
00011636 =00000000                M spde1	=	op1
00011636 =00000000                M spde2	=	op2
00011636 =00000000                M spde3	=	op3
00011636 =00000000                M spde4	=	op4
00011636                            	spMultiple	$03, $03, $08, $01
00011636 =00000003                M spmu1	=	op1
00011636 =00000003                M spmu2	=	op2
00011636 =00000008                M spmu3	=	op3
00011636 =00000001                M spmu4	=	op4
00011636                            	spRateScale	$02, $02, $02, $01
00011636 =00000002                M sprs1	=	op1
00011636 =00000002                M sprs2	=	op2
00011636 =00000002                M sprs3	=	op3
00011636 =00000001                M sprs4	=	op4
00011636                            	spAttackRt	$0E, $0D, $0E, $13
00011636 =0000000E                M spar1	=	op1
00011636 =0000000D                M spar2	=	op2
00011636 =0000000E                M spar3	=	op3
00011636 =00000013                M spar4	=	op4
00011636                            	spAmpMod	$00, $00, $00, $00
00011636 =00000000                M spam1	=	op1
00011636 =00000000                M spam2	=	op2
00011636 =00000000                M spam3	=	op3
00011636 =00000000                M spam4	=	op4
00011636                            	spSustainRt	$0E, $0E, $0E, $03
00011636 =0000000E                M spsr1	=	op1
00011636 =0000000E                M spsr2	=	op2
00011636 =0000000E                M spsr3	=	op3
00011636 =00000003                M spsr4	=	op4
00011636                            	spDecayRt	$00, $00, $00, $00
00011636 =00000000                M spdr1	=	op1
00011636 =00000000                M spdr2	=	op2
00011636 =00000000                M spdr3	=	op3
00011636 =00000000                M spdr4	=	op4
00011636                            	spSustainLv	$01, $01, $0F, $00
00011636 =00000001                M spsl1	=	op1
00011636 =00000001                M spsl2	=	op2
00011636 =0000000F                M spsl3	=	op3
00011636 =00000000                M spsl4	=	op4
00011636                            	spReleaseRt	$0F, $0F, $0F, $0F
00011636 =0000000F                M sprr1	=	op1
00011636 =0000000F                M sprr2	=	op2
00011636 =0000000F                M sprr3	=	op3
00011636 =0000000F                M sprr4	=	op4
00011636                            	spSSGEG		$00, $00, $00, $00
00011636 =00000000                M spss1	=	op1
00011636 =00000000                M spss2	=	op2
00011636 =00000000                M spss3	=	op3
00011636 =00000000                M spss4	=	op4
00011636                            	spTotalLv	$17, $20, $28, $05
00011636 =00000017                M sptl1	=	op1
00011636 =00000020                M sptl2	=	op2
00011636 =00000028                M sptl3	=	op3
00011636 =00000005                M sptl4	=	op4
00011636 3A                       M 	dc.b	(spfe<<3)+spal
00011637 =00000080                M sptlmask4	set	$80
00011637 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011637 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011637 =00000000                M sptlmask1	set	((spal=7)<<7)
00011637 0308 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001163B 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001163F 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011643 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011647 1FFF 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001164B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001164F 1728 2085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011653 4E41 54                  M 	dc.b	'NAT'
00011656                            
00011656                            	; Patch $42
00011656                            	; $07
00011656                            	; $06, $7C, $75, $0A,	$1F, $1F, $1F, $1F
00011656                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00011656                            	; $0F, $0F, $0F, $0F,	$07, $07, $07, $07
00011656                            	spAlgorithm	$07
00011656 =00000043                M spatnum	=	spatnum+1
00011656 =00000007                M spal	=	val
00011656                            	spFeedback	$00
00011656 =00000000                M spfe	=	val
00011656                            	spDetune	$00, $07, $07, $00
00011656 =00000000                M spde1	=	op1
00011656 =00000007                M spde2	=	op2
00011656 =00000007                M spde3	=	op3
00011656 =00000000                M spde4	=	op4
00011656                            	spMultiple	$06, $05, $0C, $0A
00011656 =00000006                M spmu1	=	op1
00011656 =00000005                M spmu2	=	op2
00011656 =0000000C                M spmu3	=	op3
00011656 =0000000A                M spmu4	=	op4
00011656                            	spRateScale	$00, $00, $00, $00
00011656 =00000000                M sprs1	=	op1
00011656 =00000000                M sprs2	=	op2
00011656 =00000000                M sprs3	=	op3
00011656 =00000000                M sprs4	=	op4
00011656                            	spAttackRt	$1F, $1F, $1F, $1F
00011656 =0000001F                M spar1	=	op1
00011656 =0000001F                M spar2	=	op2
00011656 =0000001F                M spar3	=	op3
00011656 =0000001F                M spar4	=	op4
00011656                            	spAmpMod	$00, $00, $00, $00
00011656 =00000000                M spam1	=	op1
00011656 =00000000                M spam2	=	op2
00011656 =00000000                M spam3	=	op3
00011656 =00000000                M spam4	=	op4
00011656                            	spSustainRt	$00, $00, $00, $00
00011656 =00000000                M spsr1	=	op1
00011656 =00000000                M spsr2	=	op2
00011656 =00000000                M spsr3	=	op3
00011656 =00000000                M spsr4	=	op4
00011656                            	spDecayRt	$00, $00, $00, $00
00011656 =00000000                M spdr1	=	op1
00011656 =00000000                M spdr2	=	op2
00011656 =00000000                M spdr3	=	op3
00011656 =00000000                M spdr4	=	op4
00011656                            	spSustainLv	$00, $00, $00, $00
00011656 =00000000                M spsl1	=	op1
00011656 =00000000                M spsl2	=	op2
00011656 =00000000                M spsl3	=	op3
00011656 =00000000                M spsl4	=	op4
00011656                            	spReleaseRt	$0F, $0F, $0F, $0F
00011656 =0000000F                M sprr1	=	op1
00011656 =0000000F                M sprr2	=	op2
00011656 =0000000F                M sprr3	=	op3
00011656 =0000000F                M sprr4	=	op4
00011656                            	spSSGEG		$00, $00, $00, $00
00011656 =00000000                M spss1	=	op1
00011656 =00000000                M spss2	=	op2
00011656 =00000000                M spss3	=	op3
00011656 =00000000                M spss4	=	op4
00011656                            	spTotalLv	$07, $07, $07, $07
00011656 =00000007                M sptl1	=	op1
00011656 =00000007                M sptl2	=	op2
00011656 =00000007                M sptl3	=	op3
00011656 =00000007                M sptl4	=	op4
00011656 07                       M 	dc.b	(spfe<<3)+spal
00011657 =00000080                M sptlmask4	set	$80
00011657 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011657 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011657 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
00011657 067C 750A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001165B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001165F 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011663 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011667 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001166B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001166F 8787 8787                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011673 4E41 54                  M 	dc.b	'NAT'
00011676                            
00011676                            	; Patch $43
00011676                            	; $3A
00011676                            	; $01, $40, $01, $31,	$1F, $1F, $1F, $1F
00011676                            	; $0B, $04, $04, $04,	$02, $04, $03, $02
00011676                            	; $5F, $1F, $5F, $2F,	$18, $05, $11, $05
00011676                            	spAlgorithm	$02
00011676 =00000044                M spatnum	=	spatnum+1
00011676 =00000002                M spal	=	val
00011676                            	spFeedback	$07
00011676 =00000007                M spfe	=	val
00011676                            	spDetune	$00, $00, $04, $03
00011676 =00000000                M spde1	=	op1
00011676 =00000000                M spde2	=	op2
00011676 =00000004                M spde3	=	op3
00011676 =00000003                M spde4	=	op4
00011676                            	spMultiple	$01, $01, $00, $01
00011676 =00000001                M spmu1	=	op1
00011676 =00000001                M spmu2	=	op2
00011676 =00000000                M spmu3	=	op3
00011676 =00000001                M spmu4	=	op4
00011676                            	spRateScale	$00, $00, $00, $00
00011676 =00000000                M sprs1	=	op1
00011676 =00000000                M sprs2	=	op2
00011676 =00000000                M sprs3	=	op3
00011676 =00000000                M sprs4	=	op4
00011676                            	spAttackRt	$1F, $1F, $1F, $1F
00011676 =0000001F                M spar1	=	op1
00011676 =0000001F                M spar2	=	op2
00011676 =0000001F                M spar3	=	op3
00011676 =0000001F                M spar4	=	op4
00011676                            	spAmpMod	$00, $00, $00, $00
00011676 =00000000                M spam1	=	op1
00011676 =00000000                M spam2	=	op2
00011676 =00000000                M spam3	=	op3
00011676 =00000000                M spam4	=	op4
00011676                            	spSustainRt	$0B, $04, $04, $04
00011676 =0000000B                M spsr1	=	op1
00011676 =00000004                M spsr2	=	op2
00011676 =00000004                M spsr3	=	op3
00011676 =00000004                M spsr4	=	op4
00011676                            	spDecayRt	$02, $03, $04, $02
00011676 =00000002                M spdr1	=	op1
00011676 =00000003                M spdr2	=	op2
00011676 =00000004                M spdr3	=	op3
00011676 =00000002                M spdr4	=	op4
00011676                            	spSustainLv	$05, $05, $01, $02
00011676 =00000005                M spsl1	=	op1
00011676 =00000005                M spsl2	=	op2
00011676 =00000001                M spsl3	=	op3
00011676 =00000002                M spsl4	=	op4
00011676                            	spReleaseRt	$0F, $0F, $0F, $0F
00011676 =0000000F                M sprr1	=	op1
00011676 =0000000F                M sprr2	=	op2
00011676 =0000000F                M sprr3	=	op3
00011676 =0000000F                M sprr4	=	op4
00011676                            	spSSGEG		$00, $00, $00, $00
00011676 =00000000                M spss1	=	op1
00011676 =00000000                M spss2	=	op2
00011676 =00000000                M spss3	=	op3
00011676 =00000000                M spss4	=	op4
00011676                            	spTotalLv	$18, $11, $05, $05
00011676 =00000018                M sptl1	=	op1
00011676 =00000011                M sptl2	=	op2
00011676 =00000005                M sptl3	=	op3
00011676 =00000005                M sptl4	=	op4
00011676 3A                       M 	dc.b	(spfe<<3)+spal
00011677 =00000080                M sptlmask4	set	$80
00011677 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011677 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011677 =00000000                M sptlmask1	set	((spal=7)<<7)
00011677 0140 0131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001167B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001167F 0B04 0404                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011683 0204 0302                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011687 5F1F 5F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001168B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001168F 1805 1185                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011693 4E41 54                  M 	dc.b	'NAT'
00011696                            
00011696                            	; Patch $44
00011696                            	; $3C
00011696                            	; $01, $01, $0E, $04,	$8D, $52, $9F, $1F
00011696                            	; $09, $00, $00, $0D,	$00, $00, $00, $00
00011696                            	; $23, $08, $02, $6F,	$15, $02, $10, $05
00011696                            	spAlgorithm	$04
00011696 =00000045                M spatnum	=	spatnum+1
00011696 =00000004                M spal	=	val
00011696                            	spFeedback	$07
00011696 =00000007                M spfe	=	val
00011696                            	spDetune	$00, $00, $00, $00
00011696 =00000000                M spde1	=	op1
00011696 =00000000                M spde2	=	op2
00011696 =00000000                M spde3	=	op3
00011696 =00000000                M spde4	=	op4
00011696                            	spMultiple	$01, $0E, $01, $04
00011696 =00000001                M spmu1	=	op1
00011696 =0000000E                M spmu2	=	op2
00011696 =00000001                M spmu3	=	op3
00011696 =00000004                M spmu4	=	op4
00011696                            	spRateScale	$02, $02, $01, $00
00011696 =00000002                M sprs1	=	op1
00011696 =00000002                M sprs2	=	op2
00011696 =00000001                M sprs3	=	op3
00011696 =00000000                M sprs4	=	op4
00011696                            	spAttackRt	$0D, $1F, $12, $1F
00011696 =0000000D                M spar1	=	op1
00011696 =0000001F                M spar2	=	op2
00011696 =00000012                M spar3	=	op3
00011696 =0000001F                M spar4	=	op4
00011696                            	spAmpMod	$00, $00, $00, $00
00011696 =00000000                M spam1	=	op1
00011696 =00000000                M spam2	=	op2
00011696 =00000000                M spam3	=	op3
00011696 =00000000                M spam4	=	op4
00011696                            	spSustainRt	$09, $00, $00, $0D
00011696 =00000009                M spsr1	=	op1
00011696 =00000000                M spsr2	=	op2
00011696 =00000000                M spsr3	=	op3
00011696 =0000000D                M spsr4	=	op4
00011696                            	spDecayRt	$00, $00, $00, $00
00011696 =00000000                M spdr1	=	op1
00011696 =00000000                M spdr2	=	op2
00011696 =00000000                M spdr3	=	op3
00011696 =00000000                M spdr4	=	op4
00011696                            	spSustainLv	$02, $00, $00, $06
00011696 =00000002                M spsl1	=	op1
00011696 =00000000                M spsl2	=	op2
00011696 =00000000                M spsl3	=	op3
00011696 =00000006                M spsl4	=	op4
00011696                            	spReleaseRt	$03, $02, $08, $0F
00011696 =00000003                M sprr1	=	op1
00011696 =00000002                M sprr2	=	op2
00011696 =00000008                M sprr3	=	op3
00011696 =0000000F                M sprr4	=	op4
00011696                            	spSSGEG		$00, $00, $00, $00
00011696 =00000000                M spss1	=	op1
00011696 =00000000                M spss2	=	op2
00011696 =00000000                M spss3	=	op3
00011696 =00000000                M spss4	=	op4
00011696                            	spTotalLv	$15, $10, $02, $05
00011696 =00000015                M sptl1	=	op1
00011696 =00000010                M sptl2	=	op2
00011696 =00000002                M sptl3	=	op3
00011696 =00000005                M sptl4	=	op4
00011696 3C                       M 	dc.b	(spfe<<3)+spal
00011697 =00000080                M sptlmask4	set	$80
00011697 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011697 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011697 =00000000                M sptlmask1	set	((spal=7)<<7)
00011697 0101 0E04                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001169B 8D52 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001169F 0900 000D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116A3 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116A7 2308 026F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116AF 1582 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000116B3 4E41 54                  M 	dc.b	'NAT'
000116B6                            
000116B6                            	; Patch $45
000116B6                            	; $04
000116B6                            	; $37, $72, $77, $49,	$1F, $1F, $1F, $1F
000116B6                            	; $07, $0A, $07, $0D,	$00, $0B, $00, $0B
000116B6                            	; $1F, $0F, $1F, $0F,	$23, $00, $23, $00
000116B6                            	spAlgorithm	$04
000116B6 =00000046                M spatnum	=	spatnum+1
000116B6 =00000004                M spal	=	val
000116B6                            	spFeedback	$00
000116B6 =00000000                M spfe	=	val
000116B6                            	spDetune	$03, $07, $07, $04
000116B6 =00000003                M spde1	=	op1
000116B6 =00000007                M spde2	=	op2
000116B6 =00000007                M spde3	=	op3
000116B6 =00000004                M spde4	=	op4
000116B6                            	spMultiple	$07, $07, $02, $09
000116B6 =00000007                M spmu1	=	op1
000116B6 =00000007                M spmu2	=	op2
000116B6 =00000002                M spmu3	=	op3
000116B6 =00000009                M spmu4	=	op4
000116B6                            	spRateScale	$00, $00, $00, $00
000116B6 =00000000                M sprs1	=	op1
000116B6 =00000000                M sprs2	=	op2
000116B6 =00000000                M sprs3	=	op3
000116B6 =00000000                M sprs4	=	op4
000116B6                            	spAttackRt	$1F, $1F, $1F, $1F
000116B6 =0000001F                M spar1	=	op1
000116B6 =0000001F                M spar2	=	op2
000116B6 =0000001F                M spar3	=	op3
000116B6 =0000001F                M spar4	=	op4
000116B6                            	spAmpMod	$00, $00, $00, $00
000116B6 =00000000                M spam1	=	op1
000116B6 =00000000                M spam2	=	op2
000116B6 =00000000                M spam3	=	op3
000116B6 =00000000                M spam4	=	op4
000116B6                            	spSustainRt	$07, $07, $0A, $0D
000116B6 =00000007                M spsr1	=	op1
000116B6 =00000007                M spsr2	=	op2
000116B6 =0000000A                M spsr3	=	op3
000116B6 =0000000D                M spsr4	=	op4
000116B6                            	spDecayRt	$00, $00, $0B, $0B
000116B6 =00000000                M spdr1	=	op1
000116B6 =00000000                M spdr2	=	op2
000116B6 =0000000B                M spdr3	=	op3
000116B6 =0000000B                M spdr4	=	op4
000116B6                            	spSustainLv	$01, $01, $00, $00
000116B6 =00000001                M spsl1	=	op1
000116B6 =00000001                M spsl2	=	op2
000116B6 =00000000                M spsl3	=	op3
000116B6 =00000000                M spsl4	=	op4
000116B6                            	spReleaseRt	$0F, $0F, $0F, $0F
000116B6 =0000000F                M sprr1	=	op1
000116B6 =0000000F                M sprr2	=	op2
000116B6 =0000000F                M sprr3	=	op3
000116B6 =0000000F                M sprr4	=	op4
000116B6                            	spSSGEG		$00, $00, $00, $00
000116B6 =00000000                M spss1	=	op1
000116B6 =00000000                M spss2	=	op2
000116B6 =00000000                M spss3	=	op3
000116B6 =00000000                M spss4	=	op4
000116B6                            	spTotalLv	$23, $23, $00, $00
000116B6 =00000023                M sptl1	=	op1
000116B6 =00000023                M sptl2	=	op2
000116B6 =00000000                M sptl3	=	op3
000116B6 =00000000                M sptl4	=	op4
000116B6 04                       M 	dc.b	(spfe<<3)+spal
000116B7 =00000080                M sptlmask4	set	$80
000116B7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000116B7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000116B7 =00000000                M sptlmask1	set	((spal=7)<<7)
000116B7 3772 7749                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116BB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116BF 070A 070D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116C3 000B 000B                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116C7 1F0F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116CF 2380 2380                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000116D3 4E41 54                  M 	dc.b	'NAT'
000116D6                            
000116D6                            	; Patch $46
000116D6                            	; $3C
000116D6                            	; $31, $73, $71, $31,	$10, $8C, $0A, $13
000116D6                            	; $00, $00, $00, $00,	$00, $0C, $00, $03
000116D6                            	; $0F, $0F, $0F, $0F,	$20, $00, $20, $00
000116D6                            	spAlgorithm	$04
000116D6 =00000047                M spatnum	=	spatnum+1
000116D6 =00000004                M spal	=	val
000116D6                            	spFeedback	$07
000116D6 =00000007                M spfe	=	val
000116D6                            	spDetune	$03, $07, $07, $03
000116D6 =00000003                M spde1	=	op1
000116D6 =00000007                M spde2	=	op2
000116D6 =00000007                M spde3	=	op3
000116D6 =00000003                M spde4	=	op4
000116D6                            	spMultiple	$01, $01, $03, $01
000116D6 =00000001                M spmu1	=	op1
000116D6 =00000001                M spmu2	=	op2
000116D6 =00000003                M spmu3	=	op3
000116D6 =00000001                M spmu4	=	op4
000116D6                            	spRateScale	$00, $00, $02, $00
000116D6 =00000000                M sprs1	=	op1
000116D6 =00000000                M sprs2	=	op2
000116D6 =00000002                M sprs3	=	op3
000116D6 =00000000                M sprs4	=	op4
000116D6                            	spAttackRt	$10, $0A, $0C, $13
000116D6 =00000010                M spar1	=	op1
000116D6 =0000000A                M spar2	=	op2
000116D6 =0000000C                M spar3	=	op3
000116D6 =00000013                M spar4	=	op4
000116D6                            	spAmpMod	$00, $00, $00, $00
000116D6 =00000000                M spam1	=	op1
000116D6 =00000000                M spam2	=	op2
000116D6 =00000000                M spam3	=	op3
000116D6 =00000000                M spam4	=	op4
000116D6                            	spSustainRt	$00, $00, $00, $00
000116D6 =00000000                M spsr1	=	op1
000116D6 =00000000                M spsr2	=	op2
000116D6 =00000000                M spsr3	=	op3
000116D6 =00000000                M spsr4	=	op4
000116D6                            	spDecayRt	$00, $00, $0C, $03
000116D6 =00000000                M spdr1	=	op1
000116D6 =00000000                M spdr2	=	op2
000116D6 =0000000C                M spdr3	=	op3
000116D6 =00000003                M spdr4	=	op4
000116D6                            	spSustainLv	$00, $00, $00, $00
000116D6 =00000000                M spsl1	=	op1
000116D6 =00000000                M spsl2	=	op2
000116D6 =00000000                M spsl3	=	op3
000116D6 =00000000                M spsl4	=	op4
000116D6                            	spReleaseRt	$0F, $0F, $0F, $0F
000116D6 =0000000F                M sprr1	=	op1
000116D6 =0000000F                M sprr2	=	op2
000116D6 =0000000F                M sprr3	=	op3
000116D6 =0000000F                M sprr4	=	op4
000116D6                            	spSSGEG		$00, $00, $00, $00
000116D6 =00000000                M spss1	=	op1
000116D6 =00000000                M spss2	=	op2
000116D6 =00000000                M spss3	=	op3
000116D6 =00000000                M spss4	=	op4
000116D6                            	spTotalLv	$20, $20, $00, $00
000116D6 =00000020                M sptl1	=	op1
000116D6 =00000020                M sptl2	=	op2
000116D6 =00000000                M sptl3	=	op3
000116D6 =00000000                M sptl4	=	op4
000116D6 3C                       M 	dc.b	(spfe<<3)+spal
000116D7 =00000080                M sptlmask4	set	$80
000116D7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000116D7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000116D7 =00000000                M sptlmask1	set	((spal=7)<<7)
000116D7 3173 7131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116DB 108C 0A13                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116DF 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116E3 000C 0003                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116E7 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116EF 2080 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000116F3 4E41 54                  M 	dc.b	'NAT'
000116F6                            
000116F6                            	; Patch $47
000116F6                            	; $24
000116F6                            	; $00, $04, $01, $04,	$10, $19, $10, $0D
000116F6                            	; $00, $03, $00, $00,	$02, $00, $01, $00
000116F6                            	; $0A, $0C, $0D, $0C,	$08, $04, $0B, $05
000116F6                            	spAlgorithm	$04
000116F6 =00000048                M spatnum	=	spatnum+1
000116F6 =00000004                M spal	=	val
000116F6                            	spFeedback	$04
000116F6 =00000004                M spfe	=	val
000116F6                            	spDetune	$00, $00, $00, $00
000116F6 =00000000                M spde1	=	op1
000116F6 =00000000                M spde2	=	op2
000116F6 =00000000                M spde3	=	op3
000116F6 =00000000                M spde4	=	op4
000116F6                            	spMultiple	$00, $01, $04, $04
000116F6 =00000000                M spmu1	=	op1
000116F6 =00000001                M spmu2	=	op2
000116F6 =00000004                M spmu3	=	op3
000116F6 =00000004                M spmu4	=	op4
000116F6                            	spRateScale	$00, $00, $00, $00
000116F6 =00000000                M sprs1	=	op1
000116F6 =00000000                M sprs2	=	op2
000116F6 =00000000                M sprs3	=	op3
000116F6 =00000000                M sprs4	=	op4
000116F6                            	spAttackRt	$10, $10, $19, $0D
000116F6 =00000010                M spar1	=	op1
000116F6 =00000010                M spar2	=	op2
000116F6 =00000019                M spar3	=	op3
000116F6 =0000000D                M spar4	=	op4
000116F6                            	spAmpMod	$00, $00, $00, $00
000116F6 =00000000                M spam1	=	op1
000116F6 =00000000                M spam2	=	op2
000116F6 =00000000                M spam3	=	op3
000116F6 =00000000                M spam4	=	op4
000116F6                            	spSustainRt	$00, $00, $03, $00
000116F6 =00000000                M spsr1	=	op1
000116F6 =00000000                M spsr2	=	op2
000116F6 =00000003                M spsr3	=	op3
000116F6 =00000000                M spsr4	=	op4
000116F6                            	spDecayRt	$02, $01, $00, $00
000116F6 =00000002                M spdr1	=	op1
000116F6 =00000001                M spdr2	=	op2
000116F6 =00000000                M spdr3	=	op3
000116F6 =00000000                M spdr4	=	op4
000116F6                            	spSustainLv	$00, $00, $00, $00
000116F6 =00000000                M spsl1	=	op1
000116F6 =00000000                M spsl2	=	op2
000116F6 =00000000                M spsl3	=	op3
000116F6 =00000000                M spsl4	=	op4
000116F6                            	spReleaseRt	$0A, $0D, $0C, $0C
000116F6 =0000000A                M sprr1	=	op1
000116F6 =0000000D                M sprr2	=	op2
000116F6 =0000000C                M sprr3	=	op3
000116F6 =0000000C                M sprr4	=	op4
000116F6                            	spSSGEG		$00, $00, $00, $00
000116F6 =00000000                M spss1	=	op1
000116F6 =00000000                M spss2	=	op2
000116F6 =00000000                M spss3	=	op3
000116F6 =00000000                M spss4	=	op4
000116F6                            	spTotalLv	$08, $0B, $04, $05
000116F6 =00000008                M sptl1	=	op1
000116F6 =0000000B                M sptl2	=	op2
000116F6 =00000004                M sptl3	=	op3
000116F6 =00000005                M sptl4	=	op4
000116F6 24                       M 	dc.b	(spfe<<3)+spal
000116F7 =00000080                M sptlmask4	set	$80
000116F7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000116F7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000116F7 =00000000                M sptlmask1	set	((spal=7)<<7)
000116F7 0004 0104                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116FB 1019 100D                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116FF 0003 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011703 0200 0100                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011707 0A0C 0D0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001170B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001170F 0884 0B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011713 4E41 54                  M 	dc.b	'NAT'
00011716                            
00011716                            	; Patch $48
00011716                            	; $22
00011716                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
00011716                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
00011716                            	; $01, $11, $31, $88,	$19, $28, $24, $00
00011716                            	spAlgorithm	$02
00011716 =00000049                M spatnum	=	spatnum+1
00011716 =00000002                M spal	=	val
00011716                            	spFeedback	$04
00011716 =00000004                M spfe	=	val
00011716                            	spDetune	$06, $00, $07, $03
00011716 =00000006                M spde1	=	op1
00011716 =00000000                M spde2	=	op2
00011716 =00000007                M spde3	=	op3
00011716 =00000003                M spde4	=	op4
00011716                            	spMultiple	$01, $04, $0C, $01
00011716 =00000001                M spmu1	=	op1
00011716 =00000004                M spmu2	=	op2
00011716 =0000000C                M spmu3	=	op3
00011716 =00000001                M spmu4	=	op4
00011716                            	spRateScale	$00, $02, $03, $01
00011716 =00000000                M sprs1	=	op1
00011716 =00000002                M sprs2	=	op2
00011716 =00000003                M sprs3	=	op3
00011716 =00000001                M sprs4	=	op4
00011716                            	spAttackRt	$14, $0F, $10, $14
00011716 =00000014                M spar1	=	op1
00011716 =0000000F                M spar2	=	op2
00011716 =00000010                M spar3	=	op3
00011716 =00000014                M spar4	=	op4
00011716                            	spAmpMod	$00, $00, $00, $00
00011716 =00000000                M spam1	=	op1
00011716 =00000000                M spam2	=	op2
00011716 =00000000                M spam3	=	op3
00011716 =00000000                M spam4	=	op4
00011716                            	spSustainRt	$01, $05, $05, $08
00011716 =00000001                M spsr1	=	op1
00011716 =00000005                M spsr2	=	op2
00011716 =00000005                M spsr3	=	op3
00011716 =00000008                M spsr4	=	op4
00011716                            	spDecayRt	$02, $05, $02, $1F
00011716 =00000002                M spdr1	=	op1
00011716 =00000005                M spdr2	=	op2
00011716 =00000002                M spdr3	=	op3
00011716 =0000001F                M spdr4	=	op4
00011716                            	spSustainLv	$00, $03, $01, $08
00011716 =00000000                M spsl1	=	op1
00011716 =00000003                M spsl2	=	op2
00011716 =00000001                M spsl3	=	op3
00011716 =00000008                M spsl4	=	op4
00011716                            	spReleaseRt	$01, $01, $01, $08
00011716 =00000001                M sprr1	=	op1
00011716 =00000001                M sprr2	=	op2
00011716 =00000001                M sprr3	=	op3
00011716 =00000008                M sprr4	=	op4
00011716                            	spSSGEG		$00, $00, $00, $00
00011716 =00000000                M spss1	=	op1
00011716 =00000000                M spss2	=	op2
00011716 =00000000                M spss3	=	op3
00011716 =00000000                M spss4	=	op4
00011716                            	spTotalLv	$19, $24, $28, $00
00011716 =00000019                M sptl1	=	op1
00011716 =00000024                M sptl2	=	op2
00011716 =00000028                M sptl3	=	op3
00011716 =00000000                M sptl4	=	op4
00011716 22                       M 	dc.b	(spfe<<3)+spal
00011717 =00000080                M sptlmask4	set	$80
00011717 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011717 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011717 =00000000                M sptlmask1	set	((spal=7)<<7)
00011717 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001171B 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001171F 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011723 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011727 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001172B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001172F 1928 2480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011733 4E41 54                  M 	dc.b	'NAT'
00011736                            
00011736                            	; Patch $49
00011736                            	; $3B
00011736                            	; $51, $71, $61, $41,	$51, $16, $18, $1A
00011736                            	; $05, $01, $01, $00,	$09, $01, $01, $01
00011736                            	; $17, $97, $27, $87,	$1C, $22, $15, $00
00011736                            	spAlgorithm	$03
00011736 =0000004A                M spatnum	=	spatnum+1
00011736 =00000003                M spal	=	val
00011736                            	spFeedback	$07
00011736 =00000007                M spfe	=	val
00011736                            	spDetune	$05, $06, $07, $04
00011736 =00000005                M spde1	=	op1
00011736 =00000006                M spde2	=	op2
00011736 =00000007                M spde3	=	op3
00011736 =00000004                M spde4	=	op4
00011736                            	spMultiple	$01, $01, $01, $01
00011736 =00000001                M spmu1	=	op1
00011736 =00000001                M spmu2	=	op2
00011736 =00000001                M spmu3	=	op3
00011736 =00000001                M spmu4	=	op4
00011736                            	spRateScale	$01, $00, $00, $00
00011736 =00000001                M sprs1	=	op1
00011736 =00000000                M sprs2	=	op2
00011736 =00000000                M sprs3	=	op3
00011736 =00000000                M sprs4	=	op4
00011736                            	spAttackRt	$11, $18, $16, $1A
00011736 =00000011                M spar1	=	op1
00011736 =00000018                M spar2	=	op2
00011736 =00000016                M spar3	=	op3
00011736 =0000001A                M spar4	=	op4
00011736                            	spAmpMod	$00, $00, $00, $00
00011736 =00000000                M spam1	=	op1
00011736 =00000000                M spam2	=	op2
00011736 =00000000                M spam3	=	op3
00011736 =00000000                M spam4	=	op4
00011736                            	spSustainRt	$05, $01, $01, $00
00011736 =00000005                M spsr1	=	op1
00011736 =00000001                M spsr2	=	op2
00011736 =00000001                M spsr3	=	op3
00011736 =00000000                M spsr4	=	op4
00011736                            	spDecayRt	$09, $01, $01, $01
00011736 =00000009                M spdr1	=	op1
00011736 =00000001                M spdr2	=	op2
00011736 =00000001                M spdr3	=	op3
00011736 =00000001                M spdr4	=	op4
00011736                            	spSustainLv	$01, $02, $09, $08
00011736 =00000001                M spsl1	=	op1
00011736 =00000002                M spsl2	=	op2
00011736 =00000009                M spsl3	=	op3
00011736 =00000008                M spsl4	=	op4
00011736                            	spReleaseRt	$07, $07, $07, $07
00011736 =00000007                M sprr1	=	op1
00011736 =00000007                M sprr2	=	op2
00011736 =00000007                M sprr3	=	op3
00011736 =00000007                M sprr4	=	op4
00011736                            	spSSGEG		$00, $00, $00, $00
00011736 =00000000                M spss1	=	op1
00011736 =00000000                M spss2	=	op2
00011736 =00000000                M spss3	=	op3
00011736 =00000000                M spss4	=	op4
00011736                            	spTotalLv	$1C, $15, $22, $00
00011736 =0000001C                M sptl1	=	op1
00011736 =00000015                M sptl2	=	op2
00011736 =00000022                M sptl3	=	op3
00011736 =00000000                M sptl4	=	op4
00011736 3B                       M 	dc.b	(spfe<<3)+spal
00011737 =00000080                M sptlmask4	set	$80
00011737 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011737 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011737 =00000000                M sptlmask1	set	((spal=7)<<7)
00011737 5171 6141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001173B 5116 181A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001173F 0501 0100                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011743 0901 0101                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011747 1797 2787                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001174B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001174F 1C22 1580                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011753 4E41 54                  M 	dc.b	'NAT'
00011756                            
00011756                            	; Patch $4A
00011756                            	; $32
00011756                            	; $00, $01, $04, $04,	$1F, $16, $18, $1B
00011756                            	; $08, $07, $07, $04,	$07, $08, $06, $1F
00011756                            	; $04, $58, $05, $77,	$06, $05, $15, $00
00011756                            	spAlgorithm	$02
00011756 =0000004B                M spatnum	=	spatnum+1
00011756 =00000002                M spal	=	val
00011756                            	spFeedback	$06
00011756 =00000006                M spfe	=	val
00011756                            	spDetune	$00, $00, $00, $00
00011756 =00000000                M spde1	=	op1
00011756 =00000000                M spde2	=	op2
00011756 =00000000                M spde3	=	op3
00011756 =00000000                M spde4	=	op4
00011756                            	spMultiple	$00, $04, $01, $04
00011756 =00000000                M spmu1	=	op1
00011756 =00000004                M spmu2	=	op2
00011756 =00000001                M spmu3	=	op3
00011756 =00000004                M spmu4	=	op4
00011756                            	spRateScale	$00, $00, $00, $00
00011756 =00000000                M sprs1	=	op1
00011756 =00000000                M sprs2	=	op2
00011756 =00000000                M sprs3	=	op3
00011756 =00000000                M sprs4	=	op4
00011756                            	spAttackRt	$1F, $18, $16, $1B
00011756 =0000001F                M spar1	=	op1
00011756 =00000018                M spar2	=	op2
00011756 =00000016                M spar3	=	op3
00011756 =0000001B                M spar4	=	op4
00011756                            	spAmpMod	$00, $00, $00, $00
00011756 =00000000                M spam1	=	op1
00011756 =00000000                M spam2	=	op2
00011756 =00000000                M spam3	=	op3
00011756 =00000000                M spam4	=	op4
00011756                            	spSustainRt	$08, $07, $07, $04
00011756 =00000008                M spsr1	=	op1
00011756 =00000007                M spsr2	=	op2
00011756 =00000007                M spsr3	=	op3
00011756 =00000004                M spsr4	=	op4
00011756                            	spDecayRt	$07, $06, $08, $1F
00011756 =00000007                M spdr1	=	op1
00011756 =00000006                M spdr2	=	op2
00011756 =00000008                M spdr3	=	op3
00011756 =0000001F                M spdr4	=	op4
00011756                            	spSustainLv	$00, $00, $05, $07
00011756 =00000000                M spsl1	=	op1
00011756 =00000000                M spsl2	=	op2
00011756 =00000005                M spsl3	=	op3
00011756 =00000007                M spsl4	=	op4
00011756                            	spReleaseRt	$04, $05, $08, $07
00011756 =00000004                M sprr1	=	op1
00011756 =00000005                M sprr2	=	op2
00011756 =00000008                M sprr3	=	op3
00011756 =00000007                M sprr4	=	op4
00011756                            	spSSGEG		$00, $00, $00, $00
00011756 =00000000                M spss1	=	op1
00011756 =00000000                M spss2	=	op2
00011756 =00000000                M spss3	=	op3
00011756 =00000000                M spss4	=	op4
00011756                            	spTotalLv	$06, $15, $05, $00
00011756 =00000006                M sptl1	=	op1
00011756 =00000015                M sptl2	=	op2
00011756 =00000005                M sptl3	=	op3
00011756 =00000000                M sptl4	=	op4
00011756 32                       M 	dc.b	(spfe<<3)+spal
00011757 =00000080                M sptlmask4	set	$80
00011757 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011757 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011757 =00000000                M sptlmask1	set	((spal=7)<<7)
00011757 0001 0404                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001175B 1F16 181B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001175F 0807 0704                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011763 0708 061F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011767 0458 0577                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001176B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001176F 0605 1580                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011773 4E41 54                  M 	dc.b	'NAT'
00011776                            
00011776                            	; Patch $4B
00011776                            	; $39
00011776                            	; $01, $61, $00, $00,	$1F, $5F, $5F, $5F
00011776                            	; $10, $11, $09, $09,	$1F, $1F, $1E, $1C
00011776                            	; $FF, $FF, $FF, $FF,	$1C, $22, $1F, $02
00011776                            	spAlgorithm	$01
00011776 =0000004C                M spatnum	=	spatnum+1
00011776 =00000001                M spal	=	val
00011776                            	spFeedback	$07
00011776 =00000007                M spfe	=	val
00011776                            	spDetune	$00, $00, $06, $00
00011776 =00000000                M spde1	=	op1
00011776 =00000000                M spde2	=	op2
00011776 =00000006                M spde3	=	op3
00011776 =00000000                M spde4	=	op4
00011776                            	spMultiple	$01, $00, $01, $00
00011776 =00000001                M spmu1	=	op1
00011776 =00000000                M spmu2	=	op2
00011776 =00000001                M spmu3	=	op3
00011776 =00000000                M spmu4	=	op4
00011776                            	spRateScale	$00, $01, $01, $01
00011776 =00000000                M sprs1	=	op1
00011776 =00000001                M sprs2	=	op2
00011776 =00000001                M sprs3	=	op3
00011776 =00000001                M sprs4	=	op4
00011776                            	spAttackRt	$1F, $1F, $1F, $1F
00011776 =0000001F                M spar1	=	op1
00011776 =0000001F                M spar2	=	op2
00011776 =0000001F                M spar3	=	op3
00011776 =0000001F                M spar4	=	op4
00011776                            	spAmpMod	$00, $00, $00, $00
00011776 =00000000                M spam1	=	op1
00011776 =00000000                M spam2	=	op2
00011776 =00000000                M spam3	=	op3
00011776 =00000000                M spam4	=	op4
00011776                            	spSustainRt	$10, $09, $11, $09
00011776 =00000010                M spsr1	=	op1
00011776 =00000009                M spsr2	=	op2
00011776 =00000011                M spsr3	=	op3
00011776 =00000009                M spsr4	=	op4
00011776                            	spDecayRt	$1F, $1E, $1F, $1C
00011776 =0000001F                M spdr1	=	op1
00011776 =0000001E                M spdr2	=	op2
00011776 =0000001F                M spdr3	=	op3
00011776 =0000001C                M spdr4	=	op4
00011776                            	spSustainLv	$0F, $0F, $0F, $0F
00011776 =0000000F                M spsl1	=	op1
00011776 =0000000F                M spsl2	=	op2
00011776 =0000000F                M spsl3	=	op3
00011776 =0000000F                M spsl4	=	op4
00011776                            	spReleaseRt	$0F, $0F, $0F, $0F
00011776 =0000000F                M sprr1	=	op1
00011776 =0000000F                M sprr2	=	op2
00011776 =0000000F                M sprr3	=	op3
00011776 =0000000F                M sprr4	=	op4
00011776                            	spSSGEG		$00, $00, $00, $00
00011776 =00000000                M spss1	=	op1
00011776 =00000000                M spss2	=	op2
00011776 =00000000                M spss3	=	op3
00011776 =00000000                M spss4	=	op4
00011776                            	spTotalLv	$1C, $1F, $22, $02
00011776 =0000001C                M sptl1	=	op1
00011776 =0000001F                M sptl2	=	op2
00011776 =00000022                M sptl3	=	op3
00011776 =00000002                M sptl4	=	op4
00011776 39                       M 	dc.b	(spfe<<3)+spal
00011777 =00000080                M sptlmask4	set	$80
00011777 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011777 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011777 =00000000                M sptlmask1	set	((spal=7)<<7)
00011777 0161 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001177B 1F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001177F 1011 0909                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011783 1F1F 1E1C                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011787 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001178B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001178F 1C22 1F82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011793 4E41 54                  M 	dc.b	'NAT'
00011796                            
00011796                            	; Patch $4C
00011796                            	; $27
00011796                            	; $14, $30, $51, $62,	$5C, $5C, $5C, $5C
00011796                            	; $00, $00, $00, $00,	$04, $1B, $04, $04
00011796                            	; $FA, $F8, $F8, $FA,	$08, $08, $08, $08
00011796                            	spAlgorithm	$07
00011796 =0000004D                M spatnum	=	spatnum+1
00011796 =00000007                M spal	=	val
00011796                            	spFeedback	$04
00011796 =00000004                M spfe	=	val
00011796                            	spDetune	$01, $05, $03, $06
00011796 =00000001                M spde1	=	op1
00011796 =00000005                M spde2	=	op2
00011796 =00000003                M spde3	=	op3
00011796 =00000006                M spde4	=	op4
00011796                            	spMultiple	$04, $01, $00, $02
00011796 =00000004                M spmu1	=	op1
00011796 =00000001                M spmu2	=	op2
00011796 =00000000                M spmu3	=	op3
00011796 =00000002                M spmu4	=	op4
00011796                            	spRateScale	$01, $01, $01, $01
00011796 =00000001                M sprs1	=	op1
00011796 =00000001                M sprs2	=	op2
00011796 =00000001                M sprs3	=	op3
00011796 =00000001                M sprs4	=	op4
00011796                            	spAttackRt	$1C, $1C, $1C, $1C
00011796 =0000001C                M spar1	=	op1
00011796 =0000001C                M spar2	=	op2
00011796 =0000001C                M spar3	=	op3
00011796 =0000001C                M spar4	=	op4
00011796                            	spAmpMod	$00, $00, $00, $00
00011796 =00000000                M spam1	=	op1
00011796 =00000000                M spam2	=	op2
00011796 =00000000                M spam3	=	op3
00011796 =00000000                M spam4	=	op4
00011796                            	spSustainRt	$00, $00, $00, $00
00011796 =00000000                M spsr1	=	op1
00011796 =00000000                M spsr2	=	op2
00011796 =00000000                M spsr3	=	op3
00011796 =00000000                M spsr4	=	op4
00011796                            	spDecayRt	$04, $04, $1B, $04
00011796 =00000004                M spdr1	=	op1
00011796 =00000004                M spdr2	=	op2
00011796 =0000001B                M spdr3	=	op3
00011796 =00000004                M spdr4	=	op4
00011796                            	spSustainLv	$0F, $0F, $0F, $0F
00011796 =0000000F                M spsl1	=	op1
00011796 =0000000F                M spsl2	=	op2
00011796 =0000000F                M spsl3	=	op3
00011796 =0000000F                M spsl4	=	op4
00011796                            	spReleaseRt	$0A, $08, $08, $0A
00011796 =0000000A                M sprr1	=	op1
00011796 =00000008                M sprr2	=	op2
00011796 =00000008                M sprr3	=	op3
00011796 =0000000A                M sprr4	=	op4
00011796                            	spSSGEG		$00, $00, $00, $00
00011796 =00000000                M spss1	=	op1
00011796 =00000000                M spss2	=	op2
00011796 =00000000                M spss3	=	op3
00011796 =00000000                M spss4	=	op4
00011796                            	spTotalLv	$08, $08, $08, $08
00011796 =00000008                M sptl1	=	op1
00011796 =00000008                M sptl2	=	op2
00011796 =00000008                M sptl3	=	op3
00011796 =00000008                M sptl4	=	op4
00011796 27                       M 	dc.b	(spfe<<3)+spal
00011797 =00000080                M sptlmask4	set	$80
00011797 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011797 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011797 =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
00011797 1430 5162                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001179B 5C5C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001179F 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117A3 041B 0404                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117A7 FAF8 F8FA                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117AF 8888 8888                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117B3 4E41 54                  M 	dc.b	'NAT'
000117B6                            
000117B6                            	; Patch $4D
000117B6                            	; $26
000117B6                            	; $01, $02, $01, $00,	$11, $19, $10, $17
000117B6                            	; $01, $01, $03, $01,	$07, $04, $03, $03
000117B6                            	; $05, $45, $3A, $0A,	$0A, $02, $0E, $00
000117B6                            	spAlgorithm	$06
000117B6 =0000004E                M spatnum	=	spatnum+1
000117B6 =00000006                M spal	=	val
000117B6                            	spFeedback	$04
000117B6 =00000004                M spfe	=	val
000117B6                            	spDetune	$00, $00, $00, $00
000117B6 =00000000                M spde1	=	op1
000117B6 =00000000                M spde2	=	op2
000117B6 =00000000                M spde3	=	op3
000117B6 =00000000                M spde4	=	op4
000117B6                            	spMultiple	$01, $01, $02, $00
000117B6 =00000001                M spmu1	=	op1
000117B6 =00000001                M spmu2	=	op2
000117B6 =00000002                M spmu3	=	op3
000117B6 =00000000                M spmu4	=	op4
000117B6                            	spRateScale	$00, $00, $00, $00
000117B6 =00000000                M sprs1	=	op1
000117B6 =00000000                M sprs2	=	op2
000117B6 =00000000                M sprs3	=	op3
000117B6 =00000000                M sprs4	=	op4
000117B6                            	spAttackRt	$11, $10, $19, $17
000117B6 =00000011                M spar1	=	op1
000117B6 =00000010                M spar2	=	op2
000117B6 =00000019                M spar3	=	op3
000117B6 =00000017                M spar4	=	op4
000117B6                            	spAmpMod	$00, $00, $00, $00
000117B6 =00000000                M spam1	=	op1
000117B6 =00000000                M spam2	=	op2
000117B6 =00000000                M spam3	=	op3
000117B6 =00000000                M spam4	=	op4
000117B6                            	spSustainRt	$01, $03, $01, $01
000117B6 =00000001                M spsr1	=	op1
000117B6 =00000003                M spsr2	=	op2
000117B6 =00000001                M spsr3	=	op3
000117B6 =00000001                M spsr4	=	op4
000117B6                            	spDecayRt	$07, $03, $04, $03
000117B6 =00000007                M spdr1	=	op1
000117B6 =00000003                M spdr2	=	op2
000117B6 =00000004                M spdr3	=	op3
000117B6 =00000003                M spdr4	=	op4
000117B6                            	spSustainLv	$00, $03, $04, $00
000117B6 =00000000                M spsl1	=	op1
000117B6 =00000003                M spsl2	=	op2
000117B6 =00000004                M spsl3	=	op3
000117B6 =00000000                M spsl4	=	op4
000117B6                            	spReleaseRt	$05, $0A, $05, $0A
000117B6 =00000005                M sprr1	=	op1
000117B6 =0000000A                M sprr2	=	op2
000117B6 =00000005                M sprr3	=	op3
000117B6 =0000000A                M sprr4	=	op4
000117B6                            	spSSGEG		$00, $00, $00, $00
000117B6 =00000000                M spss1	=	op1
000117B6 =00000000                M spss2	=	op2
000117B6 =00000000                M spss3	=	op3
000117B6 =00000000                M spss4	=	op4
000117B6                            	spTotalLv	$0A, $0E, $02, $00
000117B6 =0000000A                M sptl1	=	op1
000117B6 =0000000E                M sptl2	=	op2
000117B6 =00000002                M sptl3	=	op3
000117B6 =00000000                M sptl4	=	op4
000117B6 26                       M 	dc.b	(spfe<<3)+spal
000117B7 =00000080                M sptlmask4	set	$80
000117B7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000117B7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000117B7 =00000000                M sptlmask1	set	((spal=7)<<7)
000117B7 0102 0100                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117BB 1119 1017                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117BF 0101 0301                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117C3 0704 0303                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117C7 0545 3A0A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117CF 0A82 8E80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117D3 4E41 54                  M 	dc.b	'NAT'
000117D6                            
000117D6                            	; Patch $4E
000117D6                            	; $32
000117D6                            	; $30, $51, $72, $72,	$13, $18, $1F, $1F
000117D6                            	; $18, $1E, $1A, $05,	$05, $04, $02, $04
000117D6                            	; $25, $D5, $35, $25,	$15, $04, $1C, $00
000117D6                            	spAlgorithm	$02
000117D6 =0000004F                M spatnum	=	spatnum+1
000117D6 =00000002                M spal	=	val
000117D6                            	spFeedback	$06
000117D6 =00000006                M spfe	=	val
000117D6                            	spDetune	$03, $07, $05, $07
000117D6 =00000003                M spde1	=	op1
000117D6 =00000007                M spde2	=	op2
000117D6 =00000005                M spde3	=	op3
000117D6 =00000007                M spde4	=	op4
000117D6                            	spMultiple	$00, $02, $01, $02
000117D6 =00000000                M spmu1	=	op1
000117D6 =00000002                M spmu2	=	op2
000117D6 =00000001                M spmu3	=	op3
000117D6 =00000002                M spmu4	=	op4
000117D6                            	spRateScale	$00, $00, $00, $00
000117D6 =00000000                M sprs1	=	op1
000117D6 =00000000                M sprs2	=	op2
000117D6 =00000000                M sprs3	=	op3
000117D6 =00000000                M sprs4	=	op4
000117D6                            	spAttackRt	$13, $1F, $18, $1F
000117D6 =00000013                M spar1	=	op1
000117D6 =0000001F                M spar2	=	op2
000117D6 =00000018                M spar3	=	op3
000117D6 =0000001F                M spar4	=	op4
000117D6                            	spAmpMod	$00, $00, $00, $00
000117D6 =00000000                M spam1	=	op1
000117D6 =00000000                M spam2	=	op2
000117D6 =00000000                M spam3	=	op3
000117D6 =00000000                M spam4	=	op4
000117D6                            	spSustainRt	$18, $1A, $1E, $05
000117D6 =00000018                M spsr1	=	op1
000117D6 =0000001A                M spsr2	=	op2
000117D6 =0000001E                M spsr3	=	op3
000117D6 =00000005                M spsr4	=	op4
000117D6                            	spDecayRt	$05, $02, $04, $04
000117D6 =00000005                M spdr1	=	op1
000117D6 =00000002                M spdr2	=	op2
000117D6 =00000004                M spdr3	=	op3
000117D6 =00000004                M spdr4	=	op4
000117D6                            	spSustainLv	$02, $03, $0D, $02
000117D6 =00000002                M spsl1	=	op1
000117D6 =00000003                M spsl2	=	op2
000117D6 =0000000D                M spsl3	=	op3
000117D6 =00000002                M spsl4	=	op4
000117D6                            	spReleaseRt	$05, $05, $05, $05
000117D6 =00000005                M sprr1	=	op1
000117D6 =00000005                M sprr2	=	op2
000117D6 =00000005                M sprr3	=	op3
000117D6 =00000005                M sprr4	=	op4
000117D6                            	spSSGEG		$00, $00, $00, $00
000117D6 =00000000                M spss1	=	op1
000117D6 =00000000                M spss2	=	op2
000117D6 =00000000                M spss3	=	op3
000117D6 =00000000                M spss4	=	op4
000117D6                            	spTotalLv	$15, $1C, $04, $00
000117D6 =00000015                M sptl1	=	op1
000117D6 =0000001C                M sptl2	=	op2
000117D6 =00000004                M sptl3	=	op3
000117D6 =00000000                M sptl4	=	op4
000117D6 32                       M 	dc.b	(spfe<<3)+spal
000117D7 =00000080                M sptlmask4	set	$80
000117D7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000117D7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000117D7 =00000000                M sptlmask1	set	((spal=7)<<7)
000117D7 3051 7272                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117DB 1318 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117DF 181E 1A05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117E3 0504 0204                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117E7 25D5 3525                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117EF 1504 1C80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117F3 4E41 54                  M 	dc.b	'NAT'
000117F6                            
000117F6                            	; Patch $4F
000117F6                            	; $3E
000117F6                            	; $38, $01, $7A, $34,	$59, $D9, $5F, $9C
000117F6                            	; $0F, $04, $0F, $0A,	$02, $02, $05, $05
000117F6                            	; $AF, $AF, $66, $66,	$28, $00, $23, $00
000117F6                            	spAlgorithm	$06
000117F6 =00000050                M spatnum	=	spatnum+1
000117F6 =00000006                M spal	=	val
000117F6                            	spFeedback	$07
000117F6 =00000007                M spfe	=	val
000117F6                            	spDetune	$03, $07, $00, $03
000117F6 =00000003                M spde1	=	op1
000117F6 =00000007                M spde2	=	op2
000117F6 =00000000                M spde3	=	op3
000117F6 =00000003                M spde4	=	op4
000117F6                            	spMultiple	$08, $0A, $01, $04
000117F6 =00000008                M spmu1	=	op1
000117F6 =0000000A                M spmu2	=	op2
000117F6 =00000001                M spmu3	=	op3
000117F6 =00000004                M spmu4	=	op4
000117F6                            	spRateScale	$01, $01, $03, $02
000117F6 =00000001                M sprs1	=	op1
000117F6 =00000001                M sprs2	=	op2
000117F6 =00000003                M sprs3	=	op3
000117F6 =00000002                M sprs4	=	op4
000117F6                            	spAttackRt	$19, $1F, $19, $1C
000117F6 =00000019                M spar1	=	op1
000117F6 =0000001F                M spar2	=	op2
000117F6 =00000019                M spar3	=	op3
000117F6 =0000001C                M spar4	=	op4
000117F6                            	spAmpMod	$00, $00, $00, $00
000117F6 =00000000                M spam1	=	op1
000117F6 =00000000                M spam2	=	op2
000117F6 =00000000                M spam3	=	op3
000117F6 =00000000                M spam4	=	op4
000117F6                            	spSustainRt	$0F, $0F, $04, $0A
000117F6 =0000000F                M spsr1	=	op1
000117F6 =0000000F                M spsr2	=	op2
000117F6 =00000004                M spsr3	=	op3
000117F6 =0000000A                M spsr4	=	op4
000117F6                            	spDecayRt	$02, $05, $02, $05
000117F6 =00000002                M spdr1	=	op1
000117F6 =00000005                M spdr2	=	op2
000117F6 =00000002                M spdr3	=	op3
000117F6 =00000005                M spdr4	=	op4
000117F6                            	spSustainLv	$0A, $06, $0A, $06
000117F6 =0000000A                M spsl1	=	op1
000117F6 =00000006                M spsl2	=	op2
000117F6 =0000000A                M spsl3	=	op3
000117F6 =00000006                M spsl4	=	op4
000117F6                            	spReleaseRt	$0F, $06, $0F, $06
000117F6 =0000000F                M sprr1	=	op1
000117F6 =00000006                M sprr2	=	op2
000117F6 =0000000F                M sprr3	=	op3
000117F6 =00000006                M sprr4	=	op4
000117F6                            	spSSGEG		$00, $00, $00, $00
000117F6 =00000000                M spss1	=	op1
000117F6 =00000000                M spss2	=	op2
000117F6 =00000000                M spss3	=	op3
000117F6 =00000000                M spss4	=	op4
000117F6                            	spTotalLv	$28, $23, $00, $00
000117F6 =00000028                M sptl1	=	op1
000117F6 =00000023                M sptl2	=	op2
000117F6 =00000000                M sptl3	=	op3
000117F6 =00000000                M sptl4	=	op4
000117F6 3E                       M 	dc.b	(spfe<<3)+spal
000117F7 =00000080                M sptlmask4	set	$80
000117F7 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000117F7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000117F7 =00000000                M sptlmask1	set	((spal=7)<<7)
000117F7 3801 7A34                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117FB 59D9 5F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117FF 0F04 0F0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011803 0202 0505                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011807 AFAF 6666                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001180B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001180F 2880 A380                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011813 4E41 54                  M 	dc.b	'NAT'
00011816                            
00011816                            	; Patch $50
00011816                            	; $3A
00011816                            	; $31, $37, $72, $02,	$0F, $0B, $0B, $8B
00011816                            	; $04, $10, $09, $0A,	$00, $00, $03, $00
00011816                            	; $19, $08, $08, $18,	$1E, $21, $37, $00
00011816                            	spAlgorithm	$02
00011816 =00000051                M spatnum	=	spatnum+1
00011816 =00000002                M spal	=	val
00011816                            	spFeedback	$07
00011816 =00000007                M spfe	=	val
00011816                            	spDetune	$03, $07, $03, $00
00011816 =00000003                M spde1	=	op1
00011816 =00000007                M spde2	=	op2
00011816 =00000003                M spde3	=	op3
00011816 =00000000                M spde4	=	op4
00011816                            	spMultiple	$01, $02, $07, $02
00011816 =00000001                M spmu1	=	op1
00011816 =00000002                M spmu2	=	op2
00011816 =00000007                M spmu3	=	op3
00011816 =00000002                M spmu4	=	op4
00011816                            	spRateScale	$00, $00, $00, $02
00011816 =00000000                M sprs1	=	op1
00011816 =00000000                M sprs2	=	op2
00011816 =00000000                M sprs3	=	op3
00011816 =00000002                M sprs4	=	op4
00011816                            	spAttackRt	$0F, $0B, $0B, $0B
00011816 =0000000F                M spar1	=	op1
00011816 =0000000B                M spar2	=	op2
00011816 =0000000B                M spar3	=	op3
00011816 =0000000B                M spar4	=	op4
00011816                            	spAmpMod	$00, $00, $00, $00
00011816 =00000000                M spam1	=	op1
00011816 =00000000                M spam2	=	op2
00011816 =00000000                M spam3	=	op3
00011816 =00000000                M spam4	=	op4
00011816                            	spSustainRt	$04, $09, $10, $0A
00011816 =00000004                M spsr1	=	op1
00011816 =00000009                M spsr2	=	op2
00011816 =00000010                M spsr3	=	op3
00011816 =0000000A                M spsr4	=	op4
00011816                            	spDecayRt	$00, $03, $00, $00
00011816 =00000000                M spdr1	=	op1
00011816 =00000003                M spdr2	=	op2
00011816 =00000000                M spdr3	=	op3
00011816 =00000000                M spdr4	=	op4
00011816                            	spSustainLv	$01, $00, $00, $01
00011816 =00000001                M spsl1	=	op1
00011816 =00000000                M spsl2	=	op2
00011816 =00000000                M spsl3	=	op3
00011816 =00000001                M spsl4	=	op4
00011816                            	spReleaseRt	$09, $08, $08, $08
00011816 =00000009                M sprr1	=	op1
00011816 =00000008                M sprr2	=	op2
00011816 =00000008                M sprr3	=	op3
00011816 =00000008                M sprr4	=	op4
00011816                            	spSSGEG		$00, $00, $00, $00
00011816 =00000000                M spss1	=	op1
00011816 =00000000                M spss2	=	op2
00011816 =00000000                M spss3	=	op3
00011816 =00000000                M spss4	=	op4
00011816                            	spTotalLv	$1E, $37, $21, $00
00011816 =0000001E                M sptl1	=	op1
00011816 =00000037                M sptl2	=	op2
00011816 =00000021                M sptl3	=	op3
00011816 =00000000                M sptl4	=	op4
00011816 3A                       M 	dc.b	(spfe<<3)+spal
00011817 =00000080                M sptlmask4	set	$80
00011817 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011817 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011817 =00000000                M sptlmask1	set	((spal=7)<<7)
00011817 3137 7202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001181B 0F0B 0B8B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001181F 0410 090A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011823 0000 0300                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011827 1908 0818                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001182B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001182F 1E21 3780                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011833 4E41 54                  M 	dc.b	'NAT'
00011836                            
00011836                            	; Patch $51
00011836                            	; $3D
00011836                            	; $0A, $06, $06, $06,	$1F, $0C, $0C, $0C
00011836                            	; $00, $09, $09, $01,	$01, $02, $05, $01
00011836                            	; $F6, $F8, $F7, $F7,	$00, $00, $00, $00
00011836                            	spAlgorithm	$05
00011836 =00000052                M spatnum	=	spatnum+1
00011836 =00000005                M spal	=	val
00011836                            	spFeedback	$07
00011836 =00000007                M spfe	=	val
00011836                            	spDetune	$00, $00, $00, $00
00011836 =00000000                M spde1	=	op1
00011836 =00000000                M spde2	=	op2
00011836 =00000000                M spde3	=	op3
00011836 =00000000                M spde4	=	op4
00011836                            	spMultiple	$0A, $06, $06, $06
00011836 =0000000A                M spmu1	=	op1
00011836 =00000006                M spmu2	=	op2
00011836 =00000006                M spmu3	=	op3
00011836 =00000006                M spmu4	=	op4
00011836                            	spRateScale	$00, $00, $00, $00
00011836 =00000000                M sprs1	=	op1
00011836 =00000000                M sprs2	=	op2
00011836 =00000000                M sprs3	=	op3
00011836 =00000000                M sprs4	=	op4
00011836                            	spAttackRt	$1F, $0C, $0C, $0C
00011836 =0000001F                M spar1	=	op1
00011836 =0000000C                M spar2	=	op2
00011836 =0000000C                M spar3	=	op3
00011836 =0000000C                M spar4	=	op4
00011836                            	spAmpMod	$00, $00, $00, $00
00011836 =00000000                M spam1	=	op1
00011836 =00000000                M spam2	=	op2
00011836 =00000000                M spam3	=	op3
00011836 =00000000                M spam4	=	op4
00011836                            	spSustainRt	$00, $09, $09, $01
00011836 =00000000                M spsr1	=	op1
00011836 =00000009                M spsr2	=	op2
00011836 =00000009                M spsr3	=	op3
00011836 =00000001                M spsr4	=	op4
00011836                            	spSustainLv	$0F, $0F, $0F, $0F
00011836 =0000000F                M spsl1	=	op1
00011836 =0000000F                M spsl2	=	op2
00011836 =0000000F                M spsl3	=	op3
00011836 =0000000F                M spsl4	=	op4
00011836                            	spDecayRt	$01, $05, $02, $01
00011836 =00000001                M spdr1	=	op1
00011836 =00000005                M spdr2	=	op2
00011836 =00000002                M spdr3	=	op3
00011836 =00000001                M spdr4	=	op4
00011836                            	spReleaseRt	$06, $07, $08, $07
00011836 =00000006                M sprr1	=	op1
00011836 =00000007                M sprr2	=	op2
00011836 =00000008                M sprr3	=	op3
00011836 =00000007                M sprr4	=	op4
00011836                            	spSSGEG		$00, $00, $00, $00
00011836 =00000000                M spss1	=	op1
00011836 =00000000                M spss2	=	op2
00011836 =00000000                M spss3	=	op3
00011836 =00000000                M spss4	=	op4
00011836                            	spTotalLv	$00, $00, $00, $00
00011836 =00000000                M sptl1	=	op1
00011836 =00000000                M sptl2	=	op2
00011836 =00000000                M sptl3	=	op3
00011836 =00000000                M sptl4	=	op4
00011836 3D                       M 	dc.b	(spfe<<3)+spal
00011837 =00000080                M sptlmask4	set	$80
00011837 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011837 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011837 =00000000                M sptlmask1	set	((spal=7)<<7)
00011837 0A06 0606                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001183B 1F0C 0C0C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001183F 0009 0901                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011843 0102 0501                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011847 F6F8 F7F7                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001184B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001184F 0080 8080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011853 4E41 54                  M 	dc.b	'NAT'
00011856                            
00011856                            	; Patch $52
00011856                            	; $3C
00011856                            	; $31, $73, $71, $31,	$10, $8C, $0A, $13
00011856                            	; $00, $00, $00, $00,	$00, $0C, $00, $03
00011856                            	; $0F, $0F, $0F, $0F,	$20, $00, $20, $00
00011856                            	spAlgorithm	$04
00011856 =00000053                M spatnum	=	spatnum+1
00011856 =00000004                M spal	=	val
00011856                            	spFeedback	$07
00011856 =00000007                M spfe	=	val
00011856                            	spDetune	$03, $07, $07, $03
00011856 =00000003                M spde1	=	op1
00011856 =00000007                M spde2	=	op2
00011856 =00000007                M spde3	=	op3
00011856 =00000003                M spde4	=	op4
00011856                            	spMultiple	$01, $01, $03, $01
00011856 =00000001                M spmu1	=	op1
00011856 =00000001                M spmu2	=	op2
00011856 =00000003                M spmu3	=	op3
00011856 =00000001                M spmu4	=	op4
00011856                            	spRateScale	$00, $00, $02, $00
00011856 =00000000                M sprs1	=	op1
00011856 =00000000                M sprs2	=	op2
00011856 =00000002                M sprs3	=	op3
00011856 =00000000                M sprs4	=	op4
00011856                            	spAttackRt	$10, $0A, $0C, $13
00011856 =00000010                M spar1	=	op1
00011856 =0000000A                M spar2	=	op2
00011856 =0000000C                M spar3	=	op3
00011856 =00000013                M spar4	=	op4
00011856                            	spAmpMod	$00, $00, $00, $00
00011856 =00000000                M spam1	=	op1
00011856 =00000000                M spam2	=	op2
00011856 =00000000                M spam3	=	op3
00011856 =00000000                M spam4	=	op4
00011856                            	spSustainRt	$00, $00, $00, $00
00011856 =00000000                M spsr1	=	op1
00011856 =00000000                M spsr2	=	op2
00011856 =00000000                M spsr3	=	op3
00011856 =00000000                M spsr4	=	op4
00011856                            	spSustainLv	$00, $00, $00, $00
00011856 =00000000                M spsl1	=	op1
00011856 =00000000                M spsl2	=	op2
00011856 =00000000                M spsl3	=	op3
00011856 =00000000                M spsl4	=	op4
00011856                            	spDecayRt	$00, $00, $0C, $03
00011856 =00000000                M spdr1	=	op1
00011856 =00000000                M spdr2	=	op2
00011856 =0000000C                M spdr3	=	op3
00011856 =00000003                M spdr4	=	op4
00011856                            	spReleaseRt	$0F, $0F, $0F, $0F
00011856 =0000000F                M sprr1	=	op1
00011856 =0000000F                M sprr2	=	op2
00011856 =0000000F                M sprr3	=	op3
00011856 =0000000F                M sprr4	=	op4
00011856                            	spSSGEG		$00, $00, $00, $00
00011856 =00000000                M spss1	=	op1
00011856 =00000000                M spss2	=	op2
00011856 =00000000                M spss3	=	op3
00011856 =00000000                M spss4	=	op4
00011856                            	spTotalLv	$20, $20, $00, $00
00011856 =00000020                M sptl1	=	op1
00011856 =00000020                M sptl2	=	op2
00011856 =00000000                M sptl3	=	op3
00011856 =00000000                M sptl4	=	op4
00011856 3C                       M 	dc.b	(spfe<<3)+spal
00011857 =00000080                M sptlmask4	set	$80
00011857 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011857 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011857 =00000000                M sptlmask1	set	((spal=7)<<7)
00011857 3173 7131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001185B 108C 0A13                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001185F 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011863 000C 0003                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011867 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001186B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001186F 2080 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011873 4E41 54                  M 	dc.b	'NAT'
00011876                            
00011876                            	; Patch $53
00011876                            	; $3C
00011876                            	; $33, $41, $7F, $74,	$5B, $9F, $5F, $1F
00011876                            	; $04, $07, $07, $08,	$00, $00, $00, $00
00011876                            	; $A7, $C6, $C9, $D9,	$21, $00, $2D, $06
00011876                            	spAlgorithm	$04
00011876 =00000054                M spatnum	=	spatnum+1
00011876 =00000004                M spal	=	val
00011876                            	spFeedback	$07
00011876 =00000007                M spfe	=	val
00011876                            	spDetune	$03, $07, $04, $07
00011876 =00000003                M spde1	=	op1
00011876 =00000007                M spde2	=	op2
00011876 =00000004                M spde3	=	op3
00011876 =00000007                M spde4	=	op4
00011876                            	spMultiple	$03, $0F, $01, $04
00011876 =00000003                M spmu1	=	op1
00011876 =0000000F                M spmu2	=	op2
00011876 =00000001                M spmu3	=	op3
00011876 =00000004                M spmu4	=	op4
00011876                            	spRateScale	$01, $01, $02, $00
00011876 =00000001                M sprs1	=	op1
00011876 =00000001                M sprs2	=	op2
00011876 =00000002                M sprs3	=	op3
00011876 =00000000                M sprs4	=	op4
00011876                            	spAttackRt	$1B, $1F, $1F, $1F
00011876 =0000001B                M spar1	=	op1
00011876 =0000001F                M spar2	=	op2
00011876 =0000001F                M spar3	=	op3
00011876 =0000001F                M spar4	=	op4
00011876                            	spAmpMod	$00, $00, $00, $00
00011876 =00000000                M spam1	=	op1
00011876 =00000000                M spam2	=	op2
00011876 =00000000                M spam3	=	op3
00011876 =00000000                M spam4	=	op4
00011876                            	spSustainRt	$04, $07, $07, $08
00011876 =00000004                M spsr1	=	op1
00011876 =00000007                M spsr2	=	op2
00011876 =00000007                M spsr3	=	op3
00011876 =00000008                M spsr4	=	op4
00011876                            	spSustainLv	$0A, $0C, $0C, $0D
00011876 =0000000A                M spsl1	=	op1
00011876 =0000000C                M spsl2	=	op2
00011876 =0000000C                M spsl3	=	op3
00011876 =0000000D                M spsl4	=	op4
00011876                            	spDecayRt	$00, $00, $00, $00
00011876 =00000000                M spdr1	=	op1
00011876 =00000000                M spdr2	=	op2
00011876 =00000000                M spdr3	=	op3
00011876 =00000000                M spdr4	=	op4
00011876                            	spReleaseRt	$07, $09, $06, $09
00011876 =00000007                M sprr1	=	op1
00011876 =00000009                M sprr2	=	op2
00011876 =00000006                M sprr3	=	op3
00011876 =00000009                M sprr4	=	op4
00011876                            	spSSGEG		$00, $00, $00, $00
00011876 =00000000                M spss1	=	op1
00011876 =00000000                M spss2	=	op2
00011876 =00000000                M spss3	=	op3
00011876 =00000000                M spss4	=	op4
00011876                            	spTotalLv	$21, $2D, $00, $06
00011876 =00000021                M sptl1	=	op1
00011876 =0000002D                M sptl2	=	op2
00011876 =00000000                M sptl3	=	op3
00011876 =00000006                M sptl4	=	op4
00011876 3C                       M 	dc.b	(spfe<<3)+spal
00011877 =00000080                M sptlmask4	set	$80
00011877 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011877 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011877 =00000000                M sptlmask1	set	((spal=7)<<7)
00011877 3341 7F74                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001187B 5B9F 5F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001187F 0407 0708                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011883 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011887 A7C6 C9D9                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001188B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001188F 2180 2D86                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011893 4E41 54                  M 	dc.b	'NAT'
00011896                            
00011896                            	; Patch $54
00011896                            	; $22
00011896                            	; $61, $77, $02, $31,	$14, $D0, $8F, $54
00011896                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
00011896                            	; $01, $11, $31, $88,	$19, $28, $20, $00
00011896                            	spAlgorithm	$02
00011896 =00000055                M spatnum	=	spatnum+1
00011896 =00000002                M spal	=	val
00011896                            	spFeedback	$04
00011896 =00000004                M spfe	=	val
00011896                            	spDetune	$06, $00, $07, $03
00011896 =00000006                M spde1	=	op1
00011896 =00000000                M spde2	=	op2
00011896 =00000007                M spde3	=	op3
00011896 =00000003                M spde4	=	op4
00011896                            	spMultiple	$01, $02, $07, $01
00011896 =00000001                M spmu1	=	op1
00011896 =00000002                M spmu2	=	op2
00011896 =00000007                M spmu3	=	op3
00011896 =00000001                M spmu4	=	op4
00011896                            	spRateScale	$00, $02, $03, $01
00011896 =00000000                M sprs1	=	op1
00011896 =00000002                M sprs2	=	op2
00011896 =00000003                M sprs3	=	op3
00011896 =00000001                M sprs4	=	op4
00011896                            	spAttackRt	$14, $0F, $10, $14
00011896 =00000014                M spar1	=	op1
00011896 =0000000F                M spar2	=	op2
00011896 =00000010                M spar3	=	op3
00011896 =00000014                M spar4	=	op4
00011896                            	spAmpMod	$00, $00, $00, $00
00011896 =00000000                M spam1	=	op1
00011896 =00000000                M spam2	=	op2
00011896 =00000000                M spam3	=	op3
00011896 =00000000                M spam4	=	op4
00011896                            	spSustainRt	$01, $05, $05, $08
00011896 =00000001                M spsr1	=	op1
00011896 =00000005                M spsr2	=	op2
00011896 =00000005                M spsr3	=	op3
00011896 =00000008                M spsr4	=	op4
00011896                            	spSustainLv	$00, $03, $01, $08
00011896 =00000000                M spsl1	=	op1
00011896 =00000003                M spsl2	=	op2
00011896 =00000001                M spsl3	=	op3
00011896 =00000008                M spsl4	=	op4
00011896                            	spDecayRt	$02, $05, $02, $1F
00011896 =00000002                M spdr1	=	op1
00011896 =00000005                M spdr2	=	op2
00011896 =00000002                M spdr3	=	op3
00011896 =0000001F                M spdr4	=	op4
00011896                            	spReleaseRt	$01, $01, $01, $08
00011896 =00000001                M sprr1	=	op1
00011896 =00000001                M sprr2	=	op2
00011896 =00000001                M sprr3	=	op3
00011896 =00000008                M sprr4	=	op4
00011896                            	spSSGEG		$00, $00, $00, $00
00011896 =00000000                M spss1	=	op1
00011896 =00000000                M spss2	=	op2
00011896 =00000000                M spss3	=	op3
00011896 =00000000                M spss4	=	op4
00011896                            	spTotalLv	$19, $20, $28, $00
00011896 =00000019                M sptl1	=	op1
00011896 =00000020                M sptl2	=	op2
00011896 =00000028                M sptl3	=	op3
00011896 =00000000                M sptl4	=	op4
00011896 22                       M 	dc.b	(spfe<<3)+spal
00011897 =00000080                M sptlmask4	set	$80
00011897 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011897 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011897 =00000000                M sptlmask1	set	((spal=7)<<7)
00011897 6177 0231                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001189B 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001189F 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118A3 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118A7 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118AF 1928 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000118B3 4E41 54                  M 	dc.b	'NAT'
000118B6                            
000118B6                            	; Patch $55
000118B6                            	; $22
000118B6                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
000118B6                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
000118B6                            	; $01, $11, $31, $88,	$19, $28, $24, $00
000118B6                            	spAlgorithm	$02
000118B6 =00000056                M spatnum	=	spatnum+1
000118B6 =00000002                M spal	=	val
000118B6                            	spFeedback	$04
000118B6 =00000004                M spfe	=	val
000118B6                            	spDetune	$06, $00, $07, $03
000118B6 =00000006                M spde1	=	op1
000118B6 =00000000                M spde2	=	op2
000118B6 =00000007                M spde3	=	op3
000118B6 =00000003                M spde4	=	op4
000118B6                            	spMultiple	$01, $04, $0C, $01
000118B6 =00000001                M spmu1	=	op1
000118B6 =00000004                M spmu2	=	op2
000118B6 =0000000C                M spmu3	=	op3
000118B6 =00000001                M spmu4	=	op4
000118B6                            	spRateScale	$00, $02, $03, $01
000118B6 =00000000                M sprs1	=	op1
000118B6 =00000002                M sprs2	=	op2
000118B6 =00000003                M sprs3	=	op3
000118B6 =00000001                M sprs4	=	op4
000118B6                            	spAttackRt	$14, $0F, $10, $14
000118B6 =00000014                M spar1	=	op1
000118B6 =0000000F                M spar2	=	op2
000118B6 =00000010                M spar3	=	op3
000118B6 =00000014                M spar4	=	op4
000118B6                            	spAmpMod	$00, $00, $00, $00
000118B6 =00000000                M spam1	=	op1
000118B6 =00000000                M spam2	=	op2
000118B6 =00000000                M spam3	=	op3
000118B6 =00000000                M spam4	=	op4
000118B6                            	spSustainRt	$01, $05, $05, $08
000118B6 =00000001                M spsr1	=	op1
000118B6 =00000005                M spsr2	=	op2
000118B6 =00000005                M spsr3	=	op3
000118B6 =00000008                M spsr4	=	op4
000118B6                            	spSustainLv	$00, $03, $01, $08
000118B6 =00000000                M spsl1	=	op1
000118B6 =00000003                M spsl2	=	op2
000118B6 =00000001                M spsl3	=	op3
000118B6 =00000008                M spsl4	=	op4
000118B6                            	spDecayRt	$02, $05, $02, $1F
000118B6 =00000002                M spdr1	=	op1
000118B6 =00000005                M spdr2	=	op2
000118B6 =00000002                M spdr3	=	op3
000118B6 =0000001F                M spdr4	=	op4
000118B6                            	spReleaseRt	$01, $01, $01, $08
000118B6 =00000001                M sprr1	=	op1
000118B6 =00000001                M sprr2	=	op2
000118B6 =00000001                M sprr3	=	op3
000118B6 =00000008                M sprr4	=	op4
000118B6                            	spSSGEG		$00, $00, $00, $00
000118B6 =00000000                M spss1	=	op1
000118B6 =00000000                M spss2	=	op2
000118B6 =00000000                M spss3	=	op3
000118B6 =00000000                M spss4	=	op4
000118B6                            	spTotalLv	$19, $24, $28, $00
000118B6 =00000019                M sptl1	=	op1
000118B6 =00000024                M sptl2	=	op2
000118B6 =00000028                M sptl3	=	op3
000118B6 =00000000                M sptl4	=	op4
000118B6 22                       M 	dc.b	(spfe<<3)+spal
000118B7 =00000080                M sptlmask4	set	$80
000118B7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000118B7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000118B7 =00000000                M sptlmask1	set	((spal=7)<<7)
000118B7 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118BB 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118BF 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118C3 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118C7 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118CF 1928 2480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000118D3 4E41 54                  M 	dc.b	'NAT'
000118D6                            
000118D6                            	; Patch $56
000118D6                            	; $20
000118D6                            	; $66, $65, $60, $61,	$DF, $DF, $9F, $9F
000118D6                            	; $07, $06, $09, $06,	$07, $06, $06, $08
000118D6                            	; $29, $19, $19, $F9,	$1C, $3A, $16, $00
000118D6                            	spAlgorithm	$00
000118D6 =00000057                M spatnum	=	spatnum+1
000118D6 =00000000                M spal	=	val
000118D6                            	spFeedback	$04
000118D6 =00000004                M spfe	=	val
000118D6                            	spDetune	$06, $06, $06, $06
000118D6 =00000006                M spde1	=	op1
000118D6 =00000006                M spde2	=	op2
000118D6 =00000006                M spde3	=	op3
000118D6 =00000006                M spde4	=	op4
000118D6                            	spMultiple	$06, $00, $05, $01
000118D6 =00000006                M spmu1	=	op1
000118D6 =00000000                M spmu2	=	op2
000118D6 =00000005                M spmu3	=	op3
000118D6 =00000001                M spmu4	=	op4
000118D6                            	spRateScale	$03, $02, $03, $02
000118D6 =00000003                M sprs1	=	op1
000118D6 =00000002                M sprs2	=	op2
000118D6 =00000003                M sprs3	=	op3
000118D6 =00000002                M sprs4	=	op4
000118D6                            	spAttackRt	$1F, $1F, $1F, $1F
000118D6 =0000001F                M spar1	=	op1
000118D6 =0000001F                M spar2	=	op2
000118D6 =0000001F                M spar3	=	op3
000118D6 =0000001F                M spar4	=	op4
000118D6                            	spAmpMod	$00, $00, $00, $00
000118D6 =00000000                M spam1	=	op1
000118D6 =00000000                M spam2	=	op2
000118D6 =00000000                M spam3	=	op3
000118D6 =00000000                M spam4	=	op4
000118D6                            	spSustainRt	$07, $09, $06, $06
000118D6 =00000007                M spsr1	=	op1
000118D6 =00000009                M spsr2	=	op2
000118D6 =00000006                M spsr3	=	op3
000118D6 =00000006                M spsr4	=	op4
000118D6                            	spDecayRt	$07, $06, $06, $08
000118D6 =00000007                M spdr1	=	op1
000118D6 =00000006                M spdr2	=	op2
000118D6 =00000006                M spdr3	=	op3
000118D6 =00000008                M spdr4	=	op4
000118D6                            	spSustainLv	$02, $01, $01, $0F
000118D6 =00000002                M spsl1	=	op1
000118D6 =00000001                M spsl2	=	op2
000118D6 =00000001                M spsl3	=	op3
000118D6 =0000000F                M spsl4	=	op4
000118D6                            	spReleaseRt	$09, $09, $09, $09
000118D6 =00000009                M sprr1	=	op1
000118D6 =00000009                M sprr2	=	op2
000118D6 =00000009                M sprr3	=	op3
000118D6 =00000009                M sprr4	=	op4
000118D6                            	spSSGEG		$00, $00, $00, $00
000118D6 =00000000                M spss1	=	op1
000118D6 =00000000                M spss2	=	op2
000118D6 =00000000                M spss3	=	op3
000118D6 =00000000                M spss4	=	op4
000118D6                            	spTotalLv	$1C, $16, $3A, $00
000118D6 =0000001C                M sptl1	=	op1
000118D6 =00000016                M sptl2	=	op2
000118D6 =0000003A                M sptl3	=	op3
000118D6 =00000000                M sptl4	=	op4
000118D6 20                       M 	dc.b	(spfe<<3)+spal
000118D7 =00000080                M sptlmask4	set	$80
000118D7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000118D7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000118D7 =00000000                M sptlmask1	set	((spal=7)<<7)
000118D7 6665 6061                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118DB DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118DF 0706 0906                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118E3 0706 0608                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118E7 2919 19F9                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118EF 1C3A 1680                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000118F3 4E41 54                  M 	dc.b	'NAT'
000118F6                            
000118F6                            	; Patch $57
000118F6                            	; $3A
000118F6                            	; $31, $01, $01, $71,	$8F, $8F, $4F, $4D
000118F6                            	; $09, $09, $00, $03,	$00, $00, $00, $00
000118F6                            	; $15, $F5, $05, $0A,	$19, $1F, $19, $01
000118F6                            	spAlgorithm	$02
000118F6 =00000058                M spatnum	=	spatnum+1
000118F6 =00000002                M spal	=	val
000118F6                            	spFeedback	$07
000118F6 =00000007                M spfe	=	val
000118F6                            	spDetune	$03, $00, $00, $07
000118F6 =00000003                M spde1	=	op1
000118F6 =00000000                M spde2	=	op2
000118F6 =00000000                M spde3	=	op3
000118F6 =00000007                M spde4	=	op4
000118F6                            	spMultiple	$01, $01, $01, $01
000118F6 =00000001                M spmu1	=	op1
000118F6 =00000001                M spmu2	=	op2
000118F6 =00000001                M spmu3	=	op3
000118F6 =00000001                M spmu4	=	op4
000118F6                            	spRateScale	$02, $01, $02, $01
000118F6 =00000002                M sprs1	=	op1
000118F6 =00000001                M sprs2	=	op2
000118F6 =00000002                M sprs3	=	op3
000118F6 =00000001                M sprs4	=	op4
000118F6                            	spAttackRt	$0F, $0F, $0F, $0D
000118F6 =0000000F                M spar1	=	op1
000118F6 =0000000F                M spar2	=	op2
000118F6 =0000000F                M spar3	=	op3
000118F6 =0000000D                M spar4	=	op4
000118F6                            	spAmpMod	$00, $00, $00, $00
000118F6 =00000000                M spam1	=	op1
000118F6 =00000000                M spam2	=	op2
000118F6 =00000000                M spam3	=	op3
000118F6 =00000000                M spam4	=	op4
000118F6                            	spSustainRt	$09, $00, $09, $03
000118F6 =00000009                M spsr1	=	op1
000118F6 =00000000                M spsr2	=	op2
000118F6 =00000009                M spsr3	=	op3
000118F6 =00000003                M spsr4	=	op4
000118F6                            	spDecayRt	$00, $00, $00, $00
000118F6 =00000000                M spdr1	=	op1
000118F6 =00000000                M spdr2	=	op2
000118F6 =00000000                M spdr3	=	op3
000118F6 =00000000                M spdr4	=	op4
000118F6                            	spSustainLv	$01, $00, $0F, $00
000118F6 =00000001                M spsl1	=	op1
000118F6 =00000000                M spsl2	=	op2
000118F6 =0000000F                M spsl3	=	op3
000118F6 =00000000                M spsl4	=	op4
000118F6                            	spReleaseRt	$05, $05, $05, $0A
000118F6 =00000005                M sprr1	=	op1
000118F6 =00000005                M sprr2	=	op2
000118F6 =00000005                M sprr3	=	op3
000118F6 =0000000A                M sprr4	=	op4
000118F6                            	spSSGEG		$00, $00, $00, $00
000118F6 =00000000                M spss1	=	op1
000118F6 =00000000                M spss2	=	op2
000118F6 =00000000                M spss3	=	op3
000118F6 =00000000                M spss4	=	op4
000118F6                            	spTotalLv	$19, $19, $1F, $01
000118F6 =00000019                M sptl1	=	op1
000118F6 =00000019                M sptl2	=	op2
000118F6 =0000001F                M sptl3	=	op3
000118F6 =00000001                M sptl4	=	op4
000118F6 3A                       M 	dc.b	(spfe<<3)+spal
000118F7 =00000080                M sptlmask4	set	$80
000118F7 =00000000                M sptlmask2	set	((spal>=5)<<7)
000118F7 =00000000                M sptlmask3	set	((spal>=4)<<7)
000118F7 =00000000                M sptlmask1	set	((spal=7)<<7)
000118F7 3101 0171                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118FB 8F8F 4F4D                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118FF 0909 0003                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011903 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011907 15F5 050A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001190B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001190F 191F 1981                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011913 4E41 54                  M 	dc.b	'NAT'
00011916                            
00011916                            	; Patch $58
00011916                            	; $3A
00011916                            	; $01, $07, $01, $01,	$8E, $8E, $8D, $53
00011916                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
00011916                            	; $1F, $FF, $1F, $0F,	$17, $28, $27, $86
00011916                            	spAlgorithm	$02
00011916 =00000059                M spatnum	=	spatnum+1
00011916 =00000002                M spal	=	val
00011916                            	spFeedback	$07
00011916 =00000007                M spfe	=	val
00011916                            	spDetune	$00, $00, $00, $00
00011916 =00000000                M spde1	=	op1
00011916 =00000000                M spde2	=	op2
00011916 =00000000                M spde3	=	op3
00011916 =00000000                M spde4	=	op4
00011916                            	spMultiple	$01, $01, $07, $01
00011916 =00000001                M spmu1	=	op1
00011916 =00000001                M spmu2	=	op2
00011916 =00000007                M spmu3	=	op3
00011916 =00000001                M spmu4	=	op4
00011916                            	spRateScale	$02, $02, $02, $01
00011916 =00000002                M sprs1	=	op1
00011916 =00000002                M sprs2	=	op2
00011916 =00000002                M sprs3	=	op3
00011916 =00000001                M sprs4	=	op4
00011916                            	spAttackRt	$0E, $0D, $0E, $13
00011916 =0000000E                M spar1	=	op1
00011916 =0000000D                M spar2	=	op2
00011916 =0000000E                M spar3	=	op3
00011916 =00000013                M spar4	=	op4
00011916                            	spAmpMod	$00, $00, $00, $00
00011916 =00000000                M spam1	=	op1
00011916 =00000000                M spam2	=	op2
00011916 =00000000                M spam3	=	op3
00011916 =00000000                M spam4	=	op4
00011916                            	spSustainRt	$0E, $0E, $0E, $03
00011916 =0000000E                M spsr1	=	op1
00011916 =0000000E                M spsr2	=	op2
00011916 =0000000E                M spsr3	=	op3
00011916 =00000003                M spsr4	=	op4
00011916                            	spDecayRt	$00, $00, $00, $00
00011916 =00000000                M spdr1	=	op1
00011916 =00000000                M spdr2	=	op2
00011916 =00000000                M spdr3	=	op3
00011916 =00000000                M spdr4	=	op4
00011916                            	spSustainLv	$01, $01, $0F, $00
00011916 =00000001                M spsl1	=	op1
00011916 =00000001                M spsl2	=	op2
00011916 =0000000F                M spsl3	=	op3
00011916 =00000000                M spsl4	=	op4
00011916                            	spReleaseRt	$0F, $0F, $0F, $0F
00011916 =0000000F                M sprr1	=	op1
00011916 =0000000F                M sprr2	=	op2
00011916 =0000000F                M sprr3	=	op3
00011916 =0000000F                M sprr4	=	op4
00011916                            	spSSGEG		$00, $00, $00, $00
00011916 =00000000                M spss1	=	op1
00011916 =00000000                M spss2	=	op2
00011916 =00000000                M spss3	=	op3
00011916 =00000000                M spss4	=	op4
00011916                            	spTotalLv	$17, $27, $28, $06
00011916 =00000017                M sptl1	=	op1
00011916 =00000027                M sptl2	=	op2
00011916 =00000028                M sptl3	=	op3
00011916 =00000006                M sptl4	=	op4
00011916 3A                       M 	dc.b	(spfe<<3)+spal
00011917 =00000080                M sptlmask4	set	$80
00011917 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011917 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011917 =00000000                M sptlmask1	set	((spal=7)<<7)
00011917 0107 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001191B 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001191F 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011923 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011927 1FFF 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001192B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001192F 1728 2786                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011933 4E41 54                  M 	dc.b	'NAT'
00011936                            
00011936                            	; Patch $59
00011936                            	; $3A
00011936                            	; $51, $07, $51, $02,	$0F, $0B, $0F, $0F
00011936                            	; $1F, $1F, $1F, $0F,	$00, $00, $00, $02
00011936                            	; $0F, $0F, $0F, $1F,	$1C, $28, $22, $81
00011936                            	spAlgorithm	$02
00011936 =0000005A                M spatnum	=	spatnum+1
00011936 =00000002                M spal	=	val
00011936                            	spFeedback	$07
00011936 =00000007                M spfe	=	val
00011936                            	spDetune	$05, $05, $00, $00
00011936 =00000005                M spde1	=	op1
00011936 =00000005                M spde2	=	op2
00011936 =00000000                M spde3	=	op3
00011936 =00000000                M spde4	=	op4
00011936                            	spMultiple	$01, $01, $07, $02
00011936 =00000001                M spmu1	=	op1
00011936 =00000001                M spmu2	=	op2
00011936 =00000007                M spmu3	=	op3
00011936 =00000002                M spmu4	=	op4
00011936                            	spRateScale	$00, $00, $00, $00
00011936 =00000000                M sprs1	=	op1
00011936 =00000000                M sprs2	=	op2
00011936 =00000000                M sprs3	=	op3
00011936 =00000000                M sprs4	=	op4
00011936                            	spAttackRt	$0F, $0F, $0B, $0F
00011936 =0000000F                M spar1	=	op1
00011936 =0000000F                M spar2	=	op2
00011936 =0000000B                M spar3	=	op3
00011936 =0000000F                M spar4	=	op4
00011936                            	spAmpMod	$00, $00, $00, $00
00011936 =00000000                M spam1	=	op1
00011936 =00000000                M spam2	=	op2
00011936 =00000000                M spam3	=	op3
00011936 =00000000                M spam4	=	op4
00011936                            	spSustainRt	$1F, $1F, $1F, $0F
00011936 =0000001F                M spsr1	=	op1
00011936 =0000001F                M spsr2	=	op2
00011936 =0000001F                M spsr3	=	op3
00011936 =0000000F                M spsr4	=	op4
00011936                            	spDecayRt	$00, $00, $00, $02
00011936 =00000000                M spdr1	=	op1
00011936 =00000000                M spdr2	=	op2
00011936 =00000000                M spdr3	=	op3
00011936 =00000002                M spdr4	=	op4
00011936                            	spSustainLv	$00, $00, $00, $01
00011936 =00000000                M spsl1	=	op1
00011936 =00000000                M spsl2	=	op2
00011936 =00000000                M spsl3	=	op3
00011936 =00000001                M spsl4	=	op4
00011936                            	spReleaseRt	$0F, $0F, $0F, $0F
00011936 =0000000F                M sprr1	=	op1
00011936 =0000000F                M sprr2	=	op2
00011936 =0000000F                M sprr3	=	op3
00011936 =0000000F                M sprr4	=	op4
00011936                            	spSSGEG		$00, $00, $00, $00
00011936 =00000000                M spss1	=	op1
00011936 =00000000                M spss2	=	op2
00011936 =00000000                M spss3	=	op3
00011936 =00000000                M spss4	=	op4
00011936                            	spTotalLv	$1C, $22, $28, $01
00011936 =0000001C                M sptl1	=	op1
00011936 =00000022                M sptl2	=	op2
00011936 =00000028                M sptl3	=	op3
00011936 =00000001                M sptl4	=	op4
00011936 3A                       M 	dc.b	(spfe<<3)+spal
00011937 =00000080                M sptlmask4	set	$80
00011937 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011937 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011937 =00000000                M sptlmask1	set	((spal=7)<<7)
00011937 5107 5102                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001193B 0F0B 0F0F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001193F 1F1F 1F0F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011943 0000 0002                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011947 0F0F 0F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001194B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001194F 1C28 2281                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011953 4E41 54                  M 	dc.b	'NAT'
00011956                            
00011956                            	even
00011956                            
00011956                            ; -------------------------------------------------------------------------
00011956                            VoiceBankSFX:
00011956 =00000000                  sPatNum = 0
00011956                            	include "Sound/unipatchsfx.asm"; include universal Voice banks
00011956                            
00011956                            ; ------------------------------------------------------------------------
00011956                            ; AMPS SFX patch list
00011956                            ; -------------------------------------------------------------------------
00011956                            
00011956                            	; Patch $00
00011956                            	; $07
00011956                            	; $07, $07, $08, $08,	$1F, $1F, $1F, $1F
00011956                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00011956                            	; $0F, $0F, $0F, $0F,	$80, $80, $80, $80
00011956                            	spAlgorithm	$07
00011956 =00000001                M spatnum	=	spatnum+1
00011956 =00000007                M spal	=	val
00011956                            	spFeedback	$00
00011956 =00000000                M spfe	=	val
00011956                            	spDetune	$00, $00, $00, $00
00011956 =00000000                M spde1	=	op1
00011956 =00000000                M spde2	=	op2
00011956 =00000000                M spde3	=	op3
00011956 =00000000                M spde4	=	op4
00011956                            	spMultiple	$07, $08, $07, $08
00011956 =00000007                M spmu1	=	op1
00011956 =00000008                M spmu2	=	op2
00011956 =00000007                M spmu3	=	op3
00011956 =00000008                M spmu4	=	op4
00011956                            	spRateScale	$00, $00, $00, $00
00011956 =00000000                M sprs1	=	op1
00011956 =00000000                M sprs2	=	op2
00011956 =00000000                M sprs3	=	op3
00011956 =00000000                M sprs4	=	op4
00011956                            	spAttackRt	$1F, $1F, $1F, $1F
00011956 =0000001F                M spar1	=	op1
00011956 =0000001F                M spar2	=	op2
00011956 =0000001F                M spar3	=	op3
00011956 =0000001F                M spar4	=	op4
00011956                            	spAmpMod	$00, $00, $00, $00
00011956 =00000000                M spam1	=	op1
00011956 =00000000                M spam2	=	op2
00011956 =00000000                M spam3	=	op3
00011956 =00000000                M spam4	=	op4
00011956                            	spSustainRt	$00, $00, $00, $00
00011956 =00000000                M spsr1	=	op1
00011956 =00000000                M spsr2	=	op2
00011956 =00000000                M spsr3	=	op3
00011956 =00000000                M spsr4	=	op4
00011956                            	spDecayRt	$00, $00, $00, $00
00011956 =00000000                M spdr1	=	op1
00011956 =00000000                M spdr2	=	op2
00011956 =00000000                M spdr3	=	op3
00011956 =00000000                M spdr4	=	op4
00011956                            	spSustainLv	$00, $00, $00, $00
00011956 =00000000                M spsl1	=	op1
00011956 =00000000                M spsl2	=	op2
00011956 =00000000                M spsl3	=	op3
00011956 =00000000                M spsl4	=	op4
00011956                            	spReleaseRt	$0F, $0F, $0F, $0F
00011956 =0000000F                M sprr1	=	op1
00011956 =0000000F                M sprr2	=	op2
00011956 =0000000F                M sprr3	=	op3
00011956 =0000000F                M sprr4	=	op4
00011956                            	spSSGEG		$00, $00, $00, $00
00011956 =00000000                M spss1	=	op1
00011956 =00000000                M spss2	=	op2
00011956 =00000000                M spss3	=	op3
00011956 =00000000                M spss4	=	op4
00011956                            	spTotalLv2	$80, $80, $80, $80
00011956 =00000080                M sptl1	=	op1
00011956 =00000080                M sptl2	=	op2
00011956 =00000080                M sptl3	=	op3
00011956 =00000080                M sptl4	=	op4
00011956 07                       M 	dc.b	(spfe<<3)+spal
00011957 0707 0808                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001195B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001195F 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011963 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011967 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001196B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001196F 8080 8080                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011973 4E41 54                  M 	dc.b	'NAT'
00011976                            
00011976                            	; Patch $01
00011976                            	; $0C
00011976                            	; $08, $08, $08, $08,	$1F, $1F, $1F, $1F
00011976                            	; $00, $0A, $00, $0A,	$00, $00, $00, $0A
00011976                            	; $FF, $FF, $FF, $FF,	$55, $81, $33, $81
00011976                            	spAlgorithm	$04
00011976 =00000002                M spatnum	=	spatnum+1
00011976 =00000004                M spal	=	val
00011976                            	spFeedback	$01
00011976 =00000001                M spfe	=	val
00011976                            	spDetune	$00, $00, $00, $00
00011976 =00000000                M spde1	=	op1
00011976 =00000000                M spde2	=	op2
00011976 =00000000                M spde3	=	op3
00011976 =00000000                M spde4	=	op4
00011976                            	spMultiple	$08, $08, $08, $08
00011976 =00000008                M spmu1	=	op1
00011976 =00000008                M spmu2	=	op2
00011976 =00000008                M spmu3	=	op3
00011976 =00000008                M spmu4	=	op4
00011976                            	spRateScale	$00, $00, $00, $00
00011976 =00000000                M sprs1	=	op1
00011976 =00000000                M sprs2	=	op2
00011976 =00000000                M sprs3	=	op3
00011976 =00000000                M sprs4	=	op4
00011976                            	spAttackRt	$1F, $1F, $1F, $1F
00011976 =0000001F                M spar1	=	op1
00011976 =0000001F                M spar2	=	op2
00011976 =0000001F                M spar3	=	op3
00011976 =0000001F                M spar4	=	op4
00011976                            	spAmpMod	$00, $00, $00, $00
00011976 =00000000                M spam1	=	op1
00011976 =00000000                M spam2	=	op2
00011976 =00000000                M spam3	=	op3
00011976 =00000000                M spam4	=	op4
00011976                            	spSustainRt	$00, $00, $0A, $0A
00011976 =00000000                M spsr1	=	op1
00011976 =00000000                M spsr2	=	op2
00011976 =0000000A                M spsr3	=	op3
00011976 =0000000A                M spsr4	=	op4
00011976                            	spDecayRt	$00, $00, $00, $0A
00011976 =00000000                M spdr1	=	op1
00011976 =00000000                M spdr2	=	op2
00011976 =00000000                M spdr3	=	op3
00011976 =0000000A                M spdr4	=	op4
00011976                            	spSustainLv	$0F, $0F, $0F, $0F
00011976 =0000000F                M spsl1	=	op1
00011976 =0000000F                M spsl2	=	op2
00011976 =0000000F                M spsl3	=	op3
00011976 =0000000F                M spsl4	=	op4
00011976                            	spReleaseRt	$0F, $0F, $0F, $0F
00011976 =0000000F                M sprr1	=	op1
00011976 =0000000F                M sprr2	=	op2
00011976 =0000000F                M sprr3	=	op3
00011976 =0000000F                M sprr4	=	op4
00011976                            	spSSGEG		$00, $00, $00, $00
00011976 =00000000                M spss1	=	op1
00011976 =00000000                M spss2	=	op2
00011976 =00000000                M spss3	=	op3
00011976 =00000000                M spss4	=	op4
00011976                            	spTotalLv	$55, $33, $01, $01
00011976 =00000055                M sptl1	=	op1
00011976 =00000033                M sptl2	=	op2
00011976 =00000001                M sptl3	=	op3
00011976 =00000001                M sptl4	=	op4
00011976 0C                       M 	dc.b	(spfe<<3)+spal
00011977 =00000080                M sptlmask4	set	$80
00011977 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011977 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011977 =00000000                M sptlmask1	set	((spal=7)<<7)
00011977 0808 0808                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001197B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001197F 000A 000A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011983 0000 000A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011987 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001198B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
0001198F 5581 3381                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011993 4E41 54                  M 	dc.b	'NAT'
00011996                            
00011996                            	; Patch $02
00011996                            	; $30
00011996                            	; $30, $30, $30, $30,	$9E, $D8, $DC, $DC
00011996                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
00011996                            	; $BF, $BF, $BF, $BF,	$14, $3A, $14, $80
00011996                            	spAlgorithm	$00
00011996 =00000003                M spatnum	=	spatnum+1
00011996 =00000000                M spal	=	val
00011996                            	spFeedback	$06
00011996 =00000006                M spfe	=	val
00011996                            	spDetune	$03, $03, $03, $03
00011996 =00000003                M spde1	=	op1
00011996 =00000003                M spde2	=	op2
00011996 =00000003                M spde3	=	op3
00011996 =00000003                M spde4	=	op4
00011996                            	spMultiple	$00, $00, $00, $00
00011996 =00000000                M spmu1	=	op1
00011996 =00000000                M spmu2	=	op2
00011996 =00000000                M spmu3	=	op3
00011996 =00000000                M spmu4	=	op4
00011996                            	spRateScale	$02, $03, $03, $03
00011996 =00000002                M sprs1	=	op1
00011996 =00000003                M sprs2	=	op2
00011996 =00000003                M sprs3	=	op3
00011996 =00000003                M sprs4	=	op4
00011996                            	spAttackRt	$1E, $1C, $18, $1C
00011996 =0000001E                M spar1	=	op1
00011996 =0000001C                M spar2	=	op2
00011996 =00000018                M spar3	=	op3
00011996 =0000001C                M spar4	=	op4
00011996                            	spAmpMod	$00, $00, $00, $00
00011996 =00000000                M spam1	=	op1
00011996 =00000000                M spam2	=	op2
00011996 =00000000                M spam3	=	op3
00011996 =00000000                M spam4	=	op4
00011996                            	spSustainRt	$0E, $04, $0A, $05
00011996 =0000000E                M spsr1	=	op1
00011996 =00000004                M spsr2	=	op2
00011996 =0000000A                M spsr3	=	op3
00011996 =00000005                M spsr4	=	op4
00011996                            	spDecayRt	$08, $08, $08, $08
00011996 =00000008                M spdr1	=	op1
00011996 =00000008                M spdr2	=	op2
00011996 =00000008                M spdr3	=	op3
00011996 =00000008                M spdr4	=	op4
00011996                            	spSustainLv	$0B, $0B, $0B, $0B
00011996 =0000000B                M spsl1	=	op1
00011996 =0000000B                M spsl2	=	op2
00011996 =0000000B                M spsl3	=	op3
00011996 =0000000B                M spsl4	=	op4
00011996                            	spReleaseRt	$0F, $0F, $0F, $0F
00011996 =0000000F                M sprr1	=	op1
00011996 =0000000F                M sprr2	=	op2
00011996 =0000000F                M sprr3	=	op3
00011996 =0000000F                M sprr4	=	op4
00011996                            	spSSGEG		$00, $00, $00, $00
00011996 =00000000                M spss1	=	op1
00011996 =00000000                M spss2	=	op2
00011996 =00000000                M spss3	=	op3
00011996 =00000000                M spss4	=	op4
00011996                            	spTotalLv2	$14, $14, $3A, $80
00011996 =00000014                M sptl1	=	op1
00011996 =00000014                M sptl2	=	op2
00011996 =0000003A                M sptl3	=	op3
00011996 =00000080                M sptl4	=	op4
00011996 30                       M 	dc.b	(spfe<<3)+spal
00011997 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001199B 9ED8 DCDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
0001199F 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000119A3 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119A7 BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119AB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119AF 143A 1480                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000119B3 4E41 54                  M 	dc.b	'NAT'
000119B6                            
000119B6                            	; Patch $03
000119B6                            	; $04
000119B6                            	; $37, $72, $77, $49,	$1F, $1F, $1F, $1F
000119B6                            	; $07, $0A, $07, $0D,	$00, $0B, $00, $0B
000119B6                            	; $1F, $0F, $1F, $0F,	$23, $00, $23, $00
000119B6                            	spAlgorithm	$04
000119B6 =00000004                M spatnum	=	spatnum+1
000119B6 =00000004                M spal	=	val
000119B6                            	spFeedback	$00
000119B6 =00000000                M spfe	=	val
000119B6                            	spDetune	$03, $07, $07, $04
000119B6 =00000003                M spde1	=	op1
000119B6 =00000007                M spde2	=	op2
000119B6 =00000007                M spde3	=	op3
000119B6 =00000004                M spde4	=	op4
000119B6                            	spMultiple	$07, $07, $02, $09
000119B6 =00000007                M spmu1	=	op1
000119B6 =00000007                M spmu2	=	op2
000119B6 =00000002                M spmu3	=	op3
000119B6 =00000009                M spmu4	=	op4
000119B6                            	spRateScale	$00, $00, $00, $00
000119B6 =00000000                M sprs1	=	op1
000119B6 =00000000                M sprs2	=	op2
000119B6 =00000000                M sprs3	=	op3
000119B6 =00000000                M sprs4	=	op4
000119B6                            	spAttackRt	$1F, $1F, $1F, $1F
000119B6 =0000001F                M spar1	=	op1
000119B6 =0000001F                M spar2	=	op2
000119B6 =0000001F                M spar3	=	op3
000119B6 =0000001F                M spar4	=	op4
000119B6                            	spAmpMod	$00, $00, $00, $00
000119B6 =00000000                M spam1	=	op1
000119B6 =00000000                M spam2	=	op2
000119B6 =00000000                M spam3	=	op3
000119B6 =00000000                M spam4	=	op4
000119B6                            	spSustainRt	$07, $07, $0A, $0D
000119B6 =00000007                M spsr1	=	op1
000119B6 =00000007                M spsr2	=	op2
000119B6 =0000000A                M spsr3	=	op3
000119B6 =0000000D                M spsr4	=	op4
000119B6                            	spDecayRt	$00, $00, $0B, $0B
000119B6 =00000000                M spdr1	=	op1
000119B6 =00000000                M spdr2	=	op2
000119B6 =0000000B                M spdr3	=	op3
000119B6 =0000000B                M spdr4	=	op4
000119B6                            	spSustainLv	$01, $01, $00, $00
000119B6 =00000001                M spsl1	=	op1
000119B6 =00000001                M spsl2	=	op2
000119B6 =00000000                M spsl3	=	op3
000119B6 =00000000                M spsl4	=	op4
000119B6                            	spReleaseRt	$0F, $0F, $0F, $0F
000119B6 =0000000F                M sprr1	=	op1
000119B6 =0000000F                M sprr2	=	op2
000119B6 =0000000F                M sprr3	=	op3
000119B6 =0000000F                M sprr4	=	op4
000119B6                            	spSSGEG		$00, $00, $00, $00
000119B6 =00000000                M spss1	=	op1
000119B6 =00000000                M spss2	=	op2
000119B6 =00000000                M spss3	=	op3
000119B6 =00000000                M spss4	=	op4
000119B6                            	spTotalLv2	$23, $23, $00, $00
000119B6 =00000023                M sptl1	=	op1
000119B6 =00000023                M sptl2	=	op2
000119B6 =00000000                M sptl3	=	op3
000119B6 =00000000                M sptl4	=	op4
000119B6 04                       M 	dc.b	(spfe<<3)+spal
000119B7 3772 7749                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000119BB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000119BF 070A 070D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000119C3 000B 000B                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119C7 1F0F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119CB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119CF 2300 2300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000119D3 4E41 54                  M 	dc.b	'NAT'
000119D6                            
000119D6                            	; Patch $04
000119D6                            	; $3C
000119D6                            	; $0F, $01, $03, $01,	$1F, $1F, $1F, $1F
000119D6                            	; $19, $12, $19, $0E,	$05, $12, $00, $0F
000119D6                            	; $0F, $7F, $FF, $FF,	$00, $00, $00, $00
000119D6                            	spAlgorithm	$04
000119D6 =00000005                M spatnum	=	spatnum+1
000119D6 =00000004                M spal	=	val
000119D6                            	spFeedback	$07
000119D6 =00000007                M spfe	=	val
000119D6                            	spDetune	$00, $00, $00, $00
000119D6 =00000000                M spde1	=	op1
000119D6 =00000000                M spde2	=	op2
000119D6 =00000000                M spde3	=	op3
000119D6 =00000000                M spde4	=	op4
000119D6                            	spMultiple	$0F, $03, $01, $01
000119D6 =0000000F                M spmu1	=	op1
000119D6 =00000003                M spmu2	=	op2
000119D6 =00000001                M spmu3	=	op3
000119D6 =00000001                M spmu4	=	op4
000119D6                            	spRateScale	$00, $00, $00, $00
000119D6 =00000000                M sprs1	=	op1
000119D6 =00000000                M sprs2	=	op2
000119D6 =00000000                M sprs3	=	op3
000119D6 =00000000                M sprs4	=	op4
000119D6                            	spAttackRt	$1F, $1F, $1F, $1F
000119D6 =0000001F                M spar1	=	op1
000119D6 =0000001F                M spar2	=	op2
000119D6 =0000001F                M spar3	=	op3
000119D6 =0000001F                M spar4	=	op4
000119D6                            	spAmpMod	$00, $00, $00, $00
000119D6 =00000000                M spam1	=	op1
000119D6 =00000000                M spam2	=	op2
000119D6 =00000000                M spam3	=	op3
000119D6 =00000000                M spam4	=	op4
000119D6                            	spSustainRt	$19, $19, $12, $0E
000119D6 =00000019                M spsr1	=	op1
000119D6 =00000019                M spsr2	=	op2
000119D6 =00000012                M spsr3	=	op3
000119D6 =0000000E                M spsr4	=	op4
000119D6                            	spDecayRt	$05, $00, $12, $0F
000119D6 =00000005                M spdr1	=	op1
000119D6 =00000000                M spdr2	=	op2
000119D6 =00000012                M spdr3	=	op3
000119D6 =0000000F                M spdr4	=	op4
000119D6                            	spSustainLv	$00, $0F, $07, $0F
000119D6 =00000000                M spsl1	=	op1
000119D6 =0000000F                M spsl2	=	op2
000119D6 =00000007                M spsl3	=	op3
000119D6 =0000000F                M spsl4	=	op4
000119D6                            	spReleaseRt	$0F, $0F, $0F, $0F
000119D6 =0000000F                M sprr1	=	op1
000119D6 =0000000F                M sprr2	=	op2
000119D6 =0000000F                M sprr3	=	op3
000119D6 =0000000F                M sprr4	=	op4
000119D6                            	spSSGEG		$00, $00, $00, $00
000119D6 =00000000                M spss1	=	op1
000119D6 =00000000                M spss2	=	op2
000119D6 =00000000                M spss3	=	op3
000119D6 =00000000                M spss4	=	op4
000119D6                            	spTotalLv2	$00, $00, $00, $00
000119D6 =00000000                M sptl1	=	op1
000119D6 =00000000                M sptl2	=	op2
000119D6 =00000000                M sptl3	=	op3
000119D6 =00000000                M sptl4	=	op4
000119D6 3C                       M 	dc.b	(spfe<<3)+spal
000119D7 0F01 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000119DB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000119DF 1912 190E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000119E3 0512 000F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119E7 0F7F FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119EB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119EF 0000 0000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000119F3 4E41 54                  M 	dc.b	'NAT'
000119F6                            
000119F6                            	; Patch $05
000119F6                            	; $30
000119F6                            	; $30, $30, $30, $30,	$9E, $A8, $AC, $DC
000119F6                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
000119F6                            	; $BF, $BF, $BF, $BF,	$04, $2C, $14, $00
000119F6                            	spAlgorithm	$00
000119F6 =00000006                M spatnum	=	spatnum+1
000119F6 =00000000                M spal	=	val
000119F6                            	spFeedback	$06
000119F6 =00000006                M spfe	=	val
000119F6                            	spDetune	$03, $03, $03, $03
000119F6 =00000003                M spde1	=	op1
000119F6 =00000003                M spde2	=	op2
000119F6 =00000003                M spde3	=	op3
000119F6 =00000003                M spde4	=	op4
000119F6                            	spMultiple	$00, $00, $00, $00
000119F6 =00000000                M spmu1	=	op1
000119F6 =00000000                M spmu2	=	op2
000119F6 =00000000                M spmu3	=	op3
000119F6 =00000000                M spmu4	=	op4
000119F6                            	spRateScale	$02, $02, $02, $03
000119F6 =00000002                M sprs1	=	op1
000119F6 =00000002                M sprs2	=	op2
000119F6 =00000002                M sprs3	=	op3
000119F6 =00000003                M sprs4	=	op4
000119F6                            	spAttackRt	$1E, $0C, $08, $1C
000119F6 =0000001E                M spar1	=	op1
000119F6 =0000000C                M spar2	=	op2
000119F6 =00000008                M spar3	=	op3
000119F6 =0000001C                M spar4	=	op4
000119F6                            	spAmpMod	$00, $00, $00, $00
000119F6 =00000000                M spam1	=	op1
000119F6 =00000000                M spam2	=	op2
000119F6 =00000000                M spam3	=	op3
000119F6 =00000000                M spam4	=	op4
000119F6                            	spSustainRt	$0E, $04, $0A, $05
000119F6 =0000000E                M spsr1	=	op1
000119F6 =00000004                M spsr2	=	op2
000119F6 =0000000A                M spsr3	=	op3
000119F6 =00000005                M spsr4	=	op4
000119F6                            	spDecayRt	$08, $08, $08, $08
000119F6 =00000008                M spdr1	=	op1
000119F6 =00000008                M spdr2	=	op2
000119F6 =00000008                M spdr3	=	op3
000119F6 =00000008                M spdr4	=	op4
000119F6                            	spSustainLv	$0B, $0B, $0B, $0B
000119F6 =0000000B                M spsl1	=	op1
000119F6 =0000000B                M spsl2	=	op2
000119F6 =0000000B                M spsl3	=	op3
000119F6 =0000000B                M spsl4	=	op4
000119F6                            	spReleaseRt	$0F, $0F, $0F, $0F
000119F6 =0000000F                M sprr1	=	op1
000119F6 =0000000F                M sprr2	=	op2
000119F6 =0000000F                M sprr3	=	op3
000119F6 =0000000F                M sprr4	=	op4
000119F6                            	spSSGEG		$00, $00, $00, $00
000119F6 =00000000                M spss1	=	op1
000119F6 =00000000                M spss2	=	op2
000119F6 =00000000                M spss3	=	op3
000119F6 =00000000                M spss4	=	op4
000119F6                            	spTotalLv2	$04, $14, $2C, $00
000119F6 =00000004                M sptl1	=	op1
000119F6 =00000014                M sptl2	=	op2
000119F6 =0000002C                M sptl3	=	op3
000119F6 =00000000                M sptl4	=	op4
000119F6 30                       M 	dc.b	(spfe<<3)+spal
000119F7 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000119FB 9E88 8CDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000119FF 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A03 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A07 BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A0B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A0F 042C 1400                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A13 4E41 54                  M 	dc.b	'NAT'
00011A16                            
00011A16                            	; Patch $06
00011A16                            	; $20
00011A16                            	; $36, $35, $30, $31,	$DF, $DF, $9F, $9F
00011A16                            	; $07, $06, $09, $06,	$07, $06, $06, $08
00011A16                            	; $2F, $1F, $1F, $FF,	$16, $30, $13, $00
00011A16                            	spAlgorithm	$00
00011A16 =00000007                M spatnum	=	spatnum+1
00011A16 =00000000                M spal	=	val
00011A16                            	spFeedback	$04
00011A16 =00000004                M spfe	=	val
00011A16                            	spDetune	$03, $03, $03, $03
00011A16 =00000003                M spde1	=	op1
00011A16 =00000003                M spde2	=	op2
00011A16 =00000003                M spde3	=	op3
00011A16 =00000003                M spde4	=	op4
00011A16                            	spMultiple	$06, $00, $05, $01
00011A16 =00000006                M spmu1	=	op1
00011A16 =00000000                M spmu2	=	op2
00011A16 =00000005                M spmu3	=	op3
00011A16 =00000001                M spmu4	=	op4
00011A16                            	spRateScale	$03, $02, $03, $02
00011A16 =00000003                M sprs1	=	op1
00011A16 =00000002                M sprs2	=	op2
00011A16 =00000003                M sprs3	=	op3
00011A16 =00000002                M sprs4	=	op4
00011A16                            	spAttackRt	$1F, $1F, $1F, $1F
00011A16 =0000001F                M spar1	=	op1
00011A16 =0000001F                M spar2	=	op2
00011A16 =0000001F                M spar3	=	op3
00011A16 =0000001F                M spar4	=	op4
00011A16                            	spAmpMod	$00, $00, $00, $00
00011A16 =00000000                M spam1	=	op1
00011A16 =00000000                M spam2	=	op2
00011A16 =00000000                M spam3	=	op3
00011A16 =00000000                M spam4	=	op4
00011A16                            	spSustainRt	$07, $09, $06, $06
00011A16 =00000007                M spsr1	=	op1
00011A16 =00000009                M spsr2	=	op2
00011A16 =00000006                M spsr3	=	op3
00011A16 =00000006                M spsr4	=	op4
00011A16                            	spDecayRt	$07, $06, $06, $08
00011A16 =00000007                M spdr1	=	op1
00011A16 =00000006                M spdr2	=	op2
00011A16 =00000006                M spdr3	=	op3
00011A16 =00000008                M spdr4	=	op4
00011A16                            	spSustainLv	$02, $01, $01, $0F
00011A16 =00000002                M spsl1	=	op1
00011A16 =00000001                M spsl2	=	op2
00011A16 =00000001                M spsl3	=	op3
00011A16 =0000000F                M spsl4	=	op4
00011A16                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A16 =0000000F                M sprr1	=	op1
00011A16 =0000000F                M sprr2	=	op2
00011A16 =0000000F                M sprr3	=	op3
00011A16 =0000000F                M sprr4	=	op4
00011A16                            	spSSGEG		$00, $00, $00, $00
00011A16 =00000000                M spss1	=	op1
00011A16 =00000000                M spss2	=	op2
00011A16 =00000000                M spss3	=	op3
00011A16 =00000000                M spss4	=	op4
00011A16                            	spTotalLv2	$16, $13, $30, $00
00011A16 =00000016                M sptl1	=	op1
00011A16 =00000013                M sptl2	=	op2
00011A16 =00000030                M sptl3	=	op3
00011A16 =00000000                M sptl4	=	op4
00011A16 20                       M 	dc.b	(spfe<<3)+spal
00011A17 3635 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A1B DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A1F 0706 0906                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A23 0706 0608                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A27 2F1F 1FFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A2B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A2F 1630 1300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A33 4E41 54                  M 	dc.b	'NAT'
00011A36                            
00011A36                            	; Patch $07
00011A36                            	; $35
00011A36                            	; $05, $09, $08, $07,	$1E, $0D, $0D, $0E
00011A36                            	; $0C, $15, $03, $06,	$16, $0E, $09, $10
00011A36                            	; $2F, $2F, $1F, $1F,	$15, $12, $12, $00
00011A36                            	spAlgorithm	$05
00011A36 =00000008                M spatnum	=	spatnum+1
00011A36 =00000005                M spal	=	val
00011A36                            	spFeedback	$06
00011A36 =00000006                M spfe	=	val
00011A36                            	spDetune	$00, $00, $00, $00
00011A36 =00000000                M spde1	=	op1
00011A36 =00000000                M spde2	=	op2
00011A36 =00000000                M spde3	=	op3
00011A36 =00000000                M spde4	=	op4
00011A36                            	spMultiple	$05, $08, $09, $07
00011A36 =00000005                M spmu1	=	op1
00011A36 =00000008                M spmu2	=	op2
00011A36 =00000009                M spmu3	=	op3
00011A36 =00000007                M spmu4	=	op4
00011A36                            	spRateScale	$00, $00, $00, $00
00011A36 =00000000                M sprs1	=	op1
00011A36 =00000000                M sprs2	=	op2
00011A36 =00000000                M sprs3	=	op3
00011A36 =00000000                M sprs4	=	op4
00011A36                            	spAttackRt	$1E, $0D, $0D, $0E
00011A36 =0000001E                M spar1	=	op1
00011A36 =0000000D                M spar2	=	op2
00011A36 =0000000D                M spar3	=	op3
00011A36 =0000000E                M spar4	=	op4
00011A36                            	spAmpMod	$00, $00, $00, $00
00011A36 =00000000                M spam1	=	op1
00011A36 =00000000                M spam2	=	op2
00011A36 =00000000                M spam3	=	op3
00011A36 =00000000                M spam4	=	op4
00011A36                            	spSustainRt	$0C, $03, $15, $06
00011A36 =0000000C                M spsr1	=	op1
00011A36 =00000003                M spsr2	=	op2
00011A36 =00000015                M spsr3	=	op3
00011A36 =00000006                M spsr4	=	op4
00011A36                            	spDecayRt	$16, $09, $0E, $10
00011A36 =00000016                M spdr1	=	op1
00011A36 =00000009                M spdr2	=	op2
00011A36 =0000000E                M spdr3	=	op3
00011A36 =00000010                M spdr4	=	op4
00011A36                            	spSustainLv	$02, $01, $02, $01
00011A36 =00000002                M spsl1	=	op1
00011A36 =00000001                M spsl2	=	op2
00011A36 =00000002                M spsl3	=	op3
00011A36 =00000001                M spsl4	=	op4
00011A36                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A36 =0000000F                M sprr1	=	op1
00011A36 =0000000F                M sprr2	=	op2
00011A36 =0000000F                M sprr3	=	op3
00011A36 =0000000F                M sprr4	=	op4
00011A36                            	spSSGEG		$00, $00, $00, $00
00011A36 =00000000                M spss1	=	op1
00011A36 =00000000                M spss2	=	op2
00011A36 =00000000                M spss3	=	op3
00011A36 =00000000                M spss4	=	op4
00011A36                            	spTotalLv2	$15, $12, $12, $00
00011A36 =00000015                M sptl1	=	op1
00011A36 =00000012                M sptl2	=	op2
00011A36 =00000012                M sptl3	=	op3
00011A36 =00000000                M sptl4	=	op4
00011A36 35                       M 	dc.b	(spfe<<3)+spal
00011A37 0509 0807                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A3B 1E0D 0D0E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A3F 0C15 0306                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A43 160E 0910                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A47 2F2F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A4B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A4F 1512 1200                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A53 4E41 54                  M 	dc.b	'NAT'
00011A56                            
00011A56                            	; Patch $08
00011A56                            	; $3E
00011A56                            	; $36, $01, $00, $04,	$59, $D9, $5F, $9C
00011A56                            	; $0F, $04, $0F, $0A,	$02, $02, $05, $05
00011A56                            	; $A9, $AF, $66, $66,	$20, $00, $0A, $00
00011A56                            	spAlgorithm	$06
00011A56 =00000009                M spatnum	=	spatnum+1
00011A56 =00000006                M spal	=	val
00011A56                            	spFeedback	$07
00011A56 =00000007                M spfe	=	val
00011A56                            	spDetune	$03, $00, $00, $00
00011A56 =00000003                M spde1	=	op1
00011A56 =00000000                M spde2	=	op2
00011A56 =00000000                M spde3	=	op3
00011A56 =00000000                M spde4	=	op4
00011A56                            	spMultiple	$06, $00, $01, $04
00011A56 =00000006                M spmu1	=	op1
00011A56 =00000000                M spmu2	=	op2
00011A56 =00000001                M spmu3	=	op3
00011A56 =00000004                M spmu4	=	op4
00011A56                            	spRateScale	$01, $01, $03, $02
00011A56 =00000001                M sprs1	=	op1
00011A56 =00000001                M sprs2	=	op2
00011A56 =00000003                M sprs3	=	op3
00011A56 =00000002                M sprs4	=	op4
00011A56                            	spAttackRt	$19, $1F, $19, $1C
00011A56 =00000019                M spar1	=	op1
00011A56 =0000001F                M spar2	=	op2
00011A56 =00000019                M spar3	=	op3
00011A56 =0000001C                M spar4	=	op4
00011A56                            	spAmpMod	$00, $00, $00, $00
00011A56 =00000000                M spam1	=	op1
00011A56 =00000000                M spam2	=	op2
00011A56 =00000000                M spam3	=	op3
00011A56 =00000000                M spam4	=	op4
00011A56                            	spSustainRt	$0F, $0F, $04, $0A
00011A56 =0000000F                M spsr1	=	op1
00011A56 =0000000F                M spsr2	=	op2
00011A56 =00000004                M spsr3	=	op3
00011A56 =0000000A                M spsr4	=	op4
00011A56                            	spDecayRt	$02, $05, $02, $05
00011A56 =00000002                M spdr1	=	op1
00011A56 =00000005                M spdr2	=	op2
00011A56 =00000002                M spdr3	=	op3
00011A56 =00000005                M spdr4	=	op4
00011A56                            	spSustainLv	$0A, $06, $0A, $06
00011A56 =0000000A                M spsl1	=	op1
00011A56 =00000006                M spsl2	=	op2
00011A56 =0000000A                M spsl3	=	op3
00011A56 =00000006                M spsl4	=	op4
00011A56                            	spReleaseRt	$09, $06, $0F, $06
00011A56 =00000009                M sprr1	=	op1
00011A56 =00000006                M sprr2	=	op2
00011A56 =0000000F                M sprr3	=	op3
00011A56 =00000006                M sprr4	=	op4
00011A56                            	spSSGEG		$00, $00, $00, $00
00011A56 =00000000                M spss1	=	op1
00011A56 =00000000                M spss2	=	op2
00011A56 =00000000                M spss3	=	op3
00011A56 =00000000                M spss4	=	op4
00011A56                            	spTotalLv2	$20, $0A, $00, $00
00011A56 =00000020                M sptl1	=	op1
00011A56 =0000000A                M sptl2	=	op2
00011A56 =00000000                M sptl3	=	op3
00011A56 =00000000                M sptl4	=	op4
00011A56 3E                       M 	dc.b	(spfe<<3)+spal
00011A57 3601 0004                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A5B 59D9 5F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A5F 0F04 0F0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A63 0202 0505                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A67 A9AF 6666                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A6B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A6F 2000 0A00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A73 4E41 54                  M 	dc.b	'NAT'
00011A76                            
00011A76                            	; Patch $09
00011A76                            	; $3A
00011A76                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011A76                            	; $05, $18, $05, $10,	$0B, $1F, $10, $10
00011A76                            	; $1F, $2F, $4F, $2F,	$0D, $07, $04, $00
00011A76                            	spAlgorithm	$02
00011A76 =0000000A                M spatnum	=	spatnum+1
00011A76 =00000002                M spal	=	val
00011A76                            	spFeedback	$07
00011A76 =00000007                M spfe	=	val
00011A76                            	spDetune	$02, $01, $03, $03
00011A76 =00000002                M spde1	=	op1
00011A76 =00000001                M spde2	=	op2
00011A76 =00000003                M spde3	=	op3
00011A76 =00000003                M spde4	=	op4
00011A76                            	spMultiple	$01, $00, $00, $02
00011A76 =00000001                M spmu1	=	op1
00011A76 =00000000                M spmu2	=	op2
00011A76 =00000000                M spmu3	=	op3
00011A76 =00000002                M spmu4	=	op4
00011A76                            	spRateScale	$00, $00, $00, $00
00011A76 =00000000                M sprs1	=	op1
00011A76 =00000000                M sprs2	=	op2
00011A76 =00000000                M sprs3	=	op3
00011A76 =00000000                M sprs4	=	op4
00011A76                            	spAttackRt	$1F, $1F, $1F, $1F
00011A76 =0000001F                M spar1	=	op1
00011A76 =0000001F                M spar2	=	op2
00011A76 =0000001F                M spar3	=	op3
00011A76 =0000001F                M spar4	=	op4
00011A76                            	spAmpMod	$00, $00, $00, $00
00011A76 =00000000                M spam1	=	op1
00011A76 =00000000                M spam2	=	op2
00011A76 =00000000                M spam3	=	op3
00011A76 =00000000                M spam4	=	op4
00011A76                            	spSustainRt	$05, $05, $18, $10
00011A76 =00000005                M spsr1	=	op1
00011A76 =00000005                M spsr2	=	op2
00011A76 =00000018                M spsr3	=	op3
00011A76 =00000010                M spsr4	=	op4
00011A76                            	spDecayRt	$0B, $10, $1F, $10
00011A76 =0000000B                M spdr1	=	op1
00011A76 =00000010                M spdr2	=	op2
00011A76 =0000001F                M spdr3	=	op3
00011A76 =00000010                M spdr4	=	op4
00011A76                            	spSustainLv	$01, $04, $02, $02
00011A76 =00000001                M spsl1	=	op1
00011A76 =00000004                M spsl2	=	op2
00011A76 =00000002                M spsl3	=	op3
00011A76 =00000002                M spsl4	=	op4
00011A76                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A76 =0000000F                M sprr1	=	op1
00011A76 =0000000F                M sprr2	=	op2
00011A76 =0000000F                M sprr3	=	op3
00011A76 =0000000F                M sprr4	=	op4
00011A76                            	spSSGEG		$00, $00, $00, $00
00011A76 =00000000                M spss1	=	op1
00011A76 =00000000                M spss2	=	op2
00011A76 =00000000                M spss3	=	op3
00011A76 =00000000                M spss4	=	op4
00011A76                            	spTotalLv2	$0D, $04, $07, $00
00011A76 =0000000D                M sptl1	=	op1
00011A76 =00000004                M sptl2	=	op2
00011A76 =00000007                M sptl3	=	op3
00011A76 =00000000                M sptl4	=	op4
00011A76 3A                       M 	dc.b	(spfe<<3)+spal
00011A77 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A7B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A7F 0518 0510                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A83 0B1F 1010                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A87 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A8B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A8F 0D07 0400                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A93 4E41 54                  M 	dc.b	'NAT'
00011A96                            
00011A96                            	; Patch $0A
00011A96                            	; $3C
00011A96                            	; $00, $44, $02, $02, 	$1F, $1F, $1F, $15
00011A96                            	; $00, $1F, $00, $00,	$00, $00, $00, $00
00011A96                            	; $0F, $0F, $0F, $0F, 	$0D, $80, $28, $80
00011A96                            	spAlgorithm	$04
00011A96 =0000000B                M spatnum	=	spatnum+1
00011A96 =00000004                M spal	=	val
00011A96                            	spFeedback	$07
00011A96 =00000007                M spfe	=	val
00011A96                            	spDetune	$00, $00, $04, $00
00011A96 =00000000                M spde1	=	op1
00011A96 =00000000                M spde2	=	op2
00011A96 =00000004                M spde3	=	op3
00011A96 =00000000                M spde4	=	op4
00011A96                            	spMultiple	$00, $02, $04, $02
00011A96 =00000000                M spmu1	=	op1
00011A96 =00000002                M spmu2	=	op2
00011A96 =00000004                M spmu3	=	op3
00011A96 =00000002                M spmu4	=	op4
00011A96                            	spRateScale	$00, $00, $00, $00
00011A96 =00000000                M sprs1	=	op1
00011A96 =00000000                M sprs2	=	op2
00011A96 =00000000                M sprs3	=	op3
00011A96 =00000000                M sprs4	=	op4
00011A96                            	spAttackRt	$1F, $1F, $1F, $15
00011A96 =0000001F                M spar1	=	op1
00011A96 =0000001F                M spar2	=	op2
00011A96 =0000001F                M spar3	=	op3
00011A96 =00000015                M spar4	=	op4
00011A96                            	spAmpMod	$00, $00, $00, $00
00011A96 =00000000                M spam1	=	op1
00011A96 =00000000                M spam2	=	op2
00011A96 =00000000                M spam3	=	op3
00011A96 =00000000                M spam4	=	op4
00011A96                            	spSustainRt	$00, $00, $1F, $00
00011A96 =00000000                M spsr1	=	op1
00011A96 =00000000                M spsr2	=	op2
00011A96 =0000001F                M spsr3	=	op3
00011A96 =00000000                M spsr4	=	op4
00011A96                            	spDecayRt	$00, $00, $00, $00
00011A96 =00000000                M spdr1	=	op1
00011A96 =00000000                M spdr2	=	op2
00011A96 =00000000                M spdr3	=	op3
00011A96 =00000000                M spdr4	=	op4
00011A96                            	spSustainLv	$00, $00, $00, $00
00011A96 =00000000                M spsl1	=	op1
00011A96 =00000000                M spsl2	=	op2
00011A96 =00000000                M spsl3	=	op3
00011A96 =00000000                M spsl4	=	op4
00011A96                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A96 =0000000F                M sprr1	=	op1
00011A96 =0000000F                M sprr2	=	op2
00011A96 =0000000F                M sprr3	=	op3
00011A96 =0000000F                M sprr4	=	op4
00011A96                            	spSSGEG		$00, $00, $00, $00
00011A96 =00000000                M spss1	=	op1
00011A96 =00000000                M spss2	=	op2
00011A96 =00000000                M spss3	=	op3
00011A96 =00000000                M spss4	=	op4
00011A96                            	spTotalLv2	$0D, $28, $80, $80
00011A96 =0000000D                M sptl1	=	op1
00011A96 =00000028                M sptl2	=	op2
00011A96 =00000080                M sptl3	=	op3
00011A96 =00000080                M sptl4	=	op4
00011A96 3C                       M 	dc.b	(spfe<<3)+spal
00011A97 0044 0202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A9B 1F1F 1F15                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A9F 001F 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011AA3 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011AA7 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011AAB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011AAF 0D80 2880                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011AB3 4E41 54                  M 	dc.b	'NAT'
00011AB6                            
00011AB6                            	; Patch $0B
00011AB6                            	; $3A
00011AB6                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011AB6                            	; $05, $18, $09, $02,	$06, $0F, $06, $02
00011AB6                            	; $1F, $2F, $4F, $2F,	$0F, $1A, $0E, $00
00011AB6                            	spAlgorithm	$02
00011AB6 =0000000C                M spatnum	=	spatnum+1
00011AB6 =00000002                M spal	=	val
00011AB6                            	spFeedback	$07
00011AB6 =00000007                M spfe	=	val
00011AB6                            	spDetune	$02, $01, $03, $03
00011AB6 =00000002                M spde1	=	op1
00011AB6 =00000001                M spde2	=	op2
00011AB6 =00000003                M spde3	=	op3
00011AB6 =00000003                M spde4	=	op4
00011AB6                            	spMultiple	$01, $00, $00, $02
00011AB6 =00000001                M spmu1	=	op1
00011AB6 =00000000                M spmu2	=	op2
00011AB6 =00000000                M spmu3	=	op3
00011AB6 =00000002                M spmu4	=	op4
00011AB6                            	spRateScale	$00, $00, $00, $00
00011AB6 =00000000                M sprs1	=	op1
00011AB6 =00000000                M sprs2	=	op2
00011AB6 =00000000                M sprs3	=	op3
00011AB6 =00000000                M sprs4	=	op4
00011AB6                            	spAttackRt	$1F, $1F, $1F, $1F
00011AB6 =0000001F                M spar1	=	op1
00011AB6 =0000001F                M spar2	=	op2
00011AB6 =0000001F                M spar3	=	op3
00011AB6 =0000001F                M spar4	=	op4
00011AB6                            	spAmpMod	$00, $00, $00, $00
00011AB6 =00000000                M spam1	=	op1
00011AB6 =00000000                M spam2	=	op2
00011AB6 =00000000                M spam3	=	op3
00011AB6 =00000000                M spam4	=	op4
00011AB6                            	spSustainRt	$05, $09, $18, $02
00011AB6 =00000005                M spsr1	=	op1
00011AB6 =00000009                M spsr2	=	op2
00011AB6 =00000018                M spsr3	=	op3
00011AB6 =00000002                M spsr4	=	op4
00011AB6                            	spDecayRt	$06, $06, $0F, $02
00011AB6 =00000006                M spdr1	=	op1
00011AB6 =00000006                M spdr2	=	op2
00011AB6 =0000000F                M spdr3	=	op3
00011AB6 =00000002                M spdr4	=	op4
00011AB6                            	spSustainLv	$01, $04, $02, $02
00011AB6 =00000001                M spsl1	=	op1
00011AB6 =00000004                M spsl2	=	op2
00011AB6 =00000002                M spsl3	=	op3
00011AB6 =00000002                M spsl4	=	op4
00011AB6                            	spReleaseRt	$0F, $0F, $0F, $0F
00011AB6 =0000000F                M sprr1	=	op1
00011AB6 =0000000F                M sprr2	=	op2
00011AB6 =0000000F                M sprr3	=	op3
00011AB6 =0000000F                M sprr4	=	op4
00011AB6                            	spSSGEG		$00, $00, $00, $00
00011AB6 =00000000                M spss1	=	op1
00011AB6 =00000000                M spss2	=	op2
00011AB6 =00000000                M spss3	=	op3
00011AB6 =00000000                M spss4	=	op4
00011AB6                            	spTotalLv2	$0F, $0E, $1A, $00
00011AB6 =0000000F                M sptl1	=	op1
00011AB6 =0000000E                M sptl2	=	op2
00011AB6 =0000001A                M sptl3	=	op3
00011AB6 =00000000                M sptl4	=	op4
00011AB6 3A                       M 	dc.b	(spfe<<3)+spal
00011AB7 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011ABB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011ABF 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011AC3 060F 0602                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011AC7 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011ACB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011ACF 0F1A 0E00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011AD3 4E41 54                  M 	dc.b	'NAT'
00011AD6                            
00011AD6                            	; Patch $0C
00011AD6                            	; $FD
00011AD6                            	; $09, $03, $00, $00, 	$1F, $1F, $1F, $1F
00011AD6                            	; $10, $0C, $0C, $0C,	$0B, $1F, $10, $05
00011AD6                            	; $1F, $2F, $4F, $2F, 	$09, $80, $8E, $88
00011AD6                            	spAlgorithm	$05
00011AD6 =0000000D                M spatnum	=	spatnum+1
00011AD6 =00000005                M spal	=	val
00011AD6                            	spFeedback	$07
00011AD6 =00000007                M spfe	=	val
00011AD6                            	spDetune	$00, $00, $00, $00
00011AD6 =00000000                M spde1	=	op1
00011AD6 =00000000                M spde2	=	op2
00011AD6 =00000000                M spde3	=	op3
00011AD6 =00000000                M spde4	=	op4
00011AD6                            	spMultiple	$09, $00, $03, $00
00011AD6 =00000009                M spmu1	=	op1
00011AD6 =00000000                M spmu2	=	op2
00011AD6 =00000003                M spmu3	=	op3
00011AD6 =00000000                M spmu4	=	op4
00011AD6                            	spRateScale	$00, $00, $00, $00
00011AD6 =00000000                M sprs1	=	op1
00011AD6 =00000000                M sprs2	=	op2
00011AD6 =00000000                M sprs3	=	op3
00011AD6 =00000000                M sprs4	=	op4
00011AD6                            	spAttackRt	$1F, $1F, $1F, $1F
00011AD6 =0000001F                M spar1	=	op1
00011AD6 =0000001F                M spar2	=	op2
00011AD6 =0000001F                M spar3	=	op3
00011AD6 =0000001F                M spar4	=	op4
00011AD6                            	spAmpMod	$00, $00, $00, $00
00011AD6 =00000000                M spam1	=	op1
00011AD6 =00000000                M spam2	=	op2
00011AD6 =00000000                M spam3	=	op3
00011AD6 =00000000                M spam4	=	op4
00011AD6                            	spSustainRt	$10, $0C, $0C, $0C
00011AD6 =00000010                M spsr1	=	op1
00011AD6 =0000000C                M spsr2	=	op2
00011AD6 =0000000C                M spsr3	=	op3
00011AD6 =0000000C                M spsr4	=	op4
00011AD6                            	spDecayRt	$0B, $10, $1F, $05
00011AD6 =0000000B                M spdr1	=	op1
00011AD6 =00000010                M spdr2	=	op2
00011AD6 =0000001F                M spdr3	=	op3
00011AD6 =00000005                M spdr4	=	op4
00011AD6                            	spSustainLv	$01, $04, $02, $02
00011AD6 =00000001                M spsl1	=	op1
00011AD6 =00000004                M spsl2	=	op2
00011AD6 =00000002                M spsl3	=	op3
00011AD6 =00000002                M spsl4	=	op4
00011AD6                            	spReleaseRt	$0F, $0F, $0F, $0F
00011AD6 =0000000F                M sprr1	=	op1
00011AD6 =0000000F                M sprr2	=	op2
00011AD6 =0000000F                M sprr3	=	op3
00011AD6 =0000000F                M sprr4	=	op4
00011AD6                            	spSSGEG		$00, $00, $00, $00
00011AD6 =00000000                M spss1	=	op1
00011AD6 =00000000                M spss2	=	op2
00011AD6 =00000000                M spss3	=	op3
00011AD6 =00000000                M spss4	=	op4
00011AD6                            	spTotalLv2	$09, $8E, $80, $88
00011AD6 =00000009                M sptl1	=	op1
00011AD6 =0000008E                M sptl2	=	op2
00011AD6 =00000080                M sptl3	=	op3
00011AD6 =00000088                M sptl4	=	op4
00011AD6 3D                       M 	dc.b	(spfe<<3)+spal
00011AD7 0903 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011ADB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011ADF 100C 0C0C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011AE3 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011AE7 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011AEB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011AEF 0980 8E88                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011AF3 4E41 54                  M 	dc.b	'NAT'
00011AF6                            
00011AF6                            	; Patch $0D
00011AF6                            	; $3C
00011AF6                            	; $05, $01, $0A, $01,	$56, $5C, $5C, $5C
00011AF6                            	; $0E, $11, $11, $11,	$09, $0A, $06, $0A
00011AF6                            	; $4F, $3F, $3F, $3F,	$1F, $00, $2B, $00
00011AF6                            	spAlgorithm	$04
00011AF6 =0000000E                M spatnum	=	spatnum+1
00011AF6 =00000004                M spal	=	val
00011AF6                            	spFeedback	$07
00011AF6 =00000007                M spfe	=	val
00011AF6                            	spDetune	$00, $00, $00, $00
00011AF6 =00000000                M spde1	=	op1
00011AF6 =00000000                M spde2	=	op2
00011AF6 =00000000                M spde3	=	op3
00011AF6 =00000000                M spde4	=	op4
00011AF6                            	spMultiple	$05, $0A, $01, $01
00011AF6 =00000005                M spmu1	=	op1
00011AF6 =0000000A                M spmu2	=	op2
00011AF6 =00000001                M spmu3	=	op3
00011AF6 =00000001                M spmu4	=	op4
00011AF6                            	spRateScale	$01, $01, $01, $01
00011AF6 =00000001                M sprs1	=	op1
00011AF6 =00000001                M sprs2	=	op2
00011AF6 =00000001                M sprs3	=	op3
00011AF6 =00000001                M sprs4	=	op4
00011AF6                            	spAttackRt	$16, $1C, $1C, $1C
00011AF6 =00000016                M spar1	=	op1
00011AF6 =0000001C                M spar2	=	op2
00011AF6 =0000001C                M spar3	=	op3
00011AF6 =0000001C                M spar4	=	op4
00011AF6                            	spAmpMod	$00, $00, $00, $00
00011AF6 =00000000                M spam1	=	op1
00011AF6 =00000000                M spam2	=	op2
00011AF6 =00000000                M spam3	=	op3
00011AF6 =00000000                M spam4	=	op4
00011AF6                            	spSustainRt	$0E, $11, $11, $11
00011AF6 =0000000E                M spsr1	=	op1
00011AF6 =00000011                M spsr2	=	op2
00011AF6 =00000011                M spsr3	=	op3
00011AF6 =00000011                M spsr4	=	op4
00011AF6                            	spDecayRt	$09, $06, $0A, $0A
00011AF6 =00000009                M spdr1	=	op1
00011AF6 =00000006                M spdr2	=	op2
00011AF6 =0000000A                M spdr3	=	op3
00011AF6 =0000000A                M spdr4	=	op4
00011AF6                            	spSustainLv	$04, $03, $03, $03
00011AF6 =00000004                M spsl1	=	op1
00011AF6 =00000003                M spsl2	=	op2
00011AF6 =00000003                M spsl3	=	op3
00011AF6 =00000003                M spsl4	=	op4
00011AF6                            	spReleaseRt	$0F, $0F, $0F, $0F
00011AF6 =0000000F                M sprr1	=	op1
00011AF6 =0000000F                M sprr2	=	op2
00011AF6 =0000000F                M sprr3	=	op3
00011AF6 =0000000F                M sprr4	=	op4
00011AF6                            	spSSGEG		$00, $00, $00, $00
00011AF6 =00000000                M spss1	=	op1
00011AF6 =00000000                M spss2	=	op2
00011AF6 =00000000                M spss3	=	op3
00011AF6 =00000000                M spss4	=	op4
00011AF6                            	spTotalLv2	$1F, $2B, $00, $00
00011AF6 =0000001F                M sptl1	=	op1
00011AF6 =0000002B                M sptl2	=	op2
00011AF6 =00000000                M sptl3	=	op3
00011AF6 =00000000                M sptl4	=	op4
00011AF6 3C                       M 	dc.b	(spfe<<3)+spal
00011AF7 0501 0A01                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011AFB 565C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011AFF 0E11 1111                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B03 090A 060A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B07 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B0B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B0F 1F00 2B00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B13 4E41 54                  M 	dc.b	'NAT'
00011B16                            
00011B16                            	; Patch $0E
00011B16                            	; $05
00011B16                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $1F
00011B16                            	; $12, $0C, $0C, $0C,	$12, $08, $08, $08
00011B16                            	; $1F, $5F, $5F, $5F,	$07, $00, $00, $00
00011B16                            	spAlgorithm	$05
00011B16 =0000000F                M spatnum	=	spatnum+1
00011B16 =00000005                M spal	=	val
00011B16                            	spFeedback	$00
00011B16 =00000000                M spfe	=	val
00011B16                            	spDetune	$00, $00, $00, $00
00011B16 =00000000                M spde1	=	op1
00011B16 =00000000                M spde2	=	op2
00011B16 =00000000                M spde3	=	op3
00011B16 =00000000                M spde4	=	op4
00011B16                            	spMultiple	$00, $00, $00, $00
00011B16 =00000000                M spmu1	=	op1
00011B16 =00000000                M spmu2	=	op2
00011B16 =00000000                M spmu3	=	op3
00011B16 =00000000                M spmu4	=	op4
00011B16                            	spRateScale	$00, $00, $00, $00
00011B16 =00000000                M sprs1	=	op1
00011B16 =00000000                M sprs2	=	op2
00011B16 =00000000                M sprs3	=	op3
00011B16 =00000000                M sprs4	=	op4
00011B16                            	spAttackRt	$1F, $1F, $1F, $1F
00011B16 =0000001F                M spar1	=	op1
00011B16 =0000001F                M spar2	=	op2
00011B16 =0000001F                M spar3	=	op3
00011B16 =0000001F                M spar4	=	op4
00011B16                            	spAmpMod	$00, $00, $00, $00
00011B16 =00000000                M spam1	=	op1
00011B16 =00000000                M spam2	=	op2
00011B16 =00000000                M spam3	=	op3
00011B16 =00000000                M spam4	=	op4
00011B16                            	spSustainRt	$12, $0C, $0C, $0C
00011B16 =00000012                M spsr1	=	op1
00011B16 =0000000C                M spsr2	=	op2
00011B16 =0000000C                M spsr3	=	op3
00011B16 =0000000C                M spsr4	=	op4
00011B16                            	spDecayRt	$12, $08, $08, $08
00011B16 =00000012                M spdr1	=	op1
00011B16 =00000008                M spdr2	=	op2
00011B16 =00000008                M spdr3	=	op3
00011B16 =00000008                M spdr4	=	op4
00011B16                            	spSustainLv	$01, $05, $05, $05
00011B16 =00000001                M spsl1	=	op1
00011B16 =00000005                M spsl2	=	op2
00011B16 =00000005                M spsl3	=	op3
00011B16 =00000005                M spsl4	=	op4
00011B16                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B16 =0000000F                M sprr1	=	op1
00011B16 =0000000F                M sprr2	=	op2
00011B16 =0000000F                M sprr3	=	op3
00011B16 =0000000F                M sprr4	=	op4
00011B16                            	spSSGEG		$00, $00, $00, $00
00011B16 =00000000                M spss1	=	op1
00011B16 =00000000                M spss2	=	op2
00011B16 =00000000                M spss3	=	op3
00011B16 =00000000                M spss4	=	op4
00011B16                            	spTotalLv2	$07, $00, $00, $00
00011B16 =00000007                M sptl1	=	op1
00011B16 =00000000                M sptl2	=	op2
00011B16 =00000000                M sptl3	=	op3
00011B16 =00000000                M sptl4	=	op4
00011B16 05                       M 	dc.b	(spfe<<3)+spal
00011B17 0000 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B1B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B1F 120C 0C0C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B23 1208 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B27 1F5F 5F5F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B2B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B2F 0700 0000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B33 4E41 54                  M 	dc.b	'NAT'
00011B36                            
00011B36                            	; Patch $0F
00011B36                            	; $39
00011B36                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011B36                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011B36                            	; $1F, $2F, $4F, $2F,	$0E, $07, $04, $00
00011B36                            	spAlgorithm	$01
00011B36 =00000010                M spatnum	=	spatnum+1
00011B36 =00000001                M spal	=	val
00011B36                            	spFeedback	$07
00011B36 =00000007                M spfe	=	val
00011B36                            	spDetune	$02, $01, $03, $03
00011B36 =00000002                M spde1	=	op1
00011B36 =00000001                M spde2	=	op2
00011B36 =00000003                M spde3	=	op3
00011B36 =00000003                M spde4	=	op4
00011B36                            	spMultiple	$01, $00, $00, $02
00011B36 =00000001                M spmu1	=	op1
00011B36 =00000000                M spmu2	=	op2
00011B36 =00000000                M spmu3	=	op3
00011B36 =00000002                M spmu4	=	op4
00011B36                            	spRateScale	$00, $00, $00, $00
00011B36 =00000000                M sprs1	=	op1
00011B36 =00000000                M sprs2	=	op2
00011B36 =00000000                M sprs3	=	op3
00011B36 =00000000                M sprs4	=	op4
00011B36                            	spAttackRt	$1F, $1F, $1F, $1F
00011B36 =0000001F                M spar1	=	op1
00011B36 =0000001F                M spar2	=	op2
00011B36 =0000001F                M spar3	=	op3
00011B36 =0000001F                M spar4	=	op4
00011B36                            	spAmpMod	$00, $00, $00, $00
00011B36 =00000000                M spam1	=	op1
00011B36 =00000000                M spam2	=	op2
00011B36 =00000000                M spam3	=	op3
00011B36 =00000000                M spam4	=	op4
00011B36                            	spSustainRt	$05, $09, $18, $02
00011B36 =00000005                M spsr1	=	op1
00011B36 =00000009                M spsr2	=	op2
00011B36 =00000018                M spsr3	=	op3
00011B36 =00000002                M spsr4	=	op4
00011B36                            	spDecayRt	$0B, $10, $1F, $05
00011B36 =0000000B                M spdr1	=	op1
00011B36 =00000010                M spdr2	=	op2
00011B36 =0000001F                M spdr3	=	op3
00011B36 =00000005                M spdr4	=	op4
00011B36                            	spSustainLv	$01, $04, $02, $02
00011B36 =00000001                M spsl1	=	op1
00011B36 =00000004                M spsl2	=	op2
00011B36 =00000002                M spsl3	=	op3
00011B36 =00000002                M spsl4	=	op4
00011B36                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B36 =0000000F                M sprr1	=	op1
00011B36 =0000000F                M sprr2	=	op2
00011B36 =0000000F                M sprr3	=	op3
00011B36 =0000000F                M sprr4	=	op4
00011B36                            	spSSGEG		$00, $00, $00, $00
00011B36 =00000000                M spss1	=	op1
00011B36 =00000000                M spss2	=	op2
00011B36 =00000000                M spss3	=	op3
00011B36 =00000000                M spss4	=	op4
00011B36                            	spTotalLv	$0E, $04, $07, $00
00011B36 =0000000E                M sptl1	=	op1
00011B36 =00000004                M sptl2	=	op2
00011B36 =00000007                M sptl3	=	op3
00011B36 =00000000                M sptl4	=	op4
00011B36 39                       M 	dc.b	(spfe<<3)+spal
00011B37 =00000080                M sptlmask4	set	$80
00011B37 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011B37 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011B37 =00000000                M sptlmask1	set	((spal=7)<<7)
00011B37 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B3B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B3F 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B43 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B47 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B4B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B4F 0E07 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011B53 4E41 54                  M 	dc.b	'NAT'
00011B56                            
00011B56                            	; Patch $10
00011B56                            	; $35
00011B56                            	; $14, $1A, $04, $09,	$0E, $10, $11, $0E
00011B56                            	; $0C, $15, $03, $06,	$16, $0E, $09, $10
00011B56                            	; $2F, $2F, $4F, $4F,	$2F, $12, $12, $80
00011B56                            	spAlgorithm	$05
00011B56 =00000011                M spatnum	=	spatnum+1
00011B56 =00000005                M spal	=	val
00011B56                            	spFeedback	$06
00011B56 =00000006                M spfe	=	val
00011B56                            	spDetune	$01, $00, $01, $00
00011B56 =00000001                M spde1	=	op1
00011B56 =00000000                M spde2	=	op2
00011B56 =00000001                M spde3	=	op3
00011B56 =00000000                M spde4	=	op4
00011B56                            	spMultiple	$04, $04, $0A, $09
00011B56 =00000004                M spmu1	=	op1
00011B56 =00000004                M spmu2	=	op2
00011B56 =0000000A                M spmu3	=	op3
00011B56 =00000009                M spmu4	=	op4
00011B56                            	spRateScale	$00, $00, $00, $00
00011B56 =00000000                M sprs1	=	op1
00011B56 =00000000                M sprs2	=	op2
00011B56 =00000000                M sprs3	=	op3
00011B56 =00000000                M sprs4	=	op4
00011B56                            	spAttackRt	$0E, $11, $10, $0E
00011B56 =0000000E                M spar1	=	op1
00011B56 =00000011                M spar2	=	op2
00011B56 =00000010                M spar3	=	op3
00011B56 =0000000E                M spar4	=	op4
00011B56                            	spAmpMod	$00, $00, $00, $00
00011B56 =00000000                M spam1	=	op1
00011B56 =00000000                M spam2	=	op2
00011B56 =00000000                M spam3	=	op3
00011B56 =00000000                M spam4	=	op4
00011B56                            	spSustainRt	$0C, $03, $15, $06
00011B56 =0000000C                M spsr1	=	op1
00011B56 =00000003                M spsr2	=	op2
00011B56 =00000015                M spsr3	=	op3
00011B56 =00000006                M spsr4	=	op4
00011B56                            	spDecayRt	$16, $09, $0E, $10
00011B56 =00000016                M spdr1	=	op1
00011B56 =00000009                M spdr2	=	op2
00011B56 =0000000E                M spdr3	=	op3
00011B56 =00000010                M spdr4	=	op4
00011B56                            	spSustainLv	$02, $04, $02, $04
00011B56 =00000002                M spsl1	=	op1
00011B56 =00000004                M spsl2	=	op2
00011B56 =00000002                M spsl3	=	op3
00011B56 =00000004                M spsl4	=	op4
00011B56                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B56 =0000000F                M sprr1	=	op1
00011B56 =0000000F                M sprr2	=	op2
00011B56 =0000000F                M sprr3	=	op3
00011B56 =0000000F                M sprr4	=	op4
00011B56                            	spSSGEG		$00, $00, $00, $00
00011B56 =00000000                M spss1	=	op1
00011B56 =00000000                M spss2	=	op2
00011B56 =00000000                M spss3	=	op3
00011B56 =00000000                M spss4	=	op4
00011B56                            	spTotalLv2	$2F, $12, $12, $80
00011B56 =0000002F                M sptl1	=	op1
00011B56 =00000012                M sptl2	=	op2
00011B56 =00000012                M sptl3	=	op3
00011B56 =00000080                M sptl4	=	op4
00011B56 35                       M 	dc.b	(spfe<<3)+spal
00011B57 141A 0409                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B5B 0E10 110E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B5F 0C15 0306                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B63 160E 0910                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B67 2F2F 4F4F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B6B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B6F 2F12 1280                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B73 4E41 54                  M 	dc.b	'NAT'
00011B76                            
00011B76                            	; Patch $11
00011B76                            	; $38
00011B76                            	; $01, $00, $00, $00,	$1F, $1F, $1F, $1F
00011B76                            	; $09, $09, $09, $0B,	$00, $00, $00, $00
00011B76                            	; $FF, $FF, $FF, $FF,	$5C, $22, $27, $80
00011B76                            	spAlgorithm	$00
00011B76 =00000012                M spatnum	=	spatnum+1
00011B76 =00000000                M spal	=	val
00011B76                            	spFeedback	$07
00011B76 =00000007                M spfe	=	val
00011B76                            	spDetune	$00, $00, $00, $00
00011B76 =00000000                M spde1	=	op1
00011B76 =00000000                M spde2	=	op2
00011B76 =00000000                M spde3	=	op3
00011B76 =00000000                M spde4	=	op4
00011B76                            	spMultiple	$01, $00, $00, $00
00011B76 =00000001                M spmu1	=	op1
00011B76 =00000000                M spmu2	=	op2
00011B76 =00000000                M spmu3	=	op3
00011B76 =00000000                M spmu4	=	op4
00011B76                            	spRateScale	$00, $00, $00, $00
00011B76 =00000000                M sprs1	=	op1
00011B76 =00000000                M sprs2	=	op2
00011B76 =00000000                M sprs3	=	op3
00011B76 =00000000                M sprs4	=	op4
00011B76                            	spAttackRt	$1F, $1F, $1F, $1F
00011B76 =0000001F                M spar1	=	op1
00011B76 =0000001F                M spar2	=	op2
00011B76 =0000001F                M spar3	=	op3
00011B76 =0000001F                M spar4	=	op4
00011B76                            	spAmpMod	$00, $00, $00, $00
00011B76 =00000000                M spam1	=	op1
00011B76 =00000000                M spam2	=	op2
00011B76 =00000000                M spam3	=	op3
00011B76 =00000000                M spam4	=	op4
00011B76                            	spSustainRt	$09, $09, $09, $0B
00011B76 =00000009                M spsr1	=	op1
00011B76 =00000009                M spsr2	=	op2
00011B76 =00000009                M spsr3	=	op3
00011B76 =0000000B                M spsr4	=	op4
00011B76                            	spDecayRt	$00, $00, $00, $00
00011B76 =00000000                M spdr1	=	op1
00011B76 =00000000                M spdr2	=	op2
00011B76 =00000000                M spdr3	=	op3
00011B76 =00000000                M spdr4	=	op4
00011B76                            	spSustainLv	$0F, $0F, $0F, $0F
00011B76 =0000000F                M spsl1	=	op1
00011B76 =0000000F                M spsl2	=	op2
00011B76 =0000000F                M spsl3	=	op3
00011B76 =0000000F                M spsl4	=	op4
00011B76                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B76 =0000000F                M sprr1	=	op1
00011B76 =0000000F                M sprr2	=	op2
00011B76 =0000000F                M sprr3	=	op3
00011B76 =0000000F                M sprr4	=	op4
00011B76                            	spSSGEG		$00, $00, $00, $00
00011B76 =00000000                M spss1	=	op1
00011B76 =00000000                M spss2	=	op2
00011B76 =00000000                M spss3	=	op3
00011B76 =00000000                M spss4	=	op4
00011B76                            	spTotalLv2	$5C, $27, $22, $80
00011B76 =0000005C                M sptl1	=	op1
00011B76 =00000027                M sptl2	=	op2
00011B76 =00000022                M sptl3	=	op3
00011B76 =00000080                M sptl4	=	op4
00011B76 38                       M 	dc.b	(spfe<<3)+spal
00011B77 0100 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B7B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B7F 0909 090B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B83 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B87 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B8B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B8F 5C22 2780                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B93 4E41 54                  M 	dc.b	'NAT'
00011B96                            
00011B96                            	; Patch $12
00011B96                            	; $3B
00011B96                            	; $3C, $39, $30, $31,	$DF, $1F, $1F, $DF
00011B96                            	; $04, $05, $04, $01,	$04, $04, $04, $02
00011B96                            	; $FF, $0F, $1F, $AF,	$29, $20, $0F, $00
00011B96                            	spAlgorithm	$03
00011B96 =00000013                M spatnum	=	spatnum+1
00011B96 =00000003                M spal	=	val
00011B96                            	spFeedback	$07
00011B96 =00000007                M spfe	=	val
00011B96                            	spDetune	$03, $03, $03, $03
00011B96 =00000003                M spde1	=	op1
00011B96 =00000003                M spde2	=	op2
00011B96 =00000003                M spde3	=	op3
00011B96 =00000003                M spde4	=	op4
00011B96                            	spMultiple	$0C, $00, $09, $01
00011B96 =0000000C                M spmu1	=	op1
00011B96 =00000000                M spmu2	=	op2
00011B96 =00000009                M spmu3	=	op3
00011B96 =00000001                M spmu4	=	op4
00011B96                            	spRateScale	$03, $00, $00, $03
00011B96 =00000003                M sprs1	=	op1
00011B96 =00000000                M sprs2	=	op2
00011B96 =00000000                M sprs3	=	op3
00011B96 =00000003                M sprs4	=	op4
00011B96                            	spAttackRt	$1F, $1F, $1F, $1F
00011B96 =0000001F                M spar1	=	op1
00011B96 =0000001F                M spar2	=	op2
00011B96 =0000001F                M spar3	=	op3
00011B96 =0000001F                M spar4	=	op4
00011B96                            	spAmpMod	$00, $00, $00, $00
00011B96 =00000000                M spam1	=	op1
00011B96 =00000000                M spam2	=	op2
00011B96 =00000000                M spam3	=	op3
00011B96 =00000000                M spam4	=	op4
00011B96                            	spSustainRt	$04, $04, $05, $01
00011B96 =00000004                M spsr1	=	op1
00011B96 =00000004                M spsr2	=	op2
00011B96 =00000005                M spsr3	=	op3
00011B96 =00000001                M spsr4	=	op4
00011B96                            	spDecayRt	$04, $04, $04, $02
00011B96 =00000004                M spdr1	=	op1
00011B96 =00000004                M spdr2	=	op2
00011B96 =00000004                M spdr3	=	op3
00011B96 =00000002                M spdr4	=	op4
00011B96                            	spSustainLv	$0F, $01, $00, $0A
00011B96 =0000000F                M spsl1	=	op1
00011B96 =00000001                M spsl2	=	op2
00011B96 =00000000                M spsl3	=	op3
00011B96 =0000000A                M spsl4	=	op4
00011B96                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B96 =0000000F                M sprr1	=	op1
00011B96 =0000000F                M sprr2	=	op2
00011B96 =0000000F                M sprr3	=	op3
00011B96 =0000000F                M sprr4	=	op4
00011B96                            	spSSGEG		$00, $00, $00, $00
00011B96 =00000000                M spss1	=	op1
00011B96 =00000000                M spss2	=	op2
00011B96 =00000000                M spss3	=	op3
00011B96 =00000000                M spss4	=	op4
00011B96                            	spTotalLv2	$29, $0F, $20, $00
00011B96 =00000029                M sptl1	=	op1
00011B96 =0000000F                M sptl2	=	op2
00011B96 =00000020                M sptl3	=	op3
00011B96 =00000000                M sptl4	=	op4
00011B96 3B                       M 	dc.b	(spfe<<3)+spal
00011B97 3C39 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B9B DF1F 1FDF                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B9F 0405 0401                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011BA3 0404 0402                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011BA7 FF0F 1FAF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011BAB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011BAF 2920 0F00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011BB3 4E41 54                  M 	dc.b	'NAT'
00011BB6                            
00011BB6                            	; Patch $13
00011BB6                            	; $3A
00011BB6                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011BB6                            	; $05, $18, $09, $02,	$06, $0F, $06, $02
00011BB6                            	; $1F, $2F, $4F, $2F,	$0F, $0E, $0E, $00
00011BB6                            	spAlgorithm	$02
00011BB6 =00000014                M spatnum	=	spatnum+1
00011BB6 =00000002                M spal	=	val
00011BB6                            	spFeedback	$07
00011BB6 =00000007                M spfe	=	val
00011BB6                            	spDetune	$02, $01, $03, $03
00011BB6 =00000002                M spde1	=	op1
00011BB6 =00000001                M spde2	=	op2
00011BB6 =00000003                M spde3	=	op3
00011BB6 =00000003                M spde4	=	op4
00011BB6                            	spMultiple	$01, $00, $00, $02
00011BB6 =00000001                M spmu1	=	op1
00011BB6 =00000000                M spmu2	=	op2
00011BB6 =00000000                M spmu3	=	op3
00011BB6 =00000002                M spmu4	=	op4
00011BB6                            	spRateScale	$00, $00, $00, $00
00011BB6 =00000000                M sprs1	=	op1
00011BB6 =00000000                M sprs2	=	op2
00011BB6 =00000000                M sprs3	=	op3
00011BB6 =00000000                M sprs4	=	op4
00011BB6                            	spAttackRt	$1F, $1F, $1F, $1F
00011BB6 =0000001F                M spar1	=	op1
00011BB6 =0000001F                M spar2	=	op2
00011BB6 =0000001F                M spar3	=	op3
00011BB6 =0000001F                M spar4	=	op4
00011BB6                            	spAmpMod	$00, $00, $00, $00
00011BB6 =00000000                M spam1	=	op1
00011BB6 =00000000                M spam2	=	op2
00011BB6 =00000000                M spam3	=	op3
00011BB6 =00000000                M spam4	=	op4
00011BB6                            	spSustainRt	$05, $09, $18, $02
00011BB6 =00000005                M spsr1	=	op1
00011BB6 =00000009                M spsr2	=	op2
00011BB6 =00000018                M spsr3	=	op3
00011BB6 =00000002                M spsr4	=	op4
00011BB6                            	spDecayRt	$06, $06, $0F, $02
00011BB6 =00000006                M spdr1	=	op1
00011BB6 =00000006                M spdr2	=	op2
00011BB6 =0000000F                M spdr3	=	op3
00011BB6 =00000002                M spdr4	=	op4
00011BB6                            	spSustainLv	$01, $04, $02, $02
00011BB6 =00000001                M spsl1	=	op1
00011BB6 =00000004                M spsl2	=	op2
00011BB6 =00000002                M spsl3	=	op3
00011BB6 =00000002                M spsl4	=	op4
00011BB6                            	spReleaseRt	$0F, $0F, $0F, $0F
00011BB6 =0000000F                M sprr1	=	op1
00011BB6 =0000000F                M sprr2	=	op2
00011BB6 =0000000F                M sprr3	=	op3
00011BB6 =0000000F                M sprr4	=	op4
00011BB6                            	spSSGEG		$00, $00, $00, $00
00011BB6 =00000000                M spss1	=	op1
00011BB6 =00000000                M spss2	=	op2
00011BB6 =00000000                M spss3	=	op3
00011BB6 =00000000                M spss4	=	op4
00011BB6                            	spTotalLv2	$0F, $0E, $0E, $00
00011BB6 =0000000F                M sptl1	=	op1
00011BB6 =0000000E                M sptl2	=	op2
00011BB6 =0000000E                M sptl3	=	op3
00011BB6 =00000000                M sptl4	=	op4
00011BB6 3A                       M 	dc.b	(spfe<<3)+spal
00011BB7 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011BBB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011BBF 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011BC3 060F 0602                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011BC7 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011BCB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011BCF 0F0E 0E00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011BD3 4E41 54                  M 	dc.b	'NAT'
00011BD6                            
00011BD6                            	; Patch $14
00011BD6                            	; $07
00011BD6                            	; $04, $04, $05, $04,	$1F, $1F, $15, $15
00011BD6                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00011BD6                            	; $1F, $1F, $1F, $1F,	$7F, $7F, $80, $80
00011BD6                            	spAlgorithm	$07
00011BD6 =00000015                M spatnum	=	spatnum+1
00011BD6 =00000007                M spal	=	val
00011BD6                            	spFeedback	$00
00011BD6 =00000000                M spfe	=	val
00011BD6                            	spDetune	$00, $00, $00, $00
00011BD6 =00000000                M spde1	=	op1
00011BD6 =00000000                M spde2	=	op2
00011BD6 =00000000                M spde3	=	op3
00011BD6 =00000000                M spde4	=	op4
00011BD6                            	spMultiple	$04, $05, $04, $04
00011BD6 =00000004                M spmu1	=	op1
00011BD6 =00000005                M spmu2	=	op2
00011BD6 =00000004                M spmu3	=	op3
00011BD6 =00000004                M spmu4	=	op4
00011BD6                            	spRateScale	$00, $00, $00, $00
00011BD6 =00000000                M sprs1	=	op1
00011BD6 =00000000                M sprs2	=	op2
00011BD6 =00000000                M sprs3	=	op3
00011BD6 =00000000                M sprs4	=	op4
00011BD6                            	spAttackRt	$1F, $15, $1F, $15
00011BD6 =0000001F                M spar1	=	op1
00011BD6 =00000015                M spar2	=	op2
00011BD6 =0000001F                M spar3	=	op3
00011BD6 =00000015                M spar4	=	op4
00011BD6                            	spAmpMod	$00, $00, $00, $00
00011BD6 =00000000                M spam1	=	op1
00011BD6 =00000000                M spam2	=	op2
00011BD6 =00000000                M spam3	=	op3
00011BD6 =00000000                M spam4	=	op4
00011BD6                            	spSustainRt	$00, $00, $00, $00
00011BD6 =00000000                M spsr1	=	op1
00011BD6 =00000000                M spsr2	=	op2
00011BD6 =00000000                M spsr3	=	op3
00011BD6 =00000000                M spsr4	=	op4
00011BD6                            	spDecayRt	$00, $00, $00, $00
00011BD6 =00000000                M spdr1	=	op1
00011BD6 =00000000                M spdr2	=	op2
00011BD6 =00000000                M spdr3	=	op3
00011BD6 =00000000                M spdr4	=	op4
00011BD6                            	spSustainLv	$01, $01, $01, $01
00011BD6 =00000001                M spsl1	=	op1
00011BD6 =00000001                M spsl2	=	op2
00011BD6 =00000001                M spsl3	=	op3
00011BD6 =00000001                M spsl4	=	op4
00011BD6                            	spReleaseRt	$0F, $0F, $0F, $0F
00011BD6 =0000000F                M sprr1	=	op1
00011BD6 =0000000F                M sprr2	=	op2
00011BD6 =0000000F                M sprr3	=	op3
00011BD6 =0000000F                M sprr4	=	op4
00011BD6                            	spSSGEG		$00, $00, $00, $00
00011BD6 =00000000                M spss1	=	op1
00011BD6 =00000000                M spss2	=	op2
00011BD6 =00000000                M spss3	=	op3
00011BD6 =00000000                M spss4	=	op4
00011BD6                            	spTotalLv2	$7F, $80, $7F, $80
00011BD6 =0000007F                M sptl1	=	op1
00011BD6 =00000080                M sptl2	=	op2
00011BD6 =0000007F                M sptl3	=	op3
00011BD6 =00000080                M sptl4	=	op4
00011BD6 07                       M 	dc.b	(spfe<<3)+spal
00011BD7 0404 0504                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011BDB 1F1F 1515                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011BDF 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011BE3 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011BE7 1F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011BEB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011BEF 7F7F 8080                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011BF3 4E41 54                  M 	dc.b	'NAT'
00011BF6                            
00011BF6                            	; Patch $15
00011BF6                            	; $00
00011BF6                            	; $00, $03, $02, $00,	$D9, $DF, $1F, $1F
00011BF6                            	; $12, $11, $14, $0F,	$0A, $00, $0A, $0D
00011BF6                            	; $FF, $FF, $FF, $FF,	$22, $07, $27, $00
00011BF6                            	spAlgorithm	$00
00011BF6 =00000016                M spatnum	=	spatnum+1
00011BF6 =00000000                M spal	=	val
00011BF6                            	spFeedback	$00
00011BF6 =00000000                M spfe	=	val
00011BF6                            	spDetune	$00, $00, $00, $00
00011BF6 =00000000                M spde1	=	op1
00011BF6 =00000000                M spde2	=	op2
00011BF6 =00000000                M spde3	=	op3
00011BF6 =00000000                M spde4	=	op4
00011BF6                            	spMultiple	$00, $02, $03, $00
00011BF6 =00000000                M spmu1	=	op1
00011BF6 =00000002                M spmu2	=	op2
00011BF6 =00000003                M spmu3	=	op3
00011BF6 =00000000                M spmu4	=	op4
00011BF6                            	spRateScale	$03, $00, $03, $00
00011BF6 =00000003                M sprs1	=	op1
00011BF6 =00000000                M sprs2	=	op2
00011BF6 =00000003                M sprs3	=	op3
00011BF6 =00000000                M sprs4	=	op4
00011BF6                            	spAttackRt	$19, $1F, $1F, $1F
00011BF6 =00000019                M spar1	=	op1
00011BF6 =0000001F                M spar2	=	op2
00011BF6 =0000001F                M spar3	=	op3
00011BF6 =0000001F                M spar4	=	op4
00011BF6                            	spAmpMod	$00, $00, $00, $00
00011BF6 =00000000                M spam1	=	op1
00011BF6 =00000000                M spam2	=	op2
00011BF6 =00000000                M spam3	=	op3
00011BF6 =00000000                M spam4	=	op4
00011BF6                            	spSustainRt	$12, $14, $11, $0F
00011BF6 =00000012                M spsr1	=	op1
00011BF6 =00000014                M spsr2	=	op2
00011BF6 =00000011                M spsr3	=	op3
00011BF6 =0000000F                M spsr4	=	op4
00011BF6                            	spDecayRt	$0A, $0A, $00, $0D
00011BF6 =0000000A                M spdr1	=	op1
00011BF6 =0000000A                M spdr2	=	op2
00011BF6 =00000000                M spdr3	=	op3
00011BF6 =0000000D                M spdr4	=	op4
00011BF6                            	spSustainLv	$0F, $0F, $0F, $0F
00011BF6 =0000000F                M spsl1	=	op1
00011BF6 =0000000F                M spsl2	=	op2
00011BF6 =0000000F                M spsl3	=	op3
00011BF6 =0000000F                M spsl4	=	op4
00011BF6                            	spReleaseRt	$0F, $0F, $0F, $0F
00011BF6 =0000000F                M sprr1	=	op1
00011BF6 =0000000F                M sprr2	=	op2
00011BF6 =0000000F                M sprr3	=	op3
00011BF6 =0000000F                M sprr4	=	op4
00011BF6                            	spSSGEG		$00, $00, $00, $00
00011BF6 =00000000                M spss1	=	op1
00011BF6 =00000000                M spss2	=	op2
00011BF6 =00000000                M spss3	=	op3
00011BF6 =00000000                M spss4	=	op4
00011BF6                            	spTotalLv2	$22, $27, $07, $00
00011BF6 =00000022                M sptl1	=	op1
00011BF6 =00000027                M sptl2	=	op2
00011BF6 =00000007                M sptl3	=	op3
00011BF6 =00000000                M sptl4	=	op4
00011BF6 00                       M 	dc.b	(spfe<<3)+spal
00011BF7 0003 0200                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011BFB D9DF 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011BFF 1211 140F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C03 0A00 0A0D                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C07 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C0B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C0F 2207 2700                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C13 4E41 54                  M 	dc.b	'NAT'
00011C16                            
00011C16                            	; Patch $16
00011C16                            	; $20
00011C16                            	; $36, $35, $30, $31,	$41, $49, $3B, $4B
00011C16                            	; $09, $06, $09, $08,	$01, $03, $02, $A9
00011C16                            	; $0F, $0F, $0F, $0F,	$29, $27, $23, $00
00011C16                            	spAlgorithm	$00
00011C16 =00000017                M spatnum	=	spatnum+1
00011C16 =00000000                M spal	=	val
00011C16                            	spFeedback	$04
00011C16 =00000004                M spfe	=	val
00011C16                            	spDetune	$03, $03, $03, $03
00011C16 =00000003                M spde1	=	op1
00011C16 =00000003                M spde2	=	op2
00011C16 =00000003                M spde3	=	op3
00011C16 =00000003                M spde4	=	op4
00011C16                            	spMultiple	$06, $00, $05, $01
00011C16 =00000006                M spmu1	=	op1
00011C16 =00000000                M spmu2	=	op2
00011C16 =00000005                M spmu3	=	op3
00011C16 =00000001                M spmu4	=	op4
00011C16                            	spRateScale	$01, $00, $01, $01
00011C16 =00000001                M sprs1	=	op1
00011C16 =00000000                M sprs2	=	op2
00011C16 =00000001                M sprs3	=	op3
00011C16 =00000001                M sprs4	=	op4
00011C16                            	spAttackRt	$01, $1B, $09, $0B
00011C16 =00000001                M spar1	=	op1
00011C16 =0000001B                M spar2	=	op2
00011C16 =00000009                M spar3	=	op3
00011C16 =0000000B                M spar4	=	op4
00011C16                            	spAmpMod	$00, $00, $00, $00
00011C16 =00000000                M spam1	=	op1
00011C16 =00000000                M spam2	=	op2
00011C16 =00000000                M spam3	=	op3
00011C16 =00000000                M spam4	=	op4
00011C16                            	spSustainRt	$09, $09, $06, $08
00011C16 =00000009                M spsr1	=	op1
00011C16 =00000009                M spsr2	=	op2
00011C16 =00000006                M spsr3	=	op3
00011C16 =00000008                M spsr4	=	op4
00011C16                            	spDecayRt	$01, $02, $03, $A9
00011C16 =00000001                M spdr1	=	op1
00011C16 =00000002                M spdr2	=	op2
00011C16 =00000003                M spdr3	=	op3
00011C16 =000000A9                M spdr4	=	op4
00011C16                            	spSustainLv	$00, $00, $00, $00
00011C16 =00000000                M spsl1	=	op1
00011C16 =00000000                M spsl2	=	op2
00011C16 =00000000                M spsl3	=	op3
00011C16 =00000000                M spsl4	=	op4
00011C16                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C16 =0000000F                M sprr1	=	op1
00011C16 =0000000F                M sprr2	=	op2
00011C16 =0000000F                M sprr3	=	op3
00011C16 =0000000F                M sprr4	=	op4
00011C16                            	spSSGEG		$00, $00, $00, $00
00011C16 =00000000                M spss1	=	op1
00011C16 =00000000                M spss2	=	op2
00011C16 =00000000                M spss3	=	op3
00011C16 =00000000                M spss4	=	op4
00011C16                            	spTotalLv2	$29, $23, $27, $00
00011C16 =00000029                M sptl1	=	op1
00011C16 =00000023                M sptl2	=	op2
00011C16 =00000027                M sptl3	=	op3
00011C16 =00000000                M sptl4	=	op4
00011C16 20                       M 	dc.b	(spfe<<3)+spal
00011C17 3635 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C1B 4149 1B4B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C1F 0906 0908                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C23 0103 02A9                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C27 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C2B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C2F 2927 2300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C33 4E41 54                  M 	dc.b	'NAT'
00011C36                            
00011C36                            	; Patch $17
00011C36                            	; $30
00011C36                            	; $30, $30, $30, $30,	$9E, $D8, $DC, $DC
00011C36                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
00011C36                            	; $BF, $BF, $BF, $BF,	$10, $3A, $10, $00
00011C36                            	spAlgorithm	$00
00011C36 =00000018                M spatnum	=	spatnum+1
00011C36 =00000000                M spal	=	val
00011C36                            	spFeedback	$06
00011C36 =00000006                M spfe	=	val
00011C36                            	spDetune	$03, $03, $03, $03
00011C36 =00000003                M spde1	=	op1
00011C36 =00000003                M spde2	=	op2
00011C36 =00000003                M spde3	=	op3
00011C36 =00000003                M spde4	=	op4
00011C36                            	spMultiple	$00, $00, $00, $00
00011C36 =00000000                M spmu1	=	op1
00011C36 =00000000                M spmu2	=	op2
00011C36 =00000000                M spmu3	=	op3
00011C36 =00000000                M spmu4	=	op4
00011C36                            	spRateScale	$02, $03, $03, $03
00011C36 =00000002                M sprs1	=	op1
00011C36 =00000003                M sprs2	=	op2
00011C36 =00000003                M sprs3	=	op3
00011C36 =00000003                M sprs4	=	op4
00011C36                            	spAttackRt	$1E, $1C, $18, $1C
00011C36 =0000001E                M spar1	=	op1
00011C36 =0000001C                M spar2	=	op2
00011C36 =00000018                M spar3	=	op3
00011C36 =0000001C                M spar4	=	op4
00011C36                            	spAmpMod	$00, $00, $00, $00
00011C36 =00000000                M spam1	=	op1
00011C36 =00000000                M spam2	=	op2
00011C36 =00000000                M spam3	=	op3
00011C36 =00000000                M spam4	=	op4
00011C36                            	spSustainRt	$0E, $04, $0A, $05
00011C36 =0000000E                M spsr1	=	op1
00011C36 =00000004                M spsr2	=	op2
00011C36 =0000000A                M spsr3	=	op3
00011C36 =00000005                M spsr4	=	op4
00011C36                            	spDecayRt	$08, $08, $08, $08
00011C36 =00000008                M spdr1	=	op1
00011C36 =00000008                M spdr2	=	op2
00011C36 =00000008                M spdr3	=	op3
00011C36 =00000008                M spdr4	=	op4
00011C36                            	spSustainLv	$0B, $0B, $0B, $0B
00011C36 =0000000B                M spsl1	=	op1
00011C36 =0000000B                M spsl2	=	op2
00011C36 =0000000B                M spsl3	=	op3
00011C36 =0000000B                M spsl4	=	op4
00011C36                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C36 =0000000F                M sprr1	=	op1
00011C36 =0000000F                M sprr2	=	op2
00011C36 =0000000F                M sprr3	=	op3
00011C36 =0000000F                M sprr4	=	op4
00011C36                            	spSSGEG		$00, $00, $00, $00
00011C36 =00000000                M spss1	=	op1
00011C36 =00000000                M spss2	=	op2
00011C36 =00000000                M spss3	=	op3
00011C36 =00000000                M spss4	=	op4
00011C36                            	spTotalLv2	$10, $10, $3A, $00
00011C36 =00000010                M sptl1	=	op1
00011C36 =00000010                M sptl2	=	op2
00011C36 =0000003A                M sptl3	=	op3
00011C36 =00000000                M sptl4	=	op4
00011C36 30                       M 	dc.b	(spfe<<3)+spal
00011C37 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C3B 9ED8 DCDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C3F 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C43 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C47 BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C4B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C4F 103A 1000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C53 4E41 54                  M 	dc.b	'NAT'
00011C56                            
00011C56                            	; Patch $18
00011C56                            	; $04
00011C56                            	; $00, $01, $00, $05,	$0F, $1F, $0F, $1F
00011C56                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00011C56                            	; $8F, $8F, $8F, $8F,	$1F, $8D, $1F, $80
00011C56                            	spAlgorithm	$04
00011C56 =00000019                M spatnum	=	spatnum+1
00011C56 =00000004                M spal	=	val
00011C56                            	spFeedback	$00
00011C56 =00000000                M spfe	=	val
00011C56                            	spDetune	$00, $00, $00, $00
00011C56 =00000000                M spde1	=	op1
00011C56 =00000000                M spde2	=	op2
00011C56 =00000000                M spde3	=	op3
00011C56 =00000000                M spde4	=	op4
00011C56                            	spMultiple	$00, $00, $01, $05
00011C56 =00000000                M spmu1	=	op1
00011C56 =00000000                M spmu2	=	op2
00011C56 =00000001                M spmu3	=	op3
00011C56 =00000005                M spmu4	=	op4
00011C56                            	spRateScale	$00, $00, $00, $00
00011C56 =00000000                M sprs1	=	op1
00011C56 =00000000                M sprs2	=	op2
00011C56 =00000000                M sprs3	=	op3
00011C56 =00000000                M sprs4	=	op4
00011C56                            	spAttackRt	$0F, $0F, $1F, $1F
00011C56 =0000000F                M spar1	=	op1
00011C56 =0000000F                M spar2	=	op2
00011C56 =0000001F                M spar3	=	op3
00011C56 =0000001F                M spar4	=	op4
00011C56                            	spAmpMod	$00, $00, $00, $00
00011C56 =00000000                M spam1	=	op1
00011C56 =00000000                M spam2	=	op2
00011C56 =00000000                M spam3	=	op3
00011C56 =00000000                M spam4	=	op4
00011C56                            	spSustainRt	$00, $00, $00, $00
00011C56 =00000000                M spsr1	=	op1
00011C56 =00000000                M spsr2	=	op2
00011C56 =00000000                M spsr3	=	op3
00011C56 =00000000                M spsr4	=	op4
00011C56                            	spDecayRt	$00, $00, $00, $00
00011C56 =00000000                M spdr1	=	op1
00011C56 =00000000                M spdr2	=	op2
00011C56 =00000000                M spdr3	=	op3
00011C56 =00000000                M spdr4	=	op4
00011C56                            	spSustainLv	$08, $08, $08, $08
00011C56 =00000008                M spsl1	=	op1
00011C56 =00000008                M spsl2	=	op2
00011C56 =00000008                M spsl3	=	op3
00011C56 =00000008                M spsl4	=	op4
00011C56                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C56 =0000000F                M sprr1	=	op1
00011C56 =0000000F                M sprr2	=	op2
00011C56 =0000000F                M sprr3	=	op3
00011C56 =0000000F                M sprr4	=	op4
00011C56                            	spSSGEG		$00, $00, $00, $00
00011C56 =00000000                M spss1	=	op1
00011C56 =00000000                M spss2	=	op2
00011C56 =00000000                M spss3	=	op3
00011C56 =00000000                M spss4	=	op4
00011C56                            	spTotalLv2	$1F, $1F, $8D, $80
00011C56 =0000001F                M sptl1	=	op1
00011C56 =0000001F                M sptl2	=	op2
00011C56 =0000008D                M sptl3	=	op3
00011C56 =00000080                M sptl4	=	op4
00011C56 04                       M 	dc.b	(spfe<<3)+spal
00011C57 0001 0005                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C5B 0F1F 0F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C5F 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C63 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C67 8F8F 8F8F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C6B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C6F 1F8D 1F80                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C73 4E41 54                  M 	dc.b	'NAT'
00011C76                            
00011C76                            	; Patch $19
00011C76                            	; $3C
00011C76                            	; $05, $01, $0A, $01,	$56, $5C, $5C, $5C
00011C76                            	; $0E, $11, $11, $11,	$09, $0A, $06, $0A
00011C76                            	; $4F, $3F, $3F, $3F,	$17, $80, $20, $80
00011C76                            	spAlgorithm	$04
00011C76 =0000001A                M spatnum	=	spatnum+1
00011C76 =00000004                M spal	=	val
00011C76                            	spFeedback	$07
00011C76 =00000007                M spfe	=	val
00011C76                            	spDetune	$00, $00, $00, $00
00011C76 =00000000                M spde1	=	op1
00011C76 =00000000                M spde2	=	op2
00011C76 =00000000                M spde3	=	op3
00011C76 =00000000                M spde4	=	op4
00011C76                            	spMultiple	$05, $0A, $01, $01
00011C76 =00000005                M spmu1	=	op1
00011C76 =0000000A                M spmu2	=	op2
00011C76 =00000001                M spmu3	=	op3
00011C76 =00000001                M spmu4	=	op4
00011C76                            	spRateScale	$01, $01, $01, $01
00011C76 =00000001                M sprs1	=	op1
00011C76 =00000001                M sprs2	=	op2
00011C76 =00000001                M sprs3	=	op3
00011C76 =00000001                M sprs4	=	op4
00011C76                            	spAttackRt	$16, $1C, $1C, $1C
00011C76 =00000016                M spar1	=	op1
00011C76 =0000001C                M spar2	=	op2
00011C76 =0000001C                M spar3	=	op3
00011C76 =0000001C                M spar4	=	op4
00011C76                            	spAmpMod	$00, $00, $00, $00
00011C76 =00000000                M spam1	=	op1
00011C76 =00000000                M spam2	=	op2
00011C76 =00000000                M spam3	=	op3
00011C76 =00000000                M spam4	=	op4
00011C76                            	spSustainRt	$0E, $11, $11, $11
00011C76 =0000000E                M spsr1	=	op1
00011C76 =00000011                M spsr2	=	op2
00011C76 =00000011                M spsr3	=	op3
00011C76 =00000011                M spsr4	=	op4
00011C76                            	spDecayRt	$09, $06, $0A, $0A
00011C76 =00000009                M spdr1	=	op1
00011C76 =00000006                M spdr2	=	op2
00011C76 =0000000A                M spdr3	=	op3
00011C76 =0000000A                M spdr4	=	op4
00011C76                            	spSustainLv	$04, $03, $03, $03
00011C76 =00000004                M spsl1	=	op1
00011C76 =00000003                M spsl2	=	op2
00011C76 =00000003                M spsl3	=	op3
00011C76 =00000003                M spsl4	=	op4
00011C76                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C76 =0000000F                M sprr1	=	op1
00011C76 =0000000F                M sprr2	=	op2
00011C76 =0000000F                M sprr3	=	op3
00011C76 =0000000F                M sprr4	=	op4
00011C76                            	spSSGEG		$00, $00, $00, $00
00011C76 =00000000                M spss1	=	op1
00011C76 =00000000                M spss2	=	op2
00011C76 =00000000                M spss3	=	op3
00011C76 =00000000                M spss4	=	op4
00011C76                            	spTotalLv	$17, $20, $00, $00
00011C76 =00000017                M sptl1	=	op1
00011C76 =00000020                M sptl2	=	op2
00011C76 =00000000                M sptl3	=	op3
00011C76 =00000000                M sptl4	=	op4
00011C76 3C                       M 	dc.b	(spfe<<3)+spal
00011C77 =00000080                M sptlmask4	set	$80
00011C77 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011C77 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011C77 =00000000                M sptlmask1	set	((spal=7)<<7)
00011C77 0501 0A01                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C7B 565C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C7F 0E11 1111                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C83 090A 060A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C87 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C8B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C8F 1780 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011C93 4E41 54                  M 	dc.b	'NAT'
00011C96                            
00011C96                            	; Patch $1A
00011C96                            	; $F9
00011C96                            	; $21, $30, $10, $32,	$1C, $1F, $1F, $10
00011C96                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011C96                            	; $1F, $2F, $4F, $2F,	$0C, $06, $04, $80
00011C96                            	spAlgorithm	$01
00011C96 =0000001B                M spatnum	=	spatnum+1
00011C96 =00000001                M spal	=	val
00011C96                            	spFeedback	$07
00011C96 =00000007                M spfe	=	val
00011C96                            	spDetune	$02, $01, $03, $03
00011C96 =00000002                M spde1	=	op1
00011C96 =00000001                M spde2	=	op2
00011C96 =00000003                M spde3	=	op3
00011C96 =00000003                M spde4	=	op4
00011C96                            	spMultiple	$01, $00, $00, $02
00011C96 =00000001                M spmu1	=	op1
00011C96 =00000000                M spmu2	=	op2
00011C96 =00000000                M spmu3	=	op3
00011C96 =00000002                M spmu4	=	op4
00011C96                            	spRateScale	$00, $00, $00, $00
00011C96 =00000000                M sprs1	=	op1
00011C96 =00000000                M sprs2	=	op2
00011C96 =00000000                M sprs3	=	op3
00011C96 =00000000                M sprs4	=	op4
00011C96                            	spAttackRt	$1C, $1F, $1F, $10
00011C96 =0000001C                M spar1	=	op1
00011C96 =0000001F                M spar2	=	op2
00011C96 =0000001F                M spar3	=	op3
00011C96 =00000010                M spar4	=	op4
00011C96                            	spAmpMod	$00, $00, $00, $00
00011C96 =00000000                M spam1	=	op1
00011C96 =00000000                M spam2	=	op2
00011C96 =00000000                M spam3	=	op3
00011C96 =00000000                M spam4	=	op4
00011C96                            	spSustainRt	$05, $09, $18, $02
00011C96 =00000005                M spsr1	=	op1
00011C96 =00000009                M spsr2	=	op2
00011C96 =00000018                M spsr3	=	op3
00011C96 =00000002                M spsr4	=	op4
00011C96                            	spDecayRt	$0B, $10, $1F, $05
00011C96 =0000000B                M spdr1	=	op1
00011C96 =00000010                M spdr2	=	op2
00011C96 =0000001F                M spdr3	=	op3
00011C96 =00000005                M spdr4	=	op4
00011C96                            	spSustainLv	$01, $04, $02, $02
00011C96 =00000001                M spsl1	=	op1
00011C96 =00000004                M spsl2	=	op2
00011C96 =00000002                M spsl3	=	op3
00011C96 =00000002                M spsl4	=	op4
00011C96                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C96 =0000000F                M sprr1	=	op1
00011C96 =0000000F                M sprr2	=	op2
00011C96 =0000000F                M sprr3	=	op3
00011C96 =0000000F                M sprr4	=	op4
00011C96                            	spSSGEG		$00, $00, $00, $00
00011C96 =00000000                M spss1	=	op1
00011C96 =00000000                M spss2	=	op2
00011C96 =00000000                M spss3	=	op3
00011C96 =00000000                M spss4	=	op4
00011C96                            	spTotalLv	$0C, $04, $06, $00
00011C96 =0000000C                M sptl1	=	op1
00011C96 =00000004                M sptl2	=	op2
00011C96 =00000006                M sptl3	=	op3
00011C96 =00000000                M sptl4	=	op4
00011C96 39                       M 	dc.b	(spfe<<3)+spal
00011C97 =00000080                M sptlmask4	set	$80
00011C97 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011C97 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011C97 =00000000                M sptlmask1	set	((spal=7)<<7)
00011C97 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C9B 1C1F 1F10                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C9F 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011CA3 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011CA7 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011CAB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011CAF 0C06 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011CB3 4E41 54                  M 	dc.b	'NAT'
00011CB6                            
00011CB6                            	; Patch $1B
00011CB6                            	; $00
00011CB6                            	; $00, $03, $02, $00,	$D9, $DF, $1F, $1F
00011CB6                            	; $12, $11, $14, $0F,	$0A, $00, $0A, $0D
00011CB6                            	; $FF, $FF, $FF, $FF,	$22, $07, $27, $80
00011CB6                            	spAlgorithm	$00
00011CB6 =0000001C                M spatnum	=	spatnum+1
00011CB6 =00000000                M spal	=	val
00011CB6                            	spFeedback	$00
00011CB6 =00000000                M spfe	=	val
00011CB6                            	spDetune	$00, $00, $00, $00
00011CB6 =00000000                M spde1	=	op1
00011CB6 =00000000                M spde2	=	op2
00011CB6 =00000000                M spde3	=	op3
00011CB6 =00000000                M spde4	=	op4
00011CB6                            	spMultiple	$00, $02, $03, $00
00011CB6 =00000000                M spmu1	=	op1
00011CB6 =00000002                M spmu2	=	op2
00011CB6 =00000003                M spmu3	=	op3
00011CB6 =00000000                M spmu4	=	op4
00011CB6                            	spRateScale	$03, $00, $03, $00
00011CB6 =00000003                M sprs1	=	op1
00011CB6 =00000000                M sprs2	=	op2
00011CB6 =00000003                M sprs3	=	op3
00011CB6 =00000000                M sprs4	=	op4
00011CB6                            	spAttackRt	$19, $1F, $1F, $1F
00011CB6 =00000019                M spar1	=	op1
00011CB6 =0000001F                M spar2	=	op2
00011CB6 =0000001F                M spar3	=	op3
00011CB6 =0000001F                M spar4	=	op4
00011CB6                            	spAmpMod	$00, $00, $00, $00
00011CB6 =00000000                M spam1	=	op1
00011CB6 =00000000                M spam2	=	op2
00011CB6 =00000000                M spam3	=	op3
00011CB6 =00000000                M spam4	=	op4
00011CB6                            	spSustainRt	$12, $14, $11, $0F
00011CB6 =00000012                M spsr1	=	op1
00011CB6 =00000014                M spsr2	=	op2
00011CB6 =00000011                M spsr3	=	op3
00011CB6 =0000000F                M spsr4	=	op4
00011CB6                            	spDecayRt	$0A, $0A, $00, $0D
00011CB6 =0000000A                M spdr1	=	op1
00011CB6 =0000000A                M spdr2	=	op2
00011CB6 =00000000                M spdr3	=	op3
00011CB6 =0000000D                M spdr4	=	op4
00011CB6                            	spSustainLv	$0F, $0F, $0F, $0F
00011CB6 =0000000F                M spsl1	=	op1
00011CB6 =0000000F                M spsl2	=	op2
00011CB6 =0000000F                M spsl3	=	op3
00011CB6 =0000000F                M spsl4	=	op4
00011CB6                            	spReleaseRt	$0F, $0F, $0F, $0F
00011CB6 =0000000F                M sprr1	=	op1
00011CB6 =0000000F                M sprr2	=	op2
00011CB6 =0000000F                M sprr3	=	op3
00011CB6 =0000000F                M sprr4	=	op4
00011CB6                            	spSSGEG		$00, $00, $00, $00
00011CB6 =00000000                M spss1	=	op1
00011CB6 =00000000                M spss2	=	op2
00011CB6 =00000000                M spss3	=	op3
00011CB6 =00000000                M spss4	=	op4
00011CB6                            	spTotalLv	$22, $27, $07, $00
00011CB6 =00000022                M sptl1	=	op1
00011CB6 =00000027                M sptl2	=	op2
00011CB6 =00000007                M sptl3	=	op3
00011CB6 =00000000                M sptl4	=	op4
00011CB6 00                       M 	dc.b	(spfe<<3)+spal
00011CB7 =00000080                M sptlmask4	set	$80
00011CB7 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011CB7 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011CB7 =00000000                M sptlmask1	set	((spal=7)<<7)
00011CB7 0003 0200                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011CBB D9DF 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011CBF 1211 140F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011CC3 0A00 0A0D                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011CC7 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011CCB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011CCF 2207 2780                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011CD3 4E41 54                  M 	dc.b	'NAT'
00011CD6                            
00011CD6                            	; Patch $1C
00011CD6                            	; $34
00011CD6                            	; $09, $0F, $01, $D7,	$1F, $1F, $1F, $1F
00011CD6                            	; $0C, $11, $09, $0F,	$0A, $0E, $0D, $0E
00011CD6                            	; $35, $1A, $55, $3A,	$0C, $80, $0F, $80
00011CD6                            	spAlgorithm	$04
00011CD6 =0000001D                M spatnum	=	spatnum+1
00011CD6 =00000004                M spal	=	val
00011CD6                            	spFeedback	$06
00011CD6 =00000006                M spfe	=	val
00011CD6                            	spDetune	$00, $00, $00, $0D
00011CD6 =00000000                M spde1	=	op1
00011CD6 =00000000                M spde2	=	op2
00011CD6 =00000000                M spde3	=	op3
00011CD6 =0000000D                M spde4	=	op4
00011CD6                            	spMultiple	$09, $01, $0F, $07
00011CD6 =00000009                M spmu1	=	op1
00011CD6 =00000001                M spmu2	=	op2
00011CD6 =0000000F                M spmu3	=	op3
00011CD6 =00000007                M spmu4	=	op4
00011CD6                            	spRateScale	$00, $00, $00, $00
00011CD6 =00000000                M sprs1	=	op1
00011CD6 =00000000                M sprs2	=	op2
00011CD6 =00000000                M sprs3	=	op3
00011CD6 =00000000                M sprs4	=	op4
00011CD6                            	spAttackRt	$1F, $1F, $1F, $1F
00011CD6 =0000001F                M spar1	=	op1
00011CD6 =0000001F                M spar2	=	op2
00011CD6 =0000001F                M spar3	=	op3
00011CD6 =0000001F                M spar4	=	op4
00011CD6                            	spAmpMod	$00, $00, $00, $00
00011CD6 =00000000                M spam1	=	op1
00011CD6 =00000000                M spam2	=	op2
00011CD6 =00000000                M spam3	=	op3
00011CD6 =00000000                M spam4	=	op4
00011CD6                            	spSustainRt	$0C, $09, $11, $0F
00011CD6 =0000000C                M spsr1	=	op1
00011CD6 =00000009                M spsr2	=	op2
00011CD6 =00000011                M spsr3	=	op3
00011CD6 =0000000F                M spsr4	=	op4
00011CD6                            	spDecayRt	$0A, $0D, $0E, $0E
00011CD6 =0000000A                M spdr1	=	op1
00011CD6 =0000000D                M spdr2	=	op2
00011CD6 =0000000E                M spdr3	=	op3
00011CD6 =0000000E                M spdr4	=	op4
00011CD6                            	spSustainLv	$03, $05, $01, $03
00011CD6 =00000003                M spsl1	=	op1
00011CD6 =00000005                M spsl2	=	op2
00011CD6 =00000001                M spsl3	=	op3
00011CD6 =00000003                M spsl4	=	op4
00011CD6                            	spReleaseRt	$05, $05, $0A, $0A
00011CD6 =00000005                M sprr1	=	op1
00011CD6 =00000005                M sprr2	=	op2
00011CD6 =0000000A                M sprr3	=	op3
00011CD6 =0000000A                M sprr4	=	op4
00011CD6                            	spSSGEG		$00, $00, $00, $00
00011CD6 =00000000                M spss1	=	op1
00011CD6 =00000000                M spss2	=	op2
00011CD6 =00000000                M spss3	=	op3
00011CD6 =00000000                M spss4	=	op4
00011CD6                            	spTotalLv	$0C, $0F, $00, $00
00011CD6 =0000000C                M sptl1	=	op1
00011CD6 =0000000F                M sptl2	=	op2
00011CD6 =00000000                M sptl3	=	op3
00011CD6 =00000000                M sptl4	=	op4
00011CD6 34                       M 	dc.b	(spfe<<3)+spal
00011CD7 =00000080                M sptlmask4	set	$80
00011CD7 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011CD7 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011CD7 =00000000                M sptlmask1	set	((spal=7)<<7)
00011CD7 090F 01D7                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011CDB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011CDF 0C11 090F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011CE3 0A0E 0D0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011CE7 351A 553A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011CEB 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011CEF 0C80 0F80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011CF3 4E41 54                  M 	dc.b	'NAT'
00011CF6                            
00011CF6                            	; Patch $1D
00011CF6                            	; $FA
00011CF6                            	; $21, $3A, $19, $30,	$1F, $1F, $1F, $1F
00011CF6                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011CF6                            	; $1F, $2F, $4F, $2F,	$0E, $07, $04, $80
00011CF6                            	spAlgorithm	$02
00011CF6 =0000001E                M spatnum	=	spatnum+1
00011CF6 =00000002                M spal	=	val
00011CF6                            	spFeedback	$07
00011CF6 =00000007                M spfe	=	val
00011CF6                            	spDetune	$02, $01, $03, $03
00011CF6 =00000002                M spde1	=	op1
00011CF6 =00000001                M spde2	=	op2
00011CF6 =00000003                M spde3	=	op3
00011CF6 =00000003                M spde4	=	op4
00011CF6                            	spMultiple	$01, $09, $0A, $00
00011CF6 =00000001                M spmu1	=	op1
00011CF6 =00000009                M spmu2	=	op2
00011CF6 =0000000A                M spmu3	=	op3
00011CF6 =00000000                M spmu4	=	op4
00011CF6                            	spRateScale	$00, $00, $00, $00
00011CF6 =00000000                M sprs1	=	op1
00011CF6 =00000000                M sprs2	=	op2
00011CF6 =00000000                M sprs3	=	op3
00011CF6 =00000000                M sprs4	=	op4
00011CF6                            	spAttackRt	$1F, $1F, $1F, $1F
00011CF6 =0000001F                M spar1	=	op1
00011CF6 =0000001F                M spar2	=	op2
00011CF6 =0000001F                M spar3	=	op3
00011CF6 =0000001F                M spar4	=	op4
00011CF6                            	spAmpMod	$00, $00, $00, $00
00011CF6 =00000000                M spam1	=	op1
00011CF6 =00000000                M spam2	=	op2
00011CF6 =00000000                M spam3	=	op3
00011CF6 =00000000                M spam4	=	op4
00011CF6                            	spSustainRt	$05, $09, $18, $02
00011CF6 =00000005                M spsr1	=	op1
00011CF6 =00000009                M spsr2	=	op2
00011CF6 =00000018                M spsr3	=	op3
00011CF6 =00000002                M spsr4	=	op4
00011CF6                            	spDecayRt	$0B, $10, $1F, $05
00011CF6 =0000000B                M spdr1	=	op1
00011CF6 =00000010                M spdr2	=	op2
00011CF6 =0000001F                M spdr3	=	op3
00011CF6 =00000005                M spdr4	=	op4
00011CF6                            	spSustainLv	$01, $04, $02, $02
00011CF6 =00000001                M spsl1	=	op1
00011CF6 =00000004                M spsl2	=	op2
00011CF6 =00000002                M spsl3	=	op3
00011CF6 =00000002                M spsl4	=	op4
00011CF6                            	spReleaseRt	$0F, $0F, $0F, $0F
00011CF6 =0000000F                M sprr1	=	op1
00011CF6 =0000000F                M sprr2	=	op2
00011CF6 =0000000F                M sprr3	=	op3
00011CF6 =0000000F                M sprr4	=	op4
00011CF6                            	spSSGEG		$00, $00, $00, $00
00011CF6 =00000000                M spss1	=	op1
00011CF6 =00000000                M spss2	=	op2
00011CF6 =00000000                M spss3	=	op3
00011CF6 =00000000                M spss4	=	op4
00011CF6                            	spTotalLv	$0E, $04, $07, $00
00011CF6 =0000000E                M sptl1	=	op1
00011CF6 =00000004                M sptl2	=	op2
00011CF6 =00000007                M sptl3	=	op3
00011CF6 =00000000                M sptl4	=	op4
00011CF6 3A                       M 	dc.b	(spfe<<3)+spal
00011CF7 =00000080                M sptlmask4	set	$80
00011CF7 =00000000                M sptlmask2	set	((spal>=5)<<7)
00011CF7 =00000000                M sptlmask3	set	((spal>=4)<<7)
00011CF7 =00000000                M sptlmask1	set	((spal=7)<<7)
00011CF7 213A 1930                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011CFB 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011CFF 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011D03 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011D07 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011D0B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011D0F 0E07 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011D13 4E41 54                  M 	dc.b	'NAT'
00011D16                            
00011D16                            	; Patch $1E
00011D16                            	; $1C
00011D16                            	; $2E, $02, $0F, $02,	$1F, $1F, $1F, $1F
00011D16                            	; $18, $04, $14, $0E,	$00, $00, $00, $00
00011D16                            	; $FF, $FF, $FF, $FF,	$20, $80, $1B, $80
00011D16                            	spAlgorithm	$0C
00011D16 =0000001F                M spatnum	=	spatnum+1
00011D16 =0000000C                M spal	=	val
00011D16                            	spFeedback	$01
00011D16 =00000001                M spfe	=	val
00011D16                            	spDetune	$02, $00, $00, $00
00011D16 =00000002                M spde1	=	op1
00011D16 =00000000                M spde2	=	op2
00011D16 =00000000                M spde3	=	op3
00011D16 =00000000                M spde4	=	op4
00011D16                            	spMultiple	$0E, $0F, $02, $02
00011D16 =0000000E                M spmu1	=	op1
00011D16 =0000000F                M spmu2	=	op2
00011D16 =00000002                M spmu3	=	op3
00011D16 =00000002                M spmu4	=	op4
00011D16                            	spRateScale	$00, $00, $00, $00
00011D16 =00000000                M sprs1	=	op1
00011D16 =00000000                M sprs2	=	op2
00011D16 =00000000                M sprs3	=	op3
00011D16 =00000000                M sprs4	=	op4
00011D16                            	spAttackRt	$1F, $1F, $1F, $1F
00011D16 =0000001F                M spar1	=	op1
00011D16 =0000001F                M spar2	=	op2
00011D16 =0000001F                M spar3	=	op3
00011D16 =0000001F                M spar4	=	op4
00011D16                            	spAmpMod	$00, $00, $00, $00
00011D16 =00000000                M spam1	=	op1
00011D16 =00000000                M spam2	=	op2
00011D16 =00000000                M spam3	=	op3
00011D16 =00000000                M spam4	=	op4
00011D16                            	spSustainRt	$18, $14, $04, $0E
00011D16 =00000018                M spsr1	=	op1
00011D16 =00000014                M spsr2	=	op2
00011D16 =00000004                M spsr3	=	op3
00011D16 =0000000E                M spsr4	=	op4
00011D16                            	spDecayRt	$00, $00, $00, $00
00011D16 =00000000                M spdr1	=	op1
00011D16 =00000000                M spdr2	=	op2
00011D16 =00000000                M spdr3	=	op3
00011D16 =00000000                M spdr4	=	op4
00011D16                            	spSustainLv	$0F, $0F, $0F, $0F
00011D16 =0000000F                M spsl1	=	op1
00011D16 =0000000F                M spsl2	=	op2
00011D16 =0000000F                M spsl3	=	op3
00011D16 =0000000F                M spsl4	=	op4
00011D16                            	spReleaseRt	$0F, $0F, $0F, $0F
00011D16 =0000000F                M sprr1	=	op1
00011D16 =0000000F                M sprr2	=	op2
00011D16 =0000000F                M sprr3	=	op3
00011D16 =0000000F                M sprr4	=	op4
00011D16                            	spSSGEG		$00, $00, $00, $00
00011D16 =00000000                M spss1	=	op1
00011D16 =00000000                M spss2	=	op2
00011D16 =00000000                M spss3	=	op3
00011D16 =00000000                M spss4	=	op4
00011D16                            	spTotalLv	$20, $1B, $00, $00
00011D16 =00000020                M sptl1	=	op1
00011D16 =0000001B                M sptl2	=	op2
00011D16 =00000000                M sptl3	=	op3
00011D16 =00000000                M sptl4	=	op4
00011D16 14                       M 	dc.b	(spfe<<3)+spal
00011D17 =00000080                M sptlmask4	set	$80
00011D17 =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011D17 =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011D17 =00000000                M sptlmask1	set	((spal=7)<<7)
00011D17 2E02 0F02                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011D1B 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011D1F 1804 140E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011D23 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011D27 FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011D2B 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011D2F 2080 9B80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011D33 4E41 54                  M 	dc.b	'NAT'
00011D36                            
00011D36                            	even
00011D36                            
00011D36                            ; -------------------------------------------------------------------------
00011D36                            	opt ae-				; disable automatic evens
00011D36                            
00011D36                            sfxaddr	include	"Sound/sfxdata.asm"	; include all sfx
00011D36                            
00011D36                            
00011D36                            ; ------------------------------------------------------------------------
00011D36                            ; AMPS SFX data
00011D36                            ; -------------------------------------------------------------------------
00011D36                            
00011D36                            Snd_Jump:
00011D36                            		include	"Sound/sfx/Jump.asm"
00011D36                            SndJump_Header:
00011D36                            	sHeaderInit	
00011D36 =00011D36                M spointzero	=	*
00011D36 =00000000                M spatnum	=	0
00011D36                            	sHeaderPrio	$60
00011D36 60                       M 	dc.b	$60
00011D37                            	sHeaderCh	$01
00011D37 00                       M 	dc.b	$01-1
00011D38                            	sHeaderSFX	$80, $C0, SndJump_FM5, -1, $00
00011D38 80C0                     M 	dc.b	$80,$c0
00011D3A 0000                     M 	dc.w	sndjump_fm5-spointzero
00011D3C FF00                     M 	dc.b	-1,$00
00011D3E                            
00011D3E                            SndJump_FM5:
00011D3E F3E7                       	dc.b	$F3,	$E7
00011D40                            	ssMod68k	$00, $01, -5, $10
00011D40 F000 01FB 10             M 	dc.b	$f0,$00,$01,-5,$10
00011D45 A510                       	dc.b nC3, $10
00011D47                            	sModOff
00011D47 EC                       M 	dc.b	$ec
00011D48                            	
00011D48                            Jumploop:
00011D48 E702                       	dc.b	$E7,	$02
00011D4A                            	saVol	$01
00011D4A ED01                     M 	dc.b	$ed,$01
00011D4C                            	sLoop		$00, $0B, Jumploop
00011D4C F700                     M 	dc.b	$f7,$00
00011D4E FFF9                     M 	dc.w	jumploop-*-1
00011D50 0B                       M 	dc.b	$0b
00011D51                            	
00011D51                            	sStop	
00011D51 F5                       M 	dc.b	$f5
00011D52                            		even
00011D52                            Snd_Skid:
00011D52                            		include	"Sound/sfx/Skid.asm"
00011D52                            Skid_Header:
00011D52                            	sHeaderInit	
00011D52 =00011D52                M spointzero	=	*
00011D52 =00000000                M spatnum	=	0
00011D52                            	sHeaderPrio	$60
00011D52 60                       M 	dc.b	$60
00011D53                            	sHeaderCh	$01
00011D53 00                       M 	dc.b	$01-1
00011D54                            	sHeaderSFX	$80, $C0, Skid_FM5, $00, $00
00011D54 80C0                     M 	dc.b	$80,$c0
00011D56 0000                     M 	dc.w	skid_fm5-spointzero
00011D58 0000                     M 	dc.b	$00,$00
00011D5A                            
00011D5A                            Skid_FM5:
00011D5A F3E7                       	dc.b	$F3,	$E7
00011D5C 8001                       	dc.b nRst, $01
00011D5E                            	
00011D5E                            Skid_Loop1:
00011D5E AD01 8001                  	dc.b nAb3, $01, nRst, $01
00011D62                            	sLoop		$00, $03, Skid_Loop1
00011D62 F700                     M 	dc.b	$f7,$00
00011D64 FFF9                     M 	dc.w	skid_loop1-*-1
00011D66 03                       M 	dc.b	$03
00011D67                            
00011D67                            Skid_Loop2:
00011D67 AD01 8001                  	dc.b nAb3, $01, nRst, $01
00011D6B                            	saVol	$01
00011D6B ED01                     M 	dc.b	$ed,$01
00011D6D                            	sLoop		$00, $09, Skid_Loop2
00011D6D F700                     M 	dc.b	$f7,$00
00011D6F FFF7                     M 	dc.w	skid_loop2-*-1
00011D71 09                       M 	dc.b	$09
00011D72                            	sStop	
00011D72 F5                       M 	dc.b	$f5
00011D74 00                         		even
00011D74                            Snd_Death:
00011D74                            		include	"Sound/sfx/Death.asm"
00011D74                            Death_Header:
00011D74                            	sHeaderInit	
00011D74 =00011D74                M spointzero	=	*
00011D74 =00000000                M spatnum	=	0
00011D74                            	sHeaderPrio	$60
00011D74 60                       M 	dc.b	$60
00011D75                            	sHeaderCh	$01
00011D75 00                       M 	dc.b	$01-1
00011D76                            	sHeaderSFX	$80, $05, Death_FM5, $F4, $00
00011D76 8005                     M 	dc.b	$80,$05
00011D78 0000                     M 	dc.w	death_fm5-spointzero
00011D7A F400                     M 	dc.b	$f4,$00
00011D7C                            
00011D7C                            Death_FM5:
00011D7C                            	sVoice		$02
00011D7C E802                     M 	dc.b	$e8,$02
00011D7E B007 E7AD                  	dc.b nB3, $07, sHold, nAb3
00011D82                            
00011D82                            Death_Loop1:
00011D82 01                         	dc.b $01
00011D83                            	saVol		$01
00011D83 ED01                     M 	dc.b	$ed,$01
00011D85                            	sLoop		$00, $2F, Death_Loop1
00011D85 F700                     M 	dc.b	$f7,$00
00011D87 FFFA                     M 	dc.w	death_loop1-*-1
00011D89 2F                       M 	dc.b	$2f
00011D8A                            	sStop	
00011D8A F5                       M 	dc.b	$f5
00011D8C 00                         		even
00011D8C                            Snd_Push:
00011D8C                            		include	"Sound/sfx/Push.asm"
00011D8C                            Push_Header:
00011D8C                            	sHeaderInit	
00011D8C =00011D8C                M spointzero	=	*
00011D8C =00000000                M spatnum	=	0
00011D8C                            	sHeaderPrio	$60
00011D8C 60                       M 	dc.b	$60
00011D8D                            	sHeaderCh	$01
00011D8D 00                       M 	dc.b	$01-1
00011D8E                            	sHeaderSFX	$80, $05, Push_FM5, $00, $06
00011D8E 8005                     M 	dc.b	$80,$05
00011D90 0000                     M 	dc.w	push_fm5-spointzero
00011D92 0006                     M 	dc.b	$00,$06
00011D94                            
00011D94                            Push_FM5:
00011D94                            	sVoice		$13
00011D94 E813                     M 	dc.b	$e8,$13
00011D96 8F07 8002 8F06 8010        	dc.b nD1, $07, nRst, $02, nD1, $06, nRst, $10
00011D9E                            	sStop	
00011D9E F5                       M 	dc.b	$f5
00011DA0 00                         		even
00011DA0                            Snd_Bubble:
00011DA0                            Snd_Drown:
00011DA0                            Snd_DrownWarning:
00011DA0                            Snd_DrownCountdown:
00011DA0                            Snd_Checkpoint:
00011DA0                            		include	"Sound/sfx/Checkpoint.asm"
00011DA0                            Attack_Header:
00011DA0                            	sHeaderInit	
00011DA0 =00011DA0                M spointzero	=	*
00011DA0 =00000000                M spatnum	=	0
00011DA0                            	sHeaderPrio	$60
00011DA0 60                       M 	dc.b	$60
00011DA1                            	sHeaderCh	$02
00011DA1 01                       M 	dc.b	$02-1
00011DA2                            	sHeaderSFX	$80, $80, Attack_FM5, $00, $00
00011DA2 8080                     M 	dc.b	$80,$80
00011DA4 0000                     M 	dc.w	attack_fm5-spointzero
00011DA6 0000                     M 	dc.b	$00,$00
00011DA8                            	sHeaderSFX	$80, $A0, Attack_FM5B, $00, $04
00011DA8 80A0                     M 	dc.b	$80,$a0
00011DAA 0000                     M 	dc.w	attack_fm5b-spointzero
00011DAC 0004                     M 	dc.b	$00,$04
00011DAE                            
00011DAE                            Attack_FM5B:
00011DAE 8002                       	dc.b	nRst,	$02
00011DB0                            
00011DB0                            Attack_FM5:
00011DB0                            
00011DB0                            Attack_Loop1:
00011DB0 B103 8001                  	dc.b nC4, $03, nRst, $01
00011DB4                            	sLoop		$00, $01, Attack_Loop1
00011DB4 F700                     M 	dc.b	$f7,$00
00011DB6 FFF9                     M 	dc.w	attack_loop1-*-1
00011DB8 01                       M 	dc.b	$01
00011DB9                            
00011DB9                            Attack_Loop2:
00011DB9 B103 8001                  	dc.b nC4, $03, nRst, $01
00011DBD                            	saVol	$01
00011DBD ED01                     M 	dc.b	$ed,$01
00011DBF B003 8001                  	dc.b nB3, $03, nRst, $01
00011DC3                            	saVol	$01
00011DC3 ED01                     M 	dc.b	$ed,$01
00011DC5 AF03 8001                  	dc.b nBb3, $03, nRst, $01
00011DC9                            	saVol	$01
00011DC9 ED01                     M 	dc.b	$ed,$01
00011DCB AE03 8001                  	dc.b nBb3-1, $03, nRst, $01
00011DCF                            	saVol	$01
00011DCF ED01                     M 	dc.b	$ed,$01
00011DD1                            	sLoop		$00, $03, Attack_Loop2
00011DD1 F700                     M 	dc.b	$f7,$00
00011DD3 FFE5                     M 	dc.w	attack_loop2-*-1
00011DD5 03                       M 	dc.b	$03
00011DD6                            	sStop	
00011DD6 F5                       M 	dc.b	$f5
00011DD8 00                         		even
00011DD8                            Snd_SpikeMove:
00011DD8                            Snd_Ring:
00011DD8                            		include	"Sound/sfx/Ring.asm"
00011DD8                            Ring_Header:
00011DD8                            	sHeaderInit	
00011DD8 =00011DD8                M spointzero	=	*
00011DD8 =00000000                M spatnum	=	0
00011DD8                            	sHeaderPrio	$60
00011DD8 60                       M 	dc.b	$60
00011DD9                            	sHeaderCh	$01
00011DD9 00                       M 	dc.b	$01-1
00011DDA                            	sHeaderSFX	$80, $05, Ring_FM5, $00, $0A
00011DDA 8005                     M 	dc.b	$80,$05
00011DDC 0000                     M 	dc.w	ring_fm5-spointzero
00011DDE 000A                     M 	dc.b	$00,$0a
00011DE0                            
00011DE0                            Ring_FM5:
00011DE0                            	sVoice		$03
00011DE0 E803                     M 	dc.b	$e8,$03
00011DE2 C105 C405 C91B             	dc.b nE5, $05, nG5, $05, nC6, $1B
00011DE8                            	sStop	
00011DE8 F5                       M 	dc.b	$f5
00011DEA 00                         		even
00011DEA                            Snd_RingLoss:
00011DEA                            		include	"Sound/sfx/Ring Loss.asm"
00011DEA                            RingLoss_Header:
00011DEA                            	sHeaderInit	
00011DEA =00011DEA                M spointzero	=	*
00011DEA =00000000                M spatnum	=	0
00011DEA                            	sHeaderPrio	$60
00011DEA 60                       M 	dc.b	$60
00011DEB                            	sHeaderCh	$02
00011DEB 01                       M 	dc.b	$02-1
00011DEC                            	sHeaderSFX	$80, $04, RingLoss_FM4, $00, $05
00011DEC 8004                     M 	dc.b	$80,$04
00011DEE 0000                     M 	dc.w	ringloss_fm4-spointzero
00011DF0 0005                     M 	dc.b	$00,$05
00011DF2                            	sHeaderSFX	$80, $05, RingLoss_FM5, $00, $08
00011DF2 8005                     M 	dc.b	$80,$05
00011DF4 0000                     M 	dc.w	ringloss_fm5-spointzero
00011DF6 0008                     M 	dc.b	$00,$08
00011DF8                            
00011DF8                            RingLoss_FM4:
00011DF8                            	sVoice		$03
00011DF8 E803                     M 	dc.b	$e8,$03
00011DFA C602 0505 0505 0505 3A     	dc.b nA5, $02, $05, $05, $05, $05, $05, $05, $3A
00011E03                            	sStop	
00011E03 F5                       M 	dc.b	$f5
00011E04                            
00011E04                            RingLoss_FM5:
00011E04                            	sVoice		$03
00011E04 E803                     M 	dc.b	$e8,$03
00011E06 8002 C402 0515 0205 32     	dc.b nRst, $02, nG5, $02, $05, $15, $02, $05, $32
00011E0F                            	sStop	
00011E0F F5                       M 	dc.b	$f5
00011E10                            		even
00011E10                            Snd_Spring:
00011E10                            		include	"Sound/sfx/Spring.asm"
00011E10                            Spring_Header:
00011E10                            	sHeaderInit	
00011E10 =00011E10                M spointzero	=	*
00011E10 =00000000                M spatnum	=	0
00011E10                            	sHeaderPrio	$60
00011E10 60                       M 	dc.b	$60
00011E11                            	sHeaderCh	$01
00011E11 00                       M 	dc.b	$01-1
00011E12                            	sHeaderSFX	$80, $04, Spring_FM4, $00, $02
00011E12 8004                     M 	dc.b	$80,$04
00011E14 0000                     M 	dc.w	spring_fm4-spointzero
00011E16 0002                     M 	dc.b	$00,$02
00011E18                            
00011E18                            Spring_FM4:
00011E18                            	sVoice		$06
00011E18 E806                     M 	dc.b	$e8,$06
00011E1A 8001                       	dc.b nRst, $01
00011E1C                            	ssMod68k	$03, $01, $5D, $0F
00011E1C F003 015D 0F             M 	dc.b	$f0,$03,$01,$5d,$0f
00011E21 B00C                       	dc.b nB3, $0C
00011E23                            	sModOff	
00011E23 EC                       M 	dc.b	$ec
00011E24                            
00011E24                            Spring_Loop1:
00011E24 E7                         	dc.b sHold
00011E25                            	saVol		$02
00011E25 ED02                     M 	dc.b	$ed,$02
00011E27 BD02                       	dc.b nC5, $02
00011E29                            	sLoop		$00, $19, Spring_Loop1
00011E29 F700                     M 	dc.b	$f7,$00
00011E2B FFF8                     M 	dc.w	spring_loop1-*-1
00011E2D 19                       M 	dc.b	$19
00011E2E                            	sStop	
00011E2E F5                       M 	dc.b	$f5
00011E30 00                         		even
00011E30                            Snd_Shield:
00011E30                            Snd_Splash:
00011E30                            Snd_Bumper:
00011E30                            		include	"Sound/sfx/Bumper.asm"
00011E30                            BumperHeader:
00011E30                            	sHeaderInit	
00011E30 =00011E30                M spointzero	=	*
00011E30 =00000000                M spatnum	=	0
00011E30                            	sHeaderPrio	$60
00011E30 60                       M 	dc.b	$60
00011E31                            	sHeaderCh	$03
00011E31 02                       M 	dc.b	$03-1
00011E32                            	sHeaderSFX	$80, $05, BumperFM5, $00, $00
00011E32 8005                     M 	dc.b	$80,$05
00011E34 0000                     M 	dc.w	bumperfm5-spointzero
00011E36 0000                     M 	dc.b	$00,$00
00011E38                            	sHeaderSFX	$80, $04, BumperFM4, $00, $00
00011E38 8004                     M 	dc.b	$80,$04
00011E3A 0000                     M 	dc.w	bumperfm4-spointzero
00011E3C 0000                     M 	dc.b	$00,$00
00011E3E                            	sHeaderSFX	$80, $02, BumperFM3, $00, $02
00011E3E 8002                     M 	dc.b	$80,$02
00011E40 0000                     M 	dc.w	bumperfm3-spointzero
00011E42 0002                     M 	dc.b	$00,$02
00011E44                            
00011E44                            BumperFM5:
00011E44                            	sVoice		$0D
00011E44 E80D                     M 	dc.b	$e8,$0d
00011E46                            	ssJump		BumperJump1
00011E46 F6                       M 	dc.b	$f6
00011E47 0000                     M 	dc.w	bumperjump1-*-1
00011E49                            
00011E49                            BumperFM4:
00011E49                            	sVoice		$0D
00011E49 E80D                     M 	dc.b	$e8,$0d
00011E4B                            	saDetune	$07
00011E4B E207                     M 	dc.b	$e2,$07
00011E4D 8001                       	dc.b nRst, $01
00011E4F                            
00011E4F                            BumperJump1:
00011E4F BA20                       	dc.b nA4, $20
00011E51                            	sStop	
00011E51 F5                       M 	dc.b	$f5
00011E52                            
00011E52                            BumperFM3:
00011E52                            	sVoice		$0E
00011E52 E80E                     M 	dc.b	$e8,$0e
00011E54 9A03                       	dc.b nCs2, $03
00011E56                            	sStop	
00011E56 F5                       M 	dc.b	$f5
00011E58 00                         		even
00011E58                            Snd_Switch:
00011E58                            Snd_Signpost:
00011E58                            Snd_Collapse:
00011E58                            Snd_WallSmash:
00011E58                            Snd_Rumble:
00011E58                            Snd_Warp:
00011E58                            Snd_BossHit:
00011E58                            		include	"Sound/sfx/Boss Hit.asm"
00011E58                            BossHit_Header:
00011E58                            	sHeaderInit	
00011E58 =00011E58                M spointzero	=	*
00011E58 =00000000                M spatnum	=	0
00011E58                            	sHeaderPrio	$60
00011E58 60                       M 	dc.b	$60
00011E59                            	sHeaderCh	$01
00011E59 00                       M 	dc.b	$01-1
00011E5A                            	sHeaderSFX	$80, $05, BossHit_FM4, $00, $00
00011E5A 8005                     M 	dc.b	$80,$05
00011E5C 0000                     M 	dc.w	bosshit_fm4-spointzero
00011E5E 0000                     M 	dc.b	$00,$00
00011E60                            
00011E60                            BossHit_FM4:
00011E60                            	sVoice		$0F
00011E60 E80F                     M 	dc.b	$e8,$0f
00011E62                            	ssMod68k	$01, $01, $0C, $01
00011E62 F001 010C 01             M 	dc.b	$f0,$01,$01,$0c,$01
00011E67                            
00011E67                            BossHit_Loop1:
00011E67 810A                       	dc.b nC0, $0A
00011E69                            	saVol		$10
00011E69 ED10                     M 	dc.b	$ed,$10
00011E6B                            	sLoop		$00, $04, BossHit_Loop1
00011E6B F700                     M 	dc.b	$f7,$00
00011E6D FFF9                     M 	dc.w	bosshit_loop1-*-1
00011E6F 04                       M 	dc.b	$04
00011E70                            	sStop	
00011E70 F5                       M 	dc.b	$f5
00011E72 00                         		even
00011E72                            Snd_Bomb:
00011E72                            		include	"Sound/sfx/Bomb.asm"
00011E72                            Bomb_Header:
00011E72                            	sHeaderInit	
00011E72 =00011E72                M spointzero	=	*
00011E72 =00000000                M spatnum	=	0
00011E72                            	sHeaderPrio	$60
00011E72 60                       M 	dc.b	$60
00011E73                            	sHeaderCh	$01
00011E73 00                       M 	dc.b	$01-1
00011E74                            	sHeaderSFX	$80, $05, Bomb_FM5, $00, $00
00011E74 8005                     M 	dc.b	$80,$05
00011E76 0000                     M 	dc.w	bomb_fm5-spointzero
00011E78 0000                     M 	dc.b	$00,$00
00011E7A                            
00011E7A                            Bomb_FM5:
00011E7A                            	sVoice		$09
00011E7A E809                     M 	dc.b	$e8,$09
00011E7C 8A22                       	dc.b nA0, $22
00011E7E                            	sStop	
00011E7E F5                       M 	dc.b	$f5
00011E80 00                         		even
00011E80                            Snd_BreakItem:
00011E80                            		include	"Sound/sfx/Break Item.asm"
00011E80                            BreakItem_Header:
00011E80                            	sHeaderInit	
00011E80 =00011E80                M spointzero	=	*
00011E80 =00000000                M spatnum	=	0
00011E80                            	sHeaderPrio	$60
00011E80 60                       M 	dc.b	$60
00011E81                            	sHeaderCh	$01
00011E81 00                       M 	dc.b	$01-1
00011E82                            	sHeaderSFX	$80, $05, BreakItem_FM5, $00, $00
00011E82 8005                     M 	dc.b	$80,$05
00011E84 0000                     M 	dc.w	breakitem_fm5-spointzero
00011E86 0000                     M 	dc.b	$00,$00
00011E88                            
00011E88                            BreakItem_FM5:
00011E88                            	ssMod68k	$03, $01, $72, $0B
00011E88 F003 0172 0B             M 	dc.b	$f0,$03,$01,$72,$0b
00011E8D                            	sVoice		$04
00011E8D E804                     M 	dc.b	$e8,$04
00011E8F BA16                       	dc.b nA4, $16
00011E91                            	sStop	
00011E91 F5                       M 	dc.b	$f5
00011E92                            		even
00011E92                            Snd_FloorBounce:
00011E92                            		include	"Sound/sfx/Floor Bounce.asm"
00011E92                            FloorBounce_Header:
00011E92                            	sHeaderInit	
00011E92 =00011E92                M spointzero	=	*
00011E92 =00000000                M spatnum	=	0
00011E92                            	sHeaderPrio	$60
00011E92 60                       M 	dc.b	$60
00011E93                            	sHeaderCh	$01
00011E93 00                       M 	dc.b	$01-1
00011E94                            	sHeaderSFX	$80, $05, FloorBounce_FM5, $00, $00
00011E94 8005                     M 	dc.b	$80,$05
00011E96 0000                     M 	dc.w	floorbounce_fm5-spointzero
00011E98 0000                     M 	dc.b	$00,$00
00011E9A                            
00011E9A                            FloorBounce_FM5:
00011E9A                            	sVoice		$18
00011E9A E818                     M 	dc.b	$e8,$18
00011E9C A00F                       	dc.b nG2, $0F
00011E9E                            	saVol		$0F
00011E9E ED0F                     M 	dc.b	$ed,$0f
00011EA0                            	sLoop		$00, $04, FloorBounce_FM5
00011EA0 F700                     M 	dc.b	$f7,$00
00011EA2 FFF7                     M 	dc.w	floorbounce_fm5-*-1
00011EA4 04                       M 	dc.b	$04
00011EA5                            	sStop	
00011EA5 F5                       M 	dc.b	$f5
00011EA6                            		even
00011EA6                            Snd_Charge:
00011EA6                            		include	"Sound/sfx/Charge.asm"
00011EA6                            PeeloutCharge_Header:
00011EA6                            	sHeaderInit
00011EA6 =00011EA6                M spointzero	=	*
00011EA6 =00000000                M spatnum	=	0
00011EA6                            	sHeaderPrio	$60
00011EA6 60                       M 	dc.b	$60
00011EA7                            	sHeaderCh	$01
00011EA7 00                       M 	dc.b	$01-1
00011EA8                            
00011EA8                            	sHeaderSFX	$80, $05, PeeloutCharge_FM5, $00, $05
00011EA8 8005                     M 	dc.b	$80,$05
00011EAA 0000                     M 	dc.w	peeloutcharge_fm5-spointzero
00011EAC 0005                     M 	dc.b	$00,$05
00011EAE                            
00011EAE                            ; FM5 Data
00011EAE                            PeeloutCharge_FM5:
00011EAE                            	sVoice	$0A
00011EAE E80A                     M 	dc.b	$e8,$0a
00011EB0 8001                       	dc.b	nRst, $01
00011EB2                            	ssMod68k	$01, $01, $09, $FF
00011EB2 F001 0109 FF             M 	dc.b	$f0,$01,$01,$09,$ff
00011EB7 CA22                       	dc.b	nCs6, $22
00011EB9                            	sModOn
00011EB9 EB                       M 	dc.b	$eb
00011EBA                            	saVol	$02
00011EBA ED02                     M 	dc.b	$ed,$02
00011EBC                            	sModOff
00011EBC EC                       M 	dc.b	$ec
00011EBD                            
00011EBD                            PeeloutCharge_Jump00:
00011EBD E7D1 02                    	dc.b	sHold, nAb6, $02
00011EC0                            	ssJump	PeeloutCharge_Jump00
00011EC0 F6                       M 	dc.b	$f6
00011EC1 FFFB                     M 	dc.w	peeloutcharge_jump00-*-1
00011EC4 00                         		even
00011EC4                            Snd_ChargeStop:
00011EC4                            		include	"Sound/sfx/Charge Stop.asm"
00011EC4                            PeeloutStop_Header:
00011EC4                            	sHeaderInit
00011EC4 =00011EC4                M spointzero	=	*
00011EC4 =00000000                M spatnum	=	0
00011EC4                            	sHeaderPrio	$60
00011EC4 60                       M 	dc.b	$60
00011EC5                            	sHeaderCh   $01
00011EC5 00                       M 	dc.b	$01-1
00011EC6                            
00011EC6                            	sHeaderSFX $80, $05, PeeloutStop_FM5,	$00, $00
00011EC6 8005                     M 	dc.b	$80,$05
00011EC8 0000                     M 	dc.w	peeloutstop_fm5-spointzero
00011ECA 0000                     M 	dc.b	$00,$00
00011ECC                            
00011ECC                            ; FM5 Data
00011ECC                            PeeloutStop_FM5:
00011ECC                            	sStop
00011ECC F5                       M 	dc.b	$f5
00011ECE 00                         		even
00011ECE                            Snd_ChargeRelease:
00011ECE                            		include	"Sound/sfx/Charge Release.asm"
00011ECE                            Peelout_Release_Header:
00011ECE                            	sHeaderInit
00011ECE =00011ECE                M spointzero	=	*
00011ECE =00000000                M spatnum	=	0
00011ECE                            	sHeaderPrio	$60
00011ECE 60                       M 	dc.b	$60
00011ECF                            	sHeaderCh	$02
00011ECF 01                       M 	dc.b	$02-1
00011ED0                            
00011ED0                            	sHeaderSFX	$80, $04, Peelout_Release_FM4, $00, $00
00011ED0 8004                     M 	dc.b	$80,$04
00011ED2 0000                     M 	dc.w	peelout_release_fm4-spointzero
00011ED4 0000                     M 	dc.b	$00,$00
00011ED6                            	sHeaderSFX	$80, $05, Peelout_Release_FM5, $00, $08
00011ED6 8005                     M 	dc.b	$80,$05
00011ED8 0000                     M 	dc.w	peelout_release_fm5-spointzero
00011EDA 0008                     M 	dc.b	$00,$08
00011EDC                            
00011EDC                            ; FM4 Data
00011EDC                            Peelout_Release_FM4:
00011EDC                            	sVoice		$0C
00011EDC E80C                     M 	dc.b	$e8,$0c
00011EDE                            	ssMod68k	$01, $01, $C5, $1A
00011EDE F001 01C5 1A             M 	dc.b	$f0,$01,$01,$c5,$1a
00011EE3 CD07                       	dc.b		nE6, $07
00011EE5                            	saVol		$09
00011EE5 ED09                     M 	dc.b	$ed,$09
00011EE7                            	sPan		spCenter, $00
00011EE7 E0C0                     M 	dc.b	$e0,spcenter|$00
00011EE9                            	sVoice		$0A
00011EE9 E80A                     M 	dc.b	$e8,$0a
00011EEB                            	ssMod68k	$03, $01, $09, $FF
00011EEB F003 0109 FF             M 	dc.b	$f0,$03,$01,$09,$ff
00011EF0 D625                       	dc.b		nCs7, $25
00011EF2                            	sModOff
00011EF2 EC                       M 	dc.b	$ec
00011EF3                            
00011EF3                            Peelout_Release_Loop00:
00011EF3 E7                         	dc.b		sHold
00011EF4                            	saVol		$01
00011EF4 ED01                     M 	dc.b	$ed,$01
00011EF6 DC02                       	dc.b		nG7, $02
00011EF8                            	sLoop		$00, $2A, Peelout_Release_Loop00
00011EF8 F700                     M 	dc.b	$f7,$00
00011EFA FFF8                     M 	dc.w	peelout_release_loop00-*-1
00011EFC 2A                       M 	dc.b	$2a
00011EFD                            	sStop
00011EFD F5                       M 	dc.b	$f5
00011EFE                            
00011EFE                            ; FM5 Data
00011EFE                            Peelout_Release_FM5:
00011EFE                            	sVoice		$0B
00011EFE E80B                     M 	dc.b	$e8,$0b
00011F00                            	ssMod68k	$01, $01, $20, $08
00011F00 F001 0120 08             M 	dc.b	$f0,$01,$01,$20,$08
00011F05 800A                       	dc.b		nRst, $0A
00011F07                            
00011F07                            Peelout_Release_Loop01:
00011F07 880F                       	dc.b		nG0, $0F
00011F09                            	sLoop		$00, $03, Peelout_Release_Loop01
00011F09 F700                     M 	dc.b	$f7,$00
00011F0B FFFB                     M 	dc.w	peelout_release_loop01-*-1
00011F0D 03                       M 	dc.b	$03
00011F0E                            
00011F0E                            Peelout_Release_Loop02:
00011F0E 880A                       	dc.b		nG0, $0A
00011F10                            	saVol		$05
00011F10 ED05                     M 	dc.b	$ed,$05
00011F12                            	sLoop		$00, $06, Peelout_Release_Loop02
00011F12 F700                     M 	dc.b	$f7,$00
00011F14 FFF9                     M 	dc.w	peelout_release_loop02-*-1
00011F16 06                       M 	dc.b	$06
00011F17                            	sStop
00011F17 F5                       M 	dc.b	$f5
00011F18                            		even
00011F18                            Snd_DiamondBreak:
00011F18                            		include	"Sound/sfx/Diamond Break.asm"
00011F18                            DiamondBreak_Header:
00011F18                            	sHeaderInit	
00011F18 =00011F18                M spointzero	=	*
00011F18 =00000000                M spatnum	=	0
00011F18                            	sHeaderPrio	$60
00011F18 60                       M 	dc.b	$60
00011F19                            	sHeaderCh	$01
00011F19 00                       M 	dc.b	$01-1
00011F1A                            	sHeaderSFX	$80, $05, DiamondBreak_FM5, $00, $07
00011F1A 8005                     M 	dc.b	$80,$05
00011F1C 0000                     M 	dc.w	diamondbreak_fm5-spointzero
00011F1E 0007                     M 	dc.b	$00,$07
00011F20                            
00011F20                            DiamondBreak_FM5:
00011F20                            	sVoice		$1E
00011F20 E81E                     M 	dc.b	$e8,$1e
00011F22 AE08                       	dc.b nA3, $08
00011F24                            	sStop	
00011F24 F5                       M 	dc.b	$f5
00011F26 00                         		even
00011F26                            
00011F26                            ; -------------------------------------------------------------------------
00011F26                            musaddr	include	"Sound/musicdata.asm"	; include all music
00011F26                            
00011F26                            
00011F26                            ; ------------------------------------------------------------------------
00011F26                            ; AMPS music data
00011F26                            ; -------------------------------------------------------------------------
00011F26                            
00011F26                            Mus_WWZ:
00011F26                            		include	"Sound/music/Wacky Workbench.asm"
00011F26                            ; Level music was replaced with a silent music track, since I did not create the music, 
00011F26                            ; nor do I currently have permission to share it.
00011F26                            
00011F26                            Mus_WWZ_Header:
00011F26                            	sHeaderInit
00011F26 =00011F26                M spointzero	=	*
00011F26 =00000000                M spatnum	=	0
00011F26                            	sHeaderTempo	$02, $33
00011F26 0133                     M 	dc.b	$02-1,$33
00011F28                            	sHeaderCh	$05, $03
00011F28 04                       M 	dc.b	$05-1
00011F29 02                       M 	dc.b	$03-1
00011F2A                            	sHeaderDAC	Mus_WWZ_DAC2
00011F2A 0000                     M 	dc.w	mus_wwz_dac2-spointzero
00011F2C 0000                     M 	dc.w	$00
00011F2E                            	sHeaderDAC	Mus_WWZ_DAC
00011F2E 0000                     M 	dc.w	mus_wwz_dac-spointzero
00011F30 0000                     M 	dc.w	$00
00011F32                            	sHeaderFM	Mus_WWZ_FM1, $00, $0A
00011F32 0000                     M 	dc.w	mus_wwz_fm1-spointzero
00011F34 000A                     M 	dc.b	$00,$0a
00011F36                            	sHeaderFM	Mus_WWZ_FM2, $00, $11
00011F36 0000                     M 	dc.w	mus_wwz_fm2-spointzero
00011F38 0011                     M 	dc.b	$00,$11
00011F3A                            	sHeaderFM	Mus_WWZ_FM3, $00, $10
00011F3A 0000                     M 	dc.w	mus_wwz_fm3-spointzero
00011F3C 0010                     M 	dc.b	$00,$10
00011F3E                            	sHeaderFM	Mus_WWZ_FM4, $00, $10
00011F3E 0000                     M 	dc.w	mus_wwz_fm4-spointzero
00011F40 0010                     M 	dc.b	$00,$10
00011F42                            	sHeaderFM	Mus_WWZ_FM5, $00, $0C
00011F42 0000                     M 	dc.w	mus_wwz_fm5-spointzero
00011F44 000C                     M 	dc.b	$00,$0c
00011F46                            	sHeaderPSG	Mus_WWZ_PSG1, $00, $20>>3, $00, v00
00011F46 0000                     M 	dc.w	mus_wwz_psg1-spointzero
00011F48 0004 0000                M 	dc.b	$00,$20>>3,$00,v00
00011F4C                            	sHeaderPSG	Mus_WWZ_PSG2, $00, $40>>3, $00, v00
00011F4C 0000                     M 	dc.w	mus_wwz_psg2-spointzero
00011F4E 0008 0000                M 	dc.b	$00,$40>>3,$00,v00
00011F52                            	sHeaderPSG	Mus_WWZ_PSG3, $00, $18>>3, $00, v00
00011F52 0000                     M 	dc.w	mus_wwz_psg3-spointzero
00011F54 0003 0000                M 	dc.b	$00,$18>>3,$00,v00
00011F58                            
00011F58                            Mus_WWZ_DAC:
00011F58                            Mus_WWZ_DAC2:
00011F58                            Mus_WWZ_FM1:
00011F58                            Mus_WWZ_FM2:
00011F58                            Mus_WWZ_FM3:
00011F58                            Mus_WWZ_FM4:
00011F58                            Mus_WWZ_FM5:
00011F58                            Mus_WWZ_PSG1:
00011F58                            Mus_WWZ_PSG2:
00011F58                            Mus_WWZ_PSG3:
00011F58                            	sStop
00011F58 F5                       M 	dc.b	$f5
00011F5A 00                         		even
00011F5A                            Mus_Boss:
00011F5A                            		include	"Sound/music/Boss.asm"
00011F5A                            Boss_Header:
00011F5A                            	sHeaderInit
00011F5A =00011F5A                M spointzero	=	*
00011F5A =00000000                M spatnum	=	0
00011F5A                            	sHeaderTempo	$01, $1D
00011F5A 001D                     M 	dc.b	$01-1,$1d
00011F5C                            	sHeaderCh	$05, $03
00011F5C 04                       M 	dc.b	$05-1
00011F5D 02                       M 	dc.b	$03-1
00011F5E                            
00011F5E                            	sHeaderDAC	Boss_DAC2
00011F5E 0000                     M 	dc.w	boss_dac2-spointzero
00011F60 0000                     M 	dc.w	$00
00011F62                            	sHeaderDAC	Boss_DAC
00011F62 0000                     M 	dc.w	boss_dac-spointzero
00011F64 0000                     M 	dc.w	$00
00011F66                            	sHeaderFM	Boss_FM1,	$0C, $0A
00011F66 0000                     M 	dc.w	boss_fm1-spointzero
00011F68 0C0A                     M 	dc.b	$0c,$0a
00011F6A                            	sHeaderFM	Boss_FM2,	$0C, $06
00011F6A 0000                     M 	dc.w	boss_fm2-spointzero
00011F6C 0C06                     M 	dc.b	$0c,$06
00011F6E                            	sHeaderFM	Boss_FM3,	$0C, $08
00011F6E 0000                     M 	dc.w	boss_fm3-spointzero
00011F70 0C08                     M 	dc.b	$0c,$08
00011F72                            	sHeaderFM	Boss_FM4,	$00, $0F
00011F72 0000                     M 	dc.w	boss_fm4-spointzero
00011F74 000F                     M 	dc.b	$00,$0f
00011F76                            	sHeaderFM	Boss_FM5,	$00, $0F
00011F76 0000                     M 	dc.w	boss_fm5-spointzero
00011F78 000F                     M 	dc.b	$00,$0f
00011F7A                            	sHeaderPSG	Boss_PSG1,	$E8-$0C, $04, $00, v0C
00011F7A 0000                     M 	dc.w	boss_psg1-spointzero
00011F7C DC04 000C                M 	dc.b	$e8-$0c,$04,$00,v0c
00011F80                            	sHeaderPSG	Boss_PSG2,	$E8-$0C, $06, $00, v0C
00011F80 0000                     M 	dc.w	boss_psg2-spointzero
00011F82 DC06 000C                M 	dc.b	$e8-$0c,$06,$00,v0c
00011F86                            	sHeaderPSG	Boss_PSG3,	$FE-$0C, $03, $00, v04
00011F86 0000                     M 	dc.w	boss_psg3-spointzero
00011F88 F203 0004                M 	dc.b	$fe-$0c,$03,$00,v04
00011F8C                            
00011F8C                            ; FM1 Data
00011F8C                            Boss_FM1:
00011F8C                            	sVoice        $56
00011F8C E856                     M 	dc.b	$e8,$56
00011F8E                            
00011F8E                            Boss_Jump01:
00011F8E                            	sNoteTimeOut        $08
00011F8E FD08                     M 	dc.b	$fd,$08
00011F90                            	sCall            Boss_Call02
00011F90 F8                       M 	dc.b	$f8
00011F91 0000                     M 	dc.w	boss_call02-*-1
00011F93                            	sNoteTimeOut        $0A
00011F93 FD0A                     M 	dc.b	$fd,$0a
00011F95                            
00011F95                            Boss_Loop0B:
00011F95 910C 9D                    	dc.b	nE1, $0C, nE2
00011F98                            	sLoop            $00, $04, Boss_Loop0B
00011F98 F700                     M 	dc.b	$f7,$00
00011F9A FFFA                     M 	dc.w	boss_loop0b-*-1
00011F9C 04                       M 	dc.b	$04
00011F9D                            	sNoteTimeOut        $08
00011F9D FD08                     M 	dc.b	$fd,$08
00011F9F                            	sCall            Boss_Call02
00011F9F F8                       M 	dc.b	$f8
00011FA0 0000                     M 	dc.w	boss_call02-*-1
00011FA2                            	sNoteTimeOut        $0A
00011FA2 FD0A                     M 	dc.b	$fd,$0a
00011FA4 910C 9D93 9F94 A095 A1     	dc.b	nE1, $0C, nE2, nFs1, nFs2, nG1, nG2, nAb1, nAb2
00011FAD                            
00011FAD                            Boss_Loop0C:
00011FAD                            	sCall            Boss_Call03
00011FAD F8                       M 	dc.b	$f8
00011FAE 0000                     M 	dc.w	boss_call03-*-1
00011FB0 940C A006 A094 0CA0 06A0   	dc.b	nG1, $0C, nG2, $06, nG2, nG1, $0C, nG2, $06, nG2
00011FBA                            	sCall            Boss_Call03
00011FBA F8                       M 	dc.b	$f8
00011FBB 0000                     M 	dc.w	boss_call03-*-1
00011FBD 910C 9D06 9D91 0C9D 069D   	dc.b	nE1, $0C, nE2, $06, nE2, nE1, $0C, nE2, $06, nE2
00011FC7                            	sLoop            $00, $04, Boss_Loop0C
00011FC7 F700                     M 	dc.b	$f7,$00
00011FC9 FFE3                     M 	dc.w	boss_loop0c-*-1
00011FCB 04                       M 	dc.b	$04
00011FCC                            	ssJump            Boss_Jump01
00011FCC F6                       M 	dc.b	$f6
00011FCD FFC0                     M 	dc.w	boss_jump01-*-1
00011FCF                            
00011FCF                            Boss_Call03:
00011FCF 960C A206 A296 0CA2 06A2+  	dc.b	nA1, $0C, nA2, $06, nA2, nA1, $0C, nA2, $06, nA2, nA1, $0C
00011FDB A206 A296 0CA2 06A2 940C+  	dc.b	nA2, $06, nA2, nA1, $0C, nA2, $06, nA2, nG1, $0C, nG2, $06
00011FE7 A094 0CA0 06A0             	dc.b	nG2, nG1, $0C, nG2, $06, nG2
00011FED                            	sRet
00011FED F9                       M 	dc.b	$f9
00011FEE                            
00011FEE                            Boss_Call02:
00011FEE 960C A2A2 96A2 A296 A2     	dc.b	nA1, $0C, nA2, nA2, nA1, nA2, nA2, nA1, nA2
00011FF7                            	sRet
00011FF7 F9                       M 	dc.b	$f9
00011FF8                            
00011FF8                            ; PSG1 Data
00011FF8                            Boss_PSG1:
00011FF8                            ; PSG2 Data
00011FF8                            Boss_PSG2:
00011FF8                            Boss_DAC2:
00011FF8                            	sStop
00011FF8 F5                       M 	dc.b	$f5
00011FF9                            
00011FF9                            ; FM2 Data
00011FF9                            Boss_FM2:
00011FF9                            	sVoice        $58
00011FF9 E858                     M 	dc.b	$e8,$58
00011FFB                            
00011FFB                            Boss_Loop09:
00011FFB                            	sNoteTimeOut        $08
00011FFB FD08                     M 	dc.b	$fd,$08
00011FFD AE0C A9A9 AEA9 A9AE A9     	dc.b	nA3, $0C, nE3, nE3, nA3, nE3, nE3, nA3, nE3
00012006                            	sNoteTimeOut        $17
00012006 FD17                     M 	dc.b	$fd,$17
00012008 B018 B0B0 B0               	dc.b	nB3, $18, nB3, nB3, nB3
0001200D                            	sLoop            $00, $02, Boss_Loop09
0001200D F700                     M 	dc.b	$f7,$00
0001200F FFEB                     M 	dc.w	boss_loop09-*-1
00012011 02                       M 	dc.b	$02
00012012                            	saTranspose      $F4
00012012 E4F4                     M 	dc.b	$e4,$f4
00012014                            	sVoice        $59
00012014 E859                     M 	dc.b	$e8,$59
00012016                            
00012016                            Boss_Loop0A:
00012016                            	sCall            Boss_Call01
00012016 F8                       M 	dc.b	$f8
00012017 0000                     M 	dc.w	boss_call01-*-1
00012019                            	sLoop            $00, $04, Boss_Loop0A
00012019 F700                     M 	dc.b	$f7,$00
0001201B FFFA                     M 	dc.w	boss_loop0a-*-1
0001201D 04                       M 	dc.b	$04
0001201E                            	saTranspose      $0C
0001201E E40C                     M 	dc.b	$e4,$0c
00012020                            	ssJump            Boss_FM2
00012020 F6                       M 	dc.b	$f6
00012021 FFD7                     M 	dc.w	boss_fm2-*-1
00012023                            
00012023                            Boss_Call01:
00012023 AE06 80B0 80B1 18B3 B1B0+  	dc.b	nA3, $06, nRst, nB3, nRst, nC4, $18, nD4, nC4, nB3, $06, nRst
0001202F B180 B080 AC18 A906 80AC+  	dc.b	nC4, nRst, nB3, nRst, nG3, $18, nE3, $06, nRst, nG3, $18, nA3
0001203B 0680 B080 B118 B3B1 B006+  	dc.b	$06, nRst, nB3, nRst, nC4, $18, nD4, nC4, nB3, $06, nRst, nC4
00012047 80B3 80B4 80B5 0C80 24     	dc.b	nRst, nD4, nRst, nEb4, nRst, nE4, $0C, nRst, $24
00012050                            	sRet
00012050 F9                       M 	dc.b	$f9
00012051                            
00012051                            ; FM3 Data
00012051                            Boss_FM3:
00012051                            	sVoice        $58
00012051 E858                     M 	dc.b	$e8,$58
00012053                            
00012053                            Boss_Loop06:
00012053                            	sNoteTimeOut        $08
00012053 FD08                     M 	dc.b	$fd,$08
00012055 B10C AEAE B1AE AEB1 AE     	dc.b	nC4, $0C, nA3, nA3, nC4, nA3, nA3, nC4, nA3
0001205E                            	sNoteTimeOut        $17
0001205E FD17                     M 	dc.b	$fd,$17
00012060 AD18 ADAD AD               	dc.b	nAb3, $18, nAb3, nAb3, nAb3
00012065                            	sLoop            $00, $02, Boss_Loop06
00012065 F700                     M 	dc.b	$f7,$00
00012067 FFEB                     M 	dc.w	boss_loop06-*-1
00012069 02                       M 	dc.b	$02
0001206A                            
0001206A                            Boss_Loop07:
0001206A 8030                       	dc.b	nRst, $30
0001206C                            	sLoop            $00, $10, Boss_Loop07
0001206C F700                     M 	dc.b	$f7,$00
0001206E FFFB                     M 	dc.w	boss_loop07-*-1
00012070 10                       M 	dc.b	$10
00012071                            	ssDetune       $03
00012071 E103                     M 	dc.b	$e1,$03
00012073                            	saVol        $FC
00012073 EDFC                     M 	dc.b	$ed,$fc
00012075                            
00012075                            Boss_Loop08:
00012075                            	sCall            Boss_Call01
00012075 F8                       M 	dc.b	$f8
00012076 FFAC                     M 	dc.w	boss_call01-*-1
00012078                            	sLoop            $00, $02, Boss_Loop08
00012078 F700                     M 	dc.b	$f7,$00
0001207A FFFA                     M 	dc.w	boss_loop08-*-1
0001207C 02                       M 	dc.b	$02
0001207D                            	ssDetune       $00
0001207D E100                     M 	dc.b	$e1,$00
0001207F                            	saVol        $04
0001207F ED04                     M 	dc.b	$ed,$04
00012081                            	ssJump            Boss_FM3
00012081 F6                       M 	dc.b	$f6
00012082 FFCE                     M 	dc.w	boss_fm3-*-1
00012084                            
00012084                            ; FM4 Data
00012084                            Boss_FM4:
00012084                            	sPan             spLeft, $00
00012084 E080                     M 	dc.b	$e0,spleft|$00
00012086                            	ssDetune       $02
00012086 E102                     M 	dc.b	$e1,$02
00012088                            	ssMod68k          $0C, $01, $04, $04
00012088 F00C 0104 04             M 	dc.b	$f0,$0c,$01,$04,$04
0001208D                            	ssJump            Boss_Jump00
0001208D F6                       M 	dc.b	$f6
0001208E 0000                     M 	dc.w	boss_jump00-*-1
00012090                            
00012090                            ; FM5 Data
00012090                            Boss_FM5:
00012090                            	sPan             spRight, $00
00012090 E040                     M 	dc.b	$e0,spright|$00
00012092                            	ssMod68k          $0C, $01, $FC, $04
00012092 F00C 01FC 04             M 	dc.b	$f0,$0c,$01,$fc,$04
00012097                            
00012097                            Boss_Jump00:
00012097                            	sModOff
00012097 EC                       M 	dc.b	$ec
00012098                            	sVoice        $57
00012098 E857                     M 	dc.b	$e8,$57
0001209A 8030 8024 BF06 C1C2 0CC2+  	dc.b	nRst, $30, nRst, $24, nD5, $06, nE5, nF5, $0C, nF5, nE5, nE5
000120A6 BFBF C180 8030 8024 BF06+  	dc.b	nD5, nD5, nE5, nRst, nRst, $30, nRst, $24, nD5, $06, nE5, nF5
000120B2 0CC1 C0C1 C518 C1          	dc.b	$0C, nE5, nEb5, nE5, nAb5, $18, nE5
000120B9                            
000120B9                            Boss_Loop05:
000120B9 8030 80                    	dc.b	nRst, $30, nRst
000120BC                            	sLoop            $00, $04, Boss_Loop05
000120BC F700                     M 	dc.b	$f7,$00
000120BE FFFA                     M 	dc.w	boss_loop05-*-1
000120C0 04                       M 	dc.b	$04
000120C1                            	sModOn
000120C1 EB                       M 	dc.b	$eb
000120C2                            	saVol        $02
000120C2 ED02                     M 	dc.b	$ed,$02
000120C4                            	sCall            Boss_Call00
000120C4 F8                       M 	dc.b	$f8
000120C5 0000                     M 	dc.w	boss_call00-*-1
000120C7 AC                         	dc.b	nG3
000120C8                            	sCall            Boss_Call00
000120C8 F8                       M 	dc.b	$f8
000120C9 0000                     M 	dc.w	boss_call00-*-1
000120CB ADBD E718 BF0C BDBC 30B8+  	dc.b	nAb3, nC5, sHold, $18, nD5, $0C, nC5, nB4, $30, nG4, nC5, sHold
000120D7 18BF 0CBD BC30 B9          	dc.b	$18, nD5, $0C, nC5, nB4, $30, nAb4
000120DE                            	saVol        $F5
000120DE EDF5                     M 	dc.b	$ed,$f5
000120E0                            	sVoice        $58
000120E0 E858                     M 	dc.b	$e8,$58
000120E2 BD06 80BF 80C1 18C2 C1BF+  	dc.b	nC5, $06, nRst, nD5, nRst, nE5, $18, nF5, nE5, nD5, $06, nRst
000120EE C180 BF80 BC18 B806 80BC+  	dc.b	nE5, nRst, nD5, nRst, nB4, $18, nG4, $06, nRst, nB4, $18, nC5
000120FA 0680 BF80 C118 C2C1 BF06+  	dc.b	$06, nRst, nD5, nRst, nE5, $18, nF5, nE5, nD5, $06, nRst, nE5
00012106 80C2 80C3 80C5 0C80 24     	dc.b	nRst, nF5, nRst, nFs5, nRst, nAb5, $0C, nRst, $24
0001210F                            	saVol        $09
0001210F ED09                     M 	dc.b	$ed,$09
00012111                            	ssJump            Boss_Jump00
00012111 F6                       M 	dc.b	$f6
00012112 FF84                     M 	dc.w	boss_jump00-*-1
00012114                            
00012114                            Boss_Call00:
00012114 B130 E718 B30C B1B0 30     	dc.b	nC4, $30, sHold, $18, nD4, $0C, nC4, nB3, $30
0001211D                            	sRet
0001211D F9                       M 	dc.b	$f9
0001211E                            
0001211E                            ; PSG3 Data
0001211E                            Boss_PSG3:
0001211E                            	sNoisePSG         $E7
0001211E F3E7                     M 	dc.b	$f3,$e7
00012120                            	sNoteTimeOut        $05
00012120 FD05                     M 	dc.b	$fd,$05
00012122                            
00012122                            Boss_Loop0D:
00012122 C624 2418 8030 80          	dc.b	nA5, $24, $24, $18, nRst, $30, nRst
00012129                            	sLoop            $00, $02, Boss_Loop0D
00012129 F700                     M 	dc.b	$f7,$00
0001212B FFF6                     M 	dc.w	boss_loop0d-*-1
0001212D 02                       M 	dc.b	$02
0001212E                            
0001212E                            Boss_Loop0E:
0001212E C618                       	dc.b	nA5, $18
00012130                            	sLoop            $00, $40, Boss_Loop0E
00012130 F700                     M 	dc.b	$f7,$00
00012132 FFFB                     M 	dc.w	boss_loop0e-*-1
00012134 40                       M 	dc.b	$40
00012135                            	ssJump            Boss_Loop0D
00012135 F6                       M 	dc.b	$f6
00012136 FFEB                     M 	dc.w	boss_loop0d-*-1
00012138                            
00012138                            ; DAC Data
00012138                            Boss_DAC:
00012138 830C 8383 8383 8383 8387+  	dc.b	dSnare, $0C, dSnare, dSnare, dSnare, dSnare, dSnare, dSnare, dSnare, dTomMid, $0C, dTomL
00012144 8789 8789 8789             	dc.b	dTomMid, dTomL, dTomMid, dTomL, dTomMid, dTomL
0001214A                            	sLoop            $00, $02, Boss_DAC
0001214A F700                     M 	dc.b	$f7,$00
0001214C FFEB                     M 	dc.w	boss_dac-*-1
0001214E 02                       M 	dc.b	$02
0001214F 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00012154                            
00012154                            Boss_Loop00:
00012154 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00012159                            	sLoop            $00, $06, Boss_Loop00
00012159 F700                     M 	dc.b	$f7,$00
0001215B FFF8                     M 	dc.w	boss_loop00-*-1
0001215D 06                       M 	dc.b	$06
0001215E 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
0001216A 8306 83                    	dc.b	dSnare, $06, dSnare
0001216D                            
0001216D                            Boss_Loop01:
0001216D 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00012172                            	sLoop            $00, $05, Boss_Loop01
00012172 F700                     M 	dc.b	$f7,$00
00012174 FFF8                     M 	dc.w	boss_loop01-*-1
00012176 05                       M 	dc.b	$05
00012177 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
00012183 8302 8704 8302 8704 890C+  	dc.b	dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C, dSnare, $06
0001218F 83                         	dc.b	dSnare
00012190                            	sLoop            $01, $03, Boss_Loop00
00012190 F701                     M 	dc.b	$f7,$01
00012192 FFC1                     M 	dc.w	boss_loop00-*-1
00012194 03                       M 	dc.b	$03
00012195                            
00012195                            Boss_Loop02:
00012195 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
0001219A                            	sLoop            $00, $06, Boss_Loop02
0001219A F700                     M 	dc.b	$f7,$00
0001219C FFF8                     M 	dc.w	boss_loop02-*-1
0001219E 06                       M 	dc.b	$06
0001219F 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
000121AB 8306 83                    	dc.b	dSnare, $06, dSnare
000121AE                            
000121AE                            Boss_Loop03:
000121AE 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
000121B3                            	sLoop            $00, $03, Boss_Loop03
000121B3 F700                     M 	dc.b	$f7,$00
000121B5 FFF8                     M 	dc.w	boss_loop03-*-1
000121B7 03                       M 	dc.b	$03
000121B8                            
000121B8                            Boss_Loop04:
000121B8 890C 8302 8704 8302 8704   	dc.b	dTomL, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04
000121C2                            	sLoop            $00, $04, Boss_Loop04
000121C2 F700                     M 	dc.b	$f7,$00
000121C4 FFF3                     M 	dc.w	boss_loop04-*-1
000121C6 04                       M 	dc.b	$04
000121C7                            	ssJump            Boss_DAC
000121C7 F6                       M 	dc.b	$f6
000121C8 FF6F                     M 	dc.w	boss_dac-*-1
000121CA                            		even
000121CA                            
000121CA                            ; -------------------------------------------------------------------------
000121CA                            musend
000121CA                            ; ===========================================================================
000121CA                            ; ---------------------------------------------------------------------------
000121CA                            ; Include samples and filters
000121CA                            ; ---------------------------------------------------------------------------
000121CA                            
000121CA                            		align	$8000		; must be aligned to bank...
000121CA                          M 	cnop	0,$8000
00018000                            fLog:		incbin "Sound/amps/filters/Logarithmic.dat"	; logarithmic filter (no filter)
00020000                            ;fLinear:	incbin "Sound/amps/filters/Linear.dat"	; linear filter (no filter)
00020000                            
00020000                            dacaddr		dcb.b	Z80E_Read*(MaxPitch/$100),$00
00020180                            SWF_Stop:	dcb.b	$8000-(2*Z80E_Read*(MaxPitch/$100)),$80
00027E80                            SWFR_Stop:	dcb.b	Z80E_Read*(MaxPitch/$100),$00
00028000                            
00028000                            	include	"Sound/dacdata.asm"
00028000                            
00028000                            
00028000                            ; ------------------------------------------------------------------------
00028000                            ; AMPS sample data
00028000                            ; -------------------------------------------------------------------------
00028000                            
00028000                            	incSWF	Kick,		"Sound/dac/incswf/Kick.swf"
00028000                          M swf_kick	incbin	"Sound/dac/incswf/Kick.swf"
00028E4A                          M swfr_kick	dcb.b	z80e_read*(maxpitch/$100),$00
00028FCA                            	incSWF	Snare,		"Sound/dac/incswf/Snare.swf"
00028FCA                          M swf_snare	incbin	"Sound/dac/incswf/Snare.swf"
0002B874                          M swfr_snare	dcb.b	z80e_read*(maxpitch/$100),$00
0002B9F4                            	incSWF	Tom,		"Sound/dac/incswf/Space Tom.swf"
0002B9F4                          M swf_tom	incbin	"Sound/dac/incswf/Space Tom.swf"
0002E288                          M swfr_tom	dcb.b	z80e_read*(maxpitch/$100),$00
0002E408                            	incSWF	Title,		"Sound/dac/incswf/Title.swf"
0002E408                          M swf_title	incbin	"Sound/dac/incswf/Title.swf"
00084EC7                          M swfr_title	dcb.b	z80e_read*(maxpitch/$100),$00
00085047                            	incSWF	Sega,		"Sound/dac/incswf/Sega.swf"
00085047                          M swf_sega	incbin	"Sound/dac/incswf/Sega.swf"
0008AC9D                          M swfr_sega	dcb.b	z80e_read*(maxpitch/$100),$00
0008AE1D                            	incSWF	Punch,		"Sound/dac/incswf/Punch.swf"
0008AE1D                          M swf_punch	incbin	"Sound/dac/incswf/Punch.swf"
0008D145                          M swfr_punch	dcb.b	z80e_read*(maxpitch/$100),$00
0008D2C5                            	incSWF	EndingSong,	"Sound/dac/incswf/EndingSong.swf"
0008D2C5                          M swf_endingsong	incbin	"Sound/dac/incswf/EndingSong.swf"
0009A6D8                          M swfr_endingsong	dcb.b	z80e_read*(maxpitch/$100),$00
0009A858                            	incSWF	BinBowie,	"Sound/dac/incswf/BinBowie.swf"
0009A858                          M swf_binbowie	incbin	"Sound/dac/incswf/BinBowie.swf"
000AF3FE                          M swfr_binbowie	dcb.b	z80e_read*(maxpitch/$100),$00
000AF57E                            	incSWF	Wacky_Base_Loud,"Sound/dac/incswf/Wacky_Base_Loud.swf"
000AF57E                          M swf_wacky_base_loud	incbin	"Sound/dac/incswf/Wacky_Base_Loud.swf"
000BB808                          M swfr_wacky_base_loud	dcb.b	z80e_read*(maxpitch/$100),$00
000BB988                            
000BB988                            ; -------------------------------------------------------------------------
000BB988                            	opt ae+				; enable automatic evens
000BB988                            	list				; continue source listing
000BB988                            ; ===========================================================================
000BB988                            DualPCM:
000BB988                            		z80prog	0
000BB988                          M 	pusho
000BB988                          M 	opt	ae-
000BB988                          M 	opt	an+
00000000                            		include	"Sound/amps/code/Z80.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DUAL-PCM - by MarkeyJester
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Read		macro
00000000                            		ldi					; 16	; copy from window to buffer, and increment register
00000000                            		zadd	a,b				; 04	; add dividend
00000000                            		adc	hl,sp				; 15	; add quotient
00000000                            		endm					; Total: 35
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_CapPCM	macro
00000000                            		jp	po, .ov\@			; 10	; if the sample hasn't overflown the 7F/80 boundary, branch
00000000                            		sbc	a,a				; 04	; erase sample, and subtract the carry to get either FF or 00, depending on overflow direction
00000000                            		xor	07Fh				; 07	; reverse FF/00 (xor 80 below helps)
00000000                            .ov\@		xor	080h				; 07	; convert to unsigned
00000000                            		endm					; Total: 17/28
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush01	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 2 to volume 1
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush02	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 1 to volume 2
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert01	macro
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert02	macro
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Wrap		macro
00000000                            		dec	l				; 04	; check l...
00000000                            		inc	l				; 04	; ''
00000000                            		M_WrapCondition
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_WrapCondition	macro
00000000                            		jp	nz, .c\@			; 10	; if it's not 0, branch
00000000                            		inc	h				; 04	; advance OUT buffers
00000000                            		bit	004h,h				; 08	; have the OUT buffer addresses reached 1000 (end of buffer) yet?
00000000                            		jp	z, .c\@				; 10	; if not, branch
00000000                            		ld	hl,PCM_Buffer2			; 10	; reset OUT buffers
00000000                            .c\@
00000000                            		endm
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start of Z80 ROM
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80_Start:
0000000B                            
0000000B 0000 0000 00               		align	MaxPitch/$100
00000010                            
00000010                            	; The space from "Start" until the maximum pitch amount, is the space
00000010                            	; where data could potentially be pushed into, thanks to the sp.
00000010                            
00000010                            	; The sp will likely be from roughly FFEF - 000F for the quotient of
00000010                            	; the pitch.  Now, FFEF - FFFF will be fine, since that points to the
00000010                            	; 68k window, which will be pointing to 68k ROM, so nothing will happen.
00000010                            	; But the address from 0000 - 000F points to the beginning of ROM, so
00000010                            	; this place must be free from use outside of V-blank.
00000010                            
00000010                            Z80_Stack:
00000010                            
00000010                            ; ===========================================================================
00000010                            ; ---------------------------------------------------------------------------
00000010                            ; PCM 1 Resetting
00000010                            ; ---------------------------------------------------------------------------
00000010                            		align	010h
00000010                            ; ---------------------------------------------------------------------------
00000010                            
00000010                            BreakLate:
00000019                            
00000019                            ; ===========================================================================
00000019                            ; ---------------------------------------------------------------------------
00000019                            ; PCM 1 Resetting
00000019                            ; ---------------------------------------------------------------------------
00000019 0000 0000 0000 0000 0000+  		align	028h
00000028                            ; ---------------------------------------------------------------------------
00000028                            
00000028                            PCM1_ResetJmp:
0000002B                            
0000002B                            ; ===========================================================================
0000002B                            ; ---------------------------------------------------------------------------
0000002B                            ; PCM 2 Resetting
0000002B                            ; ---------------------------------------------------------------------------
0000002B 0000 0000 00               		align	030h
00000030                            ; ---------------------------------------------------------------------------
00000030                            
00000030                            PCM2_ResetJmp:
00000033                            
00000033                            ; ===========================================================================
00000033                            ; ---------------------------------------------------------------------------
00000033                            ; Breaking out for V-blank
00000033                            ; ---------------------------------------------------------------------------
00000033 0000 0000 00               		align	038h
00000038                            ; ---------------------------------------------------------------------------
00000038                            
00000038                            BreakVBlank:
0000003C 2F                         		cpl					; 04	; change buffer
00000040                            
00000040                            BVB_Check:
00000046                            
00000046                            ; ---------------------------------------------------------------------------
00000046                            ; Breaking out for V-blank, during non-read
00000046                            ; ---------------------------------------------------------------------------
00000046                            
00000046                            BreakPrep:
00000061                            	;	ei					; 04	; enable interrupts
00000061 ED4D                       		reti					; 14	; return
00000063                            
00000063                            ; ===========================================================================
00000063                            ; ---------------------------------------------------------------------------
00000063                            ; Breaking out for V-blank, during read of window or bank register
00000063                            ; ---------------------------------------------------------------------------
00000063                            
00000063                            BreakDMA:
00000066                            
00000066                            	; --- Finding out which registers we're dealing with ---
00000066                            
00000074 1F                         BDMA_NoExchange:	rra					; 04	; get buffer we're currently reading from
00000083 D9                         BDMA_NoFixFlush:	exx					; 04	; swap to the "read" set of exx registers
00000084                            BDMA_ReadSet:
00000084                            
00000084                            ; ---------------------------------------------------------------------------
00000084                            ; Flush remaining data
00000084                            ; ---------------------------------------------------------------------------
00000084                            
00000084                            BreakBank:
00000084 D9                         			exx					; 04	; switch registers
00000086 D9                         			exx					; 04	; switch registers
00000087 ED44                       		zneg	a				; 08	; reverse position
00000090                            
00000090                            BDMA_NoMax:
0000009A                            
0000009A                            BDMA_FlushLoop:
0000009E                            
0000009E                            BDMA_Flush02:
0000009E D9                         			exx					; 04	; switch registers
000000B2 D9                         			exx					; 04	; switch registers
000000B7                            
000000B7                            BDMA_Flush01:
000000B7 D9                         			exx					; 04	; switch registers
000000CB D9                         			exx					; 04	; switch registers
000000D0                            
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            ; Wrapping OUT buffers
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            
000000D0 D9                         			exx					; 04	; switch registers
000000DF D9                         			exx					; 04	; switch back
000000E0                            
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            ; Restore interrupt instructions
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            
00000107                            
00000107                            BDMA_NoRestore:
00000107                            
00000107                            ; ---------------------------------------------------------------------------
00000107                            ; YM2612 flushing
00000107                            ; ---------------------------------------------------------------------------
00000107                            
0000010A                            
00000116                            
00000116                            YMF_Buff1:
0000011F D9                         			exx					; 04	; switch registers back
00000120                            
00000120                            YM_Flush:
00000123                            
00000123                            YMF_NextByte:
00000136 D9                         			exx					; 04	; switch registers
00000149 D9                         			exx					; 04	; switch registers
0000015D D9                         			exx					; 04	; switch registers
00000170 D9                         			exx					; 04	; switch registers
00000176                            
00000176                            	; --- Advance/Wrap OUT buffers ---
00000176                            
00000189                            
00000189                            YMF_Finish02:
00000192                            
00000192                            YMF_Finish01:
0000019B                            
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            ; Waiting for v-blank to finish
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            
0000019B                            PCM_Flush_exx:
0000019B D9                         			exx
0000019C                            
0000019C                            PCM_Flush:
0000019F                            
0000019F                            PCM_NextByte:
000001B2 D9                         			exx					; 04	; switch registers
000001B7                            
000001B7                            
000001B7 D9                         			exx					; 04	; switch registers
000001CB D9                         			exx					; 04	; switch registers
000001CC                            
000001D0                            
000001D0 D9                         			exx					; 04	; switch registers
000001D6                            
000001D6                            	; --- Advance/Wrap OUT buffers ---
000001D6                            
000001E4                            
000001E9 D9                         		exx					; 04	; switch registers down again...
000001EA                            
000001F6                            
000001F6                            YMF_SetBuff1:
000001F8                            
00000202                            
00000202                            VB_PCM1_VolOK:
0000020C                            
0000020C                            VB_PCM2_VolOK:
0000020C                            
0000020C 37                         		scf					; 04	; set carry flag
0000020D                            
00000222                            
00000222                            PCM_VolChangeNo:
00000222                            
00000222                            
0000022D                            
0000022D                            ; ===========================================================================
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            ; Setup/Init
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            
0000022D                            Z80_Init:
00000230                            
00000230                            	; --- YM2612 DAC Setup ---
00000230                            
0000023F                            
0000023F                            	; --- Setting up channels to be mute ---
0000023F                            
00000251                            
0000025A EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000261 EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000268 EDB0                       			ldir					; 21 16	; copy mute sample data over...
0000026F EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000271                            
00000271                            	; --- Setting up PCM 1 switch ---
00000271                            
0000027A                            
0000027A                            	; --- Setting up PCM 2 switch ---
0000027A                            
00000283                            
00000283                            	; --- Final register setup ---
00000283                            
0000028B                            
00000290                            
00000290 D9                         			exx					; 04	; switch registers
00000291                            
00000291                            ; ===========================================================================
00000291                            ; ---------------------------------------------------------------------------
00000291                            ; The catch up loop
00000291                            ; ---------------------------------------------------------------------------
00000291                            
00000291                            CatchUp:
00000291 D9                         			exx					; 04	; switch registers
00000292                            
00000292                            CatchUp_Exx:
000002A5 D9                         			exx					; 04	; switch registers
000002A6                            
000002A6                            Z80_Int2:	;ei
000002A6 00                         		znop					; 04
000002A7                            
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            ; PCM 1
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            
000002A7                            PCM1_MuteRet:
000002AC 00                         Int1_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
000002C8 D9                         			exx					; 04	; switch registers
000002DC D9                         			exx					; 04	; switch registers
000002E4                            
000002E4                            PCM1_PrepRet:
000002E4                            
000002F2                            
000002FC EDA0                       PCM1_PreInst03:	ldi					; 16	; copy from window to buffer, and increment register
000002FE D9                         			exx					; 04	; switch registers
00000313 D9                         			exx					; 04	; switch registers
0000032C D9                         			exx					; 04	; switch registers
00000341 D9                         			exx					; 04	; switch registers
00000357 EDA0                       PCM1_PreInst0C:	ldi					; 16	; copy from window to buffer, and increment register
00000359 D9                         			exx					; 04	; switch registers
0000036E D9                         			exx					; 04	; switch registers
00000387 D9                         			exx					; 04	; switch registers
0000039C D9                         			exx					; 04	; switch registers
000003B2 EDA0                       PCM1_PreInst15:	ldi					; 16	; copy from window to buffer, and increment register
000003B4 D9                         			exx					; 04	; switch registers
000003C9 D9                         			exx					; 04	; switch registers
000003E6 D9                         			exx					; 04	; switch registers
000003FB D9                         			exx					; 04	; switch registers
00000403                            
00000403                            ; ---------------------------------------------------------------------------
00000403                            ; PCM 2
00000403                            ; ---------------------------------------------------------------------------
00000403                            
00000403                            PCM2_MuteRet:
00000408 00                         Int2_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
0000041A D9                         			exx					; 04	; switch registers
0000042E D9                         			exx					; 04	; switch registers
00000440                            
00000440                            PCM2_PrepRet:
00000440                            
0000044E                            
00000453 D9                         			exx					; 04	; switch registers
00000468 D9                         			exx					; 04	; switch registers
0000047E EDA0                       PCM2_PreInst06:	ldi					; 16	; copy from window to buffer, and increment register
00000480 D9                         			exx					; 04	; switch registers
00000495 D9                         			exx					; 04	; switch registers
000004AE D9                         			exx					; 04	; switch registers
000004C3 D9                         			exx					; 04	; switch registers
000004D9 EDA0                       PCM2_PreInst0F:	ldi					; 16	; copy from window to buffer, and increment register
000004DB D9                         			exx					; 04	; switch registers
000004F0 D9                         			exx					; 04	; switch registers
00000509 D9                         			exx					; 04	; switch registers
0000051E D9                         			exx					; 04	; switch registers
00000534 EDA0                       PCM2_PreInst18:	ldi					; 16	; copy from window to buffer, and increment register
00000536 D9                         			exx					; 04	; switch registers
0000054B D9                         			exx					; 04	; switch registers
0000055F                            
00000570                            
00000570                            ; ---------------------------------------------------------------------------
00000570                            ; Wrapping OUT buffers
00000570                            ; ---------------------------------------------------------------------------
00000570                            
00000570 D9                         			exx					; 04	; switch registers
00000590 D9                         			exx					; 04	; switch back
00000591                            
00000591                            ; ---------------------------------------------------------------------------
00000591                            ; Wrap IN buffers
00000591                            ; ---------------------------------------------------------------------------
00000591                            
000005A3                            
000005A3                            PCM_BuffNoReset:
000005A3                            
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            ; Rebank...
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            
000005A3 37                         		scf					; 04	; set carry flag
000005BA 37                         		scf					; 04	; set carry flag
000005BB                            
000005BB                            PCM1_IgnoreBank:
000005D1 37                         		scf					; 04	; set carry flag
000005D2                            
000005D2                            PCM2_IgnoreBank:
000005D2                            
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            ; Pitch control
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            
000005DA                            
00000602 37                         		scf					; 04	; set carry flag
00000603                            
00000603                            PCM1_IgnorePitch:
00000603                            
0000060B                            
00000633 37                         		scf					; 04	; set carry flag
00000634                            
00000634                            PCM2_IgnorePitch:
00000634                            
00000634                            ; ---------------------------------------------------------------------------
00000634                            ; Updating Volume
00000634                            ; ---------------------------------------------------------------------------
00000634                            
0000064B                            	;	scf					; 04	; don't think it's necessary here...
0000064B                            
0000064E                            PCM_VolumeRet:
0000064E                            
0000064E                            
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            ; New samples...
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            
00000654                            
00000654                            ; ---------------------------------------------------------------------------
00000654                            ; Checking for "Flush" mode
00000654                            ; ---------------------------------------------------------------------------
00000654                            
00000654                            PCM_NoUpdate:
00000654 D9                         		exx					; 04	; switch registers
00000656 1F                         			rra					; 04	; get upper bit only into carry
00000658 1F                         			rra					; 04	; shift address down with carry
00000659 D9                         		exx					; 04	; switch registers
0000066A                            
0000066A                            CU_ValidDist:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; New sample playback
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F                            CU_Flush:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; Main "Flush" loop
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F D9                         			exx					; 04	; switch registers back
00000673                            
00000673                            FL_NextByte:
00000686 D9                         			exx					; 04	; switch registers
0000068C D9                         			exx					; 04	; switch registers
000006A0 D9                         			exx					; 04	; switch registers
000006A5 D9                         			exx					; 04	; switch registers
000006A6                            
000006AB                            
000006AB                            	; --- Advance/Wrap OUT buffers ---
000006AB                            
000006BC                            
000006BC                            ; ===========================================================================
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            ; When PCM sample 1 has reached an end marker & needs to loop back
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            
000006BC                            PCM1_Mute:
000006CE                            
000006CE                            PCM1_Normal:
000006D4                            
000006D4                            PCM1_Reverse:
000006E4 D9                         			exx					; 04	; switch registers
000006E9 D9                         			exx					; 04	; switch registers
000006ED                            
000006ED                            ; ===========================================================================
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            ; When PCM sample 1 address has reached the end of a window, just to play the last bit
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            
000006ED                            PCM1_PrepReset:
000006FC                            
000006FC                            PCM1_PrepCount:
00000715 D9                         			exx					; 04	; switch registers
00000729 D9                         			exx					; 04	; switch registers
00000731                            
00000731                            ; ===========================================================================
00000731                            ; ---------------------------------------------------------------------------
00000731                            ; When PCM sample 1 address has gone outside the window, and needs to reset
00000731                            ; ---------------------------------------------------------------------------
00000731                            
00000731                            PCM1_Reset:
0000074B                            
00000755                            
00000758                            
0000075A                            
0000075F                            
0000076B                            
00000771 0F                         		rrca					; 04
00000773 0F                         		rrca					; 04
00000775 0F                         		rrca					; 04
00000777 0F                         		rrca					; 04
00000779 0F                         		rrca					; 04
0000077B 0F                         		rrca					; 04
0000077D 0F                         		rrca					; 04
00000780                            
00000782                            
00000787                            
00000797                            
0000079A                            
0000079A                            ; ===========================================================================
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            ; 68K SET - routine to load a new sample 1
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            
0000079A                            PCM1_NewSample:
000007AA                            
000007AA                            PCM1_NewNormal:
000007B0                            
000007B0                            PCM1_NewReverse:
000007C0                            
000007C5 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000007C7                            
000007C7                            ; ===========================================================================
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            ; When PCM sample 2 has reached an end marker & needs to loop back
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            
000007C7                            PCM2_Mute:
000007D9                            
000007D9                            PCM2_Normal:
000007DF                            
000007DF                            PCM2_Reverse:
000007EF D9                         			exx					; 04	; switch registers
000007F4 D9                         			exx					; 04	; switch registers
000007F8                            
000007F8                            ; ===========================================================================
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            ; When PCM sample 2 address has reached the end of a window, just to play the last bit
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            
000007F8                            PCM2_PrepReset:
00000807                            
00000807                            PCM2_PrepCount:
00000827                            
00000827                            ; ===========================================================================
00000827                            ; ---------------------------------------------------------------------------
00000827                            ; When PCM sample 2 address has gone outside the window, and needs to reset
00000827                            ; ---------------------------------------------------------------------------
00000827                            
00000827                            PCM2_Reset:
00000841                            
0000084B                            
0000084E                            
00000850                            
00000855                            
00000861                            
00000867 0F                         		rrca					; 04
00000869 0F                         		rrca					; 04
0000086B 0F                         		rrca					; 04
0000086D 0F                         		rrca					; 04
0000086F 0F                         		rrca					; 04
00000871 0F                         		rrca					; 04
00000873 0F                         		rrca					; 04
00000876                            
00000878                            
0000087D                            
0000088D                            
00000890                            
00000890                            ; ===========================================================================
00000890                            ; ---------------------------------------------------------------------------
00000890                            ; 68K SET - routine to load a new sample 2
00000890                            ; ---------------------------------------------------------------------------
00000890                            
00000890                            PCM2_NewSample:
000008A0                            
000008A0                            PCM2_NewNormal:
000008A6                            
000008A6                            PCM2_NewReverse:
000008B6                            
000008BB 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000008BD                            
000008BD                            ; ===========================================================================
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            ; PCM volume Lists
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            		align	00200h
00000A00                            ; ---------------------------------------------------------------------------
00000A00                            
00000A00 0081 8283 8485 8687 8889+  PCM_Volume1:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000A10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000A20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000A30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000A40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000A50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000A60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000A70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000A80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000A90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000AA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000AB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000AC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000AD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000AE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000AF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000B00                            
00000B00 0081 8283 8485 8687 8889+  PCM_Volume2:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000B10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000B20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000B30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000B40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000B50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000B60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000B70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000B80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000B90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000BA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000BB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000BC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000BD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000BE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000BF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000C00                            
00000C00                            ; ===========================================================================
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            ; Bank interrupt preparation list
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            		align	00080h
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            
00000C00 F202                       PCM1_PrepTable:	dw	PCM1_PreInst01
00000C02 F702                       		dw	PCM1_PreInst02
00000C04 FC02                       		dw	PCM1_PreInst03
00000C06 1803                       		dw	PCM1_PreInst04
00000C08 1D03                       		dw	PCM1_PreInst05
00000C0A 2203                       		dw	PCM1_PreInst06
00000C0C 2703                       		dw	PCM1_PreInst07
00000C0E 4303                       		dw	PCM1_PreInst08
00000C10 4803                       		dw	PCM1_PreInst09
00000C12 4D03                       		dw	PCM1_PreInst0A
00000C14 5203                       		dw	PCM1_PreInst0B
00000C16 5703                       		dw	PCM1_PreInst0C
00000C18 7303                       		dw	PCM1_PreInst0D
00000C1A 7803                       		dw	PCM1_PreInst0E
00000C1C 7D03                       		dw	PCM1_PreInst0F
00000C1E 8203                       		dw	PCM1_PreInst10
00000C20 9E03                       		dw	PCM1_PreInst11
00000C22 A303                       		dw	PCM1_PreInst12
00000C24 A803                       		dw	PCM1_PreInst13
00000C26 AD03                       		dw	PCM1_PreInst14
00000C28 B203                       		dw	PCM1_PreInst15
00000C2A CE03                       		dw	PCM1_PreInst16
00000C2C D303                       		dw	PCM1_PreInst17
00000C2E D803                       		dw	PCM1_PreInst18
00000C30 4E04                       PCM2_PrepTable:	dw	PCM2_PreInst01
00000C32 6A04                       		dw	PCM2_PreInst02
00000C34 6F04                       		dw	PCM2_PreInst03
00000C36 7404                       		dw	PCM2_PreInst04
00000C38 7904                       		dw	PCM2_PreInst05
00000C3A 7E04                       		dw	PCM2_PreInst06
00000C3C 9A04                       		dw	PCM2_PreInst07
00000C3E 9F04                       		dw	PCM2_PreInst08
00000C40 A404                       		dw	PCM2_PreInst09
00000C42 A904                       		dw	PCM2_PreInst0A
00000C44 C504                       		dw	PCM2_PreInst0B
00000C46 CA04                       		dw	PCM2_PreInst0C
00000C48 CF04                       		dw	PCM2_PreInst0D
00000C4A D404                       		dw	PCM2_PreInst0E
00000C4C D904                       		dw	PCM2_PreInst0F
00000C4E F504                       		dw	PCM2_PreInst10
00000C50 FA04                       		dw	PCM2_PreInst11
00000C52 FF04                       		dw	PCM2_PreInst12
00000C54 0405                       		dw	PCM2_PreInst13
00000C56 2005                       		dw	PCM2_PreInst14
00000C58 2505                       		dw	PCM2_PreInst15
00000C5A 2A05                       		dw	PCM2_PreInst16
00000C5C 2F05                       		dw	PCM2_PreInst17
00000C5E 3405                       		dw	PCM2_PreInst18
00000C60                            
00000C60                            ; ===========================================================================
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            ; Specific variable data...
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            
00000C60                            	; --- Current bank address for PCM channels ---
00000C60                            
00000C60 00                         PCM1_BankCur:	db	000h					; The current bank address of PCM 1
00000C61 00                         PCM2_BankCur:	db	000h					; The current bank address of PCM 2
00000C62                            
00000C62                            	; --- "Mute Sample" pointer into 68k memory ---
00000C62                            
00000C62 0000                       MuteSample:	dw	00000h					; sample window address
00000C64 00                         MuteBank:	db	000h					; sample bank address
00000C65 0000                       MuteSample_Rev:	dw	00000h					; sample window address
00000C67 00                         MuteBank_Rev:	db	000h					; sample bank address
00000C68                            
00000C68                            	; --- YM2612 Pointers ---
00000C68                            
00000C68 00                         YM_Buffer:	db	000h					; 00 = Z80 Buffer 1 | 68k Buffer 2 ... FF = Z80 Buffer 2 | 68k Buffer 1
00000C69                            
00000C69                            ; ===========================================================================
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            ; Sample requested by 68k
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            
00000C69                            	; --- PCM 1 start sample ---
00000C69                            
00000C69 0000                       PCM1_Sample:		dw	00000h					; PCM 1 requested sample
00000C6B 00                         PCM1_Bank:		db	000h					; PCM 1 requested bank
00000C6C 0000                       PCM1_Sample_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C6E 00                         PCM1_Bank_Rev:		db	000h					; PCM 1 requested bank (reverse position)
00000C6F                            
00000C6F                            	; --- PCM 1 next sample ---
00000C6F                            
00000C6F 0000                       PCM1_SampleNext:	dw	00000h					; PCM 1 requested sample
00000C71 00                         PCM1_BankNext:		db	000h					; PCM 1 requested bank
00000C72 0000                       PCM1_SampleNext_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C74 00                         PCM1_BankNext_Rev:	db	000h					; PCM 1 requested bank (reverse position)
00000C75                            
00000C75                            	; --- PCM 2 start sample ---
00000C75                            
00000C75 0000                       PCM2_Sample:		dw	00000h					; PCM 2 requested sample
00000C77 00                         PCM2_Bank:		db	000h					; PCM 2 requested bank
00000C78 0000                       PCM2_Sample_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C7A 00                         PCM2_Bank_Rev:		db	000h					; PCM 2 requested bank (reverse position)
00000C7B                            
00000C7B                            	; --- PCM 2 next sample ---
00000C7B                            
00000C7B 0000                       PCM2_SampleNext:	dw	00000h					; PCM 2 requested sample
00000C7D 00                         PCM2_BankNext:		db	000h					; PCM 2 requested bank
00000C7E 0000                       PCM2_SampleNext_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C80 00                         PCM2_BankNext_Rev:	db	000h					; PCM 2 requested bank (reverse position)
00000C81                            
00000C81                            ; ===========================================================================
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            ; PCM buffer (1000h = start of cue, Make sure both buffers end in a multiple of 100)
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            
00000C81 0000 0000 0000 0000 0000+  		align	(01000h-00200h)-00150h
00000CB0                            PCM_Buffer1:	rept	00150h
00000CB0                            		db	080h
00000CB0 8080 8080 8080 8080 8080+  		endr
00000E00                            
00000E00 0000 0000 0000 0000 0000+  		align	01000h-00150h
00000EB0                            PCM_Buffer2:	rept	00150h
00000EB0                            		db	080h
00000EB0 8080 8080 8080 8080 8080+  		endr
00001000                            
00001000                            ; ===========================================================================
00001000                            ; ---------------------------------------------------------------------------
00001000                            ; The YM2612 operator writing lists (68k writes here, z80 must flush off)
00001000                            ; ---------------------------------------------------------------------------
00001000                            
00001000                            YM_Buffer1:	rept	00400h
00001000                            		db	0FFh
00001000 FFFF FFFF FFFF FFFF FFFF+  		endr
00001400                            
00001400                            YM_Buffer2:	rept	00400h
00001400                            		db	0FFh
00001400 FFFF FFFF FFFF FFFF FFFF+  		endr
00001800                            
00001800                            ; ===========================================================================
00001800                            ; ---------------------------------------------------------------------------
00001800                            ; Overflow calculation multiplication tables
00001800                            ; ---------------------------------------------------------------------------
00001800                            
00001800                            PCM_OverflwCalc:
00001800                            
00001800                            		; --- Lower byte ---
00001800                            
00001800 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001810 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001820 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001830 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001840 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001850 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001860 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001870 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001880 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001890 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018A0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018B0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018C0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018D0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018E0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018F0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001900                            
00001900                            		; --- Upper byte ---
00001900                            
00001900 0000 0000 0000 0000 0000+  		db	000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,001h,001h,001h,001h,001h
00001910 0101 0101 0101 0202 0202+  		db	001h,001h,001h,001h,001h,001h,002h,002h,002h,002h,002h,002h,002h,002h,002h,002h
00001920 0303 0303 0303 0303 0303+  		db	003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,004h,004h,004h,004h,004h
00001930 0404 0404 0404 0505 0505+  		db	004h,004h,004h,004h,004h,004h,005h,005h,005h,005h,005h,005h,005h,005h,005h,005h
00001940 0606 0606 0606 0606 0606+  		db	006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,007h,007h,007h,007h,007h
00001950 0707 0707 0707 0808 0808+  		db	007h,007h,007h,007h,007h,007h,008h,008h,008h,008h,008h,008h,008h,008h,008h,008h
00001960 0909 0909 0909 0909 0909+  		db	009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,00Ah,00Ah,00Ah,00Ah,00Ah
00001970 0A0A 0A0A 0A0A 0B0B 0B0B+  		db	00Ah,00Ah,00Ah,00Ah,00Ah,00Ah,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh
00001980 0C0C 0C0C 0C0C 0C0C 0C0C+  		db	00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Dh,00Dh,00Dh,00Dh,00Dh
00001990 0D0D 0D0D 0D0D 0E0E 0E0E+  		db	00Dh,00Dh,00Dh,00Dh,00Dh,00Dh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh
000019A0 0F0F 0F0F 0F0F 0F0F 0F0F+  		db	00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,010h,010h,010h,010h,010h
000019B0 1010 1010 1010 1111 1111+  		db	010h,010h,010h,010h,010h,010h,011h,011h,011h,011h,011h,011h,011h,011h,011h,011h
000019C0 1212 1212 1212 1212 1212+  		db	012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,013h,013h,013h,013h,013h
000019D0 1313 1313 1313 1414 1414+  		db	013h,013h,013h,013h,013h,013h,014h,014h,014h,014h,014h,014h,014h,014h,014h,014h
000019E0 1515 1515 1515 1515 1515+  		db	015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,016h,016h,016h,016h,016h
000019F0 1616 1616 1616 1717 1717+  		db	016h,016h,016h,016h,016h,016h,017h,017h,017h,017h,017h,017h,017h,017h,017h,017h
00001A00                            
00001A00                            ; ===========================================================================
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            ; Subroutine to change a channel's volume table
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            
00001A00                            PCM_VolumeControl:
00001A06                            
00001A1B                            
00001A1B                            PCM1_NoVolume:
00001A1B                            
00001A30                            
00001A30                            PCM2_NoVolume:
00001A31 37                         		scf					; 04	; set carry flag
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; The volume changing itself
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            SwitchVolume:
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; Software version of volume table (This is slower to process but will save
00001A35                            ; 8000 bytes of ROM space).  It'll also cause chopping in the sample playback
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            ;		ld	b,a				; 04	; store volume
00001A35                            ;		zneg					; 08	; convert volume to 00 - 80 (mute - loud)
00001A35                            ;		zadd	a,080h				; 07	; ''
00001A35                            ;		zadd	a,a				; 04	; shift MSB into carry
00001A35                            ;		ld	(SV_fraction+001h),a		; 13	; store fraction
00001A35                            ;		sbc	a,a				; 04	; get only the carry (for quotient)
00001A35                            ;		zneg					; 08	; ''
00001A35                            ;		ld	c,a				; 04	; store quotient in c
00001A35                            ;		ld	hl,00000h			; 10	; reset current fraction/dividend
00001A35                            ;		ld	a,b				; 04	; reload volume
00001A35                            ;		zadd	a,080h				; 07	; rotate starting volume
00001A35                            ;SV_fraction:	ld	b,000h				; 07	; set fraction/dividend
00001A35                            ;
00001A35                            ;SV_SetNormal:
00001A35                            ;		ld	(de),a				; 07	; save to table
00001A35                            ;		zadd	hl,bc 				; 11	; add fraction/dividend
00001A35                            ;		adc	a,c				; 04	; add carry to quotient
00001A35                            ;		inc	e				; 04	; advance table
00001A35                            ;		jp	nz,SV_SetNormal			; 10	; repeat until the table is finished (should reach 100)
00001A35                            ;
00001A35                            ;SV_Return:	jp	00000h				; 10	; return
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A46                            
00001A46                            	; --- Non-flush version ---
00001A46                            
00001A55                            
00001A55                            SV_NoMute:
00001A5A                            
00001A5A                            SV_LoadVolume:
00001A5A                            		rept	008h
00001A5A                            		ldi					; 16	; copy volume bytes over
00001A5A EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001A6E                            
00001A6E                            	; --- Flush version ---
00001A6E                            
00001A6E                            SV_Flush:
00001A79 D9                         			exx					; 04	; switch registers
00001A8D D9                         			exx					; 04	; switch registers
00001A91                            
00001A91                            SVF_NoMute:
00001A96                            
00001A96                            SVF_LoadVolume:
00001A96 D9                         			exx					; 04	; switch registers
00001AAA D9                         			exx					; 04	; switch registers
00001AAB                            
00001AAB                            SVF_StartVolume:
00001AAB                            		rept	008h
00001AAB                            		ldi					; 16	; copy volume bytes over
00001AAB EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001ABB D9                         			exx					; 04	; switch registers
00001ACF D9                         			exx					; 04	; switch registers
00001AD0                            		rept	008h
00001AD0                            		ldi					; 16	; copy volume bytes over
00001AD0 EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001AE2 D9                         			exx					; 04	; switch registers
00001AF1 D9                         			exx					; 04	; switch registers
00001AFC                            
00001AFC                            ; ===========================================================================
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ; Switching a channel's bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	hl,PCM1_BankCur			; 10	; address of bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		ld	a,(PCM1_PitchQuo+001h)		; 13	; load pitch quotient
00001AFC                            ;		call	SwitchBank			; 17	; change the bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	a,(PCM1_BankCur)		; 13	; load bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		call	SetBank				; 17	; set bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            
00001AFC                            SwitchBank:
00001B03                            
00001B03                            SetBank:
00001B06                            	rept	008h
00001B06                            		xor	a				; 04	; clear a
00001B06                            		rrc	l				; 08	; shift bit into carry
00001B06                            		adc	a,h				; 04	; set instruction bits (with carry register bit)
00001B06                            		ld	(de),a				; 07	; write instruction
00001B06                            		inc	e	; WARNING (see comment)	; 04	; advance to next instruction (ONLY WORKS IF THE INSTRUCTIONS DON'T CROSS A 100 BYTE BOUNDARY, please align)
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            ; Warning stuff
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            
00001B37                            
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ===========================================================================
00001B37                            DualPCM_sz:
000BD4BF =00000000                M z80prg	=	0
000BD4BF                          M 	mexit
000BD4BF                            
000BD4BF                            ; =========================================================================================================================================================
000BD4BF                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000BD4BF                            ; Error handler
000BD4BF                            ; -------------------------------------------------------------------------------------------------------------------------------------------------------
000BD4BF                            		include	"Config/Error/error.asm"
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Vladikcomper's debugger
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Error handler control flags
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            ; Screen appearence flags
000BD4BF =00000001                  _eh_address_error	equ	$01	; use for address and bus errors only (tells error handler to display additional "Address" field)
000BD4BF =00000002                  _eh_show_sr_usp		equ	$02	; displays SR and USP registers content on error screen
000BD4BF                            
000BD4BF                            ; Advanced execution flags
000BD4BF                            ; WARNING! For experts only, DO NOT USES them unless you know what you're doing
000BD4BF =00000020                  _eh_return		equ	$20
000BD4BF =00000040                  _eh_enter_console	equ	$40
000BD4BF =00000080                  _eh_align_offset	equ	$80
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Errors vector table
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            ; Default screen configuration
000BD4BF =00000000                  _eh_default		equ	0	;_eh_show_sr_usp
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            exBus:
000BD4BF                            	__ErrorMessage "BUS ERROR", _eh_default|_eh_address_error
000BD4BF                          M 	__fstring_generateargumentscode	"BUS ERROR"
000BD4BF =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
000BD4BF =00000000                M 	__stack:set	0
000BD4BF =00000000                M 	__sp:	set 0
000BD4BF                          M 	while	(__pos)
000BD4BF                          M 	rept	__stack
000BD4C0 004E B900 0000 00        M 	jsr	errorhandler
000BD4C6                          M 	__fstring_generatedecodedstring	"BUS ERROR"
000BD4C6 =00000001                M 	__lpos:	set 1
000BD4C6 =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
000BD4C6                          M 	while	(__pos)
000BD4C6                          M 	__substr:	substr __lpos,,"BUS ERROR"
000BD4C6 4255 5320 4552 524F 52   M 	dc.b	"BUS ERROR"
000BD4CF 00                       M 	dc.b	0
000BD4D0 01                       M 	dc.b	_eh_default|_eh_address_error+0
000BD4D2 00                       M 	even
000BD4D2                            
000BD4D2                            exAddr:
000BD4D2                            	__ErrorMessage "ADDRESS ERROR", _eh_default|_eh_address_error
000BD4D2                          M 	__fstring_generateargumentscode	"ADDRESS ERROR"
000BD4D2 =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
000BD4D2 =00000000                M 	__stack:set	0
000BD4D2 =00000000                M 	__sp:	set 0
000BD4D2                          M 	while	(__pos)
000BD4D2                          M 	rept	__stack
000BD4D2 4EB9 0000 0000           M 	jsr	errorhandler
000BD4D8                          M 	__fstring_generatedecodedstring	"ADDRESS ERROR"
000BD4D8 =00000001                M 	__lpos:	set 1
000BD4D8 =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
000BD4D8                          M 	while	(__pos)
000BD4D8                          M 	__substr:	substr __lpos,,"ADDRESS ERROR"
000BD4D8 4144 4452 4553 5320 4552+M 	dc.b	"ADDRESS ERROR"
000BD4E5 00                       M 	dc.b	0
000BD4E6 01                       M 	dc.b	_eh_default|_eh_address_error+0
000BD4E8 00                       M 	even
000BD4E8                            
000BD4E8                            exIll:
000BD4E8                            	__ErrorMessage "ILLEGAL INSTRUCTION", _eh_default
000BD4E8                          M 	__fstring_generateargumentscode	"ILLEGAL INSTRUCTION"
000BD4E8 =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
000BD4E8 =00000000                M 	__stack:set	0
000BD4E8 =00000000                M 	__sp:	set 0
000BD4E8                          M 	while	(__pos)
000BD4E8                          M 	rept	__stack
000BD4E8 4EB9 0000 0000           M 	jsr	errorhandler
000BD4EE                          M 	__fstring_generatedecodedstring	"ILLEGAL INSTRUCTION"
000BD4EE =00000001                M 	__lpos:	set 1
000BD4EE =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
000BD4EE                          M 	while	(__pos)
000BD4EE                          M 	__substr:	substr __lpos,,"ILLEGAL INSTRUCTION"
000BD4EE 494C 4C45 4741 4C20 494E+M 	dc.b	"ILLEGAL INSTRUCTION"
000BD501 00                       M 	dc.b	0
000BD502 00                       M 	dc.b	_eh_default+0
000BD504 00                       M 	even
000BD504                            
000BD504                            exDiv:
000BD504                            	__ErrorMessage "ZERO DIVIDE", _eh_default
000BD504                          M 	__fstring_generateargumentscode	"ZERO DIVIDE"
000BD504 =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000BD504 =00000000                M 	__stack:set	0
000BD504 =00000000                M 	__sp:	set 0
000BD504                          M 	while	(__pos)
000BD504                          M 	rept	__stack
000BD504 4EB9 0000 0000           M 	jsr	errorhandler
000BD50A                          M 	__fstring_generatedecodedstring	"ZERO DIVIDE"
000BD50A =00000001                M 	__lpos:	set 1
000BD50A =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000BD50A                          M 	while	(__pos)
000BD50A                          M 	__substr:	substr __lpos,,"ZERO DIVIDE"
000BD50A 5A45 524F 2044 4956 4944+M 	dc.b	"ZERO DIVIDE"
000BD515 00                       M 	dc.b	0
000BD516 00                       M 	dc.b	_eh_default+0
000BD518 00                       M 	even
000BD518                            
000BD518                            exChk:
000BD518                            	__ErrorMessage "CHK INSTRUCTION", _eh_default
000BD518                          M 	__fstring_generateargumentscode	"CHK INSTRUCTION"
000BD518 =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000BD518 =00000000                M 	__stack:set	0
000BD518 =00000000                M 	__sp:	set 0
000BD518                          M 	while	(__pos)
000BD518                          M 	rept	__stack
000BD518 4EB9 0000 0000           M 	jsr	errorhandler
000BD51E                          M 	__fstring_generatedecodedstring	"CHK INSTRUCTION"
000BD51E =00000001                M 	__lpos:	set 1
000BD51E =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000BD51E                          M 	while	(__pos)
000BD51E                          M 	__substr:	substr __lpos,,"CHK INSTRUCTION"
000BD51E 4348 4B20 494E 5354 5255+M 	dc.b	"CHK INSTRUCTION"
000BD52D 00                       M 	dc.b	0
000BD52E 00                       M 	dc.b	_eh_default+0
000BD530 00                       M 	even
000BD530                            
000BD530                            Trapv:
000BD530                            	__ErrorMessage "TRAPV INSTRUCTION", _eh_default
000BD530                          M 	__fstring_generateargumentscode	"TRAPV INSTRUCTION"
000BD530 =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000BD530 =00000000                M 	__stack:set	0
000BD530 =00000000                M 	__sp:	set 0
000BD530                          M 	while	(__pos)
000BD530                          M 	rept	__stack
000BD530 4EB9 0000 0000           M 	jsr	errorhandler
000BD536                          M 	__fstring_generatedecodedstring	"TRAPV INSTRUCTION"
000BD536 =00000001                M 	__lpos:	set 1
000BD536 =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000BD536                          M 	while	(__pos)
000BD536                          M 	__substr:	substr __lpos,,"TRAPV INSTRUCTION"
000BD536 5452 4150 5620 494E 5354+M 	dc.b	"TRAPV INSTRUCTION"
000BD547 00                       M 	dc.b	0
000BD548 00                       M 	dc.b	_eh_default+0
000BD54A 00                       M 	even
000BD54A                            
000BD54A                            exPriv:
000BD54A                            	__ErrorMessage "PRIVILEGE VIOLATION", _eh_default
000BD54A                          M 	__fstring_generateargumentscode	"PRIVILEGE VIOLATION"
000BD54A =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000BD54A =00000000                M 	__stack:set	0
000BD54A =00000000                M 	__sp:	set 0
000BD54A                          M 	while	(__pos)
000BD54A                          M 	rept	__stack
000BD54A 4EB9 0000 0000           M 	jsr	errorhandler
000BD550                          M 	__fstring_generatedecodedstring	"PRIVILEGE VIOLATION"
000BD550 =00000001                M 	__lpos:	set 1
000BD550 =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000BD550                          M 	while	(__pos)
000BD550                          M 	__substr:	substr __lpos,,"PRIVILEGE VIOLATION"
000BD550 5052 4956 494C 4547 4520+M 	dc.b	"PRIVILEGE VIOLATION"
000BD563 00                       M 	dc.b	0
000BD564 00                       M 	dc.b	_eh_default+0
000BD566 00                       M 	even
000BD566                            
000BD566                            exTrace:
000BD566                            	__ErrorMessage "TRACE", _eh_default
000BD566                          M 	__fstring_generateargumentscode	"TRACE"
000BD566 =00000000                M 	__pos:	set instr("TRACE",'%<')
000BD566 =00000000                M 	__stack:set	0
000BD566 =00000000                M 	__sp:	set 0
000BD566                          M 	while	(__pos)
000BD566                          M 	rept	__stack
000BD566 4EB9 0000 0000           M 	jsr	errorhandler
000BD56C                          M 	__fstring_generatedecodedstring	"TRACE"
000BD56C =00000001                M 	__lpos:	set 1
000BD56C =00000000                M 	__pos:	set instr("TRACE",'%<')
000BD56C                          M 	while	(__pos)
000BD56C                          M 	__substr:	substr __lpos,,"TRACE"
000BD56C 5452 4143 45             M 	dc.b	"TRACE"
000BD571 00                       M 	dc.b	0
000BD572 00                       M 	dc.b	_eh_default+0
000BD574 00                       M 	even
000BD574                            
000BD574                            exLineA:
000BD574                            	__ErrorMessage "LINE A EMULATOR", _eh_default
000BD574                          M 	__fstring_generateargumentscode	"LINE A EMULATOR"
000BD574 =00000000                M 	__pos:	set instr("LINE A EMULATOR",'%<')
000BD574 =00000000                M 	__stack:set	0
000BD574 =00000000                M 	__sp:	set 0
000BD574                          M 	while	(__pos)
000BD574                          M 	rept	__stack
000BD574 4EB9 0000 0000           M 	jsr	errorhandler
000BD57A                          M 	__fstring_generatedecodedstring	"LINE A EMULATOR"
000BD57A =00000001                M 	__lpos:	set 1
000BD57A =00000000                M 	__pos:	set instr("LINE A EMULATOR",'%<')
000BD57A                          M 	while	(__pos)
000BD57A                          M 	__substr:	substr __lpos,,"LINE A EMULATOR"
000BD57A 4C49 4E45 2041 2045 4D55+M 	dc.b	"LINE A EMULATOR"
000BD589 00                       M 	dc.b	0
000BD58A 00                       M 	dc.b	_eh_default+0
000BD58C 00                       M 	even
000BD58C                            
000BD58C                            exLineF:
000BD58C                            	__ErrorMessage "LINE F EMULATOR", _eh_default
000BD58C                          M 	__fstring_generateargumentscode	"LINE F EMULATOR"
000BD58C =00000000                M 	__pos:	set instr("LINE F EMULATOR",'%<')
000BD58C =00000000                M 	__stack:set	0
000BD58C =00000000                M 	__sp:	set 0
000BD58C                          M 	while	(__pos)
000BD58C                          M 	rept	__stack
000BD58C 4EB9 0000 0000           M 	jsr	errorhandler
000BD592                          M 	__fstring_generatedecodedstring	"LINE F EMULATOR"
000BD592 =00000001                M 	__lpos:	set 1
000BD592 =00000000                M 	__pos:	set instr("LINE F EMULATOR",'%<')
000BD592                          M 	while	(__pos)
000BD592                          M 	__substr:	substr __lpos,,"LINE F EMULATOR"
000BD592 4C49 4E45 2046 2045 4D55+M 	dc.b	"LINE F EMULATOR"
000BD5A1 00                       M 	dc.b	0
000BD5A2 00                       M 	dc.b	_eh_default+0
000BD5A4 00                       M 	even
000BD5A4                            
000BD5A4                            exMisc:
000BD5A4                            	__ErrorMessage "MISC EXCEPTION", _eh_default
000BD5A4                          M 	__fstring_generateargumentscode	"MISC EXCEPTION"
000BD5A4 =00000000                M 	__pos:	set instr("MISC EXCEPTION",'%<')
000BD5A4 =00000000                M 	__stack:set	0
000BD5A4 =00000000                M 	__sp:	set 0
000BD5A4                          M 	while	(__pos)
000BD5A4                          M 	rept	__stack
000BD5A4 4EB9 0000 0000           M 	jsr	errorhandler
000BD5AA                          M 	__fstring_generatedecodedstring	"MISC EXCEPTION"
000BD5AA =00000001                M 	__lpos:	set 1
000BD5AA =00000000                M 	__pos:	set instr("MISC EXCEPTION",'%<')
000BD5AA                          M 	while	(__pos)
000BD5AA                          M 	__substr:	substr __lpos,,"MISC EXCEPTION"
000BD5AA 4D49 5343 2045 5843 4550+M 	dc.b	"MISC EXCEPTION"
000BD5B8 00                       M 	dc.b	0
000BD5B9 00                       M 	dc.b	_eh_default+0
000BD5BA                          M 	even
000BD5BA                            
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            ; Import error handler global functions
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            
000BD5BA                            ErrorHandler.__global__error_initconsole		equ	ErrorHandler+$146
000BD5BA                            ErrorHandler.__global__errorhandler_setupvdp		equ	ErrorHandler+$234
000BD5BA                            ErrorHandler.__global__console_loadpalette		equ	ErrorHandler+$A1C
000BD5BA                            ErrorHandler.__global__console_setposasxy_stack		equ	ErrorHandler+$A58
000BD5BA                            ErrorHandler.__global__console_setposasxy		equ	ErrorHandler+$A5E
000BD5BA                            ErrorHandler.__global__console_getposasxy		equ	ErrorHandler+$A8A
000BD5BA                            ErrorHandler.__global__console_startnewline		equ	ErrorHandler+$AAC
000BD5BA                            ErrorHandler.__global__console_setbasepattern		equ	ErrorHandler+$AD4
000BD5BA                            ErrorHandler.__global__console_setwidth			equ	ErrorHandler+$AE8
000BD5BA                            ErrorHandler.__global__console_writeline_withpattern	equ	ErrorHandler+$AFE
000BD5BA                            ErrorHandler.__global__console_writeline		equ	ErrorHandler+$B00
000BD5BA                            ErrorHandler.__global__console_write			equ	ErrorHandler+$B04
000BD5BA                            ErrorHandler.__global__console_writeline_formatted	equ	ErrorHandler+$BB0
000BD5BA                            ErrorHandler.__global__console_write_formatted		equ	ErrorHandler+$BB4
000BD5BA                            
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            ; Error handler external functions (compiled only when used)
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            
000BD5BA                            
000BD5BA                            ErrorHandler.__extern__console_only:
000BD5BA 46FC 2700 4FEF FFF2 48E7+  	dc.l	$46FC2700, $4FEFFFF2, $48E7FFFE, $47EF003C
000BD5CA 4EBA 0000                  	jsr		ErrorHandler.__global__errorhandler_setupvdp(pc)
000BD5CE 4EBA 0000                  	jsr		ErrorHandler.__global__error_initconsole(pc)
000BD5D2 4CDF 7FFF 487A 0008 2F2F+  	dc.l	$4CDF7FFF, $487A0008, $2F2F0012, $4E7560FE
000BD5E2                            
000BD5E2                            
000BD5E2                            ; -------------------------------------------------------------------------
000BD5E2                            ; Include error handler binary module
000BD5E2                            ; -------------------------------------------------------------------------
000BD5E2                            
000BD5E2                            ErrorHandler:
000BD5E2                            	incbin	"Config/Error/ErrorHandler.bin"
000BEFF6                            
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            ; WARNING!
000BEFF6                            ;	DO NOT put any data from now on! DO NOT use ROM padding!
000BEFF6                            ;	Symbol data should be appended here after ROM is compiled
000BEFF6                            ;	by ConvSym utility, otherwise debugger modules won't be able
000BEFF6                            ;	to resolve symbol names.
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            
000BEFF6                            
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            ; =========================================================================================================================================================
